- en: Capitolo 8\. Autenticazione e autorizzazione
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Questo lavoro è stato tradotto utilizzando l''AI. Siamo lieti di ricevere il
    tuo feedback e i tuoi commenti: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)'
  prefs: []
  type: TYPE_NORMAL
- en: Finora hai costruito servizi GenAI in grado di interagire con i database, di
    trasmettere le risposte dei modelli e di gestire utenti simultanei.
  prefs: []
  type: TYPE_NORMAL
- en: I tuoi servizi sono ora attivi e funzionanti, ma poiché non sono protetti da
    aggressori o utenti malintenzionati, la loro distribuzione in produzione potrebbe
    rivelarsi problematica.
  prefs: []
  type: TYPE_NORMAL
- en: In questo capitolo imparerai a proteggere i tuoi servizi con un livello di autenticazione
    e a implementare le protezioni di autorizzazione per proteggere le risorse sensibili
    dagli utenti non privilegiati.
  prefs: []
  type: TYPE_NORMAL
- en: Per raggiungere questo obiettivo, Go esplorerà vari modelli di autenticazione
    e autorizzazione e implementerà JWT e l'autenticazione basata sull'identità con
    il controllo degli accessi basato sui ruoli.
  prefs: []
  type: TYPE_NORMAL
- en: Autenticazione e autorizzazione
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prima di parlare dei metodi di autenticazione, chiariamo brevemente che l'autenticazione
    e l'autorizzazione sono due concetti distinti che spesso vengono usati per errore
    in modo intercambiabile.
  prefs: []
  type: TYPE_NORMAL
- en: Secondo la definizione di OWASP:^([1](ch08.html#id970))
  prefs: []
  type: TYPE_NORMAL
- en: L*'autenticazione* è il processo di verifica che un individuo, un'entità o un
    sito web sia chi o cosa dichiara di essere, determinando la validità di uno o
    più autenticatori (come password, impronte digitali o token di sicurezza) che
    vengono utilizzati a sostegno di questa dichiarazione.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'D''altra parte, il National Institute of Standards and Technology (NIST) definisce
    l''autorizzazione come:'
  prefs: []
  type: TYPE_NORMAL
- en: Un processo per verificare che un'azione o un servizio richiesto sia approvato
    per un'entità specifica.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Mentre l'autenticazione riguarda la verifica dell'identità, l'autorizzazione
    si concentra sulla verifica dei permessi di un'identità per accedere o modificare
    le risorse.
  prefs: []
  type: TYPE_NORMAL
- en: Suggerimento
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: L'autenticazione è come presentare il passaporto all'immigrazione, mentre l'autorizzazione
    è come avere il visto giusto per entrare in un paese, specificando la durata del
    soggiorno e le attività consentite una volta entrati.
  prefs: []
  type: TYPE_NORMAL
- en: Parliamo dei metodi di autenticazione in modo più dettagliato, prima di affrontare
    il tema dell'autorizzazione più avanti nel capitolo.
  prefs: []
  type: TYPE_NORMAL
- en: Metodi di autenticazione
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Esistono diversi meccanismi di autenticazione che puoi implementare nei tuoi
    servizi GenAI per renderli sicuri attraverso la verifica dell'identità.
  prefs: []
  type: TYPE_NORMAL
- en: 'A seconda dei requisiti di sicurezza, dell''ambiente applicativo, del budget
    e delle tempistiche del progetto, puoi decidere di adottare uno o più dei seguenti
    meccanismi di autenticazione:'
  prefs: []
  type: TYPE_NORMAL
- en: Di base
  prefs: []
  type: TYPE_NORMAL
- en: Richiedere l'uso di credenziali come nome utente e password per verificare l'identità.
  prefs: []
  type: TYPE_NORMAL
- en: Gettoni web JSON (JWT)
  prefs: []
  type: TYPE_NORMAL
- en: I token di *accesso* possono essere considerati come i biglietti del cinema
    che stabiliscono se puoi accedere agli schermi, quale schermo stai visitando e
    dove sei seduto.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth
  prefs: []
  type: TYPE_NORMAL
- en: Verifica di un'identità tramite un provider di identità utilizzando lo standard
    *OAuth2*.
  prefs: []
  type: TYPE_NORMAL
- en: Basato sui tasti
  prefs: []
  type: TYPE_NORMAL
- en: Utilizza una coppia di chiavi private e pubbliche per autenticare un'identità.
    Invece dei token, il server di autorizzazione rilascia una chiave pubblica al
    cliente e memorizza una copia di una chiave privata collegata che può utilizzare
    in seguito per la verifica.^([2](ch08.html#id971))
  prefs: []
  type: TYPE_NORMAL
- en: La[Figura 8-1](#authentication_methods) mostra il flusso di dati dei metodi
    di autenticazione sopra citati in modo più dettagliato.
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0801](assets/bgai_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figura 8-1\. Metodi di autenticazione
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Conoscendo i meccanismi di autenticazione, può essere difficile decidere quale
    metodo adottare per soddisfare i tuoi requisiti di sicurezza. Per aiutarti nella
    scelta, la[Tabella 8-1](#authentication_methods_comparison) mette a confronto
    i suddetti metodi di autenticazione.
  prefs: []
  type: TYPE_NORMAL
- en: Tabella 8-1\. Confronto tra i metodi di autenticazione
  prefs: []
  type: TYPE_NORMAL
- en: '| Tipo | Vantaggi | Limitazioni | Casi d''uso |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Di base |'
  prefs: []
  type: TYPE_TB
- en: Semplicità
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Veloce da implementare
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facile da capire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Invia le credenziali in testo normale |'
  prefs: []
  type: TYPE_TB
- en: Prototipi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambienti interni o non di produzione
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Gettone |'
  prefs: []
  type: TYPE_TB
- en: Scalabilità
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Il disaccoppiamento facilita l'implementazione di architetture a microservizi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I token possono essere firmati e crittografati per una maggiore sicurezza.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altamente personalizzabile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autosufficiente per ridurre i viaggi del database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Può essere passato nelle intestazioni HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Necessità costante di rigenerare gettoni di breve durata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complessità della memorizzazione dei token sul lato client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I token possono diventare grandi e consumare una larghezza di banda eccessiva.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I token stateless possono rendere difficile l'implementazione di applicazioni
    multi-step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Le configurazioni errate sul lato client possono compromettere i token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Applicazioni a pagina singola e per dispositivi mobili
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applicazioni che richiedono flussi di autenticazione personalizzati
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| OAuth |'
  prefs: []
  type: TYPE_TB
- en: Delega l'autenticazione a provider esterni
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basato su uno standard (OAuth2) e testato per gli scenari aziendali
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accesso a risorse esterne per conto dell'utente
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Complesso da capire e da implementare
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ogni fornitore di identità può implementare il flusso OAuth in modo leggermente
    diverso.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Applicazioni che richiedono i dati degli utenti da fornitori di identità esterni
    come GitHub, Google o Microsoft.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applicazioni aziendali che richiedono l'SSO con i propri identity provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Basato sui tasti |'
  prefs: []
  type: TYPE_TB
- en: Meccanismo di autenticazione simile all'accesso Secure Shell (SSH)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Gestire e mantenere sicure le chiavi private può essere complesso
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Le chiavi compromesse possono creare rischi per la sicurezza
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problemi di scalabilità
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Piccole applicazioni
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applicazioni in ambienti interni
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Nella prossima sezione, implementerai l'autenticazione di base, JWT e OAuth
    per il tuo GenAI per comprendere appieno i componenti sottostanti e le loro interazioni.
  prefs: []
  type: TYPE_NORMAL
- en: Autenticazione di base
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nell'autenticazione di base, il client fornisce un nome utente e una password
    quando effettua una richiesta di accesso alle risorse dal server. È la tecnica
    più semplice perché non richiede l'implementazione di cookie, identificatori di
    sessione o moduli di login. Grazie alla sua semplicità, l'autenticazione di base
    è ideale per gli ambienti sandbox e per la prototipazione. Tuttavia, evita di
    usarla in ambienti di produzione perché trasmette nomi utente e password in chiaro
    a ogni richiesta, rendendola altamente vulnerabile agli attacchi di intercettazione.
  prefs: []
  type: TYPE_NORMAL
- en: Per eseguire una richiesta autenticata tramite l'autenticazione di base, devi
    aggiungere un'intestazione `Authorization` con un valore di `Basic <credentials>`
    affinché il server riesca ad autenticarla. Il valore `<credentials>` deve essere
    una codifica *Base64* del nome utente e della password uniti da un singolo punto
    (ad esempio, `base64.encode(ali:secretpassword)`.
  prefs: []
  type: TYPE_NORMAL
- en: In FastAPI, puoi proteggere un endpoint con l'autenticazione di base, come mostrato
    nell'[Esempio 8-1](#basic_authentication_endpoint).
  prefs: []
  type: TYPE_NORMAL
- en: Esempio 8-1\. Implementazione dell'autenticazione di base in FastAPI
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI ha implementato diversi meccanismi di sicurezza HTTP, tra cui `HTTP​Ba⁠sic`
    che può sfruttare il sistema di dependency injection di FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizza la libreria integrata `secrets` per confrontare il nome utente e la
    password forniti con i valori del server. L'uso di `secrets.compare_digest()`
    garantisce che la durata delle operazioni di verifica rimanga costante indipendentemente
    dagli input, per evitare *attacchi di temporizzazione*.^([3](ch08.html#id972))
  prefs: []
  type: TYPE_NORMAL
- en: Nota che `secrets.compare_digest()` può accettare solo input di tipo byte o
    stringa contenenti caratteri ASCII (cioè solo caratteri inglesi). Per gestire
    altri caratteri, dovrai prima codificare gli input con `UTF-8` in byte prima di
    eseguire i controlli delle credenziali.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Restituisce un'autorizzazione standardizzata `HTTPException` conforme agli standard
    di sicurezza che i browser comprendono in modo da mostrare nuovamente il prompt
    di accesso all'utente. Il messaggio di eccezione deve essere generico per evitare
    di far trapelare informazioni sensibili, come l'esistenza di un account utente,
    agli aggressori.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_authentication_and_authorization_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: L'utilizzo di `HTTPBasic` con `Depends()` restituisce l'oggetto `HTTPBasicCredentials`
    che contiene il nome utente fornito.
  prefs: []
  type: TYPE_NORMAL
- en: Iniettare una dipendenza di sicurezza in qualsiasi endpoint FastAPI lo proteggerà
    con l'autenticazione implementata. Puoi sperimentarlo tu stesso visitando la pagina`/docs`
    e inviando una richiesta all'endpoint `/users/me`.
  prefs: []
  type: TYPE_NORMAL
- en: L'endpoint mostrerà un'icona *a forma di lucchetto* e, al momento della richiesta,
    dovrebbe comparire un avviso di accesso che ti chiederà di fornire le credenziali,
    come puoi vedere nella [Figura 8-2](#basic_authentication).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0802](assets/bgai_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figura 8-2\. Autenticazione di base in FastAPI
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Con 25 righe di codice sei riuscito a implementare una forma di autenticazione
    di base per proteggere un endpoint. Ora puoi utilizzare l'autenticazione di base
    nei tuoi prototipi e nei server di sviluppo.
  prefs: []
  type: TYPE_NORMAL
- en: Tieni presente che dovresti evitare di adottare il meccanismo di autenticazione
    di base nei servizi GenAI di livello produttivo. Un'alternativa migliore e più
    sicura per i servizi rivolti al pubblico è l'*autenticazione JWT*, che elimina
    la necessità di sessioni lato server memorizzando tutti i dettagli dell'autenticazione
    all'interno di un token. Inoltre, mantiene l'integrità dei dati e funziona in
    diversi domini con uno standard ampiamente accettato.
  prefs: []
  type: TYPE_NORMAL
- en: Autenticazione con token web JSON (JWT)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ora che hai acquisito una maggiore familiarità con i concetti di base dell'autenticazione,
    implementiamo un livello di autenticazione JWT più complesso ma sicuro per il
    tuo servizio FastAPI. Come parte di questo processo, dovrai anche rifattorizzare
    gli endpoint esistenti per combinarli sotto un router API separato per le risorse,
    in modo da raggruppare, nominare, etichettare e proteggere più endpoint contemporaneamente.
  prefs: []
  type: TYPE_NORMAL
- en: Che cos'è il JWT?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I JWT sono un modo sicuro e compatto di asserire le rivendicazioni tra le applicazioni
    tramite token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Questi gettoni sono composti da tre parti:'
  prefs: []
  type: TYPE_NORMAL
- en: Intestazioni
  prefs: []
  type: TYPE_NORMAL
- en: Specifica il tipo di token e l'algoritmo di firma oltre alla data e all'autorità
    emittente.
  prefs: []
  type: TYPE_NORMAL
- en: Carico utile
  prefs: []
  type: TYPE_NORMAL
- en: Specifica il corpo del token che rappresenta le rivendicazioni sulla risorsa
    insieme a metadati aggiuntivi.
  prefs: []
  type: TYPE_NORMAL
- en: Firma
  prefs: []
  type: TYPE_NORMAL
- en: La funzione che crea il token lo firma utilizzando il *payload codificato*,
    le *intestazioni codificate*, un *segreto* e l'algoritmo di firma.
  prefs: []
  type: TYPE_NORMAL
- en: Suggerimento
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: L'algoritmo di codifica `base64` viene spesso utilizzato per codificare e decodificare
    i dati per garantire la compattezza e la sicurezza degli URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[La Figura 8-3](#jwt) mostra l''aspetto di un tipico JWT.'
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0803](assets/bgai_0803.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figura 8-3\. Componenti JWT (Fonte: [jwt.io](https://jwt.io))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I JWT sono sicuri, compatti e convenienti perché possono contenere tutte le
    informazioni necessarie per eseguire l'autenticazione dell'utente, evitando la
    necessità di effettuare più viaggi nel database. Inoltre, grazie alla loro compattezza,
    puoi trasferirli attraverso la rete utilizzando il corpo HTTP `POST`, le intestazioni
    o i parametri URL.
  prefs: []
  type: TYPE_NORMAL
- en: Come iniziare con l'autenticazione JWT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Per iniziare a implementare il meccanismo di autenticazione JWT in FastAPI,
    devi installare le dipendenze `passlib` e `python-jose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2] # entities.py  import uuid from datetime import UTC, datetime from sqlalchemy
    import Index, String from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column  class
    Base(DeclarativeBase):     pass  class User(Base):     __tablename__ = "users"      id:
    Mapped[uuid.UUID] = mapped_column(primary_key=True, default=uuid.uuid4)     email:
    Mapped[str] = mapped_column(String(length=255), unique=True)     hashed_password:
    Mapped[str] = mapped_column(String(length=255))     is_active: Mapped[bool] =
    mapped_column(default=True)     role: Mapped[str] = mapped_column(default="USER")     created_at:
    Mapped[datetime] = mapped_column(default=datetime.now(UTC))     updated_at: Mapped[datetime]
    = mapped_column(         default=datetime.now(UTC), onupdate=datetime.now(UTC)     )      __table_args__
    = (Index("ix_users_email", "email"),) [PRE3] # schemas.py  from datetime import
    datetime from typing import Annotated from pydantic import (UUID4, AfterValidator,
    BaseModel, ConfigDict, Field,                       validate_call)  @validate_call
    def validate_username(value: str) -> str: ![1](assets/1.png)     if not value.isalnum():         raise
    ValueError("Username must be alphanumeric")     return value  @validate_call def
    validate_password(value: str) -> str: ![1](assets/1.png)     validations = [         (             lambda
    v: any(char.isdigit() for char in v),             "Password must contain at least
    one digit",         ),         (             lambda v: any(char.isupper() for
    char in v),             "Password must contain at least one uppercase letter",         ),         (             lambda
    v: any(char.islower() for char in v),             "Password must contain at least
    one lowercase letter",         ),     ]     for condition, error_message in validations:         if
    not condition(value):             raise ValueError(error_message)     return value  ValidUsername
    = Annotated[     str, Field(min_length=3, max_length=20), AfterValidator(validate_username)
    ] ValidPassword = Annotated[     str, Field(min_length=8, max_length=64), AfterValidator(validate_password)
    ]  class UserBase(BaseModel):     model_config = ConfigDict(from_attributes=True)
    ![2](assets/2.png)      username: ValidUsername     is_active: bool = True     role:
    str = "USER"  class UserCreate(UserBase): ![3](assets/3.png)     password: ValidPassword  class
    UserInDB(UserBase): ![4](assets/4.png)     hashed_password: str  class UserOut(UserBase):     id:
    UUID4     created_at: datetime     updated_at: datetime [PRE4] # entities.py  from
    datetime import UTC, datetime from sqlalchemy import ForeignKey, Index, String
    from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship  class
    Base(DeclarativeBase):     pass  class Token(Base):     __tablename__ = "tokens"      id:
    Mapped[int] = mapped_column(primary_key=True)     user_id: Mapped[int] = mapped_column(ForeignKey("users.id"))     expires_at:
    Mapped[datetime] = mapped_column()     is_active: Mapped[bool] = mapped_column(default=True)     ip_address:
    Mapped[str | None] = mapped_column(String(length=255))     created_at: Mapped[datetime]
    = mapped_column(default=datetime.now(UTC))     updated_at: Mapped[datetime] =
    mapped_column(         default=datetime.now(UTC), onupdate=datetime.now(UTC)     )      user
    = relationship("User", back_populates="tokens")      __table_args__ = (         Index("ix_tokens_user_id",
    "user_id"),         Index("ix_tokens_ip_address", "ip_address"),     )  class
    User(Base):     __tablename__ = "users"     # other columns...      tokens = relationship(         "Token",
    back_populates="user", cascade="all, delete-orphan"     )  # schemas.py  from
    datetime import datetime from pydantic import BaseModel  class TokenBase(BaseModel):     user_id:
    int     expires_at: datetime     is_active: bool = True     ip_address: str |
    None = None  class TokenCreate(TokenBase):     pass  class TokenOut(BaseModel):     access_token:
    str     token_type: str = "Bearer" [PRE5] """create users and tokens tables  Revision
    ID: 1234567890ab Revises: Create Date: 2025-01-28 12:34:56.789012  """  from datetime
    import UTC, datetime import sqlalchemy as sa from alembic import op  ...  def
    upgrade():     op.create_table(         "users",         sa.Column("id", sa.UUID(as_uuid=True)),
    ![1](assets/1.png)         sa.Column("email", sa.String(length=255)),         sa.Column("hashed_password",
    sa.String(length=255)), ![2](assets/2.png)         sa.Column(             "is_active",
    sa.Boolean(), server_default=sa.sql.expression.true()         ), ![3](assets/3.png)         sa.Column("role",
    sa.String(), server_default=sa.text("USER")), ![4](assets/4.png)         sa.Column("created_at",
    sa.DateTime(), default=datetime.now(UTC)),         sa.Column(             "updated_at",             sa.DateTime(),             default=datetime.now(UTC),             onupdate=datetime.now(UTC),
    ![5](assets/5.png)         ),         sa.PrimaryKeyConstraint("id"),         sa.UniqueConstraint("email"),         sa.Index("ix_users_email",
    "email"), ![6](assets/6.png)     )      op.create_table(         "tokens",         sa.Column("id",
    sa.UUID(as_uuid=True)), ![1](assets/1.png)         sa.Column("user_id", sa.Integer()),         sa.Column("expires_at",
    sa.DateTime()), ![7](assets/7.png)         sa.Column("is_active", sa.Boolean(),
    default=True), ![8](assets/8.png)         sa.Column("ip_address", sa.String(length=255),
    nullable=True),         sa.Column("created_at", sa.DateTime(), default=datetime.now(UTC)),         sa.Column(             "updated_at",             sa.DateTime(),             default=datetime.now(UTC),             onupdate=datetime.now(UTC),
    ![9](assets/9.png)         ),         sa.ForeignKeyConstraint(             ["user_id"],             ["users.id"],         ),         sa.PrimaryKeyConstraint("id"),         sa.Index("ix_tokens_user_id",
    "user_id"),         sa.Index("ix_tokens_ip_address", "ip_address"), ![10](assets/10.png)     )   def
    downgrade():     op.drop_table("tokens")     op.drop_table("users") [PRE6]`  [PRE7]
    # services/auth.py  from fastapi.security import HTTPBearer from passlib.context
    import CryptContext  class PasswordService:     security = HTTPBearer()     pwd_context
    = CryptContext(schemes=["bcrypt"]) ![1](assets/1.png)      async def verify_password(         self,
    password: str, hashed_password: str     ) -> bool:         return self.pwd_context.verify(password,
    hashed_password) ![2](assets/2.png)      async def get_password_hash(self, password:
    str) -> str:         return self.pwd_context.hash(password) ![2](assets/2.png)
    [PRE8] # exceptions.py  from fastapi import HTTPException, status  UnauthorizedException
    = HTTPException(     status_code=status.HTTP_401_UNAUTHORIZED,     detail="Not
    authenticated",     headers={"WWW-Authenticate": "Bearer"}, )  AlreadyRegisteredException
    = HTTPException(     status_code=status.HTTP_400_BAD_REQUEST,     detail="Username
    already registered", ) [PRE9] # repositories.py  from entities import Token from
    repositories.interfaces import Repository from schemas import TokenCreate, TokenUpdate
    from sqlalchemy import select from sqlalchemy.ext.asyncio import AsyncSession  class
    TokenRepository(Repository):     def __init__(self, session: AsyncSession) ->
    None:         self.session = session      async def list(self, skip: int, take:
    int) -> list[Token]:         async with self.session.begin():             result
    = await self.session.execute(                 select(Token).offset(skip).limit(take)             )         return
    [r for r in result.scalars().all()]      async def get(self, token_id: int) ->
    Token | None:         async with self.session.begin():             result = await
    self.session.execute(                 select(Token).where(Token.id == token_id)             )         return
    result.scalars().first()      async def create(self, token: TokenCreate) -> Token:         new_token
    = Token(**token.dict())         async with self.session.begin():             self.session.add(new_token)             await
    self.session.commit()             await self.session.refresh(new_token)         return
    new_token      async def update(         self, token_id: int, updated_token: TokenUpdate     )
    -> Token | None:         token = await self.get(token_id)         if not token:             return
    None         for key, value in updated_token.dict(exclude_unset=True).items():             setattr(token,
    key, value)         async with self.session.begin():             await self.session.commit()             await
    self.session.refresh(token)         return token      async def delete(self, token_id:
    int) -> None:         token = await self.get(token_id)         if not token:             return         async
    with self.session.begin():             await self.session.delete(token)             await
    self.session.commit() [PRE10] # services/auth.py  from datetime import UTC, datetime,
    timedelta from exceptions import UnauthorizedException from jose import JWTError,
    jwt from pydantic import UUID4 from repositories import TokenRepository from schemas
    import TokenCreate, TokenUpdate  class TokenService(TokenRepository):     secret_key
    = "your_secret_key"     algorithm = "HS256"     expires_in_minutes = 60 ![1](assets/1.png)  async
    def create_access_token(     self, data: dict, expires_delta: timedelta | None
    = None ![2](assets/2.png) ) -> str:     to_encode = data.copy()     if expires_delta:         expire
    = datetime.now(UTC) + expires_delta     else:         expire = datetime.now(UTC)
    + timedelta(minutes=self.expires_in_minutes)     token_id = await self.create(TokenCreate(expires_at=expire))
    ![3](assets/3.png)     to_encode.update(         {"exp": expire, "iss": "your_service_name",
    "sub": token_id} ![4](assets/4.png)     )     encoded_jwt = jwt.encode(         to_encode,
    self.secret_key, algorithm=self.algorithm ![5](assets/5.png)     )     return
    encoded_jwt  async def deactivate(self, token_id: UUID4) -> None:     await self.update(TokenUpdate(id=token_id,
    is_active=False))  def decode(self, encoded_token: str) -> dict:     try:         return
    jwt.decode(             encoded_token, self.secret_key, algorithms=[self.algorithm]         )     except
    JWTError:         raise UnauthorizedException  async def validate(self, token_id:
    UUID4) -> bool:     return (token := await self.get(token_id)) is not None and
    token.is_active [PRE11] # services/auth.py  from typing import Annotated from
    databases import DBSessionDep from entities import Token, User, UserCreate, UserInDB
    from exceptions import AlreadyRegisteredException, UnauthorizedException from
    fastapi import Depends from fastapi.security import (HTTPAuthorizationCredentials,
    HTTPBearer,                               OAuth2PasswordRequestForm) from services.auth
    import PasswordService, TokenService from services.users import UserService  security
    = HTTPBearer() LoginFormDep = Annotated[OAuth2PasswordRequestForm, Depends()]
    AuthHeaderDep = Annotated[HTTPAuthorizationCredentials, Depends(security)]  class
    AuthService:     def __init__(self, session: DBSessionDep):         self.password_service
    = PasswordService()         self.token_service = TokenService(session)         self.user_service
    = UserService(session)      async def register_user(self, user: UserCreate) ->
    User:         if await self.user_service.get(user.username):             raise
    AlreadyRegisteredException         hashed_password = await self.password_service.get_password_hash(             user.password         )         return
    await self.user_service.create(             UserInDB(username=user.username, hashed_password=hashed_password)         )      async
    def authenticate_user(self, form_data: LoginFormDep) -> Token: ![1](assets/1.png)         if
    not (user := await self.user_service.get_user(form_data.username)):             raise
    UnauthorizedException         if not await self.password_service.verify_password(             form_data.password,
    user.hashed_password         ):             raise UnauthorizedException         return
    await self.token_service.create_access_token(user._asdict())      async def get_current_user(self,
    credentials: AuthHeaderDep) -> User:         if credentials.scheme != "Bearer":             raise
    UnauthorizedException         if not (token := credentials.credentials):             raise
    UnauthorizedException         payload = self.token_service.decode(token)         if
    not await self.token_service.validate(payload.get("sub")):             raise UnauthorizedException         if
    not (username := payload.get("username")):             raise UnauthorizedException         if
    not (user := await self.user_service.get(username)):             raise UnauthorizedException         return
    user      async def logout(self, credentials: AuthHeaderDep) -> None:         payload
    = self.token_service.decode(credentials.credentials)         await self.token_service.deactivate(payload.get("sub"))      #
    Add Password Reset Method     async def reset_password(self): ... [PRE12] # routes/auth.py  from
    typing import Annotated from entities import User from fastapi import APIRouter,
    Depends from models import TokenOut, UserOut from services.auth import AuthService  auth_service
    = AuthService() RegisterUserDep = Annotated[User, Depends(auth_service.register_user)]
    AuthenticateUserCredDep = Annotated[     str, Depends(auth_service.authenticate_user_with_credentials)
    ] AuthenticateUserTokenDep = Annotated[User, Depends(auth_service.register_user)]
    PasswordResetDep = Annotated[None, Depends(auth_service.reset_password)] ![1](assets/1.png)  router
    = APIRouter(prefix="/auth", tags=["Authentication"]) ![2](assets/2.png)  @router.post("/register")
    async def register_user_controller(new_user: RegisterUserDep) -> UserOut:     return
    new_user  @router.post("/token") ![3](assets/3.png) async def login_for_access_token_controller(     access_token:
    AuthenticateUserCredDep, ) -> TokenOut:     return {"access_token": access_token,
    "token_type": "bearer"}  @router.post("/logout", dependencies=[Depends(auth_service.logout)])
    ![3](assets/3.png) ![4](assets/4.png) async def logout_access_token_controller()
    -> dict:     return {"message": "Logged out"}  @router.post("reset-password")
    ![3](assets/3.png) async def reset_password_controller(credentials: str) -> dict:     return
    {         "message": "If an account exists, "         "a password reset link will
    be sent to the provided email"     } [PRE13] # routes/resource.py  from fastapi
    import APIRouter  router = APIRouter(prefix="/generate", tags=["Resource"]) ![1](assets/1.png)  @router.get("/generate/text",
    ...) def serve_language_model_controller(...):     ...  @router.get("/generate/audio",
    ...) def serve_text_to_audio_model_controller(...)     ...  ... # Add other controllers
    to the resource router here  # main.py  from typing import Annotated import routes
    from entities import User from fastapi import Depends, FastAPI from services.auth
    import AuthService  auth_service = AuthService() AuthenticateUserDep = Annotated[User,
    Depends(auth_service.get_current_user)]  ...  app = FastAPI(lifespan=lifespan)  app.include_router(routes.auth.router,
    prefix="/auth", tags=["Auth"]) ![2](assets/2.png) app.include_router(     routes.resource.router,     dependencies=[AuthenticateUserDep],     prefix="/generate",     tags=["Generate"],
    ) ![3](assets/3.png) ...  # Add other routes to the app here [PRE14]`  [PRE15]
    # routes/auth.py  import secrets from fastapi import APIRouter, Request, status
    from fastapi.responses import RedirectResponse  client_id = "your_client_id" client_secret
    = "your_client_secret"  router = APIRouter()  ...  @router.get("/oauth/github/login",
    status_code=status.HTTP_301_REDIRECT) def oauth_github_login_controller(request:
    Request) -> RedirectResponse:     state = secrets.token_urlsafe(16)     redirect_uri
    = request.url_for("oauth_github_callback_controller")     response = RedirectResponse(         url=f"https://github.com/login/oauth/authorize"         f"?client_id={client_id}"         f"&scope=user"         f"&state={state}"         f"&redirect_uri={redirect_uri}"     )
    ![1](assets/1.png)     csrf_token = secrets.token_urlsafe(16)     request.session["x-csrf-state-token"]
    = csrf_token     return response [PRE16] # client.py  import requests import streamlit
    as st  if st.button("Login with GitHub"):     response = requests.get("http://localhost:8000/auth/oauth/github/login")     if
    not response.ok:         st.error("Failed to login with GitHub. Please try again
    later")         response.raise_for_status() [PRE17] # dependencies/auth.py  from
    typing import Annotated import aiohttp from fastapi import Depends, HTTPException
    from loguru import logger  client_id = "your_client_id" client_secret = "your_client_secret"  async
    def exchange_grant_with_access_token(code: str) -> str:     try:         body
    = {             "client_id": client_id,             "client_secret": client_secret,             "code":
    code,         }         headers = {             "Accept": "application/json",             "Content-Type":
    "application/json",         }         async with aiohttp.ClientSession() as session:             async
    with session.post(                 "https://github.com/login/oauth/access_token",                 json=body,                 headers=headers,             )
    as resp:                 access_token_data = await resp.json()     except Exception
    as e:         logger.warning(f"Failed to fetch the access token. Error: {e}")         raise
    HTTPException(             status_code=503, detail="Failed to fetch access token"         )      if
    not access_token_data:         raise HTTPException(             status_code=503,
    detail="Failed to obtain access token"         )      return access_token_data.get("access_token",
    "")  ExchangeCodeTokenDep = Annotated[str, Depends(exchange_grant_with_access_token)]
    [PRE18] # routes/auth.py  from dependencies.auth import ExchangeCodeTokenDep from
    fastapi import Depends, HTTPException, Request from fastapi.responses import RedirectResponse  ...  def
    check_csrf_state(request: Request, state: str) -> None:     if state != request.session.get("x-csrf-token"):         raise
    HTTPException(detail="Bad request", status_code=401)  @router.get("/oauth/github/callback",
    dependencies=[Depends(check_csrf_state)]) async def oauth_github_callback_controller(     access_token:
    ExchangeCodeTokenDep, ) -> RedirectResponse:     response = RedirectResponse(url=f"http://localhost:8501")     response.set_cookie(key="access_token",
    value=access_token, httponly=True)     return response [PRE19] # main.py  from
    fastapi import FastAPI from starlette.middleware.sessions import SessionMiddleware  ...  app
    = FastAPI(lifespan=lifespan) app.add_middleware(SessionMiddleware, secret_key="your_secret_key")
    [PRE20] # routes/auth.py  from typing import Annotated import aiohttp from fastapi
    import Depends, HTTPException from fastapi.security import HTTPAuthorizationCredentials,
    HTTPBearer  security = HTTPBearer() HTTPBearerDep = Annotated[HTTPAuthorizationCredentials,
    Depends(security)]  ...  async def get_user_info(credentials: HTTPBearerDep) ->
    dict:     try:         async with aiohttp.ClientSession() as session:             headers
    = {"Authorization": f"Bearer {credentials.credentials}"}             async with
    session.get(                 "https://api.github.com/user", headers=headers             )
    as resp:                 return await resp.json()     except Exception as e:         raise
    HTTPException(             status_code=503, detail=f"Failed to obtain user info
    - Error: {e}"         )  GetUserInfoDep = Annotated[dict, Depends(get_user_info)]  @router.get("/oauth/github/callback")
    async def get_current_user_controller(user_info: GetUserInfoDep) -> dict:     return
    user_info [PRE21] # dependencies/auth.py  from entities import User from fastapi
    import Depends, HTTPException, status from services.auth import AuthService  async
    def is_admin(user: User = Depends(AuthService.get_current_user)) -> User: ![1](assets/1.png)     if
    user.role != "ADMIN":         raise HTTPException(             status_code=status.HTTP_403_FORBIDDEN,             detail="Not
    allowed to perform this action",         )     return user  # routers/resource.py  from
    dependencies.auth import is_admin from fastapi import APIRouter, Depends from
    services.auth import AuthService  router = APIRouter(     dependencies=[Depends(AuthService.get_current_user)],
    ![3](assets/3.png)     prefix="/generate",     tags=["Resource"], )  @router.post("/image",
    dependencies=[Depends(is_admin)]) async def generate_image_controller(): ![2](assets/2.png)     ...  @router.post("/text")
    ![3](assets/3.png) async def generate_text_controller():     ... [PRE22] # dependencies/auth.py  from
    typing import Annotated  from entities import User from fastapi import APIRouter,
    Depends, HTTPException, status from services.auth import AuthService  CurrentUserDep
    = Annotated[User, Depends(AuthService.get_current_user)]  async def has_role(user:
    CurrentUserDep, roles: list[str]) -> User:     if user.role not in roles:         raise
    HTTPException(             status_code=status.HTTP_403_FORBIDDEN,             detail="Not
    allowed to perform this action",         )     return user   # routes/resource.py  ...  @router.post(     "/image",     dependencies=[Depends(lambda
    user: has_role(user, ["ADMIN", "MODERATOR"]))], ) async def generate_image_controller():     ...  @router.post(     "/text",
    dependencies=[Depends(lambda user: has_role(user, ["EDITOR"]))] ) async def generate_text_controller():     ...
    [PRE23] # dependencies/auth.py  from typing import Annotated from fastapi import
    Depends, HTTPException, status ...  # import services and entities here  CurrentUserDep
    = Annotated[User, Depends(AuthService.get_current_user)] TeamMembershipRep = Annotated[Team,
    Depends(TeamService.get_current_team)] ResourceDep = Annotated[Resource, Depends(ResourceService.get_resource)]  def
    authorize(     user: CurrentUserDep, resource: ResourceDep, team: TeamMembershipRep
    ) -> bool:     if user.role == "ADMIN":         return True     if user.id in
    team.members:         return True     if resource.is_public:         return True     raise
    HTTPException(         status_code=status.HTTP_403_FORBIDDEN, detail="Access Denied"     )  #
    routes/resource.py  from dependencies.auth import authorize from fastapi import
    APIRouter, Depends  router = APIRouter(     dependencies=[Depends(authorize)],
    prefix="/generate", tags=["Resource"] )  @router.post("/image") async def generate_image_controller():
    ...  @router.post("/text") async def generate_text_controller(): ... [PRE24] #
    authorization_api.py (Authorization Service)  from typing import Annotated, Literal
    from fastapi import Depends, FastAPI from pydantic import BaseModel  ...  # import
    services and entities here  CurrentUserDep = Annotated[User, Depends(AuthService.get_current_user)]
    ActionRep = Annotated[Literal["READ", "CREATE", "UPDATE", "DELETE"], str] ResourceDep
    = Annotated[Resource, Depends(ResourceService.get_resource)]  class AuthorizationResponse(BaseModel):     allowed:
    bool  app = FastAPI()  app.get("/authorize") def authorization_controller(     user:
    CurrentUserDep, resource: ResourceDep, action: ActionRep ) -> AuthorizationResponse:     if
    user.role == "ADMIN":         return AuthorizationResponse(allowed=True)     if
    action in user.permissions.get(resource.id, []):         return AuthorizationResponse(allowed=True)     ...  #
    Other permission checks     return AuthorizationResponse(allowed=False)  # genai_api.py
    (GenAI Service)  from fastapi import APIRouter, HTTPException, status from pydantic
    import BaseModel  class AuthorizationData(BaseModel):     user_id: int     resource_id:
    int     action: str  authorization_client = ...  # Create authorization client  async
    def enforce(data: AuthorizationData) -> bool:     response = await authorization_client.decide(data)     if
    response.allowed:         return True     raise HTTPException(         status_code=status.HTTP_403_FORBIDDEN,
    detail="Access Denied"     )  router = APIRouter(     dependencies=[Depends(enforce)],
    prefix="/generate", tags=["Resource"] )  @router.post("/text") async def generate_text_controller():     ...
    [PRE25]`'
  prefs: []
  type: TYPE_NORMAL
