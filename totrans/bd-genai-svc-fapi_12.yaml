- en: Chapter 8\. Authentication and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you’ve built GenAI services that can interact with databases, stream
    model responses, and handle concurrent users.
  prefs: []
  type: TYPE_NORMAL
- en: Your services are now up and running, but since they’re not protected from attackers
    or malicious users, deploying them to production may prove problematic.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to secure your services with an authentication
    layer and implement authorization guards to protect sensitive resources from nonprivileged
    users.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we’re going to explore various authentication and authorization
    patterns then implement JWT and identity-based authentication with role-based
    access control.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before talking about authentication methods, let’s briefly clarify that authentication
    and authorization are two separate concepts that are often interchangeably used
    by mistake.
  prefs: []
  type: TYPE_NORMAL
- en: According to the OWASP definition:^([1](ch08.html#id970))
  prefs: []
  type: TYPE_NORMAL
- en: '*Authentication* is the process of verifying that an individual, entity, or
    website is who or what it claims to be by determining the validity of one or more
    authenticators (like passwords, fingerprints, or security tokens) that are used
    to back up this claim.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'On the other hand, the National Institute of Standards and Technology (NIST)
    defines authorization as:'
  prefs: []
  type: TYPE_NORMAL
- en: A process for verifying that a requested action or service is approved for a
    specific entity.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: While authentication is about verifying the identity, authorization focuses
    on verifying permissions of an identity to access or mutate resources.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An analogy that might clarify this distinction is passing through passport control
    at an airport. Authentication is like presenting your passport at immigration,
    while authorization is like having the right visa to enter a country, specifying
    the duration of your stay and permitted activities once you enter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss authentication methods in more detail before diving into authorization
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several authentication mechanisms that you can implement in your GenAI
    services to secure them by identity verification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on your security requirements, application environment, budget, and
    project timelines, you may decide to adopt one or more of the following authentication
    mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic
  prefs: []
  type: TYPE_NORMAL
- en: Requiring the use of credentials such as username and password to verify identity.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Tokens (JWT)
  prefs: []
  type: TYPE_NORMAL
- en: Requiring the use of *access tokens* to verify identity. You can think of access
    tokens like cinema tickets that dictate whether you can access the screens and
    which screen you’re visiting and where you’re sitting.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth
  prefs: []
  type: TYPE_NORMAL
- en: Verifying an identity via an identity provider using the *OAuth2* standard.
  prefs: []
  type: TYPE_NORMAL
- en: Key-based
  prefs: []
  type: TYPE_NORMAL
- en: Using a private and public key pair to authenticate an identity. Instead of
    tokens, the authorization server issues a public key to the client and stores
    a copy of a linked private key that it can use later for verification.^([2](ch08.html#id971))
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-1](#authentication_methods) shows the data flow of the aforementioned
    authentication methods in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0801](assets/bgai_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Authentication methods
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Being aware of authentication mechanisms, it can still be challenging to decide
    on the method to adopt when addressing your security requirements. To assist with
    the selection task, [Table 8-1](#authentication_methods_comparison) compares the
    aforementioned authentication methods.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. Comparison of authentication methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Benefits | Limitations | Use cases |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Basic |'
  prefs: []
  type: TYPE_TB
- en: Simplicity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast to implement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Sends credentials in plain text |'
  prefs: []
  type: TYPE_TB
- en: Prototypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal or nonproduction environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Token |'
  prefs: []
  type: TYPE_TB
- en: Scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoupling facilitates implementation of microservice architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tokens can be signed and encrypted for higher security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highly customizable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-contained reducing database round-trips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be passed in HTTP headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Constant need to regenerate short-lived tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complexity of client-side token storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tokens can get large, consuming excess bandwidth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateless tokens can make multi-step applications hard to implement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side misconfigurations can compromise tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Single-page and mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications requiring custom authentication flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| OAuth |'
  prefs: []
  type: TYPE_TB
- en: Delegates authentication to external providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on a standard (OAuth2) and battle-tested for enterprise scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to external resources on behalf of the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Complex to understand and implement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each identity provider may implement the OAuth flow slightly differently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Applications requiring user data from external identity providers such as GitHub,
    Google, or Microsoft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enterprise applications that require SSO with their own identity provider(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Key-based |'
  prefs: []
  type: TYPE_TB
- en: Similar authentication mechanism to Secure Shell (SSH) access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Managing and keeping private keys secure can be complex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compromised keys can create security risks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Small applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications within internal environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: You should now feel confident in deciding the appropriate authentication mechanism
    to adopt. In the next section, you’re going to implement basic, JWT, and OAuth
    authentication for your GenAI to fully understand the underlying components and
    their interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In basic authentication, the client provides a username and password when making
    a request to access resources from the server. It is the simplest technique as
    it won’t require cookies, session identifiers, or any login forms to be implemented.
    Because of its simplicity, basic authentication is ideal for sandbox environments
    and when prototyping. However, avoid using it in production environments as it
    transmits usernames and passwords in plain text on every request, making it highly
    vulnerable to interception attacks.
  prefs: []
  type: TYPE_NORMAL
- en: To perform an authenticated request via basic authentication, you must add an
    `Authorization` header with a value of `Basic <credentials>` for the server to
    successfully authenticate it. The `<credentials>` value must be a *Base64* encoding
    of the username and password joined by a single colon (i.e., `base64.encode(ali:secretpassword)`.
  prefs: []
  type: TYPE_NORMAL
- en: In FastAPI, you can protect an endpoint with basic authentication, as shown
    in [Example 8-1](#basic_authentication_endpoint).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-1\. Implementing basic authentication in FastAPI
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI has implemented several HTTP security mechanisms including `HTTP​Ba⁠sic`
    that can leverage the FastAPI’s dependency injection system.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `secrets` built-in library to compare the provided username and password
    with the server’s values. Using `secrets.compare_digest()` ensures the duration
    of checking operations remain consistent no matter what the inputs are to avoid
    *timing attacks*.^([3](ch08.html#id972))
  prefs: []
  type: TYPE_NORMAL
- en: Note that `secrets.compare_digest()` can only accept byte or string inputs containing
    ASCII characters (i.e., English-only characters). To handle other characters,
    you will need to encode the inputs with `UTF-8` to bytes first before performing
    the credential checks.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Return a standardized authorization `HTTPException` compliant with security
    standards that browsers understand so that they show the login prompt again to
    the user. The exception message must be generic to avoid leaking any sensitive
    information, such as the existence of a user account, to attackers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_authentication_and_authorization_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `HTTPBasic` with `Depends()` returns the `HTTPBasicCredentials` object
    that contains the provided username.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting a security dependency to any FastAPI endpoint will protect it with
    the implemented authentication. You can experience this yourself now by visiting
    the `/docs` page and sending a request to the `/users/me` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint will show a *lock* icon in front of it, and you should see a sign-in
    alert when making a request, asking you to provide credentials, as you can see
    in [Figure 8-2](#basic_authentication).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0802](assets/bgai_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. Basic authentication in FastAPI
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Well done! In 25 lines of code, you managed to implement a basic form of authentication
    to protect an endpoint. You can now use basic authentication in your own prototypes
    and development servers.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind, you should avoid adopting the basic authentication mechanism in
    production-grade GenAI services. A better and more secure alternative for public-facing
    services is *JWT authentication*. It eliminates the need for server-side sessions
    by storing all authentication details within a token. It also maintains data integrity
    and works across different domains with a widely accepted standard.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Tokens (JWT) Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’re more familiar with basic concepts of authentication, let’s implement
    a more complex but secure JWT authentication layer to your FastAPI service. As
    part of this, you’ll also refactor your existing endpoints to combine them under
    a separate resource API router to group, name, tag, and protect multiple endpoints
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: What is JWT?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JWTs are a URL-safe and compact way of asserting claims between applications
    via tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'These tokens consist of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Headers
  prefs: []
  type: TYPE_NORMAL
- en: Specify the token type and signing algorithm in addition to the datetime and
    the issuing authority.
  prefs: []
  type: TYPE_NORMAL
- en: Payload
  prefs: []
  type: TYPE_NORMAL
- en: Specify the body of the token representing the claims on the resource alongside
    additional metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Signature
  prefs: []
  type: TYPE_NORMAL
- en: The function that creates the token will also sign it using the *encoded payload*,
    *encoded headers*, a *secret*, and the signing algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `base64` encoding algorithm is often used to encode and decode data for
    compactness and URL safety.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-3](#jwt) shows what a typical JWT looks like.'
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0803](assets/bgai_0803.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3\. JWT components (Source: [jwt.io](https://jwt.io))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: JWTs are secure, compact, and convenient since they can hold all the information
    needed to perform user authentication, avoiding the need for multiple database
    round-trips. In addition, due to their compactness, you can transfer them across
    the network using the HTTP `POST` body, headers, or URL parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with JWT authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get started with implementing the JWT authentication mechanism in FastAPI,
    you need to install the `passlib` and `python-jose` dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With the dependencies installed, you will then need tables in the database to
    store the generated users and associated token data. For data persistence, let’s
    migrate the database to create the `users` and `tokens` tables, as shown in [Figure 8-4](#erd).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0804](assets/bgai_0804.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. Entity relationship diagram of `users` and `tokens` tables
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you look at [Figure 8-4](#erd), you will spot that the `tokens` table has
    a one-to-many relationship with the `users` table. You can use the token records
    to track successful login attempts for each user and to revoke access if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s define the required SQLAlchemy models and Pydantic schemas for database
    queries and data validation, as shown in Examples [8-2](#user_models) and [8-3](#users_schema).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-2\. Declare user SQLAlchemy ORM models
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You will be using the ORM models at the data access layer while the Pydantic
    schemas will validate incoming and outgoing authentication data at the endpoint
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-3\. Declare user Pydantic schemas with username and password field
    validators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Validate both username and password to enforce higher security requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Allow Pydantic to read SQLAlchemy ORM model attributes instead of having to
    manually populate Pydantic schemas from SQLAlchemy models.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Use inheritance to declare several Pydantic schemas based on a user base model.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_authentication_and_authorization_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a separate schema that accepts the `hashed_password` field to be used
    only for creating new user records during the registration process. All other
    schemas must skip storing this field to eliminate the risk of password leakage.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the token models and schemas is fairly similar, as you can see in [Example 8-4](#token_models).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-4\. Declare token ORM models and Pydantic schemas
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s auto-generate a migration file using the `alembic revision --autogenerate
    -m "create users and tokens tables` command so that you can specify the details
    of both tables by following [Example 8-5](#users_migration).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-5\. Database migration to create the `users` and `tokens` tables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically generate universally unique identifiers (UUIDs) in the database
    layer for user and token records to prevent attackers from guessing identifiers
    of sensitive resources (i.e., user or token records).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid storing raw password strings in the database to reduce security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Add the ability to enable or disable account access.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_authentication_and_authorization_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Add the ability to specify user roles such as `USER` and `ADMIN` for managing
    access levels of an account. Authorization checks will use the `role` field to
    manage access of privileged resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_authentication_and_authorization_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Auto-timestamp user creation and updates for monitoring and security purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_authentication_and_authorization_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Add a unique constraint and a secondary index on the email field to optimize
    user queries by email and eliminate the possibility of creating duplicate email
    accounts.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_authentication_and_authorization_CO3-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Tokens must expire after a short period of time to reduce the time window that
    exposed tokens may be misused by attackers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_authentication_and_authorization_CO3-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Add the ability to disable tokens that should no longer be valid for either
    being exposed or if a user has logged out.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_authentication_and_authorization_CO3-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Track the token creation and update times for monitoring and security.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_authentication_and_authorization_CO3-11)'
  prefs: []
  type: TYPE_NORMAL
- en: Create secondary indexes on `user_id` and `ip_address` fields to optimize token
    queries by these fields.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the `alembic upgrade head` command to execute the migration in [Example 8-5](#users_migration)
    against your database and create both `users` and `tokens` tables.
  prefs: []
  type: TYPE_NORMAL
- en: With the ORM models and Pydantic schemas declared, you can focus on the core
    authentication mechanism logic.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-5](#jwt_architecture) shows the architecture of the JWT authentication
    system you’re going to implement in your FastAPI GenAI service.'
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0805](assets/bgai_0805.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5\. JWT authentication system architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the following code examples, you will see how to implement the core authentication
    flows starting with user registration and JWT generation.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing and salting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step after creating the `users` and `tokens` tables in the database
    is to store new users in the database upon registration. However, you should avoid
    storing passwords in plain form, because if the database is compromised, the attackers
    will have every user’s credential.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the authentication mechanism will leverage a *hashing algorithm* that
    converts plain passwords into an encoded string that can’t be decoded back into
    its original form. Since the decoding process isn’t reversible, cryptographic
    hashing algorithms differ from standard encoding/decoding functions such as Base64.
  prefs: []
  type: TYPE_NORMAL
- en: While storing hashed passwords is more secure than storing plain passwords,
    it doesn’t provide enough protection. If such a database of hashed passwords falls
    into the hands of attackers, they can use a precomputed hash tables—​commonly
    referred to as *rainbow tables*. Attackers can use rainbow tables to brute-force
    their way into your system by recovering plaintext passwords. To protect against
    these brute-force attacks, you also need to introduce an element of randomness
    to your hashing process using a technique termed *salting*.
  prefs: []
  type: TYPE_NORMAL
- en: With salts, the cryptographic hashing algorithm produces different hashed passwords,
    even though the users may register with common, compromised, or duplicate passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Password hashing with a random salt protects against brute-force attacks using
    rainbow tables. However, it doesn’t protect against *password spraying*, where
    attackers use a database of common passwords, or *credential stuffing*, where
    attackers enumerate on a list of compromised passwords.
  prefs: []
  type: TYPE_NORMAL
- en: During salting, the hashing function generates a random salt that appends to
    the plain password prior to hashing and then generates a hashed password.^([4](ch08.html#id982))
    Before storing the hashed password in the database, the salt is prefixed to the
    hashed password for later retrieval during verification.
  prefs: []
  type: TYPE_NORMAL
- en: When registered users try to log in, they have to supply the same password they
    used to create their account. During the password verification process, the password
    that the user provides is hashed using the same salt that was used during registration
    which is retrieved from the database. If the generated hashed password is exactly
    identical to the hashed password in the database, then the user is authenticated.
    Otherwise, you can safely assume that wrong credentials have been supplied.
  prefs: []
  type: TYPE_NORMAL
- en: The salting and hashing are powerful techniques that prevent attackers from
    brute-forcing their way into your system with rainbow tables. You can see the
    full hashing and salting process in [Figure 8-6](#password_hashing).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0806](assets/bgai_0806.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6\. Password hash salting mechanism
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The password service shown in [Figure 8-6](#password_hashing) is implemented
    as `PasswordService` in [Example 8-6](#password_service).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-6\. Implement a password service
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `AuthService` with a secret and password context managed by the `bcrypt`
    library that will handle all the user password hashing and verification.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `bcrypt`’s cryptography algorithm and application secret to hash and verify
    passwords.
  prefs: []
  type: TYPE_NORMAL
- en: The `bcrypt` cryptographic library provides the core functionality of the `Password​Ser⁠vice`
    for hashing and verifying passwords. Using this service, requests can now be authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: If a request can’t be authenticated, you will also need to raise authorization-related
    exceptions, as shown in [Example 8-7](#auth_exceptions).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-7\. Create authentication exceptions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The two most common authorization HTTP exceptions you will raise are related
    to unauthorized access or bad requests due to using already used usernames.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have checked a user’s identity via their credentials, you will need
    to issue them an *access token*. These tokens should be short-lived to reduce
    the time-window that an attacker can use the token to access resources if the
    token is stolen.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the size footprints of the tokens and protect against *token forgery*,
    the token service will sign (using a secret) and encode the token payloads with
    an encoding such as Base64. The payload will normally contain the user’s details
    such as their ID, role, issuance system, and expiry dates.
  prefs: []
  type: TYPE_NORMAL
- en: The token service can also decode the payload of received tokens and check their
    validity during the authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the token service will also require database access to store and retrieve
    tokens to perform its functions. Therefore, it should inherit a `TokenRepository`,
    as shown in [Example 8-8](#token_repository).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-8\. Implementing token repository
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With the `TokenRepository` implemented, you can now develop the `TokenService`,
    as shown in [Example 8-9](#token_service).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-9\. Implement a token service by inheriting the token repository
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a `TokenService` for issuing and checking authentication tokens. Configurations
    are shared across all instances of the service.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Generate access tokens based on data provided to the token service with expiry
    dates.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a token record in the database and get a unique identifier.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_authentication_and_authorization_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The access token must expire within an hour, so the `exp` calculated field will
    be used to check token validity.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_authentication_and_authorization_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Encode the generated token into an encoded string using the `base64` algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a `PasswordService` and a `TokenService`, you can complete
    the core JWT authentication mechanism with a dedicated higher-level `AuthService`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 8-10](#auth_service) shows the implementation of the `AuthService`
    class that contains several dependency functions for registering users, issuing
    access tokens, and protecting your API routes.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-10\. Implement an auth service to handle higher-level authentication
    logic
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The core authentication logic of the application that verifies whether a user
    exists and their password credentials. Returns `False` if any checks fail.
  prefs: []
  type: TYPE_NORMAL
- en: You can now use the `AuthService` to register and authenticate users using their
    credentials. Refer to [Example 8-11](#auth_controllers) to see how the `AuthService`
    is used to create the required dependencies for a dedicated authentication router.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-11\. Implement authentication controllers to enable login and registration
    functionality
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the `AuthService` and declare reusable annotated dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a separate API router for authentication endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Implement endpoints for registering users, user login (token issuance), user
    logout (token revocation), and password reset.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_authentication_and_authorization_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Since the `LogoutUserDep` dependency won’t return anything, inject it within
    the dependency array of the router.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a dedicated authentication router, create a separate resource
    router to group all your resource endpoints within. With both routers, you can
    now add them to your FastAPI app, as shown in [Example 8-12](#routers), to complete
    the JWT authentication work.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-12\. Refactor FastAPI application to use routers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Refactor existing endpoints to be grouped under a separate API router named
    the resource router.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Add both auth and resource routers to the FastAPI `app` router.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Protect the resource endpoints by injecting the `AuthenticateUserDep` dependency
    at the router level. Requests must now include an `Authorization` header with
    a bearer token to be authenticated with the resource router.
  prefs: []
  type: TYPE_NORMAL
- en: Massive congratulations! You now have a fully working GenAI service protected
    by JWT authentication, which can be deployed to production with some additional
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll learn a few ideas on additional enhancements you
    can make to the system to tighten the security of your JWT authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication flows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need to handle several authentication flows to fully implement a usable
    JWT authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *core* authentication flows include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: User registration
  prefs: []
  type: TYPE_NORMAL
- en: New users will want to register a new account by providing their emails and
    a secure password. Your authentication logic may check for password strength,
    no existing users with the same email, and that the user reconfirms the password
    and email. You should also avoid storing the user’s raw password in the database.
  prefs: []
  type: TYPE_NORMAL
- en: User login
  prefs: []
  type: TYPE_NORMAL
- en: On each user login, your system can generate, store, and provide a unique temporary
    access token (i.e., JWT) if a user supplies their correct credentials. Your protected
    resource server routers should reject any incoming requests that don’t contain
    a valid JWT. Valid JWTs can be verified through their signature and checked against
    the valid tokens specified in the database.
  prefs: []
  type: TYPE_NORMAL
- en: User logout
  prefs: []
  type: TYPE_NORMAL
- en: When the user logs out, your system can revoke the currently issued token and
    prevent future malicious login attempts with the current token.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the core flows, you should also consider *secondary* flows to
    implement a production-ready authentication system. These flows could be used
    for:'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying identity
  prefs: []
  type: TYPE_NORMAL
- en: To prevent spambots from registering active accounts in your system and consuming
    server resources, you will want some form of user verification mechanism in place.
    For instance, add email verification by integrating an emailing server to your
    authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting passwords
  prefs: []
  type: TYPE_NORMAL
- en: Users can forget their passwords at any time. You will want to implement a flow
    for users to reset their passwords. If a user resets their password, all active
    tokens in the database against their user account must be revoked.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing logout
  prefs: []
  type: TYPE_NORMAL
- en: Revoke all previously generated access tokens of a user on all clients to prevent
    stolen tokens from being used to access the system.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling user accounts
  prefs: []
  type: TYPE_NORMAL
- en: Administrators or users may want to disable their accounts to prevent future
    login attempts.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting user accounts
  prefs: []
  type: TYPE_NORMAL
- en: This is required if users would like to remove their accounts from your systems.
    Depending on your data storage requirements, you may want to delete personally
    identifiable information while keeping other associated data.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking successive login attempts
  prefs: []
  type: TYPE_NORMAL
- en: Temporarily disable an account that has had multiple failed login attempts within
    a short time span.
  prefs: []
  type: TYPE_NORMAL
- en: Providing refresh tokens
  prefs: []
  type: TYPE_NORMAL
- en: Generate both short-lived *access* tokens and long-lived *refresh* tokens. Since
    access tokens can expire frequently to reduce the window of opportunity for attackers
    to use a stolen token, clients can reuse their refresh token to request new access
    tokens. This removes the need for frequent logins while maintaining security of
    the system against attackers.
  prefs: []
  type: TYPE_NORMAL
- en: Two-factor authentication (2FA) or multifactor authentication (MFA)
  prefs: []
  type: TYPE_NORMAL
- en: You can secure your system against exposed password-protected accounts by requiring
    2FA or MFA as an additional protection layer. 2FA/MFA examples include SMS/email
    verification, one-time passwords (OTPs), or randomly generated number sequences
    from a paired authentication app as a second login step before an access token
    can be generated.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The aforementioned list is not exhaustive. You may want to check out [“OWASP
    Top 10 Web Applications Security Risks”](https://oreil.ly/xAGfn) and [“OWASP Authentication
    Cheat Sheet”](https://oreil.ly/oSyuz) for the full list of considerations when
    implementing your own JWT authentication from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to following the OWASP top 10 guidelines, you should use security
    mechanisms such as *rate limiting*, *geo/IP-tracking*, and *account lockouts*
    to defend against various attacks.
  prefs: []
  type: TYPE_NORMAL
- en: You can also consider using third-party authentication providers (such as Okta/Auth0,
    Firebase Auth, KeyCloak, Amazon Cognito, etc.) that include these security features
    in their services.
  prefs: []
  type: TYPE_NORMAL
- en: While credentials-based authentication using JWTs can be considered a production-ready
    authentication system and be further enhanced with MFA systems in place, the mechanism
    has its own limitations. For instance, as previously mentioned, requiring credentials
    and storing hashed passwords in a database can retain security risks if attackers
    leverage password spraying or credential stuffing brute-force attacks.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if you require access to user resources external to your system,
    you will need to implement additional mechanisms to verify your application’s
    identity to external identity providers. Since this remains a common need in many
    applications and services, a protocol called OAuth has been developed to facilitate
    the whole process.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how you can use OAuth authentication to add more login options
    for users and access external user resources. This can enhance the performance
    of your GenAI services and generate higher-quality outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing OAuth Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We touched upon the concept of OAuth authentication via identity providers earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth is an open standard for access delegation, often used to grant websites
    or applications limited access to user information without exposing passwords.
    It allows you to authenticate users using identity providers such as Google, Facebook,
    etc., and grants your application access to user resources like calendars, files,
    social feeds, etc., on external services.
  prefs: []
  type: TYPE_NORMAL
- en: By using OAuth, you can simplify the implementation of authentication in your
    app by leveraging existing identity providers instead of creating your own authentication
    mechanisms such as JWT.
  prefs: []
  type: TYPE_NORMAL
- en: '*Identity providers* (IDPs) are platforms that enable other applications, such
    as your GenAI service, to integrate with and rely on their identity and authentication
    systems to access resources on behalf of users via a standardized process. The
    IDP authenticates users and issues security tokens that assert the user’s identity
    and other attributes. GitHub, Google, Microsoft 365, Apple, Meta, and LinkedIn
    are only a handful of hundreds of identity providers.'
  prefs: []
  type: TYPE_NORMAL
- en: The protocol powering this entire flow under the hood is *OAuth 2.0*, an authorization
    framework giving applications limited access to another service on behalf of a
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Using this approach, your application can redirect users to identity provider
    platforms so that users can grant limited timed access to their accounts on those
    platforms. After the user gives consent, your application can perform operations
    on their behalf on their resources like calendars or read their profile information
    including personally identifiable information such as emails or images.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, OAuth authentication is often used to verify the identity of users
    as you trust the external platform/identity provider’s authentication process.
    Therefore, this approach reduces the burden of storing and securing user credentials
    in your system, which can be prone to brute-force attacks on weak or compromised
    passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you’re going to implement a variant of OAuth based on the
    *authorization code flow* that’s commonly used in modern applications. The step-by-step
    process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user clicks the login button in your application to start the authentication
    flow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is redirected to the identity provider’s login page, and your application
    supplies a client ID and secret to the identity provider to identify itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user logs into their account and is presented with a consent screen like
    the one shown in [Figure 8-7](#oauth2_consent_screen) presenting them the scopes
    (i.e., permissions) that your application is requesting on their behalf.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![bgai 0807](assets/bgai_0807.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 8-7\. Example consent screen
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: The user grants all, some, or none of the requested scopes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If consent is not rejected by the user (i.e., the resource owner), the identity
    provider’s authorization server issues your application a *grant code* to an endpoint
    that you provide called the *redirect URI*. If your redirect URI is not previously
    approved with the identity provider, the identity provider will reject to issue
    a grant code here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After your application receives a grant code associated with the user session,
    permitted scopes, and your application’s client ID, it can exchange this grant
    code with the authorization server for a *short-lived access token* and a *longer-lived
    refresh token*. You can use the refresh token to request new access tokens without
    having to restart the whole authentication process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your application can now use this access token to access the provider’s resource
    server to perform operations on behalf of the user on their resources. As a result,
    you can authenticate the user via the identity provider to resources on your system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Through the OAuth process, the authorization server may also issue a *state*
    parameter or *CSRF token*, which your application must supply as it communicates
    with the identity provider’s servers. The purpose of the state parameter or CSRF
    token is to protect against cross-site request forgery (CSRF) attacks.
  prefs: []
  type: TYPE_NORMAL
- en: With CSRF, attackers may steal an authenticated session to forge authenticated
    requests to the resource servers without the user’s knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-8](#oauth2) shows the full OAuth authentication flow.'
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0808](assets/bgai_0808.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-8\. OAuth authentication flow
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you have a high-level overview of the OAuth authentication flow, let’s
    implement it inside FastAPI with an identity provider such as GitHub to fully
    understand the underlying mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth Authentication with GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step to setting up the OAuth authentication is to create a set of
    client ID and secret credentials within GitHub so that their systems can identify
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: You can generate a client ID and secret from GitHub by visiting the developer
    settings under your GitHub profile and creating an OAuth application.^([5](ch08.html#id994))
  prefs: []
  type: TYPE_NORMAL
- en: With your new application client ID and secret, you can now redirect users to
    the GitHub authorization server from your application by following [Example 8-13](#oauth_redirect).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-13\. Redirect users to the GitHub authorization server to start the
    OAuth process
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Redirect user to the GitHub authorization server to log into their account while
    supplying your application credentials, a requested scope, and a CSRF state value
    to prevent against CSRF attacks.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Example 8-13](#oauth_redirect), the scope of the request
    is the user, meaning that once users log into their GitHub account, they will
    be presented with a consent screen for your application to be granted access to
    their user profile.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a backend endpoint redirecting requests to the GitHub authorization
    server, you can put a button in your client-side application to hit this endpoint
    and start the OAuth process with GitHub (see [Example 8-14](#oauth_client)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-14\. Adding a GitHub login button to the Streamlit client-side application
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You now have implemented the redirect flow that starts the OAuth authentication
    process with GitHub as the identity provider.
  prefs: []
  type: TYPE_NORMAL
- en: When users log into their GitHub account, GitHub will show them a consent screen
    similar to [Figure 8-7](#oauth2_consent_screen).
  prefs: []
  type: TYPE_NORMAL
- en: If the user accepts the consent, GitHub will redirect the user back to your
    application with a grant code and a state. You should check whether the state
    matches the previously generated state.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the states do not match, a third party has made the request, and you should
    stop the process.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the grant code, you can send this to the GitHub authorization
    to exchange it for an access token, as shown in [Example 8-15](#oauth_exchange).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-15\. Exchanging grant code with an access token while protecting against
    CSRF attacks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can now add a new endpoint that accepts requests from the GitHub authorization
    server. This callback endpoint should have a CSRF protection to guard against
    third parties impersonating the authorization server. If the request from GitHub
    is forged, the state parameter provided and the one stored in the request session
    won’t match.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 8-16](#oauth_callback) shows the callback endpoint implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-16\. Implement callback endpoint to get access token while protecting
    against CSRF attacks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In [Example 8-16](#oauth_callback), you are using the request session for CSRF
    protection, but this won’t work without adding the Starlette’s `SessionMiddlware`
    first to maintain a secure user session that’s only mutable on the server side,
    as shown in [Example 8-17](#oauth_session).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-17\. Add a session middleware to manage session state for protecting
    against CSRF attacks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Avoid relying on HTTP *cookies* to store and read the `state` between request
    sessions as cookies can be read and manipulated by third parties. Never trust
    any data that comes from the client.
  prefs: []
  type: TYPE_NORMAL
- en: By writing the unique `state` to the session in [Example 8-13](#oauth_redirect)
    and comparing it with the `state` value in the incoming request query parameters,
    you can then confirm the identity of the request.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the requester is the GitHub authorization server sending you a
    grant `code`. Once you receive the grant `code`, you then exchange it with the
    GitHub authorization server for an access token.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The process shown in the OAuth-related code examples can also be implemented
    with the open source `authlib` package for simpler implementation, as the package
    handles most of the work for you.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can use the access token you received from the authorization server
    to fetch user information such as their name, email, and profile image to register
    their identity in your application.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 8-18](#oauth_user_info) demonstrates how to implement an endpoint
    that returns the user info from GitHub if the request supplies an access token
    as part of the request’s authorization header.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Ideally, you should avoid sharing the user’s GitHub access token with the user’s
    browser. If the token is stolen, your application is responsible for compromising
    the user’s GitHub account.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, create and share your own short-lived access token tied to the GitHub
    access token to authenticate the user with your application. If your application
    token is stolen, you avoid compromising user accounts beyond the scope of your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-18\. Use access token to get user information from GitHub resource
    servers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You should now have a working authentication system that leverages
    OAuth2 to authenticate users.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth2 Flow Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OAuth2 flow that you just implemented was the *authorization code flow*
    (ACF). However, there are other flows that you can choose depending on the use
    case. The identity provider documentation may present you with solutions for various
    flows, which can feel overwhelming if you’re not aware of these use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization code flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The authorization code flow is the common approach for applications that leverage
    servers and backend APIs such as FastAPI, using code grants to issue access tokens.
  prefs: []
  type: TYPE_NORMAL
- en: A more secure variant of ACF leverages *proof key for exchange* (PKCE, pronounced
    “pixie”). You can use the ACF-PKCE flow where you cannot protect the authorization
    code from being stolen—for instance, on mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: During the ACF-PKCE flow, you add a hashed secret called the `code_challenge`
    when sending the initial request to the identity provider. Then you present the
    unhashed secret `code_verifier` again to exchange the authorization code for an
    access token.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, PKCE protects against *authorization code interception* attacks—shown
    in [Figure 8-10](#oauth_interception_attack)—by adding a layer of verification
    during the token exchange process.
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0810](assets/bgai_0810.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-10\. OAuth2 authorization code interception attack on a mobile device
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Implicit flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For single-page applications (SPAs) where there is no separate backend, you
    can also use the *implicit flow*, which skips the authorization grant code to
    directly get an access token. Implicit flow is less secure than the previous flow
    but enhances the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Client credentials flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re building a backend service for machine-to-machine communication and
    where no browsers will be involved, then you can use the *client credentials flow*.
    Here you can exchange your client ID and secret for an access token to access
    your own resources on the identity provider servers (i.e., you won’t have access
    on behalf of other users).
  prefs: []
  type: TYPE_NORMAL
- en: Resource owner password credentials flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Resource owner password credentials flow* is like the client credentials flow
    but uses a username and password of the user to get an access token. As the credentials
    are being exchanged directly with the authorization server, you should avoid using
    this flow as much as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Device authorization flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, there is the *device authorization flow* that’s mostly used for devices
    with limited input capabilities, such as when you log into your Apple TV account
    on your smart TV by scanning a QR code and using a web browser from your phone.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-2](#oauth_flows_comparison) compares the various flows to help you
    select the right option for your own use case, based on your specific requirements
    and constraints.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2\. Comparison of OAuth2 authorization flows
  prefs: []
  type: TYPE_NORMAL
- en: '| Flow | Description | Considerations | Use cases |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Authorization code flow (including PKCE) | Get the authorization code via
    a user login and exchange for an access token. |'
  prefs: []
  type: TYPE_TB
- en: Provider’s access token must be securely stored and never exposed to the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use ACF-PKCE flow if possible for enhanced security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Server-side applications and web applications with a backend server that can
    securely handle the client secret and access tokens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile applications if using a PKCE token as client credentials can’t be securely
    stored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Implicit flow | Get an access token without an authorization code. |'
  prefs: []
  type: TYPE_TB
- en: Less secure as the access token is exposed to the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use when using the authorization code flow is not possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Single-page applications (SPAs) where user experience is prioritized over
    security, when prototyping, or where the authorization code flow is not possible.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Client credentials flow | The client directly exchanges its client credentials
    (client ID and client secret) for an access token. | No user interaction involved,
    meant for scenarios where the client is acting on its own behalf. Ensure secure
    storage of client credentials. | Server-to-server applications. |'
  prefs: []
  type: TYPE_TB
- en: '| Resource owner password credentials flow | Exchange user’s username and password
    directly for an access token. |'
  prefs: []
  type: TYPE_TB
- en: High security risk as user’s credentials are handled directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only use in legacy systems where other flows are not supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Legacy applications or highly trusted environments. |'
  prefs: []
  type: TYPE_TB
- en: '| Device authorization flow | Visit a URL on another device to enter a code
    for an access token. | Requires a second device with a web browser for the user
    to authenticate. | Devices with limited input capabilities, like smart TVs, gaming
    consoles, or IoT devices. |'
  prefs: []
  type: TYPE_TB
- en: You should now feel more confident in securing your application with a variety
    of commercial identity verification mechanisms, including the various OAuth2 flows
    that leverage external IDPs.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication forms the first step to securing your services by identifying
    who the users of your system are.
  prefs: []
  type: TYPE_NORMAL
- en: 'A question remains: what should happen when a user is logged into your services?
    Can they fetch data, interact with models, and mutate resources as they please,
    or would you rather control their interactions in your services?'
  prefs: []
  type: TYPE_NORMAL
- en: These are problems that an authorization system will tackle, which we will talk
    about next.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve been covering various authentication mechanisms including the
    basic, token-based (JWT), and OAuth2 for securing your applications.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, authentication systems identify and verify actors, whereas
    the authorization systems enforce *permissions* in an application (i.e., who can
    do what on which resource).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you’re going to learn about the authorization system that
    takes into account the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The *actor* (i.e., the user or a third-party service acting on behalf of the
    user)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *action* being undertaken
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The impact of the action on *resources*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In essence, an authorization system can be compared to a function that accepts
    three inputs—*actor*, *action*, *resource*—and returns a *Boolean decision* to
    *allow* or *deny* a request. To implement the authorization function, you will
    require *authorization data* such as user attributes, relationships (like team/group/org
    memberships), resource ownership, roles, and permissions passed through a set
    of *abstract rules* to determine the Boolean allow/deny decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Once a decision is made, you can *enforce* the authorization by either allowing
    actions (such as fetching or mutating resources) or denying requests (such as
    sending 403 Forbidden responses, redirecting users, hiding resources, locking
    accounts, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: On the surface level, implementing authorization can be simple. Using a few
    conditional statements, you can check whether a user has permissions to perform
    an action. However, this naive approach can get complex to manage as the number
    of places you need to implement authorization steps increases. This issue becomes
    worse as you make changes to the logic across the application, making the system
    complex and adding finer controls. You may end up duplicating logic or making
    future changes more difficult, and the authorization rules may deeply be interwoven
    in your application logic, making separation from the rest of the application
    more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, authorization models can be useful to help you navigate the complexity
    of managing authorization decisions and enforcements in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few common *authorization models* that you can learn to make structuring
    and implementing an authorization system easier:'
  prefs: []
  type: TYPE_NORMAL
- en: Role-based access control (RBAC)
  prefs: []
  type: TYPE_NORMAL
- en: Authorization is based on the roles assigned to users, where each role has specific
    permissions. For instance, administrators can access every available GenAI model,
    bypassing authorization rules enforced on users.
  prefs: []
  type: TYPE_NORMAL
- en: Relationship-based access control (ReBAC)
  prefs: []
  type: TYPE_NORMAL
- en: Authorization is determined by the relationships between entities, such as user-to-user
    (i.e., follower, friend, connection) or user-to-resource (i.e., group, team, org)
    relationships. For instance, this could authorize a user who is a member of a
    team to access premium models purchased by that team.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute-based access control (ABAC)
  prefs: []
  type: TYPE_NORMAL
- en: Authorization decisions are made based on attributes of users, resources, and
    the environment, allowing for fine-grained access control. For instance, a conversation
    with a *public* attribute is viewable by everyone, and a user with a *paid* attribute
    can access premium GenAI models.
  prefs: []
  type: TYPE_NORMAL
- en: RBAC is the simplest authorization model but won’t provide the enhanced granular
    controls and flexibility of other authorization models. ABAC controls provide
    more fine-grained access control and can override both ReBAC and RBAC rules. Furthermore,
    ReBAC can also override or extend RBAC controls.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-4](#authorization_methods_comparison) compares the three authorization
    models.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-4\. Comparison of authorization methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Benefits | Limitations | Use cases |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Role-based (RBAC) | Simplifies management | Limited flexibility | Enterprise
    environments, access control, financial systems, healthcare systems |'
  prefs: []
  type: TYPE_TB
- en: '| Relationship-based (ReBAC) | Fine-grained control | Needs relationship data
    from various sources with complex permission evaluations | Social networks, collaborative
    platforms, content-sharing applications, project management tools |'
  prefs: []
  type: TYPE_TB
- en: '| Attribute-based (ABAC) | Highly flexible | Needs attribute data from various
    sources with complex permission evaluations | Dynamic environments, cloud services,
    IoT systems, regulatory compliance, personalized user experiences |'
  prefs: []
  type: TYPE_TB
- en: These three authorization models also have a hierarchical relationship, as demonstrated
    in [Figure 8-11](#authorization_models).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0811](assets/bgai_0811.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-11\. Authorization models
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s now discuss each authorization model in detail, starting with the RBAC
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Role-Based Access Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using *roles* is a widely adopted model for implementing authorization in applications
    due to their simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Roles are straightforward to understand. They normally correspond to whom the
    user is and what they want to do in the application. Sometimes authorization roles
    can directly map to roles in your organization’s hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: You can group permissions under a role that can then be *assigned* to users
    to grant user those permissions. A *permission* specifies the action that a user
    can take on resources, such as if the user can interact with the paid LLM model
    provided by your service.
  prefs: []
  type: TYPE_NORMAL
- en: For better administrative and user experience, you can create multiple roles
    with preset permissions to reduce decision fatigue when setting user permissions.
    Instead of having to set a vast number of permissions, you can assign a few predefined
    roles.
  prefs: []
  type: TYPE_NORMAL
- en: A common starting point for many commercial services is user and administrator
    roles. While a member can access the core functionality of the application such
    as interacting with GenAI models, and reading and writing resources, they won’t
    be able to view data of other users or manage roles. On the other hand, administrators
    can assign and remove roles, view and mutate every resource, or disable and enable
    accounts. Administrators may also have access to early features such as GenAI
    models that normal users can’t access yet, as shown in [Figure 8-12](#rbac_example).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0812](assets/bgai_0812.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-12\. RBAC example where only administrators have access to image-based
    GenAI models
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can implement a simple RBAC authorization model to control the GenAI services
    that your users can access, as shown in [Example 8-19](#rbac).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-19\. Implementing RBAC using FastAPI dependencies
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `is_admin` authorization dependency guard on top of the `Auth​Ser⁠vice.get_current_user`
    dependency. Mark the function as `async` since the child dependency is performing
    an async operation against the database.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the authorization guard dependency to deny access to the image generation
    service for nonadmin authenticated users.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Nonadmin authenticated users can still access other resource controllers since
    the router is secured by an authentication guard dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Using the same logic shown in [Example 8-19](#rbac), you can construct varying
    system prompt templates or use different model variants fine-tuned to each role.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Bear in mind that implementing authorization at the application layer is more
    secure than delegating it to the GenAI model. LLMs and other GenAI models can
    be vulnerable to *prompt injection* attacks where an attacker manipulates the
    input to the model to bypass system instructions to produce unauthorized and harmful
    outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Future versions of LLMs and other GenAI models may mitigate prompt injection
    risks by enforcing custom authorization rules internally using extensions like
    the *control neural network (ControlNet)* in Stable Diffusion models.
  prefs: []
  type: TYPE_NORMAL
- en: To create more complex RBAC authorization logic than the one shown in [Example 8-19](#rbac),
    you can implement *subdependencies* or an *abstract dependency*. Both approaches
    will leverage FastAPI’s powerful *hierarchical dependency graphs* as authorization
    guards to enforce permissions in your GenAI service.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, if you add new roles in the future that inherit a subset of permissions
    of another role (i.e., moderators and admins), then you can follow either of the
    approaches shown in [Figure 8-13](#complex_rbac_approaches).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0813](assets/bgai_0813.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-13\. Approaches for implementing complex RBAC models
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can implement complex RBAC authorization logic using abstract dependencies,
    as shown in [Example 8-20](#complex_rbac_abstract).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-20\. Implementing complex RBAC authorization using abstract dependencies
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In summary, RBAC simplifies permission management by assigning permissions to
    roles rather than individuals, making it easier to manage and audit. It is scalable
    and efficient for organizations with well-defined roles and responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: However, RBAC can lead to role explosion when many granular roles are necessary,
    making it hard to manage. It also lacks the flexibility to handle complex hierarchical
    relationships like teams and groups alongside setting dynamic permissions based
    on attributes like user preferences, time, and privacy settings, which limits
    its granularity compared to ReBAC or ABAC.
  prefs: []
  type: TYPE_NORMAL
- en: Relationship-Based Access Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Relationship-based access control* is an extension of RBAC with a focus on
    relationships between resources and users.'
  prefs: []
  type: TYPE_NORMAL
- en: With this mode, instead of just setting roles at the user level across the entire
    application, you must set roles and permissions at the resource level. This means
    you will have to confirm the actions each role can take on every resource type.
    For example, instead of assigning a “moderator” role to a user that grants access
    to all resources (i.e., conversations, teams, users, etc.), you would assign specific
    permissions to the moderator role for each resource. A moderator might have read
    and delete permissions on the conversation resource but only read permission on
    the team resource.
  prefs: []
  type: TYPE_NORMAL
- en: This model allows you to create authorization policies based on hierarchical
    and nested structures within your data and be visualized as graphs where nodes
    can be represented as resources/identities and edges as relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Since you can create authorization rules based on relationships, this can save
    you lots of time setting permissions at an instance level. As an example, instead
    of sharing every private LLM conversation in your app one by one, you can group
    them under a team or a folder and share the folder or add members to the team
    instead. In ReBAC, children instances can inherit parent’s permissions, as shown
    in [Figure 8-14](#rebac_example). It’s the same for related instances if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0814](assets/bgai_0814.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-14\. Example ReBAC where a user can see the team’s private conversations
    and threads
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The example shown in [Figure 8-14](#rebac_example) demonstrates both organization
    and hierarchical relationships between users (i.e., teams and members) and resources
    (conversations and threads).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you decide to adopt the ReBAC model, I recommend visually mapping out the
    relationships between resources and identities in your application.
  prefs: []
  type: TYPE_NORMAL
- en: This work includes mapping out *policies* (i.e., rules), *resources* and available
    *actions* on them, *resource-level roles*, and *relationships* between entities.
  prefs: []
  type: TYPE_NORMAL
- en: A big problem that ReBAC solves by extending RBAC is the explosion of roles
    within the RBAC model by combining relationships with roles. It is ideal for managing
    permissions in complex hierarchical structures and allows for reverse queries,
    enabling efficient permission definitions using teams and groups. However, ReBAC
    can be complex to implement and maintain, resource-intensive, difficult to audit,
    and not as fine-grained as ABAC for dynamic permissions based on attributes like
    time or location.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute-Based Access Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Attribute-based access control* authorization model expands basic RBAC roles
    by setting access control rules based on *conditions applied to attributes* to
    implement more granular policies. As an example, ABAC can prevent users from uploading
    sensitive documents into your RAG-enabled services if the document contains *personally
    identifiable information (PII)* (i.e., `upload.has_pii=true`).'
  prefs: []
  type: TYPE_NORMAL
- en: Another example of ABAC can be seen in SaaS applications like ChatGPT where
    only paid users have access to the service’s premium GenAI models (see [Figure 8-15](#abac_example)).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0815](assets/bgai_0815.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-15\. ABAC example where only paid users have access to premium GenAI
    models
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Since the freedom to set policies based on attributes is infinite, the ABAC
    model allows for significantly fine-grained authorization policies. However, ABAC
    can be cumbersome for managing hierarchical structures, making it challenging
    to determine which users have access to a specific resource. For example, if you
    have a policy that grants access based on attributes like user role, data sensitivity
    level, and project membership, determining all users who can access a specific
    dataset requires evaluating these attributes for every user.
  prefs: []
  type: TYPE_NORMAL
- en: While less complicated than ReBAC, ABAC can still be challenging to implement,
    in particular in large and complex applications that support a large number of
    roles, users, and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid Authorization Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve worked with larger applications in the past, you will notice that
    they combine features of the RBAC, ReBAC, and ABAC authorization models. For instance,
    administrators may have access to any resource and user management/authentication
    features (RBAC), and users can share their private resources by setting visibility
    attribute to `public` (ABAC) and can add members to their team for collaborating
    on private resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'A hybrid approach combining RBAC, ReBAC, and ABAC models may give you the strengths
    of all the authorization models:'
  prefs: []
  type: TYPE_NORMAL
- en: RBAC simplifies permission management by assigning roles to users, making it
    easy to manage and audit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReBAC is perfect for managing hierarchical relationships and reverse queries,
    making it suitable for complex hierarchical structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ABAC provides fine-grained control based on user and resource attributes, allowing
    for dynamic and context-aware permissions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 8-16](#authorization_hybrid) demonstrates the hybrid authorization
    model.'
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0816](assets/bgai_0816.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-16\. Hybrid authorization model based on roles, relationships, and
    attributes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To implement the hybrid authorization combining RBAC, ReBAC, and ABAC models,
    you can follow [Example 8-21](#rbac_rebac_abac).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-21\. Implementing the hybrid authorization model combining RBAC, ReBAC,
    and ABAC
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you define rules and permissions based on each authorization model, you also
    may decide to bypass rules if certain conditions are met. This can lead to complex
    logic and create a maintenance burden on your application code.
  prefs: []
  type: TYPE_NORMAL
- en: Since implementing a hybrid model can be complex, you may consider developing
    a separate authorization service to eliminate the need for significant code changes
    with volatile permissions that change frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Using an external system for authorization decisions allows your application’s
    authorization logic to remain consistent, as shown in [Figure 8-17](#authz_separate).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0817](assets/bgai_0817.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-17\. Separating the authorization service from the GenAI service
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Example 8-22](#authorization_separate_example) shows how to develop a separate
    authorization system.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-22\. Using an authorization service with the GenAI service
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in [Example 8-22](#authorization_separate_example), using an
    external system to authorize user actions on resources helps you and your team
    to modularize authorization logic with more complex and volatile permission requirements.
  prefs: []
  type: TYPE_NORMAL
- en: However, since developing a complex external authorization service from scratch
    can take a lot of your time, you may want to consider using authorization providers
    (such as Oso, Permify, Okta/Auth0, etc.) with your authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about both authentication and authorization mechanisms
    to secure your GenAI services.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the chapter, you were introduced to several authentication methods,
    including basic, token-based, OAuth, and key-based authentication. To gain hands-on
    experience, you implemented several authentication systems from scratch in your
    FastAPI service, which helped you understand the underlying mechanisms. This included
    managing user passwords, creating and using JWT access tokens, and implementing
    authentication flows for user verification. Additionally, you learned how to integrate
    your services with identity providers like GitHub using the OAuth2 standard to
    authenticate users and access external user resources in your application.
  prefs: []
  type: TYPE_NORMAL
- en: While you were building the authentication system, you also learned about attack
    vectors such as credential stuffing, password spraying, cross-site request forgery,
    open redirect, and phishing attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, you explored authorization systems that determine and enforce access
    levels based on authorization data and logic. You learned how authorization systems
    can become complex and how different models, including RBAC, ReBAC, and ABAC,
    can assist in managing permissions in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will focus on testing, including writing unit, integration,
    end-to-end, and regression tests. You’ll be introduced to concepts like testing
    boundaries, coverage, mocking, patching, parameterization, isolation, and idempotency,
    which will help you write maintainable and effective tests as your applications
    grow in complexity. Specifically, you’ll learn how to test GenAI services that
    use probabilistic models and interface with asynchronous systems.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch08.html#id970-marker)) Open Worldwide Application Security Project is
    an online community that produces resources on system software and web application
    security.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch08.html#id971-marker)) Key-based authentication won’t be discussed further
    as it involves complex cryptographic principles that are beyond the scope of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch08.html#id972-marker)) In a *timing attack*, attackers try to guess
    passwords by comparing and analyzing elapsed password evaluation times with the
    password length. Therefore, to prevent timing attacks, cryptographic algorithms
    must check passwords within a constant time span.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch08.html#id982-marker)) Typical salt lengths include 16 bytes (128 bits)
    for balancing performance and security, or 32 bytes (256 bits) for securing sensitive
    systems. You can use cryptographic libraries such as `passlib` to generate these
    salts correctly.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch08.html#id994-marker)) For up-to-date instructions, please visit [the
    GitHub documentation](https://oreil.ly/tWg6w).
  prefs: []
  type: TYPE_NORMAL
