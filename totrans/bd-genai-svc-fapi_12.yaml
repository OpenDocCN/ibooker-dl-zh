- en: Capitolo 8\. Autenticazione e autorizzazione
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。身份验证和授权
- en: 'Questo lavoro è stato tradotto utilizzando l''AI. Siamo lieti di ricevere il
    tuo feedback e i tuoi commenti: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这项工作使用AI进行翻译。我们很高兴收到您的反馈和评论：[translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)
- en: Finora hai costruito servizi GenAI in grado di interagire con i database, di
    trasmettere le risposte dei modelli e di gestire utenti simultanei.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经构建了能够与数据库交互、传输模型响应和处理同时用户的服务。
- en: I tuoi servizi sono ora attivi e funzionanti, ma poiché non sono protetti da
    aggressori o utenti malintenzionati, la loro distribuzione in produzione potrebbe
    rivelarsi problematica.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你的服务现在已激活并运行，但由于它们没有受到攻击者或恶意用户的保护，因此在生产环境中的部署可能会出现问题。
- en: In questo capitolo imparerai a proteggere i tuoi servizi con un livello di autenticazione
    e a implementare le protezioni di autorizzazione per proteggere le risorse sensibili
    dagli utenti non privilegiati.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何通过身份验证级别来保护你的服务，并实施授权保护来防止非特权用户访问敏感资源。
- en: Per raggiungere questo obiettivo, Go esplorerà vari modelli di autenticazione
    e autorizzazione e implementerà JWT e l'autenticazione basata sull'identità con
    il controllo degli accessi basato sui ruoli.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目标，Go将探索各种身份验证和授权模型，并实施JWT和基于身份的认证以及基于角色的访问控制。
- en: Autenticazione e autorizzazione
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**身份验证和授权**'
- en: Prima di parlare dei metodi di autenticazione, chiariamo brevemente che l'autenticazione
    e l'autorizzazione sono due concetti distinti che spesso vengono usati per errore
    in modo intercambiabile.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论身份验证方法之前，我们简要说明一下，身份验证和授权是两个不同的概念，它们经常被错误地互换使用。
- en: Secondo la definizione di OWASP:^([1](ch08.html#id970))
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 根据OWASP的定义：^([1](ch08.html#id970))
- en: L*'autenticazione* è il processo di verifica che un individuo, un'entità o un
    sito web sia chi o cosa dichiara di essere, determinando la validità di uno o
    più autenticatori (come password, impronte digitali o token di sicurezza) che
    vengono utilizzati a sostegno di questa dichiarazione.
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**身份验证**是验证一个人、实体或网站是否是其声明的身份的过程，通过确定一个或多个用于支持此声明的身份验证者（如密码、指纹或安全令牌）的有效性。'
- en: 'D''altra parte, il National Institute of Standards and Technology (NIST) definisce
    l''autorizzazione come:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，美国国家标准与技术研究院（NIST）将授权定义为：
- en: Un processo per verificare che un'azione o un servizio richiesto sia approvato
    per un'entità specifica.
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个验证所需动作或服务是否被特定实体批准的过程。
- en: Mentre l'autenticazione riguarda la verifica dell'identità, l'autorizzazione
    si concentra sulla verifica dei permessi di un'identità per accedere o modificare
    le risorse.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然身份验证涉及身份的验证，但授权则集中在验证一个身份访问或修改资源的权限。
- en: Suggerimento
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '**建议**'
- en: L'autenticazione è come presentare il passaporto all'immigrazione, mentre l'autorizzazione
    è come avere il visto giusto per entrare in un paese, specificando la durata del
    soggiorno e le attività consentite una volta entrati.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证就像在移民局出示护照，而授权则像是拥有正确的签证进入一个国家，指定停留时间和允许的活动。
- en: Parliamo dei metodi di autenticazione in modo più dettagliato, prima di affrontare
    il tema dell'autorizzazione più avanti nel capitolo.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论授权这一章的后面部分之前，让我们更详细地讨论身份验证方法。
- en: Metodi di autenticazione
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**身份验证方法**'
- en: Esistono diversi meccanismi di autenticazione che puoi implementare nei tuoi
    servizi GenAI per renderli sicuri attraverso la verifica dell'identità.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的GenAI服务中，你可以实施多种身份验证机制，以确保通过身份验证来提高安全性。
- en: 'A seconda dei requisiti di sicurezza, dell''ambiente applicativo, del budget
    e delle tempistiche del progetto, puoi decidere di adottare uno o più dei seguenti
    meccanismi di autenticazione:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据安全要求、应用程序环境、预算和项目时间表，你可以决定采用以下一个或多个身份验证机制：
- en: Di base
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本**'
- en: Richiedere l'uso di credenziali come nome utente e password per verificare l'identità.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请求使用用户名和密码等凭证来验证身份。
- en: Gettoni web JSON (JWT)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Web JSON令牌（JWT）
- en: I token di *accesso* possono essere considerati come i biglietti del cinema
    che stabiliscono se puoi accedere agli schermi, quale schermo stai visitando e
    dove sei seduto.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问令牌**可以被视为电影票，确定你是否可以进入放映厅，你正在参观哪个放映厅以及你坐在哪里。'
- en: OAuth
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth
- en: Verifica di un'identità tramite un provider di identità utilizzando lo standard
    *OAuth2*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用标准*OAuth2*通过身份提供者验证身份。
- en: Basato sui tasti
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 基于按钮
- en: Utilizza una coppia di chiavi private e pubbliche per autenticare un'identità.
    Invece dei token, il server di autorizzazione rilascia una chiave pubblica al
    cliente e memorizza una copia di una chiave privata collegata che può utilizzare
    in seguito per la verifica.^([2](ch08.html#id971))
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一对公钥和私钥来验证身份。而不是token，授权服务器向客户端发布一个公钥，并存储一个关联私钥的副本，该副本可以随后用于验证.^([2](ch08.html#id971))
- en: La[Figura 8-1](#authentication_methods) mostra il flusso di dati dei metodi
    di autenticazione sopra citati in modo più dettagliato.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-1](#authentication_methods)展示了上述认证方法的详细数据流。'
- en: '![bgai 0801](assets/bgai_0801.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0801](assets/bgai_0801.png)'
- en: Figura 8-1\. Metodi di autenticazione
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-1\. 认证方法
- en: Conoscendo i meccanismi di autenticazione, può essere difficile decidere quale
    metodo adottare per soddisfare i tuoi requisiti di sicurezza. Per aiutarti nella
    scelta, la[Tabella 8-1](#authentication_methods_comparison) mette a confronto
    i suddetti metodi di autenticazione.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 了解认证机制后，可能很难决定采用哪种方法来满足你的安全需求。为了帮助你做出选择，[表8-1](#authentication_methods_comparison)对这些认证方法进行了比较。
- en: Tabella 8-1\. Confronto tra i metodi di autenticazione
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-1\. 认证方法对比
- en: '| Tipo | Vantaggi | Limitazioni | Casi d''uso |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 优点 | 局限性 | 用例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Di base |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 基础 |'
- en: Semplicità
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单性
- en: Veloce da implementare
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现快速
- en: Facile da capire
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于理解
- en: '| Invia le credenziali in testo normale |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 以明文形式发送凭证 |'
- en: Prototipi
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型
- en: Ambienti interni o non di produzione
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部或非生产环境
- en: '|'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Gettone |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 令牌 |'
- en: Scalabilità
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Il disaccoppiamento facilita l'implementazione di architetture a microservizi
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦简化了微服务架构的实施
- en: I token possono essere firmati e crittografati per una maggiore sicurezza.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: token可以进行签名和加密以提高安全性。
- en: Altamente personalizzabile
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度可定制
- en: Autosufficiente per ridurre i viaggi del database
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自给自足以减少数据库的旅行
- en: Può essere passato nelle intestazioni HTTP
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过HTTP头部传递
- en: '|'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Necessità costante di rigenerare gettoni di breve durata
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要不断重新生成短期token
- en: Complessità della memorizzazione dei token sul lato client
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端端token存储的复杂性
- en: I token possono diventare grandi e consumare una larghezza di banda eccessiva.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: token可能会变得很大，消耗过多的带宽。
- en: I token stateless possono rendere difficile l'implementazione di applicazioni
    multi-step
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态token可能使多步骤应用的实现变得困难
- en: Le configurazioni errate sul lato client possono compromettere i token
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端端的错误配置可能会危及token
- en: '|'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Applicazioni a pagina singola e per dispositivi mobili
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单页应用和移动设备应用
- en: Applicazioni che richiedono flussi di autenticazione personalizzati
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要自定义认证流程的应用
- en: API REST
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API REST
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| OAuth |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| OAuth |'
- en: Delega l'autenticazione a provider esterni
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将认证委托给外部提供者
- en: Basato su uno standard (OAuth2) e testato per gli scenari aziendali
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于标准（OAuth2）并针对企业场景进行测试
- en: Accesso a risorse esterne per conto dell'utente
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表用户访问外部资源
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Complesso da capire e da implementare
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和实现复杂
- en: Ogni fornitore di identità può implementare il flusso OAuth in modo leggermente
    diverso.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个身份提供者可以以略微不同的方式实现OAuth流程。
- en: '|'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Applicazioni che richiedono i dati degli utenti da fornitori di identità esterni
    come GitHub, Google o Microsoft.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要从外部身份提供者（如GitHub、Google或Microsoft）获取用户数据的程序。
- en: Applicazioni aziendali che richiedono l'SSO con i propri identity provider
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要与自己的身份提供者进行SSO的企业应用
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Basato sui tasti |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 基于按钮 |'
- en: Meccanismo di autenticazione simile all'accesso Secure Shell (SSH)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于Secure Shell (SSH)访问的认证机制
- en: '|'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Gestire e mantenere sicure le chiavi private può essere complesso
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理和维护私钥的安全可能很复杂
- en: Le chiavi compromesse possono creare rischi per la sicurezza
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被泄露的密钥可能带来安全风险
- en: Problemi di scalabilità
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性问题
- en: '|'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Piccole applicazioni
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型应用
- en: Applicazioni in ambienti interni
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部环境应用
- en: '|'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Nella prossima sezione, implementerai l'autenticazione di base, JWT e OAuth
    per il tuo GenAI per comprendere appieno i componenti sottostanti e le loro interazioni.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将实现基本认证、JWT和OAuth，以充分理解其底层组件及其交互。
- en: Autenticazione di base
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本认证
- en: Nell'autenticazione di base, il client fornisce un nome utente e una password
    quando effettua una richiesta di accesso alle risorse dal server. È la tecnica
    più semplice perché non richiede l'implementazione di cookie, identificatori di
    sessione o moduli di login. Grazie alla sua semplicità, l'autenticazione di base
    è ideale per gli ambienti sandbox e per la prototipazione. Tuttavia, evita di
    usarla in ambienti di produzione perché trasmette nomi utente e password in chiaro
    a ogni richiesta, rendendola altamente vulnerabile agli attacchi di intercettazione.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Per eseguire una richiesta autenticata tramite l'autenticazione di base, devi
    aggiungere un'intestazione `Authorization` con un valore di `Basic <credentials>`
    affinché il server riesca ad autenticarla. Il valore `<credentials>` deve essere
    una codifica *Base64* del nome utente e della password uniti da un singolo punto
    (ad esempio, `base64.encode(ali:secretpassword)`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: In FastAPI, puoi proteggere un endpoint con l'autenticazione di base, come mostrato
    nell'[Esempio 8-1](#basic_authentication_endpoint).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Esempio 8-1\. Implementazione dell'autenticazione di base in FastAPI
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO1-1)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI ha implementato diversi meccanismi di sicurezza HTTP, tra cui `HTTP​Ba⁠sic`
    che può sfruttare il sistema di dependency injection di FastAPI.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO1-2)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Utilizza la libreria integrata `secrets` per confrontare il nome utente e la
    password forniti con i valori del server. L'uso di `secrets.compare_digest()`
    garantisce che la durata delle operazioni di verifica rimanga costante indipendentemente
    dagli input, per evitare *attacchi di temporizzazione*.^([3](ch08.html#id972))
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Nota che `secrets.compare_digest()` può accettare solo input di tipo byte o
    stringa contenenti caratteri ASCII (cioè solo caratteri inglesi). Per gestire
    altri caratteri, dovrai prima codificare gli input con `UTF-8` in byte prima di
    eseguire i controlli delle credenziali.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO1-4)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Restituisce un'autorizzazione standardizzata `HTTPException` conforme agli standard
    di sicurezza che i browser comprendono in modo da mostrare nuovamente il prompt
    di accesso all'utente. Il messaggio di eccezione deve essere generico per evitare
    di far trapelare informazioni sensibili, come l'esistenza di un account utente,
    agli aggressori.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_authentication_and_authorization_CO1-5)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: L'utilizzo di `HTTPBasic` con `Depends()` restituisce l'oggetto `HTTPBasicCredentials`
    che contiene il nome utente fornito.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Iniettare una dipendenza di sicurezza in qualsiasi endpoint FastAPI lo proteggerà
    con l'autenticazione implementata. Puoi sperimentarlo tu stesso visitando la pagina`/docs`
    e inviando una richiesta all'endpoint `/users/me`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: L'endpoint mostrerà un'icona *a forma di lucchetto* e, al momento della richiesta,
    dovrebbe comparire un avviso di accesso che ti chiederà di fornire le credenziali,
    come puoi vedere nella [Figura 8-2](#basic_authentication).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: L'endpoint mostrerà un'icona *a forma di lucchetto* e, al momento della richiesta,
    dovrebbe comparire un avviso di accesso che ti chiederà di fornire le credenziali,
    come puoi vedere nella [Figura 8-2](#basic_authentication).
- en: '![bgai 0802](assets/bgai_0802.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0802](assets/bgai_0802.png)'
- en: Figura 8-2\. Autenticazione di base in FastAPI
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figura 8-2\. Autenticazione di base in FastAPI
- en: Con 25 righe di codice sei riuscito a implementare una forma di autenticazione
    di base per proteggere un endpoint. Ora puoi utilizzare l'autenticazione di base
    nei tuoi prototipi e nei server di sviluppo.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Con 25 righe di codice sei riuscito a implementare una forma di autenticazione
    di base per proteggere un endpoint. Ora puoi utilizzare l'autenticazione di base
    nei tuoi prototipi e nei server di sviluppo.
- en: Tieni presente che dovresti evitare di adottare il meccanismo di autenticazione
    di base nei servizi GenAI di livello produttivo. Un'alternativa migliore e più
    sicura per i servizi rivolti al pubblico è l'*autenticazione JWT*, che elimina
    la necessità di sessioni lato server memorizzando tutti i dettagli dell'autenticazione
    all'interno di un token. Inoltre, mantiene l'integrità dei dati e funziona in
    diversi domini con uno standard ampiamente accettato.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Tieni presente che dovresti evitare di adottare il meccanismo di autenticazione
    di base nei servizi GenAI di livello produttivo. Un'alternativa migliore e più
    sicura per i servizi rivolti al pubblico è l'*autenticazione JWT*, che elimina
    la necessità di sessioni lato server memorizzando tutti i dettagli dell'autenticazione
    all'interno di un token. Inoltre, mantiene l'integrità dei dati e funziona in
    diversi domini con uno standard ampiamente accettato.
- en: Autenticazione con token web JSON (JWT)
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Autenticazione con token web JSON (JWT)
- en: Ora che hai acquisito una maggiore familiarità con i concetti di base dell'autenticazione,
    implementiamo un livello di autenticazione JWT più complesso ma sicuro per il
    tuo servizio FastAPI. Come parte di questo processo, dovrai anche rifattorizzare
    gli endpoint esistenti per combinarli sotto un router API separato per le risorse,
    in modo da raggruppare, nominare, etichettare e proteggere più endpoint contemporaneamente.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Ora che hai acquisito una maggiore familiarità con i concetti di base dell'autenticazione,
    implementiamo un livello di autenticazione JWT più complesso ma sicuro per il
    tuo servizio FastAPI. Come parte di questo processo, dovrai anche rifattorizzare
    gli endpoint esistenti per combinarli sotto un router API separato per le risorse,
    in modo da raggruppare, nominare, etichettare e proteggere più endpoint contemporaneamente.
- en: Che cos'è il JWT?
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Che cos'è il JWT?
- en: I JWT sono un modo sicuro e compatto di asserire le rivendicazioni tra le applicazioni
    tramite token.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: I JWT sono un modo sicuro e compatto di asserire le rivendicazioni tra le applicazioni
    tramite token.
- en: 'Questi gettoni sono composti da tre parti:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'Questi gettoni sono composti da tre parti:'
- en: Intestazioni
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Intestazioni
- en: Specifica il tipo di token e l'algoritmo di firma oltre alla data e all'autorità
    emittente.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Specifica il tipo di token e l'algoritmo di firma oltre alla data e all'autorità
    emittente.
- en: Carico utile
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Carico utile
- en: Specifica il corpo del token che rappresenta le rivendicazioni sulla risorsa
    insieme a metadati aggiuntivi.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Specifica il corpo del token che rappresenta le rivendicazioni sulla risorsa
    insieme a metadati aggiuntivi.
- en: Firma
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Firma
- en: La funzione che crea il token lo firma utilizzando il *payload codificato*,
    le *intestazioni codificate*, un *segreto* e l'algoritmo di firma.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: La funzione che crea il token lo firma utilizzando il *payload codificato*,
    le *intestazioni codificate*, un *segreto* e l'algoritmo di firma.
- en: Suggerimento
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Suggerimento
- en: L'algoritmo di codifica `base64` viene spesso utilizzato per codificare e decodificare
    i dati per garantire la compattezza e la sicurezza degli URL.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: L'algoritmo di codifica `base64` viene spesso utilizzato per codificare e decodificare
    i dati per garantire la compatibilità e la sicurezza degli URL.
- en: '[La Figura 8-3](#jwt) mostra l''aspetto di un tipico JWT.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[La Figura 8-3](#jwt) mostra l''aspetto di un tipico JWT.'
- en: '![bgai 0803](assets/bgai_0803.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0803](assets/bgai_0803.png)'
- en: 'Figura 8-3\. Componenti JWT (Fonte: [jwt.io](https://jwt.io))'
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 'Figura 8-3\. Componenti JWT (Fonte: [jwt.io](https://jwt.io))'
- en: I JWT sono sicuri, compatti e convenienti perché possono contenere tutte le
    informazioni necessarie per eseguire l'autenticazione dell'utente, evitando la
    necessità di effettuare più viaggi nel database. Inoltre, grazie alla loro compattezza,
    puoi trasferirli attraverso la rete utilizzando il corpo HTTP `POST`, le intestazioni
    o i parametri URL.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: I JWT sono sicuri, compatti e convenienti perché possono contenere tutte le
    informazioni necessarie per eseguire l'autenticazione dell'utente, evitando la
    necessità di effettuare più viaggi nel database. Inoltre, grazie alla loro compattezza,
    puoi trasferirli attraverso la rete utilizzando il corpo HTTP `POST`, le intestazioni
    o i parametri URL.
- en: Come iniziare con l'autenticazione JWT
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Come iniziare con l'autenticazione JWT
- en: 'Per iniziare a implementare il meccanismo di autenticazione JWT in FastAPI,
    devi installare le dipendenze `passlib` e `python-jose`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 'Per iniziare a implementare il meccanismo di autenticazione JWT in FastAPI,
    devi installare le dipendenze `passlib` e `python-jose`:'
- en: '[PRE1]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2] # entities.py  import uuid from datetime import UTC, datetime from sqlalchemy
    import Index, String from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column  class
    Base(DeclarativeBase):     pass  class User(Base):     __tablename__ = "users"      id:
    Mapped[uuid.UUID] = mapped_column(primary_key=True, default=uuid.uuid4)     email:
    Mapped[str] = mapped_column(String(length=255), unique=True)     hashed_password:
    Mapped[str] = mapped_column(String(length=255))     is_active: Mapped[bool] =
    mapped_column(default=True)     role: Mapped[str] = mapped_column(default="USER")     created_at:
    Mapped[datetime] = mapped_column(default=datetime.now(UTC))     updated_at: Mapped[datetime]
    = mapped_column(         default=datetime.now(UTC), onupdate=datetime.now(UTC)     )      __table_args__
    = (Index("ix_users_email", "email"),) [PRE3] # schemas.py  from datetime import
    datetime from typing import Annotated from pydantic import (UUID4, AfterValidator,
    BaseModel, ConfigDict, Field,                       validate_call)  @validate_call
    def validate_username(value: str) -> str: ![1](assets/1.png)     if not value.isalnum():         raise
    ValueError("Username must be alphanumeric")     return value  @validate_call def
    validate_password(value: str) -> str: ![1](assets/1.png)     validations = [         (             lambda
    v: any(char.isdigit() for char in v),             "Password must contain at least
    one digit",         ),         (             lambda v: any(char.isupper() for
    char in v),             "Password must contain at least one uppercase letter",         ),         (             lambda
    v: any(char.islower() for char in v),             "Password must contain at least
    one lowercase letter",         ),     ]     for condition, error_message in validations:         if
    not condition(value):             raise ValueError(error_message)     return value  ValidUsername
    = Annotated[     str, Field(min_length=3, max_length=20), AfterValidator(validate_username)
    ] ValidPassword = Annotated[     str, Field(min_length=8, max_length=64), AfterValidator(validate_password)
    ]  class UserBase(BaseModel):     model_config = ConfigDict(from_attributes=True)
    ![2](assets/2.png)      username: ValidUsername     is_active: bool = True     role:
    str = "USER"  class UserCreate(UserBase): ![3](assets/3.png)     password: ValidPassword  class
    UserInDB(UserBase): ![4](assets/4.png)     hashed_password: str  class UserOut(UserBase):     id:
    UUID4     created_at: datetime     updated_at: datetime [PRE4] # entities.py  from
    datetime import UTC, datetime from sqlalchemy import ForeignKey, Index, String
    from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship  class
    Base(DeclarativeBase):     pass  class Token(Base):     __tablename__ = "tokens"      id:
    Mapped[int] = mapped_column(primary_key=True)     user_id: Mapped[int] = mapped_column(ForeignKey("users.id"))     expires_at:
    Mapped[datetime] = mapped_column()     is_active: Mapped[bool] = mapped_column(default=True)     ip_address:
    Mapped[str | None] = mapped_column(String(length=255))     created_at: Mapped[datetime]
    = mapped_column(default=datetime.now(UTC))     updated_at: Mapped[datetime] =
    mapped_column(         default=datetime.now(UTC), onupdate=datetime.now(UTC)     )      user
    = relationship("User", back_populates="tokens")      __table_args__ = (         Index("ix_tokens_user_id",
    "user_id"),         Index("ix_tokens_ip_address", "ip_address"),     )  class
    User(Base):     __tablename__ = "users"     # other columns...      tokens = relationship(         "Token",
    back_populates="user", cascade="all, delete-orphan"     )  # schemas.py  from
    datetime import datetime from pydantic import BaseModel  class TokenBase(BaseModel):     user_id:
    int     expires_at: datetime     is_active: bool = True     ip_address: str |
    None = None  class TokenCreate(TokenBase):     pass  class TokenOut(BaseModel):     access_token:
    str     token_type: str = "Bearer" [PRE5] """create users and tokens tables  Revision
    ID: 1234567890ab Revises: Create Date: 2025-01-28 12:34:56.789012  """  from datetime
    import UTC, datetime import sqlalchemy as sa from alembic import op  ...  def
    upgrade():     op.create_table(         "users",         sa.Column("id", sa.UUID(as_uuid=True)),
    ![1](assets/1.png)         sa.Column("email", sa.String(length=255)),         sa.Column("hashed_password",
    sa.String(length=255)), ![2](assets/2.png)         sa.Column(             "is_active",
    sa.Boolean(), server_default=sa.sql.expression.true()         ), ![3](assets/3.png)         sa.Column("role",
    sa.String(), server_default=sa.text("USER")), ![4](assets/4.png)         sa.Column("created_at",
    sa.DateTime(), default=datetime.now(UTC)),         sa.Column(             "updated_at",             sa.DateTime(),             default=datetime.now(UTC),             onupdate=datetime.now(UTC),
    ![5](assets/5.png)         ),         sa.PrimaryKeyConstraint("id"),         sa.UniqueConstraint("email"),         sa.Index("ix_users_email",
    "email"), ![6](assets/6.png)     )      op.create_table(         "tokens",         sa.Column("id",
    sa.UUID(as_uuid=True)), ![1](assets/1.png)         sa.Column("user_id", sa.Integer()),         sa.Column("expires_at",
    sa.DateTime()), ![7](assets/7.png)         sa.Column("is_active", sa.Boolean(),
    default=True), ![8](assets/8.png)         sa.Column("ip_address", sa.String(length=255),
    nullable=True),         sa.Column("created_at", sa.DateTime(), default=datetime.now(UTC)),         sa.Column(             "updated_at",             sa.DateTime(),             default=datetime.now(UTC),             onupdate=datetime.now(UTC),
    ![9](assets/9.png)         ),         sa.ForeignKeyConstraint(             ["user_id"],             ["users.id"],         ),         sa.PrimaryKeyConstraint("id"),         sa.Index("ix_tokens_user_id",
    "user_id"),         sa.Index("ix_tokens_ip_address", "ip_address"), ![10](assets/10.png)     )   def
    downgrade():     op.drop_table("tokens")     op.drop_table("users") [PRE6]`  [PRE7]
    # services/auth.py  from fastapi.security import HTTPBearer from passlib.context
    import CryptContext  class PasswordService:     security = HTTPBearer()     pwd_context
    = CryptContext(schemes=["bcrypt"]) ![1](assets/1.png)      async def verify_password(         self,
    password: str, hashed_password: str     ) -> bool:         return self.pwd_context.verify(password,
    hashed_password) ![2](assets/2.png)      async def get_password_hash(self, password:
    str) -> str:         return self.pwd_context.hash(password) ![2](assets/2.png)
    [PRE8] # exceptions.py  from fastapi import HTTPException, status  UnauthorizedException
    = HTTPException(     status_code=status.HTTP_401_UNAUTHORIZED,     detail="Not
    authenticated",     headers={"WWW-Authenticate": "Bearer"}, )  AlreadyRegisteredException
    = HTTPException(     status_code=status.HTTP_400_BAD_REQUEST,     detail="Username
    already registered", ) [PRE9] # repositories.py  from entities import Token from
    repositories.interfaces import Repository from schemas import TokenCreate, TokenUpdate
    from sqlalchemy import select from sqlalchemy.ext.asyncio import AsyncSession  class
    TokenRepository(Repository):     def __init__(self, session: AsyncSession) ->
    None:         self.session = session      async def list(self, skip: int, take:
    int) -> list[Token]:         async with self.session.begin():             result
    = await self.session.execute(                 select(Token).offset(skip).limit(take)             )         return
    [r for r in result.scalars().all()]      async def get(self, token_id: int) ->
    Token | None:         async with self.session.begin():             result = await
    self.session.execute(                 select(Token).where(Token.id == token_id)             )         return
    result.scalars().first()      async def create(self, token: TokenCreate) -> Token:         new_token
    = Token(**token.dict())         async with self.session.begin():             self.session.add(new_token)             await
    self.session.commit()             await self.session.refresh(new_token)         return
    new_token      async def update(         self, token_id: int, updated_token: TokenUpdate     )
    -> Token | None:         token = await self.get(token_id)         if not token:             return
    None         for key, value in updated_token.dict(exclude_unset=True).items():             setattr(token,
    key, value)         async with self.session.begin():             await self.session.commit()             await
    self.session.refresh(token)         return token      async def delete(self, token_id:
    int) -> None:         token = await self.get(token_id)         if not token:             return         async
    with self.session.begin():             await self.session.delete(token)             await
    self.session.commit() [PRE10] # services/auth.py  from datetime import UTC, datetime,
    timedelta from exceptions import UnauthorizedException from jose import JWTError,
    jwt from pydantic import UUID4 from repositories import TokenRepository from schemas
    import TokenCreate, TokenUpdate  class TokenService(TokenRepository):     secret_key
    = "your_secret_key"     algorithm = "HS256"     expires_in_minutes = 60 ![1](assets/1.png)  async
    def create_access_token(     self, data: dict, expires_delta: timedelta | None
    = None ![2](assets/2.png) ) -> str:     to_encode = data.copy()     if expires_delta:         expire
    = datetime.now(UTC) + expires_delta     else:         expire = datetime.now(UTC)
    + timedelta(minutes=self.expires_in_minutes)     token_id = await self.create(TokenCreate(expires_at=expire))
    ![3](assets/3.png)     to_encode.update(         {"exp": expire, "iss": "your_service_name",
    "sub": token_id} ![4](assets/4.png)     )     encoded_jwt = jwt.encode(         to_encode,
    self.secret_key, algorithm=self.algorithm ![5](assets/5.png)     )     return
    encoded_jwt  async def deactivate(self, token_id: UUID4) -> None:     await self.update(TokenUpdate(id=token_id,
    is_active=False))  def decode(self, encoded_token: str) -> dict:     try:         return
    jwt.decode(             encoded_token, self.secret_key, algorithms=[self.algorithm]         )     except
    JWTError:         raise UnauthorizedException  async def validate(self, token_id:
    UUID4) -> bool:     return (token := await self.get(token_id)) is not None and
    token.is_active [PRE11] # services/auth.py  from typing import Annotated from
    databases import DBSessionDep from entities import Token, User, UserCreate, UserInDB
    from exceptions import AlreadyRegisteredException, UnauthorizedException from
    fastapi import Depends from fastapi.security import (HTTPAuthorizationCredentials,
    HTTPBearer,                               OAuth2PasswordRequestForm) from services.auth
    import PasswordService, TokenService from services.users import UserService  security
    = HTTPBearer() LoginFormDep = Annotated[OAuth2PasswordRequestForm, Depends()]
    AuthHeaderDep = Annotated[HTTPAuthorizationCredentials, Depends(security)]  class
    AuthService:     def __init__(self, session: DBSessionDep):         self.password_service
    = PasswordService()         self.token_service = TokenService(session)         self.user_service
    = UserService(session)      async def register_user(self, user: UserCreate) ->
    User:         if await self.user_service.get(user.username):             raise
    AlreadyRegisteredException         hashed_password = await self.password_service.get_password_hash(             user.password         )         return
    await self.user_service.create(             UserInDB(username=user.username, hashed_password=hashed_password)         )      async
    def authenticate_user(self, form_data: LoginFormDep) -> Token: ![1](assets/1.png)         if
    not (user := await self.user_service.get_user(form_data.username)):             raise
    UnauthorizedException         if not await self.password_service.verify_password(             form_data.password,
    user.hashed_password         ):             raise UnauthorizedException         return
    await self.token_service.create_access_token(user._asdict())      async def get_current_user(self,
    credentials: AuthHeaderDep) -> User:         if credentials.scheme != "Bearer":             raise
    UnauthorizedException         if not (token := credentials.credentials):             raise
    UnauthorizedException         payload = self.token_service.decode(token)         if
    not await self.token_service.validate(payload.get("sub")):             raise UnauthorizedException         if
    not (username := payload.get("username")):             raise UnauthorizedException         if
    not (user := await self.user_service.get(username)):             raise UnauthorizedException         return
    user      async def logout(self, credentials: AuthHeaderDep) -> None:         payload
    = self.token_service.decode(credentials.credentials)         await self.token_service.deactivate(payload.get("sub"))      #
    Add Password Reset Method     async def reset_password(self): ... [PRE12] # routes/auth.py  from
    typing import Annotated from entities import User from fastapi import APIRouter,
    Depends from models import TokenOut, UserOut from services.auth import AuthService  auth_service
    = AuthService() RegisterUserDep = Annotated[User, Depends(auth_service.register_user)]
    AuthenticateUserCredDep = Annotated[     str, Depends(auth_service.authenticate_user_with_credentials)
    ] AuthenticateUserTokenDep = Annotated[User, Depends(auth_service.register_user)]
    PasswordResetDep = Annotated[None, Depends(auth_service.reset_password)] ![1](assets/1.png)  router
    = APIRouter(prefix="/auth", tags=["Authentication"]) ![2](assets/2.png)  @router.post("/register")
    async def register_user_controller(new_user: RegisterUserDep) -> UserOut:     return
    new_user  @router.post("/token") ![3](assets/3.png) async def login_for_access_token_controller(     access_token:
    AuthenticateUserCredDep, ) -> TokenOut:     return {"access_token": access_token,
    "token_type": "bearer"}  @router.post("/logout", dependencies=[Depends(auth_service.logout)])
    ![3](assets/3.png) ![4](assets/4.png) async def logout_access_token_controller()
    -> dict:     return {"message": "Logged out"}  @router.post("reset-password")
    ![3](assets/3.png) async def reset_password_controller(credentials: str) -> dict:     return
    {         "message": "If an account exists, "         "a password reset link will
    be sent to the provided email"     } [PRE13] # routes/resource.py  from fastapi
    import APIRouter  router = APIRouter(prefix="/generate", tags=["Resource"]) ![1](assets/1.png)  @router.get("/generate/text",
    ...) def serve_language_model_controller(...):     ...  @router.get("/generate/audio",
    ...) def serve_text_to_audio_model_controller(...)     ...  ... # Add other controllers
    to the resource router here  # main.py  from typing import Annotated import routes
    from entities import User from fastapi import Depends, FastAPI from services.auth
    import AuthService  auth_service = AuthService() AuthenticateUserDep = Annotated[User,
    Depends(auth_service.get_current_user)]  ...  app = FastAPI(lifespan=lifespan)  app.include_router(routes.auth.router,
    prefix="/auth", tags=["Auth"]) ![2](assets/2.png) app.include_router(     routes.resource.router,     dependencies=[AuthenticateUserDep],     prefix="/generate",     tags=["Generate"],
    ) ![3](assets/3.png) ...  # Add other routes to the app here [PRE14]`  [PRE15]
    # routes/auth.py  import secrets from fastapi import APIRouter, Request, status
    from fastapi.responses import RedirectResponse  client_id = "your_client_id" client_secret
    = "your_client_secret"  router = APIRouter()  ...  @router.get("/oauth/github/login",
    status_code=status.HTTP_301_REDIRECT) def oauth_github_login_controller(request:
    Request) -> RedirectResponse:     state = secrets.token_urlsafe(16)     redirect_uri
    = request.url_for("oauth_github_callback_controller")     response = RedirectResponse(         url=f"https://github.com/login/oauth/authorize"         f"?client_id={client_id}"         f"&scope=user"         f"&state={state}"         f"&redirect_uri={redirect_uri}"     )
    ![1](assets/1.png)     csrf_token = secrets.token_urlsafe(16)     request.session["x-csrf-state-token"]
    = csrf_token     return response [PRE16] # client.py  import requests import streamlit
    as st  if st.button("Login with GitHub"):     response = requests.get("http://localhost:8000/auth/oauth/github/login")     if
    not response.ok:         st.error("Failed to login with GitHub. Please try again
    later")         response.raise_for_status() [PRE17] # dependencies/auth.py  from
    typing import Annotated import aiohttp from fastapi import Depends, HTTPException
    from loguru import logger  client_id = "your_client_id" client_secret = "your_client_secret"  async
    def exchange_grant_with_access_token(code: str) -> str:     try:         body
    = {             "client_id": client_id,             "client_secret": client_secret,             "code":
    code,         }         headers = {             "Accept": "application/json",             "Content-Type":
    "application/json",         }         async with aiohttp.ClientSession() as session:             async
    with session.post(                 "https://github.com/login/oauth/access_token",                 json=body,                 headers=headers,             )
    as resp:                 access_token_data = await resp.json()     except Exception
    as e:         logger.warning(f"Failed to fetch the access token. Error: {e}")         raise
    HTTPException(             status_code=503, detail="Failed to fetch access token"         )      if
    not access_token_data:         raise HTTPException(             status_code=503,
    detail="Failed to obtain access token"         )      return access_token_data.get("access_token",
    "")  ExchangeCodeTokenDep = Annotated[str, Depends(exchange_grant_with_access_token)]
    [PRE18] # routes/auth.py  from dependencies.auth import ExchangeCodeTokenDep from
    fastapi import Depends, HTTPException, Request from fastapi.responses import RedirectResponse  ...  def
    check_csrf_state(request: Request, state: str) -> None:     if state != request.session.get("x-csrf-token"):         raise
    HTTPException(detail="Bad request", status_code=401)  @router.get("/oauth/github/callback",
    dependencies=[Depends(check_csrf_state)]) async def oauth_github_callback_controller(     access_token:
    ExchangeCodeTokenDep, ) -> RedirectResponse:     response = RedirectResponse(url=f"http://localhost:8501")     response.set_cookie(key="access_token",
    value=access_token, httponly=True)     return response [PRE19] # main.py  from
    fastapi import FastAPI from starlette.middleware.sessions import SessionMiddleware  ...  app
    = FastAPI(lifespan=lifespan) app.add_middleware(SessionMiddleware, secret_key="your_secret_key")
    [PRE20] # routes/auth.py  from typing import Annotated import aiohttp from fastapi
    import Depends, HTTPException from fastapi.security import HTTPAuthorizationCredentials,
    HTTPBearer  security = HTTPBearer() HTTPBearerDep = Annotated[HTTPAuthorizationCredentials,
    Depends(security)]  ...  async def get_user_info(credentials: HTTPBearerDep) ->
    dict:     try:         async with aiohttp.ClientSession() as session:             headers
    = {"Authorization": f"Bearer {credentials.credentials}"}             async with
    session.get(                 "https://api.github.com/user", headers=headers             )
    as resp:                 return await resp.json()     except Exception as e:         raise
    HTTPException(             status_code=503, detail=f"Failed to obtain user info
    - Error: {e}"         )  GetUserInfoDep = Annotated[dict, Depends(get_user_info)]  @router.get("/oauth/github/callback")
    async def get_current_user_controller(user_info: GetUserInfoDep) -> dict:     return
    user_info [PRE21] # dependencies/auth.py  from entities import User from fastapi
    import Depends, HTTPException, status from services.auth import AuthService  async
    def is_admin(user: User = Depends(AuthService.get_current_user)) -> User: ![1](assets/1.png)     if
    user.role != "ADMIN":         raise HTTPException(             status_code=status.HTTP_403_FORBIDDEN,             detail="Not
    allowed to perform this action",         )     return user  # routers/resource.py  from
    dependencies.auth import is_admin from fastapi import APIRouter, Depends from
    services.auth import AuthService  router = APIRouter(     dependencies=[Depends(AuthService.get_current_user)],
    ![3](assets/3.png)     prefix="/generate",     tags=["Resource"], )  @router.post("/image",
    dependencies=[Depends(is_admin)]) async def generate_image_controller(): ![2](assets/2.png)     ...  @router.post("/text")
    ![3](assets/3.png) async def generate_text_controller():     ... [PRE22] # dependencies/auth.py  from
    typing import Annotated  from entities import User from fastapi import APIRouter,
    Depends, HTTPException, status from services.auth import AuthService  CurrentUserDep
    = Annotated[User, Depends(AuthService.get_current_user)]  async def has_role(user:
    CurrentUserDep, roles: list[str]) -> User:     if user.role not in roles:         raise
    HTTPException(             status_code=status.HTTP_403_FORBIDDEN,             detail="Not
    allowed to perform this action",         )     return user   # routes/resource.py  ...  @router.post(     "/image",     dependencies=[Depends(lambda
    user: has_role(user, ["ADMIN", "MODERATOR"]))], ) async def generate_image_controller():     ...  @router.post(     "/text",
    dependencies=[Depends(lambda user: has_role(user, ["EDITOR"]))] ) async def generate_text_controller():     ...
    [PRE23] # dependencies/auth.py  from typing import Annotated from fastapi import
    Depends, HTTPException, status ...  # import services and entities here  CurrentUserDep
    = Annotated[User, Depends(AuthService.get_current_user)] TeamMembershipRep = Annotated[Team,
    Depends(TeamService.get_current_team)] ResourceDep = Annotated[Resource, Depends(ResourceService.get_resource)]  def
    authorize(     user: CurrentUserDep, resource: ResourceDep, team: TeamMembershipRep
    ) -> bool:     if user.role == "ADMIN":         return True     if user.id in
    team.members:         return True     if resource.is_public:         return True     raise
    HTTPException(         status_code=status.HTTP_403_FORBIDDEN, detail="Access Denied"     )  #
    routes/resource.py  from dependencies.auth import authorize from fastapi import
    APIRouter, Depends  router = APIRouter(     dependencies=[Depends(authorize)],
    prefix="/generate", tags=["Resource"] )  @router.post("/image") async def generate_image_controller():
    ...  @router.post("/text") async def generate_text_controller(): ... [PRE24] #
    authorization_api.py (Authorization Service)  from typing import Annotated, Literal
    from fastapi import Depends, FastAPI from pydantic import BaseModel  ...  # import
    services and entities here  CurrentUserDep = Annotated[User, Depends(AuthService.get_current_user)]
    ActionRep = Annotated[Literal["READ", "CREATE", "UPDATE", "DELETE"], str] ResourceDep
    = Annotated[Resource, Depends(ResourceService.get_resource)]  class AuthorizationResponse(BaseModel):     allowed:
    bool  app = FastAPI()  app.get("/authorize") def authorization_controller(     user:
    CurrentUserDep, resource: ResourceDep, action: ActionRep ) -> AuthorizationResponse:     if
    user.role == "ADMIN":         return AuthorizationResponse(allowed=True)     if
    action in user.permissions.get(resource.id, []):         return AuthorizationResponse(allowed=True)     ...  #
    Other permission checks     return AuthorizationResponse(allowed=False)  # genai_api.py
    (GenAI Service)  from fastapi import APIRouter, HTTPException, status from pydantic
    import BaseModel  class AuthorizationData(BaseModel):     user_id: int     resource_id:
    int     action: str  authorization_client = ...  # Create authorization client  async
    def enforce(data: AuthorizationData) -> bool:     response = await authorization_client.decide(data)     if
    response.allowed:         return True     raise HTTPException(         status_code=status.HTTP_403_FORBIDDEN,
    detail="Access Denied"     )  router = APIRouter(     dependencies=[Depends(enforce)],
    prefix="/generate", tags=["Resource"] )  @router.post("/text") async def generate_text_controller():     ...
    [PRE25]`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
