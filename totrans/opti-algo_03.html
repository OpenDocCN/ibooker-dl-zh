<html><head></head><body>
  <h1 class="tochead" id="heading_id_2">3 Blind search algorithms</h1>

  <p class="co-summary-head">This chapter covers<a id="idIndexMarker000"/><a id="marker-62"/></p>

  <ul class="calibre5">
    <li class="co-summary-bullet">Applying different graph types</li>

    <li class="co-summary-bullet">Graph search algorithms</li>

    <li class="co-summary-bullet">Using graph traversal algorithms to find a path between two nodes</li>

    <li class="co-summary-bullet">Using blind search algorithms to find the shortest path between two nodes in a graph</li>

    <li class="co-summary-bullet">Solving a real-world routing problem using graph search algorithms</li>
  </ul>

  <p class="body">You were introduced to deterministic and stochastic algorithms in chapter 2. In this chapter, we will focus on deterministic algorithms, specifically blind search algorithms, and their applications in exploring tree or graph structures and finding the shortest path between nodes. Using these algorithms, you can explore a maze from an initial state to a goal state, solve <i class="fm-italics">n</i>-puzzle problems, figure out the distance between you and any other person on a social media graph, search a family tree to determine the exact relationship between any two related people, or find the shortest path between any origin (e.g., your home) and any destination. Blind search algorithms are important, as they are often more efficient and practical to use when dealing with simple, well-defined problems.</p>

  <h2 class="fm-head" id="heading_id_3">3.1 Introduction to graphs</h2>

  <p class="body">A <i class="fm-italics">graph</i> is a nonlinear data structure composed of entities known as <i class="fm-italics">vertices</i> (or nodes) and the relationships between them, known as <i class="fm-italics">edges</i> (or <i class="fm-italics">arcs</i> or <i class="fm-italics">links</i>). This data structure does not follow a sequential pattern, making it <i class="fm-italics">nonlinear</i>, unlike arrays, stacks, or queues, which are linear structures. <a id="idIndexMarker001"/><a id="idIndexMarker002"/><a id="marker-63"/></p>

  <p class="body">A graph can be represented mathematically by <i class="timesitalic">G</i>, where <span class="times"><i class="fm-italics">G</i> = (<i class="fm-italics">V, E</i>)</span>. <i class="timesitalic">V</i> represents the set of nodes or vertices, and <i class="timesitalic">E</i> represents the set of edges or links. Various attributes can also be added as components to the edge tuple, such as edge length, capacity, or any other unique properties (e.g., road material). Graphs can be classified as undirected, directed, multigraph, acyclic, and hypergraphs.</p>

  <p class="body">An <i class="fm-italics">undirected graph</i> is one where a set of nodes are connected using bidirectional edges. This means that the order of two connected nodes is not essential.</p>

  <p class="body">NetworkX is a commonly used Python library for creating, manipulating, and studying the structure, dynamics, and functions of graphs and complex networks (see appendix A for more information about graph libraries). The following listing shows how you can use NetworkX to create an undirected graph.</p>

  <p class="fm-code-listing-caption">Listing 3.1 Creating an undirected graph using NetworkX</p>
  <pre class="programlisting">import networkx as nx
import matplotlib.pyplot as plt
 
graph = nx.Graph()
 
nodes = list(range(5))                        <span class="fm-combinumeral">①</span>
graph.add_nodes_from(nodes)
 
edges = [(0,1),(1,2), (1,3), (2,3),(3,4)]     <span class="fm-combinumeral">②</span>
graph.add_edges_from(edges)
 
nx.draw_networkx(graph, font_color="white")</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Generate a list of nodes from 0 to 4.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Define a list of edges.</p>

  <p class="body">The output of this code is shown in figure 3.1. The actual layout you get might be different, but the connections among the vertices will be the same as shown here.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F01_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.1 An undirected graph</p>
  </div>

  <p class="body">A <i class="fm-italics">directed graph</i> is a graph in which a set of nodes are connected using directional edges. Directed graphs have many applications, such as representing flow constraints (e.g., one-way streets), relations (e.g., causal relationships), and dependencies (e.g., tasks that depend on the completion of other tasks). The following listing shows how to use NetworkX to create a directed graph. <a id="idIndexMarker003"/><a id="marker-64"/></p>

  <p class="fm-code-listing-caption">Listing 3.2 Creating a directed graph using NetworkX</p>
  <pre class="programlisting">import networkx as nx
import matplotlib.pyplot as plt
 
graph = nx.DiGraph()       <span class="fm-combinumeral">①</span>
nodes = list(range(5))
edges = [(0,1),(1,2), (1,3), (2,3),(3,4)]
graph.add_edges_from(edges)
graph.add_nodes_from(nodes)
nx.draw_networkx(graph, font_color="white")</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> DiGraph allows for directed edges.</p>

  <p class="body">The code output is shown in figure 3.2. Note the arrows indicating the edge directions.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F02_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.2 A directed graph</p>
  </div>

  <p class="body">A <i class="fm-italics">multigraph</i> is a graph in which multiple edges may connect the same pair of vertices. These edges are called <i class="fm-italics">parallel edges</i>. Multigraphs can be used to represent complex relationships between nodes, such as multiple parallel roads between two locations in traffic routing, multiple capacities and demands in resource allocation problems, and multiple relationships between individuals in social networks, to name just a few. Unfortunately, NetworkX is not particularly good at visualizing multigraphs with parallel edges. This listing shows how you can use NetworkX in conjunction with the Matplotlib library to create a multigraph.<a id="idIndexMarker004"/><a id="idIndexMarker005"/></p>

  <p class="fm-code-listing-caption">Listing 3.3 Creating a multigraph using NetworkX</p>
  <pre class="programlisting">import networkx as nx
import matplotlib.pyplot as plt
 
graph = nx.MultiGraph()
nodes = list(range(5))
edges = [(0,1),(0,1),(4,3),(1,2), (1,3), (2,3),(3,4),(0,1)]
graph.add_nodes_from(nodes)
graph.add_edges_from(edges)
 
pos = nx.kamada_kawai_layout(graph)                                   <span class="fm-combinumeral">①</span>
ax = plt.gca()     
 
for e in graph.edges:                                                 <span class="fm-combinumeral">②</span>
     ax.annotate("",xy=pos[e[0]], xycoords='data', xytext=pos[e[1]],  <span class="fm-combinumeral">②</span>
          <span class="fm-code-continuation-arrow">➥</span>textcoords='data', arrowprops=dict(arrowstyle="-",        <span class="fm-combinumeral">②</span>
          <span class="fm-code-continuation-arrow">➥</span>connectionstyle=f"arc3, rad={0.3*e[2]}"),zorder=1)        <span class="fm-combinumeral">②</span>
 
nx.draw_networkx_nodes(graph, pos)                                    <span class="fm-combinumeral">③</span>
nx.draw_networkx_labels(graph,pos, font_color='w')                    <span class="fm-combinumeral">③</span>
 
plt.show()</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Node positions are generated using the Kamada-Kawai path-length cost function.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Draw each edge one at a time, modifying the curvature of the edge based on its index (i.e., the second edge between nodes 0 and 1).</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Draw nodes and node labels.</p>

  <p class="body"><a id="marker-65"/>It is worth noting that <code class="fm-code-in-text">kamada_kawai_layout</code> attempts to position nodes on the space so that the geometric (Euclidean) distance between them is as close as possible to the graph-theoretic (path) distance between them. Figure 3.3 shows an example of a multigraph generated by this code.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F03_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.3 Example of a multigraph. Notice the three parallel edges connecting nodes 0 and 1, as well as the two edges connecting nodes 3 and 4.</p>
  </div>

  <p class="body">As the name implies, an <i class="fm-italics">acyclic graph</i> is a graph without cycles. A <i class="fm-italics">tree</i>, as a specialized case of a graph, is a connected graph with no cycles or self-loops. In graph theory, a connected graph is a type of graph in which there is a path between every pair of vertices. A <i class="fm-italics">cycle</i>, also called a <i class="fm-italics">self-loop</i> or a <i class="fm-italics">circuit</i>, is an edge in a graph that connects a vertex (or node) to itself. In task scheduling, acyclic graphs can be used to represent the relationships between tasks where each node represents a task and each directed edge represents a precedence constraint. This constraint means that the task represented by the end node cannot start until the task represented by the start node is completed. We’ll discuss the assembly line balancing problem in chapter 6 as an example of scheduling problems. <a id="idIndexMarker006"/><a id="idIndexMarker007"/></p>

  <p class="body"><a id="marker-66"/>The following listing shows how you can use NetworkX to create and verify an acyclic graph. An example of an acyclic graph is shown in figure 3.4</p>

  <p class="fm-code-listing-caption">Listing 3.4 Creating an acyclic graph using NetworkX</p>
  <pre class="programlisting">import networkx as nx
import matplotlib.pyplot as plt
 
graph = nx.DiGraph()
nodes = list(range(5))
edges = [(0,1), (0,2),(4,1),(1,2),(2,3)]
graph.add_nodes_from(nodes)
graph.add_edges_from(edges)
 
nx.draw_networkx(graph, nx.kamada_kawai_layout(graph), with_labels=True,
<span class="fm-code-continuation-arrow">➥</span> font_color='w')
plt.show()
 
nx.is_directed_acyclic_graph(graph)    <span class="fm-combinumeral">①</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Check if the graph is acyclic.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F04_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.4 An acyclic graph—no path cycles back to any starting node.</p>
  </div>

  <p class="body">A <i class="fm-italics">hypergraph</i> is a generalization of a graph in which the generalized edges (called <i class="fm-italics">hyperedges</i>) can join any number of nodes. Hypergraphs are used to represent complex networks because they can capture higher-order many-to-many relationships. They’re used in domains such as social media, information systems, computational geometry, computational pathology, and neuroscience. For example, a group of people working on a project can be represented by a hypergraph. Each person is represented by a node, and the project is represented by a hyperedge. The hyperedge connects all the people working on the project, regardless of how many people are involved. The hyperedge can also contain other attributes, such as the project’s name, the start and end dates, the budget, etc.<a id="idIndexMarker008"/><a id="idIndexMarker009"/></p>

  <p class="body">The following listing shows how you can use HyperNetX (HNX) to create a hypergraph. HNX is a Python library that enables us to model the entities and relationships found in complex networks as hypergraphs. Figure 3.5 shows an example of a hypergraph.<a id="marker-67"/></p>

  <p class="fm-code-listing-caption">Listing 3.5 Creating a hypergraph using HyperNetX</p>
  <pre class="programlisting">import hypernetx as hnx
 
data = {
     0: ("A","B","G"),
     1: ("A","C","D","E","F"),
     2: ("B","F"),
     3: ("A","B","D","E","F","G")
}                            <span class="fm-combinumeral">①</span>
H = hnx.Hypergraph(data)     <span class="fm-combinumeral">②</span>
hnx.draw(H)                  <span class="fm-combinumeral">③</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> The data for the hypergraph comes as key-value pairs of hyperedge name/hyperedge node groups.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Create a hypergraph for the provided data.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Visualize the hypergraph.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F05_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.5 An example of a hypergraph. Hyperedges can connect more than two nodes, such as hyperedge 0, which links nodes A, B, and G.</p>
  </div>

  <p class="body">Graphs can also be weighted or unweighted. In a <i class="fm-italics">weighted graph</i>, a weight, or value, is assigned to each edge. For example, in the case of road networks, the edges could have weights that represent the cost of traversing the road. This weight could represent distance, time, or any other metric. In telecommunications networks, the weight might represent the cost of utilizing that edge or the strength of the connections between the communication devices. <a id="idIndexMarker010"/><a id="marker-68"/></p>

  <p class="body">Listing 3.6 shows how you could create and visualize a weighted graph between telecommunication devices. The weights in this example represent the speed of connections between the devices in Mbps. Running this code generated the weighted graph in figure 3.6.</p>

  <p class="fm-code-listing-caption">Listing 3.6 Creating a weighted graph using NetworkX</p>
  <pre class="programlisting">import networkx as nx
import matplotlib.pyplot as plt
 
G = nx.Graph()                                              <span class="fm-combinumeral">①</span>
 
G.add_node("Device1", pos=(0,0))                            <span class="fm-combinumeral">②</span>
G.add_node("Device2", pos=(0,2))                            <span class="fm-combinumeral">②</span>
G.add_node("Device3", pos=(2,0))                            <span class="fm-combinumeral">②</span>
G.add_node("Device4", pos=(2,2)) 
 
G.add_weighted_edges_from([("Device1", "Device2", 45.69),
                           ("Device1", "Device3", 56.34),
                           ("Device2", "Device4", 18.5)])   <span class="fm-combinumeral">③</span>
 
pos = nx.get_node_attributes(G, 'pos')                      <span class="fm-combinumeral">④</span>
nx.draw_networkx(G, pos, with_labels=True)                  <span class="fm-combinumeral">⑤</span>
nx.draw_networkx_edge_labels(G, pos,                        <span class="fm-combinumeral">⑤</span>
<span class="fm-code-continuation-arrow">➥</span>edge_labels={(u, v): d['weight'] for                      <span class="fm-combinumeral">⑤</span>
<span class="fm-code-continuation-arrow">➥</span>u, v, d in G.edges(data=True)})                           <span class="fm-combinumeral">⑤</span>
plt.show() </pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Create an empty weighted graph.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Add nodes to the graph (representing devices).</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Add weighted edges to the graph (representing connections).</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Get node position attributes from the graph.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Draw the graph.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F06_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.6 Example of a weighted graph</p>
  </div>

  <p class="body">Graphs are everywhere. Search engines like Google see the internet as a giant graph where each web page is a node, and two pages are joined by an edge if there is a link from one page to the other. A social media platform like Facebook treats each user profile as a node on a social graph, and two nodes are said to be connected if they are each other’s friends or have social ties. The concept of “following” a user, such as on a platform like X (previously Twitter), can be represented by a directional edge, where user <i class="timesitalic">A</i> can follow user <i class="timesitalic">B</i>, but the reverse is not necessarily true. Table 3.1 shows the meanings of nodes and edges on different social media platforms.</p>

  <p class="fm-table-caption">Table 3.1 Examples of graphs in the context of social media</p>

  <table border="1" class="contenttable-1-table" id="table001" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Social media platform</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Nodes</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Edges</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Type of edge</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">Facebook</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Users, groups, posts, and events</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Friendship, group membership, messages, creation of posts, and reactions on posts</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Undirected: a like, or react, or comment</p>

          <p class="fm-table-body">Directed: a friend request</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">X (previously Twitter)</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Users, groups, unregistered persons, and posts</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Following, group membership, messages, creation of posts, and reactions on posts</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Undirected: a mention or a retweet</p>

          <p class="fm-table-body">Directed: the following relationship (when you follow a person, they do not automatically follow you back)</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">LinkedIn</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Users, groups, unregistered persons, posts, skills, and jobs</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Connections, group membership, posting, reactions on posts, messages, endorsements, invitations, recommending jobs</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Undirected: an endorsement or recommendation</p>

          <p class="fm-table-body">Directed: a connection</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">Instagram</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Users, comments, containers for publishing posts, hashtags, media (e.g., photo, video, story, or album), and pages (Facebook page)</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Relationships between users such as following, liking, and commenting</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Undirected: a like or a comment</p>

          <p class="fm-table-body">Directed: a follow relationship</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">TikTok</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Users, videos, hashtags, locations, and keywords</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Relationships between users such as following, liking, and commenting</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Undirected: a like or comment</p>

          <p class="fm-table-body">Directed: a follow relationship</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body"><a id="marker-69"/>In a road network graph, the nodes represent landmarks such as intersections and points of interest (POI), and the edges represent the roads. In such a graph, most of the edges are directed, meaning that they have specific directions, and they may have additional information such as length, speed limit, capacity, etc. Each edge is a two-endpoint connection between two nodes, where the direction of the edge represents the direction of traffic flow. A <i class="fm-italics">route</i> is a sequence of edges connecting the origin node to the destination node. <a id="idIndexMarker011"/><a id="idIndexMarker012"/></p>

  <p class="body">OSMnx is a Python library developed to simplify the retrieving and manipulating of data from OpenStreetMap (OSM; openstreetmap.org). OSM is a crowdsourced geographic database of the world (see appendix B for more information about how to fetch data from open geospatial data sources). OSMnx lets you download filtered data from OSM and returns the network as a NetworkX graph data structure. It can also convert a text descriptor of a place into a NetworkX graph (see appendix A for more information about graph and mapping libraries). The following listing uses the University of Toronto as an example.<a id="idIndexMarker013"/><a id="marker-70"/></p>

  <p class="fm-code-listing-caption">Listing 3.7 University of Toronto example</p>
  <pre class="programlisting">import osmnx as ox
import matplotlib.pyplot as plt
 
place_name = "University of Toronto"     
 
graph = ox.graph_from_address(place_name)   <span class="fm-combinumeral">①</span>
ox.plot_graph(graph,figsize=(10,10))</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> A graph_from_address can also take city names and mailing addresses as input.</p>

  <p class="body">Figure 3.7 shows an OSM map of the area around the St. George campus of the University of Toronto. The graph shows the edges and nodes of the road network surrounding the campus in downtown Toronto.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F07_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.7 St. George campus, University of Toronto</p>
  </div>

  <p class="body">While the map may look visually interesting, it lacks the context of surrounding geographic features. Let’s use the folium library (see appendix A) to create a base layer map with street names, neighborhood names, and even building footprints.<a id="idIndexMarker014"/></p>
  <pre class="programlisting">graph = ox.graph_from_address(place_name)
ox.folium.plot_graph_folium(graph)</pre>

  <p class="body">Figure 3.8 shows the road network surrounding the St. George campus.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F08_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.8 Road network around St. George campus, University of Toronto</p>
  </div>

  <p class="body">Suppose you want to get from one location to another on this campus. For example, imagine you’re starting at the King Edward VII equestrian statue near Queen’s Park in Toronto, and you need to cross the campus to attend a lecture at the Bahen Centre for Information Technology. Later in this chapter, you will see how you can calculate the shortest path between these two points.<a id="marker-71"/></p>

  <p class="body">For now, let’s just plot these two locations on the map using the folium library. Figure 3.9 shows the folium map and markers.</p>

  <p class="fm-code-listing-caption">Listing 3.8 Plotting with folium</p>
  <pre class="programlisting">import folium
  
center=(43.662643, -79.395689)                                           <span class="fm-combinumeral">①</span>
source_point = (43.664527, -79.392442)                                   <span class="fm-combinumeral">②</span>
destination_point = (43.659659, -79.397669)                              <span class="fm-combinumeral">③</span>
  
  
m = folium.Map(location=center, zoom_start=15)                           <span class="fm-combinumeral">④</span>
folium.Marker(location=source_point,icon=folium.                         <span class="fm-combinumeral">⑤</span>
<span class="fm-code-continuation-arrow">➥</span>Icon(color='red',icon='camera', prefix='fa')).add_to(m)                <span class="fm-combinumeral">⑤</span>
folium.Marker(location=center,icon=folium.Icon(color='blue',             <span class="fm-combinumeral">⑤</span>
<span class="fm-code-continuation-arrow">➥</span>icon='graduation-cap', prefix='fa')).add_to(m)                         <span class="fm-combinumeral">⑤</span>
folium.Marker(location=destination_point,icon=folium.Icon(color='green', <span class="fm-combinumeral">⑤</span>
<span class="fm-code-continuation-arrow">➥</span>icon='university', prefix='fa')).add_to(m)                             <span class="fm-combinumeral">⑤</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> The GPS coordinates (latitude and longitude) of the University of Toronto</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> The GPS coordinates of the equestrian statue as a source point</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> The GPS coordinates of the Bahen Centre for Information Technology as the destination</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Create a map centered around a specified point.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Add markers wih icons.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F09_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.9 Visualizing points of interest using folium markers</p>
  </div>

  <p class="body">The output of the code is interactive and allows for features such as zooming, panning, and even layer filtering (when enabled). Appendix A provides more details about map visualization libraries in Python.<a id="idIndexMarker015"/><a id="idIndexMarker016"/><a id="marker-72"/></p>

  <h2 class="fm-head" id="heading_id_4">3.2 Graph search</h2>

  <p class="body">As I mentioned in chapter 2, search algorithms can be broadly classified into deterministic and stochastic algorithms. In <i class="fm-italics">deterministic search</i>, the search algorithm follows a rigorous procedure, and its path and the values of both the design variables and the functions are repeatable. The algorithm will follow the same path for the same starting point whenever you run the program, whether it’s today or ten years in the future. In <i class="fm-italics">stochastic search</i>, on the other hand, the algorithm always has some randomness, and the solution is not exactly repeatable. Each time you run the algorithm, you may get slightly different results.<a id="idIndexMarker017"/><a id="idIndexMarker018"/></p>

  <p class="body">Based on the availability of information about the search space or domain knowledge (e.g., the distance from the current state to the goal), deterministic search algorithms can be broadly classified into <i class="fm-italics">blind</i> (or <i class="fm-italics">uninformed</i>) search and <i class="fm-italics">informed</i> search, as illustrated in figure 3.10. Some of these algorithms, such as Kruskal’s minimum spanning tree (MST) algorithm, will be covered in the next chapter. This chapter focuses on blind search algorithms. Blind search is a search approach where no information about the search space is needed.<a id="idIndexMarker019"/><a id="idIndexMarker020"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F10_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.10 Graph search methods</p>
  </div>

  <p class="body">A blind search may conclude upon discovering the first solution, depending on the algorithm’s termination criteria. However, the search space may contain numerous valid but non-optimal solutions, so a blind search may return a solution that meets all the requirements but does so in a non-optimal way. An optimal solution can be found by running a blind search following an exhaustive search or brute-force strategy to find all the feasible solutions, which can then be compared to select the best one. This is similar to applying the British Museum algorithm, which finds a solution by checking all possibilities one by one. Given the fact that blind search treats every node in the graph or tree equally, this search approach is often referred to as a <i class="fm-italics">uniform search</i>. <a id="idIndexMarker021"/><a id="marker-73"/></p>

  <p class="body">Examples of blind search algorithms include, but are not limited to, the following:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Breadth-first search</i> (BFS) is a graph traversal algorithm that builds the search tree by levels.<a id="idIndexMarker022"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Depth-first search</i> (DFS) is a graph traversal algorithm that first explores nodes going through one adjacent to the root, then the next adjacent, until it finds a solution or it reaches a dead end. <a id="idIndexMarker023"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Depth-limited search</i> (DLS) is a DFS with a predetermined depth limit.<a id="idIndexMarker024"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Iterative deepening search</i> (IDS), or <i class="fm-italics">iterative deepening depth-first search</i> (IDDFS), combines DFS’s space efficiency and BFS’s fast search by incrementing the depth limit until the goal is reached. <a id="idIndexMarker025"/><a id="idIndexMarker026"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Dijkstra’s algorithm</i> solves the single-source shortest-path problem for a weighted graph with non-negative edge costs.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Uniform-cost</i> search (UCS) is a variant of Dijkstra’s algorithm that uses the lowest cumulative cost to find a path from the source to the destination. It is equivalent to the BFS algorithm if the path cost of all edges is the same.<a id="idIndexMarker027"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Bidirectional</i> search (BS) is a combination of forward and backward search. It searches forward from the start and backward from the goal simultaneously.<a id="idIndexMarker028"/></p>
    </li>
  </ul>

  <p class="body">The following sections discuss graph traversal algorithms and shortest path algorithms, focusing on BFS, DFS, Dijkstra’s algorithm, UCS, and BS as examples of blind search approaches.</p>

  <h2 class="fm-head" id="heading_id_5">3.3 Graph traversal algorithms</h2>

  <p class="body">Graph traversal is the process of exploring the structure of a tree or a graph by visiting the nodes following a specific, well-defined rule. This category of graph search algorithms only seeks to find a path between two nodes without optimizing for the length of the final route.<a id="idIndexMarker029"/><a id="idIndexMarker030"/><a id="marker-74"/></p>

  <h3 class="fm-head1" id="heading_id_6">3.3.1 Breadth-first search</h3>

  <p class="body">Breadth-first search (BFS) is an algorithm where the traversal starts at a specified node (the source or starting node) and follows the graph layerwise, thus exploring all of the current node’s neighboring nodes (those directly connected to the current node). Then, if a result has not been found, the algorithm searches the next-level neighbor nodes. This algorithm finds a solution if one exists, assuming that a finite number of successors, or branches, always follow any node. Algorithm 3.1 shows the BFS steps.<a id="idIndexMarker031"/><a id="idIndexMarker032"/><a id="idIndexMarker033"/></p>

  <p class="fm-code-listing-caption">Algorithm 3.1 Breadth-first search (BFS)</p>
  <pre class="programlisting">Inputs: Source node, Destination node
Output: Route from source to destination
  
Initialize <i class="fm-italics">queue</i> <span class="cambria">←</span> a FIFO initialized with source node
Initialize <i class="fm-italics">explored</i> <span class="cambria">←</span> empty
Initialize <i class="fm-italics">found</i> <span class="cambria">←</span> False
  
While <i class="fm-italics">queue</i> is not empty and <i class="fm-italics">found</i> is False do
    Set <i class="fm-italics">node</i> <span class="cambria">←</span> <i class="fm-italics">queue.</i>dequeue()
    Add <i class="fm-italics">node</i> to <i class="fm-italics">explored</i>
    For <i class="fm-italics">child</i> in <i class="fm-italics">node.</i>expand() do
        If <i class="fm-italics">child</i> is not in <i class="fm-italics">explored</i> and <i class="fm-italics">child</i> is not in <i class="fm-italics">queue</i> then
            If <i class="fm-italics">child</i> is <i class="fm-italics">destination</i> then
                Update <i class="fm-italics">route</i> <span class="cambria">←</span> <i class="fm-italics">child</i> route()
                Update <i class="fm-italics">found</i> <span class="cambria">←</span> True
            Add <i class="fm-italics">child</i> to <i class="fm-italics">queue</i>
Return <i class="fm-italics">route</i></pre>

  <p class="body">BFS uses the queue as a data structure to maintain the states to be explored. A queue is a first in, first out (FIFO) data structure, where the node that has been sitting on the queue for the longest time is the next node to be expanded. BFS dequeues a state off the queue and then enqueues its successors back on the queue.<a id="idIndexMarker034"/></p>

  <p class="body">Let’s consider the 8-puzzle problem (sometimes called the <i class="fm-italics">sliding-block problem</i> or <i class="fm-italics">tile-puzzle problem</i>). The puzzle consists of an area divided into a 3 × 3 grid. The tiles are numbered 1 through 8, except for an empty (or blank) tile. The blank tile can be moved by swapping its position with any tile directly adjacent (up, down, left, right). The puzzle’s goal is to place the tiles so that they are arranged in order. Variations of the puzzle allow the empty tile to end up either at the first or last position. This problem is an example of a well-structured problem (WSP) with the following well-defined components:<a id="idIndexMarker035"/><a id="idIndexMarker036"/><a id="idIndexMarker037"/><a id="marker-75"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">States—Location of the blank and location of the eight tiles</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Operator (successor)—Blank moves left, right, up, and down</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Goal—Match the state given by the goal state</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Solution/path—Sequence through state space</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Stopping criteria—An ordered puzzle (reaching the Goal state)</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Evaluation criteria—Number of steps or path cost (the path length)</p>
    </li>
  </ul>

  <p class="body">Figure 3.11 illustrates the BFS steps for solving the 8-puzzle problem and the search tree traversal order. In this figure, the state represents the physical configuration of the 8-puzzle problem, and each node in the search tree is a data structure that includes information about its parent, children, depth, and the cost of the path from the initial state to this node. Level 1 nodes are generated from left to right by moving the blank title left, up, and right respectively. Moving forward, level 2 nodes are generated by expanding the previously generated nodes in level 1, avoiding the previously explored nodes. We keep repeating this procedure to traverse all the possible nodes or until we hit the goal (the shaded grid). The number of steps to reach the goal will depend mainly on the initial state of the 8-puzzle board. The highlighted numbers show the order of traverse. As you can see, BFS progresses horizontally before it proceeds vertically.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F11_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.11 Using BFS to solve the 8-puzzle problem</p>
  </div>

  <p class="body"><a id="marker-76"/>Listing 3.9 utilizes a generic BFS algorithm developed for this book, which can be found in the Optimization Algorithm Tools (optalgotools) Python package (see appendix A for installation instructions). The algorithm takes starting and goal states as inputs and returns a <code class="fm-code-in-text">solution</code> object. This <code class="fm-code-in-text">solution</code> object contains the actual result and some performance metrics, such as processing time, maximum space used, and the number of solution states explored. The <code class="fm-code-in-text">State</code> class and <code class="fm-code-in-text">visualize</code> function are defined in the complete listing available in the book’s GitHub repo. The <code class="fm-code-in-text">State</code> class helps manage some data structures and utility functions, and it will allow us to reuse this problem’s structure later with different algorithms.<a id="idIndexMarker038"/><a id="idIndexMarker039"/><a id="idIndexMarker040"/><a id="idIndexMarker041"/><a id="idIndexMarker042"/></p>

  <p class="fm-code-listing-caption">Listing 3.9 Solving the 8-puzzle problem using BFS</p>
  <pre class="programlisting">#!pip install optalgotools
from optalgotools.algorithms.graph_search import BFS    <span class="fm-combinumeral">①</span>
  
init_state = [[1,4,2], [3,7,5], [6,0,8]]
  
goal_state = [[0,1,2], [3,4,5], [6,7,8]]
  
  
init_state = State(init_state)                          <span class="fm-combinumeral">②</span>
goal_state = State(goal_state)   
  
  
if not init_state.is_solvable():                        <span class="fm-combinumeral">③</span>
     print("This puzzle is not solvable.")
else:
  
    solution = BFS(init_state, goal_state)
    print(f"Process time: {solution.time} s")
    print(f"Space required: {solution.space} bytes")
    print(f"Explored states: {solution.explored}")
    visualize(solution.result)                          <span class="fm-combinumeral">④</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> The BFS algorithm is imported from a library called optalgotools.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> See the State class in the complete listing.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Some boards are not solvable</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> See the visualize function in the complete listing.</p>

  <p class="body">This is an example solution, given the preceding inputs:</p>
  <pre class="programlisting">Process time: 0.015625 s
Space required: 624 bytes
Explored states: 7</pre>

  <p class="body">Figure 3.12 shows the state changes following the BFS algorithm.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F12_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.12 The step-by-step BFS solution using Python. BFS searches for a solution but does not consider optimality.</p>
  </div>

  <p class="body"><a id="marker-77"/>To really understand how BFS works, let’s look at the steps involved in a simple path-planning problem. This problem finds a collision-free path for a mobile robot or autonomous vehicle from a start position to a given destination amidst a collection of obstacles.</p>

  <p class="body-dialog">  1. Add the source node to the queue (figure 3.13).</p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F13_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.13 Solving the path-planning problem using BFS—step 1</p>
  </div>

  <p class="body-dialog">  2. The robot can only move to the south (S) node, as the east (E) and southeast (SE) nodes are obstructed (figure 3.14).<a id="marker-78"/></p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F14_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.14 Solving the path-planning problem using BFS—step 2</p>
  </div>

  <p class="body-dialog">  3. Take S out (FIFO), and explore its neighboring nodes, S and SE, with E being an obstructed node (figure 3.15).</p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F15_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.15 Solving the path-planning problem using BFS—step 3</p>
  </div>

  <p class="body-dialog">  4. Take S out (FIFO), and explore its neighboring nodes, S and SE (figure 3.16).</p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F16_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.16 Solving the path-planning problem using BFS—step 4</p>
  </div>

  <p class="body-dialog">  5. Take SE out (FIFO), and explore its neighboring nodes, E and NE (figure 3.17).<a id="marker-79"/></p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F17_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.17 Solving the path-planning problem using BFS—step 5</p>
  </div>

  <p class="body-dialog">  6. The FIFO queue continues until the destination node is found (figure 3.18). For simplicity, assuming that the robot wants to reach node E shown in figure 3.18, we can trace back up the tree to find the path from the source node to the goal, which will be Start-S-SE-E.</p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F18_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.18 Solving the path-planning problem using BFS—final routes for an intermediate goal node E and the final destination</p>
  </div>

  <p class="body">In BFS, every node generated must remain in memory. The number of nodes generated is at most <span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">b<sup class="fm-superscript">d</sup></i>)</span>, where <i class="timesitalic">b</i> represents the maximum branching factor for each node (i.e., the number of children the node has) and <i class="timesitalic">d</i> is the depth one must expand to reach the goal. In the previous example, with E as a goal node <span class="times">(<i class="fm-italics">b</i>=2, <i class="fm-italics">d</i>=3)</span>, the total number of traversed nodes is <span class="times">2<sup class="fm-superscript">3</sup>=8</span>, including the start node.</p>

  <p class="body">Aside from the algorithm’s ability to solve the problem at hand, algorithm efficiency is evaluated based on run time (time complexity), memory requirements, and the number of primitive operations required to solve the problem in the worst case. Examples of these primitive operations include, but are not limited to, expression evaluation, variable value assignment, array indexing, and method or function calls. <a id="idIndexMarker043"/><a id="marker-80"/></p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">Big <i class="timesitalic1">O</i> notation</p>

    <p class="fm-sidebar-text">Big <i class="timesitalic">O</i> notation describes the performance or complexity of an algorithm, usually under the worst-case scenario. Big <i class="timesitalic">O</i> notation helps us answer the question, “Will the algorithm scale?” <a id="idIndexMarker044"/></p>

    <p class="fm-sidebar-text">To obtain the big <i class="timesitalic">O</i> notation for a function <span class="times">f(<i class="fm-italics">x</i>)</span>, if <span class="times">f(<i class="fm-italics">x</i>)</span> is a sum of several terms, the one with the largest growth rate is kept, and all others are omitted. Moreover, if <span class="times">f(<i class="fm-italics">x</i>)</span> is a product of several factors, any constants (terms in the product that do not depend on <i class="fm-italics">x</i>) are omitted.</p>

    <p class="fm-sidebar-text">As an example, let’s look at the ticket pricing problem presented in chapter 1: <span class="times"><i class="fm-italics">f</i>(<i class="fm-italics">x</i>) = –20<i class="fm-italics">x</i><sup class="fm-superscript">2</sup> + 6200<i class="fm-italics">x</i> – 350000</span>. Assume that <i class="timesitalic">x</i> is a vector with size <i class="timesitalic">n</i> that represents <i class="timesitalic">n</i> different ticket prices. This function is the sum of three terms, of which the one with the highest growth rate is the one with the largest exponent as a function of <i class="timesitalic">x</i>, namely <span class="times">–20<i class="fm-italics">x</i><sup class="fm-superscript">2</sup></span>. We can now apply the second rule: <span class="times">–20<i class="fm-italics">x</i><sup class="fm-superscript">2</sup></span> is a product of <span class="times">–20</span> and <span class="times"><i class="fm-italics">x</i><sup class="fm-superscript">2</sup></span>, in which the first factor does not depend on <i class="timesitalic">x</i>. Dropping this factor results in the simplified form <span class="times"><i class="fm-italics">x</i><sup class="fm-superscript">2</sup></span>. Thus, we say that <span class="times"><i class="fm-italics">f</i>(<i class="fm-italics">x</i>)</span> is a big <i class="timesitalic">O</i> of <span class="times"><i class="fm-italics">n</i><sup class="fm-superscript">2</sup></span>, where <i class="timesitalic">n</i> is the size of the decision variable <i class="fm-italics">x</i>. Mathematically we can write <span class="times"><i class="fm-italics">f</i>(<i class="fm-italics">x</i>) <span class="cambria">∈</span> <i class="fm-italics">O</i>(<i class="fm-italics">n</i><sup class="fm-superscript">2</sup>)</span> (pronounced “order <i class="timesitalic">n</i> squared” or “<i class="timesitalic">O</i> of <i class="timesitalic">n</i> squared”), which represents a quadratic complexity (i.e., the growth rate is proportional to the square of the size of the ticket price vector).<a id="idIndexMarker045"/></p>
  </div>

  <p class="body">Table 3.2 shows examples of algorithm complexities, and figure 3.19 shows examples of big <i class="timesitalic">O</i> notations.<a id="idIndexMarker046"/><a id="marker-81"/></p>

  <p class="fm-table-caption">Table 3.2 Algorithm complexity</p>

  <table border="1" class="contenttable-1-table" id="table002" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="20%"/>
      <col class="contenttable-0-col" span="1" width="15%"/>
      <col class="contenttable-0-col" span="1" width="15%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Notation</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Name</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Effectiveness</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Description</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Examples</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(1)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Constant</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Excellent</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Running time does not depend on the input size. As the input size grows, the number of operations is not affected.</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Variable declaration</p>

          <p class="fm-table-body">Accessing an array element</p>

          <p class="fm-table-body">Retrieving information from a hash-table lookup</p>

          <p class="fm-table-body">Inserting and removing from a queue</p>

          <p class="fm-table-body">Pushing and popping on a stack</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(log <i class="fm-italics">n</i>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Logarithmic</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">High</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">As the input size grows, the number of operations grows very slowly. Whenever <i class="timesitalic">n</i> doubles or triples, etc., the running time increases by a constant.</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Binary search</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">O(<i class="fm-italics">n<sup class="fm-superscript">c</sup></i>)</span>,</p>

          <p class="fm-table-body"><span class="times">0 &lt; <i class="fm-italics">c</i> &lt; 1</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Fractional power or sublinear</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">High</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">As the input size grows, the number of operations is replicated in multiplication.</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Testing graph connectedness</p>

          <p class="fm-table-body">Approximating the number of connected components in a graph</p>

          <p class="fm-table-body">Approximating the weight of the minimum spanning tree (MST)</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">n</i>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Linear</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Medium</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">As the input size grows, the number of operations increases linearly. Whenever <i class="timesitalic">n</i> doubles, the running time doubles.</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Printing out an array’s elements</p>

          <p class="fm-table-body">Simple search</p>

          <p class="fm-table-body">Kadane’s algorithm</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">n</i> log <i class="fm-italics">n</i>) = <i class="fm-italics">O</i>(log <i class="fm-italics">n</i>!)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Linearithmic, loglinear, or quasilinear</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Medium</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">As the input size grows, the number of operations increases slightly faster than linear.</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Merge sort</p>

          <p class="fm-table-body">Heapsort</p>

          <p class="fm-table-body">Timsort</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">n<sup class="fm-superscript">c</sup></i>)</span>,</p>

          <p class="fm-table-body"><span class="times"><i class="fm-italics">c</i> &gt; 1</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Polynomial or algebraic</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Low</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">As the input size grows, the number of operations increases as the exponent increases.</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Minimum spanning tree (MST)</p>

          <p class="fm-table-body">Matrix determinant</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">n</i><sup class="fm-superscript">2</sup>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Quadratic</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Low</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Whenever <i class="timesitalic">n</i> doubles, the running time increases fourfold. The quadratic function is practical for use only on small problems.</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Selection sort</p>

          <p class="fm-table-body">Bubble sort</p>

          <p class="fm-table-body">Insertion sort</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">n</i><sup class="fm-superscript">3</sup>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Cubic</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Low</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Whenever <i class="timesitalic">n</i> doubles, the running time increases eightfold. The cubic function is practical for use only on small problems.</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Matrix multiplication</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">c<sup class="fm-superscript">n</sup></i>)</span>,</p>

          <p class="fm-table-body"><span class="times"><i class="fm-italics">c</i> &gt; 1</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Exponential</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Very low</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">As the input size grows, the number of operations increases exponentially. It is slow and usually not appropriate for practical use.</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Power set</p>

          <p class="fm-table-body">Tower of Hanoi</p>

          <p class="fm-table-body">Password cracking</p>

          <p class="fm-table-body">Brute force search</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">n</i>!)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Factorial</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Extremely low</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Extremely slow, as all possible permutations of the input data need to be checked. The factorial algorithm is even worse than the exponential function.</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Traveling salesman problem</p>

          <p class="fm-table-body">Permutations of a string</p>
        </td>
      </tr>
    </tbody>
  </table>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F19_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.19 Examples of big <i class="timesitalic">O</i> notations</p>
  </div>

  <p class="body"><a id="marker-82"/>Assume a computer with a processor speed of one million operations per second is used to handle a problem of size <span class="times"><i class="fm-italics">n</i> = 20,000</span>. Table 3.3 shows the running time according to the big <i class="timesitalic">O</i> notation of the algorithm used to solve this problem.<a id="idIndexMarker047"/></p>

  <p class="fm-table-caption">Table 3.3 Algorithm complexity and the running time</p>

  <table border="1" class="contenttable-1-table" id="table003" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="33%"/>
      <col class="contenttable-0-col" span="1" width="66%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Big <i class="fm-italics">O</i></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Running time</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(1)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">10<sup class="fm-superscript">-6</sup> seconds</span></p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(log <i class="fm-italics">n</i>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">14 × 10<sup class="fm-superscript">-6</sup> seconds</span></p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">n</i>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">0.02 seconds</span></p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">n</i> log <i class="fm-italics">n</i>) = <i class="fm-italics">O</i>(log <i class="fm-italics">n</i>!)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">0.028 seconds</span></p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">n</i><sup class="fm-superscript">2</sup>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">6.66 minutes</span></p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">n</i><sup class="fm-superscript">3</sup>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">92.6 days</span></p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">c<sup class="fm-superscript">n</sup></i>), <i class="fm-italics">c</i> = 2</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">1262.137 × 10<sup class="fm-superscript">6015</sup> years</span></p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">n</i>!)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">5768.665 × 10<sup class="fm-superscript">77331</sup> years</span> (this is many orders of magnitude larger than the age of the universe, which is around 13.7 billion years)</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">For a huge workspace where the goal is deep, the number of nodes could expand exponentially and demand a large memory requirement. In terms of time complexity, for a graph <span class="times">G = (V, E)</span>, BFS has a running time of <span class="times"><i class="fm-italics">O</i>(|<i class="fm-italics">V</i>| + |<i class="fm-italics">E</i>|)</span>, since each vertex is enqueued at most once and each edge is checked either once (for a directed graph) or at most twice (for an undirected graph). The time and space complexity of BFS is also defined in terms of a branching factor <i class="timesitalic">b</i> and the depth of the shallowest goal <i class="timesitalic">d</i>. Time complexity is <span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">b<sup class="fm-superscript">d</sup></i>)</span>, and space complexity is also <span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">b<sup class="fm-superscript">d</sup></i>)</span>.</p>

  <p class="body">Let’s consider a graph with a constant branching factor <span class="times"><i class="fm-italics">b</i> = 5</span>, nodes of size 1 KB, and a limit of 1,000 nodes scanned per second. The total number of nodes <i class="timesitalic">N</i> is given by the following equation:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F19_Khamis-EQ01.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">3.1</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body"><a id="marker-83"/>Table 3.4 shows the time and memory requirements to traverse this graph using BFS. <a id="idIndexMarker048"/><a id="idIndexMarker049"/><a id="idIndexMarker050"/></p>

  <p class="fm-table-caption">Table 3.4 BFS time and space complexity</p>

  <table border="1" class="contenttable-1-table" id="table004" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Depth <i class="timesitalic">d</i></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Nodes <i class="timesitalic">N</i></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Time</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Memory</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">2</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">31</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">31 ms</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">31 KB</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">4</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">781</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.781 second</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.78 MB</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">6</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">19,531</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">5.43 hours</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">19.5 MB</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">8</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">488,281</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">56.5 days</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">488 MB</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">10</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">12,207,031</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">3.87 years</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">12.2 GB</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">12</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">305,175,781</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">96.77 years</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">305 GB</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">14</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">7,629,394,531</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">2,419.26 years</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">7.63 TB</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">Next, we’ll take a look at the counterpart to the BFS algorithm, which searches deep into a graph first, rather than breadth-wise.</p>

  <h3 class="fm-head1" id="heading_id_7">3.3.2 Depth-first search</h3>

  <p class="body">Depth-first search (DFS) is a recursive algorithm that uses the idea of backtracking. It involves exhaustive searches of all the nodes by first going as deep as possible into the graph. Then, when it reaches the last layer with no result (i.e., when a dead end is reached), it backtracks up a layer and continues the search. In DFS, the deepest nodes are expanded first, and nodes of equal depth are ordered arbitrarily. Algorithm 3.2 shows the DFS steps.<a id="idIndexMarker051"/><a id="idIndexMarker052"/><a id="idIndexMarker053"/><a id="marker-84"/></p>

  <p class="fm-code-listing-caption">Algorithm 3.2 Depth-first search (DFS)</p>
  <pre class="programlisting">Inputs: Source node, Destination node
Output: Route from source to destination
  
Initialize <i class="fm-italics">Stack</i> <span class="cambria">←</span> a LIFO initialized with <i class="fm-italics">source</i>node
Initialize <i class="fm-italics">Explored</i> <span class="cambria">←</span> empty
Initialize <i class="fm-italics">Found</i> <span class="cambria">←</span> False
  
While <i class="fm-italics">stack</i> is not empty and <i class="fm-italics">found</i> is False do
    Set <i class="fm-italics">node</i> <span class="cambria">←</span> <i class="fm-italics">stack</i>.pop()
    Add <i class="fm-italics">node</i> to <i class="fm-italics">explored</i>
    For <i class="fm-italics">child</i> in <i class="fm-italics">node</i>.expand() do
        If <i class="fm-italics">child</i> is not in <i class="fm-italics">explored</i> and <i class="fm-italics">child</i> is not in <i class="fm-italics">stack</i> then
            If <i class="fm-italics">child</i> is <i class="fm-italics">destination</i> then
               Update <i class="fm-italics">route</i> <span class="cambria">←</span> <i class="fm-italics">child</i>.route()
               Update <i class="fm-italics">found</i> <span class="cambria">←</span> True
            Add <i class="fm-italics">child</i> to <i class="fm-italics">stack</i>
Return <i class="fm-italics">route</i></pre>

  <p class="body">As you may have noticed, the only difference between DFS and BFS is in how the data structure works. Rather than working down layer by layer (FIFO), DFS drills down to the bottommost layer and moves its way back to the starting node, using a last in, first out (LIFO) data structure known as a <i class="fm-italics">stack</i>. The stack contains the list of discovered nodes. The most recently discovered node is pushed onto the top of the LIFO stack. Subsequently, the next node to be expanded is popped from the top of the stack, and all of its successors are then added to the stack.<a id="idIndexMarker054"/></p>

  <p class="body">Figure 3.20 shows the DFS solution for the 8-puzzle problem we looked at before, based on moving the blank tile. As you can see, when the algorithm reaches a dead end or terminal node (such as node 7), it goes back to the last decision point (node 3) and proceeds with another alternative (node 8 and so on). In this example, a depth bound of 5 is placed to constrain the node expansion. This depth bound makes nodes 6, 7, 10, 11, 13, 14, 16, 17, 22, 23, 26, and 27 terminal nodes in the search tree (i.e., they have no successors).</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F20_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.20 Using DFS to solve the 8-puzzle problem</p>
  </div>

  <p class="body"><a id="marker-85"/>As you can see in listing 3.10, we only need to change the algorithm in the code to use DFS. I’ve also omitted the solution visualization, the reason for which you’ll see shortly. The <code class="fm-code-in-text">State</code> class is defined in the complete listing available in the book’s GitHub repo.<a id="idIndexMarker055"/></p>

  <p class="fm-code-listing-caption">Listing 3.10 Solving the 8-puzzle problem using DFS</p>
  <pre class="programlisting">from optalgotools.algorithms.graph_search import DFS
  
init_state = [[1,4,2],[3,7,5],[6,0,8]]
goal_state = [[0,1,2],[3,4,5],[6,7,8]]
  
init_state = State(init_state)
goal_state = State(goal_state)
  
if not init_state.is_solvable():                           <span class="fm-combinumeral">①</span>
     print("This puzzle is not solvable.")
else:
     solution = DFS(init_state, goal_state)                <span class="fm-combinumeral">②</span>
     print(f"Process time: {solution.time} s")
     print(f"Space required: {solution.space} bytes")
     print(f"Explored states: {solution.explored}")
     print(f"Number of steps: {len(solution.result)}")</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Some puzzles are not</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> The inputs for DFS are the same as for BFS.</p>

  <p class="body">Here’s the output of this code run with the preceding inputs:</p>
  <pre class="programlisting">Process time: 0.5247 s
Space required: 624 bytes
Explored states: 29
Number of steps: 30</pre>

  <p class="body"><a id="marker-86"/>As you can see, DFS is not great when dealing with very deep graphs, where the solution may be located closer to the top. You can also see why I opted not to visualize the final solution: there are a lot more steps in the solution than we had in BFS! Because the solution to this problem is closer to the root node, the solution generated by DFS is a lot more convoluted (30 steps) than with BFS.</p>

  <p class="body">Revisiting the path-planning problem, DFS can be used to generate an obstacle-free path from the start location to the destination as follows:</p>

  <p class="body-dialog">  1. Add the source node to the stack (figure 3.21).</p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F21_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.21 Solving the path-planning problem using DFS—step 1</p>
  </div>

  <p class="body-dialog">  2. Explore the S node, as the E and SE nodes are obstructed (figure 3.22).</p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F22_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.22 Solving the path-planning problem using DFS—step 2</p>
  </div>

  <p class="body-dialog">  3. Take S out (LIFO), and explore its neighboring nodes, S and SE, as E is an obstructed node (figure 3.23).<a id="marker-87"/></p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F23_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.23 Solving the path-planning problem using DFS—step 3</p>
  </div>

  <p class="body-dialog">  4. Take SE out (LIFO), and explore its neighboring nodes, SW, S, E, and NE (figure 3.24).</p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F24_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.24 Solving the path-planning problem using DFS—step 4</p>
  </div>

  <p class="body-dialog">  5. The next node to be expanded would be NE, and its successors would be added to the stack. The LIFO stack continues until the goal node is found. Once the goal is found, you can then trace back through the tree to obtain the path for the vehicle to follow (figure 3.25).<a id="marker-88"/></p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F25_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.25 Solving the path-planning problem using DFS—step 5</p>
  </div>

  <p class="body">DFS usually requires considerably less memory than BFS. This is mainly because DFS does not always expand every single node at each depth. However, DFS could continue down an unbounded branch forever in the case of a search tree with infinite depth, even if the goal is not located on that branch.</p>

  <p class="body">One way to handle this problem is to use <i class="fm-italics">constrained depth-first search</i>, where the search stops after reaching a certain depth. Time complexity of DFS is <span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">b<sup class="fm-superscript">d</sup></i>)</span> where <i class="timesitalic">b</i> is the branching factor and <i class="timesitalic">d</i> is the maximum depth of the search tree. This is terrible if <i class="timesitalic">d</i> is much larger than <i class="timesitalic">b</i>, but if solutions are found deep in the tree, it may be much faster than BFS. The space complexity of DFS is <span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">bd</i>)</span>, which is linear space! This space complexity represents the maximum number of nodes to be stored in memory. <a id="idIndexMarker056"/><a id="idIndexMarker057"/><a id="idIndexMarker058"/></p>

  <p class="body"><a id="marker-89"/>Table 3.5 summarizes the differences between BFS and DFS.<a id="idIndexMarker059"/><a id="idIndexMarker060"/><a id="idIndexMarker061"/><a id="idIndexMarker062"/><a id="idIndexMarker063"/></p>

  <p class="fm-table-caption">Table 3.5 BFS versus DFS</p>

  <table border="1" class="contenttable-1-table" id="table005" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="20%"/>
      <col class="contenttable-0-col" span="1" width="40%"/>
      <col class="contenttable-0-col" span="1" width="40%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th"/>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Breadth-first search (BFS)</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Depth-first search (DFS)</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">Space complexity</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">More expensive</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Less expensive. Requires only <span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">d</i>)</span> space, irrespective of the number of children per node.</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">Time complexity</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">More time efficient. A vertex at a lower level (closer to the root) is visited first before visiting a vertex that is at a higher level (far away from the root).</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Less time efficient</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">When it is preferred</p>
        </td>

        <td class="contenttable-1-td">
          <ul class="calibre8">
            <li class="fm-list-bullet1">
              <p class="list-t">If the tree is very deep</p>
            </li>

            <li class="fm-list-bullet1">
              <p class="list-t">If the branching factor is not excessive</p>
            </li>

            <li class="fm-list-bullet1">
              <p class="list-t">If the solution appears at a relatively shallow level (i.e., the solution is near the starting point in the tree)</p>
            </li>

            <li class="fm-list-bullet1">
              <p class="list-t">Example: Search the British royal family tree for someone who died a long time ago, as they would be closer to the top of the tree (e.g., King George VI).</p>
            </li>
          </ul>
        </td>

        <td class="contenttable-1-td">
          <ul class="calibre8">
            <li class="fm-list-bullet1">
              <p class="list-t">If the graph or tree is very wide with too many adjacent nodes</p>
            </li>

            <li class="fm-list-bullet1">
              <p class="list-t">If no path is excessively deep</p>
            </li>

            <li class="fm-list-bullet1">
              <p class="list-t">If solutions occur deeply in the tree (i.e., the target is far from the source)</p>
            </li>

            <li class="fm-list-bullet1">
              <p class="list-t">Example: Search the British royal family tree for someone who is still alive, as they would be near the bottom of the tree (e.g., Prince William).</p>
            </li>
          </ul>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">In applications where the weights of the edges in a graph are all equal (e.g., all length 1), the BFS and DFS algorithms outperform shortest path algorithms like Dijkstra’s in terms of time. Shortest path algorithms will be explained in the next section.</p>

  <h2 class="fm-head" id="heading_id_8">3.4 Shortest path algorithms</h2>

  <p class="body">Suppose that you were looking for the quickest way to go from your home to work. Graph traversal algorithms like BFS and DFS may eventually get you to your destination, but they certainly do not optimize for the distance traveled. We’ll discuss Dijkstra’s algorithm, uniform-cost search (UCS), and bidirectional Dijkstra's search as examples of blind search algorithms that try to find the shortest path between a source node and a destination node. <a id="idIndexMarker064"/><a id="idIndexMarker065"/><a id="idIndexMarker066"/></p>

  <h3 class="fm-head1" id="heading_id_9">3.4.1 Dijkstra’s search</h3>

  <p class="body"><a id="marker-90"/>Dijkstra’s algorithm is a graph search algorithm that solves the single-source shortest path problem for a fully connected graph with non-negative edge path costs, producing a shortest-path tree. Dijkstra’s algorithm was published in 1959, and it’s named after Dutch computer scientist Edsger Dijkstra. This algorithm is the base of several other graph search algorithms that are commonly used to solve routing problems in popular navigation apps, as illustrated in figure 3.26. The algorithm follows dynamic programming approaches where the problem is recursively divided into simple subproblems. Dijkstra’s algorithm is uninformed, meaning it does not need to know the target node beforehand and doesn’t use heuristic information.<a id="idIndexMarker067"/><a id="idIndexMarker068"/><a id="idIndexMarker069"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F26_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.26 Dijkstra’s algorithm and examples of its variants and extensions</p>
  </div>

  <p class="body">Algorithm 3.3 shows the steps of the original version of Dijkstra’s algorithm for finding the shortest path between a known single source node to all other nodes in the graph or tree.</p>

  <p class="fm-code-listing-caption">Algorithm 3.3 Dijkstra’s algorithm</p>
  <pre class="programlisting">Inputs: A graph with weighted edges and a source node
Output: Shortest path from the source to all other nodes in the graph
  
Initialize <i class="fm-italics">shortest_dist</i> <span class="cambria">←</span> empty
Initialize <i class="fm-italics">unrelaxed_nodes</i> <span class="cambria">←</span> empty
Initialize <i class="fm-italics">seen</i> <span class="cambria">←</span> empty
  
For <i class="fm-italics">node</i> in <i class="fm-italics">graph</i>
    Set <i class="fm-italics">shortest_dist[node]</i> = Infinity
    Add <i class="fm-italics">node</i> to <i class="fm-italics">unrelaxed_nodes</i>
    Set <i class="fm-italics">shortest_dist[source]</i> <span class="cambria">←</span> 0
  
While <i class="fm-italics">unrelaxed_nodes</i> is not empty do
    Set <i class="fm-italics">node</i> <span class="cambria">←</span> <i class="fm-italics">unrelaxed_nodes</i>.pop()
    Add <i class="fm-italics">node</i> to <i class="fm-italics">seen</i>
    For <i class="fm-italics">child</i> in <i class="fm-italics">node</i>.expand() do
        If <i class="fm-italics">child</i> in <i class="fm-italics">seen</i> then skip
        Update <i class="fm-italics">distance</i> <span class="cambria">←</span> <i class="fm-italics">shortest_dist[node]</i> + length of edge to <i class="fm-italics">child</i>
        If <i class="fm-italics">distance</i> &lt; <i class="fm-italics">shortest_dist[child]</i> then
           Update <i class="fm-italics">shortest_dist[child]</i> <span class="cambria">←</span> <i class="fm-italics">distance</i>
           Update <i class="fm-italics">child.parent</i> <span class="cambria">←</span> node
Return <i class="fm-italics">shortest_dist</i></pre>

  <p class="body"><a id="marker-91"/>Dijkstra’s algorithm and its variants presented in the code for this book are all modified to require a target node. This improves the processing time when working with large graphs (e.g., road networks).</p>

  <p class="body">Let’s look at how Dijkstra’s algorithm finds the shortest path between any two nodes in a graph. The priority queue is used to pop the element of the queue with the highest priority according to some ordering function (in this case, the shortest distance between the node and the source node).</p>

  <p class="body-dialog">  0. Initial list, no predecessors: priority queue = {} (figure 3.27).</p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F27_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.27 Finding the shortest path using Dijkstra’s algorithm—step 0</p>
  </div>

  <p class="body-dialog">  1. The closest node to the source node is S, so add it to the priority queue. Update the cumulative distances (i.e., distances from the source node <i class="timesitalic">S</i> to get to the node) and predecessors for A, C, and D. Priority queue = {S} (figure 3.28).</p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F28_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.28 Finding the shortest path using Dijkstra’s algorithm—step 1</p>
  </div>

  <p class="body-dialog">  2. The next closest node is C, so add it to the priority queue. Update the distances and predecessors for A and D. Priority queue = {S, C} (figure 3.29).<a id="marker-92"/></p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F29_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.29 Finding the shortest path using Dijkstra’s algorithm—step 2</p>
  </div>

  <p class="body-dialog">  3. The next closest node is D, so add it to the priority queue. Update the distances and predecessor for B. Priority queue = {S, C, D} (figure 3.30).</p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F30_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.30 Finding the shortest path using Dijkstra’s algorithm—step 3</p>
  </div>

  <p class="body-dialog">  4. The next closest node to the source node is A, so add it to the priority queue. Priority queue = {S, C, D, A} (figure 3.31).<a id="marker-93"/></p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F31_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.31 Finding the shortest path using Dijkstra’s algorithm—step 4</p>
  </div>

  <p class="body-dialog">  5. The next step is to add the remaining node B to complete the search (figure 3.32). Priority queue = {S, C, D, A, B}. All nodes are now added.</p>

  <div class="figure">
    <p class="figuree"><img alt="" class="calibre4" src="../Images/CH03_F32_Khamis.png"/></p>

    <p class="figurecaptione">Figure 3.32 Finding the shortest path using Dijkstra’s algorithm—step 5</p>
  </div>

  <p class="body">Once the search is complete, you can choose your goal node and find the shortest path from the table. For example, if the goal node is A, the shortest path between S and A is S-C-A with length 9. Likewise, if the goal node is B, the shortest path between S and B is S-C-D-B with a distance of 10.</p>

  <p class="body">Note that we can’t use Dijkstra's search on our 8-puzzle problem as Dijkstra's search requires knowledge of the entire problem space beforehand. While the problem has a finite number of possible states (exactly 9!/2), the scale of that solution space makes the Dijkstra's search not very feasible. <a id="idIndexMarker070"/><a id="idIndexMarker071"/><a id="idIndexMarker072"/></p>

  <h3 class="fm-head1" id="heading_id_10">3.4.2 Uniform-cost search (UCS)</h3>

  <p class="body"><a id="marker-94"/>The uniform-cost search (UCS) algorithm is a blind search algorithm that uses the lowest cumulative cost to find a path from the origin to the destination. Essentially, the algorithm organizes nodes to be explored either by their cost (with the lowest cost as the highest priority) for minimization problems, or by their utility (with the highest utility as the highest priority) in the case of maximization problems. <a id="idIndexMarker073"/><a id="idIndexMarker074"/><a id="idIndexMarker075"/></p>

  <p class="body">As nodes are popped from the queue, we add the node’s children to the queue. If a child already exists in the priority queue, the priorities of both copies of the child are compared, and the lowest cost (the highest priority) in a minimization problem is accepted. This ensures that the path to each child is the shortest one available. We also maintain a visited list so we can avoid revisiting nodes that have already been popped from the queue. UCS behaves like BFS when all the edge costs in the graph are equal or identical. In this case, UCS will expand nodes in the same order as BFS—level by level or breadth-first. Algorithm 3.4 shows the steps of the UCS algorithm.</p>

  <p class="fm-code-listing-caption">Algorithm 3.4 Uniform-cost search (UCS)</p>
  <pre class="programlisting">Inputs: A graph with edges, a source node, a destination node
Output: Shortest path from source to destination in the graph
  
Initialize <i class="fm-italics">priority_queue</i> <span class="cambria">←</span> <i class="fm-italics">source</i>
Initialize <i class="fm-italics">found</i> <span class="cambria">←</span> False
Initialize <i class="fm-italics">seen</i> <span class="cambria">←</span> <i class="fm-italics">source</i>
  
While <i class="fm-italics">priority_queue</i> is not empty and <i class="fm-italics">found</i> is False do
    Set <i class="fm-italics">node</i> <span class="cambria">←</span> priority_queue.pop()
    Update <i class="fm-italics">seen</i> <span class="cambria">←</span> <i class="fm-italics">node</i>
    Update node_cost <span class="cambria">←</span> cumulative distance from source
    If <i class="fm-italics">node</i> is <i class="fm-italics">destination</i> then
        Update <i class="fm-italics">route</i> <span class="cambria">←</span> <i class="fm-italics">node</i>.route()
        Update <i class="fm-italics">found</i> <span class="cambria">←</span> True
    For child in node.expand() do
        If child in priority_queue then
            If child.priority &lt; priority_queue[child].priority then
               Set priority_queue[child].priority = child.priority
        Else
            Update priority_queue <span class="cambria">←</span> child
        Update priority_queue[child].priority <span class="cambria">←</span> node_cost
Return route</pre>

  <p class="body"><a id="marker-95"/>UCS is a variant of Dijkstra’s algorithm that is useful for large graphs because it is less time-consuming and has fewer space requirements. Whereas Dijkstra's adds all nodes to the queue at the start with an infinite cost, UCS fills the priority queue gradually. For example, consider the problem of finding the shortest path between every node pair in a graph. As a graph’s size and complexity grows, it quickly becomes apparent that UCS is more efficient, as it does not require knowing the entire graph beforehand. Table 3.6 shows the difference in processing time between Dijkstra's and UCS on graphs of different sizes. These numbers were collected using the code in Comparison.ipynb, available in the book’s GitHub repo, on an Intel Core i9-9900K at 3.60 GHz without multiprocessing or multithreading.</p>

  <p class="fm-table-caption">Table 3.6 UCS versus Dijkstra's</p>

  <table border="1" class="contenttable-1-table" id="table006" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="33.33%"/>
      <col class="contenttable-0-col" span="1" width="33.33%"/>
      <col class="contenttable-0-col" span="1" width="33.33%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head"><span class="times">Graph size = |V| + |E|</span></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Dijkstra time</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Uniform-Cost Search (UCS) time</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">108</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.25 s</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.14 s</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">628</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">84.61 s</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">58.23 s</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">1,514</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">2,082.97 s</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1,360.98 s</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">Note that running UCS on our 8-puzzle problem requires a distance property for each state (this defaults to 1), and it generates decent results overall (around 6.2 KB of space used and 789 states explored). It is important to note that because the edge lengths are all equal, UCS cannot prioritize new nodes to explore. Thus, the solution loses the advantage of shortest path algorithms, namely, the ability to optimize for a more compact solution. In the next chapter, you’ll see ways of calculating artificial distances between these states, ultimately generating solutions quickly and minimizing the number of steps required.</p>

  <h3 class="fm-head1" id="heading_id_11">3.4.3 Bidirectional Dijkstra's search</h3>

  <p class="body"><a id="marker-96"/>Bidirectional search simultaneously applies forward search and backward search. As illustrated in figure 3.33, it runs a search forward from the initial source state S<span class="cambria">→</span>G and backward from the final goal state G<span class="cambria">→</span>S until they meet.<a id="idIndexMarker076"/><a id="idIndexMarker077"/><a id="idIndexMarker078"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F33_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.33 Bidirectional Dijkstra</p>
  </div>

  <p class="body">As shown in figure 3.33, the Dijkstra's search space is <span class="times"><i class="fm-italics">C</i><sub class="fm-subscript">1</sub> = 4<i class="fm-italics">πr</i><sup class="fm-superscript">2</sup></span>, and the bidirectional Dijkstra's search space is represented by <span class="times"><i class="fm-italics">C</i><sub class="fm-subscript">2</sub> + <i class="fm-italics">C</i><sub class="fm-subscript">3</sub> = 2<i class="fm-italics">πr</i><sup class="fm-superscript">2</sup></span>. This means that we reduce the search space by about a factor of two. The following algorithm shows the steps of the bidirectional Dijkstra's algorithm.</p>

  <p class="fm-code-listing-caption">Algorithm 3.5 Bidirectional Dijkstra's</p>
  <pre class="programlisting">Inputs: A graph, a source node, a destination node
Output: Shortest path from source to destination in the graph
  
Initialize <i class="fm-italics">frontier_f</i> <span class="cambria">←</span> initialized with source
Initialize <i class="fm-italics">frontier_b</i> <span class="cambria">←</span> initialized with destination
Initialize <i class="fm-italics">explored_f</i> <span class="cambria">←</span> empty
Initialize <i class="fm-italics">explored_b</i> <span class="cambria">←</span> empty
Initialize <i class="fm-italics">found</i> <span class="cambria">←</span> False
Initialize <i class="fm-italics">collide</i> <span class="cambria">←</span> False
Initialize <i class="fm-italics">altr_expand</i> <span class="cambria">←</span> False
  
While <i class="fm-italics">frontier_f</i> is not empty and <i class="fm-italics">frontier_b</i> is not empty and not <i class="fm-italics">collide</i> and not <i class="fm-italics">found</i> do
    If altr_expand then
        Set node <span class="cambria">←</span> frontier_f.pop()
        Add node to explored_f
        For child in node.expand() do
            If child in explored_f then continue
            If child is destination then
                Update route <span class="cambria">←</span> child.route()
                Update found <span class="cambria">←</span> True
            If child in explored_b then
                Update route <span class="cambria">←</span> child.route() + reverse(overlapped.route())
                Update collide <span class="cambria">←</span> True
            Add child to frontier_f
        Update altr_expand <span class="cambria">←</span> not altr_expand
    Else
        Update node <span class="cambria">←</span> frontier_b.pop()
        Add node to explored_b
        For child in node.expand() do
            If child in explored_b then continue
            If child is origin then
               Update route <span class="cambria">←</span> child.route()
               Update found <span class="cambria">←</span> True
            If child in explored_f then
               Update route <span class="cambria">←</span> reverse(child.route()) + overlapped.route()
               Update collide <span class="cambria">←</span> True
            Add child to frontier_b
        Update altr_expand <span class="cambria">←</span> not altr_expand
Return route</pre>

  <p class="body">This approach is more efficient because of the time complexities involved. For example, a BFS search with a constant branching factor <i class="timesitalic">b</i> and depth <i class="timesitalic">d</i> would have an overall <span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">b<sup class="fm-superscript">d</sup></i>)</span> space complexity. However, by running two BFS searches in opposite directions with only half the depth <span class="times">(<i class="fm-italics">d</i>/2)</span>, the space complexity becomes <span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">b<sup class="fm-superscript">d</sup></i><sup class="fm-superscript">/2</sup> + <i class="fm-italics">b<sup class="fm-superscript">d</sup></i><sup class="fm-superscript">/2</sup>)</span> or simply <span class="times">O(<i class="fm-italics">b<sup class="fm-superscript">d</sup></i><sup class="fm-superscript">/2</sup>)</span>, which is significantly lower.</p>

  <p class="body"><a id="marker-97"/>Figure 3.34 shows the difference between the Dijkstra's and bidirectional Dijkstra's algorithms in exploring 50,841 nodes in the City of Toronto.<a id="idIndexMarker079"/><a id="idIndexMarker080"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F34_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.34 Dijkstra's vs. bidirectional Dijkstra's—forward exploration from the left and backward exploration from the right</p>
  </div>

  <h2 class="fm-head" id="heading_id_12">3.5 Applying blind search to the routing problem</h2>

  <p class="body">Puzzle games and simple grid routing problems are nice for understanding how an algorithm works. However, it’s time we look at some real-world examples and outcomes of using these algorithms. For example, imagine that you are visiting the King Edward VII equestrian statue at Queen’s Park in Toronto when you suddenly remember you have a meeting at the Bahen Centre for Information Technology at the University of Toronto. I initially presented this problem when we first discussed road network graphs at the beginning of this chapter. There are a couple of assumptions we’ll make when considering this problem:<a id="idIndexMarker081"/><a id="idIndexMarker082"/><a id="marker-98"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">You aren’t able to open a navigation app or call a friend for help, as your phone is out of battery power.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">You know your destination is somewhere in Toronto, but you have no clue where it is with reference to your starting location. (In later chapters, you’ll learn how knowing your destination’s direction can help generate near-optimal solutions in a very short amount of time.)</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Once you start using a rule for routing to your destination, you’ll stick to that r<a id="idTextAnchor000"/>ule.</p>
    </li>
  </ul>

  <p class="body">Let’s look at how we might be able to simulate our pathfinding skills using BFS, DFS, Dijkstra's, UCS, and bidirectional Dijkstra's. The code for this example is located in the book’s GitHub repo (Comparison.ipynb). Figures 3.35 to 3.37 show the routes generated by these blind search algorithms.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F35_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.35 Shortest path generated using BFS. BFS searches each layer first before moving to the next. This works best for graphs that are not very broad and that have a solution near the root node.</p>
  </div>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F36_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.36 Shortest path generated using DFS. DFS searches as deep in the graph as possible before backtracking. This works best when the graph is not very deep and solutions are located further away from the root node.<a id="marker-99"/></p>
  </div>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F37_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.37 Shortest path generated using Dijkstra’s, UCS, and bidirectional Dijkstra’s. All three of these algorithms will produce the same solution (the optimal routing) but will handle memory use and node exploration differently.</p>
  </div>

  <p class="body">It is worth noting that the <code class="fm-code-in-text">dijkstra_path</code> function in NetworkX uses Dijkstra’s method to compute the shortest weighted path between two nodes in a graph. Our optalgo- tools package also provides an implementation for different graph search algorithms such as BFS, DFS, Dijkstra's, UCS, and bidirectional Dijkstra's. The implementation of Dijkstra’s algorithm in optalgotools has been modified to work with our OSM data because graphs generated from maps will naturally have self-loops and parallel edges. Parallel edges may result in a route that is not the shortest available, as the route length depends heavily on which parallel edge was chosen when a particular path was generated. In figure 3.38, the shortest path from 0 to 2 may be returned as having a length of 7 if the top edge connecting 0 and 1 is chosen when calculating that path, versus a length of 3 when selecting the bottom edge.<a id="idIndexMarker083"/><a id="marker-100"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F38_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.38 Parallel edges may be problematic because finding the shortest path depends on which parallel edge is selected during graph exploration.</p>
  </div>

  <p class="body">Self-loops also cause trouble for the original Dijkstra’s algorithm. If a graph contains a self-loop, the shortest path to a node might come from itself. At that point, we would be unable to generate a route (figure 3.39).</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH03_F39_Khamis.png"/></p>

    <p class="figurecaption">Figure 3.39 Self-loops may disrupt the chain of parent-child nodes, which prevents us from retracing the route after a solution has been found.</p>
  </div>

  <p class="body">These two problems are generally easy but nontrivial to avoid. For parallel edges, we select the edge with the lowest weight (shortest length) and discard any other parallel edge. With self-loops, we can ignore the loop entirely, as negative-weight loops do not exist in most routing problems (a road cannot have a negative length), and positive-weight loops cannot be part of the shortest path. Additionally, the version of Dijkstra’s algorithm used in this book terminates upon finding the target node, as opposed to the traditional implementation, which ends only when the shortest path from the root node to all other nodes is found.</p>

  <p class="body">Table 3.7 compares BFS, DFS, Dijkstra's, and UCS with regards to path length, process time, space required, and the number of explored nodes. As you can see from these results, Dijkstra’s, UCS, and the bidirectional Dijkstra’s algorithms produce optimal results, with varying degrees of time and space cost. While both BFS and DFS find feasible solutions in the shortest time, the solutions delivered are not optimal and, in the case of DFS, are not even plausible. On the other hand, DFS requires knowing the entire graph beforehand, which is costly and sometimes not very practical. Much of selecting an appropriate search algorithm for a specific problem involves determining the ideal balance between processing time and space requirements. In later chapters, we’ll look at algorithms that produce near-optimal solutions and that are often used when optimal solutions are either impossible or impractical to find. Note that all these solutions are feasible; they all produce a valid (if sometimes convoluted) path from point A to point B.</p>

  <p class="fm-table-caption">Table 3.7 Comparing BFS, DFS, Dijkstra's, and UCS, where <i class="timesitalic">b</i> is the branching factor, <i class="timesitalic">m</i> is the maximum depth of the search tree, <i class="timesitalic">d</i> is the shallowest graph depth, <i class="timesitalic">E</i> is the number of edges, and <i class="timesitalic">V</i> is the number of vertices.</p>

  <table border="1" class="contenttable-1-table" id="table007" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="11%"/>
      <col class="contenttable-0-col" span="1" width="11%"/>
      <col class="contenttable-0-col" span="1" width="11%"/>
      <col class="contenttable-0-col" span="1" width="11%"/>
      <col class="contenttable-0-col" span="1" width="11%"/>
      <col class="contenttable-0-col" span="1" width="23%"/>
      <col class="contenttable-0-col" span="1" width="11%"/>
      <col class="contenttable-0-col" span="1" width="11%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Algorithm</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Cost (meters)</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Process time (s)</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Space (bytes)</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Explored nodes</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Worst-case time</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Worst-case space</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Optimality</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">BFS</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">955.962</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.015625</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1,152</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">278</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">b<sup class="fm-superscript">d</sup></i>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">b<sup class="fm-superscript">d</sup></i>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">DFS</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">3347.482</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.015625</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1,152</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">153</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">b<sup class="fm-superscript">m</sup></i>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">bm</i>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">Dijkstra’s</p>
        </td>

        <td class="contenttable-1-td" rowspan="3">
          <p class="fm-table-body">806.892</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.0625</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">3,752</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">393</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(|<i class="fm-italics">E</i>| + |<i class="fm-italics">V</i>| log |<i class="fm-italics">V</i>|)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(|<i class="fm-italics">V</i>|)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">UCS</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.03125</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">592</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">393</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>((<i class="fm-italics">b</i> + |<i class="fm-italics">E</i>|) * <i class="fm-italics">d</i>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">b<sup class="fm-superscript">d</sup></i>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">Bidirectional Dijkstra’s</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.046875</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">3,752</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">282</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">b<sup class="fm-superscript">d</sup></i><sup class="fm-superscript">/2</sup>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">b<sup class="fm-superscript">d</sup></i><sup class="fm-superscript">/2</sup>)</span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body"><a id="marker-101"/>In the next chapter, we will look at how search can be optimized if we utilize domain-specific knowledge instead of searching blindly. We’ll dive right into informed search methods and see how we can use these algorithms to solve minimum spanning tree and shortest path problems.<a id="idIndexMarker084"/><a id="idIndexMarker085"/></p>

  <h2 class="fm-head" id="heading_id_13">Summary</h2>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">Conventional graph search algorithms (blind and informed search algorithms) are deterministic search algorithms that explore a graph either for general discovery or for explicit search.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">A graph is a nonlinear data structure consisting of vertices and edges.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Blind (uninformed) search is a search approach where no information about the search space is used.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Breadth-first search (BFS) is a graph traversal algorithm that examines all the nodes in a search tree on one level before considering any of the nodes on the next level.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Depth-first search (DFS) is a graph traversal algorithm that starts at the root or an initial node or vertex, follows one branch as far as possible, and then backtracks to explore other branches until a solution is found or all paths are exhausted.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Depth-limited search (DLS) is a constrained version of DFS with a predetermined depth limit, preventing it from exploring paths beyond a certain depth.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Iterative deepening search (IDS), or iterative deepening depth-first search (IDDFS), combines DFS’s space efficiency and BFS’s fast search by incrementing the depth limit until the goal is reached.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Dijkstra’s algorithm solves the single-source shortest path problem for a weighted graph with non-negative edge costs.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Uniform-cost search (UCS) is a variant of Dijkstra’s algorithm that uses the lowest cumulative cost to find a path from the source to the destination. It is equivalent to the BFS algorithm if the path costs of all edges are the same.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Bidirectional search (BS) is a combination of forward and backward search. It searches forward from the start and backward from the goal simultaneously.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Selecting a search algorithm involves determining the target balance between time complexity, space complexity, and prior knowledge of the search space, among other factors.<a id="marker-102"/></p>
    </li>
  </ul>
</body></html>