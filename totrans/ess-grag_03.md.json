["```py\nMATCH (:Reviewer)-[r:REVIEWED]->(m:Movie)<-[:DIRECTED]-(:Director {name: 'Steven Spielberg'})\nRETURN m.title, AVG(r.score) AS avg_rating\nORDER BY avg_rating DESC\nLIMIT 3\n```", "```py\nMATCH (m:Movie {title: 'The Matrix'}) RETURN m.country\n```", "```py\nMATCH (m:Movie {title: 'The Matrix'})-[:PRODUCED_IN]->(c:Country)\n↪ RETURN c.name\n```", "```py\nLabelA {property_a: STRING}\n```", "```py\nREL_TYPE {rel_prop: STRING}\n```", "```py\n(:LabelA)-[:REL_TYPE]->(:LabelB)\n(:LabelA)-[:REL_TYPE]->(:LabelC)\n```", "```py\nNODE_PROPERTIES_QUERY = \"\"\"\nCALL apoc.meta.data()\nYIELD label, other, elementType, type, property\nWHERE NOT type = \"RELATIONSHIP\" AND elementType = \"node\"\nWITH label AS nodeLabels, collect({property:property, type:type}) AS properties\nRETURN {labels: nodeLabels, properties: properties} AS output\n\"\"\"\n\nREL_PROPERTIES_QUERY = \"\"\"\nCALL apoc.meta.data()\nYIELD label, other, elementType, type, property\nWHERE NOT type = \"RELATIONSHIP\" AND elementType = \"relationship\"\nWITH label AS relType, collect({property:property, type:type}) AS properties\nRETURN {type: relType, properties: properties} AS output\n\"\"\"\n\nREL_QUERY = \"\"\"\nCALL apoc.meta.data()\nYIELD label, other, elementType, type, property\nWHERE type = \"RELATIONSHIP\" AND elementType = \"node\"\nUNWIND other AS other_node\nRETURN {start: label, type: property, end: toString(other_node)} AS output\n\"\"\"\n```", "```py\ndef get_structured_schema(driver: neo4j.Driver) -> dict[str, Any]:\n    node_labels_response = driver.execute_query(NODE_PROPERTIES_QUERY)\n    node_properties = [\n        data[\"output\"]\n        for data in [r.data() for r in node_labels_response.records]\n    ]\n\n    rel_properties_query_response = driver.execute_query(REL_PROPERTIES_QUERY)\n    rel_properties = [\n        data[\"output\"]\n        for data in [r.data() for r in rel_properties_query_response.records]\n    ]\n\n    rel_query_response = driver.execute_query(REL_QUERY)\n    relationships = [\n        data[\"output\"]\n        for data in [r.data() for r in rel_query_response.records]\n    ]\n\n    return {\n        \"node_props\": {el[\"labels\"]: el[\"properties\"] for el in node_properties},\n        \"rel_props\": {el[\"type\"]: el[\"properties\"] for el in rel_properties},\n        \"relationships\": relationships,\n    }\n```", "```py\ndef get_schema(structured_schema: dict[str, Any]) -> str:\n    def _format_props(props: list[dict[str, Any]]) -> str:\n        return \", \".join([f\"{prop['property']}: {prop['type']}\" for prop in props])\n\n    formatted_node_props = [\n        f\"{label} {{{_format_props(props)}}}\"\n        for label, props in structured_schema[\"node_props\"].items()\n    ]\n\n    formatted_rel_props = [\n        f\"{rel_type} {{{_format_props(props)}}}\"\n        for rel_type, props in structured_schema[\"rel_props\"].items()\n    ]\n\n    formatted_rels = [\n        f\"(:{element['start']})-[:{element['type']}]->(:{element['end']})\"\n        for element in structured_schema[\"relationships\"]\n    ]\n\n    return \"\\n\".join(\n        [\n            \"Node labels and properties:\",\n            \"\\n\".join(formatted_node_props),\n            \"Relationship types and properties:\",\n            \"\\n\".join(formatted_rel_props),\n            \"The relationships:\",\n            \"\\n\".join(formatted_rels),\n        ]\n    )\n```", "```py\nprompt_template = \"\"\"\nInstructions:\nGenerate Cypher statement to query a graph database to get the data to answer the following user question.\n\nGraph database schema:\nUse only the provided relationship types and properties in the schema.\nDo not use any other relationship types or properties that are not provided in the schema.\n{schema}\n\nTerminology mapping:\nThis section is helpful to map terminology between the user question and the graph database schema.\n{terminology}\nExamples:\nThe following examples provide useful patterns for querying the graph database.\n{examples}\n\nFormat instructions:\nDo not include any explanations or apologies in your responses.\nDo not respond to any questions that might ask anything else than for you to\nconstruct a Cypher statement.\nDo not include any text except the generated Cypher statement.\nONLY RESPOND WITH CYPHER—NO CODE BLOCKS.\n\nUser question: {question}\n\"\"\"\n```", "```py\nquestion = \"Who directed the most movies?\"\n\nschema_string = get_schema(neo4j_driver)\n\nterminology_string = \"\"\"\nPersons: When a user asks about a person by trade like actor, writer, director, producer,  or reviewer, they are referring to a node with the label 'Person'.\nMovies: When a user asks about a film or movie, they are referring to a node with the label Movie.\n\"\"\"\n\nexamples = [[\"Who are the two people acted in most movies together?\", \"MATCH (p1:Person)-[:ACTED_IN]->(m:Movie)<-[:ACTED_IN]-(p2:Person) WHERE p1 <> p2 RETURN p1.name, p2.name, COUNT(m) AS movieCount ORDER BY movieCount DESC LIMIT 1\"]]\n\nfull_prompt = prompt_template.format(question=question, schema=schema_string, terminology=terminology_string,examples=\"\\n\".join([f\"Question: {e[0]}\\nCypher: {e[1]}\" for i, e in enumerate(examples)]))\nprint(full_prompt)\n```", "```py\nMovie {tagline: STRING, title: STRING, released: INTEGER}\nPerson {born: INTEGER, name: STRING}\n```", "```py\nACTED_IN {roles: LIST}\nREVIEWED {summary: STRING, rating: INTEGER}\n```", "```py\n(:Person)-[:ACTED_IN]->(:Movie)\n(:Person)-[:DIRECTED]->(:Movie)\n(:Person)-[:PRODUCED]->(:Movie)\n(:Person)-[:WROTE]->(:Movie)\n(:Person)-[:FOLLOWS]->(:Person)\n(:Person)-[:REVIEWED]->(:Movie)\n```", "```py\nCypher: MATCH (p1:Person)-[:ACTED_IN]->(m:Movie)<-[:ACTED_IN]-(p2:Person)\n↪ WHERE p1 <> p2 RETURN p1.name, p2.name, COUNT(m) AS movieCount\n↪ ORDER BY movieCount DESC LIMIT 1\n```", "```py\nMATCH (p:Person)-[:DIRECTED]->(m:Movie)\nRETURN p.name, COUNT(m) AS movieCount\nORDER BY movieCount\nDESC LIMIT 1\n```"]