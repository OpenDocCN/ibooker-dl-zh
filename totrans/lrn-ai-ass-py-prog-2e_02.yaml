- en: 3 Designing functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 设计函数
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Functions in Python and their role in designing software
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的函数及其在软件设计中的作用
- en: The standard workflow when interacting with Copilot
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Copilot交互的标准工作流程
- en: Examples of writing good functions using Copilot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Copilot编写良好函数的示例
- en: Reasonable tasks for Copilot to solve
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot可以解决的合理任务
- en: One of the hardest challenges for programming novices is to know what a reasonable
    task is to give to Copilot so that it finds a good solution. If you give Copilot
    too big of a task, it will often fail in spectacular ways that can be extremely
    difficult to fix. What, then, is a reasonable task?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编程新手来说，最难的一个挑战是知道给Copilot分配什么合理的任务，以便它能找到好的解决方案。如果你给Copilot分配的任务太大，它通常会以非常壮观的方式失败，这可能非常难以修复。那么，什么是一个合理的任务呢？
- en: This question is important for our use of Copilot but goes far beyond it. Human
    programmers struggle with complexity too. If experienced software engineers try
    to write code to solve a problem that’s too complex without breaking it down into
    smaller, more solvable subparts, they often have trouble as well. The solution
    for humans has been to use something called a *function,* whose job is to perform
    one task. Functions help us organize our code and make it easier to think about
    and fix any bugs. There are various rules of thumb for how to write a reasonable
    function in terms of number of lines of code, but, fundamentally, these rules
    try to capture writing something that (1) performs a single task and (2) isn’t
    so complex that it’s hard to get right.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题对于我们的Copilot使用很重要，但它远远超出了这个范围。人类程序员也会遇到复杂性问题。如果经验丰富的软件工程师试图在不将其分解为更小的、更易解决的子部分的情况下编写代码来解决过于复杂的问题，他们通常也会遇到麻烦。对于人类来说，解决方案是使用一种称为“函数”的东西，其任务是执行一个任务。函数帮助我们组织代码，并使其更容易思考并修复任何错误。关于如何编写合理函数有一些经验法则，但本质上，这些规则试图捕捉到编写（1）执行单个任务且（2）不会过于复杂以至于难以正确执行的东西。
- en: For people who learned to program the old-fashioned way, without Copilot, they
    may have struggled with syntax in code that’s 5–10 lines long before being introduced
    to functions. At that point, it’s natural for them to understand through experience
    that they shouldn’t write more code in a single function than they can handle
    testing and debugging. Because you’re learning to work with Copilot rather than
    syntax directly, our job in this chapter is to teach you about functions and what
    are considered reasonable and unreasonable tasks to ask Copilot to solve in a
    single function.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些以传统方式学习编程的人来说，没有Copilot的帮助，他们可能在接触到函数之前，就已经在5-10行长的代码中挣扎于语法问题。在那个阶段，他们通过经验自然地理解到，他们不应该在一个函数中编写超出自己能够测试和调试能力的代码。因为你是学习与Copilot合作而不是直接与语法打交道，所以本章的任务是教你关于函数以及什么被认为是合理和不合理的任务来请求Copilot在单个函数中解决。
- en: To help you gain perspective on functions, we’ll provide you with a number of
    examples in this chapter. Those examples employ the central workflow of interacting
    with Copilot—specifically, the cycle of writing prompts, receiving code from Copilot,
    and testing to see whether that code is correct. In the functions produced by
    Copilot, you’ll begin to see the core programming tools, such as loops, conditionals,
    and lists, which we’ll expand on in the next two chapters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你了解函数，我们将在本章提供一些示例。这些示例采用了与Copilot交互的核心工作流程——具体来说，是编写提示、从Copilot接收代码以及测试该代码是否正确的过程。在Copilot生成的函数中，你将开始看到核心编程工具，如循环、条件和列表，我们将在接下来的两章中对其进行扩展。
- en: 3.1 Functions
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 函数
- en: Before we can learn about the details of writing a function, we need some insight
    into their purpose in software. Functions are small tasks that help accomplish
    larger tasks, which, in turn, help solve larger tasks, and so forth. You probably
    already have a lot of intuition about breaking apart large tasks into smaller
    tasks. Let’s make that intuition concrete with an example.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习编写函数的细节之前，我们需要了解它们在软件中的目的。函数是帮助完成更大任务的较小任务，反过来，这些任务又帮助解决更大的任务，如此类推。你可能已经对将大任务分解为小任务有很多直觉。让我们用一个例子来具体化这种直觉。
- en: Suppose you’ve found a word search puzzle in the newspaper that you’d like to
    solve (see figure 3.1 for an example puzzle). In these kinds of puzzles, you’re
    looking for each word in the word list. The words can be found going from left
    to right, right to left, top to bottom, or bottom to top.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在报纸上找到了一个你想要解决的单词搜索谜题（见图3.1中的示例谜题）。在这些类型的谜题中，你需要找到单词列表中的每个单词。单词可以从左到右、从右到左、从上到下或从下到上找到。
- en: '![figure](../Images/3-1.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/3-1.png)'
- en: Figure 3.1 Example word search puzzle
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1 示例单词搜索谜题
- en: At a high level, your task is “find all the words in the word search.” Unfortunately,
    that description of the task isn’t helpful on its own. It doesn’t tell us what
    steps we need to take to solve the problem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，你的任务是“找到单词搜索中的所有单词。”不幸的是，这个任务的描述本身并没有帮助。它没有告诉我们需要采取哪些步骤来解决问题。
- en: Try working on the problem right now for a couple minutes. How did you start?
    How did you break down the overall task to make it more achievable?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试花几分钟时间解决这个问题。你是如何开始的？你是如何将整体任务分解，使其更容易实现的？
- en: One thing you might do is say, “OK, finding every word is a big task, but a
    smaller task is just finding the first word (CAT). Let me work on that first!”
    This is an example of taking a large task and breaking it into smaller tasks.
    To solve the entire puzzle, then, you could repeat that smaller task for each
    word that you need to find.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会这样做，比如说，“好吧，找到每个单词是一个大任务，但一个更小的任务是找到第一个单词（CAT）。让我先从那开始！”这是一个将大任务分解成小任务的例子。因此，为了解决整个谜题，你可以为需要找到的每个单词重复执行这个较小的任务。
- en: 'Now, how would we find an individual word, such as CAT? Even this task can
    be broken down further to make it easier to accomplish. For example, we could
    break it into four tasks: search for CAT from left to right, search for CAT from
    right to left, search for CAT from top to bottom, and search for CAT from bottom
    to top. Not only are we making simpler and simpler tasks, but we’re also organizing
    our work into logical pieces. Most importantly, as we’ll see throughout the chapter,
    it’s these simpler tasks whose code we’re going to ask Copilot to write and ultimately
    assemble into our complete programs.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何找到一个单独的单词，比如CAT？甚至这个任务也可以进一步分解，使其更容易完成。例如，我们可以将其分解为四个任务：从左到右搜索CAT，从右到左搜索CAT，从上到下搜索CAT，以及从下到上搜索CAT。我们不仅使任务越来越简单，而且还将我们的工作组织成逻辑部分。最重要的是，正如我们将在本章中看到的那样，我们将要求Copilot编写这些简单任务的代码，并将其最终组装成我们的完整程序。
- en: Taking a large problem and dividing it into smaller tasks is called *problem
    decomposition,* which is such an important skill in software design that we’ve
    dedicated all of chapter 7 to it. For now, it’s essential to know when a task
    is too big to ask Copilot to complete it. Asking Copilot to make a new video game
    that’s a combination of Wordscapes meets Wordle isn’t going to work at all. However,
    you can get Copilot to write a function that’s important to solve a larger problem;
    for example, you might have a function that checks whether the word provided by
    the player is present in a list of valid words. Copilot can solve that problem
    well, and that function would help Copilot get closer to solving the larger problem.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个大问题分解成更小的任务称为*问题分解*，这是软件设计中的一项重要技能，我们在第7章中专门对其进行了讨论。目前，了解何时一个任务太大，以至于不能让Copilot完成它是很重要的。让Copilot制作一个结合Wordscapes和Wordle的新视频游戏是完全行不通的。然而，你可以让Copilot编写一个对解决更大问题很重要的函数；例如，你可能有一个函数，用于检查玩家提供的单词是否在有效单词列表中。Copilot可以很好地解决这个问题，而这个函数将帮助Copilot更接近解决更大的问题。
- en: 3.1.1 The components of a function
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 函数的组成部分
- en: 'The origin of the name *function* goes back to math where functions define
    the output of something based on an input. For example, in high school math, you
    probably learned to recognize the common way to write a function as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: “函数”这个名字的起源可以追溯到数学，在数学中，函数根据输入定义某物的输出。例如，在高中数学中，你可能学习了以下常见的函数写法：
- en: f(*x*) = *x*²
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: f(*x*) = *x*²
- en: This is a function that is given a value for the variable *x* and computes the
    square of that value. So, we can say that when *x* is 6, f(*x*) is 36\. As programming
    functions also have expected output for a particular input, the name is apt for
    programming as well.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个给定变量*x*的值的函数，并计算该值的平方。因此，当*x*为6时，f(*x*)是36。由于编程函数也有特定输入的预期输出，所以这个名字对编程来说也很合适。
- en: As programmers, we also like to think of functions as promises or contracts.
    If there is a function called `larger`, and we’re told that it takes two numbers
    and gives us the larger of the two, we have faith that when we give the function
    the numbers 2 and 5, it will return the answer of 5\. We don’t need to see how
    that function works to use it, any more than we need to know how the mechanics
    of a car works to use the brake pedal. Press the brake pedal, and the car slows
    down. Give the `larger` function two numbers, and it gives us back the larger
    of the two.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们也喜欢将函数视为承诺或合同。如果一个名为 `larger` 的函数被告诉我们它接受两个数字并给出这两个数字中较大的一个，我们就相信当我们给这个函数数字
    2 和 5 时，它会返回答案 5。我们不需要看到这个函数是如何工作的就能使用它，就像我们不需要知道汽车的工作原理就能使用刹车踏板一样。按下刹车踏板，汽车就会减速。给
    `larger` 函数两个数字，它会返回这两个数字中较大的一个。
- en: Every function in Python has a *function header* (also called a *function signature*),
    which is the first line of code of the function. Given their ubiquitous nature,
    we’ll want to read and write function headers. The function header describes the
    name of the function and its inputs. In some other languages, the function header
    sometimes includes information about what the output looks like, but in Python,
    you have to find that elsewhere in the code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的每个函数都有一个 *函数头*（也称为 *函数签名*），它是函数的第一行代码。鉴于它们的普遍性，我们希望阅读和编写函数头。函数头描述了函数的名称和它的输入。在其他一些语言中，函数头有时会包含有关输出外观的信息，但在
    Python 中，你必须在代码的其他地方找到它。
- en: 'In chapter 2, we wrote # comments to tell Copilot what to do. We can continue
    to use that approach if we want Copilot to generate a function. For example, we
    can use comments to ask Copilot to write a function that tells us which of two
    numbers is larger:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '在第 2 章中，我们写了 # 注释来告诉 Copilot 要做什么。如果我们想让 Copilot 生成一个函数，我们可以继续使用那种方法。例如，我们可以使用注释来要求
    Copilot 编写一个函数，告诉我们两个数字中哪个更大：'
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#1 This function header defines a function called “larger” that accepts two
    inputs called num1 and num2.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这个函数头定义了一个名为“larger”的函数，它接受两个输入，分别称为 num1 和 num2。'
- en: '#2 Function body'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 函数体'
- en: 'As with the code in the previous chapter, we just wrote the comments to prompt
    Copilot to give us the code. The function header has three main components: the
    `def` keyword, which tells Python that this is a function; the name of the function;
    and the inputs to the function. There’s also a colon at the end of the line—be
    sure to include that or the code won’t be valid Python code. The word `def` denotes
    that it’s creating (defining) a function. After `def` is the name of the function;
    that name should describe the behavior of the function as well as possible. The
    name of this function is `larger`. If it’s hard to name a function because it
    does a bunch of different things, that’s usually a clue that it’s too big of a
    task for a single function (more on that later).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章的代码一样，我们只是写了注释来提示 Copilot 给我们代码。函数头有三个主要组成部分：`def` 关键字，它告诉 Python 这是一个函数；函数的名称；以及函数的输入。行尾还有一个冒号——一定要包含它，否则代码将不是有效的
    Python 代码。单词 `def` 表示它正在创建（定义）一个函数。`def` 之后是函数的名称；这个名字应该尽可能地描述函数的行为。这个函数的名称是 `larger`。如果一个函数很难命名因为它做了很多不同的事情，这通常是一个线索，表明这个任务对于单个函数来说太大（关于这一点稍后还会讨论）。
- en: In the parentheses of the function declaration, you’ll find the parameters.
    *Parameters* are how you provide information to a function that it needs to run.
    A function can have any number of parameters, and some functions have no parameters.
    This function has two parameters named `num1` and `num2`; there are two parameters
    because it needs to know the two numbers it’s comparing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数声明的括号中，你会找到参数。*参数* 是你向函数提供它运行所需信息的方式。一个函数可以有任意数量的参数，有些函数没有参数。这个函数有两个参数，分别命名为
    `num1` 和 `num2`；有两个参数是因为它需要知道它正在比较的两个数字。
- en: 'There can be only one output of a function; the keyword to look for when determining
    what the function is outputting is *return*. Whatever follows `return` is the
    output of the function. In this code, either `num1` or `num2` will be returned.
    Functions aren’t required to return anything (e.g., a function that prints a list
    to the screen has no reason to return anything), so if you don’t see a return
    statement, it isn’t necessarily a problem because the function may be doing something
    else (interacting with the user, for example) rather than returning something.
    Functions must also either return something or not return something: they can’t
    return something in some cases and nothing in other cases.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we had Copilot generate this function using # comments, this approach
    is actually a lot of work for Copilot. It first must get the header right, including
    figuring out how many parameters you need. Then, it must get the actual code of
    the function right. In this example, Copilot also provided the code for the function
    (also known as the function’s body).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: There’s an alternate way to prompt Copilot to write the code for a function
    that may help it generate code more accurately and may help us better understand
    exactly what we want our function to do. It involves writing a docstring, and
    we’ll use docstrings to write functions for the majority of the book.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings explain function behavior
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Docstrings* are how Python functions are described by programmers. They follow
    the function header and begin and end with three double quotation marks, as shown
    in the upcoming code function for `larger`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'By writing the header and docstring, you’ll make it easier for Copilot to generate
    the right code. In the header, you’ll be the one deciding on the name of the function
    and providing the names of each parameter that you want the function to use. After
    the function header, you’ll provide a docstring that tells Copilot what the function
    does. Then, just as before, Copilot will generate the code for the function. Because
    we gave Copilot the function header, it will be able to learn from the header
    and is less likely to make mistakes. Here’s what the alternate approach would
    look like when writing that same `larger` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**#1 Docstring description of the function**  **Notice that we wrote the function
    header as well as the docstring, and Copilot supplied the body of the function.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2 Using a function
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have a function, how do we use it? Thinking back to our f(*x*) = *x*²
    analogy, how do we give the function a value of 6 for *x* so that it returns 36?
    Let’s see how to do this with code by using that `larger` function we just wrote.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The way to use a function is to *call* it. Calling a function means to invoke
    the function on specific values of parameters. These parameter values are called
    arguments. Each value in Python has a *type*, and we need to take care to give
    values of the proper type. For example, that `larger` function is expecting two
    numbers; it might not work as expected if we supply inputs that aren’t numbers.
    When we call a function, it runs its code and returns its result. We need to capture
    that result so that we can use it later; otherwise, it will be lost. To capture
    a result, we use a *variable*, which is just a name that refers to a value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数的方法是*调用*它。调用函数意味着在特定参数值上调用函数。这些参数值被称为参数。Python中的每个值都有一个*类型*，我们需要注意给出正确类型的值。例如，`larger`函数期望两个数字；如果我们提供非数字的输入，它可能不会按预期工作。当我们调用函数时，它会运行其代码并返回结果。我们需要捕获这个结果，以便稍后使用；否则，它将会丢失。要捕获结果，我们使用一个*变量*，它只是一个指向值的名称。
- en: 'Here, we ask Copilot to call the function, store the result in a variable,
    and then print the result:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求Copilot调用函数，将结果存储在变量中，然后打印结果：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#1 Calls the larger function with the values 3 and 5 as inputs and stores the
    result'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用值3和5作为输入调用较大的函数并存储结果'
- en: The code correctly calls `larger`. Notice that it puts the two values we want
    compared after the opening parenthesis. When the function finishes, it returns
    a value that we assign to result. Then we print the result. If you run this program,
    you’ll see that the output 5 gets produced because 5 is the larger of the two
    values that we asked about.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码正确地调用了`larger`。注意，它将我们要比较的两个值放在了开括号之后。当函数执行完毕后，它返回一个值，我们将该值赋给结果。然后我们打印结果。如果你运行这个程序，你会看到输出5，因为5是我们询问的两个值中较大的一个。
- en: 'It’s okay if you aren’t comfortable with all the details here, but what we
    want you to recognize is when a function is being called, as in the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这里对所有的细节都不舒服，那没关系，但我们希望你能认识到当函数被调用时，如下所示：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The general format for a function call is
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用的通用格式是
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, when you see those parentheses right after a name, it means there’s a function
    call. Calling functions as we did here will be important to our workflow with
    Copilot, particularly in how we test functions to see if they are working properly.
    We’ll also need to call functions to get work done because functions don’t do
    anything until we call them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你看到名称后面紧跟着的括号时，这意味着有一个函数调用。像我们这里这样做函数调用对于与Copilot的工作流程非常重要，尤其是在测试函数是否正常工作方面。我们还需要调用函数来完成工作，因为函数在调用之前不会做任何事情。
- en: 3.2 The design cycle of functions with Copilot
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 使用Copilot的函数设计周期
- en: 'Let’s introduce you to the workflow we’ll use for the next few chapters. Designing
    functions with Copilot involves the following cycle of steps (see figure 3.2):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向你介绍接下来几章我们将使用的流程。使用Copilot设计函数涉及以下步骤周期（见图3.2）：
- en: Determine the desired behavior of the function.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定函数的预期行为。
- en: Write a prompt that describes the function as clearly as possible.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个尽可能清晰地描述函数的提示。
- en: Allow Copilot to generate the code.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许Copilot生成代码。
- en: Read through the code to see if it seems reasonable.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细阅读代码，看看它是否合理。
- en: 'Test the code to see if it’s correct:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试代码以查看其是否正确：
- en: If the code is correct after multiple tests, move on.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码经过多次测试后仍然正确，则继续。
- en: If the code is incorrect, move to step 2, and edit the prompt.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码不正确，则回到步骤2，并编辑提示。
- en: '![figure](../Images/3-2.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/3-2.png)'
- en: Figure 3.2 General editing cycle with Copilot. This assumes you define a reasonable
    function.
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2 使用Copilot的一般编辑周期。这假设你定义了一个合理的函数。
- en: We won’t learn how to do step 4 until the next chapter, but we bet you can already
    recognize when the code is blatantly wrong. For example, Copilot might give you
    only comments to fill the body of the function. Comments don’t do anything—they
    aren’t code—so a bunch of comments with no other code is clearly not the right
    thing to do. Or, Copilot might just write a single line such as `return` `-1`,
    or, our personal favorite, `Your` `code` `here`. Copilot learned that one from
    us professors when we provide students partial code and ask them to write the
    rest with “Your code here.” Those are all obviously incorrect, but in the next
    chapter, we’ll go over how to read code so you can more quickly spot when more
    complicated code is incorrect and, perhaps more importantly, see where and how
    to fix it. In later chapters, we’ll keep expanding on this cycle to include effective
    debugging practices, and we’ll keep practicing how to improve prompts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章学习如何进行第4步，但我们确信你已经能够识别出代码明显错误的情况。例如，Copilot可能只给出注释来填充函数的主体。注释并不做任何事情——它们不是代码——所以一大堆没有其他代码的注释显然不是正确的事情。或者，Copilot可能只写一行，比如`return`
    `-1`，或者，我们个人的最爱，`Your` `code` `here`。Copilot是从我们教授那里学到的，当我们提供学生部分代码并要求他们用“Your
    code here”来编写其余部分时。这些都是明显错误的，但在下一章中，我们将讨论如何阅读代码，这样你可以更快地发现更复杂的代码错误，也许更重要的是，看到在哪里以及如何修复它。在后面的章节中，我们将继续扩展这个周期，包括有效的调试实践，并继续练习如何改进提示。
- en: 3.3 Examples of creating good functions with Copilot
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 使用Copilot创建良好函数的示例
- en: In this section, we’re going to write a bunch of functions with Copilot. We
    think you’ll get a much better feel for functions by seeing concrete examples,
    and we’ll code them entirely in Copilot to help you see the cycle of function
    design we just described. Although our goal in this chapter isn’t to help you
    read code just yet, we’ll see programming features (sometimes called *constructs*)
    in the solutions that are very common in code (e.g., `if` statements, loops),
    so we’ll point those out when we see them. Then, in chapter 4, we’ll say more
    about how to read this code in more detail.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将与Copilot一起编写一系列函数。我们认为通过查看具体示例，你会对函数有更深的理解，我们将完全在Copilot中编写这些函数，以便帮助你看到我们刚刚描述的功能设计周期。尽管本章的目标还不是帮助你阅读代码，但我们会看到解决方案中的编程特性（有时称为*构造*），这些特性在代码中非常常见（例如，`if`语句，循环），因此当我们看到它们时，我们会指出这些特性。然后，在第4章中，我们将更详细地说明如何阅读这段代码。
- en: Many of the functions we’re about to work on are unrelated to each other. For
    example, we’ll start with a function about stock share prices and move to functions
    about strong passwords. You typically wouldn’t store unrelated stuff like this
    in the same Python file. Because we’re just exploring different examples of good
    functions, feel free to store all functions in the same Python file, perhaps named
    function ch3.py or function_practice.py.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的许多函数之间没有关联。例如，我们将从一个关于股票股价的函数开始，然后转向关于强密码的函数。你通常不会将这种不相关的内容存储在同一个Python文件中。因为我们只是在探索良好函数的不同示例，所以你可以自由地将所有函数存储在同一个Python文件中，也许命名为function_ch3.py或function_practice.py。
- en: 3.3.1 Dan’s stock pick
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 Dan的股票选择
- en: Dan is an investor in a stock called AAAPL. He purchased 10 shares for $15 each.
    Now, each of those shares is worth $17\. Dan would like to know how much money
    he has made on the stock.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Dan是AAAPL这支股票的投资者。他以每股15美元的价格购买了10股。现在，这些股票每股的价值是17美元。Dan想知道他在股票上赚了多少钱。
- en: Remember that we want to make our function as general as possible. If the only
    thing our function does is calculate this exact AAAPL situation, it wouldn’t be
    that useful in general. Sure, it would help Dan right now, but what about when
    AAAPL’s share price changes again or when he is interested in another stock entirely?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们希望使我们的函数尽可能通用。如果我们的函数唯一能做的就是计算这个特定的AAAPL情况，那么它在一般情况下就不会很有用。当然，它现在会帮助Dan，但当他再次对AAAPL的股价感兴趣或他对另一支股票感兴趣时呢？
- en: 'A useful general function here would take three parameters, all of which are
    numbers. The first parameter is the number of shares purchased, the second is
    the share price when the shares were purchased, and the third is the current share
    price. Let’s call this function `money_made`, because it’s going to determine
    how much money we’ve made or lost on the stock. In general, you want to name your
    function as an action word or words that describe what your function is doing.
    With that, we have enough to write the function header:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个有用的通用函数将接受三个参数，所有这些参数都是数字。第一个参数是购买的股票数量，第二个参数是购买股票时的股价，第三个参数是当前的股价。让我们称这个函数为`money_made`，因为它将确定我们在股票上赚了多少钱或损失了多少钱。一般来说，你希望给你的函数命名为一个动作词或描述函数所做事情的词组。有了这个，我们就有了编写函数头部的足够信息：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we need a docstring. In the docstring, we need to explain what each parameter
    is for by using its name in a sentence. We also need to include what the function
    is supposed to do. Adding our docstring, here is the full prompt we provide to
    Copilot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个文档字符串。在文档字符串中，我们需要通过在句子中使用其名称来解释每个参数的作用。我们还需要包括函数应该做什么。添加我们的文档字符串，以下是提供给Copilot的完整提示：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After typing that prompt, go to the next line, and press the Tab key. Copilot
    will fill in the code for the function. Don’t worry that the code gets indented:
    the code of functions is supposed to be indented, and, in fact, it’s an error
    if it isn’t! Here’s what we got from Copilot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入提示后，转到下一行，并按Tab键。Copilot将填充函数的代码。不用担心代码会被缩进：函数的代码应该是缩进的，实际上，如果没有缩进，那将是一个错误！以下是Copilot给出的代码：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code seems sensible. In the parentheses, it figures out the difference
    between the current price and the purchase price (the `-` is used for subtraction),
    and then it multiplies that by the number of shares that we have (the `*` is used
    for multiplication). Inspecting code like this is a useful skill, and we’ll get
    serious about it in the next chapter. Another useful skill is testing the function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来很有道理。在括号内，它计算出当前价格与购买价格之间的差异（这里使用`-`表示减法），然后将其乘以我们所持有的股票数量（这里使用`*`表示乘法）。检查这样的代码是一种有用的技能，我们将在下一章中认真对待它。另一个有用的技能是测试函数。
- en: To test the `money_made` function, we call it using various inputs and observe
    the output in each case. We could do this by asking Copilot to call the function,
    and then we run our program, much as we did with our `larger` function. We could
    then ask Copilot to change the function call by asking it to call the function
    with a different input, and then we would run our program again, repeating as
    many times as needed. However, we find it easier and more convenient to call the
    function ourselves from an interactive window. This way, we can call the function
    as many times as we like without going through Copilot at all and without cluttering
    up our program with stuff we’re going to delete anyway.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`money_made`函数，我们可以使用各种输入调用它，并观察每种情况下的输出。我们可以通过让Copilot调用函数，然后运行我们的程序来实现这一点，就像我们之前对`larger`函数所做的那样。然后我们可以要求Copilot通过使用不同的输入来更改函数调用，然后我们再次运行程序，重复所需的次数。然而，我们发现直接从交互窗口调用函数更容易、更方便。这样，我们可以多次调用函数，而无需通过Copilot，也不会在我们的程序中添加我们打算删除的东西。
- en: To try this interactive approach, select/highlight all the code of the function,
    and then press Shift-Enter (you can access a similar interactive session by selecting
    the text, right-clicking, and choosing Run Selection/Line in the Python window,
    but the guidance here is if you use Shift-Enter). Figure 3.3 shows what this looks
    like if you select the text of the function and press Shift-Enter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这种交互式方法，选择/高亮显示函数的所有代码，然后按Shift-Enter（你可以在Python窗口中选择文本，右键单击，然后在Python窗口中选择运行选择/行来访问类似的交互会话，但这里的指导是如果你使用Shift-Enter）。图3.3显示了如果你选择函数的文本并按Shift-Enter会出现什么情况。
- en: '![figure](../Images/3-3.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/3-3.png)'
- en: Figure 3.3 Running Python in an interactive session in VS Code. Note the >>>
    at the bottom of the TERMINAL tab.
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3 在VS Code中运行Python的交互会话。注意终端标签页底部的>>>。
- en: At the bottom of the resulting window, you’ll see three greater-than symbols
    >>>. This is called a *prompt*, and you’re allowed to type Python code here. (This
    prompt has nothing to do with the kind of prompt that we use when interacting
    with Copilot.) It will show us right away the result of the code that we type,
    which is convenient and fast.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果窗口的底部，你会看到三个大于号>>>。这被称为*提示符*，你可以在那里输入Python代码。（这个提示符与我们与Copilot交互时使用的提示符没有关系。）它将立即显示我们输入的代码的结果，这既方便又快捷。
- en: To call our `money_made` function, we need to provide three arguments, and they
    will be assigned left to right to the parameters. Whatever we put first will be
    assigned to `num_shares`, whatever we put second will be assigned to `purchase_share_price`,
    and whatever we put third will be assigned to `current_share_price`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用我们的`money_made`函数，我们需要提供三个参数，它们将从左到右分配给参数。我们放第一位的将分配给`num_shares`，放第二位的将分配给`purchase_share_price`，放第三位的将分配给`current_share_price`。
- en: 'Let’s try this! At the prompt, type the following, and press Enter (or Shift-Enter).
    Don’t type the >>>, as that’s already there; we’re including it throughout the
    book to make it clear where we’re typing. Figure 3.4 shows an example of running
    the function in the terminal at the Python prompt:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试！在提示符下，输入以下内容，然后按Enter（或Shift-Enter）。不要输入>>>，因为那里已经有了；我们在整本书中都包括它，以便清楚地表明我们在哪里输入。图3.4显示了在Python提示符下终端运行函数的示例：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You’ll see the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Is `20` correct? Well, we bought 10 shares, and each of them went up $2 (from
    $15 to $17), so we did make $20\. Looks good!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`20`是正确的吗？嗯，我们买了10股，每股上涨了2美元（从15美元到17美元），所以我们确实赚了20美元。看起来不错！'
- en: '![figure](../Images/3-4.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/3-4.png)'
- en: Figure 3.4 Calling the `money_made` function from the Python prompt in the VS
    Code terminal
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4 在VS Code终端的Python提示符下调用`money_made`函数
- en: We’re not done testing, though. When testing a function, you want to test it
    in various ways, not just once. All one test case tells you is that it happened
    to work with the particular input values that you provided. The more test cases
    we try, each testing the function in a different way, the more confident we are
    that our function is correct.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们还没有完成测试。当你测试一个函数时，你希望以各种方式测试它，而不仅仅是测试一次。一个测试用例只能告诉你，它碰巧在你提供的特定输入值上工作。我们尝试的测试用例越多，每个测试用例都以不同的方式测试函数，我们就越有信心我们的函数是正确的。
- en: How do we test this function in a different way? We’re looking for inputs that
    are somehow a different *category* of input. One not-so-good test right now would
    be to say, “What if our stock went from $15 to $18, instead of $15 to $17?” This
    is pretty much the same test as before, and chances are that it will work just
    fine.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何以不同的方式测试这个函数？我们正在寻找某种不同类别的输入。一个不太好的测试方法现在可能是说，“如果我们的股票从15美元涨到18美元，而不是从15美元涨到17美元怎么办？”这几乎和之前的测试一样，而且很可能它会正常工作。
- en: 'A good idea is to test what happens when the stock actually *loses* money.
    We expect to get a negative return value in this case. And it appears that our
    function works just fine with this category of test. Here’s our function call
    and the output returned to us:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好主意是测试股票实际*亏损*时会发生什么。我们预计在这种情况下会得到一个负的返回值。而且看起来我们的函数在这个测试类别中工作得很好。这是我们的函数调用和返回给我们的输出：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What other tests can we do? Well, sometimes a stock price doesn’t change at
    all. We expect 0 in this case. Let’s verify it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能进行哪些其他测试？嗯，有时候股票价格根本不会变化。我们预计在这种情况下会是0。让我们验证一下：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Looks good! Testing is a combination of science and art. How many categories
    of things are there to test? Are these two calls really two different categories?
    Have we missed any categories? You’ll improve your testing ability through practice,
    and we’ll spend all of chapter 6 talking about testing. For now, it looks like
    our `money_made` function is doing its job.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！测试是科学和艺术的结合。有多少种事物类别需要测试？这两个调用是否真的属于两个不同的类别？我们是否遗漏了任何类别？通过实践，你会提高你的测试能力，我们将在第6章全部讨论测试。目前来看，我们的`money_made`函数似乎正在正常工作。
- en: 'It’s possible for a function to use variables (rather than just its parameters)
    in its code, and we want to show you an example of that now so that you’re ready
    when you see Copilot doing it. Here’s an equivalent way to write the code for
    our `money_made` function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以在其代码中使用变量（而不仅仅是它的参数），我们现在想给你展示一个例子，这样当你看到Copilot这样做时，你就能准备好了。这是编写我们的`money_made`函数代码的等效方式：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code may even be easier to read for you: it first figures out the difference
    in share price, and then it multiplies that by the number of shares. We encourage
    you to test this version to help convince yourself that it’s still correct.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2 Leo’s password
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Leo is signing up for a new social network website called ProgrammerBook. He
    wants to make sure that his password is strong.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Leo starts with a modest definition of what it means for a password to be strong:
    it’s strong if it’s not the word *password* and not the word *qwerty*. Those are
    terrible passwords, for sure, but in reality, we have to do way better than this
    definition to ensure that our password is strong! A helpful function would be
    one that takes a proposed password and tells us whether it’s strong or not.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Unlike our previous functions in this chapter, we’re not dealing with numbers
    here. The parameter, the password to check, is text. And the return value is supposed
    to indicate some yes/no result. We need new types!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python type for text is called a *string*. There are zillions of possible
    strings because we can use a string to store whatever text we want. The Python
    type for a yes/no result is called a *Boolean* or *bool*. A bool has only two
    values: `True` or `False`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright! We’re ready to prompt Copilot. For functions that return bool (`True`/`False`)
    values, we usually name the function as `has_x`, `is_x`, or similar using some
    other verb that implies a true/false result:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In response, here’s what Copilot wrote for us:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Look over that code for a moment. That `!=` operator is the “not equal” operator,
    and each string that doesn’t count as a strong password is in single quotation
    marks. We’re going to use quotation marks every time we need to specify a specific
    string value. Again, we’ll talk more about how to read code in the next chapter,
    but for now, we hope that the code makes a fuzzy sort of sense: it looks like
    it’s checking that the password isn’t `password` and isn’t `qwerty`, which matches
    our definition of a strong password.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s make sure that this function does indeed work by making a few test
    calls. We’ll start by testing the passwords that aren’t strong. We had better
    get back `False` for each of these—and we do:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Good! Now, let’s try a strong password. We need to see `True` here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Good stuff! We now see that the function sometimes returns `False` and other
    times returns `True`, so at least it’s not always returning `False`. Let’s try
    one more:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Well, technically `True` is correct, but, wow, is `Leo` a bad password. We
    should really have done better with our definition of a strong password. Let’s
    change our prompt to give a more reasonable definition of what it means for a
    password to be strong. Here’s our next prompt and what Copilot gave us:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That `for` `char` `in` `password` that shows up a few times here is a way for
    Python to consider each character of the password. It enables something called
    a *loop*, which is a key topic that we’ll study in chapter 5.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it’s possible that you didn’t get the same code from Copilot as we
    did. But based on the code that we got, it looks like the first piece is looking
    for any uppercase character, the second piece is looking for any digit, and the
    third is looking for something that’s not an `isalnum`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有可能你没有从Copilot那里得到与我们相同的代码。但根据我们得到的代码，看起来第一部分是在寻找任何大写字母，第二部分是在寻找任何数字，而第三部分是在寻找不是`isalnum`的东西。
- en: 'Maybe `isalnum` means “is alphanumeric.” Does that include special symbols,
    and, if so, which ones? Let’s test this function to see how well we’re doing:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 也许`isalnum`意味着“是字母数字的”。这包括特殊符号吗？如果是的话，是哪些符号？让我们测试这个函数看看我们做得怎么样：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Uh-oh! We got the wrong answer for that third password. It looks pretty strong,
    but it’s not, because it lacks a special symbol. Our function returned `True`,
    but that’s the wrong return value: it was supposed to return `False`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们为那个第三个密码得到了错误的答案。它看起来相当强大，但实际上并不行，因为它缺少一个特殊符号。我们的函数返回了`True`，但这是错误的返回值：它本应该返回`False`。
- en: The code that Copilot gave us is wrong. Maybe the code that you got worked fine,
    but we didn’t get so lucky, and it’s important we know how to identify (like we
    just did) when the code is wrong and then fix it. It’s not important to know why
    it’s wrong right now, but if you’re curious about why our prompt may have given
    us the wrong behavior, it’s because we didn’t specify what we meant by a special
    character, and the code it gave us counts spaces as special characters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot给出的代码是错误的。也许你得到的代码运行得很好，但我们没有这么幸运，而且了解如何识别（就像我们刚才做的那样）代码是错误的并且修复它是很重要的。现在知道为什么它是错误的并不重要，但如果你对我们的提示可能导致的错误行为感到好奇，那是因为我们没有具体说明我们所说的特殊字符是什么，而它给出的代码将空格视为特殊字符。
- en: At this point, as we begin to troubleshoot our wrong code, we have two options.
    One option is to press Ctrl-Enter and look through the other suggestions that
    Copilot gives us. Maybe one of those suggestions will have something to do with
    special symbols that looks different from the one that didn’t work?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，当我们开始调试我们的错误代码时，我们有两个选择。一个选择是按Ctrl-Enter并查看Copilot给出的其他建议。也许其中的一条建议与那个没有工作的特殊符号有所不同？
- en: 'Indeed, on our computer here, we see such options, including this one:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，在我们的电脑上，我们看到这样的选项，包括这个：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#1 Specific choice of special symbols'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 特殊符号的具体选择'
- en: Test this function with strings such as `Leo`, `N3w` `Y0rk` `J375`, and `N3w`
    `Y0rk` `J375$` and you should see that the function works well.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 用`Leo`、`N3w` `Y0rk` `J375`和`N3w` `Y0rk` `J375$`这样的字符串测试这个函数，你应该看到函数运行良好。
- en: 'Our second option is to do some prompt engineering, which means adjusting our
    prompt to influence what Copilot gives us. In our original prompt, we talked about
    special symbols. This, in retrospect, is vague. We probably meant something more
    specific, such as punctuation. If we specifically talk about punctuation in our
    prompt, we get this interaction with Copilot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个选择是进行一些提示工程，这意味着调整我们的提示以影响Copilot给出的内容。在我们的原始提示中，我们提到了特殊符号。回想起来，这是模糊的。我们可能指的是更具体的东西，比如标点符号。如果我们具体地在提示中提到标点符号，我们会得到与Copilot的这种互动：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Looks good! That last line is talking about punctuation, which is hopeful.
    Let’s test it here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！最后一行是在谈论标点符号，这让人感到希望。让我们在这里测试它：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Looking at the bottom of that error message, you’ll see that `'string'` isn’t
    defined. Copilot wants to use a module, called `string`, but it’s a module that
    needs to be imported before we can use it. This “not defined” result can happen
    for various types of errors related to names not being found, and oftentimes the
    culprit is a module that hasn’t been imported. There are a lot of modules in Python,
    but the `string` module is well known. As you work with Copilot more, you’ll learn
    which modules are commonly used so you know to import them. You could also do
    a quick internet search to ask, “Is string a Python module,” and the results would
    confirm that it is. What we need to do is import the module.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 看看错误信息的底部，你会看到`'string'`没有定义。Copilot想要使用一个名为`string`的模块，但这是一个在使用之前需要导入的模块。这种“未定义”的结果可能发生在各种与找不到名称相关的错误中，而且很多时候罪魁祸首是一个尚未导入的模块。Python中有许多模块，但`string`模块是众所周知的。随着你更多地使用Copilot，你会了解到哪些模块是常用的，这样你就知道要导入它们。你也可以快速进行网络搜索来询问，“string是Python模块吗？”搜索结果会确认它是。我们需要做的是导入这个模块。
- en: Note that this is similar to what happened in the code that Copilot generated
    for us in chapter 2\. Back then, Copilot was using the csv module, which is a
    module already installed with Python. The string module is similarly included
    with Python; Copilot just forgot to import it. As we discussed in chapter 2, some
    modules do need to be manually installed, but the string module isn’t one of them.
    So, we don’t need to install string; we just have to import it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这与第2章中Copilot为我们生成的代码发生的情况相似。当时，Copilot正在使用csv模块，这是一个与Python一起安装的模块。字符串模块也类似地包含在Python中；Copilot只是忘记导入它。正如我们在第2章中讨论的，一些模块确实需要手动安装，但字符串模块不是其中之一。因此，我们不需要安装字符串；我们只需要导入它即可。
- en: Importing modules
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 导入模块
- en: There are a number of useful modules available in Python. In chapter 2, Copilot
    used the csv module to make it easier to deal with comma-separated values (CSV)
    files. But for Python code to take advantage of a module, we have to import that
    module. You might ask why we don’t have modules available to us without importing
    them, but that would massively increase the complexity of the code and what Python
    has to do to run code behind the scenes. Instead, the model is to include modules
    if you want to use them, and they aren’t included by default.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有许多有用的模块。在第2章中，Copilot使用了csv模块来简化处理逗号分隔值（CSV）文件。但为了Python代码能够利用一个模块，我们必须导入该模块。你可能会问为什么我们没有导入模块就可用，但那将大大增加代码的复杂性和Python在幕后运行代码所需的工作。相反，模型是，如果你想使用模块，就包含它们，它们不是默认包含的。
- en: 'Let’s add `import` `string` at the top of our code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码顶部添加`import string`：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we’re in good shape:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处于良好的状态：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That last one is `True`. It’s a strong password because it has the `$` punctuation
    added to it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是`True`。这是一个强密码，因为它添加了`$`标点符号。
- en: We hope that you’re now convinced of the value of testing. Sometimes, new programmers
    don’t test their code. They assume that the code they write is correct because
    it made sense to them. An interesting difference between novice and experienced
    programmers is that novices often assume their code is right, whereas experienced
    programmers assume their code is wrong until thoroughly tested and proved otherwise.
    Beyond this, we find that new programmers sometimes fail to test well because
    it’s disheartening to learn that the code is wrong. But it’s better to know now
    rather than later when others are using your code in a serious application. Finding
    errors through testing is actually a good thing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你现在已经相信了测试的价值。有时候，新程序员不会测试他们的代码。他们假设他们写的代码是正确的，因为它们对他们来说是有意义的。新手程序员和经验丰富的程序员之间一个有趣的不同之处在于，新手程序员经常假设他们的代码是正确的，而经验丰富的程序员则假设他们的代码是错误的，直到经过彻底测试并证明否则。除此之外，我们发现新程序员有时无法很好地进行测试，因为得知代码有错误会令人沮丧。但现在知道总比在别人在严重应用中使用你的代码时才知道要好。通过测试发现错误实际上是一件好事。
- en: 3.3.3 Getting a strong password
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 获取强密码
- en: Now that we have a function that tells us whether a password is strong or not,
    let’s write a function that obtains a strong password from the user. It will ask
    again and again for a password until the user types a strong one. This is the
    kind of code that websites use when they tell you, “Sorry, your password is too
    weak, try again.”
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个函数可以告诉我们密码是否强大，让我们编写一个函数从用户那里获取强密码。它将不断要求用户输入密码，直到用户输入一个强大的密码。这是网站在告诉你“抱歉，你的密码太弱了，请再试一次”时使用的代码。
- en: 'What should the header for such a function look like? Well, it’s going to ask
    the user for a password, but we won’t have a password parameter. In fact, we won’t
    have any parameters at all because the function doesn’t need any information to
    do its job—it just has to prompt the user, and the user will type the password
    at the keyboard. When the function has done its work, it will return the strong
    password, so it will continue to return a string as the output. Let’s try this
    prompt:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数的标题应该是什么样的呢？嗯，它将要求用户输入密码，但我们不会有一个密码参数。实际上，我们根本不会有任何参数，因为该函数不需要任何信息来完成其工作——它只需要提示用户，用户将在键盘上输入密码。当函数完成其工作后，它将返回强密码，因此它将继续以字符串作为输出返回。让我们尝试这个提示：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We get the following code from Copilot as a result:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Copilot得到了以下代码作为结果：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#1 It’s calling our earlier is_strong_password function!'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 它正在调用我们之前定义的is_strong_password函数！'
- en: That `while` keyword creates another kind of loop, this one continuing as long
    as the entered password isn’t strong. Copilot is also smart enough to call our
    earlier `is_strong_password` function to determine what counts as a strong password.
    As you’ll see in future chapters, using functions as building blocks in this way
    is precisely how large programs are built. You’ll often notice Copilot calling
    your earlier functions to solve later ones, much as we observed here.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `while` 关键字创建了一种另一种循环，只要输入的密码不强，这个循环就会继续。Copilot 也足够聪明，可以调用我们之前的 `is_strong_password`
    函数来确定什么算作强密码。正如你将在未来的章节中看到的，以这种方式使用函数作为构建块正是构建大型程序的方法。你经常会注意到Copilot调用你之前的函数来解决后续的问题，就像我们在这里观察到的那样。
- en: 'Let’s test this! Highlight all the code from our two password functions, and
    press Shift-Enter. We’ll call the function that we want to test. Then, try typing
    passwords, pressing Enter after each one. You’ll notice that it keeps asking until
    you finally provide a strong password:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下！高亮显示我们两个密码函数的所有代码，然后按 Shift-Enter。我们将调用我们想要测试的函数。然后，尝试输入密码，每次输入后按 Enter。你会注意到它会一直询问，直到你最终提供一个强密码：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that it stops asking us for a password when we finally provide a strong
    password. Then, we see the string in quotes that it returned, which is, indeed,
    our strong password.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们最终提供一个强密码时，它就不再询问我们密码了。然后，我们看到它返回的字符串，这确实是我们的强密码。
- en: 3.3.4 Scrabble scoring
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 Scrabble计分
- en: One of Dan’s favorite board games is Scrabble. Have you played it? If not, all
    you need to know is that you have some tiles in your hand, each with a letter
    on it, and your goal is to form a word using any combination of those letters.
    You don’t need to form the word exclusively with your tiles—you can attach those
    letters to existing letters on the board to create longer words—but we’re not
    going to worry about that here. The important thing for us is that different letters
    are worth different numbers of points. For example, an *a* is worth only 1 point
    because *a* is such a common letter. But *q* and *z*? Those doozies are each worth
    10 points because they’re so tough to use—or should we say *puzzling* to use.
    Yeah, that’s better.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 丹最喜欢的桌面游戏之一是Scrabble。你玩过吗？如果没有，你只需要知道你手里有一些带有字母的方块，你的目标是使用这些字母的任意组合来形成一个单词。你不需要只用你的方块来形成单词——你可以将这些字母附加到板上的现有字母上以形成更长的单词——但我们在这里不会担心这一点。对我们来说，重要的是不同的字母有不同的分数。例如，*a*
    只值 1 分，因为 *a* 是如此常见的字母。但 *q* 和 *z* 呢？这些宝贝每个都值 10 分，因为它们很难使用——或者说 *令人困惑* 的使用。是的，这样更好。
- en: To calculate the score for a word, we add up the scores for each of its letters.
    For example, the score for *zap* would be 14\. That’s because *z* is worth 10,
    *a* is worth 1, and *p* is worth 3.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算一个单词的分数，我们将它的每个字母的分数加起来。例如，*zap* 的分数将是 14。这是因为 *z* 值 10，*a* 值 1，而 *p* 值 3。
- en: 'Dan would like a function that, given a word, tells him how many points that
    word is worth. OK, so we need a function that takes a word (which is just one
    parameter). Let’s try this prompt, where we’ve included the number of points that
    each letter is worth per official Scrabble rules:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 丹想要一个函数，给定一个单词，告诉他这个单词值多少分。好吧，所以我们需要一个函数，它接受一个单词（这只是一个参数）。让我们尝试这个提示，其中我们包括了每个字母根据官方Scrabble规则的价值：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For this function, Copilot isn’t filling in the whole body for us with one press
    of the Tab key. Tab is also used to indent the code, which we also need to do
    here before Copilot will present us with code. So, we’re having to press Tab (sometimes
    once for the indentation and then again for Copilot), wait for the code to appear,
    then press Tab to accept that code, then press Enter again for more code to be
    presented, and repeat the process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个函数，Copilot不会通过按一次 Tab 键来为我们填写整个函数体。Tab 也可以用来缩进代码，我们在这里也需要这样做，这样Copilot才会展示代码。所以，我们不得不按
    Tab（有时一次用于缩进，然后再次用于Copilot），等待代码出现，然后按 Tab 接受该代码，然后再次按 Enter 以展示更多代码，并重复此过程。
- en: Getting Copilot to suggest code may require pressing Tab or Enter
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要让Copilot建议代码，可能需要按 Tab 或 Enter
- en: We find that Copilot will sometimes pause in giving suggestions until you press
    a key to help prompt it. As mentioned in table 2.1, if you’re giving it comments,
    Copilot will sometimes just want to give you more comments as suggestions. Pressing
    Enter another time can often trigger it to start generating code instead. Other
    times, pressing Tab will cause it to continue providing suggestions. Refer to
    table 2.1 if Copilot isn’t generating code for you.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，Copilot有时会在给出建议时暂停，直到你按下键来帮助提示它。如表格2.1中提到的，如果你给它评论，Copilot有时只想给你更多的评论作为建议。再次按下
    Enter 键通常可以触发它开始生成代码。有时，按下 Tab 键会导致它继续提供建议。如果 Copilot 没有为你生成代码，请参考表格2.1。
- en: 'Finally, after doing that a few times, the entire code unfurls, and we get
    the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，经过几次这样的操作后，整个代码展开，我们得到以下结果：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that all the letters of the alphabet are accounted for here, and the
    number of points that each category is worth is on the following line. We’ll discuss
    this overall kind of decision structure in the next chapter, but, at a high level,
    it’s walking through the word character by character and, for each character,
    figuring out which letter it is and adding the appropriate number of points for
    that letter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里列出了所有字母，每个类别应得的分数在下一行。我们将在下一章讨论这种整体决策结构，但简单来说，就是逐个字符遍历单词，对于每个字符，确定它是哪个字母，并为该字母添加相应的分数。
- en: 'Let’s test this to make sure our code is performing the way we want. We know
    that the word *zap* should be worth 14 points, and it is:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下，确保我们的代码正在按照我们期望的方式运行。我们知道单词 *zap* 应该值14分，确实如此：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s try a couple more. In each case, calculate by hand what you expect the
    answer to be—that way, you’ll know if the code is doing the right thing:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试几个。在每种情况下，手动计算你预期的答案——这样你就可以知道代码是否正确地执行了：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There are many ways to write correct code for a function. If you press Ctrl-Enter
    and look at the Copilot suggestions, you may see different types of code. It doesn’t
    necessarily mean that one of these types is right and the others are wrong. For
    example, here’s another solution for `num_points` that we got from the other Copilot
    suggestions:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 编写函数的正确代码有多种方式。如果你按下 Ctrl-Enter 并查看 Copilot 的建议，你可能会看到不同类型的代码。这并不意味着其中一种类型是正确的，而其他类型是错误的。例如，这里是从其他
    Copilot 建议中得到的 `num_points` 的另一个解决方案：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice here that each letter is listed individually along with its number of
    points. This structure with the letters and points is called a *dictionary*, and
    again, you’ll learn about dictionaries properly in a later chapter. The point
    for now is just that there are often multiple, equivalently good ways for Copilot
    to write the code for a function. Give this one a try with some test cases before
    you continue!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，每个字母都单独列出，并附上其对应的分数。这种包含字母和分数的结构称为 *字典*，再次强调，你将在后面的章节中详细了解字典。现在重要的是，Copilot编写函数代码通常有多种等效的好方法。在继续之前，先尝试用一些测试案例来验证这个方法！
- en: 3.3.5 The best word
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.5 最佳单词
- en: Let’s continue with the Scrabble theme. Suppose that Dan has a bunch of words
    that he can make right now, but he doesn’t know which one will give him the most
    points. Should he make the word *zap*, *pack*, or *quack*? It would be nice if
    we had a function that could take a bunch of words and tell us which is the best
    one.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续Scrabble主题。假设Dan现在有一堆单词可以组成，但他不知道哪个单词能给他带来最多的分数。他应该组成单词 *zap*、*pack* 还是
    *quack*？如果有一个函数能接受一堆单词并告诉我们哪个是最好的，那就太好了。
- en: How many parameters should we have in such a function? Your first instinct may
    be three parameters, one for each of the 3 words in our options. But that wouldn’t
    be very flexible. After all, what if we want to know the best of 5 words, 10 words,
    or 50 words? We would like our function to work no matter how many words we’re
    considering.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的函数中，我们应该有多少个参数？你的第一反应可能是三个参数，每个参数对应我们选项中的三个单词。但这不会很灵活。毕竟，如果我们想知道5个单词、10个单词或50个单词中的最佳单词，怎么办？我们希望我们的函数能够处理我们考虑的任何数量的单词。
- en: 'The trick is to use a function with one (yes, just one!) parameter, which is
    a *list* of words. Just like numbers, strings, and dictionaries, a `list` is a
    type supported by Python. It’s incredibly useful because it allows us to collect
    as many values into one place as we like. We can prompt Copilot like this to get
    the function that we want:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 技巧是使用一个只有一个（是的，只有一个！）参数的函数，这个参数是一个*单词列表*。就像数字、字符串和字典一样，列表是Python支持的一种类型。它非常有用，因为它允许我们将尽可能多的值收集到一个地方。我们可以像这样提示Copilot来获取我们想要的函数：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'How will Copilot know how many points each word is worth? Well, it can call
    that `num_points` function that we wrote in the previous section! Here’s the code
    that Copilot gives us:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot将如何知道每个单词值是多少？嗯，它可以调用我们在上一节中编写的那个`num_points`函数！这是Copilot给出的代码：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We need to be careful to call this function correctly when testing. Using
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试时需要小心地正确调用这个函数。使用
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'won’t work because that’s passing values for three parameters, not one. The
    right way to call it is to put the words inside square brackets, like this (we’ll
    see more about lists in the next chapter):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 是不会工作的，因为那样传递了三个参数，而不是一个。正确调用它的方法是把单词放在方括号里，就像这样（我们将在下一章中了解更多关于列表的内容）：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'But, as usual, you shouldn’t be content with just one test case. This function
    should work in other valid but perhaps strange cases too, such as when we have
    only one word in the list:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但，像往常一样，你不应该只满足于一个测试用例。这个函数也应该在其他有效但可能奇怪的用例中工作，例如，当我们列表中只有一个单词时：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: However, we wouldn’t test this function on a list that has no words in it. What
    would it even make sense to do in that case? Regardless of what the function does,
    it’d be hard to say one way or the other whether it was doing the correct thing
    in a situation where there really is no correct behavior!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会在一个没有任何单词的列表上测试这个函数。在那个情况下，这样做又有什么意义呢？不管这个函数做什么，在实际上没有正确行为的情况下，很难说它是否做了正确的事情！
- en: 3.4 Benefits of functions
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 函数的好处
- en: 'Now that you’ve seen a number of functions, we hope you’re starting to get
    a feel for how functions are used in software. We already mentioned that functions
    are critical in performing problem decomposition. Beyond problem decomposition,
    functions are valuable in software for a number of other reasons, including the
    following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了许多函数，我们希望你在开始了解函数在软件中的应用。我们已经提到，函数在执行问题分解中是至关重要的。除了问题分解之外，函数在软件中还有许多其他价值，包括以下方面：
- en: '**Cognitive load —*You may have heard of cognitive load [1] before. It’s the
    amount of information your brain can handle at any given time and still be effective.
    If you’re given four random words and asked to repeat them back, you might be
    able to do that. If you’re given the same task with 20 words, most of us would
    fail because it’s too much information to handle at once. Similarly, if you’ve
    ever been on a road trip with your family and are trying to optimize the travel
    time, combined with stops for the kids, lunch breaks, bathroom stops, gas station
    stops, good locations for hotels, and so on, you might have felt your head swimming
    to manage all those constraints at once. That point when you can’t handle it all
    at once is when you’ve exceeded your own brain’s processing power. Programmers
    have the same problem. If they are trying to do too much at once or solve too
    complex a problem in one piece of code, they struggle to do it correctly. Functions
    are designed to help programmers avoid doing too much work at once.*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认知负荷—*你可能之前听说过认知负荷[1]。这是你的大脑在任何给定时间内可以处理的信息量，同时仍然保持有效。如果你被给出四个随机单词并要求重复它们，你可能能够做到。如果你被给出同样的任务，但单词有20个，我们大多数人会失败，因为一次处理的信息太多。同样，如果你曾经和家人一起开车旅行并试图优化旅行时间，包括为孩子们停车、午餐休息、洗手间停车、加油站停车、好的酒店位置等等，你可能会有感觉你的头昏脑胀，难以同时管理所有这些限制。当你无法一次处理所有事情的时候，就是你超过了你自己的大脑处理能力的时候。程序员也有同样的问题。如果他们试图一次做太多事情或者在一个代码块中解决一个过于复杂的问题，他们会发现很难正确地做到。函数的设计是为了帮助程序员避免一次做太多工作。*'
- en: '**   **Avoid repetition —*Programmers (and, we’d argue, humans in general)
    aren’t very excited about solving the same problem over and over. If I write a
    function that can correctly compute the area of a circle once, I don’t need to
    write that code ever again. That means if I have two sections of my code that
    need to compute the area of a circle, I’d write one function that computes the
    area of the circle, and then I’d have my code call that function in each of those
    two places.***   *Improve* **testing —*It’s a lot harder to test a section of
    code that does multiple things compared to code that does one thing. Programmers
    use a variety of testing techniques, but a key technique is known as *unit testing*.
    Every function takes some input and produces some output. For a function that
    computes the area of a circle, for example, the input would be the circle’s radius,
    and the output would be its area. Unit tests give a function an input and then
    compare that input to the desired result. For the area-of-a-circle function, we
    might test it by giving it varying inputs (e.g., some small positive numbers,
    some large positive numbers, and 0) and compare the result of the function against
    the values we know to be correct. If the answers from the function match what
    we expect, we have a higher degree of confidence that the code is correct. If
    the code produces a mistake, we won’t have much code to check to find and fix
    the problem. But if a function does more than one task, it vastly complicates
    the testing process because you need to test each task and the interaction of
    those tasks.***   **Improve reliability —*When we write code as experienced software
    engineers, we know we make mistakes. We also know Copilot makes mistakes. If you
    imagine you’re an amazing programmer and each line of code you write is 95% likely
    to be correct, how many lines of code do you think you can write before at least
    one of those lines is likely to be incorrect? The answer is only 14\. We think
    95% correctness per line is probably a high bar for even experienced programmers
    and is likely a higher bar than what Copilot produces. By keeping the tasks small,
    tasks solvable in 12–20 lines of code, we reduce the likelihood that there’s an
    error in the code. If combined with good testing as noted previously, we can feel
    even more confident that the code is correct. Last, nothing is worse than code
    that has multiple mistakes that interact together, and the likelihood of multiple
    mistakes grows the more code you write. Both of us have been on multi-hour debugging
    expeditions because our code had more than one mistake, and we both became a lot
    better at frequent testing of short pieces of code as a result!***   **Improve
    code readability —*In this book, we mostly use Copilot to write code from scratch,
    but that’s not the only way to use Copilot. If you have a larger piece of software
    that you or your coworkers are all editing and using, Copilot can jump in to help
    write code for that too. It’s in everyone’s interest to understand the code, whether
    most of it is written by humans or by Copilot. That way, we can find bugs more
    easily, determine what code to start modifying when we want to add new features,
    and understand at a high level what would be easy or difficult to achieve with
    our overall program design. Having tasks broken down into functions helps us understand
    what each part of the code is doing so we can gain better insight into how it
    all works together. It also helps divide up the work and responsibility for ensuring
    the code is correct.*****'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免重复** —*程序员（我们可以说，人类普遍来说）并不热衷于反复解决相同的问题。如果我写了一个函数，可以正确计算圆的面积，那么我就不需要再写那段代码了。这意味着如果我的代码中有两个部分需要计算圆的面积，我会写一个计算圆面积的函数，然后在这两个地方都调用这个函数。***   *改进*
    **测试** —*与只做一件事情的代码相比，测试做多件事情的代码要困难得多。程序员使用各种测试技术，但一个关键的技术被称为*单元测试*。每个函数都接受一些输入并产生一些输出。例如，对于一个计算圆面积的函数，输入将是圆的半径，输出将是其面积。单元测试会给函数一个输入，然后比较这个输入与期望的结果。对于圆面积函数，我们可能会通过给它不同的输入（例如，一些小的正数，一些大的正数，以及0）来测试它，并将函数的结果与我们已知是正确的值进行比较。如果函数的答案与我们的预期相符，我们就对代码的正确性有了更高的信心。但如果代码产生了错误，我们检查以找到和修复问题的代码就不会很多。但是，如果一个函数执行多个任务，它会极大地复杂化测试过程，因为你需要测试每个任务以及这些任务之间的交互。***   **提高可靠性**
    —*当我们作为经验丰富的软件工程师编写代码时，我们知道我们会犯错误。我们也知道Copilot会犯错误。如果你想象自己是一位出色的程序员，你写的每一行代码有95%的可能性是正确的，你认为你能在至少有一行可能不正确之前写多少行代码？答案是只有14行。我们认为每行95%的正确性可能即使是经验丰富的程序员也是一个很高的标准，可能比Copilot产生的标准还要高。通过保持任务小，任务可以在12-20行代码内解决，我们降低了代码中存在错误的概率。如果与前面提到的良好测试相结合，我们可以更有信心地认为代码是正确的。最后，没有比代码中存在多个相互作用的错误更糟糕的了，随着你写的代码越多，多个错误的概率就越大。我们俩都经历过因为代码中存在多个错误而进行的数小时调试之旅，并且我们都因此变得更加擅长频繁测试短小的代码片段！***   **提高代码可读性**
    —*在这本书中，我们主要使用Copilot从头开始编写代码，但这不是使用Copilot的唯一方式。如果你有一个更大的软件项目，你或你的同事都在编辑和使用，Copilot也可以跳进来帮助编写那个项目的代码。无论是大部分代码是由人类还是由Copilot编写，理解代码对每个人来说都是有益的。这样，我们可以更容易地找到错误，确定当我们想要添加新功能时，从哪里开始修改代码，以及从高层次上理解使用我们的整体程序设计实现什么会容易或困难。将任务分解成函数有助于我们理解代码的每一部分在做什么，这样我们可以更好地了解它们是如何一起工作的。它还有助于分配工作责任，确保代码的正确性。*****'
- en: '**These benefits are huge for programmers. Programming languages haven’t always
    had functions. But even before they did, programmers did their best to use other
    features to mimic functions. They were ugly hacks (google “goto statements” if
    you’re interested), and all programmers are happy that we have proper functions
    now.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**这些好处对程序员来说非常巨大。编程语言并不总是有函数。但在它们有函数之前，程序员们尽力使用其他特性来模仿函数。这些方法很丑陋（如果你感兴趣，可以谷歌搜索“goto语句”），所有程序员都为现在有了真正的函数而感到高兴。'
- en: You may be asking, “I see how these advantages matter to humans, but how do
    they affect Copilot?” In general, we believe all the principles that apply to
    humans apply to Copilot, albeit sometimes for different reasons. Copilot may not
    have cognitive load, but it’s going to do better when we ask it to solve problems
    similar to what’s been done by humans before. Because humans write functions to
    solve tasks, Copilot will mimic that and write functions as well. Once we’ve written
    and tested a function, whether by hand or by Copilot, we don’t want to write it
    again. Knowing how to test if your program is working properly is just as essential
    for code produced by humans as it is by Copilot. Copilot is as likely to make
    mistakes when it generates code, so we want to catch those mistakes quickly, just
    as we do with human-written code. Even if you only work on your own code and never
    have anyone else read it, you’ll often have to go back years later to edit what
    you’ve written. Having done this ourselves, we can attest that it’s important
    for your code to be readable for your future self!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，“我明白这些优势对人类的重要性，但它们是如何影响Copilot的？”总的来说，我们认为适用于人类的所有原则也适用于Copilot，尽管有时原因不同。Copilot可能没有认知负荷，但当我们要求它解决与人类之前所做类似的问题时，它会表现得更好。因为人类编写函数来解决任务，Copilot会模仿这一点并编写函数。一旦我们手动或通过Copilot编写并测试了一个函数，我们就不想再写一次。知道如何测试你的程序是否正常工作对于人类编写的代码和Copilot编写的代码来说同样重要。Copilot在生成代码时可能会犯错误，所以我们想快速捕捉这些错误，就像我们处理人类编写的代码一样。即使你只处理自己的代码，并且从未让其他人阅读它，你也经常需要多年后回过头来编辑你之前写的代码。我们自己做这件事，可以证明，对于你未来的自己来说，让你的代码可读是非常重要的！
- en: 3.5 Roles of functions
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 函数的角色
- en: Functions are used in many different roles in programming. At a high level,
    programs are functions that (often) call other functions. Critically, all programs,
    including Python programs, originate with a single function (named `main` in languages
    such as Java, C, and C++). Python’s `main` function is essentially the first line
    of code that isn’t in a function. But if every program starts with a single function
    and trying to solve a large problem with a single function is a mistake, how does
    that work? Well, `main` will call other functions, which, in turn, will call other
    functions, and so forth. The code will still execute (mostly) sequentially in
    each function, so it may start in `main` but then move to another function, and
    so on.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在编程中扮演着多种不同的角色。在较高层次上，程序本身就是函数，它们（通常）会调用其他函数。关键的是，所有程序，包括Python程序，都起源于一个单一函数（在Java、C和C++等语言中命名为`main`）。Python的`main`函数本质上是非函数中的第一行代码。但如果我们认为每个程序都从一个单一函数开始，并且试图用一个函数解决一个大问题是一个错误，那么这是如何工作的呢？嗯，`main`会调用其他函数，而这些函数又会调用其他函数，如此类推。代码仍然会在每个函数中（主要）顺序执行，所以它可能从`main`开始，然后移动到另一个函数，依此类推。
- en: As an example, let’s use the code in the following listing. We wrote this code,
    not Copilot, because no one would ever want to write this code for anything useful
    outside of teaching. It’s just for demonstrating how function calls work.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用以下列表中的代码。我们编写这段代码，而不是Copilot，因为没有人会想编写这段代码来用于任何有用的教学之外的事情。这只是为了演示函数调用是如何工作的。
- en: Listing 3.1 Code to demonstrate how Python handles function calls
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.1 展示Python如何处理函数调用的代码
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '#1 This is the start of the program. We’ll call this “main” after the main
    function in other languages.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这是程序的开始。在其他语言中，我们将这个称为“main”。'
- en: 'If we ran this program, the output would be (we’ll explain why next):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，输出将会是（我们将在下文中解释原因）：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In figure 3.5, we provide a diagram of how the code in listing 3.1 would be
    executed by the computer. We’ve intentionally provided an example that has many
    function calls to tie together what we just learned. Again, this is *not* practical
    code; it’s just for learning purposes. Let’s trace through the code execution
    together. It may be easier to refer to figure 3.5 than listing 3.1 as you follow
    along, but either will work.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-5.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 Flow of function execution in our example from listing 3.1
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The program will start execution with the first line in the Python code that
    isn’t a function ( `print("Hi")`). Although Python doesn’t have a `main` function
    per se, we’ll refer to the block of code after the functions as `main` to help
    with this explanation. Code executes sequentially unless it encounters commands
    that tell it to execute code somewhere else. So, after executing `print("Hi")`,
    it will go to the next line, which is the call to `funct1`: `funct1()`. The call
    to `funct1` changes where the code is executing to the start of that function,
    which is the following statement: `print("there")`. The next line of `funct1`
    calls `funct2`, so the program will execute the first line of `funct2`: `print("my")`.
    What gets interesting is what happens when `funct2` finishes. There are no more
    lines of code to execute, so it automatically moves execution back to the first
    line following the call to `funct2` in `funct1`. (If the function call is in the
    middle of another statement, that statement resumes execution, but for this example,
    the function calls are each on their own line.) You may be curious why it goes
    to the next line after the call to `funct2` rather than back to the call of `funct2`.
    The problem is if it returned back to the call to `funct2`, it would be trapped
    calling `funct2` forever. As a result, functions always return back to the next
    piece of code to execute (in this example, the next line) after they are called.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Continuing this example, the next line of the code executed will be the line
    that prints `friend`. The next line calls `funct3`, which prints a period (.)
    and then returns back to its caller.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we’re back in `funct1`, on the line `print("")`. Printing an empty piece
    of text causes a new line. Now `funct1` is finished, so it transfers execution
    back to the next line in `main` after it was called. We suspect you’re getting
    the idea by now, so let’s move a bit more quickly:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '`main` next prints `I''m` and then calls `funct4`.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`funct4` prints `well` and then returns to `main` where the next line of code
    calls `funct3`.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`funct3` prints a period (.) and then returns to `main`. Notice that `funct3`
    was called both by `funct1` and by `main`, but that’s okay because functions remember
    how to return to the function that called them. In fact, having multiple functions
    calling the same function is a sign that the function being called multiple times
    is a good function because of its reuse.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After `funct3` returns to main, it will print `""`, which causes a new line
    to be started, and then it prints the word `Bye`.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That was a long example, but we provided it to give you an idea of how functions
    execute and how programs consist of defining and calling functions. In any software
    you use, think about the specific tasks that it performs: the programmers probably
    wrote one or more functions for each one. The button in a text editor that changes
    the text to bold probably calls a function to change the text to bold. That function
    might change the editor’s internal idea of the text (the editor likely stores
    your text in a different format than how you view it), and then it might call
    another function that updates the user’s (your) view of the text.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: We’d also like to use this example to discuss the different roles that functions
    play. A *helper* function is a function whose job is to make another function’s
    job easier. In a sense, every function that isn’t `main` is a helper function.
    The best helper functions are those that carry out some small, well-defined part
    of some other task, such as our `is_strong_password` function in section 3.3.2
    serving as a helper function for our `get_strong_password` function in section
    3.3.3.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Some functions simply call a bunch of other functions without doing any of their
    own work. There aren’t any of these in our example. However, if you removed the
    three `print` statements from `funct1`, it becomes this type of coordinating function.
    Others may call helper function(s) and then do some work on their own. `funct1`
    is a great example of a function that calls other functions but also does work
    on its own.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Another type of function—which we call a *leaf* function—stands on its own without
    calling other functions for help (except perhaps functions that already come with
    Python). Why leaf? If you imagine all the function calls as a big tree, these
    functions are the leaves of the tree because they have nothing coming out of them.
    `funct2`, `funct3`, and `funct4` are all leaf functions in our example. We’re
    primarily concerned with leaf functions in this chapter, but you’ll see examples
    of other kinds of functions here and especially in later chapters.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 What’s a reasonable task for a function?
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s no clear rule for what makes a good function, but there are some intuitions
    and recommendations we can share. Make no mistake, though—identifying good functions
    is a skill that takes time and practice. To help you with this, we gave you some
    examples of good functions in section 3.3\. In this section, we’ll outline our
    recommendations and provide you with some additional good and bad examples to
    help build that intuition.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.1 Attributes of good functions
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some guidelines that we believe will help you see what makes a good
    function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '*One clear* **task to perform —*A leaf function might be something like “compute
    the volume of a sphere,” “find the largest number in a list,” or “check to see
    if a list contains a specific value.” Nonleaf functions can achieve broader goals,
    like “update the game graphics” or “collect and sanitize input from the user.”
    Nonleaf functions should still have a particular goal in mind, but they are designed
    knowing that they will likely call other functions to achieve their goal.*'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个明确的任务要执行* — 一个叶函数可能像“计算球体的体积”、“在列表中找到最大的数字”或“检查列表是否包含特定值”这样的功能。非叶函数可以实现更广泛的目标，比如“更新游戏图形”或“收集并净化用户输入”。非叶函数仍然应该有一个特定的目标，但它们的设计是基于它们可能会调用其他函数来实现其目标。'
- en: '**   **Clearly defined behavior —*The task “find the largest number in a list”
    is clearly defined. If I gave you a list of numbers and asked you for the largest
    number, you know what you should do. In contrast, the task “find the best word
    in the list” is poorly defined as stated. You need more information: What is the
    “best” word? Is it the longest, the one that uses the fewest vowels, or the one
    that doesn’t share any of the same letters as “Leo” or “Dan”? You get the point;
    subjective tasks aren’t great for computers. Instead, we could write the function
    “find the word in the list that has the most characters” because what is expected
    is well defined. Often, programmers can’t put all the particulars of a function
    just in the name, so they fill in the details in the docstring to clarify its
    use. If you find yourself having to write more than a few sentences to describe
    the function’s behavior, the task is probably too much for a single function.***   **Short
    in number of lines of code —*We’ve heard different rules over the years for the
    length of functions, informed by different company style guidelines. The lengths
    we’ve heard vary from 12 to 20 lines of Python code as the maximum number of lines.
    In these rules, the number of lines is being used as a proxy for code complexity,
    and it’s not a bad rule of thumb. As programmers ourselves, we both apply similar
    rules to our code to ensure the complexity doesn’t get out of hand. With Copilot,
    we can use this as a guide as well. If you ask Copilot for a function, and it
    gives you back 50 lines of code, this probably isn’t a good function name or task.
    As we discussed earlier, that many lines of code are likely to have errors anyway.***   **General
    value over specific use —*A function that returns the number of values in a list
    that are greater than 1 might be a specific need for a part of your program, but
    there’s a way to make this better. The function should be rewritten to return
    the number of values in the list that are greater than another parameter. The
    new function would work for your use case (give the function 1 for the second
    parameter) and for any value other than 1\. We strive to have functions be as
    simple but as powerful as possible. This is why we wrote our function in section
    3.3.1 to work for any stock, not just AAAPL.***   **Clear input and output —*You
    generally don’t want a lot of parameters. That doesn’t mean you can’t have a lot
    of input, though. A single parameter could be a list of items, as in our `best_word`
    function in section 3.3.5\. It does mean that you want to find ways to keep the
    number of inputs to a minimum. You can only return one thing, but again, you can
    return a list so you aren’t as limited as it may appear. But if you find yourself
    writing a function that sometimes returns a list, sometimes returns a single value,
    and sometimes returns nothing, that’s probably not a good function.*****'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '**### 3.6.2 Examples of good (and bad) leaf functions'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are examples of good leaf functions (the function is on the left in italics,
    and the goal of that function is described on the right):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '*Compute the volume of a sphere —*Given the sphere’s radius, return its volume.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Find the largest number in a list —*Given a list, return the largest value.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Check whether a list contains a specific value —*Given a list and a value,
    return True if the list contains the value and False if it does not.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Print the state of the checkers game —*Given a 2D list representing the game
    board, output the game board to the screen in text.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Insert a value in a list —*Given a list, a new value, and a location in the
    list, return a new list that is the old list with the new value inserted at the
    desired location.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are examples of bad leaf functions and our reasons for why they are bad:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '*Request a user’s tax information and return the amount they owe this year —*Perhaps
    in some countries this wouldn’t be too bad, but we can’t imagine this as a single
    function in either the United States or Canada given the complexity of the tax
    rules!'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Identify the largest value in the list and remove that value from the list —*This
    might not seem so bad, but it’s really doing two things. The first is to find
    the largest value in the list. The second is to remove a value from the list.
    We’d recommend two leaf functions, one that finds the largest and one that removes
    the value from the list. However, this might make a good nonleaf function if your
    program needs to perform this task frequently.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Thinking of our dataset from chapter 2.) *Return the names of the quarterbacks
    with more than 4,000 yards of passing in the dataset —*This has too much specificity.
    Without a doubt, the number 4,000 should be a parameter. But it’s likely better
    to make a function that takes as input the position (quarterback, running back),
    the statistic (passing yards, games played), and the cutoff that we care about
    (4,000, 8,000) as parameters. This new function provides far more capability than
    the original, allowing a user to call the function to determine not only the names
    of particular quarterbacks who threw for more than 4,000 yards but also, for example,
    running backs who had more than 12 rushing touchdowns.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Determine the best movie of all time —*This function is too vague. Best movie
    by what definition? What movies should be considered? A better version of this
    might be a function that determines the highest-rated movie by users given at
    least a minimum number of ratings. This function would likely be part of a larger
    program where the function would have data from a movie database (say, IMDB) and
    minimum number of user ratings as inputs. The output of the function would be
    the highest-rated movie that has at least as many ratings as specified.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Play Call of Duty —*This might be the `main` function in the large code base
    for the Call of Duty game, but it’s definitely not a leaf function.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, in this chapter, you’ve learned about functions in Python and how you
    can use Copilot to help write them. You’ve also learned about the characteristics
    of good functions and how important it is to make sure your functions are solving
    tasks that can be managed well by Copilot.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Our next steps in this book all revolve around understanding whether the code
    produced by Copilot is correct and how to fix it when it isn’t. In the next chapter,
    we’ll start by explaining the basics of being able to read the code produced by
    Copilot because this gives us the first sanity check for whether Copilot is doing
    what we think it should be. Then, in later chapters, we’ll dig deeper into how
    to carefully test the code and what to do when it’s wrong.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 3.7 Exercises
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Review the following function descriptions, and determine if each is a leaf
    function. Provide reasons for your answers based on the complexity of the tasks
    the functions perform and whether they are likely to require calling additional
    custom functions.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Scrape data.* Given a list of URLs, scrape data from each page, parse the
    content to extract specific information, and save the extracted data to a database.'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Process customer orders.* Given a list of customer orders, process each order
    by checking inventory, calculating total price with discounts and taxes, updating
    inventory, and generating an order summary.'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Find the largest number in a list.* Given a list, return the largest value.'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Check whether a list contains a specific value.* Given a list and a value,
    return `True` if the list contains the value, and `False` if it does not.'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Generate student report cards.* Given a list of students and their grades,
    calculate the final grades, assign letter grades, determine class rank, and generate
    a formatted report card for each student.'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the cycle of designing functions with Copilot as outlined in this chapter.
    This cycle includes steps from determining the function’s behavior to testing
    the generated code. Based on general programming practices, identify which of
    the following steps is *not* included in the cycle described but is commonly part
    of a software development process:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying the logical correctness of the generated code by running unit tests
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Editing the function’s code manually to simplify complex logic after Copilot
    generation
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Conducting performance benchmarks on the generated code to ensure efficiency
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Consulting documentation or external resources to refine the function’s prompt
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Based on the problem description provided, write a clear and concise prompt
    for Copilot that specifies the task to be completed. Ensure your prompt includes
    all necessary details such as expected inputs, the processing to be performed,
    and the expected output:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a quaint little town, there was a humble shopkeeper who, every so often,
    would delight his customers with discounts on his goods. To streamline this process,
    he sought to create a magical formula. This formula would take the original price
    of any item in his store and the special discount he wished to offer. With these
    two pieces of information, the formula would then reveal the final price the customer
    needed to pay after the discount was woven into the original tag, making both
    the shopkeeper and his customers very happy with the ease of their transactions.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you think of two or three input examples to verify the correctness of the
    function generated by Copilot based on your prompts? Include some scenarios to
    ensure the function handles different types of input correctly and calculates
    the correct output.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Review the function description and the provided test cases for calculating
    the total cost of a meal, including tax and tip. Based on the scenario and typical
    requirements of such a function, can you think of inputs where the function doesn’t
    work correctly? Explain why handling this input is necessary to ensure the function’s
    reliability and correctness across all potential use cases.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Problem description: Create a function that calculates the total cost of a
    meal, including tax and tip. The function should take three inputs: the base price
    of the meal, the tax rate as a percentage, and the tip rate as a percentage. The
    function should calculate and return the total cost of the meal.'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test cases:'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Standard Case*—Calculate the total price of a $50 meal with a 10% tax and
    a 15% tip:'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Input: `base_price = 50`, `tax_rate = 10`, `tip_rate = 15`'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expected output: $62.50 (calculated as $50 + $5 tax + $7.50 tip)'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Zero Tip Case*—Calculate the total price of a $30 meal with a 5% tax and no
    tip:'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Input: `base_price = 30`, `tax_rate = 5`, `tip_rate = 0`'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expected output: $31.50 (calculated as $30 + $1.50 tax + $0 tip)'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*High Tax and Tip Case*—Calculate the total price of a $100 meal with a 20%
    tax and a 25% tip:'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Input: `base_price = 100`, `tax_rate = 20`, `tip_rate = 25`'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expected output: $145 (calculated as $100 + $20 tax + $25 tip)'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 5\. Review the initial prompt provided to Copilot and the resulting Python function.
    The code doesn’t fulfill the requirements as it only converts from Fahrenheit
    to Celsius and lacks the capability to convert in both directions based on a user-specified
    mode. How would you improve the prompt to ensure that the generated code meets
    the full requirements of the problem description?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Problem decomposition involves breaking a large problem into smaller tasks.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use functions to perform problem decomposition in our programs.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each function must solve one small, well-defined task.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function header or signature is the first line of code of the function.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters are used to provide information to functions.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function header indicates the name of the function and names of its parameters.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `return` to pass a value from a function to its caller.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A docstring uses the names of each function parameter to describe the purpose
    of the function.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To ask Copilot to write a function, we provide it the function header and docstring.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get a function to do its work by calling it with values (also called arguments)
    for its parameters.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To test whether a function is correct, we call it with different types of inputs.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable is a name that refers to a value.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every Python value has a type, such as a number, text (string), true/false value
    (bool), or collection of values (list or dictionary).
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompt engineering involves modifying our prompt for Copilot to influence the
    code that we get back.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to ensure that we import any module (e.g., string) our code is using.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions reduce duplication, make it easier to test our code, and reduce the
    likelihood of bugs.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing involves checking that the function does what we expect on a variety
    of different inputs.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A helper function is a small function written to make it easier to write a bigger
    function.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A leaf function doesn’t call any other function to do its job.******
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
