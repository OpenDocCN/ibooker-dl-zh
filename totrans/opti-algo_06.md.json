["```py\nObjective function f(x), x = (x_1, . . . , x_p)^T\nInitialize initial temperature T_o, initial guess x_o, iteration counter n=0 and iteration per temperature counter k=0\nSet final temperature T_f, kmax maximum number of iterations per temperature and max number of iterations N\nDefine cooling schedule\nBegin\nWhile T > T_f and n < N do\n      While k<k_{max}\n             Move randomly to a new location/state x_n + 1\n             Calculate Δf = f_{n+1}(x_{n+1}) – f_n(x_n)\n             If the new solution if better then\n                 Accept the new solution\n             Else \n                 Generate a random number r\n                 Accept if exp(−Δf/T)>r\n             k=k+1\n        End\n        Update T according to the cooling schedule\n        n = n + 1\nEnd\nReturn the final solution\n```", "```py\nimport random\nmu, sigma = 0, 1 # mean and standard deviation\nprint(random.gauss(mu, sigma))\n```", "```py\nimport numpy as np\nx=x+np.random.normal(mu, sigma, 1)\n```", "```py\n#!pip install scipy\nimport numpy as np\nfrom scipy.optimize import dual_annealing\n\ndef objective_function(solution):                                                 ①\n    return solution[0]**2 +2*(solution[1]**2) - 0.3*np.cos(3*np.pi*solution[0]) –\n➥ 0.4*np.cos(4*np.pi*solution[1]) + 0.7\n\nbounds = np.asarray([[-100, 100], [-100, 100]])                                   ②\n\nres_dual = dual_annealing(objective_function, bounds=bounds, maxiter = 100)       ③\n\nprint('Dual Annealing Solution: f(%s) = %.5f' % (res_dual['x'], res_dual['fun'])) ④\n```", "```py\n#!pip install mealpy\nfrom numpy import exp, arange\nimport matplotlib.pyplot as plt\nfrom pylab import meshgrid,cm,imshow,contour,clabel,colorbar,axis,title,show\nfrom mealpy.physics_based.SA import OriginalSA \n\nproblem = {\"fit_func\": objective_function,\"lb\": [bounds[0][0], bounds[1][0]], \"ub\":\n➥ [bounds[0][1], bounds[1][1]], \"minmax\": \"min\", \"obj_weights\": [1, 1]}    ①\n\nepoch = 100                                                                 ②\npop_size = 10                                                               ②\nmax_sub_iter = 2                                                            ②\nt0 = 1000                                                                   ②\nt1 = 1                                                                      ②\nmove_count = 5                                                              ②\nmutation_rate = 0.1                                                         ②\nmutation_step_size = 0.1                                                    ②\nmutation_step_size_damp = 0.99                                              ②\n\nmodel = OriginalSA(epoch, pop_size, max_sub_iter, t0, t1, move_count, mutation_rate,\n➥ mutation_step_size, mutation_step_size_damp)                             ③\n\nmealpy_solution, mealpy_value = model.solve(problem)                        ④\n\nprint('MEALPY SA Solution: f(%s) = %.5f' % (mealpy_solution, mealpy_value)) ⑤\n```", "```py\nimport random\nimport math\nimport numpy as np\nfrom optalgotools.algorithms import SimulatedAnnealing\nfrom optalgotools.problems import ProblemBase, ContinuousFunctionBase\n\ndef simple_example(x):                                                       ①\n    return (x-6)**2                                                          ①\n\nsimple_example_bounds = np.asarray([[0, 31]])                                ①\nsimple_example_obj = ContinuousFunctionBase(simple_example, simple_example_  ①\n➥ simple_example_bounds)                                                    ①\nsa = SimulatedAnnealing(max_iter=1000, max_iter_per_temp=100,                ①\n➥ initial_ temp=1000, final_temp=0.0001, cooling_schedule='geometric',      ①\n➥ cooling_alpha=0.9, debug=1)                                               ①\nsa.run(simple_example_obj)                                                   ①\n\ndef Bohachevsky(x_1, x_2):                                                   ②\n    return x_1**2 +2*(x_2**2)-0.3*np.cos(3*np.pi*x_1)-0.4*np.cos(4*np.       ② \npi*x_2)+0.7                                                                  ②\n\nBohachevsky_bounds = np.asarray([[-100, 100], [-100, 100]])                  ②\nBohachevsky_obj = ContinuousFunctionBase(Bohachevsky, Bohachevsky_bounds, 5) ②\nsa.run(Bohachevsky_obj)                                                      ②\n\ndef bukin(x_1, x_2):                                                         ③\n    return 100*math.sqrt(abs(x_2-0.01*x_1**2)) + 0.01 * abs(x_1 + 10)        ③\n\nbukin_bounds = np.asarray([[-15, -5], [-3, 3]])                              ③\nbukin_obj = ContinuousFunctionBase(bukin, bukin_bounds, 5)                   ③\nsa.run(bukin_obj)                                                            ③\n\ndef gramacy_and_lee(x):                                                      ④\n    return math.sin(10*pi*x)/(2*x) + (x-1)**4                                ④\n\ngramacy_and_lee_bounds = np.asarray([[0.5, 2.5]])                            ④\ngramacy_and_lee_obj = ContinuousFunctionBase(gramacy_and_lee, gramacy_and_   ④\n➥ lee_bounds, .1)                                                           ④\nsa.run(gramacy_and_lee_obj)                                                  ④\n\ndef griewank(*x):                                                            ⑤\n    x = np.asarray(x)                                                        ⑤\n    return np.sum(x**2/4000) - np.prod(np.cos(x/np.sqrt(np.asarray(range(1,  ⑤\n    ➥ len(x)+1))))) + 1                                                     ⑤\n\ngriewank_bounds = np.asarray([[-600, 600]])                                  ⑤\ngriewank_1d=ContinuousFunctionBase(griewank, griewank_bounds, 10)            ⑤\nsa.run(griewank_1d)                                                          ⑤\n\ngriewank_bounds_2d = np.asarray([[-600, 600]]*2)                             ⑥\ngriewank_2d=ContinuousFunctionBase(griewank, griewank_bounds_2d,             ⑥\n➥ (griewank_bounds_2d[:, 1] - griewank_bounds_2d[:, 0])/10)                 ⑥\nsa.run(griewank_2d)                                                          ⑥\n\ngriewank_bounds_3d = np.asarray([[-600, 600]]*3)                             ⑦\ngriewank_3d=ContinuousFunctionBase(griewank, griewank_bounds_3d,             ⑦\n➥ (griewank_bounds_3d[:, 1] - griewank_bounds_3d[:, 0])/10)                 ⑦\nsa.run(griewank_3d)                                                          ⑦\n```", "```py\nSimulated annealing is initialized:\ncurrent value = 60.73784664253138, current temp=1000\nSimulated Annealing is done: \ncurr iter: 154, curr best value: 0.6093437608551259, curr temp:9.97938882337113e-05, curr best: sol: [-14.63282848   2.14122839]\nglobal minimum: x = -14.6328, 2.1412, f(x) = 0.6093\n```", "```py\nfrom optalgotools.algorithms import SimulatedAnnealing                 ①\nfrom optalgotools.problems import Sudoku                               ②\n\nsa = SimulatedAnnealing(max_iter=100000, max_iter_per_temp=1000, \n➥ initial_temp=500, final_temp=0.001, cooling_schedule='geometric',\n➥ cooling_alpha=0.9, debug=1)                                         ③\n\nSudoku_hard = [\n    [9, 0, 0, 1, 0, 0, 0, 5, 4],\n    [0, 0, 0, 0, 8, 0, 0, 0, 0],\n    [0, 0, 5, 0, 0, 9, 0, 0, 3],\n    [0, 9, 0, 0, 3, 5, 0, 4, 1],\n    [0, 0, 0, 0, 1, 0, 0, 0, 0],\n    [4, 1, 0, 2, 6, 0, 0, 8, 0],\n    [7, 0, 0, 3, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 4, 0, 0, 0, 0],\n    [3, 5, 0, 0, 0, 1, 0, 0, 6],\n]\nsudoku_prob = Sudoku(Sudoku_hard)    \nsudoku_prob.print()                                                   ④\n                                                                      ④\nsudoku_prob.solve_backtrack()                                         ⑤\nsa.run(sudoku_prob, 0)                                                ⑥\n```", "```py\nfrom optalgotools.algorithms import SimulatedAnnealing\nfrom optalgotools.problems import TSP\n\ndists = [ [0] * 5 for _ in range(5)]\ndists[0][1] = dists[1][0] = 4\ndists[0][2] = dists[2][0] = 2\ndists[0][3] = dists[3][0] = 9\ndists[0][4] = dists[4][0] = 12\ndists[1][2] = dists[2][1] = 7\ndists[1][3] = dists[3][1] = 5\ndists[1][4] = dists[4][1] = 5\ndists[2][3] = dists[3][2] = 4\ndists[2][4] = dists[4][2] = 10\ndists[3][4] = dists[4][3] = 3\n\ntsp_sample = TSP(dists, 'random_swap')                                           ①\n\nsa = SimulatedAnnealing(max_iter=10000, max_iter_per_temp=1, initial_temp=500,\n➥ final_temp=50, cooling_schedule='linear_inverse', cooling_alpha=0.9, debug=2) ②\nsa.run(tsp_sample)                                                               ③\n```", "```py\nfrom optalgotools.problems import TSP\nfrom optalgotools.algorithms import SimulatedAnnealing\nimport matplotlib.pyplot as plt\n\nberlin52_tsp_url = 'https://raw.githubusercontent.com/coin-or/\njorlib/b3a41ce773e9b3b5b73c149d4c06097ea1511680/jorlib-core/src/test/resources/\ntspLib/tsp/berlin52.tsp'                                                  ①\n\nberlin52_tsp = TSP(load_tsp_url=berlin52_tsp_url, gen_method='mutate',\n➥ rand_len=True, init_method='random')                                   ②\n\nsa = SimulatedAnnealing(max_iter=1200, max_iter_per_temp=500, initial_temp=150,\n➥ final_temp=0.01, cooling_schedule='linear', debug=1)                   ③\n\nsa.run(berlin52_tsp, repetition=1)                                        ④\nprint(sa.val_allbest)                                                     ④\n\nberlin52_tsp.plot(sa.s_best)                                              ⑤\n```", "```py\nsol: [0, 48, 34, 35, 33, 43, 45, 36, 37, 47, 23, 4, 14, 5, 3, 24, 11, 50, 10, \n51, 13, 12, 26, 27, 25, 46, 28, 15, 49, 19, 22, 29, 1, 6, 41, 20, 30, 17, 16, \n2, 44, 18, 40, 7, 8, 9, 32, 42, 39, 38, 31, 21, 0]\n8106.88\n```", "```py\nrun(self, problem_obj=None, stoping_val=None, init=None, repetition=1)\n```", "```py\nfrom optalgotools.algorithms import SimulatedAnnealing\nfrom optalgotools.problems import TSP\nimport numpy as np\nimport pandas as pd\nimport osmnx as ox\nimport networkx as nx\nimport folium\nimport folium.plugins\n\nwal_df = pd.read_csv(\"https://raw.githubusercontent.com/Optimization-Algorithms-\n➥Book/Code-Listings/main/Appendix%20B/data/TSP/Walmart_ON.csv\")                     ①\n\ncities_list = [city for city, region in cityToRegion.items() if city in\n➥wal_df.city.unique() and region in ['Durham Region', 'York Region', 'Toronto']]    ②\n\ngta_part = wal_df[wal_df.store_number.str.startswith('Walmart Supercentre') &\n➥ wal_df.city.isin(cities_list)].reset_index(drop=True)                             ③\nwal_gta_count = gta_part.shape[0]\n\ngta_part_loc = gta_part[['latitude', 'longitude']]                                   ④\n\nG = ox.graph_from_point(tuple(gta_part_loc.mean().to_list()), dist=42000,            ④\n➥ dist_type='network', network_type='drive', clean_periphery=True, simplify=True,   ④\n➥ retain_all=True, truncate_by_edge=True)                                           ④\n\ngta_part['osmid'], gta_part['osmid_dist_m'] = zip(*gta_part.apply(lambda row:\n➥ox.nearest_nodes(G, row.longitude, row.latitude, return_dist=True), axis = 1)) \n\ngta_part_dists = np.zeros([wal_gta_count, wal_gta_count])                            ⑤\ngta_part_pathes = [[[] for i in range(wal_gta_count)] for j in range(wal_gta_count)] ⑤\nfor i in range(wal_gta_count):                                                       ⑤\n    for j in range(wal_gta_count):                                                   ⑤\n        if i==j:                                                                     ⑤\n            continue                                                                 ⑤\n        gta_part_pathes[i][j] = nx.shortest_path(G=G, source=gta_part.osmid[i],      ⑤\n➥ target=gta_part.osmid[j], weight='length', method='dijkstra')                     ⑤\n        gta_part_dists[i][j] = nx.shortest_path_length(G=G,                          ⑤\n➥source=gta_part.osmid[i], target=gta_part.osmid[j], weight='length',               ⑤\n➥ method='dijkstra')/1000                                                           ⑤\n\ngta_part_tsp = TSP(dists=gta_part_dists, gen_method='mutate')                        ⑥\n\nsa = SimulatedAnnealing(max_iter=1000, max_iter_per_temp=100, initial_temp=85,\n➥ final_temp=0.0001, cooling_schedule='linear')                                     ⑦\n\nsa.init_annealing(gta_part_tsp)                                                      ⑧\nsa.run(gta_part_tsp)                                                                 ⑨\n```"]