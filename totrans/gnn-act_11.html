<html><head></head><body>
<div id="sbo-rt-content"><div class="readable-text" id="p1">
<h1 class="readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">appendix A</span></span> <span class="chapter-title-text">Discovering graphs</span></h1>
</div>
<div class="readable-text" id="p2">
<p>In this appendix, we explore the theory and implementations of graphs that are most pertinent to using the GNNs covered in the rest of the book. The goal is to help those of you who are less familiar with graphs learn enough to follow the book (if you’re familiar with graphs, you can skip this appendix). We establish basic definitions, concepts, and nomenclature, and then survey how the theory is realized in real systems. This foundation is not only necessary to follow the material in this book but also for building the insights that make architecting custom systems and troubleshooting errors easier. </p>
</div>
<div class="readable-text intended-text" id="p3">
<p>Additionally, in a rapidly evolving field, the ability to quickly absorb new academic and technical literature is crucial for staying up to date with the state of the art. We also provide the basic background to pick up the essence of relevant published papers. In this appendix, we’ll use a running example of a social networking dataset to demonstrate the concepts. This is a dataset of more than 1,900 professionals and their industry relationships. Figure A.1 visualizes this graph (generated using Graphistry).<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p4">
<img alt="figure" height="565" src="../Images/A-1.png" width="1100"/>
<h5 class="figure-container-h5"><strong><span class="num-string">Figure A.1</span> A stylized visualization of the example social network, consisting of industry professionals and their relationships. The nodes (dots) are the professionals, and the edges (lines) denote a relationship between people. In this visualization, created using Graphistry, the left image shows an edge diverge out of the frame (bottom right). The right image is the entire graph, showing the cut-off edges and nodes. </strong></h5>
</div>
<div class="readable-text" id="p5">
<h2 class="readable-text-h2"><span class="num-string">A.1</span> Graph fundamentals</h2>
</div>
<div class="readable-text" id="p6">
<p>Let’s start with some definitions, and then we’ll see how the concepts work.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p7">
<h5 class="callout-container-h5 readable-text-h5">Key terms</h5>
</div>
<div class="readable-text" id="p8">
<p><em>Graph</em>—A data type consisting of nodes and edges. </p>
</div>
<div class="readable-text" id="p9">
<p><em>Node</em>—Also called a <em>vertex</em> or <em>point</em>, a node is an endpoint in a graph. They are connected by edges.</p>
</div>
<div class="readable-text" id="p10">
<p><em>Edge</em>—Also called a <em>link</em> or <em>relationship</em>, an edge connects nodes. They can be directed or undirected.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p11">
<img alt="sidebar figure" height="320" src="../Images/A-unnumb.png" width="149"/>
<h5 class="figure-container-h5">Loops and three types of edges</h5>
</div>
<div class="readable-text" id="p12">
<p><em>Directed edge</em>—A directed edge, usually represented by an arrow, denotes a one-way relationship or flow from one node to another.</p>
</div>
<div class="readable-text" id="p13">
<p><em>Undirected edge</em>—An undirected edge has no direction. In such an edge, a relationship or flow can go in either direction.</p>
</div>
<div class="readable-text" id="p14">
<p><em>Adjacent</em>—The property that two nodes are directly connected via an edge. Such nodes are said to be <em>joined</em>.</p>
</div>
<div class="readable-text" id="p15">
<p><em>Self-loop</em>—An edge that connects a node to itself. Such edges can be directed or undirected.</p>
</div>
<div class="readable-text" id="p16">
<p><em>Parallel edges</em>—Multiple edges that connect the same two nodes. </p>
</div>
<div class="readable-text" id="p17">
<p><em>Weights</em>—One important attribute of an edge is weight, which is a numerical value assigned to an edge. Such an attribute can describe the intensity of the connection, or some other real-world value, such as length (if a graph modeled cities on a road map). </p>
</div>
</div>
<div class="readable-text" id="p18">
<p>These concepts give us the tools to create the simplest graphs. With a simple graph created from these concepts, we could derive network properties explained in the following section. </p>
</div>
<div class="readable-text intended-text" id="p19">
<p>While real-world graphs are complex, simple graphs can often effectively represent them for various purposes. For example, though our social graph data contains node features (covered in section A.1.2), to create the visualization in figure A.1, we only used node and edge information.</p>
</div>
<div class="readable-text" id="p20">
<h3 class="readable-text-h3"><span class="num-string">A.1.1</span> Graph properties</h3>
</div>
<div class="readable-text" id="p21">
<p>In the following subsections, we discuss some of the more important properties of graphs. Many of the software programs and databases in the graph ecosystem (described in section A.3) should have the capability to compute some or all of these properties.</p>
</div>
<div class="readable-text" id="p22">
<h4 class="readable-text-h4">Size/order</h4>
</div>
<div class="readable-text" id="p23">
<p>We’re often interested in the overall number of nodes and edges in a graph. Formal names for these properties are <em>size</em> (the number of edges) and <em>order</em> (the number of nodes). In our social graph, the number of nodes is 1,933, and the number of edges is 12,239.</p>
</div>
<div class="readable-text" id="p24">
<h4 class="readable-text-h4">Degree distribution</h4>
</div>
<div class="readable-text" id="p25">
<p>A degree distribution is simply the distribution of the degrees of all the nodes in a graph. This can be shown as a histogram, as in figure A.2.</p>
</div>
<div class="readable-text intended-text" id="p26">
<p>The <em>degree</em> of a node is the number of adjacent nodes in an undirected graph. For directed graphs, there are two types of degrees a node can have: an <em>in-degree</em> for edges directed to the node and an <em>out-degree</em> for edges directed outward from the node. Self-loops often are given a count of 2 when calculating degree. If edges are given weights, a <em>weighted degree</em> can also account for these weights.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p27">
<img alt="figure" height="621" src="../Images/A-2.png" width="742"/>
<h5 class="figure-container-h5"><span class="num-string">Figure A.2</span> A histogram showing the degree distribution of our social graph</h5>
</div>
<div class="readable-text" id="p28">
<p>Related to the concept of a degree is that of a node’s neighborhood. For a given node, its adjacent nodes are also called its <em>neighbors</em>. The set of all its neighbors is called its <em>neighborhood</em>. The number of vertices in a node’s neighborhood is equal to that node’s degree.</p>
</div>
<div class="readable-text" id="p29">
<h4 class="readable-text-h4">Connectedness</h4>
</div>
<div class="readable-text" id="p30">
<p>A graph is a set of nodes and edges. In general, however, there is no condition that says for an undirected graph, every node can be reached by any other node within the same network. It can happen that within the same graph, sets of nodes are utterly separated from one another; that is, no edge links them. </p>
</div>
<div class="readable-text intended-text" id="p31">
<p>An undirected graph where any node can reach any other node is called a <em>connected graph</em>. It may seem obvious that all graphs must be connected, but this is often not the case. Graphs that have discontinuities (where a node or set of nodes are unlinked to the rest of the graph) are <em>disconnected graphs</em>. Another way to think about this is that in a connected graph, there is a path or walk whereby every node can reach every other node in the graph. For a disconnected graph, each disconnected piece is called a <em>component</em>. For a directed graph, where it’s not always possible to reach any node from any other node, a <em>strongly connected graph</em> is one where every node can reach every other node.</p>
</div>
<div class="readable-text intended-text" id="p32">
<p>As an example, the human population can be considered a disconnected social graph if we consider every individual human as a node and our communication channels as edges. While most of the population can be said to be connected by modern communication channels, there are hermits who chose to live off the grid and isolated hunter-gatherer tribes that reject contact with the rest of the world. In other use cases, there are often discontinuities in the network and its data.</p>
</div>
<div class="readable-text intended-text" id="p33">
<p>Examining our social graph, we see it’s disconnected with a large component that contains most of the nodes. Figures A.3 and A.4 show the entire graph, and the large connected component. If we focus on the large connected component, we find that the number of nodes is 1,698 and the number of edges is 12,222.<span class="aframe-location"/><span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p34">
<img alt="figure" height="544" src="../Images/A-3.png" width="806"/>
<h5 class="figure-container-h5"><span class="num-string">Figure A.3</span> Our entire social graph, which is disconnected. (<code>NetworkX</code> was used to generate this figure.) We observe a large connected component at the center, surrounded by disconnected nodes and small components consisting of two to three nodes. </h5>
</div>
<div class="browsable-container figure-container" id="p35">
<img alt="figure" height="544" src="../Images/A-4.png" width="800"/>
<h5 class="figure-container-h5"><span class="num-string">Figure A.4</span> The connected component of the social graph. (NetworkX was used to generate this figure.) Compare this to figure A.1, which is the same graph visualized using Graphistry. Differences in the parameters used in the algorithms, as well as visual features, account for the distinctiveness of the two figures.</h5>
</div>
<div class="readable-text" id="p36">
<h4 class="readable-text-h4">Graph traversals</h4>
</div>
<div class="readable-text" id="p37">
<p>In a graph, we can imagine traveling from a given node <em>a</em> to a second node <em>b</em>. Such a trip may require passing only one edge or passing several edges and nodes. Such a trip is called a <em>traversal</em>, or a <em>walk</em>, among other names. A traversal from one node to another is sometimes called a <em>hop</em>. Traversing a series of nodes is said to be done in <em>n</em> hops. A walk can be <em>open</em> or <em>closed</em>. Open walks have an ending node that is different from the starting node. A closed walk starts and ends with the same node. </p>
</div>
<div class="readable-text intended-text" id="p38">
<p>A <em>path</em> is a walk where no node is encountered more than once. A <em>cycle</em> is a closed path (with the exception of the starting node, which is also the ending node, no node is encountered twice). A <em>trail</em> is a walk where no edge is encountered more than once, and a <em>circuit</em> is a closed trail. Examples of these different types of paths are given in figure A.5. Note how the number of steps (or hops) changes between different types of paths.</p>
</div>
<div class="readable-text intended-text" id="p39">
<p>Imagine that for a given pair of nodes, we could find walks and paths between them. Of the paths we could navigate, there will be the shortest one (or maybe more than one path will tie for shortest). The length of this path is called the <em>distance</em> or <em>shortest path length</em>. <span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p40">
<img alt="figure" height="1950" src="../Images/A-5.png" width="654"/>
<h5 class="figure-container-h5"><span class="num-string">Figure A.5</span> Five types of paths</h5>
</div>
<div class="readable-text" id="p41">
<p>If we zoom out and examine the entire graph and its node pairs, we can list all the shortest path lengths. One of these distances will be the longest (or more than one may tie for longest). The largest distance is the <em>diameter</em> of the graph. The diameter is often used to characterize and compare graphs. </p>
</div>
<div class="readable-text intended-text" id="p42">
<p>If we take our list of distances and average them, we’ll generate the <em>average path length</em> of the graph. Average path length is another important measure for graphs. Both average path length and diameter give an indication of the density of the graph. Higher values for these metrics imply more connections, which in turn allow a greater variety of paths, both longer and shorter. </p>
</div>
<div class="readable-text intended-text" id="p43">
<p>For our social graph, the diameter of our largest component is 10. The diameter is undefined for the entire graph, as it’s unconnected. </p>
</div>
<div class="readable-text" id="p44">
<h4 class="readable-text-h4">Subgraphs</h4>
</div>
<div class="readable-text" id="p45">
<p>Consider a graph of nodes and edges. A <em>subgraph</em> is a subset of these nodes and edges. Subgraphs are of importance when these neighborhoods in the graph have properties that are distinct from other locations in the graph. Subgraphs occur in connected and disconnected graphs. A component of a disconnected graph is a subgraph.</p>
</div>
<div class="readable-text" id="p46">
<h4 class="readable-text-h4">Clustering coefficient</h4>
</div>
<div class="readable-text" id="p47">
<p>A node may have a high degree, but how well connected is its neighborhood? We can imagine an apartment building where everyone knows the landlord, but no one knows their neighbors (what a sad place!). The landlord would have a clustering coefficient of 0. At the other extreme, we could have an apartment where the landlord knows all the tenants, and every tenant knows every other tenant. Then, the landlord would have a clustering coefficient of 1 (such a situation, where all the nodes in a network are connected to every other node is called a <em>complete graph </em>or <em>fully connected graph</em>). Of course, there will be intermediate cases where only some of the tenants know one another, and these situations will have coefficients between 0 and 1.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p48">
<h5 class="callout-container-h5 readable-text-h5">The dimension of a graph </h5>
</div>
<div class="readable-text" id="p49">
<p>In machine learning and engineering in general, <em>dimension</em> is used in several ways. This term can be confusing as a result. </p>
</div>
<div class="readable-text" id="p50">
<p>Even within the topic of graphs, the term is used in a few ways in articles and academic literature. However, the term is often not explicitly defined or clarified. Thus, in the following list, we attempt to deconstruct the meaning of this term:</p>
</div>
<ul>
<li class="readable-text" id="p51"> <em>Size/shape of datasets</em>—In this case, dimension refers to the number of features in a dataset. Low-dimensional datasets are implied to be small enough to visualize (i.e., two or three features) or small enough to be computationally viable. </li>
<li class="readable-text" id="p52"> <em>Mathematical definitions</em>—In math, the dimension of a graph has more strict definitions. In linear algebra, graphs can be represented in vector spaces, and the dimension is an attribute of these vector spaces [1]. </li>
<li class="readable-text" id="p53"> <em>Geometric definition</em>—There is also a geometric definition of a graph’s dimension. This definition relates a graph’s dimension to the least number of Euclidean dimensions that will allow a graph’s edges to be of unit size 1 [1].  </li>
</ul>
</div>
<div class="readable-text" id="p54">
<h3 class="readable-text-h3"><span class="num-string">A.1.2</span> Characteristics of nodes and edges</h3>
</div>
<div class="readable-text" id="p55">
<p>In the most basic type of graph, we have a collection of nodes and edges, without parallel edges or self-loops. For this basic graph, we have a geometric structure only. While even this basic graph structure is useful, often more complexity is desired to properly model a situation for real-world problems and use cases. For example, we can do the following:</p>
</div>
<ol>
<li class="readable-text buletless-item" id="p56"> Reduce the geometric restrictions discussed earlier. Explicitly, these restrictions are as follows: 
    <ul>
<li> Each edge is incident to two nodes, one on each end of the edge. </li>
<li> Between two nodes, only one edge can exist. </li>
<li> No self-loops are used. </li>
</ul></li>
</ol>
<div class="readable-text list-body-item" id="p57">
<p>With these restrictions relaxed, we’re able to model more situations at the cost of more complex graphs.</p>
</div>
<ol class="faux-ol-li" style="list-style: none;">
<li class="readable-text faux-li has-faux-ol-li-counter" id="p58"><span class="faux-ol-li-counter">2. </span> Add <em>properties</em> to our graph elements (nodes, edges, the graph itself). A property or feature is data tied to a specific element. Depending on the context, terms such as <em>labels</em>, <em>attributes</em>, and <em>decorators</em> are used in place of <em>properties</em>. </li>
</ol>
<div class="readable-text" id="p59">
<p>In this section and the next, we’ll discuss the characteristics and variants of nodes, edges, and entire graphs. </p>
</div>
<div class="readable-text" id="p60">
<h4 class="readable-text-h4">Node properties</h4>
</div>
<div class="readable-text" id="p61">
<p>In the following list, we outline some of the different properties that nodes might contain. These become features in many data science or GNN tasks:</p>
</div>
<ul>
<li class="readable-text" id="p62"> <em>Names, IDs, and unique identifiers</em>—A name or an ID is a unique identifier. Many graph systems will either assign an identifier such as an index to a node, or allow the user to specify an ID. In our social graph, each node has a unique alphanumeric ID. </li>
<li class="readable-text" id="p63"> <em>Labels</em>—Within a graph, nodes may fall within certain classes or groups. For example, a graph modeling a social network may group people by their country of residence (USA, PRC, Nigeria) or their level of activity within the network (frequent user, occasional user). In this way, in contrast to the unique identifiers explained earlier, we’d expect several nodes to share the same label. </li>
<li class="readable-text" id="p64"> <em>Properties/attributes/features</em>—Properties that aren’t IDs or labels are usually called attributes or features. While such properties don’t have to be unique to a node, they don’t describe a node class either. Properties can be based on structural or nonstructural qualities.  </li>
<li class="readable-text" id="p65"> <em>Structural/topological properties</em>—Intrinsic characteristics of a node are related to the node’s topological properties and the geometrical structure of the graph in proximity to the node. Two examples are listed here:  
    <ul>
<li> A node’s degree, which, as we learned, is the number of incident edges it has. </li>
<li> A node’s centrality, which is a measure of how important a node is relative to the nodes in its neighborhood. </li>
</ul></li>
</ul>
<div class="readable-text list-body-item" id="p66">
<p>By employing graph analytical methods (described in section A.4) characteristics of nodes, relative to their local environment, can be identified. These can be incorporated into certain GNN problems as features. Node embeddings such as those generated by transductive methods (chapter 2) are another example of a property based on the graph’s local structure.</p>
</div>
<ul>
<li class="readable-text" id="p67"> <em>Nonstructural properties</em>—These are often based on real-world attributes. Taking the example of our social graph, we have two categorical properties: a person’s job category (e.g., scientist, marketer, administrator) and the type of company they work for (e.g., medical, transportation, consulting). These examples are categorical attributes. It’s possible to have numerical attributes, such as <em>years of experience</em> or <em>average number of direct reports</em> in all current and past roles. </li>
<li class="readable-text" id="p68"> <em>Edge properties —</em>Properties for edges mirror those for nodes. The most often used and important edge property is that of the edge weight, described earlier.  </li>
</ul>
<div class="readable-text" id="p69">
<h4 class="readable-text-h4">Edge variations</h4>
</div>
<div class="readable-text" id="p70">
<p>Unlike nodes, there are a few geometric variants of edges that can be used to make a graph model more descriptive.</p>
</div>
<ul>
<li class="readable-text" id="p71"> <em>Parallel edges</em>—Meaning more than one edge between two nodes <em>u</em> and <em>v</em>. </li>
<li class="readable-text" id="p72"> <em>Directionality</em>—Edges can have no direction or one direction. Because nodes <em>u</em> and <em>v</em> can have parallel edges connecting them, it’s possible to have two edges with opposite directionality or multiple edges with some combination of directions or undirectionality. </li>
<li class="readable-text" id="p73"> <em>Bidirectionality</em>—The case where between two nodes, both directions are represented in the respective edges. In practice, this term is used in a few ways: 
    <ul>
<li> To describe nondirected edges, or simple edges. </li>
<li> To describe two edges that have opposite directions (shown in figure A.6).<span class="aframe-location"/> </li>
</ul></li>
</ul>
<div class="browsable-container figure-container" id="p74">
<img alt="figure" height="341" src="../Images/A-6.png" width="397"/>
<h5 class="figure-container-h5"><span class="num-string">Figure A.6</span> From top to bottom, between two nodes, an example of an undirected edge, a directed edge from left to right, a directed edge from right to left, and two directed edges traversing both directions (bidirectionality)</h5>
</div>
<ul>
<li class="buletless-item" style="list-style-type: none;">
<ul>
<li class="readable-text" id="p75"> To describe an edge that has a direction at each end. This usage, while popular in the literature, is fairly rare in practical systems at the time of writing. </li>
</ul></li>
<li class="readable-text" id="p76"> <em>Self-loops</em>—Discussed previously, a self-loop, or loop, is the case where both ends of an edge connect to the same node. Where would one encounter a self-loop in the real world? For our social graph, let’s keep all the nodes, and consider a case where an edge would be an email sent from one professional to another. Sometimes, people send emails to themselves (for reminders). For such a scenario, an email to oneself could be modeled as a self-loop. </li>
</ul>
<div class="readable-text" id="p77">
<h3 class="readable-text-h3"><span class="num-string">A.1.3</span> Categories of graphs</h3>
</div>
<div class="readable-text" id="p78">
<p>Different categories of graphs depend on the node and edge characteristics we’ve just described. Following are the graph categories:</p>
</div>
<ul>
<li class="readable-text" id="p79"> <em>Simple graph</em>—A graph whose edges can’t be parallel edges or self-loops. Simple graphs can be connected or disconnected, as well as directed. </li>
<li class="readable-text" id="p80"> <em>Weighted graph</em>—A graph that uses weights. Our social graph has no weights; another way to express having no weights is to set all weights to 1 or 0.  </li>
<li class="readable-text" id="p81"> <em>Multigraphs —</em>A graph that is permitted to have multiple edges between any two nodes and multiple self-loops for any one node. A simple graph could be a special case of a multigraph if we’re working within a problem where we could add more edges and self-loops to it. </li>
<li class="readable-text" id="p82"> <em>Di-graphs</em>—Another term for a directed graph. </li>
<li class="readable-text" id="p83"> <em>K-partite graphs</em>—In many graphs, we may have a situation where we have two or more groups of nodes, where edges are only allowed between groups and not between nodes of the same group. “Partite” refers to the partitions of node groups, and “k” refers to the number of those partitions.  </li>
<li class="readable-text" id="p84"> <em>Monopartite graph</em>—A graph in which there is only one group of nodes and one group of edges. A monopartite social graph could consist of only “Texan” nodes connected with “work colleague” edges. For example, in a social graph, nodes can belong to “New Yorkers” or “Texans” groups, and relationships can belong to “friend” or “work colleague” groups. </li>
<li class="readable-text" id="p85"> <em>Bipartite (or bi-graph) graph</em>—A graph that has two node partitions within a graph. Nodes of one group can only connect to nodes of a second type and not to nodes within their own group. In our social graph example, nodes can belong to “New Yorkers” or “Texans” groups, and relationships can belong to “friend” or “work colleague” groups. In this graph, no New Yorkers would be adjacent to other New Yorkers, and the same for Texans. This is shown in figure A.7. <span class="aframe-location"/> </li>
</ul>
<div class="browsable-container figure-container" id="p86">
<img alt="figure" height="279" src="../Images/A-7.png" width="542"/>
<h5 class="figure-container-h5"><span class="num-string">Figure A.7</span> A bipartite graph. There are two types of nodes (upper and lower row of circles). In a bipartite graph, nodes can’t be connected to nodes of the same type (those in the same row). This is also an example of a heterogeneous graph.</h5>
</div>
<div class="readable-text list-body-item" id="p87">
<p>For more than three partitions, the requirement that adjacent nodes can’t be the same type still holds. In practice, <em>k</em> can be a large number.</p>
</div>
<ul>
<li class="readable-text" id="p88"> <em>Trees</em>—A tree is a well-studied data structure in machine learning and is a special case of a graph. It’s a connected graph without cycles. Another way to describe a graph without cycles is <em>acyclic</em>. In the data science and deep learning worlds, a well-known example is the directed acyclic graph (DAG), used in designing and governing data workflows. </li>
<li class="readable-text" id="p89"> <em>Hypergraphs</em>—Up to now, our graphs have consisted of edges that connect to two nodes or one node (a self-loop). For a hypergraph, an edge can be incident to more than two nodes. These data structures have a range of applications, including ones that involve the use of GNNs. This is shown in figure A.8.  </li>
<li class="readable-text" id="p90"> <em>Heterogeneous graphs</em>—A heterogeneous graph has multiple node and edge types, while a multirelational graph has multiple edge types.<span class="aframe-location"/> </li>
</ul>
<div class="browsable-container figure-container" id="p91">
<img alt="figure" height="694" src="../Images/A-8.png" width="1012"/>
<h5 class="figure-container-h5"><span class="num-string">Figure A.8</span> One undirected hypergraph, illustrated in two ways. On the left, we have a graph whose edges are represented by shaded areas and marked by letters, and whose vertices are dots, marked by numbers. On the right, we have a graph whose edge lines (marked by letters) connect up to three nodes (circles marked by numbers). Node 8 has no edge. Node 7 has a self-loop.</h5>
</div>
<div class="readable-text" id="p92">
<h2 class="readable-text-h2"><span class="num-string">A.2</span> Graph representations</h2>
</div>
<div class="readable-text" id="p93">
<p>Now that we have a conceptual idea of what graphs are, we move on to how to work with them. First, we focus on data structures most relevant to building graph algorithms and storing graph data. We’ll see that some of these structures, particularly the adjacency matrix, play a prominent role in the GNN algorithms we study in the bulk of this book.</p>
</div>
<div class="readable-text intended-text" id="p94">
<p>Next, we’ll examine a few graph data models. These are important in designing and managing how databases and other data systems deal with network data. Lastly, we’ll briefly take a look at how graph data is exposed to analysts and engineers via APIs and query languages.</p>
</div>
<div class="readable-text" id="p95">
<h3 class="readable-text-h3"><span class="num-string">A.2.1</span> Basic graph data structures</h3>
</div>
<div class="readable-text" id="p96">
<p>There are a few important ways to represent graphs that can be ported to a computational environment:</p>
</div>
<ul>
<li class="readable-text" id="p97"> <em>Adjacency matrix</em>—A node-to-node matrix. </li>
<li class="readable-text" id="p98"> <em>Incidence matrix</em>—An edge-to-node matrix. </li>
<li class="readable-text" id="p99"> <em>Edge lists</em>—A list of edges by their nodes. </li>
<li class="readable-text" id="p100"> <em>Adjacency lists</em>—Lists of each node’s adjacent nodes. </li>
<li class="readable-text" id="p101"> <em>Degree matrix</em>—Node-to-node matrix of degree values. </li>
<li class="readable-text" id="p102"> <em>Laplacian matrix</em>—The degree matrix minus the adjacency matrix (<strong>D</strong>-<strong>A</strong>). This is useful in spectral theory. </li>
</ul>
<div class="readable-text" id="p103">
<p>These are by no means the only ways to represent a graph, but from a survey of the literature, software, storage formats, and libraries, these are the most prevalent. In practice, a graph may not be permanently stored as one of these structures, but to execute a needed operation, a graph or subgraph may be transformed from one representation to another.</p>
</div>
<div class="readable-text intended-text" id="p104">
<p>What representations are used depends on many factors that should be weighed in planning. These factors include the following:</p>
</div>
<ul>
<li class="readable-text" id="p105"> <em>Size of graph</em>—How many vertices and edges does the graph contain, and how much are these expected to scale? </li>
<li class="readable-text" id="p106"> <em>Density of graph</em>—Is the graph sparse or dense? We’ll touch on these terms in the next subsection. </li>
<li class="readable-text" id="p107"> <em>Complexity of the graph’s structure</em>—Is the graph closer to a simple graph, or one that uses one or more of the variations discussed previously? </li>
<li class="readable-text" id="p108"> <em>Algorithms to be used</em>—For a given algorithm, a given data structure may perform relatively weakly or strongly compared to others. In the following subsections, for each structure, we’ll touch on two simple algorithms to compare. </li>
<li class="readable-text" id="p109"> <em>Costs to do CRUD (create, read, updated, delete) operations</em>—How will you modify your graph (including creating, reading, updating, or deleting nodes, edges, and their attributes) over the course of your operations and how frequently will you do so? </li>
</ul>
<div class="readable-text" id="p110">
<p>In many data projects, transformation from one data structure to another is common to accommodate particular operations. So, it’s normal to employ two or more of the previously mentioned data structures in a project. In this case, understanding the compute effort to execute the transformation is key. For the most popular structures, graph libraries allow methods that allow seamless transformations, but given the considerations listed previously, executing these transformations could take unexpected time or cost.</p>
</div>
<div class="readable-text intended-text" id="p111">
<p>For the following discussion, we’ll talk about how these data structures are used to store topological information about graphs. The only attributes we’ll consider are node IDs and edge weights. To illustrate these concepts, let’s use the weighted graph, consisting of five nodes, as shown in figure A.9. Circles indicate nodes with their IDs; rectangles are the edge weights.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p112">
<img alt="figure" height="214" src="../Images/A-9.png" width="412"/>
<h5 class="figure-container-h5"><span class="num-string">Figure A.9</span> An example graph with different weighted edges and labeled nodes from 0 to 4</h5>
</div>
<div class="readable-text" id="p113">
<p>Let’s now dive into those six popular ways of representing graphs so they can be used computationally.</p>
</div>
<div class="readable-text" id="p114">
<h4 class="readable-text-h4">Adjacency matrix</h4>
</div>
<div class="readable-text" id="p115">
<p>For a graph with <em>n</em> nodes, an <em>adjacency matrix</em> represents the graph as an <em>N</em> × <em>N</em> matrix format, where each row or column describes the edge between two nodes. For our example graph, shown previously in figure A.9, we have five columns and five rows. These rows and columns are labeled for each node. Cells of the matrix denote adjacency. </p>
</div>
<div class="readable-text intended-text" id="p116">
<p>Adjacency matrices can be used for simple directed and undirected graphs. They can also be used for graphs with self-loops. In an unweighted graph, each cell is either 0 (no adjacency) or 1 (adjacency). For a weighted graph, the values in the cells are the edge weights. For unweighted parallel edges, the values of the cells are the number of edges.</p>
</div>
<div class="readable-text intended-text" id="p117">
<p>For our example, a weighted, undirected graph, the corresponding adjacency matrix is shown in table A.1. Because our graph is undirected, the adjacency matrix is symmetric. For directed graphs, symmetry is possible but not guaranteed. </p>
</div>
<div class="browsable-container browsable-table-container framemaker-table-container" id="p118">
<h5 class="browsable-container-h5"><span class="num-string">Table A.1</span> An adjacency matrix for the graph in figure A.9</h5>
<table>
<thead>
<tr>
<th/>
<th>
<div>
<strong>0</strong>
</div></th>
<th>
<div>
<strong>1</strong>
</div></th>
<th>
<div>
<strong>2</strong>
</div></th>
<th>
<div>
<strong>3</strong>
</div></th>
<th>
<div>
<strong>4</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr>
<td> <strong>0</strong> <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
<td>  3 <br/></td>
<td>  5 <br/></td>
</tr>
<tr>
<td> <strong>1</strong> <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
<td>  1 <br/></td>
<td>  1 <br/></td>
</tr>
<tr>
<td> <strong>2</strong> <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
<td>  3 <br/></td>
<td>  0 <br/></td>
</tr>
<tr>
<td> <strong>3</strong> <br/></td>
<td>  3 <br/></td>
<td>  1 <br/></td>
<td>  3 <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
</tr>
<tr>
<td> <strong>4</strong> <br/></td>
<td>  5 <br/></td>
<td>  1 <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p119">
<p>By inspecting this matrix, we can get a quick visual understanding of the characteristics of the matrix. We can see, for example, how many degrees node 1 has and get a general idea of the distribution of the degrees. We also see that there are more empty spaces (cells with a 0 value) than edges. This ease of using the matrix to draw quick insights for small graphs is one advantage of adjacency matrices. Even for large graphs, plotting the adjacency matrix can indicate certain subgraph structures.</p>
</div>
<div class="readable-text intended-text" id="p120">
<p>Adjacency matrices, and matrix representations in general, allow you to analyze graphs by using linear algebra. One relevant example is spectral graph theory (which underlies a few GNN algorithms).</p>
</div>
<div class="readable-text intended-text" id="p121">
<p>Adjacency matrices are straightforward to implement in Python. The matrix in our example can be created using a list of lists, or a NumPy array:</p>
</div>
<div class="browsable-container listing-container" id="p122">
<div class="code-area-container">
<pre class="code-area">&gt;&gt;import numpy as np
&gt;&gt;arr = np.array([[0, 0, 0, 3, 3],
                    [0, 0, 0, 1, 1],
                    [0, 0, 0, 3, 0], 
                    [3, 1, 3, 0, 0],
                    [5, 1, 0, 0, 0]])</pre>
</div>
</div>
<div class="readable-text" id="p123">
<p>With our adjacency matrix as a NumPy array, let’s explore another property of our graph. From our visual inspection of our matrix, we noticed many more zero values than nonzero values. This makes it a sparse matrix. <em>Sparse matrices</em>, that is, matrices with a large proportion of zero values, can take up unnecessary storage or memory space and increase calculation times. <em>Dense matrices</em>, contrarily, contain a large proportion of nonzero matrices. The following determines the sparsity of our matrix:</p>
</div>
<div class="browsable-container listing-container" id="p124">
<div class="code-area-container">
<pre class="code-area">&gt;&gt;sparsity = 1.0 - ( np.count_nonzero(arr) / arr.size )
&gt;&gt;print(sparsity)
&gt;&gt; 0.6</pre>
</div>
</div>
<div class="readable-text" id="p125">
<p>So, our matrix has a sparsity of 0.6, meaning 60% of the values in this matrix are zeros. </p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p126">
<h5 class="callout-container-h5 readable-text-h5">Sparsity using node degree</h5>
</div>
<div class="readable-text" id="p127">
<p>Another way to think about sparsity is in terms of node degree. Let’s derive the sparsity value just shown from the perspective of the node degree. </p>
</div>
<div class="readable-text" id="p128">
<p>For a simple, undirected graph of <em>n</em> nodes, each node can make at most <em>n-1</em> connections, and thus have a maximum degree of <em>n-1</em>. The maximum number of edges can be calculated using combinatorics: because each edge represents a pair of nodes, for a set of <em>n</em> nodes, the maximum number of edges is “<em>n</em> choose 2”, that is, <em>(n C 2)</em> or <em>n</em>(<em>n </em>– 1)/2. However, for our small matrix, we have a directed graph, which is clear because the adjacency matrix isn’t symmetric. This means that both directions count separately and need to times by 2. Hence, for our small matrix, the maximum number of possible edges is 5(5 – 1) = 20. The density of a graph is defined as the actual number of edges, <em>e</em>,<em> </em>over all possible edges, and sparsity can then be defined as 1 – density. In our example, this leads to a quantity that disagrees with what was calculated using the matrix alone, namely (1 – 10/20) = 0.5, which is not equal to 0.6 in the preceding code snippet. This is because we haven’t considered self-loops, which is standard practice for graph theory. If we included self-loops, we would have five additional possible edges (or 5^2), resulting in (1 – 10/25), or 0.6, matching the value in the earlier code. This highlights that care needs to be taken when reporting on the sparsity of a graph. </p>
</div>
</div>
<div class="readable-text" id="p129">
<p>Now, think of a graph that has not five, but millions or billions of nodes. Such graphs exist in the real world, and quite often the sparsity can be orders of magnitudes less than 0.6. For undirected simple graphs, the adjacency matrix is symmetric, so only half the storage is needed. Most of the memory or storage containing the adjacency matrix would be devoted to zero values. Thus, the high sparsity of this data structure leads to memory inefficiencies.</p>
</div>
<div class="readable-text intended-text" id="p130">
<p>In terms of complexity, for a simple graph, the space complexity would be <strong>O</strong>(<em>n</em><sup>2</sup>), for undirected simple graphs. For an undirected graph, due to the symmetry, the space complexity would be <strong>O</strong>(<em>n</em>(<em>n</em>–1)/2).</p>
</div>
<div class="readable-text intended-text" id="p131">
<p>For time complexity, this of course depends on the task or the algorithm. Let’s look at two rudimentary tasks that we’ll also address for adjacency list and edge lists:</p>
</div>
<ul>
<li class="readable-text" id="p132"> Checking the existence of an edge between a particular pair of nodes </li>
<li class="readable-text" id="p133"> Finding the neighbors of a node </li>
</ul>
<div class="readable-text" id="p134">
<p>For the first task, we simply check the row and column corresponding to those nodes. This would take <strong>O</strong>(1) time. For the second, we need to check every item in that node’s row; this would take <strong>O</strong>(deg(<em>n</em>)) time, where deg(<em>n</em>) is the degree of the node.</p>
</div>
<div class="readable-text intended-text" id="p135">
<p>To summarize, the advantages of adjacency matrices are that they can quickly check connections between nodes and are easy to visually interpret. The downsides are that they are less space-efficient for sparse matrices. The computational tradeoffs depend on your algorithm. They shine in cases where we have small and dense graphs.</p>
</div>
<div class="readable-text" id="p136">
<h4 class="readable-text-h4">Incidence matrix</h4>
</div>
<div class="readable-text" id="p137">
<p>While the adjacency matrix has a row and column for every node, an <em>incidence matrix</em> represents every edge as a column and every node as a row. Using the same graph shown earlier in figure A.9, we can construct an incidence matrix, which we show in table A.2.</p>
</div>
<div class="browsable-container browsable-table-container framemaker-table-container" id="p138">
<h5 class="browsable-container-h5"><span class="num-string">Table A.2</span> Incidence matrix for the example graph in figure A.9</h5>
<table>
<thead>
<tr>
<th/>
<th>
<div>
<strong>0</strong>
</div></th>
<th>
<div>
<strong>1</strong>
</div></th>
<th>
<div>
<strong>2</strong>
</div></th>
<th>
<div>
<strong>3</strong>
</div></th>
<th>
<div>
<strong>4</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr>
<td> <strong>0</strong> <br/></td>
<td>  0 <br/></td>
<td>  3 <br/></td>
<td>  5 <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
</tr>
<tr>
<td> <strong>1</strong> <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
<td>  1 <br/></td>
<td>  1 <br/></td>
</tr>
<tr>
<td> <strong>2</strong> <br/></td>
<td>  3 <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
</tr>
<tr>
<td> <strong>3</strong> <br/></td>
<td>  3 <br/></td>
<td>  3 <br/></td>
<td>  0 <br/></td>
<td>  1 <br/></td>
<td>  0 <br/></td>
</tr>
<tr>
<td> <strong>4</strong> <br/></td>
<td>  0 <br/></td>
<td>  0 <br/></td>
<td>  5 <br/></td>
<td>  0 <br/></td>
<td>  1 <br/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p139">
<p>An incidence matrix can represent wider variations of graph types than an adjacency matrix. Multigraphs and hypergraphs are straightforward to express with this data structure.</p>
</div>
<div class="readable-text intended-text" id="p140">
<p>How does the incidence matrix perform with respect to space and time? To store the data of a simple graph, the incidence matrix has a space complexity of <strong>O</strong>(<em>|E|</em> * <em>|V|</em>), where <em>|V|</em> is the number of nodes (<em>V</em> for vertices), and <em>|E|</em> is the number of edges. Thus, it’s superior to the adjacency matrix for graphs with fewer edges than nodes, including sparse matrices. </p>
</div>
<div class="readable-text intended-text" id="p141">
<p>To get an idea of time complexity, we turn to our two simple tasks: checking for an edge, and finding a node’s neighbors. To check the existence of an edge, an incidence matrix has a time complexity of O(<em>|E|</em> * <em>|V|</em>), far slower than the adjacency matrix, which does this in constant time. To find the neighbors of a node, an incidence matrix also takes O(<em>|E|</em> * <em>|V|</em>). </p>
</div>
<div class="readable-text intended-text" id="p142">
<p>Overall, incidence matrices have space advantages when used with sparse matrices. For time performance, they have slow performance on the simple tasks we covered. The overall advantage of using incidence matrices is for unambiguously representing complex graphs, such as multigraphs and hypergraphs. </p>
</div>
<div class="readable-text" id="p143">
<h4 class="readable-text-h4">Adjacency lists</h4>
</div>
<div class="readable-text" id="p144">
<p>In an <em>adjacency list</em>, the aim is to show which vertices each node is adjacent to. So, for <em>n</em> nodes, we have <em>n</em> lists of neighbors corresponding to each node. Depending on what data structures are used for the lists, properties may also be included in the summary. For our example, a simple adjacency list is shown in figure A.10.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p145">
<img alt="figure" height="558" src="../Images/A-10.png" width="688"/>
<h5 class="figure-container-h5"><span class="num-string">Figure A.10</span> Our example graph and its adjacency list</h5>
</div>
<div class="readable-text" id="p146">
<p>Such an adjacency list can be accomplished in python using a dictionary with each node as the keys, and lists of the adjacent nodes as values:</p>
</div>
<div class="browsable-container listing-container" id="p147">
<div class="code-area-container">
<pre class="code-area">{ 0 : [ 3, 4],
1 : [3, 4],
2 : [3],
3 : [0, 1, 2],
4 : [0, 1] }</pre>
</div>
</div>
<div class="readable-text" id="p148">
<p>We can improve on the dictionary values to allow for the inclusion of the weights of the neighbors:</p>
</div>
<div class="browsable-container listing-container" id="p149">
<div class="code-area-container">
<pre class="code-area">{ 0 : [ (3, 3), (4, 5)],
1 : [(3, 1), (4, 1)],
2 : [(3, 3)],
3 : [(0, 3), (1, 1), (2, 3)],
4 : [(0, 5) , (1, 1)] }</pre>
</div>
</div>
<div class="readable-text" id="p150">
<p>For undirected graphs, the set of nodes doesn’t have to be ordered. Because the adjacency list doesn’t devote space to node pairs that aren’t neighbors, we see that adjacency lists lack the sparsity problems of adjacency matrices. So, to store this data structure, we have a space complexity of <strong>O</strong>(n + v), where <em>n</em> is the number of nodes, and <em>v</em> is the number of edges.</p>
</div>
<div class="readable-text intended-text" id="p151">
<p>Going back to the two computational tasks, checking the existence of an edge (task 1) would take <strong>O</strong>(deg(node)) time, where deg(node) is the degree of either node. For this, we simply check every item in that node’s list, where for the worst case, we’d have to check them all. For task 2, finding a node’s neighbors would also take <strong>O</strong>(deg(node)) time, because we have to inspect every item in that node’s list whose length is the node’s degree.</p>
</div>
<div class="readable-text intended-text" id="p152">
<p>Let’s summarize the tradeoffs of an adjacency list. The advantages are that they are relatively efficient in terms of storage because only edge relationships are stored. This means a sparse matrix would take up less space stored as an adjacency list than as an adjacency matrix. Computationally, the tradeoffs depend on the algorithm you’re running and the type of graph you’re using as input data. </p>
</div>
<div class="readable-text" id="p153">
<h4 class="readable-text-h4">Edge lists</h4>
</div>
<div class="readable-text" id="p154">
<p>Compared to the preceding two representations, <em>edge lists </em>are relatively simple. They consist of a set of doubles (two nodes) or triples (two nodes and an edge weight). These identify a unique edge thusly: </p>
</div>
<ul>
<li class="readable-text" id="p155"> Node, node (edge weight), for an undirected graph </li>
<li class="readable-text" id="p156"> Source node, destination node (edge weight), for a directed graph </li>
</ul>
<div class="readable-text" id="p157">
<p>Edge lists can represent single, unconnected nodes. For our example graph, the edge list would be the following:</p>
</div>
<div class="browsable-container listing-container" id="p158">
<div class="code-area-container">
<pre class="code-area">{ 0, 3, 3 }
{ 0, 4, 5 }
{ 1, 3, 1 }
{ 1, 4, 1 }
{ 2, 3, 3 }</pre>
</div>
</div>
<div class="readable-text" id="p159">
<p>In Python, we can create this as a set of tuples:</p>
</div>
<div class="browsable-container listing-container" id="p160">
<div class="code-area-container">
<pre class="code-area">&gt;&gt; edge_list = {( 0, 3, 3 ), ( 0, 4, 5 ), \
( 1, 3, 1 ), ( 1, 4, 1 ), ( 2, 3, 3 ) }</pre>
</div>
</div>
<div class="readable-text" id="p161">
<p>On performance, for storage, the space complexity of an edge list is O(<em>e</em>), where <em>e</em> is the number of edges. Regarding our two tasks shown previously, to establish the existence of a particular edge will have a time complexity of <strong>O</strong>(<em>e</em>), assuming an unordered edge list. To discover all the neighbors of a node, <strong>O</strong>(<em>e</em>) is the space complexity. In each case, we have to go through the edges in the list one by one to check for the edge or the node’s neighbor. So, from a compute performance point of view, edge lists have a disadvantage compared to the other two data structures, especially for executing more complex algorithms. </p>
</div>
<div class="readable-text intended-text" id="p162">
<p>However, another advantage of edge lists is that they are more compact than adjacency lists or adjacency matrices. Additionally, they are simple to both create and interpret. For example, we could store an edge list as a text file where each line only consists of two identifiers separated by a space. For many systems and databases, edge lists in CSV or text files are the default option to serialize data. </p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p163">
<h5 class="callout-container-h5 readable-text-h5">The Laplacian matrix</h5>
</div>
<div class="readable-text" id="p164">
<p>One data representation of a graph that is highly valuable in analyzing graphs is the Laplacian matrix, as mentioned earlier. This matrix is key to the development of graph spectral theory, which is in turn critical to the development of spectral-based GNN methods. </p>
</div>
<div class="readable-text" id="p165">
<p>To produce the Laplacian matrix, we subtract the adjacency matrix from the degree matrix (D – A). The degree matrix is a node-to-node matrix whose values are the degree of a particular node. The degree matrix for our example graph is given in the first table and the Laplacian matrix follows. <span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p166">
<img alt="sidebar figure" height="354" src="../Images/table_A-1.png" width="927"/>
<h5 class="figure-container-h5">Degree matrix for our example graph</h5>
</div>
<div class="browsable-container figure-container" id="p167">
<img alt="sidebar figure" height="351" src="../Images/table_A-2.png" width="929"/>
<h5 class="figure-container-h5">Laplacian matrix for our example graph</h5>
</div>
<div class="readable-text" id="p168">
<p>In practice, Laplacian matrices aren’t used for storage or as a basis for graph operations like the other data structures covered in this section. Their advantages lie in spectral analysis. We discuss spectral graph analysis in chapter 3.</p>
</div>
</div>
<div class="readable-text" id="p169">
<h3 class="readable-text-h3"><span class="num-string">A.2.2</span> Relational databases</h3>
</div>
<div class="readable-text" id="p170">
<p>We’re steadily marching from theory to implementation. In the previous section, we reviewed common data structures used to represent graphs and their tradeoffs. Graphs can be implemented in these structures from scratch in your preferred programming language and are also implemented in popular graph processing libraries. </p>
</div>
<div class="readable-text intended-text" id="p171">
<p>With the listed data structures, we have a variety of ways to implement the structural information in graphs. But graphs and their elements often come with useful attributes and metadata. </p>
</div>
<div class="readable-text intended-text" id="p172">
<p>A <em>relational database</em> is an organized way to represent the structural information, attributes, and metadata of a graph. Very much related to this is the notion of a <em>schema</em>, which is a framework that explicitly defines the elements that make up a graph (i.e., varieties of nodes and edges, attributes, etc.), and explicitly defines how these elements work together. </p>
</div>
<div class="readable-text intended-text" id="p173">
<p>Data models and schemas are critical parts of the scaffolding used to design graph systems such as graph databases and graph processing systems, and they often build on the data structures reviewed in the previous section. We’ll review three such models and provide examples of real systems where they are used. </p>
</div>
<div class="readable-text" id="p174">
<h4 class="readable-text-h4">Minimalist graph data model</h4>
</div>
<div class="readable-text" id="p175">
<p>The simplest relational database uses only nodes, edges, and weights. It can be used on directed or undirected graphs. If weights are used, they can be retrieved using a lookup table. </p>
</div>
<div class="readable-text intended-text" id="p176">
<p>Pregel, Google’s graph processing framework, which other popular frameworks are based on (including Apache Giraph used by Facebook, and Apache Spark GraphX), relies on such a directed graph. There, both edges and nodes have an identifier and a single numerical value, which can be interpreted as a weight or attribute. </p>
</div>
<div class="readable-text" id="p177">
<h4 class="readable-text-h4">RDF graph data model</h4>
</div>
<div class="readable-text" id="p178">
<p>Resource Description Framework (RDF; aka Triple Stores) models follow a subject-predicate-object pattern, where nodes are subjects and objects, and edges are predicates. Nodes and edges have one main attribute, which can be a unique resource identifier (URI) or a literal. URIs, in essence, identify the type of node or edge being described. Examples of literals can be specific timestamps or dates. Predicates represent relationships. Such triples (subject-predicate-object) represent what are called <em>facts</em> in this context. Usually, facts are directed and flow in the direction from subject to object.</p>
</div>
<div class="readable-text intended-text" id="p179">
<p>Popular graph databases that use the RDF model include Amazon’s Neptune (Neptune also allows the use of labeled property graphs [LPGs]), Virtuoso, and Stardog.</p>
</div>
<div class="readable-text" id="p180">
<h4 class="readable-text-h4">Property graph data model</h4>
</div>
<div class="readable-text" id="p181">
<p>In property graphs (aka LPGs), allowances are made to confer various metadata to nodes and edges. Such metadata include the following:</p>
</div>
<ul>
<li class="readable-text" id="p182"> <em>Identifiers</em> —Distinguish individual nodes and edges. </li>
<li class="readable-text" id="p183"> <em>Labels</em> —Describe classes (or subsets) of nodes or edges.  </li>
<li class="readable-text" id="p184"> <em>Attributes or properties</em> —Describe individual nodes or edges. </li>
</ul>
<div class="readable-text" id="p185">
<p>Nodes have an ID and a set of key/value pairs that can be used to supply additional attributes (also called properties). Similarly, edges have an ID and a set of key/value pairs for attributes. </p>
</div>
<div class="readable-text intended-text" id="p186">
<p>You can think of the property graph as the minimalist graph extended by adding labels and removing the restrictions on the types and number of attributes. Figure A.11 provides a look at a property graph and its equivalent RDF graph. Popular graph databases that use models based on the property graph include Neo4j, Azure Cosmos, and TigerGraph.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p187">
<img alt="figure" height="869" src="../Images/A-11.png" width="1100"/>
<h5 class="figure-container-h5"><span class="num-string">Figure A.11</span> Example of a property graph and its equivalent RDF graph</h5>
</div>
<div class="readable-text" id="p188">
<h4 class="readable-text-h4">Nongraph data model</h4>
</div>
<div class="readable-text" id="p189">
<p>There are a variety of databases and systems that use neither RDF nor LPG. These databases and systems store or express nodes, edges, and attributes within other storage frameworks, such as document stores, key value stores, and even within a relational database framework.</p>
</div>
<div class="readable-text" id="p190">
<h4 class="readable-text-h4">Knowledge graphs</h4>
</div>
<div class="readable-text" id="p191">
<p>Although the term is used widely in academic, commercial, and practitioner circles, there is no unifying definition of a knowledge graph. Most relevant to GNNs, we define a <em>knowledge graph</em> as a representation of knowledge discretized into facts, as defined earlier. In other words, a knowledge graph is a multigraph set onto a specific <em>subject-relationship-object</em> schema.</p>
</div>
<div class="readable-text intended-text" id="p192">
<p>Knowledge graphs may be represented with RDF schemas, but there are other data models and graph models that can accommodate knowledge graphs. GNN methods are used to embed the data in the nodes and edges, establish the quality of facts, and discover new entities and relations. An example of a knowledge graph is shown in figure A.12. <span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p193">
<img alt="figure" height="739" src="../Images/A-12.png" width="1009"/>
<h5 class="figure-container-h5"><span class="num-string">Figure A.12</span> An example of a knowledge graph representing an academic research network within a university’s physics department. The graph illustrates both hierarchical relationships, such as professors and students being members of the department, and behavioral relationships, such as professors supervising students and authoring papers. Entities such as Prof, Student, Paper, and Topic are connected through semantically meaningful relationships (e.g., Supervises, Wrote, and Inspires). Entities also have detailed features (e.g., Name, Department, and Type) to provide further context. The semantic connections and features enable advanced querying and analysis of complex academic interactions. </h5>
</div>
<div class="readable-text" id="p194">
<h4 class="readable-text-h4">Node and edge types</h4>
</div>
<div class="readable-text" id="p195">
<p>In graphs that have a schema, including knowledge graphs, the edges and nodes can be assigned a <em>type</em>. <em>Types</em> are part of a defined schema, and as such, govern how data elements interact with each other. They also often have a descriptive aspect. To distinguish <em>types</em> from <em>properties</em>, consider that while types help define the rules of how data elements work together and how they are interpreted by the data system, properties are descriptive only. </p>
</div>
<div class="readable-text intended-text" id="p196">
<p>To illustrate types, we can use a road map analogy, where towns are nodes, and passages between them are edges. Our edges may include highways, footpaths, canals, or bike paths. Each one is a type. Due to geography, towns can be surrounded by swamps, sit atop mountain peaks, or have other obstacles and impediments to one versus another passage. For towns separated by a desert, passage is only possible by a highway. For other towns, passages can be by multiple passage types. In building this analogy, we see that our town nodes also have types defined by their proximate geography: swamp town, desert town, island town, valley town.</p>
</div>
<div class="readable-text" id="p197">
<h3 class="readable-text-h3"><span class="num-string">A.2.3</span> How graphs are exposed</h3>
</div>
<div class="readable-text" id="p198">
<p>We’ve talked about relational data structures and relational databases to understand how graphs are constructed and stored. In real life, however, most of us won’t build graphs from scratch or from the bottom up. When constructing and analyzing graphs, there will be a layer of abstraction between us and the primitive data. In what ways, then, is a graph exposed to the data scientist or engineer? Next, we’ll briefly explain the following two ways and then discuss the graph ecosystem:</p>
</div>
<ul>
<li class="readable-text" id="p199"> <em>APIs</em> —Using graph libraries or data processing systems </li>
<li class="readable-text" id="p200"> <em>Query languages</em> —Querying graph databases via specialized query languages </li>
</ul>
<div class="readable-text" id="p201">
<h4 class="readable-text-h4">APIs: Graph objects in graph systems</h4>
</div>
<div class="readable-text" id="p202">
<p>When using a graph library or processing software, usually we want the graph we work with to have certain properties and to be able to execute operations on the graph. From this lens, it’s helpful to think of graphs as software objects that can be operated on by software functions. </p>
</div>
<div class="readable-text intended-text" id="p203">
<p>In Python, an effective way to implement these is to have a graph class, with some operations implemented as methods of the graph class or as standalone functions. Nodes and edges can be attributes of the graph class, or they can have their own node and edge classes. Properties of graphs implemented in this way can be attributes of the respective classes.</p>
</div>
<div class="readable-text intended-text" id="p204">
<p>An example of this is <code>NetworkX</code>, a Python-based graph processing library. <code>NetworkX</code> implements a graph class. Nodes can be any hashable object; examples of node objects are integers, strings, files, and even functions. Edges are tuple objects of their respective nodes. Both nodes and edges can have properties implemented as Python dictionaries. Following are two short lists of typical methods and attributes of graph classes found in libraries and processing systems.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p205">
<h5 class="callout-container-h5 readable-text-h5">Basic methods of graph objects</h5>
</div>
<div class="readable-text" id="p206">
<p>In the following list, we outline some of the methods that can be applied to graph objects:</p>
</div>
<ul>
<li class="readable-text" id="p207"> <code>Graph_Creation</code>—A constructor that creates a new graph object </li>
<li class="readable-text" id="p208"> <code>Add_Node</code>, <code>Add_Edge</code>—Adds nodes or edges, and their attributes and labels, if any </li>
<li class="readable-text" id="p209"> <code>Get_Node</code>, <code>Get_Edge</code>—Retrieves stored nodes or edges, with specified attributes and labels </li>
<li class="readable-text" id="p210"> <code>Update_Node</code>, <code>Updage_Edge</code>, <code>Update_Graph</code>—Updates properties and attributes of nodes, edges, and graph objects </li>
<li class="readable-text" id="p211"> <code>Delete_Node</code>, <code>Delete_Edge</code>—Deletes a specified node or edge </li>
</ul>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p212">
<h5 class="callout-container-h5 readable-text-h5">Basic attributes of graph objects</h5>
</div>
<div class="readable-text" id="p213">
<p>In the following list, we outline some of the attributes for graph objects: </p>
</div>
<ul>
<li class="readable-text" id="p214"> <code>Number_of_Nodes</code>, <code>Number_of_Edges</code>—A constructor that creates a new graph object </li>
<li class="readable-text" id="p215"> <code>Node_Neighbors</code>—Retrieves the adjacent nodes or incident edges of a node </li>
<li class="readable-text" id="p216"> <code>Node_List</code>, <code>Edge_List</code>—Adds nodes or edges and their attributes and labels, if any </li>
<li class="readable-text" id="p217"> <code>Connected_Graph</code>—Retrieves stored nodes or edges, with specified attributes and labels </li>
<li class="readable-text" id="p218"> <code>Graph_State</code>—Retrieves global attributes, labels, and properties of the graph </li>
<li class="readable-text" id="p219"> <code>Directed_Graph</code>—Deletes a specified node or edge </li>
</ul>
</div>
<div class="readable-text" id="p220">
<h4 class="readable-text-h4">Graph query languages </h4>
</div>
<div class="readable-text" id="p221">
<p>When working with a graph in a graph database, a query language is used. For most relational databases, some variant of SQL is used as the standard language. In the graph database space, there is no standard query language. Following are the languages that currently stand out:</p>
</div>
<ul>
<li class="readable-text" id="p222"> <em>Gremlin</em>—A language that can be written declaratively or imperatively, which is designed for database or processing system queries. Developed by the Apache TinkerPop project, Gremlin is used in several databases (Titan, OrientDB) and processing systems (Giraph, Hadoop, Spark).  </li>
<li class="readable-text" id="p223"> <em>Cypher</em>—A declarative language for property graph–based database queries. Developed by Neo4j, Cypher is used by Neo4j and several other databases. </li>
<li class="readable-text" id="p224"> <em>SPARQL</em>—A declarative query language for RDF-based database queries. SPARQL is used by Amazon Neptune, AllegroGraph, and others. </li>
</ul>
<div class="readable-text" id="p225">
<h2 class="readable-text-h2"><span class="num-string">A.3</span> Graph systems</h2>
</div>
<div class="readable-text" id="p226">
<p>We’ve covered the basic building blocks that allow us to implement graphs in a programming language. In practice, you’ll seldom create a graph from scratch because you’ll load data into memory or a database using a library or API. The field of graph libraries, databases, and commercial software is broad and growing rapidly. A good way to determine what to use is to start with your use case and requirements, and then choose your development and deployment architecture from there. This section will briefly give an overview of this landscape to help you. The taxonomy we develop here is by no means absolute but should serve as a useful guideline.</p>
</div>
<div class="readable-text intended-text" id="p227">
<p>At the time of writing, commercial and open source tools for graph analysis, machine learning modeling, visualization, and storage are expanding relatively rapidly. With a lot of overlap between tools and functions, as well as many hybrid tools that don’t neatly fit into any category, there is no clean delineation of segments. Given this, we just highlight basic methods and focus on the most popular tools in the following segments:</p>
</div>
<ul>
<li class="readable-text" id="p228"> Graph databases </li>
<li class="readable-text" id="p229"> Graph compute engines (or graph frameworks) </li>
<li class="readable-text" id="p230"> Visualization libraries </li>
<li class="readable-text" id="p231"> GNN libraries </li>
</ul>
<div class="readable-text" id="p232">
<h3 class="readable-text-h3"><span class="num-string">A.3.1</span> Graph databases</h3>
</div>
<div class="readable-text" id="p233">
<p>Graph databases are the graph analogues of traditional relational databases from a functional standpoint. Such databases were devised to handle transactions focused on Online Transaction Processing (OLTP). They allow CRUD transactions and also tend to follow ACID (atomicity, consistency, isolation, and durability) principles regarding the integrity of the data. Graph databases of this type differ from relational databases in that they store data using graph data models and schemas. At the time of writing, the most popular graph databases are Neo4j, Microsoft Cosmos DB, OrientDB, and ArangoDB. Except for Neo4j, these databases support multiple models, including property graphs. Neo4j supports property graphs only. The most popular databases that support RDF models are Virtuoso and Amazon Neptune.</p>
</div>
<div class="readable-text intended-text" id="p234">
<p>In addition to property graphs and RDF databases, other types of nongraph databases are used to store graph data. Document stores, relational databases, and key-value stores are examples. To use such nongraph databases with graph data models, you must carefully define how the existing schema maps to the graph elements and their attributes.</p>
</div>
<div class="readable-text" id="p235">
<h3 class="readable-text-h3"><span class="num-string">A.3.2</span> Graph compute engines (or graph frameworks)</h3>
</div>
<div class="readable-text" id="p236">
<p>Graph compute engines are designed to make queries using batches of data. Such queries can output aggregate statistics or output graph-specific items, such as cluster identification and find shortest paths. These data systems tend to follow the Online Application Processing (OLAP) model. It’s not unusual for such systems to work closely with a graph database, which serves the input data batches needed for the analytic queries. Examples of such systems include Apache Spark’s GraphX, Giraph, and Stanford Network Analysis Platform (SNAP).</p>
</div>
<div class="readable-text" id="p237">
<h3 class="readable-text-h3"><span class="num-string">A.3.3</span> Visualization libraries</h3>
</div>
<div class="readable-text" id="p238">
<p>Graph visualization tools share characteristics with graph compute engines, as they are geared toward analytics versus transactional queries and computations. However, such tools are designed to create aesthetic and useful images of the networks under analysis. In the best visualization tools, these images are interactive and dynamic. Outputs of visualization systems can be optimized for presentation on the web, or in printed format with high definition. Examples of such tools are Gephi, Cytoscape, and Tulip.</p>
</div>
<div class="readable-text" id="p239">
<h3 class="readable-text-h3"><span class="num-string">A.3.4</span> GNN libraries</h3>
</div>
<div class="readable-text" id="p240">
<p>The last segment of graph tools is the central subject of this book. Here, we’re grouping software tools that create graph embeddings with tools that train the models using graph data. At the time of writing, there are many solutions available. Graph representation tools range from dedicated, standalone libraries (PyTorch BigGraph [PBG]) to graph systems that have embedding as a feature (Neo4j as a database and SNAP as a compute framework).</p>
</div>
<div class="readable-text intended-text" id="p241">
<p>GNN libraries come as standalone libraries, and as libraries that use TensorFlow or PyTorch as a backend. In this text, the focus will be on PyTorch Geometric (PyG). Other popular libraries include Deep Graph Library (DGL; a standalone library) and Spektral, which uses Kera and TensorFlow as a backend. The best libraries implement not only a range of deep learning layers but also the available benchmark datasets.</p>
</div>
<div class="readable-text" id="p242">
<h2 class="readable-text-h2"><span class="num-string">A.4</span> Graph algorithms</h2>
</div>
<div class="readable-text" id="p243">
<p>As the field of graphs has been around for a while, the number of different graph algorithms is vast. Understanding well-used graph algorithms can provide valuable context with which to think about the algorithms used in neural networks. Graph algorithms can also serve as sources of node, edge, or graph features for GNNs. Finally, as with all machine learning methods, sometimes a statistical model isn’t the best solution. Understanding the analytical landscape can help when deciding whether or not to use a GNN solution.</p>
</div>
<div class="readable-text intended-text" id="p244">
<p>In this section, we review two types of graph algorithms, <em>search algorithms</em> and <em>shortest path</em>. We provide a general description, explaining why they are important. For an in-depth treatment on this topic, review the references for this appendix at the end of the book, particularly [1–3].</p>
</div>
<div class="readable-text" id="p245">
<h3 class="readable-text-h3"><span class="num-string">A.4.1</span> Traversal and search algorithms</h3>
</div>
<div class="readable-text" id="p246">
<p>In section A.1.1, we discussed the concept of a walk and a path. In these fundamental concepts, we get from one node in a graph to another by traversing a set of nodes and edges between them. </p>
</div>
<div class="readable-text intended-text" id="p247">
<p>For large graphs with many nonunique walks and paths between node pairs, how do we decide which path to take? Similarly, for graphs we haven’t explored and don’t have a map of, what is the best way to create that map? Wrapped into these questions is the problem of what direction to take when traversing a graph at a particular node. For a node of degree 1, this answer is trivial; for a node with degree 100, the answer is less so. </p>
</div>
<div class="readable-text intended-text" id="p248">
<p>Traversal algorithms offer systematic ways to walk a graph. For such algorithms, we start at a node, and following a set of rules, we decide on the next node to hop to. Often, as we conduct the walk, we keep track of nodes and edges that have been encountered. For certain algorithms, if we outline the path taken, we can end up with a tree structure. Three well known strategies for traversal are given here:</p>
</div>
<ul>
<li class="readable-text" id="p249"> <em>Breadth first</em> —A breadth-first traversal prefers to explore all of the immediate neighbors of a node before going further away. This is also known as breadth-first search (BFS). </li>
<li class="readable-text" id="p250"> <em>Depth first</em> —With depth-first search (DFS), rather than explore every immediate neighbor first, we follow each new node without regard to its relationship to the current node. This is done in such a way that every node is encountered <em>at least</em> once, and every edge is encountered <em>exactly</em> once.  </li>
</ul>
<div class="readable-text list-body-item" id="p251">
<p>There are versions of DFS and BFS for directed graphs as well.</p>
</div>
<ul>
<li class="readable-text" id="p252"> <em>Random</em> —In random traversals, in contrast to BFS and DFS, where traversal is governed by a set of rules, traversal to the next node is done randomly. For a starting node of degree 4 in a random traversal with a uniform distribution, each neighboring node would have a 25% chance of being chosen. Such methods are used in algorithms such as DeepWalk and Node2Vec (covered in chapter 2). </li>
</ul>
<div class="readable-text" id="p253">
<h3 class="readable-text-h3"><span class="num-string">A.4.2</span> Shortest path</h3>
</div>
<div class="readable-text" id="p254">
<p>An enduring problem highly related to graphs is that of the shortest path. Interest in solving this problem has existed for decades (a great survey paper of shortest path methods was published as far back as 1969 [4]), with several distinct algorithms existing. Modern applications of shortest path methods are used in navigation applications, such as finding the fastest route to a destination. Variations of such algorithms include the following:</p>
</div>
<ul>
<li class="readable-text buletless-item" id="p255"> Shortest path between 
    <ul>
<li> Two nodes </li>
<li> Two nodes on a path that includes specified nodes </li>
<li> All nodes </li>
<li> One node to all others </li>
</ul></li>
<li class="readable-text" id="p256"> Ranked shortest paths (i.e., second shortest path, third shortest, etc.) </li>
</ul>
<div class="readable-text" id="p257">
<p>Such algorithms can also take into account weights in graphs. In these cases, shortest path algorithms are also called least-cost algorithms.</p>
</div>
<div class="readable-text intended-text" id="p258">
<p>A highly lauded algorithm for least-cost determination is Dijkstra’s algorithm. Given a node, it finds the shortest path to every other node or to a specified node. As this algorithm progresses, it traverses the graph while keeping track of the distance and connecting nodes (to the start node) of each node it encounters. It prioritizes the nodes encountered by their shortest (or least-cost) path to the start node. As the algorithm traverses, it prioritizes low-cost paths.</p>
</div>
<div class="readable-text" id="p259">
<h2 class="readable-text-h2"><span class="num-string">A.5</span> How to read GNN literature</h2>
</div>
<div class="readable-text" id="p260">
<p>GNNs are a rapidly proliferating topic. New methods and techniques have been proposed in a short span of time. Though this book focuses on practical and commercial applications of graphs, much of the state of the art in this field is disclosed in academic journals and conferences. Knowing how to effectively study publications from these sources is essential to keep up to speed with the field and to encounter valuable ideas that can be implemented in code.</p>
</div>
<div class="readable-text intended-text" id="p261">
<p>In this short section, we list some commonly used notations to describe graphs in technical publications as well as a few tips on reading academic literature for the practitioner. These tips are especially for those interested in using the methodology in a paper but are working under time constraints:</p>
</div>
<ul>
<li class="readable-text" id="p262"> To efficiently extract value from a paper, be selective on which sections of the publication to focus on. It’s important to clearly understand the problem statement and the solution to translate this into code. This might sound obvious, but many papers include sections that, for a practitioner, can be distracting at best. Mathematical proofs and long historical notes are good examples. </li>
<li class="readable-text" id="p263"> A positive trend is the increasing inclusion of code and data in research papers to enhance reproducibility. However, replicating results may still be challenging due to factors like model-specific optimizations or hardware constraints. If you encounter difficulties, reaching out to the authors can often provide valuable clarification. </li>
<li class="readable-text" id="p264"> Look closely at indicators of the application scope of the problem and solution. An exciting development may not be applicable to your problem, and it may not be immediately obvious. Similarly, don’t take all claims for state-of-the-art results at face value. The academic world is extremely competitive and claimed state-of-the-art results may not hold, especially if a paper isn’t yet peer-reviewed. </li>
</ul>
<div class="readable-text" id="p265">
<h3 class="readable-text-h3"><span class="num-string">A.5.1</span> Common graph notations</h3>
</div>
<div class="readable-text" id="p266">
<p>In mathematical notation, a graph is described as a set of nodes and edges:</p>
</div>
<div class="readable-text indented-paragraph equation-paragraph" id="p267">
<p><span class="num-string">(A.1)</span> <em>G</em> = (<em>V</em>, <em>E  </em>)</p>
</div>
<div class="readable-text" id="p268">
<p>where <em>V</em> and <em>E</em> are collections or sets of vertices (nodes) and edges, respectively. When we want to express the count of elements in these collections, we use <em>|V|</em> and <em>|E|</em>. In the following list, we outline some of the typical nomenclature for the mathematics of graphs:</p>
</div>
<ul>
<li class="readable-text" id="p269"> For directed graphs, an accented G (<em><span><img alt="equation image" height="30" src="../Images/eq-appendix-a-269-1.png" width="12"/></span></em>) is sometimes, but not always used. </li>
<li class="readable-text" id="p270"> Individual nodes and edges are denoted by lowercase letters, <em>v</em> and <em>e</em>, respectively. </li>
<li class="readable-text" id="p271"> When referring to a pair of adjacent nodes, we use <em>u</em> and <em>v</em>. Thus, an edge can also be expressed as {<em>u</em>, <em>v</em>}, or <em>uv</em>. </li>
<li class="readable-text" id="p272"> When dealing with weighted graphs, a weight for a particular edge is expressed as <em>w</em>(<em>e</em>). In terms of an edge’s nodes, we can include the weight as {<em>u</em>, <em>v</em>,<em> w </em>}. </li>
<li class="readable-text" id="p273"> To express the features of a graph or its elements, we use the notation <em>x</em> or <strong>x </strong>when the features are expressed as a vector or matrix, respectively. </li>
<li class="readable-text" id="p274"> For graph representations, because many such representations are matrices, bold letters are used to express them: <strong>A</strong> for the adjacency matrix, <strong>L</strong> for the Laplacian matrix, and so on. </li>
</ul>
</div></body></html>