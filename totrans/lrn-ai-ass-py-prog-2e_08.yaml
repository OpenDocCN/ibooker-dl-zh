- en: 9 *Automating tedious tasks*
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 *自动化繁琐的任务*
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding why programmers write tools
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解程序员编写工具的原因
- en: Determining which modules we need to write a given tool
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定我们需要编写特定工具的模块
- en: Automating cleaning up emails that have > > > symbols
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化清理带有> > >符号的电子邮件
- en: Automating manipulating PDF files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化操作PDF文件
- en: Automating removing duplicate pictures across multiple image libraries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化在多个图像库中删除重复图片
- en: Suppose that you’re responsible for creating 100 reports, one for each of 100
    people. Perhaps you’re a teacher and need to send a report to each of your students.
    Perhaps you work for HR and need to send an annual assessment report to each employee.
    Regardless of your role, you have the problem of having to create these reports,
    and you decided to prepare your reports as .pdf files. You need a customized cover
    page for each report too, and those cover pages are designed by one of your colleagues
    (a graphic design artist).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你负责创建100份报告，每份报告对应100个人中的每一个。也许你是一名教师，需要给每个学生发送一份报告。也许你在人力资源部门工作，需要给每个员工发送年度评估报告。无论你的角色如何，你都有必须创建这些报告的问题，你决定将这些报告作为.pdf文件准备。你还需要为每份报告准备定制的封面页，这些封面页是由你的同事（一位平面设计师）设计的。
- en: You and your colleague work independently, and, finally, the job is done. Or
    wait, not so fast. Because now you have to put each cover page at the beginning
    of each report.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你和你的同事独立工作，最后工作完成了。或者等等，不是那么快。因为现在你必须将每个封面页放在每份报告的开头。
- en: At this point, a nonprogrammer might grit their teeth and start on the job,
    manually merging the cover page with the first report, the second cover page with
    the second report, and so on. That could take hours. Not knowing that there may
    be another way, a nonprogrammer may just power ahead until the job is done.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，一个非程序员可能会咬紧牙关开始工作，手动将封面页与第一份报告合并，第二封面页与第二份报告合并，以此类推。这可能会花费数小时。由于不知道还有其他方法，一个非程序员可能会一直努力直到工作完成。
- en: But you’re a programmer now. And most programmers, the two of us included, would
    never power ahead with manual work like this.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但你现在是一名程序员。而且大多数程序员，包括我们两个，都不会手动进行这样的工作。
- en: In this chapter, we’re going to show you how to write programs to automate tedious
    tasks. The second example in the chapter will automate the “merging cover pages
    with reports” situation. But we’ll do others as well. Received an email that’s
    been forwarded so many times
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向你展示如何编写程序来自动化繁琐的任务。章节中的第二个例子将自动化“合并封面页与报告”的情况。但我们还会做其他的事情。收到已被转发多次的电子邮件
- en: that it looks
  id: totrans-12
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它看起来
- en: like
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样
- en: this?
  id: totrans-14
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个？
- en: Or does your family have several phones, each with hundreds of images, and you
    just want to get the images all in the same place so that you can archive them
    without losing anything? In this chapter, we’ll show you how to automate tasks
    like that.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你的家人有几部手机，每部手机都有几百张图片，你只是想将所有图片放在同一个地方，以便你可以归档它们而不会丢失任何东西？在本章中，我们将向你展示如何自动化这类任务。
- en: 9.1 Why programmers make tools
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 为什么程序员要制作工具
- en: 'There’s a common sentiment that programmers often express: we’re lazy. This
    doesn’t mean that we don’t want to do our work. It means that we don’t want to
    do *repetitive, boring, tedious* work because that’s what computers are good at.
    Programmers develop a sort of spidey-sense for this kind of drudgery. Suppose
    Leo has a few hundred photos, and he wants to delete any photos that are duplicates.
    There’s no way he’d do this by hand. Or suppose that Dan has to send out a customized
    email to each of his students. If it’s more than a few students, there’s no way
    he’s doing this by hand. As soon as programmers start noticing that they’re repeating
    the same keys on the keyboard or working through the same steps over and over,
    they’ll stop and make a tool to automate it.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员常常表达的一种普遍观点是：我们很懒惰。这并不意味着我们不想完成我们的工作。这意味着我们不想做那些重复、无聊、繁琐的工作，因为那是计算机擅长的事情。程序员对这种苦差事有一种类似蜘蛛侠的感觉。假设Leo有几百张照片，他想要删除任何重复的照片。他不可能手动做这件事。或者假设Dan必须给他的每个学生发送定制的电子邮件。如果学生人数超过几个，他也不可能手动做这件事。一旦程序员开始注意到他们在键盘上重复相同的按键或一遍又一遍地执行相同的步骤，他们就会停下来，制作一个工具来自动化这个过程。
- en: When programmers talk about tools, they’re talking about programs that do something
    that saves them time. A tool often isn’t the end goal, and writing one can itself
    feel tedious and not glamorous. But once we have a tool, we can use it to save
    us time. Sometimes, we’ll use a tool once, for one specific job, and then never
    again. Commonly, though, a tool ends up being useful over and over, whether we
    use the tool exactly as we wrote it or by making some small changes. For example,
    after Dan finishes teaching each course, he uses a program he wrote to collate
    all student grades and submit them to the university. He makes small changes to
    the tool each time—changing the weights of each assignment, for example—but then
    Dan can use that slightly modified tool to do the work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员谈论工具时，他们是在谈论那些能节省他们时间的程序。一个工具通常不是最终目标，编写一个工具本身可能会感觉枯燥乏味，并不光彩。但一旦我们有了工具，我们就可以用它来节省时间。有时，我们可能会用一次工具，完成一项特定的任务，然后就不会再用了。然而，通常情况下，一个工具会反复被证明是有用的，无论是我们按照我们编写的方式使用它，还是通过做一些小的改动。例如，丹完成每一门课程的授课后，他会使用自己编写的程序来整理所有学生的成绩并提交给大学。每次他都会对工具做一些小的改动——比如改变每个作业的权重——但丹就可以使用这个略微修改过的工具来完成工作。
- en: 'The great thing about using Copilot is that it makes cranking out these tools
    easier. Here’s how one software engineer explains it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Copilot 的好处是它使制作这些工具变得更加容易。以下是某位软件工程师的解释：
- en: We all know that tools are important, that effective tools are challenging to
    create, and that management doesn’t care or understand the need for tools. . .
    . I can’t express how fundamentally different programming feels now that I can
    build two quality tools per day, for every single itch I want to scratch. [1]
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们都知道工具很重要，有效的工具很难创建，而管理层并不关心或理解对工具的需求……我无法表达现在编程感觉有多么根本性地不同，因为我现在每天可以构建两个质量工具，以满足我每一个想要解决的问题。[1]
- en: 9.2 How to use Copilot to write tools
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 如何使用 Copilot 编写工具
- en: As we learned in chapter 5 when talking about modules, sometimes we need to
    use a module to help us write the program we want. Some modules are built into
    Python. For example, in chapter 5, we used the built-in zipfile module to help
    us create a .zip file. Other modules aren’t built in, and we need to install them
    first before we can use them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 5 章讨论模块时所学到的，有时我们需要使用一个模块来帮助我们编写我们想要的程序。一些模块是内置在 Python 中的。例如，在第 5 章中，我们使用了内置的
    zipfile 模块来帮助我们创建一个 .zip 文件。其他模块不是内置的，我们需要先安装它们才能使用。
- en: When writing a tool, it’s often the case that we’ll be working with some specialized
    data format (zip files, PDF files, Microsoft Excel spreadsheets, images) or performing
    some specialized task (sending email, interacting with a website, moving files
    around). For most of this, we’re going to need to use a module. Which module,
    though? And is it built in, or do we need to install it? These are the first questions
    we need to get answers to.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写工具时，我们通常需要处理一些特殊的数据格式（zip 文件、PDF 文件、Microsoft Excel 电子表格、图像）或执行一些特殊的任务（发送电子邮件、与网站交互、移动文件）。对于大多数这些任务，我们都需要使用一个模块。那么，是哪个模块呢？它是内置的还是我们需要安装它？这是我们首先需要得到答案的问题。
- en: Fortunately, we can use Copilot Chat (or ChatGPT) to help us get started. As
    a reminder, we’re using the Copilot Chat feature because it’s built into our Visual
    Studio Code (VS Code) IDE and because Copilot Chat has access to the very code
    we’re currently writing so it can incorporate what we’re doing into its answers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以使用 Copilot Chat（或 ChatGPT）来帮助我们开始。作为提醒，我们使用 Copilot Chat 功能是因为它内置在我们的
    Visual Studio Code（VS Code）IDE 中，并且因为 Copilot Chat 可以访问我们目前正在编写的代码，因此它可以将其所做的工作纳入其答案中。
- en: 'The plan is to have a conversation with Copilot to determine which module we
    need to use. Once we know that and install the module, if necessary, then we can
    get down to the business of writing the code for our tool. We’ll do that the way
    we’ve always done it: by writing the function header and a docstring and having
    Copilot fill in the code for us. Once Copilot starts writing code, we need to
    follow the same steps as in previous chapters, including checking code correctness,
    fixing bugs, and maybe even doing some problem decomposition. To focus our attention
    on writing tools to automate tasks, we’ll minimize the time we spend on these
    additional tasks here.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是与 Copilot 进行对话，以确定我们需要使用哪个模块。一旦我们知道这一点并安装了模块（如果需要的话），我们就可以着手编写我们工具的代码了。我们将像以前一样做：编写函数头和文档字符串，让
    Copilot 填写代码。一旦 Copilot 开始编写代码，我们需要遵循与前面章节相同的步骤，包括检查代码正确性、修复错误，甚至可能进行一些问题分解。为了将我们的注意力集中在编写自动化任务的工具上，我们将尽量减少在这些额外任务上花费的时间。
- en: It may be possible to ask Copilot or ChatGPT to write the entire tool for us,
    without even having to put it inside of a function. We won’t do that here, though,
    because we still think that the benefits of functions are worthwhile. A function
    will help us document our code so that we know what it does, and it enables flexibility
    if we later decide, for example, to add additional parameters to our function
    to change the behavior of the tool.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可能可以向 Copilot 或 ChatGPT 请求为我们编写整个工具，甚至不需要将其放入函数中。不过，我们在这里不会这样做，因为我们仍然认为函数的好处是值得的。函数将帮助我们记录代码，以便我们知道它做什么，并且它使我们能够在以后决定，例如，向函数添加额外的参数以改变工具的行为。
- en: '9.3 Example 1: Cleaning up email text'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 示例 1：清理电子邮件文本
- en: 'Sometimes, an email gets replied to and forwarded so many times that it becomes
    a mess, with many greater than (>) signs and spaces on some of the lines. Here’s
    a sample email of what we mean:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一封电子邮件被回复和转发多次，变得一团糟，有些行上有许多大于（>）符号和空格。以下是我们所指的样本电子邮件：
- en: Hi Leo,
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 嗨，利奥，
- en: Dan -- any luck with your natural language research?
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 丹 -- 你的自然语言研究有什么进展吗？
- en: Yes! That website you showed me
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是的！你给我看的那个网站
- en: '[https://www.kaggle.com/](https://www.kaggle.com/)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.kaggle.com/](https://www.kaggle.com/)'
- en: is very useful. I found a dataset on there that collects
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 非常有用。我在那里找到一个数据集，它收集了
- en: a lot
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 很多
- en: of questions and answers that might be useful to my research.
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可能对我的研究有用的问答。
- en: Thank you,
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 谢谢，
- en: Dan
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 丹
- en: 'Suppose that you wanted to save this email information for future use. You
    might like to clean up the > and space symbols at the start of lines. You could
    start manually deleting them—this email isn’t that long, after all—but don’t do
    that because here you have an opportunity to design a general-purpose tool that
    you can use whenever you need to perform this task. Whether your email has five
    lines, a hundred lines, or a million lines, it won’t matter: just use the tool
    and be done.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想保存这封电子邮件信息以备将来使用。你可能希望清理行首的>和空格符号。你可以开始手动删除它们——毕竟，这封电子邮件并不长——但不要这样做，因为这里你有机会设计一个通用的工具，你可以在需要执行此任务时使用它。无论你的电子邮件有五行、一百行还是一百万行，这都不会有关系：只需使用工具，完成任务即可。
- en: 9.3.1 Conversing with Copilot
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 与 Copilot 对话
- en: We need to make the messy email available to our tool so that the tool can clean
    it up. One way we can do this is to first copy the text of an email to the clipboard
    (using your Copy to Clipboard command on your operating system, such as Ctrl-C).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要让杂乱的电子邮件可供我们的工具使用，以便工具可以清理它。我们可以做到这一点的一种方法是将电子邮件的文本首先复制到剪贴板（使用您操作系统的复制到剪贴板命令，例如
    Ctrl-C）。
- en: Each computer operating system has a clipboard to store the last thing copied.
    If you’ve ever used Copy-Paste, you’ve used that clipboard. We’re going to use
    the clipboard for temporary storage of text so we can edit the text in the clipboard
    and then paste it where we need it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个计算机操作系统都有一个剪贴板来存储最后复制的内容。如果你曾经使用过复制粘贴，你就使用过那个剪贴板。我们将使用剪贴板作为文本的临时存储，以便我们可以在剪贴板中编辑文本，然后将其粘贴到所需的位置。
- en: After copying the text from the messy email to the clipboard, we could then
    run the tool on the text in the clipboard, and the tool could clean up the email
    and replace the clipboard contents with the cleaned-up version. For the tool to
    do something reasonable, we assume that your clipboard has email text on it. The
    tool will remove the > and space characters at the start of each line so that
    you can paste (using your operating system Paste command, such as Ctrl-V) the
    newly cleaned-up email wherever you want. In terms of Python, it will need to
    pull the clipboard contents into a string (i.e., copy the contents of the clipboard),
    clean it up, and then put that new cleaned-up text back on the clipboard (i.e.,
    paste to the clipboard), replacing the junky version of the email that was there
    before.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在将乱糟糟的电子邮件内容复制到剪贴板后，我们可以在剪贴板中的文本上运行工具，该工具可以清理电子邮件并将剪贴板内容替换为清理后的版本。为了使工具执行合理操作，我们假设您的剪贴板上有电子邮件文本。工具将删除每行开头的>和空格字符，这样您就可以使用操作系统的粘贴命令（如Ctrl-V）将新清理的电子邮件粘贴到您想要的位置。在Python方面，它需要将剪贴板内容拉入一个字符串（即复制剪贴板的内容），清理它，然后将新的清理文本放回剪贴板（即粘贴到剪贴板），替换之前那里的垃圾邮件版本。
- en: So, how do we access the clipboard in our Python program? That’s what we need
    to figure out, so that will frame the conversation that we have with Copilot.
    Similar to chapter 8, we’re going to use “Human” for the prompts that we type
    and “GitHub Copilot” for Copilot’s responses. You can use the Copilot Chat feature
    or ChatGPT to have a similar conversation. We’re typing our prompts into the Copilot
    Chat window.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在Python程序中访问剪贴板？这正是我们需要弄清楚的问题，这将是我们与Copilot对话的框架。类似于第8章，我们将使用“Human”作为我们输入的提示，使用“GitHub
    Copilot”作为Copilot的响应。您可以使用Copilot Chat功能或ChatGPT进行类似的对话。我们正在将提示输入到Copilot Chat窗口中。
- en: In our chats with Copilot, we’re going to explore widely before settling on
    a solution. We’ll explain why we’re doing this once we’ve gotten the hang of things
    through one example, but we note this here so that you’ll be ready for this seemingly
    less direct approach. Copilot provides quite a bit of sample code in its responses.
    As we’re exploring, feel free to skim that code, but don’t get bogged down in
    it. We’ll look at more particulars of the code once we finish exploring and settle
    on a plan. Let’s start learning!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们与Copilot的对话中，我们将广泛探索，然后确定解决方案。一旦我们通过一个示例掌握了事情，我们就会解释为什么这样做，但在这里我们注明这一点，以便您为这种看似不那么直接的方法做好准备。Copilot在其响应中提供了大量的示例代码。在我们探索的过程中，您可以随意浏览那些代码，但不要陷入其中。一旦我们完成探索并确定计划，我们再来看代码的更多细节。让我们开始学习吧！
- en: LPHumanI would like to write a Python program that accesses the clipboard and
    lets me copy and paste using the clipboard. How can I do this?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman我想写一个Python程序，可以访问剪贴板并让我使用剪贴板进行复制和粘贴。我该如何操作？
- en: '![chatGpt](../Images/chatGpt.png)GitHub CopilotYou can use the pyperclip module
    to access the clipboard in Python. Here’s an example program that lets you copy
    and paste using the clipboard:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot您可以使用pyperclip模块在Python中访问剪贴板。以下是一个示例程序，它允许您使用剪贴板进行复制和粘贴：'
- en: '[PRE0]`*[PRE1]`*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]`*[PRE1]`*'
- en: '*`*import pyperclip*`*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import pyperclip*`*'
- en: '*`*# Copy to clipboard*`*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 复制到剪贴板*`*'
- en: '*`*pyperclip.copy(''Hello, world!'')*`*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pyperclip.copy(''Hello, world!'')*`*'
- en: '*`*# Paste from clipboard*`*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 从剪贴板粘贴*`*'
- en: '*`*text = pyperclip.paste()*`*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*text = pyperclip.paste()*`*'
- en: '*`*print(text)*`*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(text)*`*'
- en: '*[PRE2]*[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE2]*[PRE3]'
- en: This program first imports the pyperclip module. It then copies the string `'Hello,`
    `world!'` to the clipboard using the `copy()` function. Finally, it pastes the
    contents of the clipboard into the “text” variable using the `paste()` function
    and prints the result.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序首先导入pyperclip模块。然后使用`copy()`函数将字符串`'Hello, world!'`复制到剪贴板。最后，使用`paste()`函数将剪贴板的内容粘贴到“text”变量中，并打印结果。
- en: You can install the pyperclip module using pip by running `pip` `install` `pyperclip`
    in your terminal.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在终端中运行`pip install pyperclip`来使用pip安装pyperclip模块。
- en: Copilot’s response teaches us that we can use the pyperclip module to interact
    with the clipboard in our Python program. The sample code that it provided even
    showed us how to copy stuff from our program to the clipboard and paste stuff
    from the clipboard into a variable (`text`). We’re making great progress!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot的响应告诉我们，我们可以在Python程序中使用pyperclip模块与剪贴板进行交互。它提供的示例代码甚至展示了如何从我们的程序中复制内容到剪贴板，并将剪贴板中的内容粘贴到一个变量（`text`）中。我们取得了很大的进步！
- en: The final paragraph of the response tells us how to install pyperclip. Aha!
    So pyperclip doesn’t come with Python by default. While we’ll learn how to install
    modules later, it might be nice to not have to worry about that. So, let’s continue
    the conversation, asking Copilot if we can do better.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的最后一段告诉我们如何安装 pyperclip。啊哈！所以 pyperclip 并不是 Python 默认自带的。虽然我们稍后会学习如何安装模块，但不必担心这一点可能是个好事。所以，让我们继续对话，询问
    Copilot 是否有更好的方法。
- en: LPHuman Is there a way I can do it without having to install a Python module?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman 想知道是否有办法在不安装 Python 模块的情况下完成这个操作？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, you can use the tkinter
    module that comes with Python to access the clipboard. Here’s an example program
    that lets you copy and paste using the clipboard without installing any additional
    modules:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 是的，你可以使用 Python 自带的 tkinter
    模块来访问剪贴板。以下是一个示例程序，它允许你使用剪贴板复制和粘贴，而不需要安装任何额外的模块：'
- en: '[PRE4]`*[PRE5]`*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]`*[PRE5]`*'
- en: '*`*import tkinter as tk*`*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import tkinter as tk*`*'
- en: '*`*# Create a Tkinter window*`*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Create a Tkinter window*`*'
- en: '*`*root = tk.Tk()*`*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*root = tk.Tk()*`*'
- en: '*`*# Hide the window*`*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Hide the window*`*'
- en: '*`*root.withdraw()*`*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*root.withdraw()*`*'
- en: '*`*# Copy to clipboard*`*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Copy to clipboard*`*'
- en: '*`*root.clipboard_clear()*`*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*root.clipboard_clear()*`*'
- en: '*`*root.clipboard_append(''Hello, world!'')*`*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*root.clipboard_append(''Hello, world!'')*`*'
- en: '*`*# Paste from clipboard*`*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Paste from clipboard*`*'
- en: '*`*text = root.clipboard_get()*`*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*text = root.clipboard_get()*`*'
- en: '*`*print(text)*`*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(text)*`*'
- en: '*[PRE6]*[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE6]*[PRE7]'
- en: This program first creates a hidden Tkinter window using the `Tk()` function
    and hides it using the `withdraw()` method. It then clears the clipboard using
    the `clipboard_ clear()` method and appends the string `'Hello,` `world!'` to
    the clipboard using the `clipboard_append()` method. Finally, it retrieves the
    contents of the clipboard using the `clipboard_get()` method and prints the result.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序首先使用 `Tk()` 函数创建一个隐藏的 Tkinter 窗口，并使用 `withdraw()` 方法将其隐藏。然后，它使用 `clipboard_clear()`
    方法清除剪贴板，并使用 `clipboard_append()` 方法将字符串 `'Hello, world!'` 添加到剪贴板。最后，它使用 `clipboard_get()`
    方法检索剪贴板的内容并打印结果。
- en: Note that this method only works if you have a graphical environment available,
    such as a desktop environment on Linux or macOS, or the Windows desktop on Windows.
    If you’re running Python in a terminal-only environment, you’ll need to use a
    different method to access the clipboard.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种方法仅在存在图形环境时才有效，例如 Linux 或 macOS 上的桌面环境，或 Windows 上的 Windows 桌面。如果你在仅终端的环境中运行
    Python，你需要使用不同的方法来访问剪贴板。
- en: It seems that we’ve won something and lost something else. The win is that this
    tkinter module is built into Python. The loss is that “the method only works if
    you have a graphical environment available.” Do we have a graphical environment
    available in our Python setup? While we could certainly try the code to find out,
    this requirement gives us pause. After all, the pyperclip solution didn’t have
    that requirement, so we might not need it (whatever it happens to mean). Let’s
    try again.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们既有所得也有所失。所得是，这个 tkinter 模块是 Python 内置的。所失是，“该方法仅在存在图形环境时才有效。”在我们的 Python
    设置中是否有图形环境呢？虽然我们可以尝试代码来找出答案，但这个要求让我们犹豫。毕竟，pyperclip 解决方案没有这个要求，所以我们可能不需要它（无论它具体意味着什么）。让我们再试一次。
- en: LPHumanIs there another way I can do it without having to install a Python module?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman 还有没有其他方法可以在不安装 Python 模块的情况下完成这个操作？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, you can access the clipboard
    using the win32clipboard module, which is included in the standard library on
    Windows. Here’s an example program that allows you to copy and paste using the
    clipboard without installing any additional modules:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 是的，你可以使用包含在 Windows 标准库中的 win32clipboard
    模块来访问剪贴板。以下是一个示例程序，它允许你使用剪贴板复制和粘贴，而不需要安装任何额外的模块：'
- en: '[PRE8]`*[PRE9]`*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]`*[PRE9]`*'
- en: '*`*import win32clipboard*`*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import win32clipboard*`*'
- en: '*`*# Copy to clipboard*`*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Copy to clipboard*`*'
- en: '*`*text = "Hello, world!"*`*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*text = "Hello, world!"*`*'
- en: '*`*win32clipboard.OpenClipboard()*`*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.OpenClipboard()*`*'
- en: '*`*win32clipboard.EmptyClipboard()*`*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.EmptyClipboard()*`*'
- en: '*`*win32clipboard.SetClipboardText(text)*`*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.SetClipboardText(text)*`*'
- en: '*`*win32clipboard.CloseClipboard()*`*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.CloseClipboard()*`*'
- en: '*`*# Paste from clipboard*`*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Paste from clipboard*`*'
- en: '*`*win32clipboard.OpenClipboard()*`*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.OpenClipboard()*`*'
- en: '*`*pasted_text = win32clipboard.GetClipboardData()*`*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pasted_text = win32clipboard.GetClipboardData()*`*'
- en: '*`*win32clipboard.CloseClipboard()*`*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.CloseClipboard()*`*'
- en: '*`*print(pasted_text)*`*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(pasted_text)*`*'
- en: '*[PRE10]*[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE10]*[PRE11]'
- en: This program first imports the win32clipboard module. To copy text to the clipboard,
    you can call the `OpenClipboard()` function to open the clipboard, then call `EmptyClipboard()`
    to clear any existing data, and finally call `SetClipboardText()` to set the text
    on the clipboard. After setting the text, you should call `CloseClipboard()` to
    close the clipboard.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: To paste from the clipboard, you can call `OpenClipboard()` to open the clipboard,
    then call `GetClipboardData()` to get the text from the clipboard. After getting
    the text, you should call `CloseClipboard()` to close the clipboard. In this example,
    the program copies the text `"Hello,` `world!"` to the clipboard, then pastes
    it and prints it to the console.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: “Standard library on Windows,” eh? That’s concerning because it means that our
    tool might not work on other operating systems. Let’s see about that.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanDoes that work on Linux or macOS too?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot No, the win32clipboard module
    is specific to Windows and won’t work on Linux or macOS. On Linux, you can use
    the `xclip` command-line utility to access the clipboard. Here’s an example program
    that allows you to copy and paste using the clipboard on Linux:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]`*[PRE13]`*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import subprocess*`*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Copy to clipboard*`*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '*`*text = "Hello, world!"*`*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '*`*subprocess.run([''xclip'', ''-selection'', ''clipboard''], input=text.encode(''utf-8''))*`*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Paste from clipboard*`*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '*`*p = subprocess.Popen([''xclip'', ''-selection'', ''clipboard'', ''-o''],
    stdout=subprocess.PIPE)*`*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pasted_text = p.stdout.read().decode(''utf-8'')*`*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '*`*print(pasted_text)*`*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE14]*[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: This program uses the subprocess module to run the `xclip` command-line utility.
    To copy text to the clipboard, you can call `subprocess.run()` and pass in the
    `xclip` command with the `-selection` `clipboard` option to specify the clipboard
    selection, and the `input` parameter to pass in the text you want to copy. To
    paste from the clipboard, you can call `subprocess.Popen()` and pass in the `xclip`
    command with the `-selection` `clipboard` `-o` options to read the text from the
    clipboard, and then read the output of the command using the `stdout` attribute
    of the `Popen` object. In this example, the program copies the text `"Hello,`
    `world!"` to the clipboard, then pastes it and prints it to the console.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: On macOS, you can use the `pbcopy` and `pbpaste` command-line utilities to access
    the clipboard. The usage is similar to `xclip`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: We’ve gotten some solutions that are specific to different operating systems.
    We don’t like this! We want our tool to work no matter which operating system
    we’re using. (Even if we’re using only Windows ourselves, maybe one day, we’ll
    share this tool with others who use different operating systems.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: We could continue our conversation, but in retrospect, having to install that
    single pyperclip module doesn’t seem so bad. Let’s go ahead with it. In general,
    it can be valuable to explore your options when deciding how to start writing
    a tool, and conversing with Copilot is helpful for carrying out this exploration.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续我们的对话，但回顾起来，安装那个单一的pyperclip模块似乎并不那么糟糕。让我们继续吧。一般来说，在决定如何开始编写工具时探索你的选项是有价值的，与Copilot进行对话有助于进行这种探索。
- en: Why we should explore and understand our options
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为什么我们应该探索和理解我们的选项
- en: 'There are several reasons why you shouldn’t just use the first module that
    Copilot chat tells you to use:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因说明为什么你不应该仅仅使用Copilot聊天告诉你的第一个模块：
- en: It may not work on all operating systems. In general, we want to find modules
    that work across multiple operating systems so that the tool can be used by you
    (if you later switch operating systems) or others with whom you’ve shared the
    tool.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能不会在所有操作系统上工作。一般来说，我们想要找到可以在多个操作系统上工作的模块，这样工具就可以供你（如果你后来切换操作系统）或与你分享工具的其他人使用。
- en: It may turn out not to work for our use case after all, or we may struggle to
    get the code to work. If we have other options, we can start trying those before
    sinking too much time into a strategy that may or may not ultimately work out.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终可能发现它并不适用于我们的用例，或者我们可能难以让代码正常工作。如果我们有其他选择，我们可以在投入太多时间到一个可能或不可能最终成功的策略之前，先尝试那些其他选项。
- en: Modules are updated frequently. Usually this is to add new features and fix
    bugs, but sometimes, functions are removed or changed in this process as well.
    When the author of a module removes a function, it’s known as *deprecating that
    function**.* Once a function is deprecated,it may no longer work, and we need
    to find a replacement. Copilot is trained only every once in a while, not continuously,
    so if a new version of a module comes out after Copilot was trained on it, Copilot
    won’t know about the updates. This can lead to Copilot suggesting code that depends
    on an older version of the module than the one you have. There are ways to address
    this, as we’ll see later in the chapter. But if you run into trouble, having other
    options to explore is useful.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块经常更新。通常这是为了添加新功能并修复错误，但有时在这个过程中，功能也可能被移除或更改。当一个模块的作者移除一个功能时，这被称为*弃用该功能**。一旦一个功能被弃用，它可能就不再工作，我们需要找到一个替代方案。Copilot只是偶尔进行训练，而不是持续训练，所以如果Copilot在训练后该模块的新版本发布，Copilot将不会知道这些更新。这可能导致Copilot建议依赖于比你所拥有的模块旧版本的代码。我们将在本章后面看到解决这个问题的方法。但如果你遇到麻烦，有其他选项可供探索是有用的。
- en: 9.3.2 Writing the tool to clean up email
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 编写清理电子邮件的工具
- en: 'The first thing we need to do is to install the pyperclip module. How do we
    install it, though? The good news is that Python has made it easy to install new
    modules. Go to the Terminal at the bottom right of VS Code and type the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是安装pyperclip模块。那么我们该如何安装它呢？好消息是Python使得安装新模块变得很容易。前往VS Code右下角的终端，并输入以下命令：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note  For some operating systems, you may need to use `pip3` rather than `pip`.
    On Windows machines, we recommend using `pip` if you followed our installation
    instructions from chapter 2\. On Mac or Linux machines, we recommend using `pip3`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于某些操作系统，你可能需要使用`pip3`而不是`pip`。在Windows机器上，如果你遵循了第2章中的安装说明，我们建议使用`pip`。在Mac或Linux机器上，我们建议使用`pip3`。
- en: 'When you run this command, you might see that other modules get installed too.
    Don’t worry about that: sometimes modules need other modules to be able to do
    their work, and Python just installs them all so that you don’t have to worry
    about installing those dependencies yourself.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个命令时，你可能会看到还安装了其他模块。不用担心这个问题：有时模块需要其他模块来执行它们的工作，Python会自动安装所有这些模块，这样你就不必担心自己安装这些依赖项了。
- en: Once that’s installed, we can import the module and then write the header and
    docstring for our function that will remove the > and space characters from the
    start of lines. The reason we’re importing the module here is to influence Copilot
    to use that module when writing the code for the function. Here’s the prompt we
    used and the code that Copilot gave us.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以导入该模块，然后为我们的函数编写头和文档字符串，该函数将从行首删除>和空格字符。我们在这里导入模块的原因是影响Copilot在编写函数代码时使用该模块。以下是我们的提示和Copilot给出的代码。
- en: 'Listing 9.1 First try: Clean up email text in the clipboard'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1 第一次尝试：清理剪贴板中的电子邮件文本
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#1 Puts the current contents of the clipboard into the text string'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将剪贴板当前内容放入文本字符串'
- en: '#2 Splits the string into a list of its lines'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将字符串拆分为其行列表'
- en: '#3 Loops through each line'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 遍历每一行'
- en: '#4 Removes spaces and &gt; symbols from the start of the line'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 从行的开头移除空格和 &gt; 符号'
- en: '#5 This looks odd.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 这看起来有点奇怪。'
- en: '#6 Copies the cleaned-up text to the clipboard'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 将清理后的文本复制到剪贴板'
- en: '#7 Note a common Python convention (see the following discussion).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 注意一个常见的 Python 习惯（见以下讨论）。'
- en: '#8 Calls our function to automatically clean up the clipboard!'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 调用我们的函数来自动清理剪贴板！'
- en: 'We can see that the program is carrying out the correct sequence of steps:
    it’s obtaining the clipboard contents, cleaning up that text, and then copying
    the cleaned-up text back to the clipboard. As we learned from our earlier chat
    with Copilot, we want Copilot to write code that uses the `paste` and `copy` functions
    of `pyperclip`, and that’s exactly what it’s doing. The second-to-last line of
    the program is something we haven’t seen before in this book:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到程序正在执行正确的步骤序列：它正在获取剪贴板内容，清理文本，然后将清理后的文本复制回剪贴板。正如我们从与 Copilot 的早期聊天中学到的，我们希望
    Copilot 编写使用 `pyperclip` 的 `paste` 和 `copy` 函数的代码，这正是它所做的事情。程序倒数第二行是我们在这本书中之前没有见过的：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can actually remove this line if you like (and if you do, also unindent
    the line below it). It ensures that the `clean_email` function is only called
    when you run your program, not when you import it as a module. After all, if you
    did want to import this as a module (to be used as part of a larger program),
    you would call `clean_email` whenever you needed that functionality, not necessarily
    as soon as the module was imported. (And, in general, whenever you’re interested
    in understanding a line of code more fully, you can ask Copilot about it!) Unfortunately,
    this code doesn’t work. If you run it, you’ll receive this error:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果你喜欢，可以删除这一行（如果你这样做，也要取消下一行的缩进）。这确保了 `clean_email` 函数只有在运行你的程序时才会被调用，而不是在将其作为模块导入时。毕竟，如果你确实想将其作为模块导入（作为更大程序的一部分使用），你会在需要该功能时调用
    `clean_email`，而不一定是模块导入时。 （而且，一般来说，每当你想更全面地理解一行代码时，你都可以询问 Copilot！）不幸的是，这段代码不起作用。如果你运行它，你会收到以下错误：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The syntax error means that we have a program that isn’t written in valid Python
    code. We’re going to fix this now! We have a couple of options for how to do so.
    One is to highlight your code and ask Copilot Chat to fix the bug. For us, this
    did fix the problem. You could also try asking ChatGPT in conversation: “Propose
    a fix for the bugs in my code <insert your code>.” This is a useful tip to keep
    in mind whenever the code that you get back from Copilot doesn’t work as expected.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误意味着我们有一个没有用有效 Python 代码编写的程序。我们现在将修复它！我们有几个选项可以这样做。一个是突出显示你的代码，并要求 Copilot
    Chat 修复错误。对我们来说，这确实解决了问题。你也可以尝试在与 ChatGPT 的对话中提出：“为我的代码中的错误提出修复建议 <插入你的代码>。” 这是一个有用的提示，当你从
    Copilot 得到的代码没有按预期工作时要记住！
- en: Copilot fixed the code for us by fixing the line with the syntax error. The
    new code is shown in the following listing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 通过修复有语法错误的行为我们修复了代码。新的代码如下所示。
- en: 'Listing 9.2 Second try: Clean up email text in the clipboard'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2 第二次尝试：清理剪贴板中的电子邮件文本
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#1 Joins the individual lines back into one string'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将单独的行重新组合成一个字符串'
- en: The new line of code, changed from the odd line of code that we had previously,
    is
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码行，与之前奇怪的一行代码不同，是
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The goal of this line is to join all the lines of text together into a single
    string that the program will later copy to the clipboard. What does that `\n`
    mean? That represents the start of a newline in code. What is the `join` method?
    It takes all the items in a list (lines) and joins them together into a single
    string.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这行的目的是将所有文本行连接成一个单独的字符串，程序稍后会将其复制到剪贴板。那个 `\n` 代表什么？它代表代码中换行的开始。`join` 方法是什么？它接受列表（行）中的所有项并将它们连接成一个单独的字符串。
- en: 'We can understand how this works in more detail by experimenting a little with
    `join`. Here’s an example of using `join` with an empty string rather than the
    `''\n''` string:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过稍微实验 `join` 来更详细地理解它是如何工作的。这里是一个使用空字符串而不是 `'\n'` 字符串的 `join` 示例：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 Shows the list of three lines'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 显示三行的列表'
- en: '#2 Calls join on the empty string'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 在空字符串上调用 join 方法'
- en: 'Notice that some of the words are squished together. That’s not exactly what
    we want—we need something between them. How about a space? Let’s try using `join`
    again, this time with a space in the string rather than the empty string:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有些单词挤在一起。这并不是我们想要的--我们需要在它们之间留点空间。怎么样，让我们再次尝试使用`join`，这次在字符串中使用空格而不是空字符串：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Or, we could use `''*''`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用`'*'`：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That fixes our squished words. And, the `*s` tells us where each line ends,
    but it would be nicer to actually maintain the fact that the email is three lines.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就解决了我们的单词挤压问题。而且，`*s`告诉我们每行在哪里结束，但最好实际上保持电子邮件是三行的事实。
- en: 'We need a way in Python to use a line break or newline character, rather than
    a space or `*`. We can’t just press Enter because that would split the string
    over two lines and that isn’t valid Python syntax. The way to do it is by using
    `''\n''`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们需要一种方法来使用换行符或换行符字符，而不是空格或`*`。我们不能只是按Enter键，因为这会将字符串分成两行，这不是有效的Python语法。要做到这一点，我们可以使用`'\n'`：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now our tool is ready to be used. If you copy some messy email text to your
    clipboard, run our program, and paste the clipboard, you’ll see that the email
    has been cleaned up. For example, if we run it on our previous sample email, we
    get the following cleaned-up version:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的工具已经准备好使用了。如果你将一些杂乱的电子邮件文本复制到剪贴板，运行我们的程序，然后粘贴剪贴板，你会看到电子邮件已经被清理。例如，如果我们对之前的样本电子邮件运行它，我们会得到以下清理后的版本：
- en: Hi Leo,
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，利奥，
- en: Dan -- any luck with your natural language research?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 丹--你在自然语言研究方面有什么进展吗？
- en: Yes! That website you showed me
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！你给我看的那个网站
- en: '[https://www.kaggle.com/](https://www.kaggle.com/)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.kaggle.com/](https://www.kaggle.com/)'
- en: is very useful. I found a dataset on there that collects
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 非常有用。我在那里找到一个数据集，它收集了
- en: a lot
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 很多
- en: of questions and answers that might be useful to my research.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 可能对我的研究有用的问答。
- en: Thank you,
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢，
- en: Dan
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 丹
- en: Of course, we could still do more. The line breaks in that email aren’t great
    (the line “a lot” is extremely and needlessly short), and you might want to clean
    that up as well. You could begin to make these kinds of improvements by adding
    new requirements to your prompts to Copilot. We’ll stop here because we’ve accomplished
    our initial goal of email cleanup, but we encourage you to continue exploring
    more robust solutions on your own.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还可以做更多。那封电子邮件中的换行符不太好（“很多”这一行非常短且没有必要），你可能还想清理一下。你可以通过向Copilot的提示中添加新要求来开始进行这些改进。我们在这里停下来，因为我们已经完成了电子邮件清理的初步目标，但我们鼓励你继续独立探索更稳健的解决方案。
- en: '9.4 Example 2: Adding cover pages to PDF files'
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 示例2：向PDF文件添加封面页
- en: Let’s return to the scenario from the start of the chapter. We have written
    100 reports that are in .pdf format. Our colleague has designed 100 covers for
    those reports that are also in .pdf format, and we need to merge the covers with
    the reports so that each finalized .pdf file starts with the cover and continues
    with the report. Figure 9.1 provides an illustration of the desired process.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到本章开头的场景。我们已经编写了100份报告，这些报告都是.pdf格式的。我们的同事为这些报告设计了100个封面，这些封面也是.pdf格式的，我们需要将封面与报告合并，以便每个最终生成的.pdf文件从封面开始，然后继续是报告。图9.1展示了所需的过程。
- en: '![figure](../Images/9-1.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-1.png)'
- en: Figure 9.1 Illustration of the desired process of creating combined .pdfs by
    merging the report cover in the cover directory with the report in the report’s
    directory. Note that the reports may be more than one page.
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1 创建合并.pdf文件所需过程的示意图，通过将封面目录中的报告封面与报告目录中的报告合并。注意，报告可能有多页。
- en: PDF files (and Microsoft Word and Excel files) aren’t text files
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: PDF文件（以及Microsoft Word和Excel文件）不是文本文件
- en: You might wonder why we can’t simply use Python methods such as `read` and `write`
    to manipulate .pdf files. After all, that’s just what we did when working with
    .csv files in chapter 2.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们不能简单地使用Python的`read`和`write`方法来操作.pdf文件。毕竟，我们在第2章处理.csv文件时就是这样做的。
- en: 'The big difference is that .csv files are text files, which are files readable
    by humans with no formatting or special commands. However, many other file formats
    aren’t text files. A .pdf file, for example, isn’t human-readable and needs to
    be processed by code that is aware of the .pdf format. This is true of Microsoft
    Word files and Microsoft Excel files as well: they’re not text files, so we need
    specialized tools to work with them.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'In the resources for this book, in the ch9 folder, you’ll find two subfolders:
    the reports subfolder contains 100 reports as .pdf files, and the covers subfolder
    contains 100 covers as .pdf files, one for each report. The reports are named
    1.pdf, 2.pdf, 3.pdf, and so on; the respective covers are named cover1.pdf, cover2.pdf,
    cover3.pdf, and so on. We’ll merge these reports and covers together in this section.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Open some of the cover .pdf files and some of the report .pdf files. You can
    do that using a program such as Adobe Acrobat or however you typically open .pdf
    files on your computer. You’ll notice that the covers are always exactly one page,
    but the reports can be more than one page. When we get to the code, we should
    take care to tell Copilot that reports can be more than one page; otherwise, Copilot
    might write code assuming that the reports, like the covers, are only one page.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering how we created these 100 covers and reports. You’d be
    disappointed if we made them manually, one at a time, right? Don’t worry. We automated
    that creation process in much the same way we’ll automate the merging process
    next.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 9.4.1 Conversing with Copilot
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need our tool to find all reports and covers, add the cover to the front
    of each report, and produce a finalized .pdf for each report that contains both
    the cover page and report pages. How do we merge .pdf files using Python? Let’s
    find out.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanI need to write a **Python program that merges .pdf files. How do I do
    this?**
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the PyPDF2 library
    to merge PDF files in Python. Here is an example code snippet that shows how to
    merge two PDF files:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]`*[PRE27]`*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import PyPDF2*`*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Open the PDF files to be merged*`*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf1 = open(''file1.pdf'', ''rb'')*`*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf2 = open(''file2.pdf'', ''rb'')*`*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Create a PDF reader object for each file*`*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '*`*reader1 = PyPDF2.PdfFileReader(pdf1)*`*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '*`*reader2 = PyPDF2.PdfFileReader(pdf2)*`*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Create a PDF writer object*`*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '*`*writer = PyPDF2.PdfFileWriter()*`*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Loop through the pages of each PDF and add them to the writer object*`*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '*`*for i in range(reader1.getNumPages()):*`*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '*`*page = reader1.getPage(i)*`*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '*`*writer.addPage(page)*`*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '*`*for i in range(reader2.getNumPages()):*`*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '*`*page = reader2.getPage(i)*`*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '*`*writer.addPage(page)*`*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Write the merged PDF to a file*`*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '*`*output = open(''merged.pdf'', ''wb'')*`*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '*`*writer.write(output)*`*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Close the input and output files*`*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf1.close()*`*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf2.close()*`*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '*`*output.close()*`*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE28]*[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we first open the two PDF files to be merged using the `open()`
    function. We then create a PDF reader object for each file using the `PdfFileReader()`
    function from PyPDF2.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a PDF writer object using the `PdfFileWriter()` function. We
    then loop through the pages of each PDF file using the `getNumPages()` and `getPage()`
    methods of the reader objects and add each page to the writer object using the
    `addPage()` method.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we write the merged PDF to a file using the `write()` method of the
    writer object and close all the input and output files using the `close()` method.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: We have a lead! This PyPDF2 module seems to do what we need. It looks like it
    gives us `PdfFileReader` to read an existing .pdf file and `PdfFileWriter` to
    create a new .pdf file. We see the code using `getPage` to get a page from an
    existing .pdf file and `addPage` to write it to the new .pdf file—very promising.
    Is there something built-in to Python that we could use, so that we don’t have
    to worry about installing PyPDF2?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanIs there a way I can do it without having to install a Python module?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, you can use the subprocess
    module to call a command-line tool like `pdftk` to merge PDF files. Here is an
    example code snippet that shows how to merge two PDF files using `pdftk`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]`*[PRE31]`*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import subprocess*`*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Call pdftk to merge the PDF files*`*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '*`*subprocess.call([''pdftk'', ''file1.pdf'', ''file2.pdf'',*`*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '*`*''cat'', ''output'', ''merged.pdf''])*`*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE32]*[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use the `subprocess.call()` function to call `pdftk` with
    the appropriate arguments to merge the two PDF files `file1.pdf` and `file2.pdf`.
    The `cat` argument tells `pdftk` to concatenate the input files, and the `output`
    argument specifies the output file name as `merged.pdf`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you will need to have `pdftk` installed on your system for this code
    to work. If you don’t have `pdftk` installed, you can download it from the official
    website: [https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/](https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: This approach may ultimately end up being valuable, but it’s not exactly a built-in
    solution. After all, the final paragraph talks about us having to install some
    new software called `pdftk`!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’d probably go with the first option of using PyPDF2\. But
    let’s press forward once more with Copilot to make sure we don’t miss any good
    options.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanAre there other Python .pdf libraries that I should consider?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, there are several other
    Python libraries that you can use to work with PDF files. Here are some popular
    ones:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: ReportLab—a library for creating PDF documents from scratch, with support for
    text, graphics, and images.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FPDF—a library for creating PDF documents from scratch, with support for text,
    graphics, and images.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PDFMiner—a library for extracting text and metadata from PDF files.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PyMuPDF—a library for working with PDF files, with support for text, graphics,
    and images.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyMuPDF——一个用于处理PDF文件的库，支持文本、图形和图像。
- en: pdfrw—a library for reading and writing PDF files, with support for text, graphics,
    and images.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: pdfrw——一个用于读取和写入PDF文件的库，支持文本、图形和图像。
- en: Each library has its own strengths and weaknesses, so you should choose the
    one that best fits your needs. If you only need to merge PDF files, then PyPDF2
    or pdftk may be sufficient. However, if you need to create or manipulate PDF files
    in more complex ways, then one of the other libraries may be a better choice.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每个库都有其自身的优缺点，因此您应该选择最适合您需求的库。如果您只需要合并PDF文件，那么PyPDF2或pdftk可能就足够了。然而，如果您需要以更复杂的方式创建或操作PDF文件，那么其他库可能是一个更好的选择。
- en: The last paragraph tells us that we’re probably in good shape using PyPDF2 if
    all we need to do is merge .pdf files. But let’s finish our conversation here
    by understanding the pros and cons of all of these tools. That way, if we get
    stuck with PyPDF2, we know where to turn to next.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段告诉我们，如果我们只需要合并.pdf文件，那么使用PyPDF2可能就足够了。但让我们通过了解所有这些工具的优缺点来结束我们的对话。这样，如果我们遇到PyPDF2的问题，我们就知道下一步该怎么做。
- en: LPHumanCan you summarize the **strengths and weaknesses of these libraries?**
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman您可以总结一下这些库的优缺点吗？
- en: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot Certainly! Here is a summary
    of the strengths and weaknesses of the libraries I mentioned:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot** 毫无疑问！以下是关于我提到的库的优缺点的总结：'
- en: PyPDF2—a library for working with PDF files, with support for text, graphics,
    and images.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: PyPDF2——一个用于处理PDF文件的库，支持文本、图形和图像。
- en: 'Strengths:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Easy to use for simple tasks like merging PDF files.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于简单任务（如合并PDF文件）来说易于使用。
- en: Good documentation and examples available.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: Supports a wide range of PDF features.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: 'Weaknesses:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Limited support for advanced PDF features like forms and annotations.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对高级PDF功能（如表单和注释）的支持有限。
- en: Can be slow for large PDF files.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大型PDF文件可能运行缓慢。
- en: ReportLab—a library for creating PDF documents from scratch, with support for
    text, graphics, and images.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ReportLab——一个用于从头创建PDF文档的库，支持文本、图形和图像。
- en: 'Strengths:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Very powerful and flexible for creating complex PDF documents.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建复杂的PDF文档非常强大和灵活。
- en: Supports a wide range of PDF features.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: Good documentation and examples available.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: 'Weaknesses:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Steep learning curve for beginners.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于初学者来说，学习曲线陡峭。
- en: Can be slow for large PDF files.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大型PDF文件可能运行缓慢。
- en: FPDF—a library for creating PDF documents from scratch, with support for text,
    graphics, and images.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: FPDF——一个用于从头创建PDF文档的库，支持文本、图形和图像。
- en: 'Strengths:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Lightweight and easy to use.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轻量级且易于使用。
- en: Good documentation and examples available.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: Supports a wide range of PDF features.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: 'Weaknesses:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Limited support for advanced PDF features like forms and annotations.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对高级PDF功能（如表单和注释）的支持有限。
- en: Can be slow for large PDF files.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大型PDF文件可能运行缓慢。
- en: PDFMiner—a library for extracting text and metadata from PDF files.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: PDFMiner——一个用于从PDF文件中提取文本和元数据的库。
- en: 'Strengths:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Very powerful and flexible for extracting text and metadata from PDF files.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从PDF文件中提取文本和元数据非常强大和灵活。
- en: Supports a wide range of PDF features.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: Good documentation and examples available.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: 'Weaknesses:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Steep learning curve for beginners.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于初学者来说，学习曲线陡峭。
- en: Limited support for creating or manipulating PDF files.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或操作PDF文件的支持有限。
- en: PyMuPDF—a library for working with PDF files, with support for text, graphics,
    and images.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: PyMuPDF——一个用于处理PDF文件的库，支持文本、图形和图像。
- en: 'Strengths:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Very fast and efficient for working with PDF files.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理PDF文件非常快速和高效。
- en: Supports a wide range of PDF features.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: Good documentation and examples available.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: 'Weaknesses:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Steep learning curve for beginners.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于初学者来说，学习曲线陡峭。
- en: Limited support for creating or manipulating PDF files.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或操作PDF文件的支持有限。
- en: pdfrw—a library for reading and writing PDF files, with support for text, graphics,
    and images.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: pdfrw——一个用于读取和写入PDF文件的库，支持文本、图形和图像。
- en: 'Strengths:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Very powerful and flexible for reading and writing PDF files.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取和写入PDF文件非常强大和灵活。
- en: Supports a wide range of PDF features.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: Good documentation and examples available.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: 'Weaknesses:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Steep learning curve for beginners.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于初学者来说学习曲线陡峭。
- en: Can be slow for large PDF files.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于大型 PDF 文件可能运行缓慢。
- en: Don’t be too intimidated by the “Steep learning curve for beginners” cautions
    in there. If Copilot has been trained on the library, then you may still be successful.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被“对于初学者来说学习曲线陡峭”的警告吓倒。如果 Copilot 在该库上进行了训练，那么你仍然可能成功。
- en: Based on what we’ve learned here, we might eliminate PDFMiner because it apparently
    has “limited support for creating or manipulating PDF files,” but we’d keep all
    others in contention just in case we need them. For now, we’re going to proceed
    with PyPDF2 and see how it goes.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在这里学到的知识，我们可能会消除 PDFMiner，因为它显然对创建或操作 PDF 文件的支持“有限”，但我们仍会保留所有其他选项，以防万一我们需要它们。目前，我们将继续使用
    PyPDF2 并看看效果如何。
- en: 9.4.2 Writing the tool
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 编写工具
- en: 'Go ahead and install the PyPDF2 module. Be careful with the capitalization:
    the module is called exactly PyPDF2, not pypdf2, pyPDF2, or any other capitalization.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 前往安装 PyPDF2 模块。注意大小写：模块名为 PyPDF2，而不是 pypdf2、pyPDF2 或任何其他大小写形式。
- en: 'In our previous example, we wrote a function to clean up an email that was
    on the clipboard. We didn’t need to pass any information to that function, so
    the function had no parameters. Here, our function will need three parameters:
    the name of the directory with the reports, the name of the directory with the
    covers, and the name of the directory where we want to write our finalized (merged)
    .pdf files.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们编写了一个用于清理剪贴板上的电子邮件的函数。我们不需要向该函数传递任何信息，因此该函数没有参数。在这里，我们的函数将需要三个参数：包含报告的目录名称、包含封面的目录名称以及我们想要写入最终（合并）.pdf
    文件的目录名称。
- en: In our docstring, we need to explain what each of these directories is for and
    also the pattern of the filenames in the directories. After all, Copilot will
    need to know how the reports match up with the cover pages.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文档字符串中，我们需要解释每个目录的作用，以及目录中文件名的模式。毕竟，Copilot 需要知道报告是如何与封面页匹配的。
- en: Trying PyPDF2
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 尝试 PyPDF2
- en: We’re going to use the PyPDF2 Python library to try to get the job done. Look
    back to what Copilot Chat told us about the PyPDF2 library. The sample code it
    gave us used `PdfFileReader` to read existing .pdf files and `PdfFileWriter` to
    create a new .pdf file. It also used `getPage` and `addPage` to manipulate pages.
    Look out for these in the code that Copilot produces—they’re telltale signs that
    Copilot is generating code that’s on the right track. Here’s the prompt that we
    used and the code that Copilot gave us.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 PyPDF2 Python 库来尝试完成这项工作。回顾 Copilot Chat 告诉我们的关于 PyPDF2 库的信息。它给出的示例代码使用了
    `PdfFileReader` 来读取现有的 .pdf 文件，并使用 `PdfFileWriter` 来创建新的 .pdf 文件。它还使用了 `getPage`
    和 `addPage` 来操作页面。注意 Copilot 生成的代码中的这些内容——它们是 Copilot 正在生成正确代码的明显迹象。以下是我们的提示和
    Copilot 给出的代码。
- en: Listing 9.3 Function to add covers to .pdf documents
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3 添加封面到 .pdf 文档的函数
- en: '[PRE34]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '#1 Gets list of the .pdf reports'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 获取 .pdf 报告的列表'
- en: '#2 Loops through the .pdf reports'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 遍历 .pdf 报告'
- en: '#3 We can use report_reader to read the pages of the report.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 我们可以使用 report_reader 来读取报告的页面。'
- en: '#4 We can use report_writer to write pages into a new .pdf file'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 我们可以使用 report_writer 将页面写入新的 .pdf 文件'
- en: '#5 Loops through each page of the report'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 遍历报告的每一页'
- en: '#6 Adds the page to our new .pdf file'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 将页面添加到我们新的 .pdf 文件中'
- en: '#7 Opens the cover associated with this report'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 打开与该报告关联的封面'
- en: '#8 We can use cover_reader to read the cover.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 我们可以使用 cover_reader 来读取封面。'
- en: '#9 Adds the cover to the start of our new .pdf file'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '#9 将封面添加到我们新的 .pdf 文件的开头'
- en: '#10 Saves our new .pdf file'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '#10 保存我们新的 .pdf 文件'
- en: '#11 Calls our function to do all the merging!'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '#11 调用我们的函数来完成所有合并操作！'
- en: Be careful with automation programs
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意自动化程序
- en: Programs like the one we’ve written to merge .pdf files can rip through hundreds
    or thousands of files very quickly. If they aren’t operating correctly, they can
    easily result in damaged or lost files. Any time we use `open` with `'w'` or `'wb'`
    as the second parameter, it means that we’re overwriting a file.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的用于合并 .pdf 文件的程序可以非常快速地处理数百或数千个文件。如果它们操作不正确，它们很容易导致文件损坏或丢失。每次我们使用 `open`
    并将 `'w'` 或 `'wb'` 作为第二个参数时，这意味着我们正在覆盖一个文件。
- en: 'Let’s focus on this line from our program in listing 9.3:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注列表 9.3 中的这一行：
- en: '[PRE35]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It’s using the `open` function to open a file. Specifically, it’s opening the
    current `report_file` file in the `final_dir` directory. The second argument to
    `open` here, `'wb'`, means that we want to open the file so we can write to it
    (that’s the `'w'`) and that the file we’re writing is a binary file (that’s the
    `'b'`), not a text file. If the file doesn’t already exist, then the `'w'` we’ve
    included will result in the file being created. That’s not the dangerous part.
    The dangerous part is what happens when the file already exists. In that case,
    `'w'` wipes out its contents and gives us an empty file that we can start writing
    to. Now, if our program is working correctly and only doing this in our `final_dir`,
    then we’re OK. But this is what we need to carefully verify before letting our
    program loose.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'We highly recommend that you first test on a small directory of files that
    you don’t care about. Further, we recommend changing lines of code that open files
    using `''w''` or `''wb''` to print a harmless output message instead, so that
    you can see exactly which files are going to be overwritten or created. For example,
    in our program here, we need to comment out these two lines:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Instead, we’ll use `print` to print out the file that we would have created
    or overwritten:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Then, when you run your program, you’ll see the names of files that the program
    *intended* to write. If the output looks good—that is, the program is operating
    exactly on the files that you wanted it to operate on—then you can uncomment the
    code that actually does the work.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Exercise caution, and *always* keep backups of your important files!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: The last line of the program in listing 9.3 makes the assumption that the directory
    of reports is called `reports`, the directory of cover pages is called `covers`,
    and the directory where the final .pdf files should go is called `final`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Now, create the `final` directory. It should be there along with your `reports`
    and `covers` directories.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall structure of the code looks promising to us: it’s getting a list
    of the .pdf reports, and then, for each one, it’s merging those pages with the
    cover page. It’s using a `for` loop to loop through the pages of the report, which
    is good because it can grab all the pages that way. By contrast, it’s *not* using
    a `for` loop on the cover .pdf file, which again is good because we know that
    the cover has only one page anyway.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the first line of code it gave us looks like it’s using a function
    called `listdir` in a module called os. There are other lines that use this module
    as well. Do we need to be importing that os module? Indeed, we do! And we can
    prove it by running the code. If you run the code, you’ll get an error:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We need to add `import os` at the start of our program to fix this. The updated
    code is in the following listing.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.4 Improved function to add covers to .pdf documents
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '#1 We were missing this import before.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re not out of the woods yet, though. Our updated program still doesn’t work.
    Here’s the error we get when we run our program:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '#1 The line in our code that’s causing an error'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '#2 We can’t use PdfFileReader anymore—it’s gone!'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve run into the problem where Copilot thinks, “Hey, let’s use `PdfFileReader`,
    since I’ve been trained that this is part of PyPDF2,” but between Copilot being
    trained and the time of our writing, the PyPDF2 maintainers have removed `PdfFileReader`
    and replaced it with something else (`PdfReader`, according to the final line
    of the error message). This discrepancy may very well be fixed for you by the
    time you read this book, but we want to pretend it’s still messed up so that we
    can teach you what to do if this does happen to you in the future. At this point,
    we have three options:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '*Install an earlier version of PyPDF2.* The last two lines of the error message
    tell us that `PdfFileReader`, the function we need from PyPDF2, was removed in
    PyPDF2 3.0.0\. As a result, if we install a version of PyPDF2 earlier than 3.0.0,
    we should have our function back. In general, installing earlier versions of libraries
    isn’t advisable because security concerns may be present in those versions that
    have since been fixed in more recent versions. In addition, there may be bugs
    present in the older versions that have since been fixed. It’s worth googling
    what has been changed in the library recently to determine whether using an older
    version is safe. In this case, we have done that homework and see no obvious risk
    in using an older version of PyPDF2\.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fix the code ourselves using the suggestion in the error message.* That is,
    we would replace `PdfFileReader` with `PdfReader` and run the program again. In
    this case, we would be told about other deprecations, and we’d need to fix those
    following the same process. It’s very nice of the authors of PyPDF2 to tell us
    what to do inside the error messages. For practice, you might like to work through
    this, making each update suggested by the error message. We wish all error messages
    were so useful, but this won’t always be the case. Sometimes, a function will
    be removed without giving us any recourse. In that case, it may be easier to consider
    our next option.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Use a different library.* Earlier, we asked Copilot for other possible .pdf
    Python libraries we could use, and we received many suggestions. If the first
    two of our options here aren’t satisfactory, we could jump to trying one of those.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’re going to illustrate how to solve the problem and get our code running
    with the first option (using an earlier version of PyPDF2) and the third option
    (using a different library entirely).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Using an earlier version of PyPDF2
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When using `pip install` to install a Python library, by default, we get the
    most current version of the library. That’s usually what we want—the latest and
    greatest—but it’s also possible to explicitly request an older version of the
    library.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Here, we need a version of PyPDF2 prior to version 3.0.0\. Rather than the standard
    usage of pip,
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: we can instead use
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `< 3.0.0` is what we use to ask for the most recent version of the library
    that’s less than version 3.0.0\. The command should result in output like the
    following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '#1 We had an existing version that is &gt;= 3.0.0.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '#2 That version is being removed . . .'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '#3 . . . and version 2.12.1 is being installed.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have an older version of PyPDF2 installed. At this point, you should
    be able to run our program. It’ll take a few seconds, and then the job will be
    done. You can check your final directory for the newly created .pdf files. Open
    a few of them to make sure that our program has done the right thing: each .pdf
    file should start with a cover page and contain all the pages of the report (not
    just the first page if the report has multiple pages).'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Think of how tedious this would have been by hand, and we’ve gotten the computer
    to do it for us. Moreover, the next time we have to do the same thing at work
    (more reports for more people), we’ve got a tool all set to help us get it done
    quickly.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Using a different .pdf library
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s try solving our problem with PyPDF2 by using another library—one of
    those that Copilot told us about in our initial conversation about .pdf libraries.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'We won’t go through all the gory details with you on how we decided which library
    to try next, but we’ll walk through the highlights of our journey. We started
    by asking Copilot Chat how we can use the ReportLab Python module to merge .pdf
    files, but that redirected us back to using PyPDF2\. We received the same response
    for FPDF: we were told that FPDF can’t merge .pdf files but that PyPDF2 can. We
    then moved on to asking about PyMuPDF, and this part of the conversation was productive:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanHow can I use the Python PyMuPDF library to merge .pdf files?
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the fitz module
    from the PyMuPDF library to merge PDF files. Here’s an example code snippet that
    shows how to merge two PDF files using PyMuPDF:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]`*[PRE45]`*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import fitz*`*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Merge the two PDF files*`*'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf_files = [''file1.pdf'', ''file2.pdf'']*`*'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf_writer = fitz.Document()*`*'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '*`*for pdf_file in pdf_files:*`*'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf_reader = fitz.open(pdf_file)*`*'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '*`*for page in pdf_reader:*`*'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf_writer.insert_pdf(page)*`*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf_writer.save(''merged.pdf'')*`*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf_writer.close()*`*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE46]*[PRE47]'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: This code first creates a list of PDF files to merge (`file1.pdf` and `file2.pdf`).
    It then creates a new `Document` object using `fitz`, which represents the merged
    PDF. It loops through each PDF file in the list, opens it using `fitz`, and inserts
    each page of the PDF file into the `pdf_writer` object using the `insert_pdf()`
    method. Finally, it saves the merged PDF to a new file called `merged.pdf` using
    the `save()` method.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: You can modify this code to add any additional content to the merged PDF using
    PyMuPDF. Just create a new `Page` object, add the content to the page, and insert
    the page into the `pdf_writer` object using the `insert_page()` method.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: The sample code here is using `insert_pdf` to add each .pdf file to the merged
    .pdf file. We should be on the lookout for our code using `insert_pdf` as well.
    The library is called PyMuPDF, so we need to install it with
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: But then we have to use `import fitz`? Why `import fitz` and not `import PyMuPDF`?
    Apparently, the designers of this library liked fitz more than PyMuPDF, so we’ll
    need to go with it. It’s rare indeed, but occasionally we use one name to install
    the library and another to import it!
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: If you encounter NameError when you import
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If Python gives you a `NameError` referring to the library that you’re trying
    to import, it’s a good bet that you haven’t successfully imported that library.
    It could be that the library isn’t in fact installed, or that you need to use
    a different name to import it. Use Copilot Chat to have a conversation if you
    ever find that you’ve installed a library but can’t seem to import it.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready to generate some code. The following listing shows the prompt
    that we used and the code that Copilot gave us.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.5 Improved function to add covers to .pdf documents
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '#1 If the final_dir directory doesn’t exist, . . .'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '#2 . . . create the final_dir directory.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Loops through the .pdf reports'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Used to read the cover'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Used to read the report'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Used as our new output file'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Adds the cover to our new .pdf file'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Adds the report to our new .pdf file'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '#9 Saves our new .pdf file'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: This program happens to start with some code that creates the output directory
    if it doesn’t already exist. After that, the steps are similar to those in our
    earlier program that used PyPDF2, although the functions called by each program
    are different. (That makes sense because PyPDF2 and PyMuPDF are different libraries,
    with different features and functions.) In both cases, we’re using `listdir` to
    get a list of the report .pdf filenames. In the `for` loop, we go through each
    of those reports; the code in the loop is responsible for creating a new .pdf
    file that contains the cover followed by the report. In our PyPDF2 code, there
    was an inner `for` loop that we needed to loop through all the pages of the report.
    In our current program, we don’t need that because Copilot used the `insert_pdf`
    function, which inserts a .pdf file into another .pdf file in one shot (not page
    by page). Whether you took the approach of installing the older library or you
    chose to use a different library, we’ve solved our problem and automated what
    would have been an unpleasantly tedious task.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’ve slightly altered the workflow that we described in the previous
    chapter to take into account handling the different Python modules that could
    aid you with your task. A modified workflow is provided in figure 9.2.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/9-2.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 Additions to our workflow to account for working with different Python
    modules
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '9.5 Example 3: Merging phone picture libraries'
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now suppose that you take a lot of pictures on your phone. Your partner (or
    sibling, parent, or child) also takes a lot of pictures on their phone. You each
    have hundreds or thousands of pictures! Sometimes you send pictures to your partner,
    and they send pictures to you, so that you and your partner have some but not
    all of each other’s pictures.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: You live life like this for a while, but honestly, it’s becoming a mess. Half
    the time when you want a picture, you can’t find it because it’s a picture that
    your partner took on their phone that they didn’t send you. And, you’re starting
    to have many duplicate pictures all over the place.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'You then have an idea: “What if we take all the pictures from my phone and
    all the pictures from your phone, and we create a combined library of all the
    pictures! Then we’ll have all the pictures in one place!” Remember that both of
    your phones may have hundreds of pictures, so doing this manually is out of the
    question. We’re going to automate this!'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: To specify our task more precisely, we’ll say that we have two directories of
    pictures (think of each directory as the contents of a phone) that we want to
    combine into a new directory. A common file format for pictures is a .png file,
    so we’ll work with those files here. Your actual phone might use .jpg files rather
    than .png files, but don’t worry. You can adapt what we do here to that picture
    file format (or any other picture file format) if you like.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: In the resources for this book, in the ch9 directory, you’ll find two subdirectories
    of picture files. These subdirectories are named pictures1 and pictures2\. You
    can imagine that pictures1 has the pictures from your phone (98 pictures) and
    pictures2 has the pictures from your partner’s phone (112 pictures). We’re going
    to combine these two phone directories into a new directory.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Open some of the .png files in the same way that you open pictures or photos
    on your computer. The pictures we’ve generated are just some random shapes, but
    the program we write here will work no matter what’s inside the pictures.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: At the outset, we said that the same picture might be on both phones, so we’ve
    generated some duplicate files in our pictures. (We have a total of 210 picture
    files, but 10 of them are duplicates, so there are only 200 unique pictures.)
    For example, in the pictures1 directory, there’s a file called 1566.png, and in
    the pictures2 directory, there’s a file called 2471.png. These two files are identical,
    and when we generate our directory of files from both phones, we’ll only want
    to keep one of these. What’s tricky here is that these pictures are the same even
    though their filenames are not.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'What if two filenames are the same? Does that mean that the pictures are the
    same? For example, notice that each directory, pictures1 and pictures2, has a
    file called 9595.png. You might think that filenames being the same means that
    the pictures inside will be the same too. But no, if you open these pictures,
    you’ll see that they’re different! This could happen in real life too: you and
    your partner could both take different pictures, and, however remote, it’s possible
    that the filenames your phones choose for those pictures just happen to be the
    same.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: If we’re not careful, we’ll end up copying 9595.png from pictures1 into our
    new directory and then overwriting it later by copying 9595.png from pictures2
    into our new directory. We need to be sure that when we copy a file, we’re not
    overwriting a different picture that may already be there with the same filename.
    We provide an example of this process in figure 9.3.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/9-3.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 Example of merging the photos in the pictures1 and pictures2 folders
    into the pictures–combined folder and managing the removal of duplicates
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’re working with directories, not actual phones
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’re assuming here that you have two directories of pictures already on your
    computer. These directories could have come from anywhere, and nothing we do here
    has anything specific to do with cell phones.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: But if you wanted to do this task for real, with pictures on your phones, you’d
    need to get those pictures onto your computer first. You could use ChatGPT to
    have that discussion! As the details are specific to different phones and go beyond
    what we want to use Copilot to automate, we won’t go further into this here.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.1 Conversing with Copilot
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our tool is going to create a combined directory of pictures from pictures1
    and pictures2, but without duplicate pictures. If our combined original picture
    directories have the same picture multiple times, we want only one of those copies
    of the picture to survive in our new directory.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, there are at least two things we might like to know: How do
    we copy a file using Python, and how do we know whether two files are the same
    picture? Let’s start by asking Copilot Chat how we can copy a file:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanI need to write a Python program that copies files. How do I do this?
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the shutil module
    in Python to copy files. Here’s an example:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]`*[PRE51]`*'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import shutil*`*'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Replace the source and destination paths with your own*`*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '*`*source = ''/path/to/source/file''*`*'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '*`*destination = ''/path/to/destination/file''*`*'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Copy the file*`*'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '*`*shutil.copy(source, destination)*`*'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE52]*[PRE53]'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: This will copy the file from the source path to the destination path. If the
    destination file already exists, it will be overwritten.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Excellent. We can use that shutil module to copy a file; we’ll need to remember
    to import that module. The final sentence that Copilot gave us is an important
    warning. We should be careful to avoid copying a file over the top of another
    file that already exists. Next, let’s determine whether this shutil module is
    built-in to Python.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanIs this shutil module built into Python?
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, the shutil module is a
    built-in module in Python, so you don’t need to install anything extra to use
    it.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why we’re focusing on making copies of files and putting them
    into our new directory, rather than moving them from our original directories
    into the new directory. The reason is that we want to leave our original directories
    alone just in case we have a bug and fail to get all the files into our new directory.
    If anything goes wrong in our new directory, it won’t matter because our original
    directories will still be intact.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: That wraps up what we need to know about copying files. Now let’s move on to
    learn how we can determine whether two files are the same picture.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve already said, it’s not sufficient to use filenames to determine whether
    pictures are the same. How can we do it, then?
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanUsing Python, how can I determine whether .png files are the same?
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the filecmp module
    in Python to compare two files and check if they are the same. Here’s an example
    code snippet that compares two .png files:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]`*[PRE55]`*'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import filecmp*`*'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Replace these file paths with the actual file paths of the .png files*`*'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# you want to compare*`*'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '*`*file1 = ''/path/to/file1.png''*`*'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '*`*file2 = ''/path/to/file2.png''*`*'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '*`*if filecmp.cmp(file1, file2):*`*'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '*`*print(''The files are the same.'')*`*'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '*`*else:*`*'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '*`*print(''The files are different.'')*`*'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE56]*[PRE57]'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: This code will compare the contents of the two files and return `True` if they
    are the same, and `False` if they are different.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: As a quick aside, the last sentence from Copilot is wrong. That code isn’t returning
    `True` or `False` anywhere. Just like Copilot can generate faulty code for us
    in our Python file, Copilot Chat can produce faulty explanations.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Our prompt wasn’t precise about the number of files that we need to compare.
    Do we want to compare two files? Hundreds of files? Our prompt doesn’t say. Copilot
    has told us what to do if we want to compare two files, which is a reasonable
    thing to tell us. But that’s not quite what we need. We need to be able to determine,
    among hundreds of files, which files are duplicates of other files. That way,
    we can detect a duplicate file and not copy it into our new directory. Let’s try
    again.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanWhat if I have hundreds of .png files and I want to find duplicates—is
    that approach you gave me still good?
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot If you have hundreds of .png
    files and you want to find duplicates, you can use the os module to iterate over
    all the files in a directory and compare each file to every other file in the
    directory. Here’s an example code snippet that does that:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]`*[PRE59]`*'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import os*`*'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import filecmp*`*'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Replace this with the actual directory path where your .png*`*'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# files are located*`*'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '*`*directory = ''/path/to/directory''*`*'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Iterate over all the files in the directory*`*'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '*`*for filename1 in os.listdir(directory):*`*'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '*`*if filename1.endswith(''.png''):*`*'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '*`*for filename2 in os.listdir(directory):*`*'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '*`*if filename2.endswith(''.png'') and filename1 != filename2:*`*'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '*`*file1 = os.path.join(directory, filename1)*`*'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '*`*file2 = os.path.join(directory, filename2)*`*'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '*`*if filecmp.cmp(file1, file2):*`*'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '*`*print(f''{filename1} and {filename2} are duplicates.'')*`*'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE60]*[PRE61]'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: This code will iterate over all the files in the directory and compare each
    `.png` file to every other `.png` file in the directory. If two files are the
    same, it will print a message indicating that they are duplicates. Note that this
    approach can be slow for large directories with many files.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'The outer `for` loop goes through each file in the directory. How do we know
    whether the current file has a duplicate? Well, we can go through each other file
    in the directory and compare it to the current file. That’s the role of the inner
    `for` loop: it uses `filecmp.cmp` to compare the current file (`file1`) to each
    other file (`file2`).'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: We didn’t mention in our prompt that we care about finding duplicates across
    multiple directories, so Copilot has focused on a single directory here. If that
    difference turns out to be a roadblock, we could make our prompt more precise.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Copilot is using two other modules here, os and filecmp. We could ask Copilot
    if these are built-in Python modules or not, but we’ll save a little time and
    just tell you here that they are built-in.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'We now want you to focus on the final sentence from Copilot: “Note that this
    approach can be slow for large directories with many files.” How slow is “slow”?
    How many is “many”? We don’t know.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: You might be tempted to ask Copilot for a better solution, one that isn’t “slow
    for large directories with many files.” But many programmers wouldn’t do that.
    It’s often a mistake to optimize our solution before we have even tried out our
    (unoptimized, apparently slow) approach for two reasons. First, maybe our “slow”
    program turns out to be fast enough! We may as well try it. Second, more optimized
    programs are often more sophisticated programs, and they may be more difficult
    for us to get right. That isn’t always the case, but it can be. And again, if
    our unoptimized program gets the job done, we don’t even have to worry about a
    more optimized version at all.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Now, if it turns out that our program really is too slow or you find yourself
    using the program repeatedly, then it may be worth the extra investment in continuing
    to work with Copilot on a faster solution. For now, though, we’re good.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.2 Top-down design
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s a little more going on in this task than in our prior two tasks. For
    one, we need to be careful not to overwrite a file that already exists in our
    new directory. For another, we need to determine which files to copy in the first
    place (remember that we only want to copy files that don’t already match a file
    in our new directory). Compare this to the .pdf merging task we just accomplished,
    where we didn’t have these extra concerns.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: To that end, we’re going to use top-down design and problem decomposition here.
    Don’t worry, it won’t be a full-on top-down design example like we did in chapter
    7\. Our task here is much smaller than our spelling suggestions task from that
    chapter. We’ll just do a little top-down design and that will help Copilot get
    us what we want.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'Our top-level function will be responsible for solving our overall task: taking
    the pictures1 and pictures2 directories and putting all unique pictures into a
    target directory. Back in chapter 3, we learned that we should make functions
    as general as we can, to make them more useful or generalizable to other tasks.
    Here, we’ve been thinking about combining two picture directories together. But
    why not 3, 5, or 50 directories? Who cares how many directories we have; we should
    be able to just combine as many directories as we want.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: So, instead of designing our top-level function to take two strings (directory
    names) as parameters, we’ll have the function take a list of strings. That way,
    we can use it on as many picture directories as we want. And, we can still readily
    use it on two picture directories—we’ll just pass a list containing the names
    of the two directories.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll name our top-level function `make_copies`. We’ll need two parameters:
    the list of directory names that we just discussed, and the name of our target
    directory where we want all the files to go.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: What’s this function going to do? It’s going to loop through each directory
    in the list of directories, and then, for each directory, it’s going to loop through
    each file. For each file, we need to determine whether to copy it or not and,
    if we need to copy it, to do the actual copying.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'Determining whether to copy the file, and then possibly copying it, is a subtask
    that we can split out of `make_copies`. We’ll name our function for this subtask
    `make_copy`. Our `make_copy` function will take two parameters: the name of a
    file and the target directory. If the file isn’t identical to any file in the
    target directory, then the function will copy the file into the target directory.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Say we want to copy a file called 9595.png from one of our picture directories
    into our target directory but that file already exists in the target directory.
    We don’t want to overwrite the file that’s already there, so we’ll need to come
    up with a new filename. We might try adding an _ (underscore) character prior
    to the .png part of the filename. That would give us 9595_.png. That one probably
    wouldn’t exist in the target directory, but if it did, we could then try 9595__.png,
    9595___.png, and so on, until we find a filename that doesn’t already exist in
    there.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Generating a unique filename is a task that we can split out of our `make_copy`
    function. We’ll call it `get_good_filename`. It will take a filename as a parameter
    and return a version of that filename that doesn’t already exist.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: And with that, our top-down design is done. Figure 9.4 depicts our work as a
    tree (well, at least the trunk of a tree), showing which function is called by
    which other function.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/9-4.png)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 Top-down design for image merging. The top-most (left-most) function
    is `make_copies`, the child of that is `make_copy`, and the child of that is `get_good_filename`.
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 9.5.3 Writing the tool
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don’t have any modules to install this time around. We do know from our Copilot
    conversation that we’ll use the built-in shutil module to copy files. We’ll also
    use the built-in filecmp module to compare files and the built-in os module to
    get a list of the files in a directory. We’ll therefore import these three modules
    at the top of our Python program.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: As in chapter 7, we’re going to solve our problem by starting at the bottom
    of our function tree and working toward the top. We do that so Copilot can call
    our already-written functions when writing code for a parent function. For each
    function, we provide the `def` line and docstring, and Copilot writes the code.
    We’ve also provided some annotations to explain how the code works.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Looking again at figure 9.4, we see that the first function we need to implement
    is `get_good_filename`. Let’s get that one done now in the following listing.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.6 `get_good_filename` function for our picture merge task
  id: totrans-477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '#1 While the filename exists . . .'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '#2 . . . insert an _ prior to .png by replacing .png with _.png.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Returns the filename that we know now doesn’t exist'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function we need to write is `make_copy`. This is the function that
    copies a file into a target directory but only if the file isn’t identical to
    a file that we’ve already copied. We’re looking for Copilot to do several things
    in its code here:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: Use `os.listdir` to get a list of files in the target directory.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `filecmp.cmp` to determine whether two files are identical.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `shutil.copy` to copy the file if there was no identical file.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the function `get_good_filename` that we just wrote.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following listing shows our prompt and the code that Copilot provided. Notice
    that the code is doing everything that we wanted it to do.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.7 `make_copy` function for our pictures merge task
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '#1 Loops through the files in the target directory'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '#2 If the file is the same as one of the files in the target directory, . .
    .'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '#3 . . . returns from the function without having copied the file.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Otherwise, copies the file and uses a good filename that doesn’t already
    exist.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: There’s only one function to go, and it’s our top-level `make_copies` function.
    For each file in each of our picture directories, we’re expecting the code to
    call `make_copy` to copy the file if needed, as shown in the following listing.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.8 `make_copies` function for our picture merge task
  id: totrans-495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '#1 Loops through our picture directories'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Loops through the files in the current picture directory'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Copies the current file into the target directory, if needed'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Runs our program on our two picture directories and the given target directory'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: The final line of code from Copilot, beneath the `make_copies` function, makes
    the assumption that our target directory will be named pictures_combined. Create
    that directory now so that it sits alongside your pictures1 and pictures2 directories
    of pictures.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed when working with .pdf files earlier in the chapter, it’s important
    that you first test the program on sample directories that you don’t care about.
    Your sample directories should have only a few files in them, so that you can
    manually determine whether the program is working as expected. You should also
    include important edge cases, such as having the same filename in each directory.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your sample directories, you should create a “harmless” version
    of the program that simply outputs messages rather than actually copying files.
    For our program here, you would change the line in `make_copy` to use `print`
    rather than `shutil.copy`.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: If the output looks good after you check the results carefully, only then should
    you run the real program on your real directories. Remember that our program is
    copying (rather than moving) files, so even in our real directories, if something
    goes wrong, there’s a good chance that the problem will be in our new directory
    and not the original directories that we actually care about.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: We’ll assume that you’re now ready to run the program on the pictures1 and pictures2
    directories. Once you run it, you can check your pictures_combined directory for
    the results. You should see that the directory has 200 files, which is exactly
    the number of unique pictures that we had across our two picture directories.
    Did we correctly handle the situation where the same filename existed in both
    picture directories but were different pictures? Yes, you can see that we have
    files named 9595.png and 9595_.png and that we therefore haven’t overwritten one
    with the other.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Oh, and how long did the program take to run on your computer? At most a few
    seconds, right? It turns out that Copilot’s warning that “this approach can be
    slow for large directories with many files” didn’t matter for us.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Now, we all know that people tend to have thousands of pictures on their phones,
    not hundreds. If you ran this program on two real phone picture libraries, you
    would again need to determine whether it completes in an acceptable amount of
    time. You could run the program and let it run for a minute or two or however
    long you’re willing to wait. For fun, we also tested our program on a total of
    10,000 small image files (a more realistic scenario than the 210 pictures across
    our pictures1 and pictures2 directories that we used in this chapter), and we
    found that it only took 1 minute to complete. At some point, our program will
    become too slow to be practical, and that’s when you’d need to do further research
    with Copilot Chat to arrive at a more efficient program.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we succeeded in automating three tedious tasks: cleaning up
    an email, adding covers to hundreds of .pdf files, and wrangling multiple picture
    libraries into one. The approach in each case was the same: use Copilot Chat to
    determine which module(s) to use, then follow the approach that we’ve honed throughout
    the book to have Copilot write the required code.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Remember, whenever you find yourself repeating the same task, it’s worth trying
    to automate it using Copilot and Python. There are many helpful Python modules
    for doing so, beyond what we showed in this chapter. For example, there are modules
    to manipulate images, work with Microsoft Excel or Microsoft Word files, send
    email, scrape data from websites, and more. If it’s a tedious task, chances are
    that someone has made a Python module to help with it and that Copilot will be
    able to help you use that module effectively.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 Exercises
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You already have a tool that cleans up email text by removing any `>` or space
    characters from the beginning of each line. What steps will you take to enhance
    this tool to also remove lines that are excessively short (e.g., lines with fewer
    than five characters, excluding spaces)?
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You’re writing a Python program to clean up a bunch of images that you have
    stored on your computer, and you’ve decided to use the Pillow library (a fork
    of the Python Image Library [PIL]). After installing the latest version of Pillow,
    you run your program but encounter the following error:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: What steps can you take to fix this problem?
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 3\. You’ve been given an Excel file named sales_data.xlsx that contains monthly
    sales data for different products. Your task is to write a Python program that
    reads the sales data, calculates the total sales for each product, and writes
    the results to a new Excel file named total_sales.xlsx. The sales_data.xlsx file
    has columns for each month (January, February, etc.).
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your program should do the following:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Read the data from `sales_data.xlsx`.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the total sales for each product across all months.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the product names and their total sales to `total_sales.xlsx`.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hints: make reasonable assumptions about the input file and you may need to
    import libraries to help you work with the .xlsx files. If you don’t have Excel
    or OpenOffice to read/write .xlsx files, feel free to do the task with .csv files
    instead.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 4\. It can be tedious to find news articles from different sources to read every
    day. Your task is to write a webscraper in Python that extracts and display the
    titles and URLs of the latest articles from a news website. You’ll need the beautifulsoup4
    and requests modules.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programmers often make tools to automate tedious tasks.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s often necessary to use a Python module to help us write our tool.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use Copilot Chat to determine which Python modules we should be using.
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s helpful to converse with Copilot to understand the pros and cons of various
    Python modules that may be available to us.
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are Python modules for working with the clipboard, working with .pdf files
    and other file formats, copying files, and more.****
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
