<html><head></head><body>
  <h1 class="tochead" id="heading_id_2">8 <a id="idTextAnchor000"/>Genetic algorithm variants</h1>

  <p class="co-summary-head">This chapter covers<a id="marker-271"/></p>

  <ul class="calibre5">
    <li class="co-summary-bullet">Introducing the Gray-coded genetic algorithm</li>

    <li class="co-summary-bullet">Understanding real-valued GA and its genetic operators</li>

    <li class="co-summary-bullet">Understanding permutation-based GA and its genetic operators</li>

    <li class="co-summary-bullet">Understanding multi-objective optimization</li>

    <li class="co-summary-bullet">Adapting genetic algorithms to strike a balance between exploration and exploitation</li>

    <li class="co-summary-bullet">Solving continuous and discrete problems using GA</li>
  </ul>

  <p class="body">This chapter continues with the topic of chapter 7: we will look at various forms of genetic algorithms (GAs) and delve deeper into their real-world applications. We’ll also look at a number of case studies and exercises, such as the traveling salesman problem (TSP), proportional integral derivative (PID) controller design, political districting, the cargo bike loading problem, manufacturing planning, facility allocation, and the opencast mining problem in this chapter and its supplementary exercises included in the online appendix C.<a id="idIndexMarker000"/><a id="idIndexMarker001"/></p>

  <h2 class="fm-head" id="heading_id_3">8.1 Gray-coded GA</h2>

  <p class="body">The Hamming cliff effect refers to the fact that small changes in a chromosome can result in large changes in a solution’s fitness, which can lead to a sharp drop-off in the fitness landscape and cause the algorithm to converge prematurely. In binary genetic algorithms, the crossover and mutation operations can significantly affect the solution due to this Hamming cliff effect, especially when the bits that are to be changed are among the most significant bits in the binary string. To mitigate the Hamming cliff effect, Gray-coded GA uses a Gray-code encoding scheme for the chromosomes.<a id="idIndexMarker002"/><a id="idIndexMarker003"/><a id="idIndexMarker004"/></p>

  <p class="body"><a id="marker-272"/>The reflected binary code, commonly referred to as <i class="fm-italics">Gray code</i> after its inventor Frank Gray, is a unique binary numbering system characterized by adjacent numerical values differing by only one bit, as shown in table 8.1. In this numeral system, each value has a unique representation that is close to the representations of its neighboring values, which helps minimize the effect of crossover and mutation operations on the solution. This coding ensures a smooth transition between values and minimizes the risk of errors during conversions or when used in various applications, such as rotary encoders and digital-to-analog converters. Table 8.1 shows the decimal numbers 1 to 15 and their corresponding binary and Gray equivalents. <a id="idIndexMarker005"/></p>

  <p class="fm-table-caption">Table 8.1 Decimal, binary, and Gray coding</p>

  <table border="1" class="contenttable-1-table" id="table001" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="33.33%"/>
      <col class="contenttable-0-col" span="1" width="33.33%"/>
      <col class="contenttable-0-col" span="1" width="33.33%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Decimal number</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Binary code</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Gray code</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">0</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0000</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0000</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">1</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0001</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0001</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">2</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0010</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0011</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">3</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0011</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0010</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">4</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0100</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0110</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">5</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0101</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0111</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">6</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0101</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">7</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0111</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0100</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">8</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1000</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1100</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">9</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1001</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1101</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">10</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1010</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1111</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">11</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1011</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1110</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">12</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1100</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1010</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">13</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1101</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1011</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">14</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1001</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">15</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1111</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1000</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">Exclusive OR (XOR) gates are used to convert 4-bit binary numbers to Gray codes, as illustrated in figure 8.1 for the ticket pricing example discussed in the previous chapter. These XOR gates result in 1 only if the inputs are different and 0 if the inputs are the same.<a id="idIndexMarker006"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F01_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.1 Gray coding and binary-to-Gray conversion</p>
  </div>

  <p class="body"><a id="marker-273"/>In Gray code, two successive values differ by only one bit. This property reduces the Hamming distance between adjacent numbers, leading to a smoother search space or smoother genotype-to-phenotype mapping.</p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">Hamming cliff problem<a class="calibre" id="idIndexMarker007"/></p>

    <p class="fm-sidebar-text">One of the drawbacks of encoding variables as binary strings is the presence of Hamming cliffs. In binary-coded GAs, a small change in the encoded value (e.g., flipping a single bit) can lead to a significant change in the decoded value, especially if the flipped bit is located toward the most significant bit position. This abrupt change between two adjacent numbers in the search space is referred to as a Hamming cliff. This problem negatively affects binary-coded GAs by disrupting the search space’s smoothness, causing poor convergence and leading to inefficient exploration and exploitation. To address the Hamming cliff problem, alternative representations like Gray code or real-valued encoding can be used, as they offer better locality and smoother search spaces, minimizing the disruptive effects of small changes on decoded values.</p>

    <p class="fm-sidebar-text">For example, assume that we have a decision variable in the range [0, 15], as shown in the following figure. In binary-coded GA, we would use 4-bit binary representation to encode the candidate solutions. Let’s assume we have two adjacent solutions in the search space: 7 and 8, or 0111 and 1000 in binary representation. The Hamming distance is the number of bit-wise differences, so the Hamming distance between 1000 and 0111 is 4. These two solutions (7 and 8) are neighbors in the search space, but when you look at their binary representations, you can see that they differ in all 4 bits. Flipping the most significant bit causes a significant change in the decoded value. In the case of Gray code, the Hamming distance between the Gray code representation 0100 (7 in decimal) and 1100 (8 in decimal) is only 1. This means that these Gray code representations for the two adjacent solutions differ by only 1 bit, providing a smoother search space and potentially improving the performance of the GA.</p>

    <p class="sidebarafigures"><img alt="" class="calibre2" src="../Images/CH08_F01_UN01_Khamis.png"/></p>

    <p class="sidebaracaptions">Hamming distances for decimal number change from 0 to 15 for binary and Gray coding</p>
  </div>

  <p class="body"><a id="marker-274"/>Gray code representations provide better locality, meaning that small changes in the encoded value result in small changes in the decoded value. This property can improve the convergence of the GA by reducing the likelihood of disruptive changes during crossover and mutation operations. However, it is worth noting that the performance improvements offered by Gray coding are problem-dependent, and this representation method is not commonly used compared to binary-coded GA.<a id="idIndexMarker008"/><a id="idIndexMarker009"/></p>

  <h2 class="fm-head" id="heading_id_4">8.2 Real-valued GA</h2>

  <p class="body">Real-valued GA is a variation on the standard GA that uses real numbers for encoding chromosomes instead of binary or Gray code representations. Many optimization problems involve continuous variables or real-valued parameters, such as curve fitting, function optimization with real-valued inputs, proportional integral derivative (PID) controller parameter tuning, or optimizing the weights of a neural network. To handle these continuous problems, it’s recommended that we use real-value GA directly for the following reasons:<a id="idIndexMarker010"/><a id="idIndexMarker011"/><a id="idIndexMarker012"/><a id="marker-275"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Precision</i>—Real-valued GAs can achieve a higher level of precision in the search space than binary GAs. Binary encoding requires the discretization of the search space into a finite number of possible solutions, which can limit the accuracy of the search. Real-valued encoding, on the other hand, allows for a continuous search space, which can provide a more precise search.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Efficiency</i>—Real-valued GAs can require fewer bits to encode a solution compared to binary GAs. For example, assume that the decision variable to be represented has a lower bound (<i class="timesitalic">LB</i>) of 0 and an upper bound (<i class="timesitalic">UB</i>) of 10, and we need to represent the solution with a precision (<i class="timesitalic">P</i>) of 0.0001. As explained in the previous chapter, the number of bits required to represent a range between <i class="timesitalic">LB</i> and <i class="timesitalic">UB</i> with a desired precision <i class="timesitalic">P</i> is <span class="times"><i class="fm-italics">number_of_bits</i> = ceil(log2(<i class="fm-italics">UB</i> – <i class="fm-italics">LB</i>)/<i class="fm-italics">P</i>)) = ceil(log2(ceil(10/0.0001))) = ceil(log2(100000)) = 17 bits</span>. A real-valued encoding can use floating-point numbers with a smaller number of bits to represent a wider range of values than a binary encoding. This can result in a more efficient use of the available memory and computation resources.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Smoothness</i>—Real-valued GAs can maintain the continuity and smoothness of the search space, which can be important in some applications. In contrast, binary GAs can suffer from the Hamming cliff effect, as discussed in the previous section.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Adaptability</i>—Real-valued GAs can adapt more easily to changes in the search space or the fitness landscape. For example, if the fitness landscape changes abruptly, real-valued GAs can adjust the step size or mutation rate to explore the new landscape more effectively. Binary GAs, on the other hand, can require a more extensive redesign of the encoding or operator parameters to adapt to changes in the search space.</p>
    </li>
  </ul>

  <p class="body">In the following subsections, we’ll look at the crossover and mutation methods used in real-valued GA.</p>

  <h3 class="fm-head1" id="heading_id_5">8.2.1 Crossover methods</h3>

  <p class="body">Some popular crossover methods for real-valued GAs are single arithmetic crossover, simple arithmetic crossover, and whole arithmetic crossover.<a id="idIndexMarker013"/><a id="idIndexMarker014"/></p>

  <p class="fm-head2">Single arithmetic crossover</p>

  <p class="body">The <i class="fm-italics">single arithmetic crossover method</i> involves picking a gene (<i class="timesitalic">k</i>) at random and generating a random weight <i class="timesitalic">α</i>, which lies in the range [0, 1]. Genes with indices <i class="timesitalic">i</i> before and after the crossover point (<span class="times"><i class="fm-italics">i</i> &lt; <i class="fm-italics">k</i></span> or <span class="times"><i class="fm-italics">i</i> &gt; <i class="fm-italics">k</i></span>) will inherit the genes from the corresponding parent chromosome. For genes at the crossover point (<span class="times"><i class="fm-italics">i</i> = <i class="fm-italics">k</i></span>), we create the offspring genes by taking a weighted average of the corresponding genes in the parent chromosomes:<a id="idIndexMarker015"/><a id="idIndexMarker016"/><a id="idIndexMarker017"/><a id="marker-276"/></p>

  <p class="fm-equation"><i class="fm-italics">Child</i><sub class="fm-subscript">1</sub><i class="fm-italics">Gene<sub class="fm-subscript">i</sub></i> = <i class="fm-italics">α</i> × <i class="fm-italics">Parent</i><sub class="fm-subscript">1</sub><i class="fm-italics">Gene<sub class="fm-subscript">i</sub></i> + (1 – <i class="fm-italics">α</i>) × <i class="fm-italics">Parent</i><sub class="fm-subscript">2</sub><i class="fm-italics">Gene<sub class="fm-subscript">i</sub></i></p>

  <p class="fm-equation"><i class="fm-italics">Child</i><sub class="fm-subscript">2</sub><i class="fm-italics">Gene<sub class="fm-subscript">i</sub></i> = <i class="fm-italics">α</i> × <i class="fm-italics">Parent</i><sub class="fm-subscript">2</sub><i class="fm-italics">Gene<sub class="fm-subscript">i</sub></i> + (1 – <i class="fm-italics">α</i>) × <i class="fm-italics">Parent</i><sub class="fm-subscript">1</sub><i class="fm-italics">Gene<sub class="fm-subscript">i</sub></i></p><!--<p class="Equation"><img src="08-web-resources/image/khamis-ch8-eqs-0x.png" alt="" />   </p>-->

  <p class="body">Figure 8.2 illustrates the single arithmetic crossover in real-valued GA.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F02_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.2 Single arithmetic crossover in real-valued GA</p>
  </div>

  <p class="fm-head2">Simple arithmetic crossover</p>

  <p class="body"><i class="fm-italics">Simple arithmetic crossover</i> is similar to single arithmetic crossover. Before a randomly picked crossover point (<span class="times"><i class="fm-italics">i</i> &lt; <i class="fm-italics">k</i></span>), the genes are inherited from the corresponding parent chromosome. After the crossover point (<span class="times"><i class="fm-italics">i</i> &gt;= <i class="fm-italics">k</i></span>), we create the offspring genes by taking a weighted average of the corresponding genes in the parent chromosomes. Figure 8.3 illustrates the simple arithmetic crossover in real-valued GA.<a id="idIndexMarker018"/><a id="idIndexMarker019"/><a id="idIndexMarker020"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F03_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.3 Simple arithmetic crossover in real-valued GA</p>
  </div>

  <p class="fm-head2"><a id="marker-277"/>Whole arithmetic crossover</p>

  <p class="body">In the <i class="fm-italics">whole arithmetic crossover</i> method, we take a weighted average of the entire parent chromosomes to create the offspring. Figure 8.4 illustrates this method in real-valued GA.<a id="idIndexMarker021"/><a id="idIndexMarker022"/><a id="idIndexMarker023"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F04_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.4 Whole arithmetic crossover in real-valued GA</p>
  </div>

  <p class="fm-head2">Simulated binary crossover</p>

  <p class="body"><i class="fm-italics">Simulated binary crossover</i> (SBX) [1] is another crossover method in real-valued GA. In SBX, real values can be represented by a binary notation, and then the point crossovers can be performed. SBX is designed to generate offspring close to the parent chromosomes by creating a probability distribution function, thus maintaining a balance between exploration and exploitation in the search space. SBX is implemented in pymoo.<a id="idIndexMarker024"/><a id="idIndexMarker025"/><a id="idIndexMarker026"/><a id="idIndexMarker027"/></p>

  <h3 class="fm-head1" id="heading_id_6">8.2.2 Mutation methods</h3>

  <p class="body">The simplest way to mutate a continuous variable is to introduce small, random perturbations to the genes of an individual to maintain diversity in the population and help the search process escape from local optima. There are several common mutation methods used in real-valued GAs:<a id="idIndexMarker028"/><a id="idIndexMarker029"/><a id="idIndexMarker030"/><a id="marker-278"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Gaussian mutation</i>—Gaussian mutation adds a random value to the gene, where the random value is sampled from a Gaussian distribution with 0 mean and a specified standard deviation <i class="fm-italics">σ</i>. The standard deviation controls the magnitude of the mutation (aka the <i class="fm-italics">mutation step</i>).<a id="idIndexMarker031"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Cauchy mutation</i>—Similar to Gaussian mutation, Cauchy mutation adds a random value to the gene, but the random value is sampled from a <i class="fm-italics">Cauchy distribution</i> (aka a <i class="fm-italics">Lorentz distribution</i> or <i class="fm-italics">Cauchy–Lorentz distribution</i>) instead of a Gaussian distribution. The Cauchy distribution has heavier tails than the Gaussian distribution, leading to a higher probability of larger mutations.<a id="idIndexMarker032"/><a id="idIndexMarker033"/><a id="idIndexMarker034"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Boundary mutation</i>—In boundary mutation, the mutated gene is randomly drawn from the uniform distribution within the variable’s range, defined by the lower bound (<i class="fm-italics">LB</i>) and upper bound (<i class="fm-italics">UB</i>). This method is analogous to the bit-flipping mutation in a binary-coded GA, and it helps explore the boundaries of the search space. It may be useful when optimal solutions are located near the variable limits.<a id="idIndexMarker035"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Polynomial mutation</i>—Polynomial mutation is a method that generates offspring close to the parent by creating a probability distribution function [2]. A distribution index (<i class="fm-italics">η</i>) controls the shape of the probability distribution function, with higher values resulting in offspring closer to their parents (exploitation) and lower values leading to offspring more spread out in the search space (exploration).<a id="idIndexMarker036"/></p>
    </li>
  </ul>

  <p class="body">To illustrate these genetic operators, let’s consider a curve-fitting example. Assume we have the data points shown in table 8.2 and that we want to fit a third-order polynomial to these data points using real-valued GA.</p>

  <p class="fm-table-caption">Table 8.2 Curve-fitting problem data</p>

  <table border="1" class="contenttable-1-table" id="table002" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1">
          <p class="fm-table-head1">x</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1.25</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">2.5</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">3.75</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">5</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1">
          <p class="fm-table-head1">y</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">5.22</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">23.5</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">79.28</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">196</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">The third-order polynomial takes the form <span class="times"><i class="fm-italics">y</i> = <i class="fm-italics">ax</i><sup class="fm-superscript">3</sup> + <i class="fm-italics">bx</i><sup class="fm-superscript">2</sup> + <i class="fm-italics">cx</i> + <i class="fm-italics">d</i></span>. A real-valued GA can be used to find the four coefficients of the polynomial: <i class="timesitalic">a, b, c</i>, and <i class="timesitalic">d</i>. This problem is treated as a minimization problem where the objective is to minimize the mean squared error (MSE) that measures how close a fitted polynomial is to given data points. MSE is calculated using the following formula:<a id="idIndexMarker037"/><a id="marker-279"/></p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH08_F04_Khamis-EQ02.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">8.1</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">where <i class="timesitalic">n</i> is the number of data points, <i class="timesitalic">y</i> is the <i class="timesitalic">y</i>-coordinate value of each data point, and <span class="times"><i class="fm-italics">y</i>′</span> is the desired value that sits on the line we created.</p>

  <p class="body">In real-valued GA, a candidate solution is represented by a vector of parameters <i class="timesitalic">a, b, c</i>, and <i class="timesitalic">d</i> that can be represented by real values. Let’s start with the following initial random solution: <span class="times"><i class="fm-italics">Parent</i><sub class="fm-subscript">1</sub> = [1 2 3 4]</span>. We calculate its fitness by substituting these values in the function <span class="times">(<i class="fm-italics">y</i> = <i class="fm-italics">x</i><sup class="fm-superscript">3</sup> + 2<i class="fm-italics">x</i><sup class="fm-superscript">2</sup> + 3<i class="fm-italics">x</i> + 4)</span>, calculating <span class="times"><i class="fm-italics">y</i>′</span> for each corresponding <i class="timesitalic">x</i> and calculating the MSE as in table 8.3.</p>

  <p class="fm-table-caption">Table 8.3 MSE calculation for parent 1</p>

  <table border="1" class="contenttable-1-table" id="table003" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1">
          <p class="fm-table-head1">x</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1.25</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">2.5</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">3.75</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">5</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1">
          <p class="fm-table-head1">y</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">5.22</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">23.5</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">79.28</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">196</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1">
          <p class="fm-table-head"><i class="timesitalic">y</i>′</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">4</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">12.83</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">39.63</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">96.11</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">194</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1">
          <p class="fm-table-head"><i class="timesitalic">Square</i> <i class="timesitalic">of error</i></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">9</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">57.88</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">260</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">283.23</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">4</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1">
          <p class="fm-table-head1">MSE</p>
        </td>

        <td class="contenttable-1-td" colspan="5">
          <p class="fm-table-body">122.83</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">Let’s generate another random solution: <span class="times"><i class="fm-italics">Parent</i><sub class="fm-subscript">2</sub> = [2 2 2 2]</span>, which gives the formula <span class="times">2<i class="fm-italics">x</i><sup class="fm-superscript">3</sup> + 2<i class="fm-italics">x</i><sup class="fm-superscript">2</sup> + 2<i class="fm-italics">x</i> + 2</span> and the MSE in table 8.4.</p>

  <p class="fm-table-caption">Table 8.4 MSE calculation for parent 2</p>

  <table border="1" class="contenttable-1-table" id="table004" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1">
          <p class="fm-table-head1">x</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1.25</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">2.5</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">3.75</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">5</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1">
          <p class="fm-table-head1">y</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">5.22</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">23.5</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">79.28</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">196</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1">
          <p class="fm-table-head"><i class="timesitalic">y</i>′</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">2</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">11.53</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">50.75</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">143.09</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">312</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1">
          <p class="fm-table-head"><i class="timesitalic">Square of</i> <i class="timesitalic">error</i></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">39.83</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">742.56</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">4,072.2</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">13,456</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1">
          <p class="fm-table-head1">MSE</p>
        </td>

        <td class="contenttable-1-td" colspan="5">
          <p class="fm-table-body">3,662.32</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">Applying whole arithmetic crossover on the two parents <span class="times"><i class="fm-italics">P</i><sub class="fm-subscript">1</sub> = [1 2 3 4]</span> and <span class="times"><i class="fm-italics">P</i><sub class="fm-subscript">2</sub> = [2 2 2 2]</span> with weight <span class="times"><i class="fm-italics">α</i> = 0.2</span> results in the following offspring:</p>

  <div class="figure">
    <p class="figured"><img alt="" class="calibre4" src="../Images/CH08_F04_Khamis-EQ03.png"/></p>
  </div>

  <div class="figure">
    <p class="figured"><img alt="" class="calibre4" src="../Images/CH08_F04_Khamis-EQ04.png"/></p>
  </div>

  <p class="body">Let’s assume <span class="times"><i class="fm-italics">Child</i><sub class="fm-subscript">1</sub></span> is subject to Gaussian mutation. This mutation process results in another child as follows: <span class="times"><i class="fm-italics">Child</i><sub class="fm-subscript">3</sub> = <i class="fm-italics">Child</i><sub class="fm-subscript">1</sub> + <i class="fm-italics">N</i>(0, <i class="fm-italics">σ</i>)</span>, where <span class="times"><i class="fm-italics">N</i>(0, <i class="fm-italics">σ</i>)</span> is a random number from a normal distribution with a mean of 0 and a standard deviation of <i class="timesitalic">σ</i>. Assuming that <span class="times"><i class="fm-italics">σ</i> = 1.2</span>, a random value of 0.43 is generated by <code class="fm-code-in-text">numpy.random.normal(0, 1.2)</code>, <span class="times"><i class="fm-italics">s</i>o <i class="fm-italics">Child</i><sub class="fm-subscript">3</sub> = [1.8 2 2.2 2.4] + 0.43 = [2.23 2.43 2.63 2.83]</span>.</p>

  <p class="body"><a id="marker-280"/>Listing 8.1 shows how to perform this curve-fitting using real-valued GA implemented in pymoo. We’ll start by generating a dataset driven by a third-order polynomial, to be used later as a ground truth. Feel free to replace this synthetically generated data with any experimental data you may have.</p>

  <p class="fm-code-listing-caption">Listing 8.1 Curve fitting using real-valued GA</p>
  <pre class="programlisting">import numpy as np
  
def third_order_polynomial(x, a, b, c, d):
    return a * x**3 + b * x**2 + c * x + d
 
a, b, c, d = 2, -3, 4, 1                     <span class="fm-combinumeral">①</span>
 
x = np.linspace(0, 5, 5)                     <span class="fm-combinumeral">②</span>
 
y = third_order_polynomial(x, a, b, c, d)    <span class="fm-combinumeral">③</span>
 
data_samples = np.column_stack((x, y))       <span class="fm-combinumeral">④</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Define coefficients for the third-order polynomial.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Generate five values as in the hand-iteration example.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Calculate y values using the third-order polynomial function.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Combine x and y values into an array of data samples.</p>

  <p class="body">As a continuation of listing 8.1, we can define a problem for curve fitting by subclassing pymoo’s <code class="fm-code-in-text">Problem</code> class, ensuring we pass the parameters to the superclass and provide an <code class="fm-code-in-text">_evaluate</code> function. The <code class="fm-code-in-text">CurveFittingProblem</code> class has an initializer method that sets the number of decision variables to 4, the number of objectives to 1, the number of constraints to 0, the lower bound of the decision variables to –10.0, and the upper bound of the decision variables to 10.0. The <code class="fm-code-in-text">vtype</code> parameter specifies the data type of the decision variables, which is set to <code class="fm-code-in-text">float</code>. This initializer method creates an instance of the problem to be solved using the genetic algorithm. The <code class="fm-code-in-text">_evaluate</code> method takes as input a set of candidate solutions (<code class="fm-code-in-text">X</code>) and an output dictionary (<code class="fm-code-in-text">out</code>) and returns the fitness of each candidate solution in the <code class="fm-code-in-text">F</code> field of the <code class="fm-code-in-text">out</code> dictionary: <a id="idIndexMarker038"/><a id="idIndexMarker039"/><a id="idIndexMarker040"/><a id="idIndexMarker041"/><a id="idIndexMarker042"/></p>
  <pre class="programlisting">import numpy as np
from pymoo.algorithms.soo.nonconvex.ga import GA                  <span class="fm-combinumeral">①</span>
from pymoo.operators.crossover.sbx import SBX                     <span class="fm-combinumeral">②</span>
from pymoo.operators.mutation.pm import PolynomialMutation        <span class="fm-combinumeral">③</span>
from pymoo.operators.repair.rounding import RoundingRepair        <span class="fm-combinumeral">④</span>
from pymoo.operators.sampling.rnd import FloatRandomSampling      <span class="fm-combinumeral">⑤</span>
from pymoo.core.problem import Problem                            <span class="fm-combinumeral">⑥</span>
from pymoo.optimize import minimize                               <span class="fm-combinumeral">⑦</span>
 
class CurveFittingProblem(Problem):                               <span class="fm-combinumeral">⑧</span>
 
    def __init__(self):                                           <span class="fm-combinumeral">⑨</span>
        super().__init__(n_var=4,
                         n_obj=1,
                         n_constr=0,
                         xl=-10.0,
                         xu=10.0, vtype=float)    
 
    def _evaluate(self, X, out, *args, **kwargs):                 <span class="fm-combinumeral">⑩</span>
        Y = np.zeros((X.shape[0], 1))
        for i, coeffs in enumerate(X):
            y_pred = np.polyval(coeffs, x)
            mse = np.mean((y - y_pred)**2)
            Y[i] = mse
        out["F"] = Y</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Import the GA implementation for single-objective optimization in nonconvex scenarios.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Import the simulated binary crossover (SBX) operator.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Import the polynomial mutation operator.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Import the rounding repair operator to ensure that the generated solutions remain within specified bounds.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Import the float random sampling operator to generate random initial solutions.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Import the generic optimization problem class.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑦</span> Import the minimize function.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑧</span> Define the optimization problem for curve fitting.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑨</span> Initialize the problem with four decision variables, ranging from –10.0 to 10.0, and a single objective with no constraints.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑩</span> Calculate the mean squared error for each set of coefficients in the input variable.</p>

  <p class="body"><a id="marker-281"/>Now we can instantiate the <code class="fm-code-in-text">CurveFittingProblem</code> class to create an instance of the problem to be solved. We can then define the genetic algorithm to be used for the optimization. The <code class="fm-code-in-text">GA</code> class is used to define the algorithm, and the <code class="fm-code-in-text">pop_size</code> parameter sets the population size to 50. The <code class="fm-code-in-text">sampling</code> parameter uses the <code class="fm-code-in-text">FloatRandomSampling</code> operator to generate the initial population of candidate solutions randomly. The <code class="fm-code-in-text">crossover</code> parameter uses the <code class="fm-code-in-text">SBX</code> operator with a crossover probability of 0.8. The <code class="fm-code-in-text">mutation</code> parameter uses the <code class="fm-code-in-text">PolynomialMutation</code> operator with a mutation probability of 0.3 and a rounding repair operator to ensure that the decision variables remain within the specified bounds. The <code class="fm-code-in-text">eliminate_duplicates</code> parameter is set to <code class="fm-code-in-text">True</code> to remove duplicate candidate solutions from the population. <a id="idIndexMarker043"/><a id="idIndexMarker044"/><a id="idIndexMarker045"/><a id="idIndexMarker046"/><a id="idIndexMarker047"/><a id="idIndexMarker048"/><a id="idIndexMarker049"/><a id="idIndexMarker050"/><a id="idIndexMarker051"/><a id="idIndexMarker052"/></p>

  <p class="body">Next, we can run the genetic algorithm to solve the curve fitting problem using the <code class="fm-code-in-text">minimize</code> function. This function takes three arguments: the instance of the problem to be solved (<code class="fm-code-in-text">problem</code>), the instance of the algorithm to be used (<code class="fm-code-in-text">algorithm</code>), and a tuple specifying the stopping criterion for the algorithm <code class="fm-code-in-text">('n_gen', 100)</code>, which specifies that the algorithm should run for 100 generations. The <code class="fm-code-in-text">seed</code> parameter is set to 1 to ensure the reproducibility of the results. The <code class="fm-code-in-text">verbose</code> parameter is set to <code class="fm-code-in-text">True</code> to display the progress of the algorithm during the optimization:<a id="idIndexMarker053"/><a id="idIndexMarker054"/><a id="idIndexMarker055"/></p>
  <pre class="programlisting">problem = CurveFittingProblem()                                           <span class="fm-combinumeral">①</span>
 
algorithm = GA(
    pop_size=50,
    sampling=FloatRandomSampling(),
    crossover= SBX(prob=0.8),
    mutation = PolynomialMutation(prob=0.3, repair=RoundingRepair()),
    eliminate_duplicates=True
)                                                                         <span class="fm-combinumeral">②</span>
 
res = minimize(problem, algorithm, ('n_gen', 100), seed=1, verbose=True)  <span class="fm-combinumeral">③</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Initialize an instance of the CurveFittingProblem class.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Create a GA solver.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Perform the optimization for 100 generations.</p>

  <p class="body">You can print the four coefficients obtained by GA as follows:</p>
  <pre class="programlisting">best_coeffs <b class="fm-bold">=</b> res<b class="fm-bold">.</b>X
print("Coefficients of the best-fit third-order polynomial:")
print("a =", best_coeffs[0])
print("b =", best_coeffs[1])
print("c =", best_coeffs[2])
print("d =", best_coeffs[3])</pre>

  <p class="body">This results in the following output:</p>
  <pre class="programlisting">Coefficients of the best-fit third-order polynomial:
a = 2, b = -3, c = 4, d = 1</pre>

  <p class="body">As you can see, the estimated values of the four coefficients are same as the coefficients of the ground truth polynomial (a, b, c, d = 2, –3, 4, 1). You can experiment with the code by changing the polynomial coefficients, using your own data, and using different crossover and mutation methods.</p>

  <p class="body">Next, we’ll look at permutation-based GA.<a id="idIndexMarker056"/><a id="idIndexMarker057"/><a id="idIndexMarker058"/><a id="idIndexMarker059"/><a id="idIndexMarker060"/></p>

  <h2 class="fm-head" id="heading_id_7">8.3 Permutation-based GA</h2>

  <p class="body"><a id="marker-282"/>Permutation-based GAs are designed to solve optimization problems where the solutions are permutations of a set of elements. Examples of such problems include the traveling salesman problem (TSP), vehicle routing problem, sports tournament scheduling, and job scheduling problem. In these problems, the solutions are represented as optimal orders or permutations of a set of elements or events. <a id="idIndexMarker061"/><a id="idIndexMarker062"/></p>

  <p class="body">There are typically two main types of problems where the goal is to determine the optimal order of events:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Resource or time-constrained problems</i>—In these problems, the events rely on limited resources or time, making the order of events crucial for optimal solutions. One example of this type of problem is ride-sharing scheduling, where the goal is to efficiently allocate resources like vehicles and drivers to serve the maximum number of passengers in the shortest possible time.<a id="idIndexMarker063"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Adjacency-based problems</i>—In these problems, the proximity or adjacency of elements plays a significant role in finding the best solution. An example of such a problem is the traveling salesman problem (TSP), where the aim is to visit a set of cities while minimizing the total travel distance, taking into account the distances between adjacent cities in the tour.<a id="idIndexMarker064"/></p>
    </li>
  </ul>

  <p class="body">These problems are often formulated as permutation problems. In a permutation representation, if there are <i class="timesitalic">n</i> variables, the solution is a list of <i class="timesitalic">n</i> distinct integers, each occurring exactly once. This representation ensures that the order or adjacency of the elements in the solution is explicitly encoded, which is essential for finding the optimal sequence of events in these types of problems. For example, let’s consider the following TSP for 8 cities. A candidate solution for this TSP is represented by a permutation such as [1, 2, 3, 4, 5, 6, 7, 8]. In permutation-based GA, specialized crossover and mutation operators are employed to preserve the constraints of the permutation problem, such as maintaining a valid sequence of cities in the TSP, where each city appears only once.</p>

  <p class="body">The following subsections describe commonly used crossover and mutation methods in permutation-based GAs. The choice of crossover and mutation methods in GAs depends on the problem being solved, the type of solutions being sought, and the objectives of the optimization problem. By carefully selecting and designing these operators, GAs can effectively explore and exploit the search space to find high-quality solutions.</p>

  <h3 class="fm-head1" id="heading_id_8">8.3.1 Crossover methods</h3>

  <p class="body"><a id="marker-283"/>Several crossover methods are commonly used in permutation-based GAs, such as partially mapped crossover (PMX), edge crossover (EC), order 1 crossover (OX1), and cycle crossover (CX). <a id="idIndexMarker065"/><a id="idIndexMarker066"/><a id="idIndexMarker067"/></p>

  <p class="fm-head2">Partially mapped crossover</p>

  <p class="body">The <i class="fm-italics">partially mapped crossover</i> (PMX) method creates offspring by combining the genetic information from two parent chromosomes while preserving the feasibility of the resulting offspring with the procedure shown in algorithm 8.1.<a id="idIndexMarker068"/><a id="idIndexMarker069"/><a id="idIndexMarker070"/><a id="idIndexMarker071"/></p>

  <p class="fm-code-listing-caption">Algorithm 8.1 Partially mapped crossover (PMX)</p>
  <pre class="programlisting">Input: two parents P1 and P2
Output: two children C1 and C2
1. Initialize: Choose two random crossover points and copy the segment between these two points from parent P1 to child C1 and from the second parent P2 to the second child C2.
2. For each element in the copied segment of C1:
3.   Find the corresponding element in P2's segment. 
4.   If the corresponding element is not already in C1:
5.      Replace the element in C1 at the same position as in P2 with the 
        corresponding element from P2.
6. Fill the remaining positions in the offspring with the elements from the other parent, ensuring that no duplicates are introduced.
7. Repeat steps 2-6 for the second offspring, using P1's segment as the reference.
8. Return C1 and C2.</pre>

  <p class="body">Figure 8.5 illustrates these steps for an 8-city TSP. In step 1, two random crossover points are chosen, and the cities between these two points are copied from parent P1 to child C1 and from the second parent P2 to the second child C2. Then we follow steps 2 to 5 for the cities that were not included in step 1. For the first city in C1, which is 3, we need to find the corresponding city in the P2 segment, which is 7. City 7 is not already included in C1, so we need to place city 7 in the place where city 3 appears in P2, which is the last position on the right, as shown by the solid black arrow in figure 8.5.<a id="marker-284"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F05_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.5 Partially mapped crossover (PMX)</p>
  </div>

  <p class="body">The following listing shows code that performs a partially mapped crossover on two parents to generate two offspring.</p>

  <p class="fm-code-listing-caption">Listing 8.2 Partially mapped crossover (PMX)</p>
  <pre class="programlisting">import random
 
def partially_mapped_crossover(parent1, parent2):
 
    n = len(parent1)
 
    point1, point2 = sorted(random.sample(range(n), 2))     <span class="fm-combinumeral">①</span>
 
    child1 = [None] * n                                     <span class="fm-combinumeral">②</span>
    child2 = [None] * n                                     <span class="fm-combinumeral">②</span>
    child1[point1:point2+1] = parent1[point1:point2+1]      <span class="fm-combinumeral">②</span>
    child2[point1:point2+1] = parent2[point1:point2+1]      <span class="fm-combinumeral">②</span>
    
    for i in range(n):                                      <span class="fm-combinumeral">③</span>
        if child1[i] is None:                               <span class="fm-combinumeral">③</span>
            value = parent2[i]                              <span class="fm-combinumeral">③</span>
            while value in child1:                          <span class="fm-combinumeral">③</span>
                value = parent2[parent1.index(value)]       <span class="fm-combinumeral">③</span>
            child1[i] = value                               <span class="fm-combinumeral">③</span>
 
        if child2[i] is None:
            value = parent1[i]
            while value in child2:
                value = parent1[parent2.index(value)]
            child2[i] = value
 
    return child1, child2                                   <span class="fm-combinumeral">④</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Select two random crossover points.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Copy the segment between crossover points from a parent to a child.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Map the remaining elements from the other parent.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Return the generated offspring.</p>

  <p class="body"><a id="marker-285"/>Running this code will produce output like that shown in figure 8.6, depending on the generated random sample.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F06_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.6 PMX results</p>
  </div>

  <p class="body">The complete version of listing 8.2 is available in the book’s GitHub repository.</p>

  <p class="fm-head2">Edge crossover</p>

  <p class="body">The <i class="fm-italics">edge crossover</i> (EC) method preserves the connectivity and adjacency information between elements from the parent chromosomes. In order to achieve this, an <i class="fm-italics">edge table</i> (or <i class="fm-italics">adjacency list</i>) is constructed. For example, in the 8-cities TSP, the edge table for two parents P1 = [1, 2, 3, 4, 5, 6, 7, 8] and P2 = [1, 6, 7, 8, 5, 2, 4, 3] is created by counting the adjacent elements in both parents, as in table 8.5. The “+” signs in the table denote a common edge between the two parents.<a id="idIndexMarker072"/><a id="idIndexMarker073"/><a id="idIndexMarker074"/><a id="idIndexMarker075"/><a id="idIndexMarker076"/><a id="idIndexMarker077"/><a id="marker-286"/></p>

  <p class="fm-table-caption">Table 8.5 An edge table (or adjacency list)</p>

  <table border="1" class="contenttable-1-table" id="table005" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="11.11%"/>
      <col class="contenttable-0-col" span="1" width="11.11%"/>
      <col class="contenttable-0-col" span="1" width="11.11%"/>
      <col class="contenttable-0-col" span="1" width="11.11%"/>
      <col class="contenttable-0-col" span="1" width="11.11%"/>
      <col class="contenttable-0-col" span="1" width="11.11%"/>
      <col class="contenttable-0-col" span="1" width="11.11%"/>
      <col class="contenttable-0-col" span="1" width="11.11%"/>
      <col class="contenttable-0-col" span="1" width="11.11%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1">
          <p class="fm-table-head">City</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">2</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">3</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">4</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">5</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">6</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">7</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">8</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1">
          <p class="fm-table-head">Edges</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">2,8,6,3</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1,3,5,4</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">2,4+,1</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">3+,5,2</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">4,6,8,2</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">5,7+,1</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">6+,8+</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">7+,1,5</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">Algorithm 8.2 shows the steps involved in edge crossover.</p>

  <p class="fm-code-listing-caption">Algorithm 8.2 Edge crossover (EC)</p>
  <pre class="programlisting">Input: two parent P1 and P2
Output: offspring C
1. Construct an edge table.
2. Start by selecting an arbitrary element from one of the parents as the starting point for the offspring.
3. For the current element in the offspring, compare its edges.
4. If an edge is common in both parents, choose that as the next element in the offspring.
5. If there is no common edge or the common edge is already in the offspring, choose the next element from the parent with the shortest edge list.
6. Repeat until the offspring is complete.
7. Return C</pre>

  <p class="body">Figure 8.7 illustrates these steps for the 8-cities TSP. This figure illustrates how to construct the edge table or adjacency list of each city. The process of counting the edges is shown in this figure. For example, cities 3 and 5 are adjacent cities or edges to city 4 in the first parent. In the second parent, cities 2 and 3 are edges for city 4. This means that city 3 is a common edge.</p>

  <p class="body">Creating a child starts by selecting city 1 randomly or as a home city. In the second row of the table, we list the adjacent cities of city 1, which are 2, 8, 6 and 3. Note that cities loop around, meaning city 1 is adjacent to city 8 in the first parent, and city 1 is adjacent to city 3 in the second parent. Discarding the already visited city 1, these cities have the following adjacent cities {3,5,4} for city 2, {7,5} for city 8, {5,7} for city 6, and {2,4} for city 3. We discard city 2, as it has three adjacent cities, and we select city 3 arbitrarily from 8, 6, and 3, as they have the same number of edges. We keep adding cities to the child following algorithm 8.2 until all the cities are added.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F07_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.7 Edge crossover</p>
  </div>

  <p class="body">The complete version of listing 8.2 is available in the book’s GitHub repository. It shows the Python implementation of edge crossover with a TSP example.</p>

  <p class="fm-head2">Order 1 crossover</p>

  <p class="body"><i class="fm-italics">Order 1 crossover</i> (OX1) creates offspring by combining the genetic information from two parent chromosomes while preserving the relative order of the elements in the resulting solutions. Algorithm 8.3 shows the steps involved in order 1 crossover.<a id="marker-287"/><a id="idIndexMarker078"/><a id="idIndexMarker079"/><a id="idIndexMarker080"/><a id="idIndexMarker081"/></p>

  <p class="fm-code-listing-caption">Algorithm 8.3 Order 1 crossover (OX1)</p>
  <pre class="programlisting">Input: two parents P1 and P2
Output: offspring C1 and C2
1. Choose two random crossover points within the chromosomes and copy the segment between the crossover points from P1 to C1 and from P2 to C2.
2. Starting from the second crossover point, go through the remaining elements in P2.
3. If an element is not already present in C1, append it to the end in the same order as it appears in P2.
4. Wrap around P2 and continue appending the elements until C1 is complete.
Repeat steps 2-4 for C2, using P1 as the reference.
5. Return C1 and C2</pre>

  <p class="body">Figure 8.8 illustrates these steps for the 8-cities TSP. Starting from the second crossover point, cities 4 and 3 cannot be added, as they are already included in C1. The next element in P2 is city 1, so it is added to C1 after the second crossover point, followed by city 7, as city 6 is already included. City 8 is added next, followed by city 2, as city 5 is already included in C1.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F08_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.8 Order 1 crossover (OX1)—The numbers in circles show the sequence in which elements are added from parent 2 to child 1.</p>
  </div>

  <p class="body">The complete version of listing 8.2 is available in the book’s GitHub repository, and it shows the Python implementation of OX1 with the TSP example.</p>

  <p class="fm-head2">Cycle crossover</p>

  <p class="body"><a id="marker-288"/><i class="fm-italics">Cycle crossover</i> (CX) operates by dividing the elements into cycles, where a <i class="fm-italics">cycle</i> is a subset of elements that consistently appear together in pairs when the two parent chromosomes are aligned. Given two parents, a cycle is formed by selecting an element from the first parent, finding its corresponding position in the second parent, and then repeating this process with the element at that position until returning to the starting element. The CX operator effectively combines the genetic information from both parents while preserving the order and adjacency relationships among the elements in the resulting offspring and maintaining the feasibility and diversity of the offspring solutions. Algorithm 8.4 shows the steps of this crossover method.<a id="idIndexMarker082"/><a id="idIndexMarker083"/><a id="idIndexMarker084"/><a id="idIndexMarker085"/><a id="idIndexMarker086"/></p>

  <p class="fm-code-listing-caption">Algorithm 8.4 Cycle crossover (CX)</p>
  <pre class="programlisting">Input: two parents P1 and P2
Output: offspring C1 and C2
1. Identify cycles between the two parents. A cycle of elements from a parent P1 is created following these steps:
    a) Begin with the starting element of P1.
    b) Look at the element at the corresponding position in P2.
    c) Move to the position with the same element in P1.
    d) Include this element in the cycle.
    e) Iterate through steps b to d until you reach the starting element of P1.
2. Create offspring by placing the elements of the identified cycles, preserving their positions from the corresponding parents.
3. Fill in the remaining positions in C1 with elements from P2 and the remaining positions of C2 with elements from P1 that were not included in the identified cycles. Maintain the order of the elements as they appear in the parents.
4. Return C1 and C2.</pre>

  <p class="body">Figure 8.9 illustrates these steps for the 10-cities TSP.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F09_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.9 Cycle crossover (CX)</p>
  </div>

  <p class="body"><a id="marker-289"/>A Python implementation of CX with a TSP example is included in the complete version of listing 8.2, available in the book’s GitHub repository. It’s important to note that the performance of crossover operators is often problem-dependent and may also be influenced by the specific parameter settings of the genetic algorithm, such as population size, mutation rate, and selection pressure. Therefore, it is recommended that you experiment with different crossover operators and fine-tune the genetic algorithm’s parameters to suit the problem being addressed.<a id="idIndexMarker087"/><a id="idIndexMarker088"/><a id="idIndexMarker089"/></p>

  <h3 class="fm-head1" id="heading_id_9">8.3.2 Mutation methods</h3>

  <p class="body">Insert, swap, inversion, and scramble are commonly used mutation methods in permutation-based GA. These methods are designed to introduce small perturbations to the solution while still preserving its feasibility:<a id="idIndexMarker090"/><a id="idIndexMarker091"/><a id="idIndexMarker092"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Insert mutation</i>—Pick two gene values at random, and move the second to follow the first, shifting the rest along to accommodate them. This method primarily maintains the order and adjacency information of the genes.<a id="idIndexMarker093"/><a id="marker-290"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Swap mutation</i>—Pick two genes at random, and swap their positions. This method mainly retains adjacency information while causing some disruption to the original order.<a id="idIndexMarker094"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Inversion mutation</i>—Randomly select two genes, and invert the substring between them. This method largely maintains adjacency information but is disruptive to the order information.<a id="idIndexMarker095"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Scramble mutation</i>—Randomly select two gene values, and rearrange the genes between the chosen positions non-contiguously, applying a random order.<a id="idIndexMarker096"/></p>
    </li>
  </ul>

  <p class="body">Figure 8.10 illustrates these methods on the first parent as a selected individual in the 8-cities TSP.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F10_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.10 Mutation methods in permutation-based GA</p>
  </div>

  <p class="body">As a continuation of listing 8.2, the following code snippet shows how you can implement inversion mutation in Python:</p>
  <pre class="programlisting">def inversion_mutation(individual, mutation_rate):
    n = len(individual)
    mutated_individual = individual.copy()
 
    if random.random() &lt; mutation_rate:
        i, j = sorted(random.sample(range(n), 2))
        mutated_individual[i:j+1] = reversed(mutated_individual[i:j+1])
 
    return mutated_individual</pre>

  <p class="body">Running this code will produce output like that in figure 8.11.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F11_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.11 Inversion mutation result</p>
  </div>

  <p class="body">The complete version of listing 8.2, available in the book’s GitHub repository, includes implementations of different crossover and mutation methods commonly used in permutation-based genetic algorithms.<a id="idIndexMarker097"/><a id="idIndexMarker098"/></p>

  <h2 class="fm-head" id="heading_id_10">8.4 Multi-objective optimization</h2>

  <p class="body">As mentioned earlier in section 1.3.2, optimization problems with multiple objective functions are known as multi-objective optimization problems (MOPs). These problems can be handled using a preference-based multi-objective optimization procedure or by using a Pareto optimization approach. In the former approach, the multiple objectives are combined into a single or overall objective function by using a relative preference vector or a weighting scheme to scalarize the multiple objectives. However, finding this preference vector or weight is subjective and sometimes is not straightforward.<a id="marker-291"/><a id="idIndexMarker099"/><a id="idIndexMarker100"/></p>

  <p class="body"><i class="fm-italics">Pareto optimization</i>, named after Italian economist and sociologist Vilfredo Pareto (1848–1923), relies on finding multiple trade-off optimal solutions and choosing one using higher-level information. This procedure tries to find the best trade-off by reducing the number of alternatives to an optimal set of nondominated solutions known as the Pareto front (or Pareto frontier), which can be used to make strategic decisions in multi-objective space. A solution is Pareto optimal if there is no other solution that improves one objective without worsening another objective, in the case of conflicting objective functions. Thus, the optimal solution for MOPs is not a single solution, as for mono-objective or single optimization problems (SOPs), but a set of solutions defined as <i class="fm-italics">Pareto optimal solutions</i>. These Pareto optimal solutions are also known as acceptable, efficient, nondominated, or non-inferior solutions. <i class="fm-italics">Nondominated solutions</i> in Pareto optimization represent the best compromises that are not outperformed by any other solution across multiple conflicting objectives.<a id="idIndexMarker101"/><a id="idIndexMarker102"/><a id="idIndexMarker103"/></p>

  <p class="body">In chapter 1, we looked at an electric vehicles example: acceleration time and driving range are conflicting objective functions, as we need to minimize the acceleration time and maximize the driving range of the vehicle. There is no universal best vehicle that achieves both, as shown in figure 8.12, which is based on real data retrieved from the <i class="fm-italics">Inside EVs</i> website (<a class="url" href="https://insideevs.com/">https://insideevs.com/</a>). For example, the Lucid Air Dream Edition has the highest driving range but not the lowest acceleration time. The dotted line shows the Pareto front—the vehicles that achieve the best trade-off between the acceleration time and the driving range.<a id="marker-292"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F12_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.12 Acceleration time vs. driving range of 19 electric vehicles, as per September 2021</p>
  </div>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">Multi-objective optimization algorithms</p>

    <p class="fm-sidebar-text">There are several algorithms for solving multi-objective optimization problems. The nondominated sorting genetic algorithm (NSGA-II) is one of the most commonly used. Other algorithms include, but are not limited to, the strength Pareto evolutionary algorithm 2 (SPEA2), the Pareto-archived evolution strategy (PAES), the niched-Pareto genetic algorithm (NPGA), multi-objective selection based on dominated hypervolume (SMS-EMOA), and multi-objective evolutionary algorithm based on decomposition (MOEA/D).</p>

    <p class="fm-sidebar-text">These algorithms have their own strengths and weaknesses, and your choice of algorithm will depend on the specific problem being solved and your preferences. NSGA-II has several advantages, such as diversity maintenance, non-dominated sorting, and fast convergence. For more details about multi-objective optimization, see Deb’s “Multi-objective optimization using evolutionary algorithms” [3] and Zitzler’s “Evolutionary algorithms for multiobjective optimization” [4].<a id="idIndexMarker104"/><a id="idIndexMarker105"/><a id="idIndexMarker106"/><a id="idIndexMarker107"/><a id="idIndexMarker108"/><a id="idIndexMarker109"/><a id="idIndexMarker110"/></p>
  </div>

  <p class="body"><a id="marker-293"/>Let’s solve a MOP using NSGA-II in an example. Assume that a manufacturer produces two products, P1 and P2, involving two different machines, M1 and M2. Each machine can only produce one product at a time, and each product has a different production time and cost on each machine:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">P1 requires 2 hours on M1 and 3 hours on M2, with production costs of $100 and $150 respectively.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">P2 requires 4 hours on M1 and 1 hour on M2, with production costs of $200 and $50 respectively.</p>
    </li>
  </ul>

  <p class="body">In each shift, the two machines, M1 and M2, have the capacity of producing 100 units of P1 and 500 units of P2. The manufacturer wants to produce at least 80 units of P1 and 300 units of P2 while minimizing production costs and minimizing the difference in production times between the two machines.</p>

  <p class="body">We’ll let <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">1</sub></span> and <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">2</sub></span> be the number of units of P1 produced on M1 and M2, respectively, and <span class="times"><i class="fm-italics">y</i><sub class="fm-subscript">1</sub></span> and <span class="times"><i class="fm-italics">y</i><sub class="fm-subscript">2</sub></span> be the number of units of P2 produced on M1 and M2, respectively. The problem can be formulated as follows:</p>

  <div class="figure">
    <p class="figured"><img alt="" class="calibre4" src="../Images/CH08_F12_Khamis-EQ05.png"/></p>
  </div>

  <p class="body">Subject to:</p>

  <div class="figure">
    <p class="figured"><img alt="" class="calibre4" src="../Images/CH08_F12_Khamis-EQ06.png"/></p>
  </div>

  <p class="body">The first objective function (<span class="times"><i class="fm-italics">f</i><sub class="fm-subscript">1</sub></span>) represents the total production costs, and the second objective function (<span class="times"><i class="fm-italics">f</i><sub class="fm-subscript">2</sub></span>) represents the difference in production times between the two machines. Listing 8.3 shows the code for finding the optimal number of units to be produced in a shift using NSGA-II.</p>

  <p class="body">We’ll start by inheriting from <code class="fm-code-in-text">ElementwiseProblem</code>, which allows us to define the optimization problem in an element-wise manner. <code class="fm-code-in-text">n_var</code> specifies the number of variables (4 in this case), <code class="fm-code-in-text">n_obj</code> defines the number of objectives (2), and <code class="fm-code-in-text">n_ieq_constr</code> indicates the number of inequality constraints (2). The <code class="fm-code-in-text">xl</code> and <code class="fm-code-in-text">xu</code> parameters define the lower and upper bounds for each variable respectively. The <code class="fm-code-in-text">_evaluate</code> method takes an input <code class="fm-code-in-text">x</code> (a solution candidate) and computes the objective values <code class="fm-code-in-text">f1</code> and <code class="fm-code-in-text">f2</code>, as well as the inequality constraints <code class="fm-code-in-text">g1</code> and <code class="fm-code-in-text">g2</code>. The third constraint is boundary constraint represented by the lower and upper bounds of the decision variables.<a id="idIndexMarker111"/><a id="marker-294"/></p>

  <p class="fm-code-listing-caption">Listing 8.3 Solving a manufacturing problem using NSGA-II</p>
  <pre class="programlisting">import numpy as np
import matplotlib.pyplot as plt
from pymoo.core.problem import ElementwiseProblem               <span class="fm-combinumeral">①</span>
 
class ManufacturingProblem(ElementwiseProblem):
 
    def __init__(self):
        super().__init__(n_var=4,
                         n_obj=2,
                         n_ieq_constr=2,
                         xl=np.array([0,0,0,0]),
                         xu=np.array([100,100,500,500]))        <span class="fm-combinumeral">②</span>
 
    def _evaluate(self, x, out, *args, **kwargs):
        f1 = 100*x[0] + 150*x[1] + 200*x[2] + 50*x[3]           <span class="fm-combinumeral">③</span>
        f2 = np.abs((2*x[0] + 4*x[2]) - (3*x[1] + x[3]))        <span class="fm-combinumeral">④</span>
 
        g1 = -x[0] - x[1] + 80                                  <span class="fm-combinumeral">⑤</span>
        g2 = -x[2] - x[3] + 300                                 <span class="fm-combinumeral">⑤</span>
 
        out["F"] = [f1, f2]
        out["G"] = [g1, g2]
 
problem = ManufacturingProblem()</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Import an instance of the problem class.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Define the number of variables, objective functions, constraints, and lower and upper bounds.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Total production costs as a first-objective function</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Difference in production times between the two machines as a second-objective function</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Define the constraints.</p>

  <p class="body">We can now set up an instance of the NSGA-II algorithm as the solver:</p>
  <pre class="programlisting">from pymoo.algorithms.moo.nsga2 import NSGA2                       <span class="fm-combinumeral">①</span>
from pymoo.operators.crossover.sbx import SBX                      <span class="fm-combinumeral">②</span>
from pymoo.operators.mutation.pm import PM                         <span class="fm-combinumeral">③</span>
from pymoo.operators.sampling.rnd import FloatRandomSampling       <span class="fm-combinumeral">④</span>
 
algorithm = NSGA2(
    pop_size=40,
    n_offsprings=10,
    sampling=FloatRandomSampling(),
    crossover=SBX(prob=0.9, eta=15),
    mutation=PM(eta=20),
    eliminate_duplicates=True
)                                                                  <span class="fm-combinumeral">⑤</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Import the NSGA-II class.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Import simulated binary crossover (SBX) as a crossover operator.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Import polynomial mutation (PM) as a mutation operator.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Import the FloatRandomSampling method to generate random floating-point values for each variable within a specified range.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Set up an instance of NSGA-II.</p>

  <p class="body">The solver has a population size (<code class="fm-code-in-text">pop_size</code>) of 40 individuals, generates 10 offspring using <code class="fm-code-in-text">FloatRandomSampling</code>, employs SBX crossover with a probability of 0.9, and fine-tunes the exponential distribution with an <code class="fm-code-in-text">eta</code> parameter of 15. PM mutation is used with an <code class="fm-code-in-text">eta</code> parameter of 20. This <code class="fm-code-in-text">eta</code> parameter controls the spread of the mutation distribution. <code class="fm-code-in-text">eliminate_duplicates</code> is set to <code class="fm-code-in-text">True</code> so that duplicate candidate solutions will be removed from the population at each generation. <a id="idIndexMarker112"/><a id="idIndexMarker113"/><a id="idIndexMarker114"/></p>

  <p class="body"><a id="marker-295"/>We define the termination criterion by specifying the number of generations as follows:</p>
  <pre class="programlisting">from pymoo.termination import get_termination
termination = get_termination("n_gen", 40)</pre>

  <p class="body">We can now run the solver to minimize both objective functions simultaneously:</p>
  <pre class="programlisting">from pymoo.optimize import minimize
 
res = minimize(problem,
               algorithm,
               termination,
               seed=1,
               save_history=True,
               verbose=True)
X = res.X
F = res.F</pre>

  <p class="body">Finally, we print the best 10 solutions as follows:</p>
  <pre class="programlisting">print("Solutions found: ")
print("Number of units of product P1 produced on machines M1 and M2\n and 
<span class="fm-code-continuation-arrow">➥</span> Number of units of product P2 produced on machines M1 and M2 are:\n",
<span class="fm-code-continuation-arrow">➥</span> np.asarray(X, dtype = 'int'))
np.set_printoptions(suppress=True, precision=3)
print("The total production costs and \n difference in production times
<span class="fm-code-continuation-arrow">➥</span> between the two machines are:\n",F)</pre>

  <p class="body">This code will produce output representing the best 10 non-dominated solutions obtained by NSGA-II and will look like this:</p>
  <pre class="programlisting">Solutions found: 
Number of units of product P1 produced on machines M1 and M2
and Number of units of product P2 produced on machines M1 and M2 are:
[[ 90  18  39 300]
[ 91  19  39 297]
[ 91  16  12 300]
[ 90  12  30 310]
[ 90  14  21 300]
[ 90  14  47 328]
[ 34  48   1 305]
[ 87  13   3 299]
[ 91  11   7 297]
[ 30  51   0 300]]
The total production costs and 
difference in production times between the two machines are:
[[34757.953    16.105]
[34935.538    13.813]
[29235.912   114.763]
[32498.687    43.463]
[30481.316    79.233]
[37228.051     0.652]
[26307.998   378.004]
[26388.316   150.968]
[27199.394   118.385]
[25980.561   392.176]]</pre>

  <p class="body">As there is no universal best solution for these two objective functions, multi-criteria decision-making can be applied to select the best trade-off—the Pareto optimal. In pymoo, the decision-making procedure starts by defining boundary points called <i class="fm-italics">ideal</i> and <i class="fm-italics">nadir</i> points: <a id="idIndexMarker115"/><a id="idIndexMarker116"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">The ideal point</i>—This refers to the best possible values for each objective function that can be achieved in the entire feasible region of the problem. This point represents the scenario where all the objective functions are minimized simultaneously.<a id="idIndexMarker117"/><a id="marker-296"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">The nadir point</i>—This is the point where each objective function is maximized while satisfying all the constraints of the problem. It is the opposite of the ideal point and represents the worst possible values for each objective function in the entire feasible region of the problem.<a id="idIndexMarker118"/></p>
    </li>
  </ul>

  <p class="body">These points are used in multi-objective optimization problems to normalize the objective functions and convert them to a common scale, allowing for a fair comparison of different solutions. The two points are calculated as follows:</p>
  <pre class="programlisting">approx_ideal = F.min(axis=0)
approx_nadir = F.max(axis=0)
nF = (F - approx_ideal) / (approx_nadir - approx_ideal)</pre>

  <p class="body">We then define weights, which are required by the decomposition functions, based on the level of importance of each objective function from the developer’s perspective:</p>
  <pre class="programlisting">weights = np.array([0.2, 0.8])      <span class="fm-combinumeral">①</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Weights for f1 and f2 respectively</p>

  <p class="body">A decomposition method is defined using the augmented scalarization function (ASF), discussed in Wierzbicki’s “The use of reference objectives in multiobjective optimization” [5]:<a id="idIndexMarker119"/></p>
  <pre class="programlisting">from pymoo.decomposition.asf import ASF
decomp = ASF()</pre>

  <p class="body">To find the best solutions, we choose the minimum ASF values calculated from all the solutions and use the inverse of the weights as required by ASF:</p>
  <pre class="programlisting">i = decomp.do(nF, 1/weights).argmin()
 
print("Best regarding ASF: Point \ni = %s\nF = %s" % (i, F[i]))
 
plt.figure(figsize=(7, 5))
plt.scatter(F[:, 0], F[:, 1], s=30, facecolors='none', edgecolors='blue')
plt.scatter(F[i, 0], F[i, 1], marker="x", color="red", s=200)
plt.title("Objective Space")
plt.xlabel("Total production costs")
plt.ylabel("Difference in production times")
plt.show()</pre>

  <p class="body"><a id="marker-297"/>The output is shown in figure 8.13.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F13_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.13 Manufacturing problem solution—the point marked with the X represents the selected Pareto optimal or best trade-off.</p>
  </div>

  <p class="body">Running the code produces the following output:</p>
  <pre class="programlisting">The best solution found: 
Number of units of product P1 produced on machines M1 and M2 are 90 and 12 respectively
Number of units of product P2 produced on machines M1 and M2 are 30 and 310 respectively
The total production costs are 32498.69
The difference in production times between the two machines is 43</pre>

  <p class="body">The complete version of listing 8.3 is available in the book’s GitHub repository. It includes another method using pseudo-weights to choose a solution from a solution set in the context of multi-objective optimization.<a id="idIndexMarker120"/><a id="idIndexMarker121"/></p>

  <h2 class="fm-head" id="heading_id_11">8.5 Adaptive GA</h2>

  <p class="body">Adaptation methods help genetic algorithms strike a balance between exploration and exploitation, using different parameters such as initialization population size, crossover operators, and mutation operators. These parameters can be deterministically or dynamically adapted based on the search progress, allowing the algorithm to converge on high-quality solutions for complex optimization problems. <a id="idIndexMarker122"/><a id="idIndexMarker123"/><a id="marker-298"/></p>

  <p class="body">For example, population size can be adaptive. A larger population size promotes diversity and exploration, while a smaller size allows for faster convergence. The population size can be increased if the algorithm is struggling to find better solutions or decreased if the population has become too diverse.</p>

  <p class="body">Mutation operator parameters can be used to adapt the genetic algorithm and balance its exploration and exploitation aspects. For example, in the case of Gaussian mutation, we can adaptively set the value of the standard deviation <i class="timesitalic">σ</i> of the Gaussian distribution during the run. The standard deviation of the Gaussian distribution can be changed following a deterministic approach, an adaptive approach, or a self-adaptive approach. If you’re using a deterministic approach, the value of <i class="timesitalic">σ</i> can be calculated in each generation using this formula: <span class="times"><i class="fm-italics">σ</i>(<i class="fm-italics">i</i>) = 1 – 0.9 * <i class="fm-italics">i</i>/ <i class="fm-italics">N</i></span> where <i class="timesitalic">i</i> is the generation number, ranging from 0 to <i class="timesitalic">N</i> (the maximum generation number). In this case, the value of <i class="timesitalic">σ</i> is 1 at the beginning of the optimization process and gradually reduces to 0.1 toward the end to move the search algorithm’s behavior from exploration to exploitation. <a id="idIndexMarker124"/></p>

  <p class="body">The adaptive approach incorporates feedback from the search process to adjust the variance and improve the search performance. Rechenberg’s <i class="fm-italics">1/5 success rule</i> is a well-known method that adjusts the step size of the search by monitoring the success rate of the search. This rule involves increasing the variance if a certain percentage of the previous mutations were successful in finding better solutions (i.e., if there was more than one successful mutation out of five tries), favoring exploration in order to avoid getting trapped in local optima. Otherwise, if there was a lower success rate, the variance should be decreased to favor exploitation. This allows the search to fine-tune its parameters based on its progress, leading to better performance and faster convergence to optimal solutions. <a id="idIndexMarker125"/></p>

  <p class="body">Figure 8.14 shows the steps of applying Rechenberg’s 1/5 success rule. This update rule is applied in every generation, and a constant <span class="times">0.82 &lt;= <i class="fm-italics">c</i> &lt;= 1</span> is used to update the standard deviation of the Gaussian distribution. As you can see, the higher the standard deviation, the higher the value of <i class="timesitalic">x</i>, and the higher the deviation from the current solution (more exploration), and vice versa.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F14_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.14 Rechenberg’s 1/5 success rule. Following this rule, the Gaussian distribution’s standard deviation is updated by a constant. The higher the standard deviation, the higher the value of <i class="fm-italics">x</i> (i.e., larger step size), the higher the deviation from the current solution (more exploration), and vice versa.</p>
  </div>

  <p class="body"><a id="marker-299"/>The self-adaptive approach incorporates the mutation step size into each individual—a technique originally employed in evolution strategies (ES). In this method, the value of <i class="fm-italics">σ</i> (the standard deviation or the mutation step size) evolves alongside the individual, resulting in distinct mutation step sizes for each individual in the population. The following equations are used in this self-adaptive approach:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH08_F14_Khamis-EQ07.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">8.2</p>
        </td>
      </tr>
    </tbody>
  </table>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH08_F14_Khamis-EQ08.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">8.3</p>
        </td>
      </tr>
    </tbody>
  </table><!--<p class="FM-Equation"><i class="FM-Italics">σ</i>’ = <i class="FM-Italics">σ</i> <i class="FM-Italics">e<sup class="FM-Superscript">N</sup></i><sup class="FM-Superscript">(0,</sup><i class="FM-Italics"><sup class="FM-Superscript">𝜏<sub class="FM-Subscript">o</sub>)</sup></i></p>-->

  <p class="body">where <i class="timesitalic">τ<sub class="fm-subscript">o</sub></i> is the learning rate.</p>

  <p class="body">Now that you have a solid understanding of the various components of GAs, we can apply this powerful optimization technique to real-world problems. In the following sections, we will use GAs to solve three distinct problems: the traveling salesman problem, tuning the parameters of a PID controller, and the political districting problem.</p>

  <h2 class="fm-head" id="heading_id_12">8.6 Solving the traveling salesman problem</h2>

  <p class="body"><a id="marker-300"/>Let’s consider the following traveling salesman problem (TSP) for 20 major cities in the USA, starting from New York City, as illustrated in figure 8.15.<a id="idIndexMarker126"/><a id="idIndexMarker127"/><a id="idIndexMarker128"/><a id="idIndexMarker129"/><a id="idIndexMarker130"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F15_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.15 The 20 major US cities TSP</p>
  </div>

  <p class="body">In listing 8.4, we start by importing the libraries we’ll use and defining the TSP. First, we define the city names and their latitudes and longitudes. We then use those coordinates to create a haversine distance matrix and then convert the data dictionary into a dataframe.</p>

  <p class="fm-code-listing-caption">Listing 8.4 Solving TSP using GA</p>
  <pre class="programlisting">import numpy as np
import pandas as pd
import networkx as nx
from collections import defaultdict
from haversine import haversine
import matplotlib.pyplot as plt
from pymoo.core.problem import ElementwiseProblem
from pymoo.core.repair import Repair
from pymoo.algorithms.soo.nonconvex.ga import GA
from pymoo.optimize import minimize
from pymoo.operators.sampling.rnd import PermutationRandomSampling
from pymoo.operators.crossover.ox import OrderCrossover
from pymoo.operators.mutation.inversion import InversionMutation
from pymoo.termination.default import DefaultSingleObjectiveTermination
from pymoo.optimize import minimize
 
cities = {
    'New York City': (40.72, -74.00),
    'Philadelphia': (39.95, -75.17),       
    'Baltimore': (39.28, -76.62),
    'Charlotte': (35.23, -80.85),
    'Memphis': (35.12, -89.97),
    'Jacksonville': (30.32, -81.70),
    'Houston': (29.77, -95.38),
    'Austin': (30.27, -97.77),
    'San Antonio': (29.53, -98.47),
    'Fort Worth': (32.75, -97.33),
    'Dallas': (32.78, -96.80),
    'San Diego': (32.78, -117.15),
    'Los Angeles': (34.05, -118.25),
    'San Jose': (37.30, -121.87),
    'San Francisco': (37.78, -122.42),    
    'Indianapolis': (39.78, -86.15),
    'Phoenix': (33.45, -112.07),       
    'Columbus': (39.98, -82.98), 
    'Chicago': (41.88, -87.63),
    'Detroit': (42.33, -83.05)
}                                                                      <span class="fm-combinumeral">①</span><a id="marker-301"/>
 
distance_matrix = defaultdict(dict)                                    <span class="fm-combinumeral">②</span>
for ka, va in cities.items():
    for kb, vb in cities.items():
        distance_matrix[ka][kb] = 0.0 if kb == ka else haversine((va[0], va[1]),
<span class="fm-code-continuation-arrow">➥</span> (vb[0], vb[1]))                                                     <span class="fm-combinumeral">②</span>
        
distances = pd.DataFrame(distance_matrix)                              <span class="fm-combinumeral">③</span>
city_names=list(distances.columns)                                     <span class="fm-combinumeral">③</span>
distances=distances.values                                             <span class="fm-combinumeral">③</span>
 
G=nx.Graph()                                                           <span class="fm-combinumeral">④</span>
for ka, va in cities.items():                                          <span class="fm-combinumeral">④</span>
    for kb, vb in cities.items():                                      <span class="fm-combinumeral">④</span>
        G.add_weighted_edges_from({(ka,kb, distance_matrix[ka][kb])})  <span class="fm-combinumeral">④</span>
        G.remove_edges_from(nx.selfloop_edges(G))                      <span class="fm-combinumeral">④</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Define city names, latitudes, and longitudes for 20 major US cities.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Create a haversine distance matrix based on latitude-longitude coordinates.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Convert the distance dictionary into a dataframe.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Create a networkx graph.</p>

  <p class="body">We can then create <code class="fm-code-in-text">TravelingSalesman</code> as a subclass of the <code class="fm-code-in-text">ElementwiseProblem</code> class available in pymoo. This class defines the number of cities and the intercity distances as problem parameters, and it evaluates the total path length as an objective function to be minimized: <a id="idIndexMarker131"/><a id="idIndexMarker132"/></p>
  <pre class="programlisting">class TravelingSalesman(ElementwiseProblem):
 
    def __init__(self, cities, distances, **kwargs):
        self.cities = cities
        n_cities = len(cities)
        self.distances = distances
 
        super().__init__(
            n_var=n_cities,
            n_obj=1,
            xl=0,
            xu=n_cities,
            vtype=int,
            **kwargs
        )
 
    def _evaluate(self, x, out, *args, **kwargs):
        f = 0
        for i in range(len(x) - 1):
            f += distances[x[i], x[i + 1]]
        f += distances[x[-1], x[0]]
        out["F"] = f</pre>

  <p class="body">The following function is a subclass of the <code class="fm-code-in-text">Repair</code> class, and it provides a method to repair solutions for the TSP, ensuring that each solution starts with the city indexed as 0 (New York City, in this example). The repair operator in pymoo is used to make sure the algorithm is only searching the feasible space. It is applied after the offspring have been reproduced:<a id="idIndexMarker133"/><a id="marker-302"/></p>
  <pre class="programlisting">class StartFromZeroRepair(Repair):
 
    def _do(self, problem, X, **kwargs):
        I = np.where(X == 0)[1]
 
        for k in range(len(X)):
            i = I[k]
            X[k] = np.concatenate([X[k, i:], X[k, :i]])
 
        return X</pre>

  <p class="body">It’s time now to define a GA solver and apply it to solve the problem.</p>
  <pre class="programlisting">problem = TravelingSalesman(cities,distance_matrix)                          <span class="fm-combinumeral">①</span>
 
algorithm = GA(
    pop_size=20,
    sampling=PermutationRandomSampling(),
    mutation=InversionMutation(),
    crossover=OrderCrossover(),
    repair=StartFromZeroRepair(),
    eliminate_duplicates=True
)                                                                             <span class="fm-combinumeral">②</span>
 
termination = DefaultSingleObjectiveTermination(period=300, n_max_gen=np.inf) <span class="fm-combinumeral">③</span>
 
res = minimize(
    problem,
    algorithm,
    termination,
    seed=1,
    verbose=False
)                                                                              <span class="fm-combinumeral">④</span> </pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Create a TSP instance for the given cities and intercity distances.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Define the GA solver.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Terminate (and disable the max generations) if the algorithm did not improve in the last 300 generations.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Find the shortest path.</p>

  <p class="body"><a id="marker-303"/>We can print the found route and its length as follows:</p>
  <pre class="programlisting">Order = res.X
Route = [city_names[i] for i in Order]
arrow_route = ' → '.join(Route)
print("Route:", arrow_route)
print("Route length:", np.round(res.F[0], 3))
print("Function Evaluations:", res.algorithm.evaluator.n_eval)</pre>

  <p class="body">This results in the following output:</p>
  <pre class="programlisting">Route: New York City → Detroit → Columbus → Indianapolis → Chicago → San Francisco → San Jose → Los Angeles → San Diego → Phoenix → San Antonio → Austin → Houston → Fort Worth → Dallas → Memphis → Jacksonville → Charlotte → Baltimore → Philadelphia
Route length: 10934.796
Function Evaluations: 6020</pre>

  <p class="body">The following code is used to visualize the obtained route using NetworkX:</p>
  <pre class="programlisting">fig, ax = plt.subplots(figsize=(15,10))
 
H = G.copy()                                                               <span class="fm-combinumeral">①</span>
 
reversed_dict = {key: value[::-1] for key, value in cities.items()}        <span class="fm-combinumeral">②</span>
 
keys_list = list(cities.keys())                                            <span class="fm-combinumeral">③</span>
 
included_cities = {keys_list[index]: cities[keys_list[index]] for index in <span class="fm-combinumeral">④</span>
<span class="fm-code-continuation-arrow">➥</span> list(res.X)}                                                            <span class="fm-combinumeral">④</span>
included_cities_keys=list(included_cities.keys())                          <span class="fm-combinumeral">④</span>
 
edge_list =list(nx.utils.pairwise(included_cities_keys))                   <span class="fm-combinumeral">⑤</span>
 
nx.draw_networkx_edges(H, pos=reversed_dict, edge_color="gray", width=0.5) <span class="fm-combinumeral">⑥</span>
 
ax=nx.draw_networkx(
    H,
    pos=reversed_dict,
    with_labels=True,
    edgelist=edge_list,
    edge_color="red",
    node_size=200,
    width=3,
)                                                                          <span class="fm-combinumeral">⑦</span>
plt.show()                                                                 <span class="fm-combinumeral">⑦</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Create an independent shallow copy of the problem graph and attributes.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Reverse latitude and longitude for correct visualization.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Create a list of keys in the original dictionary.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Create a new dictionary with the keys in the desired order.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Create an edge list.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Draw the closest edges on each node only.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑦</span> Draw and show the route.</p>

  <p class="body">Figure 8.16 shows the obtained route for this traveling salesman problem.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F16_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.16 The 20 major US cities TSP solution</p>
  </div>

  <p class="body">You can experiment with the full code in the book’s GitHub repository by changing the problem data and the genetic algorithm parameters, such as population size, sampling, crossover, and mutation methods.<a id="idIndexMarker134"/><a id="idIndexMarker135"/><a id="idIndexMarker136"/><a id="idIndexMarker137"/><a id="idIndexMarker138"/><a id="marker-304"/></p>

  <h2 class="fm-head" id="heading_id_13">8.7 PID tuning problem</h2>

  <p class="body">Have you ever wondered how your room stays at a comfortable temperature? Have you ever thought about how the heating or cooling system knows when to turn on and off automatically to maintain the temperature set on the thermostat? This is where control systems come into the picture. Control systems are like behind-the-scenes wizards that ensure things work smoothly and efficiently. They are sets of rules and mechanisms that guide devices or processes to achieve specific goals. <a id="idIndexMarker139"/><a id="idIndexMarker140"/></p>

  <p class="body">One type of control system is a <i class="fm-italics">closed-loop system</i>. Picture this: you’ve set your room’s thermostat to a cozy 22°C (72°F), and the heating or cooling system kicks in to reach that temperature. But what happens if it becomes too chilly or too warm? That’s when the closed-loop system starts to take action. It’s continually tracking the room’s current temperature, comparing it to the desired temperature, and making the necessary heating or cooling tweaks.<a id="idIndexMarker141"/></p>

  <p class="body">The proportional integral derivative (PID) controller is the most commonly used algorithm in control systems engineering. This controller is designed to compensate for any error between the measured state (e.g., the current room temperature) and the desired state (e.g., the desired temperature value). Let’s consider room temperature control using a PID controller as an example. <a id="idIndexMarker142"/></p>

  <p class="body">As shown in figure 8.17, the controller takes the error signal <i class="fm-italics">e</i>(<i class="fm-italics">t</i>) (the difference between the desired state and the feedback signal) and produces the appropriate control signal <i class="fm-italics">u</i>(<i class="fm-italics">t</i>) to turn on or off the heater in order to minimize the difference between the current room temperature and the desired value. The control signal is calculated using equation 8.4:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH08_F16_Khamis-EQ09.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">8.4</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body"><a id="marker-305"/>As shown in this equation, the <i class="fm-italics">proportional term</i> <span class="times"><i class="fm-italics">K<sub class="fm-subscript">p</sub>e</i>(<i class="fm-italics">t</i>)</span> tends to produce a control signal that is proportional to the error and aims to rectify it. The <i class="fm-italics">integral term</i> (the second term on the right side of the equation) tends to produce a control signal that is proportional to the magnitude of the error and its duration, or the area under the error curve. The <i class="fm-italics">derivative term</i> (the third term on the right side of the equation) tends to produce a control signal that is proportional to the rate of error change, thus providing an anticipatory control signal.<a id="idIndexMarker143"/><a id="idIndexMarker144"/><a id="idIndexMarker145"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F17_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.17 PID-based closed-loop control system—the PID controller takes the error signal and produces a control signal to reduce the error to zero.</p>
  </div>

  <p class="body">Utilizing a PID controller allows the system (e.g., an air conditioner or heater) to follow the specified input and attain a desired or optimal steady-state error, rise time, settling time, and overshoot:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Rise time</i>—The rise time is the time required for the response to rise from 10% to 90% of its final value. <a id="idIndexMarker146"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Peak overshoot</i>—The peak overshoot (aka maximum overshoot) is the deviation of the response at peak time from the final value of the response. <a id="idIndexMarker147"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Settling time</i>—The settling time is the time required for the response to reach the steady state and stay within the specified tolerance bands (e.g., 2–5% of the final value) after the transient response has settled. <a id="idIndexMarker148"/><a id="marker-306"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Steady-state error</i>—The steady-state error is the difference between the desired value and the actual value of the system output when the system has reached a stable condition. <a id="idIndexMarker149"/></p>
    </li>
  </ul>

  <p class="body">As shown in figure 8.18, the heater is turned on (i.e., energized) when the current room temperature is lower than the set point or the desired value. The heater is turned off (i.e., de-energized) when the temperature is above the set point.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F18_new_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.18 Step response of a system. The heater is turned on or off according to the difference between the actual temperature and the desired value.</p>
  </div>

  <p class="body">Table 8.6 shows the effect of PID controller parameters on the time response of the system. Note that these correlations may not be exactly accurate, because <i class="timesitalic">K<sub class="fm-subscript">p</sub>, K<sub class="fm-subscript">i</sub></i>, and <i class="timesitalic">K<sub class="fm-subscript">d</sub></i> are dependent on each other. In fact, changing one of these variables can change the effect of the other two. For this reason, the table should only be used as a reference when you are determining the values for <i class="timesitalic">K<sub class="fm-subscript">p</sub>, K<sub class="fm-subscript">i</sub></i>, and <i class="timesitalic">K<sub class="fm-subscript">d</sub></i>.</p>

  <p class="fm-table-caption">Table 8.6 Effects of adding PID controller parameters on the system’s response</p>

  <table border="1" class="contenttable-1-table" id="table006" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="20%"/>
      <col class="contenttable-0-col" span="1" width="20%"/>
      <col class="contenttable-0-col" span="1" width="20%"/>
      <col class="contenttable-0-col" span="1" width="20%"/>
      <col class="contenttable-0-col" span="1" width="20%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Parameter</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Rise time</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Overshoot</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Settling time</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Steady-state error</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body2">K<sub class="fm-subscript">p</sub></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Decreases</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Increases</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Small change</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Decreases</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body2">K<sub class="fm-subscript">i</sub></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Decreases</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Increases</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Increases</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Decreases significantly</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body2">K<sub class="fm-subscript">d</sub></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Small change</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Decreases</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Decreases</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Small change</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body"><a id="marker-307"/>Finding the optimal values of the PID controller parameters for an optimal controller response is a multivariate optimization problem commonly referred to as the <i class="fm-italics">PID tuning problem</i>. The following four performance metrics are commonly used to evaluate the quality of a control system such as a PID controller: <a id="idIndexMarker150"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">ITAE (integral time absolute error)</i>—This metric penalizes errors that persist over time, making it suitable for systems where transient response and settling time are important. It is calculated using this formula: <span class="times">ITAE = ∫(<i class="fm-italics">t</i>|<i class="fm-italics">e</i>(<i class="fm-italics">t</i>)|) <i class="fm-italics">dt</i></span>, where <i class="timesitalic">t</i> is the time, <span class="times"><i class="fm-italics">e</i>(<i class="fm-italics">t</i>)</span> is the error at time <i class="timesitalic">t</i> defined as <span class="times"><i class="fm-italics">e</i>(<i class="fm-italics">t</i>) = <i class="fm-italics">r</i>(<i class="fm-italics">t</i>) – <i class="fm-italics">y</i>(<i class="fm-italics">t</i>), <i class="fm-italics">r</i>(<i class="fm-italics">t</i>)</span> is the reference signal (desired output) at time <i class="timesitalic">t</i> (for step response <span class="times"><i class="fm-italics">r</i>(<i class="fm-italics">t</i>) = 1)</span>, and <span class="times"><i class="fm-italics">y</i>(<i class="fm-italics">t</i>)</span> is the actual output of the system at time <i class="timesitalic">t</i>.<a id="idIndexMarker151"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">ITSE (integral time square error)</i>—Like ITAE, this metric also penalizes errors that last for a long time but places more emphasis on larger errors due to the squared term. It is calculated using this formula: <span class="times">ITSE = ∫(<i class="fm-italics">te</i>(<i class="fm-italics">t</i>)<sup class="fm-superscript">2</sup>) <i class="fm-italics">dt</i></span>.<a id="idIndexMarker152"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">IAE (integral absolute error)</i>—This metric measures the overall magnitude of the error without considering the duration of the error. This is a simple and widely used performance metric, and it’s calculated using this formula: <span class="times">IAE = ∫|<i class="fm-italics">e</i>(<i class="fm-italics">t</i>)| <i class="fm-italics">dt</i></span>.<a id="idIndexMarker153"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">ISE (integral squared error)</i>—This metric emphasizes larger errors due to the squared term, making it useful for systems where minimizing large errors is a priority. It is calculated using this formula: <span class="times">ISE = ∫<i class="fm-italics">e</i>(<i class="fm-italics">t</i>)<sup class="fm-superscript">2</sup> <i class="fm-italics">dt</i></span>. It penalizes errors more heavily if they occur later in the evolution of the response. It also penalizes an error <i class="timesitalic">E</i> for time <i class="timesitalic">dt</i> more heavily than <span class="times"><i class="fm-italics">E</i>/<i class="fm-italics">α</i></span> for time <i class="timesitalic">αdt</i>, where <span class="times"><i class="fm-italics">α</i> &gt; 1</span>. This expected response may have a slow rise time but with a more oscillatory behavior.<a id="idIndexMarker154"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Combined criteria</i>—This metric combines overshoot, rise time, settling time, and steady-state error [6]. It is calculated using this formula: <span class="times"><i class="fm-italics">W</i> = (1 – <i class="fm-italics">e</i><sup class="fm-superscript">–</sup><i class="fm-italics"><sup class="fm-superscript">β</sup></i>)(<i class="fm-italics">M<sub class="fm-subscript">p</sub></i> + error<i class="fm-italics"><sub class="fm-subscript">ss</sub></i>) + <i class="fm-italics">e</i><sup class="fm-superscript">–</sup><i class="fm-italics"><sup class="fm-superscript">β</sup></i> (<i class="fm-italics">t<sub class="fm-subscript">s</sub></i> – <i class="fm-italics">t<sub class="fm-subscript">r</sub></i>)</span>, where <span class="times"><i class="fm-italics">M</i><sub class="fm-subscript">p</sub></span> is the overshoot, <span class="times">error<sub class="fm-subscript">ss</sub></span> is the steady-state error, <i class="timesitalic">t<sub class="fm-subscript">s</sub></i> is the settling time, <i class="timesitalic">t<sub class="fm-subscript">r</sub></i> is the rise time, and <i class="timesitalic">β</i> is a balancing factor in the range of 0.8 to 1.5. You can set <i class="timesitalic">β</i> to be larger than 0.7 to reduce the overshoot and steady-state error. On the other hand, you can set <i class="timesitalic">β</i> to be smaller than 0.7 to reduce the rise time and settling time.<a id="idIndexMarker155"/></p>
    </li>
  </ul>

  <p class="body">Each of these metrics quantifies the error between the desired output and the actual output of the system in different ways, emphasizing different aspects of the control system’s performance. Note that performance metrics are not strictly confined to the aforementioned metrics. Engineers have the flexibility to devise custom performance metrics tailored to the specific goals and characteristics of the control system under consideration.</p>

  <p class="body">Figure 8.19 shows a closed-loop control system where a transfer function is used to describe the relationship between the input and output of the system in a Laplace domain. This domain is a generalization of a frequency domain, providing a more comprehensive representation that includes transient behavior and initial conditions. Assume that <i class="timesitalic">T<sub class="fm-subscript">sp</sub></i> is the set point or the desired output and <i class="timesitalic">G</i> represents the transfer functions indicated in the block diagram.<a id="idIndexMarker156"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F19_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.19 Closed-loop control system</p>
  </div>

  <p class="body"><a id="marker-308"/>All variables are a function of <i class="timesitalic">s</i>, which is the output variable from a Laplace transform. The transfer function of a PID controller is given by this equation: <a id="idIndexMarker157"/></p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH08_F19_Khamis-EQ10.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">8.5</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">where <i class="timesitalic">K<sub class="fm-subscript">p</sub></i> is the proportional gain, <i class="timesitalic">K<sub class="fm-subscript">i</sub></i> is the integral gain, and <i class="timesitalic">K<sub class="fm-subscript">d</sub></i> is the derivative gain. Assume that the transfer function of the HVAC system is given by this equation:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH08_F19_Khamis-EQ11.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">8.6</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">Assuming that <span class="times"><i class="fm-italics">G<sub class="fm-subscript">s</sub></i> = 1</span> (unity feedback) and using block diagram reduction, we can find the overall transfer function <span class="times"><i class="fm-italics">T</i>(<i class="fm-italics">s</i>)</span> of the closed loop system:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH08_F19_Khamis-EQ12.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">8.7</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">Let’s now look at how we can find the optimal values for the PID parameters with Python. In the next listing, we start by importing the libraries we’ll use and defining the overall transfer function of the control system.<a id="marker-309"/></p>

  <p class="fm-code-listing-caption">Listing 8.5 Solving the PID tuning problem using GA</p>
  <pre class="programlisting">import numpy as np
import control                                         <span class="fm-combinumeral">①</span>
import math
import matplotlib.pyplot as plt
from pymoo.algorithms.soo.nonconvex.ga import GA 
from pymoo.operators.crossover.pntx import PointCrossover
from pymoo.operators.mutation.pm import PolynomialMutation
from pymoo.operators.repair.rounding import RoundingRepair
from pymoo.operators.sampling.rnd import FloatRandomSampling
from pymoo.core.problem import Problem
from pymoo.optimize import minimize
 
def transfer_function(Kp,Ki,Kd):                       <span class="fm-combinumeral">②</span>
    num = np.array([Kd,Kp,Ki])                         <span class="fm-combinumeral">③</span>
    den = np.array([1,(Kd+10),(Kp+20),Ki])             <span class="fm-combinumeral">④</span>
    T = control.tf(num, den)                           <span class="fm-combinumeral">⑤</span>
    t, y = control.step_response(T)                    <span class="fm-combinumeral">⑥</span>
    return T, t, y
#A Import the control module.</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Import the control module.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Take PID parameters as input.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Define the numerator of the transfer function.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Define the denominator of the transfer function.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Create a transfer function.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Get time response output using a step function as a system input.</p>

  <p class="body">Next, we can define the objective functions or performance criteria:</p>
  <pre class="programlisting">def objective_function(t, error, Kp,Ki,Kd, criterion):
    
    if criterion == 1:
        ITAE = np.trapz(t, t*error)                                    <span class="fm-combinumeral">①</span>
        objfnc= ITAE
    elif criterion == 2:
        ITSE = np.trapz(t, t*error**2)                                 <span class="fm-combinumeral">②</span>
        objfnc= ITSE
    elif criterion == 3:
        IAE =  np.trapz(t, error)                                      <span class="fm-combinumeral">③</span>
        objfnc= IAE
    elif criterion == 4:
        ISE = np.trapz(t, error**2)                                    <span class="fm-combinumeral">④</span>
        objfnc= ISE
    elif criterion == 5:
        T, _, _ =transfer_function(Kp,Ki,Kd)
        info = control.step_info(T)
        beta = 1
        Mp = info['Overshoot']
        tr = info['RiseTime']
        ts = info['SettlingTime']
        ess = abs(1-info['SteadyStateValue'])
        W = ((1-math.exp(-beta))*(Mp+ess))+((math.exp(-beta))*(ts-tr)) <span class="fm-combinumeral">⑤</span>
        objfnc=W;      
        
    return objfnc</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> ITAE (integral time absolute error)</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> ITSE (integral time square error)</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> IAE (integral absolute error)</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> ISE (integral squared error)</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> W (combined criteria)</p>

  <p class="body">We can now define the optimization problem for the PID controller:</p>
  <pre class="programlisting">class PIDProblem(Problem):
 
    def __init__(self):
        super().__init__(n_var=3,                     <span class="fm-combinumeral">①</span>
                         n_obj=1,                     <span class="fm-combinumeral">②</span>
                         n_constr=0,                  <span class="fm-combinumeral">③</span>
                         xl=0,                        <span class="fm-combinumeral">④</span>
                         xu=100,                      <span class="fm-combinumeral">④</span>
                         vtype=float)    
 
    def _evaluate(self, X, out, *args, **kwargs):     <span class="fm-combinumeral">⑤</span>
        f = np.zeros((X.shape[0], 1))   
        for i, params in enumerate(X):
            Kp, Ki, Kd = params
            T, t, y =transfer_function(Kp,Ki,Kd)
            error = 1 - y
            f[i]=objective_function(t, np.abs(error), Kp,Ki,Kd, 5)            
        out["F"] = f </pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Three decision variables, representing the PID controller’s Kp, Ki, and Kd gains</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Number of objective functions</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> No constraints</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Lower and upper bounds for the decision variables</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Evaluate the objective function.</p>

  <p class="body"><a id="marker-310"/>Next, we can set up and solve the PID tuning problem using GA. The previously defined <code class="fm-code-in-text">PIDProblem</code> class is used to model the optimization problem. The GA solver is configured with a population size of 50. Initial solutions are sampled using <code class="fm-code-in-text">FloatRandomSampling</code>, and the crossover operation employs a two-point crossover with a probability of 0.8. Additionally, polynomial mutation is applied with a probability of 0.3, and the algorithm runs for 60 generations:<a id="idIndexMarker158"/><a id="idIndexMarker159"/></p>
  <pre class="programlisting">problem = PIDProblem()
 
algorithm = GA(
    pop_size=50,
    sampling=FloatRandomSampling(),
    crossover=PointCrossover(prob=0.8, n_points=2),
    mutation = PolynomialMutation(prob=0.3, repair=RoundingRepair()),
    eliminate_duplicates=True
)
 
res = minimize(problem, algorithm, ('n_gen', 60), seed=1, verbose=True)</pre>

  <p class="body">Let’s now print the results:</p>
  <pre class="programlisting">best_params = res.X
print("Optimal PID controller parameters:")
print("Kp =", best_params[0])
print("Ki =", best_params[1])
print("Kd =", best_params[2])</pre>

  <p class="body">And we’ll visualize the time response:</p>
  <pre class="programlisting">Kp = best_params[0]
Ki = best_params[1]
Kd = best_params[2]
 
T, t, y =transfer_function(Kp,Ki,Kd)
 
plt.plot(t,y)
plt.title("Step Response")
plt.xlabel("Time (s)")
plt.grid()</pre>

  <p class="body"><a id="marker-311"/>Figure 8.20 depicts the step response of the system, demonstrating how its outputs change over time when the inputs swiftly transition from 0 to 1.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F20_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.20 Step response</p>
  </div>

  <p class="body">To show the step response characteristics (rise time, settling time, peak, and others), you can use the following function:</p>
  <pre class="programlisting">control.step_info(T)</pre>

  <p class="body">This results in the following output:</p>
  <pre class="programlisting">{'RiseTime': 0.353,
 'SettlingTime': 0.52,
 'SettlingMin': 0.92,
 'SettlingMax': 1.0,
 'Overshoot': 0,
 'Undershoot': 0,
 'Peak': 0.99,
 'PeakTime': 3.62,
 'SteadyStateValue': 1.0}</pre>

  <p class="body">You can experiment with adjusting the algorithm’s parameters (such as population size, crossover method and probability, mutation method and probability, number of generations, etc.) and altering the performance metric to observe the effects on the system’s performance.<a id="idIndexMarker160"/><a id="idIndexMarker161"/></p>

  <h2 class="fm-head" id="heading_id_14">8.8 Political districting problem<a id="idTextAnchor001"/></h2>

  <p class="body"><a id="marker-312"/>I introduced political districting in section 2.1.5—it can be defined as the process of grouping <i class="timesitalic">n</i> subregions within a territory into <i class="timesitalic">m</i> electoral districts while adhering to certain constraints. Suppose we need to merge <i class="timesitalic">n</i> neighborhoods in the City of Toronto into <i class="timesitalic">m</i> electoral districts while ensuring a sufficient level of population equality. Figure 8.21 shows a sample dataset that contains population and median household income for 16 neighborhoods in East Toronto.<a id="idIndexMarker162"/><a id="idIndexMarker163"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F21_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.21 The 16 neighborhoods in East Toronto with their population and median household income</p>
  </div>

  <p class="body">In addressing the political districting problem, a viable solution must ensure that there is a satisfactory degree of population equilibrium (i.e., a fair and balanced distribution) in every electoral district. For example, we can evaluate a district’s population balance by calculating the deviation from an ideal population size within an upper bound (<span class="times1">pop<sub class="fm-subscript">UB</sub></span>) and lower bound (<span class="times1">pop<sub class="fm-subscript">LB</sub></span>) as follows:</p>

  <div class="figure">
    <p class="figured"><img alt="" class="calibre4" src="../Images/CH08_F21_Khamis-EQ13.png"/></p>
  </div>

  <p class="body">where <i class="timesitalic">pop<sub class="fm-subscript">av</sub></i> represents the target population size that can be considered the average of all the neighborhoods and <i class="timesitalic">pop<sub class="fm-subscript">margin</sub></i> indicates the acceptable degree of deviation from the ideal population size. <i class="timesitalic">n</i> is the number of the neighborhoods, and <i class="timesitalic">m</i> is the number of districts.</p>

  <p class="body">A district will be regarded as overpopulated if its total population exceeds the upper bound, and conversely, a district will be deemed underpopulated if its total population falls below the lower bound. A district whose population falls within the upper and lower bounds will be regarded as having an appropriate population size. The objective function is to minimize the total number of overpopulated and underpopulated districts. The search process will persist until the objective function’s minimum value is obtained, ideally zero. This indicates that no districts are either overpopulated or underpopulated.</p>

  <p class="body"><a id="marker-313"/>The next listing shows how to find the political districts using GA. We’ll start by reading the data from a local folder or using a URL.</p>

  <p class="fm-code-listing-caption">Listing 8.6 Solving a political districting problem using GA</p>
  <pre class="programlisting">import geopandas as gpd
import pandas as pd
import folium
 
data_url="https://raw.githubusercontent.com/Optimization-Algorithms-Book/  <span class="fm-combinumeral">①</span>
Code-Listings/main/Appendix%20B/data/PoliticalDistricting/" 
 
toronto = gpd.read_file(data_url+"toronto.geojson")                        <span class="fm-combinumeral">②</span>
neighborhoods = pd.read_csv(data_url+"Toronto_Neighborhoods.csv")          <span class="fm-combinumeral">③</span>
 
range_limit = 16                                                           <span class="fm-combinumeral">④</span>
toronto_sample = toronto.tail(range_limit)                                 <span class="fm-combinumeral">④</span>
values = neighborhoods.tail(range_limit)                                   <span class="fm-combinumeral">④</span>
values = values.join(toronto_sample["cartodb_id"])                         <span class="fm-combinumeral">④</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> URL for the data folder</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Read the Toronto region administration boundaries.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Read the neighborhood information (e.g., names, populations, and median household incomes).</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Pick 16 neighborhoods as a subset to represent neighborhoods in East Toronto.</p>

  <p class="body">After reading the dataset, we’ll do the following data preprocessing to get the population of each neighborhood, and the adjacency relationship among every possible pair of neighborhoods, in a Boolean matrix.</p>
  <pre class="programlisting">import numpy as np
 
def get_population(lst, table):
    return table["population"].iloc[lst].to_numpy()    <span class="fm-combinumeral">①</span>
 
eval = get_population(range(range_limit), values)      <span class="fm-combinumeral">②</span>
 
def get_neighboors(database):                          <span class="fm-combinumeral">③</span>
    result = []
    for i in range(database['name'].size):
        tmp = np.zeros(database['name'].size)
        geo1 = database.iloc[i]
        for j in range(database['name'].size):
            if i != j:
                geo2 = database.iloc[j]
                if geo1["geometry"].intersects(geo2["geometry"]):
                    tmp[j] = 1
        result.append(tmp)
    return np.stack(result)
 
neighbor = get_neighboors(toronto_sample)</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Get the population of each neighborhood.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Prepare the population dataset.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Represent the adjacency relationship among every possible pair of neighborhoods.</p>

  <p class="body"><a id="marker-314"/>We’ll now define the political districting class with a single objective function, three constraints, a given number of districts, a given population margin, and an adjacency matrix between the neighborhoods. <code class="fm-code-in-text">PoliticalDistricting</code> is a custom problem class that extends the <code class="fm-code-in-text">Problem</code> class from pymoo. The <code class="fm-code-in-text">Problem</code> class implements a method that evaluates a set of solutions instead of a single solution at a time, like in the case of the <code class="fm-code-in-text">ElementwiseProblem</code> class. In the <code class="fm-code-in-text">PoliticalDistricting</code> class, the following parameters are defined:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">num_dist</code>—The number of districts to divide the region into</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">neighbor</code>—A matrix representing the neighborhood relationships between locations in the region</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">populations</code>—The population of each neighborhood</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">margin</code>—The acceptable degree of deviation from the ideal population size</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">average</code>—The average population</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">n_var</code>—The number of decision variables, which is equal to the number of neighborhoods</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">n_obj=1</code>—The number of objectives, which is 1 for this problem</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">n_eq_constr=3</code>—The number of equality constraints, which is 3 for this problem</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">xl=0</code>—The lower bound for the decision variables, which is 0 for this problem</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">xu=num_dist-1</code>—The upper bound for the decision variables, which is <code class="fm-code-in-text">num_dist-1</code> for this problem</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">vtype=int</code>—The type of decision variables, which is integer for this problem</p>
    </li>
  </ul>

  <p class="body">The following code shows how to define a <code class="fm-code-in-text">PoliticalDistricting</code> class with different parameters, such as the number of districts, neighbor information, populations, and margin:</p>
  <pre class="programlisting">from pymoo.core.problem import Problem
 
class PoliticalDistricting(Problem):
    def __init__(self,
                 num_dist, 
                 neighbor, 
                 populations, 
                 margin 
                 ):                                         <span class="fm-combinumeral">①</span>
 
        self.populations = populations                      <span class="fm-combinumeral">②</span>
        self.average = np.mean(populations)                 <span class="fm-combinumeral">③</span>
        super().__init__(n_var=len(self.populations), n_obj=1, n_eq_constr=3, 
<span class="fm-code-continuation-arrow">➥</span> xl=0, xu=num_dist-1, vtype=int)                          <span class="fm-combinumeral">④</span>
 
        self.n_var = len(self.populations) 
        self.n_dist = num_dist
        self.margin = margin
        self.neighbor = neighbor
        self.func = self._evaluate                          <span class="fm-combinumeral">⑤</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Define a constructor with specific parameters.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Hold the population data.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Store the mean population of all districts.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Call the constructor of the parent class with specific parameters.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Evaluate the solution against the objective function and constraints.</p>

  <p class="body"><a id="marker-315"/>As a continuation and as part of the <code class="fm-code-in-text">problem</code> class, we’ll extract the neighborhoods that belong to a specific district using the following function:</p>
  <pre class="programlisting">def _gather(self, x, district):
    return np.where(x==district, 1, 0)</pre>

  <p class="body">We’ll then calculate the upper and lower bounds based on the given population values and margin as follows:</p>
  <pre class="programlisting">def _get_bounds(self):
    ub = np.ceil(self.average + self.margin) *
<span class="fm-code-continuation-arrow">➥</span> (len(self.populations)/self.n_dist)
    lb = np.ceil(self.average - self.margin) * 
<span class="fm-code-continuation-arrow">➥</span> (len(self.populations)/self.n_dist)
    return ub, lb</pre>

  <p class="body">The following function is used to decide whether an electoral district is overpopulated or underpopulated:</p>
  <pre class="programlisting">def _get_result(self, gathered, ub, lb):
    product = gathered * self.populations
    summed_product = np.sum(product, axis=1)
    return np.where((summed_product &gt; ub), 1, 0) + np.where((summed_product &lt;
<span class="fm-code-continuation-arrow">➥</span> lb), 1, 0)</pre>

  <p class="body">As all the constraints are equality constraints, the following function returns true if the constraint is satisfied:</p>
  <pre class="programlisting">def _get_constraint(self, constraint):
    constraint = np.stack(constraint)
    return np.any(constraint==0, axis=0)</pre>

  <p class="body">To make sure that there is no isolated neighborhood far from other neighbors within a district, unless the district only has one neighborhood, the following function is used:</p>
  <pre class="programlisting">def _get_neighbor(self, gathered):
    singleton = np.sum(gathered, axis=1)
    singleton = np.where(singleton==1, True, False) 
    tmp_neighbor = np.dot(gathered, self.neighbor)
    tmp_neighbor = np.where(tmp_neighbor &gt; 0, 1, 0)
    product = gathered * tmp_neighbor
    return np.all(np.equal(product, gathered), axis=1) + singleton </pre>

  <p class="body">The following function determines the best approximation to make an electoral district a contiguous block:</p>
  <pre class="programlisting">def cap_district(self, gathered):
    result = np.zeros(gathered.shape[0])
    for i in range(len(gathered)):
        nonzeros = np.nonzero(gathered[i])[0]
        if nonzeros.size != 0:
            mx = np.max(nonzeros)
            mn = np.min(nonzeros)
            result[i] = self.neighbor[mx][mn] or (mx == mn)  
    return result </pre>

  <p class="body"><a id="marker-316"/>The last function in the <code class="fm-code-in-text">problem</code> class is used to evaluate the solution against the objective function, including checking the constraints:</p>
  <pre class="programlisting">    def _evaluate(self, x, out, *args, **kwargs):
        x=np.round(x).astype(int) # Ensure X is binary
        pop_count = []
        constraint1 = []
        constraint2 = []
        constraint3 = []
        for i in range(self.n_dist):
            gathered = self._gather(x, i)
            ub, lb = self._get_bounds()
            result = self._get_result(gathered, ub, lb)
            pop_count.append(result)
            constraint1.append(np.sum(gathered, axis=1))          <span class="fm-combinumeral">①</span>
            constraint2.append((self._get_neighbor(gathered)))    <span class="fm-combinumeral">②</span>
            constraint3.append(self.cap_district(gathered))       <span class="fm-combinumeral">③</span>
 
        holder = np.sum(np.stack(pop_count), axis=0)
        out["F"] = np.expand_dims(holder, axis=1) 
        out["H"] = [self._get_constraint(constraint1),
                    self._get_constraint(constraint2), 
                    self._get_constraint(constraint3)] 
 
def create_districting_problem(number_of_districts, neighborlist, population_
<span class="fm-code-continuation-arrow">➥</span> list, margin, seed=1):
    np.random.seed(seed)
    problem = PoliticalDistricting(number_of_districts, neighborlist,
<span class="fm-code-continuation-arrow">➥</span> population_list, margin)
    return problem</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Constraint 1: make sure that there is no empty district,</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Constraint 2: make sure there is no lone neighborhood within a district, unless the district only has one neighborhood.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Constraint 3: ensure the electoral district is a contiguous block by achieving the best possible approximation.</p>

  <p class="body">We can now define the GA solver and apply it to solve the problem as follows:</p>
  <pre class="programlisting">from pymoo.algorithms.soo.nonconvex.ga import GA
from pymoo.operators.sampling.rnd import FloatRandomSampling
from pymoo.operators.crossover.pntx import PointCrossover
from pymoo.operators.mutation.pm import PolynomialMutation
from pymoo.operators.repair.rounding import RoundingRepair
from pymoo.termination import get_termination
from pymoo.optimize import minimize
 
num_districts = 3
margin=6000
 
problem = create_districting_problem(num_districts, neighbor, eval, margin, seed=1)
 
algorithm = GA(
    pop_size=2000,
    sampling=FloatRandomSampling(),
    crossover=PointCrossover(prob=0.8, n_points=2),
    mutation = PolynomialMutation(prob=0.3, repair=RoundingRepair()),
    eliminate_duplicates=True
)
 
termination = get_termination("n_gen", 100)
 
res = minimize(problem,
               algorithm,
               termination,
               seed=1,
               save_history=True,
               verbose=True)</pre>

  <p class="body"><a id="marker-317"/>The resultant political districts are listed here and visualized in figure 8.22:</p>
  <pre class="programlisting">Political District- 1 :  ['Woburn', 'Highland Creek', 'Malvern']
Political District- 2 :  ['Bendale', 'Scarborough Village', 'Guildwood', 'Morningside', 'West Hill', 'Centennial Scarborough', 'Agincourt South-Malvern West']
Political District- 3 :  ['Rouge', 'Hillcrest Village', 'Steeles', "L'Amoreaux", 'Milliken', 'Agincourt North']</pre>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH08_F22_Khamis.png"/></p>

    <p class="figurecaption">Figure 8.22 The three political districts that combine the 16 neighborhoods</p>
  </div>

  <p class="body">The problem is treated as a single objective optimization problem where the objective is to minimize the total number of overpopulated and underpopulated districts. The dataset contains the median household income of each neighborhood, so you can replace the objective function to focus on the heterogeneity of the median household income. You can also treat the problem as a multi-objective optimization problem by considering both criteria.</p>

  <p class="body">This chapter marks the end of the third part of the book, which focused on genetic algorithms and their applications in solving complex optimization problems. The fourth part of the book will delve into the fascinating realm of swarm intelligence algorithms. <a id="idIndexMarker164"/><a id="idIndexMarker165"/></p>

  <h2 class="fm-head" id="heading_id_15">Summary</h2>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">The Hamming cliff problem, which results from the inherent nature of binary representation, negatively affects binary-coded GAs by disrupting the search space’s smoothness, causing poor convergence and leading to inefficient exploration and exploitation. To address this problem, alternative representations like Gray code or real-valued encoding can be used, as they offer better locality and smoother search spaces, minimizing the disruptive effects of small changes on decoded values.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Real-valued GA is well suited for optimization problems involving continuous variables or real-valued parameters. It offers benefits such as better representation precision, faster convergence, diverse crossover and mutation operations, and reduced complexity, making it an attractive choice for many continuous optimization problems.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Permutation-based GA is a class of genetic algorithms specifically designed to handle combinatorial optimization problems where the solutions can be represented as ordered sequences, or permutations, of elements.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Multi-objective optimization problems can be tackled using either a preference-based multi-objective optimization method or a Pareto optimization approach. In the preference-based method, the multiple objectives are combined into a single or overall objective function by using a weighting scheme. The Pareto optimization approach focuses on identifying multiple trade-off optimal solutions known as Pareto-optimal solutions. These solutions can be further refined using higher-level information or decision-making processes.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Crossover is primarily exploitative, as it combines the genetic material of two parent individuals to produce offspring, promoting the exchange of beneficial traits between solutions. However, depending on the implementation, crossover can also have some explorative properties, as it can produce offspring with new combinations of genes, leading to the discovery of new solutions.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Mutation can act as an explorative or exploitative operator depending on influencing factors such as the mutation rate and the mutation step size.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">In general, the crossover rate should be relatively high, as it promotes the exchange of genetic information between parent chromosomes. On the other hand, mutation is typically applied with a low probability, as its main purpose is to introduce random variations into the population.<a id="marker-318"/><a id="idIndexMarker166"/></p>
    </li>
  </ul>
</body></html>