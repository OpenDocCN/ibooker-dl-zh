["```py\ntf.layers.conv2d({filters: 32,![1](assets/1.png)kernelSize: 3,![2](assets/2.png)strides: 1,![3](assets/3.png)padding:'same',![4](assets/4.png)activation:'relu',![5](assets/5.png)inputShape:[28,28,1]![6](assets/6.png)})\n```", "```py\ntf.layers.maxPooling2d({poolSize: 2,![1](assets/1.png)strides: 2![2](assets/2.png)})\n```", "```py\n// Read images\nconst[X,Y]=awaitfolderToTensors()![1](assets/1.png)// Create layers model\nconstmodel=getModel()![2](assets/2.png)// Train\nawaitmodel.fit(X,Y,{batchSize: 256,validationSplit: 0.1,epochs: 20,shuffle: true,![3](assets/3.png)})// Save\nmodel.save('file://model_result/sorting_hat')![4](assets/4.png)// Cleanup!\ntf.dispose([X,Y,model])console.log('Tensors in memory',tf.memory().numTensors)\n```", "```py\n$ npm i glob\n```", "```py\nconst glob = require('glob')\n// OR\nimport { default as glob } from 'glob'\n```", "```py\nfiles.forEach((file) => {\n  const imageData = fs.readFileSync(file)\n  const answer = encodeDir(file)\n  const imageTensor = tf.node.decodeImage(imageData, 1)\n\n  // Store in memory\n  YS.push(answer)\n  XS.push(imageTensor)\n})\n```", "```py\nfunction encodeDir(filePath) {\n  if (filePath.includes('bird')) return 0\n  if (filePath.includes('lion')) return 1\n  if (filePath.includes('owl')) return 2\n  if (filePath.includes('parrot')) return 3\n  if (filePath.includes('raccoon')) return 4\n  if (filePath.includes('skull')) return 5\n  if (filePath.includes('snail')) return 6\n  if (filePath.includes('snake')) return 7\n  if (filePath.includes('squirrel')) return 8\n  if (filePath.includes('tiger')) return 9\n\n  // Should never get here\n  console.error('Unrecognized folder')\n  process.exit(1)\n}\n```", "```py\n// Shuffle the data (keep XS[n] === YS[n])\ntf.util.shuffleCombo(XS, YS)\n```", "```py\n// Stack values\nconsole.log('Stacking')\nconst X = tf.stack(XS)\nconst Y = tf.oneHot(YS, 10)\n\nconsole.log('Images all converted to tensors:')\nconsole.log('X', X.shape)\nconsole.log('Y', Y.shape)\n\n// Normalize X to values 0 - 1\nconst XNORM = X.div(255)\n// cleanup\ntf.dispose([XS, X])\n```", "```py\nStacking\nImages all converted to tensors:\nX [ 87541, 28, 28, 1 ]\nY [ 87541, 10 ]\n```", "```py\nconst model = tf.sequential()\n\n// Conv + Pool combo\nmodel.add(\n  tf.layers.conv2d({\n    filters: 16,\n    kernelSize: 3,\n    strides: 1,\n    padding: 'same',\n    activation: 'relu',\n    kernelInitializer: 'heNormal',\n    inputShape: [28, 28, 1],\n  })\n)\nmodel.add(tf.layers.maxPooling2d({ poolSize: 2, strides: 2 }))\n\n// Conv + Pool combo\nmodel.add(\n  tf.layers.conv2d({\n    filters: 32,\n    kernelSize: 3,\n    strides: 1,\n    padding: 'same',\n    activation: 'relu',\n  })\n)\nmodel.add(tf.layers.maxPooling2d({ poolSize: 2, strides: 2 }))\n\n// Conv + Pool combo\nmodel.add(\n  tf.layers.conv2d({\n    filters: 64,\n    kernelSize: 3,\n    strides: 1,\n    padding: 'same',\n    activation: 'relu',\n  })\n)\nmodel.add(tf.layers.maxPooling2d({ poolSize: 2, strides: 2 }))\n\n// Flatten for connecting to deep layers\nmodel.add(tf.layers.flatten())\n\n// One hidden deep layer\nmodel.add(\n  tf.layers.dense({\n    units: 128,\n    activation: 'tanh',\n  })\n)\n// Output\nmodel.add(\n  tf.layers.dense({\n    units: 10,\n    activation: 'softmax',\n  })\n)\n```", "```py\nmodel.compile({\n  optimizer: 'adam',\n  loss: 'categoricalCrossentropy',\n  metrics: ['accuracy'],\n})\n```", "```py\n_________________________________________________________________\nLayer (type)                 Output shape              Param #\n=================================================================\nconv2d_Conv2D1 (Conv2D)      [null,28,28,16]           160         ![1](assets/1.png)\n_________________________________________________________________\nmax_pooling2d_MaxPooling2D1  [null,14,14,16]           0           ![2](assets/2.png)\n_________________________________________________________________\nconv2d_Conv2D2 (Conv2D)      [null,14,14,32]           4640        ![3](assets/3.png)\n_________________________________________________________________\nmax_pooling2d_MaxPooling2D2  [null,7,7,32]             0\n_________________________________________________________________\nconv2d_Conv2D3 (Conv2D)      [null,7,7,64]             18496       ![4](assets/4.png)\n_________________________________________________________________\nmax_pooling2d_MaxPooling2D3  [null,3,3,64]             0\n_________________________________________________________________\nflatten_Flatten1 (Flatten)   [null,576]                0           ![5](assets/5.png)\n_________________________________________________________________\ndense_Dense1 (Dense)         [null,128]                73856       ![6](assets/6.png)\n_________________________________________________________________\ndense_Dense2 (Dense)         [null,10]                 1290        ![7](assets/7.png)\n=================================================================\nTotal params: 98442\nTrainable params: 98442\nNon-trainable params: 0\n_________________________________________________________________\n```", "```py\nconst canvas = document.getElementById(\"sketchpad\");\nconst context = canvas.getContext(\"2d\");\ncontext.lineWidth = 14;\ncontext.lineCap = \"round\";\nlet isIdle = true;\n\nfunction drawStart(event) {\n  context.beginPath();\n  context.moveTo(\n    event.pageX - canvas.offsetLeft,\n    event.pageY - canvas.offsetTop\n  );\n  isIdle = false;\n}\nfunction drawMove(event) {\n  if (isIdle) return;\n  context.lineTo(\n    event.pageX - canvas.offsetLeft,\n    event.pageY - canvas.offsetTop\n  );\n  context.stroke();\n}\nfunction drawEnd() { isIdle = true; }\n// Tie methods to events\ncanvas.addEventListener(\"mousedown\", drawStart, false);\ncanvas.addEventListener(\"mousemove\", drawMove, false);\ncanvas.addEventListener(\"mouseup\", drawEnd, false);\n```", "```py\ncontext.fillStyle = \"#fff\";\ncontext.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);\n```", "```py\nasyncfunctionmakePrediction(canvas,model){constdrawTensor=tf.browser.fromPixels(canvas,1)![1](assets/1.png)constresize=tf.image.resizeNearestNeighbor(drawTensor,[28,28],true)![2](assets/2.png)constbatched=resize.expandDims()![3](assets/3.png)constresults=awaitmodel.predict(batched)constpredictions=awaitresults.array()// Display\ndisplayResults(predictions[0])![4](assets/4.png)// Cleanup\ntf.dispose([drawTensor,resize,batched,results])}\n```", "```py\nfunction displayResults(predictions) {\n  // Get Scores\n  const ravenclaw = predictions[0] + predictions[2] + predictions[3]\n  const gryffindor = predictions[1] + predictions[9]\n  const hufflepuff = predictions[4] + predictions[8]\n  const slytherin = predictions[6] + predictions[7]\n  const deatheater = predictions[5]\n\n  document.getElementById(\"ravenclaw\").style.opacity = ravenclaw\n  document.getElementById(\"gryffindor\").style.opacity = gryffindor\n  document.getElementById(\"hufflepuff\").style.opacity = hufflepuff\n  document.getElementById(\"slytherin\").style.opacity = slytherin\n\n  // Harry Potter fans will enjoy this one\n  if (deatheater > 0.9) {\n    alert('DEATH EATER DETECTED!!!')\n  }\n}\n```"]