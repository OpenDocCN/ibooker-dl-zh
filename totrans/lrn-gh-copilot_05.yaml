- en: Chapter 4\. Advanced Editing and Autonomous Workflows in the IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Chapters [2](ch02.html#ch02) and [3](ch03.html#ch03), we covered the basics
    of creating code and using the chat interface to get things done with Copilot
    in the IDE. The items we’ve discussed will help handle basic use cases. But for
    more intensive coding efforts like refactoring, making significant edits, or automatically
    handling more complex changes, Copilot provides advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at a powerful set of features that leverage the
    AI to handle larger sets of changes and code generation for you. These include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Predictive edits with Next Edit Suggestions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Batch changes with Copilot Edits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated end-to-end updates with Copilot Agent mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing code based on images with Copilot Vision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging with Copilot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start off looking at a feature that can predict where your next edit should
    be.
  prefs: []
  type: TYPE_NORMAL
- en: Predictive Edits with Next Edit Suggestions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever been trying to refactor your code in some way and found yourself
    searching through your file to locate all the places you need to make changes?
    Co­pilot’s Next Edit Suggestions (NES) is designed to eliminate the need for that
    and simplify the process of identifying and making the *next change*.
  prefs: []
  type: TYPE_NORMAL
- en: NES predicts and suggests edits based on ongoing changes in your code, typos,
    or logic errors. The changes it suggests can range from a single symbol to multiple
    lines of code. In the refactoring use case, NES can analyze the edits you’re making
    and locate the next place in the logic where a change needs to be made, then the
    next place, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When enabled, and after you make an edit, NES looks at your code and tries
    to anticipate what else is related and should be changed next. NES highlights
    its suggestion for the next change by putting an arrow in the editor’s gutter.
    The *gutter* refers to the empty strip of space to the left of the line numbers
    in the editor. As an example, say we have a Python class that represents a 2D
    point and includes a method to calculate the distance between two points. It also
    includes a simple example. The code might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to change this class to work for 3D points, so we change the `__init__`
    statement to add a `z` value. If NES is enabled, after we make that change, Copilot
    will look for the next place where the code needs to be changed to handle the
    new `z` coordinate. Copilot determines it needs to add a constructor for that
    value in the `init` method, suggests the code change, and highlights it with the
    arrow in the gutter, as shown in [Figure 4-2](#nes-identifying-next):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. NES identifying the next change
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To get to this change quickly, you just hit Tab. Hovering over the arrow in
    the gutter presents an informational dialog with extended options for working
    with NES ([Figure 4-3](#nes-options-popup)). In most cases, you won’t need these.
    You can just press Tab to accept the suggested change or Escape to reject it and
    move on.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. NES options pop-up
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once we process this change (accept or reject), the process continues, and Copilot
    identifies the next suggested edit ([Figure 4-4](#next-change)). The process will
    then repeat as long as there are eligible changes that Copilot identifies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. The next change
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t Lose Focus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a pending NES change (with the arrow visible in the gutter) and
    switch focus away from the editor, the pending change will disappear, and the
    NES process will stop.
  prefs: []
  type: TYPE_NORMAL
- en: While the NES functionality can substantially help with common changes, such
    as intentional refactoring, it can also catch and point out independent issues,
    like typos and logic errors.
  prefs: []
  type: TYPE_NORMAL
- en: Assume we had coded the changes to the distance function ourselves and accidentally
    used the multiplication operator instead of the exponent operator. With NES activated,
    Copilot would catch that and suggest a change to correct it, as shown in [Figure 4-6](#nes-suggesting-change).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0406.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6\. NES suggesting a change to fix a logic error
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: NES can also help catch changes that need to be made across multiple files,
    but that currently seems to be limited to files that are open in the editor. If
    you need to make batch changes or automatically add a feature that spans multiple
    files, consider the advanced edit functionality discussed in our next section
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot Edits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copilot includes functionality to make AI-driven changes across a selected set
    of files. This functionality, called *Copilot Edits*, allows Copilot to update
    multiple files in response to a natural language prompt. You can think of this
    as a sort of batch edit functionality driven by AI. It can be useful for tasks
    ranging from simple refactoring all the way to extensive changes, like adding
    features, across a subset of existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot Edits is a separate mode in Copilot Chat. To use it, you first need
    to switch from the default Ask mode in chat to Edit mode. This is done via a menu
    that shows up when you click the drop-down arrow next to Ask*,* at the bottom
    of the prompt entry area ([Figure 4-7](#switching-chat-to-edi)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0407.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7\. Switching chat to Edit mode
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this mode, you select which files to edit and provide a prompt along with
    any needed context. Copilot then suggests edits to your code across the files
    that you can accept or reject. Let’s take a look at a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a simple set of calculator functions written in Python along
    with some basic tests and a README file.
  prefs: []
  type: TYPE_NORMAL
- en: Our Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’m sharing the code here because it provides the background for the changes
    we’re going to talk about in the rest of the chapter. And even though this is
    written in Python, you don’t have to know Python to understand what we’ll be doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the *README.md* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the calculator functions is in a file named *calculator.py*, shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the test cases is in a file named *test_calculator.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: (We also have a standard *.gitignore* file and a LICENSE file in the project.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose we want to improve our code in the Python files. Here’s a set
    of tasks we can prompt Copilot to do in Edit mode:'
  prefs: []
  type: TYPE_NORMAL
- en: Refactor the `divide` function to handle division by zero more gracefully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add [type hints](https://oreil.ly/H6bfq) to all functions in *calculator.py*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write additional unit tests for edge cases in *test_calculator.py*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start the Edits process, we need to add the files we want Copilot to work
    with. In our simple case, for the prompts we’re using, we just need the two Python
    files. We can add them most easily by selecting them from the file list and dragging
    and dropping them into the text entry area of the chat dialog. Alternatively,
    you can include them by using the `#file` chat variable. Or you can use the Add
    Context control to pick them from the list. [Figure 4-8](#selected-files-ready)
    shows the files added as context and the prompts supplied in the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0408.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-8\. Selected files ready for Copilot Edits
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once we submit this, Copilot will process the prompts against the selected files
    and propose any needed changes to accomplish the prompts. These proposed changes
    will be shown inline in the editor. You can choose to review each one and Keep/Undo
    each proposed change or Keep/Undo all proposed changes at once based on the new
    “files changed” section in the chat area. [Figure 4-9](#edited-files-ready-fo)
    shows the results of running the prompts in Edit mode for the specified context.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0409.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-9\. Edited files ready for review
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are controls for keeping or undoing each suggested edit if you need to
    get that granular. Also, files with proposed/pending changes have a symbol (dot
    inside a square) in the file list and for ones that are open in the editor. Once
    you’ve decided what to keep or undo for the proposed changes, the Keep/Undo buttons
    in the “files changed” area will change to a Done button. You click this to stop
    this round of editing.
  prefs: []
  type: TYPE_NORMAL
- en: Until you click the Done button, you can change your mind and roll back the
    edits Copilot suggested, even if you chose to keep some or all. You can do this
    in a couple of ways. You can use the Undo option in the “files changed” area above
    the entry area. Or you can click the left-curving arrow at the top of the chat
    panel. Or, you can hover over the top of the conversation in the chat and click
    the X there, as shown in [Figure 4-10](#one-of-several-option).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0410.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-10\. One of several options to roll back proposed edits
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To persist the changes in the files, click the Done button. In our example,
    the *calculator.py* file has the type hints included, and the divide function
    has been refactored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And additional test cases have been added per the other prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here’s one more tip for using Copilot Edits. Instead of selecting individual
    files, you can use the `#codebase` chat variable (see [Chapter 3](ch03.html#ch03))
    in your prompt to let Copilot try to select the appropriate files to change. For
    example, if you used the prompt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Copilot selects the *README.md* file to add the documentation to ([Figure 4-11](#using-codebase-to-up)).
    Of course, you might want to create a separate documentation file, but the point
    is that Copilot selected the best fit among the ones that were available.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0411.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-11\. Using `#codebase` to update files
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is meant to show a simple use case, but you can use Copilot Edits at a
    much larger scale and for more complex changes. The mechanics and approach apply
    the same way. The more specific you can be with the files you want changed, and
    the more directive you can be with your prompts, the better. As with any suggestions
    from the AI, the results may or may not be what you expect and may or may not
    be correct. This is why the step of reviewing the proposed changes in the editor
    is so important. If you don’t get the set of changes you expect, you can try going
    back and tweaking the prompt to see if you can get improved suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: While the AI edit capabilities in Copilot Edits are useful for suggesting changes
    in files that you select and review, sometimes we may not know which content needs
    to be *picked* for a change. And we may not want to do as many manual steps to
    get the changes in place for review. For those reasons (among others), Copilot
    can leverage the AI to make simple or complex changes more autonomously. This
    happens by using Copilot’s other mode, which uses an AI agent to handle the heavy
    lifting for you.
  prefs: []
  type: TYPE_NORMAL
- en: Agent Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In AI terminology, an AI *agent* is software that gathers input from its environment,
    makes decisions, and takes actions autonomously using available *tools* to achieve
    specific goals. Agents use the underlying AI models as their *brain* to help translate
    between natural language or code and develop plans and make decisions. GitHub
    Copilot’s Agent mode is your own coding agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Agent mode, Copilot takes one or more prompts as tasks to complete. It then
    runs in a more autonomous way by using this basic workflow for each task:'
  prefs: []
  type: TYPE_NORMAL
- en: Determines the needed context and files to edit (as opposed to you having to
    specify them). Also, it can create new files if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suggests code changes and terminal commands to complete the task. For example,
    Copilot might suggest or run commands to install dependencies or run tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checks for correctness of code edits and terminal commands output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prompts for human review or interaction if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeats the preceding steps until it assesses that the task is completed successfully
    or it can go no further on its own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While it is processing, the agent is leveraging a set of tools defined by GitHub
    to help accomplish tasks. These tools read files, run commands in the terminal,
    read output, apply proposed changes, and more. The list of tools is updated as
    new ones become available for Agent mode to use.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the agent usually does a very good job of identifying the appropriate
    context to use or update, you can use the usual methods (`#file` chat variables,
    Add Context control, etc.) to also target specific files.
  prefs: []
  type: TYPE_NORMAL
- en: These autonomous capabilities and use of iteration to complete a task are key
    features. They differentiate Copilot’s Agent mode from more selective, directed
    approaches like Copilot Edits.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get an idea of how Agent mode works in practice. We’ll use the same set
    of files from [“Copilot Edits”](#copilot-edits) that implement the calculator
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to switch to Agent mode. We can do that in the same way we did
    to get to Copilot Edits. In the text entry section of the chat panel, click the
    downward arrow and select Agent from the list ([Figure 4-12](#switch-to-agent-mode)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0412.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-12\. Switch to Agent mode
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because Agent mode is more powerful and autonomous than Edits, we can prompt
    Copilot to do sets of changes that are more significant. We’ll still keep them
    fairly simple here to introduce the process. But in [“Debugging with Copilot”](#debugging-with-copilot),
    you’ll see how to leverage Agent mode for a much more advanced task.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Copilot in Agent mode, we’re going to have it make three sets of changes
    to our calculator code. Those changes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add logging to all functions in *calculator.py*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a CLI for the calculator application and validate that it works as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate documentation for all functions by using docstrings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As usual, we need to add the prompts to the text input area, as shown in [Figure 4-14](#prompts-for-changes-v2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0414.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-14\. Prompts for changes via Agent mode
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now we are ready to submit the prompts. Notice, however, that we didn’t specify
    any additional context. We didn’t specify files as we did in Edits mode. In Agent
    mode, Copilot can autonomously figure out what tasks need to be done and what
    files need to be changed. Copilot can even go further, by applying code edits
    for review, suggesting terminal commands, and even creating new files—depending
    on the prompt. As you work with Agent mode and notice any problems or desired
    changes, you can prompt it further, and it will iterate to resolve any issues.
  prefs: []
  type: TYPE_NORMAL
- en: Once we submit our prompts, Copilot proceeds to analyze them and create a plan
    to accomplish them ([Figure 4-15](#agent-planning-approa2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0415.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-15\. Agent planning an approach
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After figuring out the plan and what needs to be changed, Copilot will apply
    edits *inline* with theexisting code. As with Edit mode, after Copilot is done,
    the proposed changes will be shown inline in the editor. You can choose to review
    each one and Keep/Undo each proposed change or Keep/Undo all proposed changes
    at once based on the new “files changed” section in the chat area, as seen in
    [Figure 4-16](#agent-changes-made-in).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0416.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-16\. Agent changes made inline
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Time to Complete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Agent mode is performing a large number of operations and iterating until
    the code is working acceptably or it can go no further, execution usually does
    take more time (sometimes considerably more) than operations in Edit or Ask mode.
  prefs: []
  type: TYPE_NORMAL
- en: Files with proposed or pending changes have a symbol (dot inside a square) in
    the file list and on their editor tab, if they’re open in the editor. Once you’ve
    reviewed the proposed changes and chosen what to keep or undo, the Keep/Undo buttons
    in the “files changed” area will change to a Done button. You click this to stop
    this round of editing.
  prefs: []
  type: TYPE_NORMAL
- en: Proposed Changes Available for Execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may not be obvious, but suggested changes that have not been reviewed yet
    will still be factored in when code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Until you click the Done button, you can change your mind and roll back the
    edits Copilot suggested, even if you chose to keep some or all. You can do this
    in a couple of ways. You can use the Undo option in the “files changed” area above
    the entry area. Or you can click the left-curving arrow at the top of the chat
    panel. Or you can hover over the top of the conversation in the chat and click
    the X there, as shown previously in [Figure 4-10](#one-of-several-option).
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that you can iterate as much as needed. Once you click the Done
    button, the changes will be persisted in the files.
  prefs: []
  type: TYPE_NORMAL
- en: One other note here is that since we told the agent we wanted it to validate
    that the CLI it created worked as expected, the agent suggested commands to be
    run in the terminal. To run each of these, it was only necessary to copy or direct
    them into the terminal and hit Enter. As shown in [Figure 4-17](#agent-driving-verific2),
    the agent was able in most cases to validate that the output was what was expected
    and conclude that the CLI was working as expected. (For some reason, it could
    not parse the output from the `add` function, but that was working correctly,
    along with the others.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0417.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-17\. Agent driving the verification
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This is only a quick overview and example of Copilot’s agentic AI capabilities.
    As you can likely already tell, this powerful feature can help in many areas of
    making changes—with appropriate prompts and reviews. Expect to see it becoming
    more ubiquitous throughout Copilot and GitHub. To further get an idea of what
    Copilot and its agentic AI functions are capable of, you’ll see how to use them
    in the next section along with another impressive feature of Copilot: parsing
    visual images to derive context and generate code!'
  prefs: []
  type: TYPE_NORMAL
- en: Using Agent Mode with Copilot Free
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re relying on the Copilot Free plan, be aware that you have a limited
    number of interactions available per month, and Agent mode can use many interactions.
    Depending on your usage pattern, Agent mode use may consume much of your available
    quota.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot Vision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever taken a screenshot of an issue you were running into in the IDE
    and sent it to a coworker because it was easier than trying to explain? Or have
    you ever seen an app interface and wanted to be able to create the code to implement
    one similar in style or appearance?
  prefs: []
  type: TYPE_NORMAL
- en: If so, or if you expect this might happen at some point, Copilot has visual-based
    functionality that can help you out. *Copilot Vision* is an advanced feature that
    lets you attach and work with images directly in Copilot Chat within certain IDEs.
    Given an image, the AI can interpret and analyze it to provide answers. But it
    can also generate code based on an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Images supplied to Copilot for analysis or as a basis for code can be of many
    types. Here are some example use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Supply a screenshot or a mockup of a UI you want Copilot to emulate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide an architecture diagram for analysis and explanation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a screenshot of an issue you’re encountering in the IDE for it to help
    with debugging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide an image with text that is difficult to read and have Copilot extract
    and report the text so it can be digested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert hand-drawn diagrams to code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate entity relationship diagrams against SQL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Results May Vary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the various capabilities of Copilot Vision are impressive, your experience
    may vary depending on image quality, the model you choose, and more. As with any
    AI-generated results, you should always be prepared to tweak the input you give
    Copilot if needed and also review the response it produces.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do a quick example of using Copilot Vision to tell us about an image.
    For this exercise, we’ll use a screenshot of a web app built with a Python library
    named Gradio and hosted on a platform called Hugging Face Spaces. The screenshot
    is shown in [Figure 4-18](#starting-image-for-us2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0418.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-18\. The starting image for use with Vision
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To use Copilot Vision at the time of this writing, you must attach the image
    to the chat input area. But you don’t have to be in any particular mode. We’ll
    start out working in Ask mode. You can attach the image either by dragging the
    image, pasting it, or selecting it via the usual context methods.  [Figure 4-19](#starting-image-attach)
    shows the image attached.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0419.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-19\. The starting image attached to chat
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If we then ask Copilot to “Tell me about this,” it examines the image and is
    able to pull a lot of details from it. [Figure 4-20](#initial-image-analysi2)
    shows the start of the output after Copilot’s analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0420.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-20\. Initial image analysis from Copilot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here’s the full output from Copilot regarding the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While this is useful, even more interesting is that Copilot can create code
    based on the image. If we prompt it with “Can you write the code for this?”, Copilot
    responds by producing a set of code for it ([Figure 4-21](#creating-code-from-an2)).
    Interestingly, the implementation it chose here uses Python, the Gradio library,
    and Hugging Face’s Transformers library for sentiment analysis. These are the
    same items that were used to originally create the app!
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0421.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-21\. Creating code from an image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now let’s see how to incorporate Copilot Vision with Copilot’s agentic AI (via
    Agent mode) to make some impressive changes to the calculator files we’ve used
    in the other sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As it stands right now, our calculator has a command-line interface but no visual
    interface. Suppose we’ve found a picture of an interface ([Figure 4-22](#image-of-desired-inte))
    that we like and would like to have for our calculator.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0422.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-22\. The image of the desired interface
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s use that as context and see if Copilot can create a web interface for
    our calculator based on that image. At the same time, we also want to add a new
    function to do exponents. And since we’re adding the web interface, to simplify
    things when we’re running the app, let’s remove the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our prompt then might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4-23](#prompts-and-image-for2) shows the image attached and the prompts
    ready to go. Note that, given the level of change and complexity, we switched
    back to Agent mode for Copilot to accomplish this.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0423.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-23\. Prompts and the image for calculator updates
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'After submitting the prompts, the Copilot agent will assess what needs to be
    done, come up with a plan, and start proposing and making changes.  [Figure 4-24](#agent-creating-web-in)
    shows example output where the agent is working on the needed changes to create
    the web app based on the image. Notice the multiple processes it’s handling, including
    these:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Flask installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding web interface pieces and updating routes for all operations in the main
    file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new files where needed, such as *index.html*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/lghc_0424.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-24\. Agent creating the web interface
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Depending on the prompt and complexity, Copilot may stop and suggest code for
    you to use to create a new file, or it can create the file itself. Similarly,
    it may install dependencies and run terminal commands or suggest them and have
    you execute the needed commands. If you don’t see as much autonomous behavior
    as you were expecting, you can revise the prompt to tell/give permission to Copilot
    to do more up front. Examples would be telling it to create any needed files or
    to update requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes Copilot may require multiple iterations with Agent mode to get the
    results you want. For example, if an issue or problem occurs when the generated
    code changes are run, you may have to go back and tell Copilot about the issue
    in the agent prompt and ask it to make additional changes to fix it. When first
    running through the examples for this chapter, the results were not being shown
    correctly in the web app. After going through two more iterations, Copilot found
    and fixed the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any iteration with the Agent mode follows the same process of making a plan,
    updating content with suggested changes inline, and running commands. The output
    is the same: a set of changes that can be run to test out the code and reviewed
    to Keep or Undo. [Figure 4-25](#ready-after-iteration) shows an example after
    the agent fixed a reported issue of results not being shown initially.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0425.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-25\. Ready after iterations
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 4-26](#final-webapp2) shows the final result running the actual calculator
    code web app interface created by the Copilot agent. As you can see, it is impressively
    similar to the reference image it was given and works as expected. Also note that
    per the prompt to add a function to handle exponents, the web app interface Copilot
    produced has a calculator button (second from left in the first row) to do exponents
    (**) that was not in the original image.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0426.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-26\. Final web app
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Copilot Vision, along with NES and Agent mode, can certainly simplify getting
    code created and updated. But, of course, you need to make sure you can figure
    out what’s wrong when the generated code isn’t working as intended. To help when
    that happens, we’ll briefly discuss how Copilot can assist you with debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with Copilot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve previously discussed several Copilot capabilities that are useful for
    helping you debug problems. We’ve talked about the `/explain` command to help
    explain code that might be having issues, and the `/fix` command to have Copilot
    suggest fixes for bugs. Copilot also has a few other features that can be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: In VS Code, Copilot can help set up and customize debug configurations. For
    example, you can use the `/startDebugging` shortcut command to create a *launch.json*
    file if one doesn’t exist, as shown in [Figure 4-27](#using-startdebugging). The
    same could also be done via a prompt in the chat.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0427.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-27\. Using `/startDebugging` to generate the launch configuration
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The same `/startDebugging` command can also be used to start a debugging session.
    When running the command, if a suitable launch config is not found, Copilot will
    generate one first. In the same conversation, Copilot will then typically include
    a button that you can click to start the actual debug process ([Figure 4-28](#debugging-session-fro)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0428.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-28\. A debugging session from Copilot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In some IDEs, like Visual Studio, Copilot integration includes an *exception
    helper*. This means that if an exception like `IndexOutOfRangeException` occurs
    during a debugging exception, a pop-up will display an Ask Copilot option. Copilot
    will provide an explanation of the error, a suggested code fix, and can even preview
    and apply the fix directly in your IDE. For more details on how to use this, see
    [the documentation](https://oreil.ly/QopeF).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re doing unit testing with Test Explorer in Visual Studio 2022, you
    have a Debug with Copilot button available. With this feature, Copilot does the
    following when a test fails:'
  prefs: []
  type: TYPE_NORMAL
- en: Generates a comprehensive debug plan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets breakpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watches critical variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guides you through the debugging process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, Copilot analyzes values of variables at breakpoints, providing
    guidance and suggestions in a feedback loop.
  prefs: []
  type: TYPE_NORMAL
- en: IDE-Specific Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some features in Copilot are only available in certain IDEs. The exception helper
    and Debug with Copilot option in Test Explorer are only available in Visual Studio
    (not in other IDEs like VS Code) at the time of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copilot also provides another command in some IDEs called `copilot-debug`.
    You can run this command from a terminal with your application to start a debug
    session. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: copilot-debug Issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `copilot-debug` can be convenient in the terminal, it seems to get *stuck*
    in some cases waiting for the IDE to connect. If you encounter an issue running
    it, try the `/startDebugging` command or built-in functionality in the IDE to
    run a debug session.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can use one other technique to debug issues that ties back in with
    the Copilot Vision functionality we discussed previously. You can have Copilot
    debug a problem from a screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a screenshot of some simple C# code (as shown in [Figure 4-29](#screenshot-of-c-sharp))
    saved as the file *Screenshot 2025-04-28 at 12.37.05 PM.png*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0429.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-29\. Screenshot of C# code
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can attach that file to our chat dialog and then ask Copilot to help us debug
    any issues with it. [Figure 4-30](#prompt-to-debug-from) shows one possible prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0430.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-30\. A prompt to debug from the screenshot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After processing the prompt and the screenshot, Copilot responds by detailing
    an unhandled exception that can result from a divide-by-zero condition and suggesting
    code to resolve the issue ([Figure 4-31](#results-of-analyzing)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_0431.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-31\. Results of analyzing the screenshot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Ultimately, whether you take advantage of any of the built-in features for debugging
    in Copilot, the chat interface is still one of your best tools. When you encounter
    an issue and aren’t sure why it happens, try asking Copilot via a query. Remember
    that specific queries like “Why does this API call fail for valid input?” yield
    better results than vague requests.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve looked at several advanced editing and workflow functionalities,
    including NES, Copilot Edits, Copilot Agent mode, and Copilot Vision. If you have
    a limited set of changes, deciding which of the first three to use can be confusing.
    [Table 4-1](#comparing-advanced-co) provides some suggestions to try to clarify
    when to use each.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of scope, a simple way to think about the differences is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: NES works at the code-edit level (single file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copilot Edits operates at the project session level (multiple files).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agent mode functions at the system level (code + terminal + testing).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For quick inline fixes, NES provides instant suggestions. Copilot Edits is great
    for guided multifile changes. Agent mode handles complete development lifecycle
    tasks including code updates and creation, validation, and execution.
  prefs: []
  type: TYPE_NORMAL
- en: With all these features, Copilot provides developer control through Keep/Undo
    mechanisms and the ability to *roll back* changes.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot Vision allows Copilot to extract information from images, such as screenshots
    of a problem, design diagrams, application interfaces, and more. With the extracted
    information, Copilot can answer questions about the image, do analysis, create
    text or code based on the image, or leverage parts of the image to solve problems
    or complete a task. The functionality is easy to use by simply pasting/dragging
    an image into the chat input area, regardless of which chat mode you’re in.
  prefs: []
  type: TYPE_NORMAL
- en: There’s one other key point to make about Agent mode. AI agents are growing
    in capabilities, utility, abilities to interact with their environment, and adaptability
    for handling all kinds of tasks. Expect Copilot’s agentic AI capabilities to continue
    to expand and grow and be used in other parts of the IDEs and Copilot interfaces.
    There is really no limit to what the agent component can do, given the right prompting
    and tools.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot also includes tools to help with debugging, such as the shortcut `/startDebugging`
    command. You can even have Copilot analyze and debug from screenshots. Along with
    other functionality previously discussed to explain and fix problems via Copilot,
    these tools can help you more quickly determine the causes of issues. It’s important
    to note, though, that not all Copilot debug features are provided in all IDEs.
    Your best bet may still be asking Copilot specific *why* questions about issues
    in the chat interface.
  prefs: []
  type: TYPE_NORMAL
- en: With this solid foundation on the basic and advanced use of Copilot, we can
    move on to some of the targeted tasks it can help with, such as test generation,
    documentation, and code translation. These capabilities can be among the most
    valuable to reduce your time spent doing routine tasks and allowing for more focus
    on the interesting and fun parts of writing code. We’ll discuss how to leverage
    Copilot to handle these in the next few chapters, starting with using Copilot
    for testing in [Chapter 5](ch05.html#ch05).
  prefs: []
  type: TYPE_NORMAL
