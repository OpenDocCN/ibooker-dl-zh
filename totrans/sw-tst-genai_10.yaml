- en: 9 AI agents as testing assistants
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9个AI代理作为测试助手
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding how AI agents can be built using LLMs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何使用LLMs构建AI代理
- en: Creating a basic AI agent to demonstrate their value
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个基本的AI代理来展示其价值
- en: Over the previous few chapters, we saw how large language models (LLMs) can
    assist us in testing. We also learned how to employ various prompt techniques
    to get the most out of LLMs and curate different prompts that can be utilized
    when required. This is a great position to be in, but what if we could take our
    new understanding one step further to create custom-made AI testing assistants?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的几章中，我们看到了大型语言模型（LLMs）如何帮助我们进行测试。我们还学习了如何使用各种提示技术充分利用LLMs，并编制出在需要时可以使用的不同提示。这是一个很好的位置，但如果我们能将我们的新理解再向前迈进一步，创建定制的AI测试助手会怎样呢？
- en: As LLMs have advanced, so have the opportunities to create AI agents, applications
    that can take a goal and autonomously interact with other systems, collect data,
    analyze information, and adapt a suitable response to achieve said goal. In the
    field of AI, an agent can be implemented in many ways, but the goal tends to be
    the same—to create something that we can give a task to be solved. The scope of
    designing and building AI agents is large, but in this chapter, we’ll learn a
    bit more about their potential and how they work in the context of generative
    AI. We’ll also create our own basic test data AI agent to demonstrate the power
    and potential of this technology.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随着LLMs的进步，创建AI代理、可以自主与其他系统交互、收集数据、分析信息并适应适当响应以实现目标的应用程序的机会也在增加。在AI领域，代理可以以许多方式实现，但目标往往相同——创建我们可以分配任务以解决的东西。设计和构建AI代理的范围很广，但在这章中，我们将更多地了解它们的潜力和在生成式AI背景下的工作方式。我们还将创建我们自己的基本测试数据AI代理，以展示这项技术的力量和潜力。
- en: 9.1 Understanding AI agents and LLMs
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 理解AI代理和LLMs
- en: When we discuss AI agents, we need to specify what we mean. AI agents can be
    implemented in different ways, depending on the field of AI we are working in.
    But that’s not to say that there aren’t expected behaviors of an agent regardless
    of how it works. So, before we begin to implement our agents, let’s first define
    what these expected behaviors might look like and then how agents might be built
    in the context of generative AI.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论AI代理时，我们需要明确我们所说的意思。AI代理可以根据我们工作的AI领域以不同的方式实现。但这并不意味着无论其工作方式如何，代理都没有预期的行为。因此，在我们开始实现我们的代理之前，让我们首先定义这些预期行为可能的样子，然后讨论在生成式AI的背景下如何构建代理。
- en: 9.1.1 What defines an AI agent?
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 什么是AI代理？
- en: 'To comprehend what defines an agent, we have to focus more on the characteristics
    that are imbued within it than on its implementation. There is no explicit list
    of characteristics an agent is expected to meet, but the following attributes
    are usually found:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解什么是代理，我们必须更多地关注其中注入的特性，而不是它的实现。没有明确的特性列表表明代理应该满足，但以下属性通常是存在的：
- en: '*Being goal-driven*—An agent must be able to receive a goal that it can ultimately
    achieve. The goal itself can be something that is either specific, such as “Make
    me a hotel booking for X,” or more abstract, such as “Determine the most successful
    stock to buy next month based on current trends.” Regardless of the scope of the
    goal, some sort of direction is required to help us evaluate whether the actions
    an agent is taking are bringing it closer to completing its task.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*以目标为导向*——代理必须能够接收一个它可以最终实现的目标。目标本身可以是具体的，例如“为我预订X酒店的房间”，或者更抽象的，例如“根据当前趋势确定下个月最成功的股票”。无论目标范围如何，都需要某种方向来帮助我们评估代理采取的行动是否使其更接近完成任务。'
- en: '*Being perceptive—*An agent must also be able to interact with the wider world.
    This might mean extracting information, or interacting with a system to produce
    results. Examples might include making an HTTP request to a web API to get data
    for processing or running web automation code to complete a booking form. Whatever
    we want our agent to achieve, we have to give it the ability to interact with
    the world outside so that it can solve problems for us.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*具有感知能力*——代理还必须能够与更广泛的世界互动。这可能意味着提取信息，或与系统交互以产生结果。例如，可能包括向Web API发出HTTP请求以获取用于处理的数据，或运行Web自动化代码以完成预订表单。无论我们希望我们的代理实现什么目标，我们都必须赋予它与世界外部互动的能力，以便它能为我们解决问题。'
- en: '*Have autonomy*—Perhaps most crucially, an agent must be able to autonomously
    decide how a problem is solved. Instead of following a clear, algorithmic path
    that we set out, it can pick and choose what tasks to do and in what order. This
    is where the core element of an agent is usually found. By evaluating the goal
    it has been given, it can interact with the world, carry out tasks, and evaluate
    whether said tasks align with the goal it’s been set.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*具有自主性*——也许最重要的是，代理必须能够自主决定如何解决问题。它不必遵循我们设定的清晰、算法化的路径，而是可以选择和决定要执行的任务及其顺序。这就是代理的核心要素通常所在的地方。通过评估它被赋予的目标，它可以与世界互动，执行任务，并评估这些任务是否与其设定的目标一致。'
- en: '*Being adaptive*—Finally, agents must also be able to learn from actions. For
    example, agents that can complete video games do so by learning from the mistakes
    they make. But it can just mean reacting to specific information that is retrieved
    at a given point in time. Much like in autonomy, the goal that has been set plays
    a role in determining if an agent has been successful when carrying out a specific
    task. If it has not, we want our agent to be able to react to that failure not
    to repeat it or to work around it to achieve its set goal.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*具有适应性*——最后，代理还必须能够从行动中学习。例如，能够完成视频游戏的代理是通过从它们犯的错误中学习来做到这一点的。但这也可以仅仅意味着对在特定时间点检索到的特定信息做出反应。与自主性类似，设定的目标在确定代理在执行特定任务时是否成功时发挥作用。如果没有，我们希望我们的代理能够对这种失败做出反应，而不是重复它或绕过它来实现其设定的目标。'
- en: This is not an exhaustive list of characteristics. Depending on the problem
    an agent is being asked to solve will determine which characteristics matter more.
    However, the examples provided give us a sense of what an AI agent might look
    like and how it behaves. Thus, an agent is an autonomous piece of software thar
    can be given a relatively complex task and solve it for us.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个详尽的特性列表。根据代理被要求解决的问题将决定哪些特性更重要。然而，提供的例子让我们对AI代理可能的样子及其行为有了概念。因此，代理是一块可以执行相对复杂任务并为我们解决问题的自主软件。
- en: 9.1.2 How an agent works with LLMs
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 代理如何与LLM协同工作
- en: So, how are these characteristics created when using LLMs to drive an agent?
    The answer is, “through the use of an LLM feature called *function calling*,”
    which allows us to encapsulate code into functions that an LLM can trigger for
    us when it is prompted to complete a task. To help us better understand this process,
    figure 9.1 outlines the general process of how function calling works.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在使用LLM（大型语言模型）驱动代理时，这些特征是如何产生的呢？答案是，“通过使用一个名为*函数调用*的LLM功能，”这使我们能够将代码封装成函数，当LLM被提示完成一个任务时，它可以为我们触发这些函数。为了帮助我们更好地理解这个过程，图9.1概述了函数调用的一般工作流程。
- en: '![](../../OEBPS/Images/CH09_F01_Winteringham2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F01_Winteringham2.png)'
- en: Figure 9.1 An outline of an LLM agent using function calling
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 使用函数调用的LLM代理概述
- en: As described in the figure, function calling works by providing both a prompt
    and encapsulated code to an LLM. The LLM can then determine which function to
    run to achieve the goal set within our prompt. Inside each function, there will
    be code built by us that will process information or interact with the outside
    world in some shape, form, or manner. For example, a function might extract data
    from a web API, scrape a web page, or gather information from a sensor. A function
    may also be sent parameters from the LLM to apply further processing on received
    data before sending it back to the LLM for future use.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所述，函数调用通过向LLM提供提示和封装的代码来实现。然后LLM可以确定运行哪个函数以达到我们在提示中设定的目标。在每一个函数内部，都会有我们构建的代码，这些代码将以某种形式处理信息或与外界进行交互。例如，一个函数可能从Web
    API中提取数据，抓取网页，或从传感器收集信息。一个函数也可能从LLM接收参数，在将数据发送回LLM用于未来使用之前对其进行进一步处理。
- en: What gives our agents their autonomous characteristic is an LLM’s ability to
    determine which functions are called when and with what data. Each function we
    create is provided with some additional instructions to help the LLM determine
    what our code within the function does. When given a task to complete, the LLM
    can process the initial prompt, select the right function to call first, and store
    any information that is returned by a function into the prompt itself.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的代理具有自主特性的，是LLM确定何时以及使用什么数据调用哪些函数的能力。我们创建的每个函数都提供了一些额外的指令，以帮助LLM确定函数内部我们的代码做了什么。当被分配一个任务去完成时，LLM可以处理初始提示，选择首先调用的正确函数，并将函数返回的任何信息存储到提示本身中。
- en: This autonomy is what distinguishes an agent from a tool that executes an ordered
    list of functions that interacts with different APIs or services. An agent may
    be given a large collection of various functions that process information and
    interact with the world in different ways, utilizing only the necessary functions
    to solve a problem.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自主性是区分代理与执行一系列函数的工具的关键，这些函数与不同的API或服务交互。代理可能被赋予大量各种函数，这些函数以不同的方式处理信息和与世界交互，仅使用必要的函数来解决问题。
- en: 9.2 Creating an AI Test Assistant
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 创建AI测试助手
- en: 'Now that we have a grounding in what agents are and how they work in the context
    of generative AI, let’s build our own. For this example, we’ll be building an
    AI agent that will read and create data for us when given instructions. This might
    feel like a somewhat simple agent, but to get into more advanced topics around
    agents would require another whole book. However, with this example, we’ll get
    a better understanding of how an agent can be built with the use of LLMs so that
    we can take both our prompt engineering and agent building to the next level.
    We’ll go through the process of creating our AI agent step by step, but you can
    check our completed version for reference at: [https://mng.bz/aVlJ](https://mng.bz/aVlJ).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了代理是什么以及它们在生成式AI环境中的工作方式，让我们自己构建一个。在这个例子中，我们将构建一个AI代理，当给出指令时，它会为我们读取和创建数据。这可能看起来是一个相对简单的代理，但要深入了解代理的高级主题，可能需要另一整本书。然而，通过这个例子，我们将更好地理解如何使用LLMs构建代理，以便我们可以将我们的提示工程和代理构建提升到下一个层次。我们将逐步创建我们的AI代理，但您可以在以下链接查看我们的完成版本以供参考：[https://mng.bz/aVlJ](https://mng.bz/aVlJ)。
- en: 9.2.1 Setting up our dummy AI agent
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 设置我们的虚拟AI代理
- en: 'We begin by creating a Maven project, and within our `pom.xml` file, we add
    the following dependencies:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个Maven项目，并在我们的`pom.xml`文件中添加以下依赖项：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Functions to quickly connect to OpenAI platform
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 快速连接到OpenAI平台的函数
- en: ❷ AI services to create our AI agent
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建我们的AI代理的AI服务
- en: ❸ Database to manipulate with our agent
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 数据库用于与我们的代理交互
- en: 'We’ll be using LangChain4J (h[ttps://docs.langchain4j.dev](https://docs.langchain4j.dev))
    to manage both the communication with our LLM and the necessary functions we want
    our agent to execute. This will become clearer when we implement said functions,
    but first, let’s establish our connection to LLM by creating a new class called
    `DataAssistant` with a `main` function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用LangChain4J（[https://docs.langchain4j.dev](https://docs.langchain4j.dev)）来管理与我们LLM的通信以及我们希望代理执行的必要函数。当实现这些函数时，这会变得更加清晰，但首先，让我们通过创建一个名为`DataAssistant`的新类并添加一个`main`函数来建立我们与LLM的连接：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we can update the class with the necessary code to send a basic prompt
    to a gpt-3.5-turbo model:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更新类，添加必要的代码来向gpt-3.5-turbo模型发送一个基本提示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Creates an interface to add our AI services into
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个接口，将我们的AI服务添加进去
- en: ❷ Sets up access to our OpenAI model and model preference
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置访问我们的OpenAI模型和模型偏好
- en: ❸ Uses AiServices.builder to add our model to our DataAssistantService
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用AiServices.builder将我们的模型添加到DataAssistantService中
- en: ❹ Sends a basic prompt to OpenAI, stores the response, and outputs it
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 向OpenAI发送基本提示，存储响应并输出
- en: 'The `OpenAiChatModel` portion of the code establishes which model we want to
    connect and our authorization method. Within the `.apiKey` method, we provide
    an API key from OpenAI that can be generated via their API keys page found at
    [https://platform.openai.com/api-keys](https://platform.openai.com/api-keys).
    We then provide the model as a parameter when setting up our `DataAssistantService`
    using the `AiServices` library. This lets us keep our model choice and our AI
    services separate, allowing us to easily change the model we want to use. The
    `DataAssistantService` interface helps to configure the method we want to use
    to send our prompt, as well as add other advanced features if we desire, such
    as system prompts that contextualize the user prompts that we want to send once
    our service is established. We’ll start to see how `AiServices` comes into its
    own shortly, but for now, we can test our implemented code out by running it and
    getting a response similar to the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的`OpenAiChatModel`部分确定了我们想要连接的模型以及我们的授权方法。在`.apiKey`方法中，我们提供了一个来自OpenAI的API密钥，该密钥可以通过他们位于[https://platform.openai.com/api-keys](https://platform.openai.com/api-keys)的API密钥页面生成。然后，在设置`DataAssistantService`时，我们使用`AiServices`库将模型作为参数提供。这使得我们可以将模型选择和AI服务分开，从而可以轻松地更改我们想要使用的模型。`DataAssistantService`接口有助于配置我们想要用来发送提示的方法，以及如果我们希望的话，添加其他高级功能，例如系统提示，这些提示将上下文化我们想要发送的用户提示，一旦我们的服务建立。我们很快就会看到`AiServices`是如何发挥其作用的，但到目前为止，我们可以通过运行它并获取以下类似的响应来测试我们实现的代码：
- en: '|'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| Hello, I am a language model AI assistant created by OpenAI. I am here to
    help answer your questions and assist you with any information you may need. How
    can I help you today? |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 你好，我是一个由OpenAI创建的语言模型AI助手。我在这里帮助你回答问题，并协助你获取可能需要的任何信息。今天我能帮您什么忙？ |'
- en: 'Now that we are connected to our LLM, we can begin to build out the tasks we
    want our agent to trigger to give our assistant some agency. To do this, we create
    a new class called `DataAssistantTools` and add the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经连接到我们的LLM，我们可以开始构建我们想要我们的代理触发的任务，以给我们的助手一些自主权。为此，我们创建了一个名为`DataAssistantTools`的新类，并添加了以下代码：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We’ve now created three functions that our LLM can choose to trigger when prompted.
    But how does the LLM determine which function to trigger at a given time? This
    is achieved by using the `@Tool` annotation provided by `LangChain4J`. The `@Tool`
    annotation not only identifies what method to trigger, but also indicates to the
    LLM in natural language what the code does, so that the LLM can determine if it’s
    a function that is worth calling. For example, our first tool has the annotation
    `@Tool("Create` `room records")`. If we send a prompt to our LLM, along with our
    tool, asking it to create some rooms, then the LLM will determine that our tool
    should be executed. If we were to send a prompt with an entirely different message,
    then the tool might not be used. We’ll see this in action shortly, but first,
    let’s update our `AiServices` builder so that it incorporates our newly created
    `DataAssistantTools`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了三个函数，我们的LLM可以在提示时选择触发。但是LLM是如何确定在给定时间触发哪个函数的呢？这是通过使用`LangChain4J`提供的`@Tool`注解来实现的。`@Tool`注解不仅标识了要触发的函数，而且还向LLM用自然语言说明了代码的作用，这样LLM就可以确定它是否是一个值得调用的函数。例如，我们的第一个工具具有`@Tool("Create
    room records")`的注解。如果我们向我们的LLM发送一个提示，包括我们的工具，要求它创建一些房间，那么LLM将确定我们的工具应该被执行。如果我们发送一个完全不同的消息的提示，那么工具可能不会被使用。我们很快就会看到这一点，但首先，让我们更新我们的`AiServices`构建器，使其包含我们新创建的`DataAssistantTools`：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Adds our tools via the tools() method within the builder
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过构建器中的`tools()`方法添加我们的工具
- en: ❷ Sets up a Scanner to keep the app running and receive prompts
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置一个扫描器以保持应用运行并接收提示
- en: As we can see, the `AiServices` builder begins to demonstrate its value by allowing
    us to set both the model we want to use and the tools we want the agent to use.
    We’ve also updated our means of inputting prompts so that the application stays
    up and running continuously and we can test out our new agent with different instructions.
    So, when we run the agent and are asked
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`AiServices`构建器开始展示其价值，它允许我们设置我们想要使用的模型和我们想要代理使用的工具。我们还更新了输入提示的方式，以便应用程序可以持续运行，我们可以用不同的指令测试我们的新代理。因此，当我们运行代理并被询问
- en: '|'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| What do you need? |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 您需要什么？ |'
- en: 'we can submit our prompt:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提交我们的提示：
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Can you create me 4 rooms and 2 bookings and tell me what’s in the db |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 你能为我创建4个房间和2个预订，并告诉我数据库里有什么吗 |'
- en: 'to be returned the following response:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回以下响应：
- en: '|'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| You want me to create 4 rooms.You want me to create 2 bookings.I’ll then
    share current database details |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 你希望我创建4个房间。你希望我创建2个预订。然后我会分享当前数据库的详细信息 |'
- en: Let’s break down how this output has been generated. First, we’ve sent our prompt
    and tools to gpt-3.5-turbo to process. The model then evaluates the details of
    the prompts and looks through the list of tools we’ve tagged using the `@Tool`
    annotation to find which tools are relevant to our instructions. At the start
    of the prompt, we requested “Can you create me 4 rooms,” and the LLM has determined
    that our `createRooms` tool should be run because of its relevance to the annotation
    `@Tool("Create` `room records")`. Next, we can see that the output correctly stated
    that we want to create four rooms. This is because we passed a parameter into
    our `createRooms` method using LangChain’s `@P` annotation in the form of `@P("Amount`
    `of` `room` `records` `to` `create") int` `count`. Notice how we provide natural
    language context again to the `@P` annotation in a similar fashion to the `@Tool`
    annotation. This allows the LLM to do a similar relevancy match, extract what
    it believes is the necessary data from our prompt, and provide it as a parameter
    to be output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这个输出是如何生成的。首先，我们将我们的提示和工具发送到gpt-3.5-turbo进行处理。然后，模型评估提示的细节，并查看我们使用`@Tool`注解标记的工具列表，以找到与我们的指令相关的工具。在提示的开始，我们请求“你能为我创建4个房间”，LLM确定我们的`createRooms`工具应该运行，因为它与注解`@Tool("Create
    room records")`相关。接下来，我们可以看到输出正确地说明了我们想要创建四个房间。这是因为我们通过LangChain的`@P`注解以`@P("Amount
    of room records to create") int count`的形式将一个参数传递给我们的`createRooms`方法。注意我们如何再次以类似`@Tool`注解的方式为`@P`注解提供自然语言上下文。这允许LLM进行类似的相关性匹配，从我们的提示中提取它认为必要的数据，并将其作为参数输出。
- en: We can now also test our agent’s ability to determine which tool to use autonomously
    by giving it different instructions. This time, when asked for a prompt, we sent
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在也可以通过给出不同的指令来测试我们的智能体自主确定使用哪个工具的能力。这次，当被要求给出一个提示时，我们发送了
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Can you tell me what’s in the database currently |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 你能告诉我数据库当前有什么吗 |'
- en: 'Running this would return the response:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此操作将返回以下响应：
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| I’ll then share current database details |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 然后，我会分享当前数据库的详细信息 |'
- en: In this case, the LLM has triggered only one of our tools, specifically `displayDatabase`
    annotated as `@Tool("Show` `results` `of` `database")`. Since we’ve not mentioned
    creating rooms or bookings in our prompt, the related tools are deemed not relevant
    to our instructions and are therefore ignored. This demonstrates the power of
    agents. Imagine if we had not just 3 tools, but 10, 20, or more. The more we add,
    the more ways we give an agent the ability to react to our instructions and solve
    our requested problems.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，LLM只触发了我们的一个工具，即被标注为`@Tool("Show results of database")`的`displayDatabase`。由于我们在提示中未提及创建房间或预订，相关的工具被认为与我们的指令不相关，因此被忽略。这展示了智能体的强大能力。想象一下，如果我们不仅仅有3个工具，而是有10个、20个或更多，那么我们给智能体提供反应我们指令和解决我们请求的问题的方式就更多了。
- en: 9.2.2 Giving our AI agent functions to execute
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 给我们的AI智能体执行函数
- en: 'We have the decision-making process wired up, so now let’s complete our agent
    and give it the ability to carry out some database queries for us. For this, we’re
    going to create a dummy database using `h2` with some basic tables to demonstrate
    how we can have our LLM execute actions for us. To do this, we’ll start by creating
    a new class `QueryTools` and adding the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了决策过程，现在让我们完成智能体，并给它执行一些数据库查询的能力。为此，我们将使用`h2`创建一个模拟数据库，其中包含一些基本表，以展示我们如何让我们的LLM为我们执行操作。为此，我们将首先创建一个新的类`QueryTools`并添加以下代码：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ On startup, creates a database with the necessary tables
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 启动时创建包含必要表的数据库
- en: ❷ A basic method to create rooms
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建房间的基本方法
- en: ❸ A basic method to create bookings
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建预订的基本方法
- en: ❹ A basic method to output the contents of each table
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 输出每个表内容的基本方法
- en: 'With our `QueryTools` class created, we can then expand our tools to interact
    with the database how we like by updating `DataAssistantTools`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了`QueryTools`类之后，我们就可以通过更新`DataAssistantTools`来扩展我们的工具，以便以我们喜欢的方式与数据库交互。
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Creates a new instance of our database on startup
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在启动时创建数据库的新实例
- en: ❷ Creates rooms by looping through the number of rooms requested
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过循环请求的房间数量创建房间
- en: ❸ Creates bookings by looping through the amount of bookings requested
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过循环请求的预订数量创建预订
- en: ❹ Outputs the contents of each table
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 输出每个表的内容
- en: 'Finally, we update our `main` method within our `DataAssistant` class to handle
    `SQLException`, resulting in the following completed code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更新`DataAssistant`类中的`main`方法以处理`SQLException`，结果如下完成代码：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With everything in place, we can now test the agent by first requesting it
    create our desired data:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪后，我们现在可以通过首先请求它创建我们所需的数据来测试代理：
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Create me 2 rooms and 3 bookings |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 创建我2个房间和3个预订 |'
- en: 'It then results in a response such as:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它会产生如下响应：
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| Two rooms and three bookings have been successfully created. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 成功创建了两个房间和三个预订。 |'
- en: We can then confirm that our data has been created by sending additional instructions
    to the agent
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向代理发送额外的指令来确认我们的数据已被创建
- en: '|'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| List me the database contents |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 列出数据库内容 |'
- en: resulting in an output that looks similar to
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出看起来类似于
- en: '|'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| Current ROOM database state:101 single 1 TRUE /images/room2.jpg A generated
    description [TV, WiFi, Safe] 100101 single 1 TRUE /images/room2.jpg A generated
    description [TV, WiFi, Safe] 100Current BOOKING database state:1 James Dean TRUE
    2022-02-01 2022-02-051 James Dean TRUE 2022-02-01 2022-02-051 James Dean TRUE
    2022-02-01 2022-02-05 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 当前房间数据库状态：101 单间 1 真实 /images/room2.jpg 生成描述 [电视, WiFi, 安全] 100101 单间 1 真实
    /images/room2.jpg 生成描述 [电视, WiFi, 安全] 100当前预订数据库状态：1 詹姆斯·迪恩 真实 2022-02-01 2022-02-051
    詹姆斯·迪恩 真实 2022-02-01 2022-02-051 詹姆斯·迪恩 真实 2022-02-01 2022-02-05 |'
- en: With our database queries now wired into our tools, we can interact with our
    agents and have them carry out our tasks. However, let’s go one step further with
    our agent and give it the capability to run multiple tools in a chain, utilizing
    data created in one tool in another.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的数据库查询已经连接到我们的工具中，我们可以与我们的代理交互，并让他们执行我们的任务。然而，让我们更进一步，让我们的代理能够运行多个工具链，利用一个工具中创建的数据在另一个工具中使用。
- en: 9.2.3 Chaining tools together
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 将工具链接在一起
- en: Currently, our tools are independent of one another. The room tool creates rooms
    that generate unique `roomid` keys for each row, but we’re not using them when
    we create new bookings. We’re simply hardcoding our values. So, to make our agent
    more dynamic, and to give it a more complex problem, let’s look at how we could
    pass the `roomid` of the most recently created room to the booking tool.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的工具是相互独立的。房间工具创建房间，并为每一行生成唯一的`roomid`键，但我们创建新的预订时并没有使用它们。我们只是简单地硬编码我们的值。因此，为了使我们的代理更加动态，并给它一个更复杂的问题，让我们看看我们如何将最近创建的房间的`roomid`传递给预订工具。
- en: 'To begin, we need to create an additional method in our `QueryTools` class
    that will either return the `roomid` of the most recently created room or an `id`
    of `0` if there are no rooms currently in the database:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在`QueryTools`类中创建一个额外的方法，该方法将返回最近创建的房间的`roomid`，如果没有房间在数据库中，则返回`id`为`0`：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With our new method in place, we next create a new tool with `DataAssistantTools`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新方法到位后，我们接下来使用`DataAssistantTools`创建一个新的工具：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice how we have set out within the `@Tool` annotation that we expect this
    prompt to be run after rooms have been created. Although this doesn’t guarantee
    the order in which tools are run by our LLM, it acts as a guardrail if we want
    rooms and bookings to be created in a specific order. Additionally, we are returning
    the `roomid` integer to the LLM. This is then stored in the context of our original
    prompt for future use, which we’ll establish by updating our `createBookings`
    method to the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在`@Tool`注解中设置，我们期望在创建房间之后运行此提示。虽然这并不保证我们的LLM按特定顺序运行工具，但如果我们要按特定顺序创建房间和预订，它充当了一个安全网。此外，我们将`roomid`整数返回给LLM。然后，我们将它在原始提示的上下文中存储起来以供将来使用，我们将通过更新我们的`createBookings`方法来实现这一点：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this updated method, we’ve added a new parameter in the form of `@P("Most
    recent` `roomid")` `int` `roomid`. To see the `roomid` extraction in action, we
    `System.out` the `roomid` before passing it `createBooking` for use in our `INSERT`
    statement. To use the `roomid`, we return to `QueryTools` and update the `createBooking`
    method to take `roomid` as a parameter and add it to our SQL statement:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更新方法中，我们添加了一个新的参数，形式为`@P("Most recent` `roomid")` `int` `roomid`。为了看到`roomid`提取的实际效果，我们在将其传递给`createBooking`用于我们的`INSERT`语句之前，使用`System.out`打印出`roomid`。为了使用`roomid`，我们返回到`QueryTools`并更新`createBooking`方法，使其接受`roomid`作为参数并将其添加到我们的SQL语句中：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we have the code in place for our agent to extract the `roomid` from our
    database using one tool and then use that value within a second tool, which we
    can see in action in this example chat I had with my version of our agent:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的代理编写了代码，使其能够使用一个工具从我们的数据库中提取`roomid`，然后使用第二个工具中的该值，我们可以在以下示例聊天中看到这一功能是如何工作的：
- en: '|'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| What do you need? |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 你需要什么？ |'
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Create three rooms |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 创建三个房间 |'
- en: '|'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| Three rooms have been successfully created. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 已成功创建三个房间。 |'
- en: '|'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| What do you need? |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 你需要什么？ |'
- en: '|'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| List database |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 列表数据库 |'
- en: '|'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| Current ROOM database state:101 single 1 TRUE /images/room2.jpg A generated
    description [TV, WiFi, Safe] 100101 single 1 TRUE /images/room2.jpg A generated
    description [TV, WiFi, Safe] 100101 single 1 TRUE /images/room2.jpg A generated
    description [TV, WiFi, Safe] 100Current BOOKING database state:The database has
    been successfully displayed. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 当前房间数据库状态：101 单人间 1 可用 /images/room2.jpg 生成描述 [电视，WiFi，保险箱] 100101 单人间 1
    可用 /images/room2.jpg 生成描述 [电视，WiFi，保险箱] 100101 单人间 1 可用 /images/room2.jpg 生成描述
    [电视，WiFi，保险箱] 100 当前预订数据库状态：数据库已成功显示。 |'
- en: '|'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| What do you need? |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 你需要什么？ |'
- en: '|'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Create three bookings |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 创建三个预订 |'
- en: '|'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| I will create the bookings for room: 3Current ROOM database state:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '| 我将为房间：3创建预订。当前房间数据库状态：'
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Current BOOKING database state:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当前预订数据库状态：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Three bookings have been successfully created. |
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 已成功创建三个预订。 |
- en: Breaking down the output, we can see that three rooms were created, which we
    confirm by asking the agent to list the current rooms. Then the agent was asked
    to create three bookings, which it did successfully. Notice the second integer
    on each row underneath `Current` `BOOKING` `database` `state:`. See how they are
    now using the `roomid:` `3`. The agent has successfully utilized both tools to
    query the most recent `roomid` before passing the retrieved `id` to the second
    tool that creates our bookings for us. We can confirm this isn’t a coincidence
    by creating further rooms to confirm that a newer, more recent `roomid` is added
    to the additional bookings we create (in this example, `roomid` ticks up to `6`).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 分析输出，我们可以看到创建了三个房间，我们通过询问代理列出当前房间来确认这一点。然后，代理被要求创建三个预订，它成功地完成了这一任务。注意在`Current`
    `BOOKING` `database` `state:`之下的每一行的第二个整数。看看它们现在是如何使用`roomid:` `3`的。代理已成功利用这两个工具查询最新的`roomid`，在将检索到的`id`传递给第二个工具（为我们创建预订的工具）之前。我们可以通过创建更多的房间来确认这不是巧合，以确认在创建的额外预订中添加了更新、更近的`roomid`（在这个例子中，`roomid`增加到`6`）。
- en: '|'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| What do you need? |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 你需要什么？ |'
- en: '|'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Create three more rooms |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 创建另外三个房间 |'
- en: '|'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| Three rooms have been created successfully. Here is the updated database:
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 已成功创建三个房间。以下是更新后的数据库： |'
- en: '|'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| What do you need? |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 你需要什么？ |'
- en: '|'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Create three more bookings |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 创建另外三个预订 |'
- en: '|'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| I will create the bookings for room: 6Three bookings have been successfully
    created. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 我将为房间：6创建预订。三个预订已成功创建。 |'
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '| What do you need? |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 你需要什么？ |'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![MW标志](../../OEBPS/Images/logo-MW.png)'
- en: '| List database |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 列表数据库 |'
- en: '|'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![OpenAI标志](../../OEBPS/Images/logo-openai.png)'
- en: '| Current ROOM database state:101 single 1 TRUE /images/room2.jpg A generated
    description [TV, WiFi, Safe] 100101 single 1 TRUE /images/room2.jpg A generated
    description [TV, WiFi, Safe] 100101 single 1 TRUE /images/room2.jpg A generated
    description [TV, WiFi, Safe] 100101 single 1 TRUE /images/room2.jpg A generated
    description [TV, WiFi, Safe] 100101 single 1 TRUE /images/room2.jpg A generated
    description [TV, WiFi, Safe] 100101 single 1 TRUE /images/room2.jpg A generated
    description [TV, WiFi, Safe] 100Current BOOKING database state:3 James Dean TRUE
    2022-02-01 2022-02-053 James Dean TRUE 2022-02-01 2022-02-053 James Dean TRUE
    2022-02-01 2022-02-056 James Dean TRUE 2022-02-01 2022-02-056 James Dean TRUE
    2022-02-01 2022-02-056 James Dean TRUE 2022-02-01 2022-02-05 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 当前ROOM数据库状态：101 单间 1 真实 /images/room2.jpg 生成描述 [电视，WiFi，保险箱] 100101 单间 1
    真实 /images/room2.jpg 生成描述 [电视，WiFi，保险箱] 100101 单间 1 真实 /images/room2.jpg 生成描述
    [电视，WiFi，保险箱] 100101 单间 1 真实 /images/room2.jpg 生成描述 [电视，WiFi，保险箱] 100101 单间 1
    真实 /images/room2.jpg 生成描述 [电视，WiFi，保险箱] 100Current BOOKING数据库状态：3 詹姆斯·迪恩 真实 2022-02-01
    2022-02-053 詹姆斯·迪恩 真实 2022-02-01 2022-02-053 詹姆斯·迪恩 真实 2022-02-01 2022-02-056
    詹姆斯·迪恩 真实 2022-02-01 2022-02-056 詹姆斯·迪恩 真实 2022-02-01 2022-02-056 詹姆斯·迪恩 真实 2022-02-01
    2022-02-05 | '
- en: This completes our basic data creator agent. We’ve looked at how we can create
    multiple tools for an agent to use and solve specific requests for us. These tools
    allow us to give an agent the ability to interact with the world around us. For
    example, we could create code to extract relevant data from a data source, connect
    to sensors or IoT (Internet of Things) devices, or interact with external websites.
    We’ve also seen how the results of those interactions with third parties can be
    fed back into our LLM for it to determine what next steps to take, as well as
    utilize extracted information for further use.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的基本数据创建代理。我们已经探讨了如何为代理创建多个工具，以便它能够使用这些工具来解决我们的特定请求。这些工具使我们能够赋予代理与周围世界互动的能力。例如，我们可以创建代码从数据源中提取相关数据，连接到传感器或物联网（IoT）设备，或与外部网站进行交互。我们还看到了这些与第三方交互的结果如何被反馈到我们的LLM中，以便它确定下一步要采取的行动，以及利用提取的信息进行进一步使用。
- en: Activity 9.1
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 活动9.1
- en: Consider different ways in which this agent could be expanded to do further
    data assistant tasks. Perhaps it could delete or update data or carry further
    analysis on what exists with the example database. Alternatively, consider building
    an agent that carries out other tasks.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑不同的方法来扩展这个代理以执行更多的数据助手任务。也许它可以删除或更新数据，或者对示例数据库中的现有内容进行进一步分析。或者，考虑构建执行其他任务的代理。
- en: 9.3 Moving forward with AI test assistants
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 使用AI测试助手向前迈进
- en: Our test data assistant demonstrates the potential of AI agents as tools that
    can help support testing activities. We can see AI agents as an approach to use
    when we reach a point where our prompts become too complicated, or we want to
    extend them to interface with third-party systems. It’s important, however, to
    have a clear sense of both the opportunities and the challenges of developing
    AI agents. So, let’s reflect on the various areas of testing we’ve used LLMs to
    support us in, the way AI agents could be designed to take our prompts further,
    and what problems might await us.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试数据助手展示了AI代理作为工具支持测试活动的潜力。我们可以将AI代理视为在提示变得过于复杂或我们希望将其扩展到与第三方系统接口时使用的方法。然而，重要的是要清楚地认识到开发AI代理的机会和挑战。因此，让我们回顾一下我们使用LLM支持测试的各个领域，AI代理如何被设计来进一步扩展我们的提示，以及我们可能面临的问题。
- en: 9.3.1 Examples of AI test assistants
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 AI测试助手的例子
- en: We’ve already seen how an AI agent could help extend the use of LLMs in the
    test data space. But to help tie it all together, here are some examples of other
    types of AI agents that would take our prompts and LLM work further.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了AI代理如何帮助扩展LLM在测试数据空间中的应用。但为了将所有这些内容串联起来，这里有一些其他类型的AI代理的例子，它们将进一步提升我们的提示和LLM工作。
- en: Analysis AI agents
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 分析AI代理
- en: We’ve learned how LLMs can help us expand our thinking, suggesting ideas and
    risks that we might not have considered. As AI agents can be connected to a range
    of data sources, an AI agent that enhances our suggestion prompts could be built
    into an assistant that offers suggestions based on collated information across
    a business domain. For example, we might have an agent like the one shown in figure
    9.2.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到LLMs（大型语言模型）如何帮助我们拓展思维，提出我们可能未曾考虑过的想法和风险。由于AI代理可以连接到各种数据源，因此可以构建一个增强我们建议提示的AI代理，该代理基于业务领域内收集的信息提供建议。例如，我们可能有一个如图9.2所示的代理。
- en: '![](../../OEBPS/Images/CH09_F02_Winteringham2.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F02_Winteringham2.png)'
- en: Figure 9.2 An AI agent connected to multiple data sources
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 连接到多个数据源的AI代理
- en: An AI agent such as this one would be able to determine what data sources to
    access based on the instructions given. It might be able to pull in relevant documentation
    from knowledge bases and project management tools or raw data from monitoring
    and analytics tools. All this collated data can then be used to improve responses
    from the LLM when asked a question, a topic we’ll explore more in the following
    chapters.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的AI代理能够根据给出的指令确定访问哪些数据源。它可能能够从知识库和项目管理工具中提取相关文档，或从监控和分析工具中提取原始数据。所有这些收集到的数据都可以用来改进当被问及问题时LLM的响应，我们将在接下来的章节中更深入地探讨这个话题。
- en: Automation assistant AI agents
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化助手AI代理
- en: We also looked at how LLMs are most effective in the test automation space if
    we create prompts that focus on specific tasks when building automation. That
    said, an AI agent’s potential to interact, parse, and share information across
    tools means that we could create an agent like the one in figure 9.3.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如果我们在构建自动化时创建专注于特定任务的提示，LLMs在测试自动化空间中最为有效。尽管如此，AI代理交互、解析和共享信息的能力意味着我们可以创建如图9.3所示的代理。
- en: '![](../../OEBPS/Images/CH09_F03_Winteringham2.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F03_Winteringham2.png)'
- en: Figure 9.3 An AI agent that processes information in different ways
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 以不同方式处理信息的AI代理
- en: An AI agent such as this one would be able to build the parts of automated tests
    in sections. The built sections could then be passed to other tools to be utilized
    in various ways. This doesn’t mean that these types of agents could still fully
    create valuable automation in one shot. Context, again, is an important factor
    that would need to be fed into these types of AI agents to enable them to embed
    rules and expectations into our automation that align with how our product works.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的AI代理能够构建自动化测试的部分。构建的部分可以传递给其他工具，以各种方式使用。这并不意味着这些类型的代理仍然可以一次性完全创建有价值的自动化。上下文，再次强调，是一个重要的因素，需要输入这些类型的AI代理，以使它们能够将规则和期望嵌入到我们的自动化中，与我们的产品工作方式保持一致。
- en: Exploratory testing AI Agents
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 探索性测试AI代理
- en: Finally, in this example, we’re not suggesting that the AI agent could do the
    exploratory testing for us, but an AI agent might prove useful as an assistant
    to the person testing, as shown in figure 9.4.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个例子中，我们并不是建议AI代理能为我们做探索性测试，但如图9.4所示，AI代理可能作为测试人员的助手非常有用。
- en: '![](../../OEBPS/Images/CH09_F04_Winteringham2.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F04_Winteringham2.png)'
- en: Figure 9.4 An AI agent that takes relevant information and uses additional prompts
    to build suggestions
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 从相关信息中获取信息并使用附加提示构建建议的AI代理
- en: Notice how, in the AI agent, we’re creating an assistant that takes an initial
    prompt and then fires off further prompts to an LLM to help develop valuable suggestions.
    Since AI agents can interact with any system via its tools, there’s no reason
    an AI agent couldn’t interact with an LLM as well. The agent in this example helps
    to parse initial instructions and then use them to determine which further prompts
    could be utilized, creating a cascade of different prompts being triggered to
    create some interesting outputs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在AI代理中，我们创建了一个助手，它接受一个初始提示，然后向LLM发送进一步的提示，以帮助生成有价值的建议。由于AI代理可以通过其工具与任何系统交互，因此没有理由AI代理不能与LLM交互。在这个例子中，代理帮助解析初始指令，然后使用这些指令来确定哪些进一步的提示可以被利用，从而触发一系列不同的提示以生成一些有趣的输出。
- en: These are, of course, just hypothetical AI agents, but each example demonstrates
    that their success is rooted in the types of prompts created for the instructions
    an agent receives and the prompts assigned to each tool. Our data agent example
    had only rudimentary prompts, but it is in those spaces where we can provide the
    expectations, parameters, and context to each tool to help an AI agent react in
    a way that proves valuable to us.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些都是假设的AI代理，但每个例子都表明，它们的成功根植于为代理接收的指令和分配给每个工具的提示类型。我们的数据代理示例只有基本的提示，但正是在这些空间中，我们可以为每个工具提供期望、参数和上下文，以帮助AI代理以对我们有价值的方式做出反应。
- en: 9.3.2 Handling the challenges of working with agents
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 处理与代理一起工作的挑战
- en: However, it’s not to say that building, using, and maintaining agents comes
    without its challenges. Here are a few challenges that need to be kept in mind.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着构建、使用和维护代理没有挑战。以下是需要注意的几个挑战。
- en: Examining an LLM’s decision-making process
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 检查LLM的决策过程
- en: Unsurprisingly, one of the biggest challenges with developing agents is their
    indeterministic nature. There’s a good chance that, as you worked through the
    example agent in this chapter, you experienced the agent either not executing
    tools when expected or creating more or fewer data than required. The LLM component
    of an agent that determines what to run and what data to share between tools is
    opaque to us. In our example agent, we are using a third-party LLM, meaning we
    have no insight into its decision-making process. Nor do we have any ability to
    monitor its behavior or control how the LLM is tuned and operates. This lack of
    control and observability can become a major risk in developing agents. As they
    grow in complexity, not only can they become more brittle, but we also have little
    insight into what went wrong.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，开发代理的最大挑战之一是其不确定性。有很大可能性，当你在这个章节中处理示例代理时，你可能会遇到代理没有按预期执行工具，或者创建比所需更多或更少的数据的情况。代理中决定运行什么和工具之间共享什么数据的部分对我们来说是透明的。在我们的示例代理中，我们使用的是第三方LLM，这意味着我们没有洞察其决策过程。我们也没有任何能力监控其行为或控制LLM的调整和操作方式。这种缺乏控制和可观察性可能会成为开发代理的重大风险。随着它们的复杂性增加，它们不仅可能变得更加脆弱，而且我们对出错的原因也几乎没有洞察力。
- en: Some steps can be taken to mitigate this risk. We could host models on our platforms
    and increase observability. But while this might give us more insights into what
    decisions were made and when by an LLM, it still doesn’t mean we can guarantee
    the outcome of an agent’s responses.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 可以采取一些措施来减轻这种风险。我们可以在我们的平台上托管模型并提高可观察性。但是，尽管这可能让我们对LLM做出的决策和何时做出决策有更多的了解，但这并不意味着我们可以保证代理响应的结果。
- en: Navigating guard rails and security concerns
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 导航防护措施和安全问题
- en: 'This brings us to the second problem when using agents: ensuring that we have
    the necessary prompts and code in place to handle situations in which an agent
    may hit an edge case, as well as preventing bad actors from using our agents to
    negatively affect our business or others. Utilizing good prompting techniques
    in outlining the purpose of each tool and adding checks and balances to help our
    agent reject invalid or undesirable requests is a must, but that means identifying
    those potential scenarios and implementing guard rails for them. The upshot is
    that agents require extensive testing and evaluation, which can come at a cost
    that outweighs the initial value of using them in the first place.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了使用代理时遇到的第二个问题：确保我们有必要的提示和代码来处理代理可能遇到边缘情况的情况，以及防止恶意行为者利用我们的代理对我们的业务或他人造成负面影响。在概述每个工具的目的时利用良好的提示技术，并添加检查和平衡来帮助我们的代理拒绝无效或不希望的要求是必须的，但这意味着要识别那些潜在的情景并为它们实施防护措施。结果是，代理需要广泛的测试和评估，这可能会带来成本，而这些成本可能会超过最初使用它们的价值。
- en: Managing when things go wrong
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 管理出错时的情况
- en: That said, despite our best efforts, there will be times when an agent does
    something wrong. Either tools are run in an incorrect order, data isn’t passed
    between tools successfully, or the code within our tools has bugs. In the context
    of our example agent, these potential errors will be swallowed up by the OpenAI
    platform. When I first developed the example agent, it was throwing exceptions
    as the JDBC library failed, and the exceptions were consumed by the agent, which
    triggered all sorts of unusual behavior. In one example, the JDBC code failed
    in a way that caused the agent to continue attempting to create new records, repeatedly
    firing the broken function, to the point at which the whole agent crashed as it
    hit a limit in the amount of function calls it could carry out. The problem was
    that this exception wasn’t shared with me, making the debugging of the problem
    difficult.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，尽管我们尽了最大努力，但有时代理会出错。可能是工具运行顺序不正确，数据在工具之间传递不成功，或者我们工具中的代码有错误。在我们的示例代理的上下文中，这些潜在的错误将被OpenAI平台吞没。当我最初开发示例代理时，由于JDBC库失败，它抛出了异常，这些异常被代理消耗，引发了各种异常行为。在一个例子中，JDBC代码以导致代理继续尝试创建新记录的方式失败，反复触发已损坏的功能，直到整个代理由于达到函数调用数量的限制而崩溃。问题是这个异常没有与我共享，这使得调试问题变得困难。
- en: Again, observability and monitoring are essential, as well as ensuring our code
    is written defensively against potential exceptions or errors. If we don’t catch
    and report them, then they are hidden, leading to wasted time trying to debug
    what was wrong in the first place.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，可观察性和监控是必不可少的，以及确保我们的代码在潜在异常或错误方面进行了防御性编写。如果我们不捕获并报告它们，那么它们就会隐藏起来，导致我们浪费时间去调试最初出了什么问题。
- en: Ultimately, agents promise the potential of making us, the individual, more
    efficient by supporting us in task completion. Given the autonomous abilities
    of agents, it can be easy to buy into the hype of their potential. But just like
    any software we seek to utilize, its creation, use, and maintenance come with
    a cost. Similarly, like all software, it’s not a silver bullet for all our problems.
    To use agents successfully, we need to take the time to consider the problem we
    are attempting to solve. At times, agents may be of use to us, but other options
    such as a well-crafted prompt might do the work just as well, or we might have
    better success with other non-AI-based tools. In the end, agents are just another
    addition to our tool belt to employ when the time is right.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，代理承诺通过支持我们完成任务，使我们个人更加高效。鉴于代理的自主能力，很容易相信他们的潜力。但就像我们寻求利用的任何软件一样，其创建、使用和维护都有成本。同样，像所有软件一样，它不是解决我们所有问题的万能药。要成功使用代理，我们需要花时间考虑我们试图解决的问题。有时，代理可能对我们有用，但其他选项，如精心设计的提示，可能同样有效，或者我们可能使用其他非基于AI的工具取得更好的成功。最后，代理只是我们在适当的时候可以使用的工具包中的另一个补充。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: AI agents exist in many different fields of artificial intelligence.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能代理存在于人工智能的许多不同领域。
- en: AI agents are expected to be goal-driven, able to perceive the wider world,
    autonomous, and adaptable.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能代理预计是目标驱动的，能够感知更广阔的世界，具有自主性和适应性。
- en: Agents within the context of LLMs are created using function calling.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在LLM的上下文中，代理是通过函数调用创建的。
- en: Function calling is achieved by providing a prompt and code grouped into functions
    that an LLM can call to achieve a goal within a prompt.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用是通过提供提示和代码块，这些代码块被分组为LLM可以调用的函数，以在提示内实现目标。
- en: Function calling can be used to interact with other sites and services, feeding
    information back to the LLM for further processing.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用可以用来与其他网站和服务交互，将信息反馈给LLM进行进一步处理。
- en: LangChain4J is a useful library for easily connecting to LLM platforms and managing
    AI services such as tools.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LangChain4J是一个有用的库，可以轻松连接到LLM平台并管理AI服务，如工具。
- en: We can create tools using the `@Tool` annotation, which helps the LLM match
    up our instructions to which method to run and when.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`@Tool`注解创建工具，这有助于LLM匹配我们的指令与要运行的方法以及何时运行。
- en: We pass extracted values from our prompt into methods as parameters using the
    `@P` annotation, which works similarly to the `@Tool` annotation.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过`@P`注解将提示中的提取值作为参数传递给方法，这与`@Tool`注解的工作方式类似。
- en: Agents can also send data between tools by returning data out of a method and
    using the `@P` annotation to pull the data in as a parameter.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理还可以通过从方法中返回数据并使用`@P`注解将数据作为参数拉入，在工具之间发送数据。
- en: When agents fail to carry out tasks or an error occurs, it can be hard to detect
    what went wrong.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当智能体无法执行任务或发生错误时，很难检测出哪里出了问题。
- en: LLMs are opaque when it comes to decision-making, which can also make debugging
    problems challenging.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当涉及到决策时，大型语言模型（LLMs）是透明的，这也可能使得调试问题变得具有挑战性。
- en: Exposing agents to a wider user base means they require guard rails in place
    to prevent agents from either not fulfilling tasks or being vulnerable to bad
    actors.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将智能体暴露给更广泛的用户基础意味着它们需要设置防护措施，以防止智能体无法完成任务或容易受到恶意行为者的攻击。
