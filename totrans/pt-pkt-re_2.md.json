["```py\nimport torch\n\nx = torch.tensor([[1,2,3],[4,5,6]])\ny = torch.tensor([[7,8,9],[10,11,12]])\nz = x + y\nprint(z)\n# out:\n#  tensor([[ 8, 10, 12],\n#          [14, 16, 18]])\n\nprint(z.size())\n# out: torch.Size([2, 3])\n```", "```py\ndevice = \"cuda\" if torch.cuda.is_available()\n  else \"cpu\"\nx = torch.tensor([[1,2,3],[4,5,6]],\n                 device=device)\ny = torch.tensor([[7,8,9],[10,11,12]],\n                 device=device)\nz = x + y\nprint(z)\n# out:\n#   tensor([[ 8, 10, 12],\n#          [14, 16, 18]], device='cuda:0')\n\nprint(z.size())\n# out: torch.Size([2, 3])\n\nprint(z.device)\n# out: cuda:0\n```", "```py\ndevice = \"cuda\" if torch.cuda.is_available()\n  else \"cpu\"\nx = x.to(device)\ny = y.to(device)\nz = x + y\nz = z.to(\"cpu\")\n# out:\n# tensor([[ 8, 10, 12],\n#         [14, 16, 18]])\n```", "```py\nimportnumpy# Created from preexisting arraysw=torch.tensor([1,2,3])![1](Images/1.png)w=torch.tensor((1,2,3))![2](Images/2.png)w=torch.tensor(numpy.array([1,2,3]))![3](Images/3.png)# Initialized by sizew=torch.empty(100,200)![4](Images/4.png)w=torch.zeros(100,200)![5](Images/5.png)w=torch.ones(100,200)![6](Images/6.png)\n```", "```py\n# Initialized by size with random valuesw=torch.rand(100,200)![1](Images/1.png)w=torch.randn(100,200)![2](Images/2.png)w=torch.randint(5,10,(100,200))![3](Images/3.png)# Initialized with specified data type or devicew=torch.empty((100,200),dtype=torch.float64,device=\"cuda\")# Initialized to have the same size, data type,#   and device as another tensorx=torch.empty_like(w)\n```", "```py\n# Specify the data type at creation using dtypew=torch.tensor([1,2,3],dtype=torch.float32)# Use the casting method to cast to a new data typew.int()# w remains a float32 after the castw=w.int()# w changes to an int32 after the cast# Use the to() method to cast to a new typew=w.to(torch.float64)![1](Images/1.png)w=w.to(dtype=torch.float64)![2](Images/2.png)# Python automatically converts data types during# operationsx=torch.tensor([1,2,3],dtype=torch.int32)y=torch.tensor([1,2,3],dtype=torch.float32)z=x+y![3](Images/3.png)print(z.dtype)# out: torch.float32\n```", "```py\nx = torch.tensor([[1,2],[3,4],[5,6],[7,8]])\nprint(x)\n# out:\n# tensor([[1, 2],\n#         [3, 4],\n#         [5, 6],\n#         [7, 8]])\n\n# Indexing, returns a tensor\nprint(x[1,1])\n# out: tensor(4)\n\n# Indexing, returns a value as a Python number\nprint(x[1,1].item())\n# out: 4\n```", "```py\n# Slicing\nprint(x[:2,1])\n# out: tensor([2, 4])\n\n# Boolean indexing\n# Only keep elements less than 5\nprint(x[x<5])\n# out: tensor([1, 2, 3, 4])\n```", "```py\n# Transpose array; x.t() or x.T can be used\nprint(x.t())\n# tensor([[1, 3, 5, 7],\n#         [2, 4, 6, 8]])\n\n# Change shape; usually view() is preferred over\n# reshape()\nprint(x.view((2,4)))\n# tensor([[1, 3, 5, 7],\n#         [2, 4, 6, 8]])\n```", "```py\n# Combining tensors\ny = torch.stack((x, x))\nprint(y)\n# out:\n# tensor([[[1, 2],\n#          [3, 4],\n#          [5, 6],\n#          [7, 8]],\n\n#         [[1, 2],\n#          [3, 4],\n#          [5, 6],\n#          [7, 8]]])\n\n# Splitting tensors\na,b = x.unbind(dim=1)\nprint(a,b)\n# out:\n#  tensor([1, 3, 5, 7]); tensor([2, 4, 6, 8])\n```", "```py\nx = torch.tensor([[1,2,3],[4,5,6]],\n         dtype=torch.float, requires_grad=True)\nprint(x)\n# out:\n# tensor([[1., 2., 3.],\n#         [4., 5., 6.]], requires_grad=True)\n\nf = x.pow(2).sum()\nprint(f)\n# tensor(91., grad_fn=<SumBackward0>)\n\nf.backward()\nprint(x.grad) # df/dx = 2x\n# tensor([[ 2.,  4.,  6.],\n#         [ 8., 10., 12.]])\n```"]