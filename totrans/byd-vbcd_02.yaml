- en: 'Chapter 1\. Introduction: What Is Vibe Coding?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AI is reshaping how we build software, introducing new paradigms for coding
    that range from free-form prompting to structured assistance. Imagine writing
    software by simply *describing* what you want it to do—almost like talking to
    a teammate—while an AI translates those ideas into code. This is the essence of
    *vibe coding*, a prompt-first, exploratory approach where you describe what you
    want in natural language and let a large language model (LLM) fill in the blanks.
    The term was recently [coined by AI pioneer Andrej Karpathy](https://oreil.ly/Ot6CR)
    to describe this new way of programming, where developers “fully give in to the
    vibes” of AI assistance.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I’ll dive deeper into what vibe coding means for professional
    developers and how it compares with—and complements—what I call *AI-assisted engineering*,
    a more formal augmented coding process. I’ll explore how the developer’s role
    is evolving in this AI-first era, what tools and workflows can maximize your effectiveness,
    and how to address the unique challenges of letting an AI loose on your codebase.
    I’ll also look at where vibe coding shines, where it struggles, and how to balance
    the speed of AI generation with the wisdom of human oversight. By the end, you
    should have a clear picture of how to harness “the vibes” in your own coding practice—responsibly
    and effectively—to become not just a faster coder but a more creative and impactful
    software product engineer in the age of AI.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explore how the role of the developer is transforming from
    writing detailed instructions for machines to collaborating with AI by expressing
    intent (see [Figure 1-1](#ch01_figure_1_1752630042312406)). We’ll see why this
    “vibe shift” in programming is such a big deal, how it works at a high level,
    and what opportunities and challenges it brings.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bevc_0101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-1\. A conceptual illustration of programming with intent. The developer
    provides a high-level specification (the “intent”), and the AI translates it into
    code. This highlights the shift from writing code line by line to guiding code
    generation at a high level.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The AI Coding Spectrum: From Vibe Coding to AI-Assisted Engineering'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over the past year, I’ve observed a fascinating split in how developers—especially
    intermediate and advanced web developers—embrace AI in their workflow. On one
    end of the spectrum lies vibe coding. On the other end is what I’ll call *AI-assisted
    engineering*: a disciplined method of weaving AI into each phase of software development,
    from design through testing, under clear constraints. Both approaches leverage
    powerful AI, but their goals, audiences, and expectations differ markedly. Throughout
    this book, I’ll explore these two extremes and what they mean for modern web development.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Vibe-Coding Approach: Code by Conversation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In vibe coding, you leverage powerful LLMs as coding partners, letting them
    handle the heavy lifting of code generation so you can focus on higher-level goals.
    As [one *Business Insider* summary puts it](https://oreil.ly/nvcFW), vibe coding
    “means using AI tools...for the heavy lifting in coding to quickly build software.”
    As NVIDIA’s CEO Jensen Huang says, thanks to AI, “the hottest new programming
    language” is English, not Java or Python. Instead of manually typing out every
    function and bug fix, you interact with the AI in natural language—sketching out
    features, reviewing suggestions, and iterating based on the AI’s output.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach represents a dramatic shift from traditional programming to AI-assisted
    development. Conventional coding demands careful planning, syntax precision, and
    often painstaking debugging. Vibe coding flips that script: “It’s not really coding—I
    just see stuff, say stuff, run stuff, and copy-paste stuff, and it mostly works,”
    Karpathy quipped to *Business Insider*, highlighting how AI can turn high-level
    instructions into working code with minimal manual effort.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers move from writing detailed instructions for computers to *orchestrating
    outcomes* with the help of AI. As an example, [Karpathy describes](https://oreil.ly/Ki6iJ)
    building a web app by continually accepting the AI’s suggestions: “I ‘Accept All’
    always, I don’t read the diffs anymore.…When I get error messages, I just copy
    paste them in.…Sometimes the LLMs can’t fix a bug so I just work around it or
    ask for random changes until it goes away.” The code “grows” beyond what he’d
    normally write himself, yet the project comes together quickly through iterative
    prompting and fixing. Essentially, vibe coding treats coding as an interactive
    conversation with your AI pair programmer rather than as a solo slog through syntax
    and stack traces. The goal is speed and exploration—to get a working solution
    with minimal friction.'
  prefs: []
  type: TYPE_NORMAL
- en: Several trends converged to make vibe coding possible. First, modern AI coding
    assistants (like OpenAI’s Codex, ChatGPT, Anthropic’s Claude, etc.) have become
    astonishingly good at generating and correcting code. In the same post, Karpathy
    notes this is “possible because the LLMs…are getting too good”—they have ingested
    vast swaths of GitHub code and can produce plausible solutions for many tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Second, new developer tools have emerged to integrate these models seamlessly
    into the coding workflow (more on these tools in a moment). Finally, the developer
    community’s mindset is evolving to trust AI assistance for bigger and bigger chunks
    of work. It’s no longer just autocomplete on steroids; it’s handing over whole
    functions or files to the AI. In practical terms, vibe coding often feels like
    having an unlimited supply of eager junior developers to implement whatever you
    ask for—except they work at the speed of cloud computation.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most eye-popping promises of vibe coding is the productivity boost.
    Early adopters report being able to create software features or prototypes ten
    to a hundred times faster than before. For instance, [Codeium Windsurf engineer
    John Hoestje muses](https://oreil.ly/_nfZn), “Why be a 10x engineer when you could
    be a 100x engineer?” This suggests that, with the right AI-powered IDE, extraordinary
    productivity is within reach. Tools like Windsurf, an AI-enhanced IDE, “can dramatically
    accelerate development time, allowing you to achieve that 100x productivity.”
    While 100x might be an extreme scenario, even more conservative studies find huge
    gains.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can generate boilerplate code in seconds, fix bugs in the blink of
    an eye, and even have AI write tests or docs, compressing workflows that used
    to take days into mere hours. No longer limited by typing speed or memory, a single
    developer armed with AI can often prototype a full stack application in a weekend—something
    that might have taken a small team weeks to accomplish in the past. It’s not just
    hype either; as I noted in a January 2025 [blog post for *Pragmatic Engineer*](https://oreil.ly/khEfs),
    surveys show that *75% of developers* have already integrated some form of AI
    into their workflows, and many companies report double- or triple-digit percentage
    improvements in development velocity. In short, AI pair programmers are turning
    the mythical “10x engineer” into a very real (and reachable) 100x engineer phenomenon.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how revolutionary this is, consider a concrete example. A developer
    wants to build a simple web app that counts words in a podcast script and estimates
    reading time. Instead of starting from scratch, they open an AI-powered coding
    environment and *tell* the AI their idea. Within minutes, the AI produces a working
    prototype. The developer then says, “Make the stats counters bright colors and
    add a PDF export,” and the AI updates the code accordingly. The result is a functional
    tool, deployed with one click—all achieved in under 10 minutes. This real-world
    scenario ([reported by a creator using Replit’s AI](https://oreil.ly/guqFZ)) shows
    how vibe coding enables extremely rapid, iterative development driven by high-level
    requests. Similarly, nonengineers are jumping in: the same article describes one
    laid-off marketer with no coding background who used an AI coding assistant to
    build 100 simple web tools that collectively reached the top of Product Hunt.
    When the barrier to creating software drops this low, we’re not just increasing
    productivity for seasoned developers⁠—we’re fundamentally expanding who can develop
    software in the first place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, vibe coding comes with serious caveats. Because you’re deferring so
    much to the AI, you might end up with code that “works” in the happy path but
    hides a minefield of bugs or poor design decisions. Without a solid plan or constraints,
    an LLM might generate a solution that lacks proper error handling, security checks,
    or scalability. In fact, AI-generated code can sometimes be built on sand: it
    appears solid but has hidden issues that only surface under real-world conditions.
    I’ve seen cases where a developer vibed their way to a complete feature in record
    time, only to discover later that the code was inefficient and hard to maintain.
    This kind of “house of cards” code can collapse under pressure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine asking an AI to “whip up a user login system.” The AI
    might produce a working authentication flow quickly, but perhaps it uses a simplified
    encryption method or a known vulnerable library. If you deploy that without deeper
    inspection, you’re taking on faith that everything is sound. Seasoned engineers
    know that’s risky: code running in production has to be understood and trusted.
    As [one expert](https://oreil.ly/ppXCf) put it, “Vibe coding your way to a production
    codebase is clearly risky. Most of the work we do as software engineers involves
    evolving existing systems, where the quality and understandability of the underlying
    code is crucial.” Vibe coding, at its extreme, can bypass those quality gates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another challenge is that vibe coding tends to downplay upfront planning. Traditional
    software engineering values designing for clarity and constraint-thinking through
    data models, choosing appropriate patterns, and writing out at least a minimal
    spec. Vibe coding flips this: it starts with *no scaffolding*, diving straight
    into implementation via prompts. That can lead to a meandering development process.
    You might prompt your way into a corner—say the AI chooses a state management
    approach or library you didn’t intend, and now you have to either steer it back
    or live with it. Without an initial blueprint, the final architecture might be
    haphazard. This is fine for a quick proof of concept, but it’s troublesome in
    a larger codebase where consistency matters.'
  prefs: []
  type: TYPE_NORMAL
- en: Vibe coding isn’t inherently “bad.” In fact, its emergence is part of the ongoing
    democratization of programming. It lowers the barrier to creating software, much
    like early low-code platforms or scripting languages did. A motivated nonengineer
    with a clear idea could potentially build a simple app through vibes alone. And
    for experienced developers, vibe coding can be a powerful brainstorming tool—it’s
    like pseudo coding but with immediate, runnable results. The key is recognizing
    its limits. Speed without discipline can lead to brittle software, so vibe coding
    requires a vigilant human in the loop. I often remind developers (and myself)
    that “vibe coding is not an excuse for low-quality work.” It should be the *start*
    of a solution, not the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The AI-Assisted Engineering Approach: Structure with an AI Partner'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the opposite end of our spectrum is *AI-assisted engineering*—a more structured,
    methodical way of building software with AI as a copilot at every step. Here,
    the developer remains very much in the driver’s seat. AI-assisted engineering
    includes using AI across the traditional software development lifecycle (SDLC),
    such as AI-powered autocomplete, chat, code migrations, bug detection, test generation,
    and both granular (function, module, component) and full code generation (see
    [Figure 1-2](#ch01_figure_2_1752630042312451)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bevc_0102.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-2\. The plan-first AI-assisted engineering workflow: developers create
    specifications, provide targeted prompts to AI systems, review generated code
    snippets, and integrate approved solutions into their projects.'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You begin with a plan (even if it’s lightweight), outlining what you need to
    build and defining the constraints and acceptance criteria up front. Then you
    incorporate AI tools in a targeted manner to accelerate or enhance parts of that
    plan. In contrast to prompt-first vibe coding, we might call this “plan-first”
    development with AI support. This could be as formal as a mini-product requirements
    document (a short PRD for a feature) or as simple as a checklist of tasks. The
    crucial difference is that you ground the work in *clear intent and constraints*
    before letting the AI loose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a React developer tasked with creating a new interactive dashboard
    component. In an AI-assisted engineering approach, they might begin by writing
    down the component’s responsibilities and API:'
  prefs: []
  type: TYPE_NORMAL
- en: Dashboard component shows a list of analytics cards, supports filtering by date
    range, and has refresh and export buttons. It should fetch data from our API (with
    proper error handling), and it must follow our design system for styling.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This outline is essentially a spec. The developer might even sketch a quick
    data model or identify existing utility functions to reuse. Only then do they
    bring in the AI: for instance, using an AI-enabled IDE or coding assistant to
    generate the skeleton of the component based on that description. The AI might
    provide a starting implementation of the React component with placeholders for
    data fetching and stubbed event handlers. Because the developer provided clear
    guidance, the AI’s output is more likely to align with the project’s needs (such
    as using the right design system classes or calling the correct API endpoints).
    The code isn’t a surprise; it’s the product of a well-formed request.'
  prefs: []
  type: TYPE_NORMAL
- en: AI-assisted engineering doesn’t stop at code generation for a single component.
    It permeates the entire development lifecycle in a controlled fashion. For routine
    coding tasks, an AI autocompletion tool like GitHub Copilot can suggest the next
    few lines as you type, saving keystrokes when you’re implementing known patterns.
    For example, as you write a unit test, your AI helper might autosuggest assertions
    based on the function name. Speaking of tests, you might use AI to generate test
    cases once a feature is in place—feeding the component’s spec or code into a prompt
    to get suggestions for edge cases you should check. The idea is to *augment* the
    engineer’s work, not replace it. You’re still thinking through the logic and verifying
    correctness; the AI just offloads some of the grunt work.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to code migration or refactoring, AI can be a godsend. Imagine
    needing to convert a class-based React component to a modern function component
    with hooks. Rather than doing it all manually, you could ask an AI assistant to
    transform the code or at least outline the steps. With a good understanding of
    the old and new patterns, an LLM can produce a draft of the refactored code, which
    you then review and polish. This structured use of AI tackles well-defined tasks
    (like “migrate this code from Redux to React Context API”) one by one rather than
    handing the AI an open-ended “build whatever” mandate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most dramatic form of AI-assisted engineering is using AI to generate
    a full mini-application or feature from a detailed specification. Several tools
    now allow you to input a description of an app, something akin to a mini-PRD,
    and get back a working codebase or prototype. For instance, a developer could
    supply a spec for:'
  prefs: []
  type: TYPE_NORMAL
- en: a to-do list app with React frontend and Node.js backend, supporting user authentication
    and real-time updates
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The AI tool would scaffold the project, create the key components, and set up
    the database schema.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t magic; it’s an accelerated version of what a diligent engineer might
    do when starting a new project (setting up directories, choosing libraries, writing
    boilerplate code). The important thing is that the AI’s creativity is *bounded
    by the constraints given in the spec*. The result is a minimum viable product
    (MVP) that adheres to the requirements you provide. An experienced developer,
    treating this output correctly, will not assume it’s production-ready on the first
    generation. Instead, they’ll treat it as a first draft. They’ll run the app, write
    or regenerate tests to validate each feature, review the code for any inconsistencies
    or insecure configurations, and refine as needed. In short, they’ll apply all
    their usual engineering rigor—just accelerated by an AI’s ability to produce bulk
    code from a blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: The goals of AI-assisted engineering are different from those of vibe coding.
    The aim here is not just to get *working* code quickly but to get *high-quality*
    code more efficiently. It’s about boosting productivity while preserving (or even
    improving) the reliability of the outcome. A team practicing AI-assisted engineering
    might say, “We want to deliver this feature two times faster but with zero compromise
    on our standards.”
  prefs: []
  type: TYPE_NORMAL
- en: The audience for this approach is typically professional developers and teams
    who have established processes (code review, testing, deployment pipelines) that
    they aren’t willing to abandon. These are intermediate to senior engineers who
    see AI as a powerful new tool in their toolbox, not a replacement for the toolbox.
    They likely have seen what happens when you cut corners, so they value practices
    that keep software maintainable. (By way of comparison, the audience for vibe
    coding includes solo developers hacking together demos, product-minded folks with
    some coding knowledge, and even relatively new programmers who leverage AI to
    compensate for gaps in their expertise.)
  prefs: []
  type: TYPE_NORMAL
- en: The expectations in AI-assisted engineering are that humans remain in control
    of decisions, and the AI provides suggestions or accelerators. Code quality, performance,
    and security remain paramount, so every AI-generated piece is subject to the same
    scrutiny as if a junior developer wrote it. Treat the AI as your intern, not your
    replacement. You might delegate tasks to it, but you must review its work. Just
    as you’d never deploy code written by a human intern without a code review, you
    shouldn’t deploy AI-written code without understanding it. This mindset keeps
    the engineering discipline front and center.
  prefs: []
  type: TYPE_NORMAL
- en: Different Mindsets, Different Expectations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vibe coding and AI-assisted engineering are two distinct mindsets. Vibe coding
    is top-down and exploratory: you start with a broad idea and let the implementation
    emerge through interaction with the AI. It’s a bit like improvisational jazz—minimal
    structure, lots of room for creative riffs, and you discover the shape of the
    song as you play. AI-assisted engineering is systematic and iterative: more like
    classical composition, where you begin with a theme or motif (your requirements)
    and methodically develop it, perhaps using some improvisation (AI suggestions)
    within the measures of a written score. Both can produce “music,” but the process
    and the kind of result will differ.'
  prefs: []
  type: TYPE_NORMAL
- en: For an intermediate or advanced web developer, your expectations for each approach
    are key. If you’re vibe coding, you expect to be surprised. The AI might come
    up with an approach you wouldn’t have written yourself—maybe it uses a different
    library or a programming idiom you’re less familiar with. Part of the allure is
    learning from those surprises or quickly getting past things you find tedious.
    But you also need to expect hiccups. Vibe-coding enthusiasts should go in with
    eyes open that they’ll be responsible for that tricky last stretch. The magic
    is real, but it’s not total.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re practicing AI-assisted engineering, your expectations are more measured
    and arguably more realistic for long-term projects. You expect the AI to save
    you time and perhaps inspire a solution or two but not to do your whole job. In
    fact, a good AI-assisted engineer might use vibe-style prompting in *microdoses*
    within a larger framework. For example, while implementing a well-specified module,
    they might momentarily switch into “vibe mode” to ask, “Hey AI, generate a quick
    utility function to format these dates,” then immediately switch back to engineer
    mode to integrate and check that function. The mindset is that AI is a collaborator
    that works under your guidance. You allocate tasks to it where it excels (like
    boilerplate, repetitive code, broad-stroke implementations), and you handle the
    rest yourself (critical logic, integration, final review).
  prefs: []
  type: TYPE_NORMAL
- en: 'Expectations here include improved productivity, fewer rote mistakes (an AI
    is less likely to misspell a variable name, for instance), and possibly a broader
    solution search space (the AI might suggest an algorithm you hadn’t thought of).
    But you also expect to invest time in validation.  Debugging AI-assisted code
    is still debugging: you run tests and step through the code in the debugger if
    needed. The difference is that you might find yourself debugging code the AI wrote
    for you, which is a new experience that comes with a learning curve. [Chapter 5](ch05.html#ch05_understanding_generated_code_review_refine_own_1752630043592278)
    will discuss this experience in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two approaches’ goals highlight a fundamental difference between them:
    vibe coding optimizes for *velocity in the short term*, whereas AI-assisted engineering
    optimizes for *sustained velocity and reliability*. A vibe coder might say, “I
    need to get this app running by tonight to see if the idea works.” An AI-assisted
    engineer would say, “I need to build this feature fast, but it should be robust
    enough to live in our codebase for years.” The former is satisfied if the code
    basically functions; the latter cares that the code is clean enough for others
    to build upon.'
  prefs: []
  type: TYPE_NORMAL
- en: These differences naturally appeal to different audiences. Less-experienced
    developers or those outside the engineering discipline might lean toward vibe
    coding because it lowers the barrier to entry and provides instant gratification.
    I’ve met product managers and designers dabbling in code via vibe prompts, treating
    the AI almost like a superpowered Stack Overflow that gives them full solutions.
    On the flip side, seasoned developers and engineering teams tend to favor AI-assisted
    engineering. They’ve been burned by fragile code before, so they start from a
    place of “let’s do this right, even if we use new tools to go faster.” They put
    in a bit more effort up front (writing that mini-PRD, setting up the project structure)
    in exchange for long-term payoffs.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Your Place on the Spectrum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s tempting to ask: which approach is better? The truth is, vibe coding and
    AI-assisted engineering aren’t mutually exclusive categories: they represent two
    ends of a spectrum, and real-world workflows often blend elements of both. A developer
    might start a project with a burst of vibe coding to scaffold something novel,
    then switch into engineering mode to firm it up. Or they might generally follow
    an AI-assisted discipline but occasionally—for a trivial one-off script or a throwaway
    prototype—say, “You know what, I’ll just vibe code this and see what I get.” The
    key is understanding the trade-offs and using the right approach for the right
    context.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of vibe coding as a high-speed exploratory vehicle: it can take you off
    the beaten path quickly, and it’s great for discovery. AI-assisted engineering
    is more like a reliable train on a track: you have to lay down rails first (plan),
    but it’s a safer bet and more likely to reach a defined destination without derailing.
    Intermediate and advanced developers should be capable of driving both vehicles,
    but they’ll choose based on the task at hand. If the goal is to innovate or ideate
    rapidly (say, in a hackathon or when validating an idea’s feasibility), vibe coding
    provides momentum. Just remember to tighten things up if you plan to reuse that
    code. If the goal is to build a maintainable product feature in a professional
    setting, leaning toward AI-assisted engineering ensures you don’t end up with
    a black-box chunk of code in your codebase that nobody truly understands.'
  prefs: []
  type: TYPE_NORMAL
- en: One fascinating thing I’ve observed is that as developers gain experience with
    AI tools, their usage often naturally shifts from the vibe end toward the engineering
    end. Initially, the novelty of having an AI generate entire blocks of code from
    a single prompt is alluring—who wouldn’t want to try essentially “talking” an
    app into existence?
  prefs: []
  type: TYPE_NORMAL
- en: But after the honeymoon, pragmatism kicks in. Developers start to see where
    the AI shines and where it stumbles. They learn to break problems down and feed
    them to the AI in pieces rather than asking for the whole solution in one go.
    In effect, they move from being “prompt artists” to becoming AI “orchestra conductors”—still
    utilizing the AI’s creative power but guiding it with a skilled hand and following
    a clear score. In my own practice, I’ve become more deliberate with prompts, often
    writing small pieces of pseudocode or comments and asking the AI to complete them
    instead of just asking open-ended questions. This way, I get the benefits of vibe-like
    fluidity but within a structure I control.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also worth noting that tooling is evolving to support the entire spectrum.
    On one side, we have chat-based interfaces and natural-language coding environments
    explicitly designed for vibe coding, where you might not even see the code until
    you ask for it. On the other, IDEs are adding AI features that seamlessly blend
    into traditional coding: for example, AI linters that suggest improvements, documentation
    generators that explain code, and version-control bots that can automatically
    create a pull request and suggest changes for review. These tools encourage an
    engineering mindset by fitting into the usual development workflow (edit, review,
    test, etc.) while still leveraging AI.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The distinction between vibe coding and AI-assisted engineering might even
    blur over time as best practices emerge. We may find that what today feels like
    “vibing” will gain more guardrails, and what feels like “structured engineering”
    will become more fluid. In fact, I’d argue that the ideal future is one where
    we can move up and down this spectrum effortlessly: exploring creative solutions
    with AI when we want to but always reining things in with solid engineering practices
    when it’s time to harden and ship the software.'
  prefs: []
  type: TYPE_NORMAL
- en: This spectrum of approaches represents a significant evolution in how we work
    with AI tools today. Yet even as we refine our techniques for collaborating with
    AI—whether through rapid vibe coding or structured engineering workflows—a more
    fundamental transformation is taking shape. The very nature of programming itself
    is changing. We’re moving away from the traditional paradigm where developers
    must translate their ideas into explicit instructions and toward a future where
    we can express our intentions directly and let AI handle the translation into
    code.
  prefs: []
  type: TYPE_NORMAL
- en: This shift challenges our most basic assumptions about what it means to be a
    programmer. For generations, our value has been tied to our ability to think like
    machines—to break down problems into discrete, logical steps that computers can
    execute. But what happens when machines become capable of understanding what we
    *want*, not just what we tell them to do? This is where *programming with intent*
    enters the picture, representing not just a new tool or technique but a fundamental
    reimagining of the developer’s role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond Lines of Code: Programming with Intent'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For decades, programming has meant writing instructions: line after line of
    code telling the computer *how* to do something. Each function, loop, and conditional
    had to be carefully crafted by a human. Programming with intent flips this script.
    Instead of focusing on the low-level implementation, the developer focuses on
    the outcome or goal: what you want the program to accomplish. You express that
    intent in a high-level way (often in natural language), and the AI system figures
    out the code to fulfill it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of it this way: traditional coding is like giving someone step-by-step
    directions, while intent-based coding is like telling them your destination and
    letting them figure out the best route. By focusing on the *what* instead of the
    *how*, developers can work at a higher level of abstraction. This approach isn’t
    entirely new—tools like visual programming, low-code platforms, and code generators
    have long promised to raise the abstraction level. But today’s AI advancements
    are finally making it practical to describe complex behaviors in plain language
    and get working code in return.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Rise of the Prompt: From Instructions to Descriptions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the heart of this shift is the humble prompt. A *prompt* is the input or
    question you give to an AI coding system. In essence, it’s a description of what
    you want the program to do rather than an instruction for how to do it. This can
    feel very different from writing code. For example, instead of writing a loop
    to parse a file, you might prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: Read this CSV file and extract the email addresses of all users older than 18.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The AI will attempt to generate code that accomplishes that description.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this happening now? The rapid progress of LLMs in understanding and generating
    text, including programming languages, has been a game changer. These AI models
    have been trained on vast amounts of code and natural language text. They can
    interpret a prompt that looks like a description of software behavior and translate
    it into actual code that implements that behavior. In other words, they’ve learned
    the patterns of how humans describe tasks and how those tasks translate into code.
  prefs: []
  type: TYPE_NORMAL
- en: This rise of prompt-based development means that, as a developer, you increasingly
    write descriptions of features and logic in natural language or pseudocode and
    let the AI handle the heavy lifting of writing syntactically correct code. The
    prompt becomes your new unit of thought. It’s a concise expression of intent.
    We’ve gone from telling the computer, “Do X, then Y, then Z” to saying, “I need
    X, Y, and Z done” and trusting the AI to fill in the blanks.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that writing a good prompt is itself a skill (which we’ll
    dive into in [Chapter 3](ch03.html#ch03_the_70_problem_ai_assisted_workflows_that_actual_1752630043200933)).
    A vague prompt can lead to incorrect or inefficient code, just as a vague requirement
    can confuse a human programmer. The better you can articulate your intent in the
    prompt, the better the AI’s output will match your needs. This is why many are
    calling prompt writing the new programming literacy.
  prefs: []
  type: TYPE_NORMAL
- en: 'How It Works: The Iterative Cycle and AI’s Role in Code Generation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So how does an AI go from your free-form description to actual, functioning
    code? The magic lies in LLMs’ ability to interpret context and generate text.
    The *large* in “large language model” refers to the number of parameters (the
    internal configuration) it has, often billions or more, which enable it to capture
    the complexities of natural and programming languages. These models have been
    trained on public code repositories, forums, documentation, and Q&A sites, learning
    both the syntax of programming languages and the semantics of how code is used
    to solve problems. When you interact with an AI coder, you’re tapping into this
    expansive learned knowledge. Let’s break it down in simple terms:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the prompt
  prefs: []
  type: TYPE_NORMAL
- en: When you provide a prompt (for example, “Generate a function that checks if
    a number is prime”), the AI model analyzes the text of that prompt. Modern models
    from Google, OpenAI, and Anthropic have been trained on countless examples of
    language and code, so they use statistical patterns to infer what you’re asking.
    Essentially, the AI tries to *predict* the most likely completion of the prompt
    with code that makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging context
  prefs: []
  type: TYPE_NORMAL
- en: These AI systems often take into account additional context beyond just the
    single-line prompt. For instance, if you’re working in an IDE with an AI assistant,
    the model might also consider the current file content, your coding style, comments,
    and even related files. All this context helps the AI generate code that fits
    your project. It’s similar to how a human developer reads surrounding code and
    documentation to understand what to do next.
  prefs: []
  type: TYPE_NORMAL
- en: Generating code
  prefs: []
  type: TYPE_NORMAL
- en: Once the model has understood (or at least made a best guess about) your intent,
    it proceeds to generate code.  Under the hood, it does this one token at a time
    (a token is a piece of a word or code symbol) using probabilities learned during
    its training. The model doesn’t “think” in the conventional sense; it doesn’t
    have a compiler or runtime checking the code. It’s simply very good at continuing
    text in a way that has a high chance of being correct code because it has seen
    so many examples before. If the prompt and context are clear, the code it produces
    can be remarkably accurate and even follow best practices it has seen in its training
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Validating with human oversight
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, the AI doesn’t run off and deploy your application for you. You
    remain in the loop. You review the generated code, test it, and can accept or
    modify it. In many cases, the AI might also offer an explanation of the code if
    asked, helping you understand the result. The AI’s role is like an assistant that
    drafts the code for you—but you, the developer, are still the decision maker who
    ensures the code is correct and fits the project’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: What’s truly impressive is that this process happens in seconds or less. The
    high-level overview is that your description (prompt) goes into a prediction engine
    (the LLM), which produces likely code as output. While the inner workings of models
    involve complex math and neural network layers, at the user level, it feels almost
    like collaborating with an expert who can instantly recall how to implement just
    about anything.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key things to understand about vibe coding (intent-based programming)
    is that it’s an iterative, collaborative process between the human and the AI.
    You don’t just write one perfect prompt and then sit back as the AI writes an
    entire program flawlessly. In practice, you engage in a back-and-forth, a feedback
    loop that gradually takes a vague idea to polished code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how a typical cycle might look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: You describe what you want'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is your initial prompt or request. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a function to calculate monthly loan payments given principal, interest
    rate, and term.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Step 2: AI provides an initial solution'
  prefs: []
  type: TYPE_NORMAL
- en: The AI generates code for that function, complete with parameters and formula
    for loan payments. It might even include comments explaining the formula.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: You review and test'
  prefs: []
  type: TYPE_NORMAL
- en: 'You look at the code. Does it make sense? Does it handle edge cases? You run
    a quick test: what if the interest rate is 0? Does it behave correctly? You notice
    it might not handle that scenario well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: You refine your request or code'
  prefs: []
  type: TYPE_NORMAL
- en: If the code isn’t perfect (and often it won’t be on the first try), refine it.
    Maybe you prompt the AI again (“Modify the function to handle a 0% interest rate
    gracefully”), or edit the code yourself and tell the AI, “Explain this part,”
    if something is unclear. This guidance helps correct any misunderstandings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: AI refines the solution'
  prefs: []
  type: TYPE_NORMAL
- en: The AI takes your feedback or new prompt and adjusts the code. Now the function
    checks for zero interest and handles it appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 6: Repeat as needed'
  prefs: []
  type: TYPE_NORMAL
- en: You continue this loop until satisfied. Perhaps next you ask the AI to also
    generate unit tests for this function to ensure it works correctly. It does so,
    and you run them to verify all is well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This collaboration is much like a pair-programming scenario where one partner
    is the human and the other is an AI assistant. The human sets the direction and
    knows the high-level requirements, while the AI offers suggestions, writes boilerplate,
    and speeds up the tedious parts. Neither is effective alone for complex tasks:
    the AI relies on the human for direction and validation, and the human offloads
    some work to the AI to move faster.'
  prefs: []
  type: TYPE_NORMAL
- en: Crucially, the iteration isn’t just about fixing errors; it’s also about evolving
    the solution. You might start with a very rough prompt and then progressively
    refine your intent as you see what the AI produces.
  prefs: []
  type: TYPE_NORMAL
- en: This encourages a mindset of experimentation. If the first attempt isn’t right,
    you haven’t wasted much time—just refine the prompt or tweak the code and try
    again. In traditional coding, writing a module only to throw it away can be frustrating,
    but with AI-generated code, the cost of a false start is low, encouraging exploration
    of different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Productivity, Accessibility, and the Changing Nature of Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why is programming with intent such a big deal? This shift has several profound
    implications:'
  prefs: []
  type: TYPE_NORMAL
- en: Boosting developer productivity
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most immediate benefit is speed. Developers can accomplish tasks
    faster when the AI handles the rote work. Routine code that might take hours to
    write by hand (like setting up database models, API endpoints, or data cleaning
    scripts) can often be generated in minutes. Early studies on AI coding assistants
    back this up: developers using tools like GitHub Copilot have been shown to complete
    tasks significantly faster ([one study](https://oreil.ly/4Ksmy) found a 55% time
    reduction on a given task with Copilot assistance). When you multiply these gains
    across an entire project, it hints at a future where software development cycles
    shorten dramatically and teams can iterate more quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping developers “in the flow”
  prefs: []
  type: TYPE_NORMAL
- en: Beyond raw speed, there’s a psychological benefit. Writing boilerplate or looking
    up syntax can break a programmer’s flow and train of thought. With an AI handling
    many of those interruptions, developers can stay focused on the problem they’re
    solving. [Many users report](https://oreil.ly/inQHR) that with AI help, they feel
    less frustrated by tedious tasks and can concentrate on the creative and design
    aspects of coding. In other words, it can make coding more enjoyable by offloading
    the boring parts, which in turn can improve the quality of the work (a happier
    coder often produces better code).
  prefs: []
  type: TYPE_NORMAL
- en: Lowering the barrier to entry
  prefs: []
  type: TYPE_NORMAL
- en: Programming has traditionally required learning the exacting grammar of code
    and the quirks of various libraries and frameworks. With intent-based programming,
    some of that burden shifts to the AI. A newcomer might not remember the exact
    syntax to open a file or the parameters of a graphing function, but if they can
    describe what they want, the AI can fill in those details. This doesn’t mean anyone
    can code complex systems with zero knowledge (you still need to understand what
    the program should do), but it does mean that the ramp-up to producing useful
    results is shorter. It’s conceivable that domain experts (like a biologist or
    an economist) could write prototypes in their field by describing their needs,
    even if they’re not professional developers. In this sense, programming becomes
    more accessible to people who have the ideas and intent but not deep coding skills.
  prefs: []
  type: TYPE_NORMAL
- en: Changing developer roles and skills
  prefs: []
  type: TYPE_NORMAL
- en: As AI takes on more code generation, the role of the human developer evolves.
    Skills like architectural design, problem decomposition, and validation become
    even more important. You might find yourself spending more time deciding *what*
    to build and reviewing *why* the code works (or doesn’t) than typing out the syntax.
    The nature of “knowing how to code” may shift toward “knowing how to get the AI
    to code.” This could democratize certain aspects of software development while
    also elevating the level at which professionals operate. We’ll likely see new
    best practices centered around how to effectively guide AI (a topic I’ll introduce
    in [Chapter 3](ch03.html#ch03_the_70_problem_ai_assisted_workflows_that_actual_1752630043200933)
    and revisit throughout the book).
  prefs: []
  type: TYPE_NORMAL
- en: Productivity versus creativity
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, as AI handles more routine coding, human developers can focus
    on higher-level creative tasks like refining the user experience, brainstorming
    new features, or tackling tricky algorithmic problems that AI might not solve
    well on its own. In this ideal scenario, the AI increases productivity on the
    repetitive 80% of coding, freeing your mental energy for the inventive 20%. It’s
    a shift in how we allocate our effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it’s not all rainbows and sunshine. This new style of development
    also raises challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: Trust and correctness
  prefs: []
  type: TYPE_NORMAL
- en: Can you trust the code an AI writes? If you don’t see every line, there’s a
    risk of mistakes going unnoticed. Developers need to thoroughly test and review
    AI-generated code. The onus is on the human to ensure the output is correct, secure,
    and efficient. Blindly trusting AI output is risky, as we’ll discuss.
  prefs: []
  type: TYPE_NORMAL
- en: Losing some low-level skills
  prefs: []
  type: TYPE_NORMAL
- en: If you rely on AI for routine coding, will you gradually lose your ability to
    write that code from scratch or debug issues deep in the weeds? It’s a concern
    akin to overreliance on calculators weakening arithmetic skills. Developers will
    need to consciously balance convenience with maintaining a solid understanding
    of the fundamentals.
  prefs: []
  type: TYPE_NORMAL
- en: Shifting job landscape
  prefs: []
  type: TYPE_NORMAL
- en: As programming with intent becomes widespread, the industry might value different
    skills. There may be less demand for people who are good at just cranking out
    boilerplate logic, and more demand for those who can design systems, integrate
    components, and verify correctness. The nature of software jobs could shift, with
    AI handling more implementation and humans focusing on design and oversight.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, one of the most critical factors in “vibe coding” is context window
    size. Gemini offers the longest context window of all AI models, which can be
    game changing when working with large projects. Some models now support context
    windows of over a million tokens, allowing them to maintain awareness of entire
    applications. Developers can feed entire codebases to an AI for comprehensive
    understanding.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll delve into these trade-offs more at the end of the chapter. But first,
    let’s familiarize ourselves with the emerging tools that enable this new way of
    coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Glimpse of the Tools: The Emerging Ecosystem'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vibe coding may be a philosophy, but it’s enabled by a new generation of AI-powered
    tools. Experienced developers who want to embrace this workflow will need to get
    acquainted with some key platforms and models that make AI-assisted coding effective.
  prefs: []
  type: TYPE_NORMAL
- en: This section is a quick tour of the essential tools in the vibe coder’s toolkit.
    These include Visual Studio Code (VSCode) with its growing ecosystem of AI features
    and extensions, next-gen AI-integrated IDEs like Cursor and Windsurf, LLMs like
    Claude (in its various versions), and ChatGPT. This section does not cover background
    coding agents, but I discuss them in detail in [Chapter 10](ch10.html#ch10_autonomous_background_coding_agents_1752630045087844).
  prefs: []
  type: TYPE_NORMAL
- en: As you read this section, don’t worry about memorizing specific tool names or
    features; the landscape is evolving fast. The goal is to understand the types
    of solutions available.
  prefs: []
  type: TYPE_NORMAL
- en: 'VSCode + Copilot: Microsoft’s Integrated AI Development Platform'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[VSCode](https://code.visualstudio.com) has transformed from the world’s most
    popular code editor into a comprehensive AI-assisted development platform through
    its deep integration with GitHub Copilot. This evolution represents Microsoft’s
    vision for keeping AI capabilities within the familiar VSCode environment that
    millions of developers already use daily.'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Copilot is an AI-powered coding assistant integrated into VSCode. It
    provides code suggestions, explanations, and automated implementations based on
    natural language prompts and existing code context. What sets this integration
    apart is its seamless nature—Copilot isn’t just an add-on but feels like a natural
    extension of the editor itself.
  prefs: []
  type: TYPE_NORMAL
- en: The core of VSCode’s AI capabilities centers on three main modes of interaction.
    First, there’s *inline code autocompletion*, where Copilot provides inline code
    suggestions as you type, ranging from single-line completions to entire function
    implementations. As you write code, ghost text appears with suggestions that you
    can accept with Tab or partially accept word by word.
  prefs: []
  type: TYPE_NORMAL
- en: Second, there’s the *chat interface*, accessible through a sidebar panel where
    you can have conversations about your code, ask questions, or request specific
    implementations. Third, and perhaps most powerful, is the *agent mode* that uses
    tool calling to access a growing set of capabilities inside Visual Studio. When
    given a goal, it selects and executes the right tools step-by-step. This agent
    mode can analyze your codebase, propose edits across multiple files, run terminal
    commands, respond to build errors, and self-correct in a loop until the task is
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: What makes VSCode’s Copilot implementation particularly compelling is its support
    for the Model Context Protocol (MCP). MCP provides a standardized way for AI models
    to discover and interact with external tools, applications, and data sources.
    This means Copilot in VSCode can connect to databases, invoke APIs, access documentation,
    and integrate with your entire development ecosystem. For instance, with the GitHub
    MCP server enabled, you can ask Copilot to “create an issue for each bug we discussed,”
    and it will interact directly with GitHub’s API to create those issues. The extensibility
    through MCP transforms Copilot from a code generator into a comprehensive development
    assistant that understands not just your code but your entire workflow.
  prefs: []
  type: TYPE_NORMAL
- en: To leverage VSCode with Copilot effectively in professional development, start
    by exploring the different interaction modes based on your task complexity. For
    simple code completions and refactoring, rely on the inline suggestions and the
    sparkle icon that appears near errors—click it for AI-powered fixes.
  prefs: []
  type: TYPE_NORMAL
- en: For more complex tasks, switch to agent mode by opening the chat panel and selecting
    “Agent” from the drop-down. Agent mode is optimized for making autonomous edits
    across multiple files in your project. It is particularly useful for complex tasks
    that require not only code edits but also the invocation of tools and terminal
    commands. The combination of VSCode’s familiar interface with Copilot’s evolving
    AI capabilities offers a compelling option for teams that want enterprise-grade
    AI assistance without leaving their established development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'VSCode + Cline: The Open Source Autonomous Coding Agent'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before exploring purpose-built AI IDEs, it’s worth examining how [Cline](https://cline.bot)
    (formerly Claude Dev) transforms VSCode into a powerful AI-assisted development
    environment. Cline represents a different philosophy from Microsoft’s Copilot.
    Rather than being a tightly integrated assistant, it functions as an autonomous
    coding agent that can take on complex, multistep development tasks from start
    to finish. This open source extension brings capabilities to VSCode that often
    exceed those found in proprietary AI editors, all while maintaining the flexibility
    and extensibility that VSCode users expect.
  prefs: []
  type: TYPE_NORMAL
- en: What distinguishes Cline is its truly agentic approach to software development.
    When you give Cline a high-level request like “Create a REST API for user management
    with authentication,” it doesn’t simply generate boilerplate code. Instead, it
    analyzes your project structure, plans the implementation across multiple files,
    creates proper folder hierarchies, installs necessary dependencies, and can even
    run tests to verify the implementation. Throughout this process, Cline maintains
    transparency by showing you each planned action—file creations, modifications,
    and terminal commands—and giving you the opportunity to approve or modify each
    step. This *human-in-the-loop* design provides the perfect balance between automation
    and control, allowing developers to leverage AI’s capabilities while maintaining
    oversight of their codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Cline’s technical capabilities extend far beyond code generation. It can use
    *browser automation* to research API documentation, debug complex issues by analyzing
    error traces across multiple files, and even interact with external services through
    its MCP support. For debugging, you can paste an error message, and Cline will
    trace through your codebase to identify the root cause, propose a fix, implement
    it, and add appropriate error handling to prevent similar issues. Its MCP integration
    means Cline can connect to your database to understand schemas before generating
    queries, access your project management tools to align implementations with requirements,
    or interact with any other MCP-compatible service. This extensibility transforms
    Cline from a code generator into a comprehensive development partner that understands
    your entire technical ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: For teams, Cline offers several compelling advantages. Being open source, teams
    can inspect its code, contribute improvements, or fork it for custom needs—crucial
    for organizations with specific security or compliance requirements. It supports
    multiple AI providers including Anthropic’s Claude, OpenAI’s models, Google’s
    Gemini, and even local models through Ollama, giving teams flexibility in model
    selection based on performance, cost, or data residency requirements.
  prefs: []
  type: TYPE_NORMAL
- en: To use Cline effectively, craft detailed prompts that include project context
    and constraints, leverage its ability to analyze your entire codebase before making
    changes, and take advantage of its iterative development capabilities. After Cline
    implements a feature, you can immediately test it and request refinements in the
    same conversation context. The combination of VSCode’s mature ecosystem with Cline’s
    autonomous capabilities offers teams a powerful, flexible, and cost-effective
    path to AI-assisted development without abandoning their existing tools and workflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cursor: The AI-Driven Code Editor'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the flagship tools of the vibe-coding movement is Cursor, an AI-enhanced
    IDE that has quickly gained popularity among developers seeking a more fluid coding
    experience. Cursor is essentially an AI-first code editor (a fork of VSCode, in
    fact) that builds state-of-the-art code generation and understanding right into
    your development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Its tagline is “The AI Code Editor,” and it’s designed to let you write and
    modify code using plain language instructions. For example, you can highlight
    a function and ask Cursor to “optimize this function” or “add error handling here,”
    and it will instantly suggest the code changes. Cursor’s AI is project-aware—it
    indexes your codebase and understands the context of your files, so it can make
    more relevant suggestions (far beyond a simple autocomplete). Cursor IDE integrates
    LLM capabilities into its core interface. It’s ChatGPT that knows your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, Cursor leverages advanced language models (often Anthropic’s
    Claude or OpenAI’s models, depending on your setup) to power its features. It
    has a chat sidebar where you can have conversations about your code, and even
    a “Composer” mode for multistep code generation. Andrej Karpathy himself has used
    Cursor’s Composer with a model called “Sonnet” in his [vibe-coding experiments](https://oreil.ly/aFqAO).
    This setup allowed him to literally *talk* to the editor (using voice-to-text
    via “SuperWhisper”) and have code appear, which he would then accept or refine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cursor can not only generate code but also *edit existing code* when instructed.
    For example, you can ask:'
  prefs: []
  type: TYPE_NORMAL
- en: Could you make it easier to switch certificates in the transport listener?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Cursor will understand you’re referring to your code and propose direct edits
    in the relevant file or read from relevant files, such as a specification markdown
    file (see [Figure 1-3](#ch01_figure_3_1752630042312486)). In the free version,
    it often provides the diff in the chat for you to approve; in the pro version,
    it can auto-apply changes to your workspace.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bevc_0103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-3\. Cursor’s interface exemplifies the newer breed of IDEs integrating
    AI. By indexing your project and iterating on prompts, tools like Cursor enable
    “leaving your editor running, grabbing coffee, and coming back to fully working
    features,” delivering exponential productivity gains.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To use Cursor effectively in a professional workflow, you should take advantage
    of its capabilities systematically. Start by opening a chat in Cursor and describe
    the feature or fix you want. For instance: add a user login form with email and
    password, including validation and error messages. Cursor will generate the needed
    code (creating new files or modifying existing ones) in a draft state. You can
    review these changes (it shows a diff or preview) and then hit “Apply” to merge
    them into your codebase. Many developers follow this loop: prompt → review → accept.
    If the suggestion isn’t perfect, you can refine your prompt (for instance, “Use
    Tailwind CSS for styling the form”) or just ask Cursor to fix any issues you spot
    (“Now, handle the case where the email is already registered”). In essence, you
    converse with your code until it looks good.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cursor also excels at understanding errors and logs. If you run your code and
    get a traceback or error message, you can paste it into the Cursor chat, and often
    the AI will analyze it and suggest a fix. This turns debugging into a [cooperative
    experience](https://oreil.ly/aFqAO): rather than you manually searching Google
    or Stack Overflow, Cursor’s AI can often pinpoint the problem and even write the
    patch. That said, it’s wise to verify the fixes, as the AI might not always get
    it right on the first try.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another pro tip: use Cursor’s ability to take multiple files into account.
    You can select a set of files (or let it know about project context in the prompt)
    so that it considers your whole codebase when generating code. For example: add
    a new API endpoint in the backend to support the login form, and connect it to
    the frontend form we just made. Cursor will recall the frontend code it just wrote
    and help craft the corresponding backend logic. This project-wide context is a
    game changer compared to earlier coding assistants that only worked file by file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, Cursor is like having an AI pair programmer *inside* your IDE,
    24/7\. It’s intuitive (you chat with it in plain language), and it can update
    your code directly. The more you practice breaking down tasks and prompting Cursor
    with clear instructions, the more you’ll find you can accomplish in a short time.
    It’s particularly great for iterative development: you build a bit, run and see
    output, then immediately ask Cursor to adjust or extend the code, and repeat.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windsurf: An AI-Powered IDE with Full Codebase Indexing'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another rising star in the vibe-coding toolbox is Windsurf, an AI-driven development
    environment that takes code understanding to the next level. Windsurf is built
    by [the team behind Codeium](https://windsurf.com), and it differentiates itself
    by indexing your entire codebase and using retrieval techniques to feed the relevant
    pieces to the AI model as you work. In practical terms, this means Windsurf is
    extremely good at handling large projects where the answer to your question might
    be spread across many files. Its core uses something called *retrieval-augmented
    generation* (RAG), which is a fancy way of saying it looks up the parts of your
    code that are relevant to your prompt and provides that context to the AI so that
    its suggestions are consistent with your existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'What does this look like for a developer? Let’s say you’re new to a big codebase
    and need to add a feature. With Windsurf, you can ask in natural language:'
  prefs: []
  type: TYPE_NORMAL
- en: Where in the codebase is the user authentication logic handled?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It will search through the index and point you to the right file or even function.
    Then, you might open a chat (Windsurf calls it the “Cascade” view, triggered by
    Cmd+L) and say:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a phone-based two-factor authentication to the login flow.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because Windsurf has the context of your auth logic, it can generate changes
    spanning multiple files (database, API, frontend) to implement this, making informed
    choices that line up with how your system is structured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Windsurf’s Write mode can boldly apply changes for you: it will create new
    files or edit existing ones automatically rather than just suggesting diffs in
    a sidebar. This can be a huge time-saver: instead of copy-pasting from suggestions,
    you see your project evolving in place. Windsurf essentially tries to take actions
    on your behalf when it’s confident, behaving like an autonomous junior dev implementing
    features across the codebase. (Cursor’s philosophy is a bit more conservative,
    asking for confirmation, although its Pro version has an “auto-apply” feature
    too.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To leverage Windsurf effectively, it helps to understand its strengths:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebase Q&A
  prefs: []
  type: TYPE_NORMAL
- en: You can query your codebase in plain English, almost like a custom Stack Overflow
    for your project. This is great for large legacy projects where finding where
    something is defined can take hours. Windsurf will answer in seconds by pulling
    from the indexed code.
  prefs: []
  type: TYPE_NORMAL
- en: Global context suggestions
  prefs: []
  type: TYPE_NORMAL
- en: Because it feeds relevant files into the model, Windsurf can handle tasks like
    “Refactor the payment module to use the new logging utility we wrote” very well,
    as it knows about both the payment module and the logging utility.
  prefs: []
  type: TYPE_NORMAL
- en: Modes of operation
  prefs: []
  type: TYPE_NORMAL
- en: Windsurf has multiple modes (Autocomplete, Chat, Command, and Cascade, as mentioned).
    The Cascade is like a superchat, where it can consider a broader context. The
    Write mode (within chat) actually executes changes. You, as the engineer, can
    decide how much autonomy to give it.
  prefs: []
  type: TYPE_NORMAL
- en: For a team, Windsurf can be integrated into daily development much like Cursor.
    When picking between them, some developers prefer Windsurf for its speed and boldness
    (noting that it feels faster to generate and apply changes) and for working with
    very large projects due to its indexing. On the other hand, Cursor’s interface
    might feel more familiar to VSCode users. It’s not necessarily an either/or choice—some
    engineers keep both handy, or teams might standardize on one.
  prefs: []
  type: TYPE_NORMAL
- en: In sum, Windsurf is an excellent tool if you want an AI coding assistant that
    truly “reads the docs/code” before writing. It minimizes the chances of hallucinated
    functions or misnamed variables because it can look things up. To get the most
    out of it, feed it clear instructions and let it rip in Write mode for big tasks,
    but also feel free to use it in a more controlled fashion for delicate changes.
    Always review the changes it makes (it will show them to you), especially for
    critical code. Windsurf is smart, but it’s not infallible. Used wisely, it’s like
    a hyperintelligent IDE that knows your entire project and can implement ideas
    across it, giving a serious boost to your throughput.
  prefs: []
  type: TYPE_NORMAL
- en: 'AI Models: The Landscape for Code Generation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AI coding landscape has transformed dramatically, with multiple powerful
    models now competing for developers’ attention, including models from the Claude,
    Gemini, and OpenAI families. Where once a single model might have dominated, today’s
    ecosystem offers a rich selection of options, each with distinct strengths that
    make them suitable for different coding scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Model Categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Today’s coding models generally fall into several categories based on their
    approach and strengths:'
  prefs: []
  type: TYPE_NORMAL
- en: Speed optimized
  prefs: []
  type: TYPE_NORMAL
- en: These prioritize quick responses and are ideal for real-time code completion
    and rapid iteration. They typically offer lower latency at the cost of slightly
    reduced accuracy on complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Deep reasoning
  prefs: []
  type: TYPE_NORMAL
- en: These take more time to “think through” problems but excel at complex debugging,
    architectural decisions, and multistep problem solving. Models with advanced reasoning
    capabilities can break down complex bugs step-by-step.
  prefs: []
  type: TYPE_NORMAL
- en: Multimodal powerhouses
  prefs: []
  type: TYPE_NORMAL
- en: Some models can process not just code and text but also images, diagrams, and
    even video content. This makes them particularly valuable for understanding visual
    documentation or working with UI/UX elements.
  prefs: []
  type: TYPE_NORMAL
- en: Open source alternatives
  prefs: []
  type: TYPE_NORMAL
- en: DeepSeek stands out by offering a comparable level of AI power to closed-source
    models without requiring payment or sign-up, though it may lack some features
    like image generation or web browsing capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the Right Model for Your Task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rather than seeking a single “best” model, successful developers now match
    models to specific tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: For rapid prototyping and general coding, models optimized for speed and broad
    language support work well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For complex debugging and system design, deep reasoning models that can trace
    through logic methodically are a good choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For working with large codebases, choose models with extensive context windows
    that can maintain project-wide awareness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For budget-conscious teams, open source models provide excellent value without
    subscription costs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many tools now support multiple AI models, including OpenAI, Claude, and Gemini
    variants, along with proprietary models, allowing developers to switch between
    them based on the task at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Practical Tips for Any Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regardless of which AI model you choose, certain practices consistently improve
    results. First, provide rich context. Don’t just ask for “a payment processing
    function.” Instead, share your data models, existing code patterns, error-handling
    approaches, and any specific requirements. The more context you provide, the better
    the output will align with your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern coding models excel at reviewing their own output. After receiving
    generated code, ask the model to check for potential issues, suggest improvements,
    or explain its reasoning. This self-critique often catches subtle bugs or suggests
    optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Use the model’s ability to maintain conversation context. Start with a basic
    implementation, then progressively refine it through follow-up requests. This
    iterative approach often yields better results than trying to specify everything
    up front.
  prefs: []
  type: TYPE_NORMAL
- en: Each model has subtle differences in how it approaches problems. Some are more
    verbose in their explanations, while others are more concise. Some default to
    newer syntax, while others play it safe. Learning these tendencies helps you craft
    better prompts.
  prefs: []
  type: TYPE_NORMAL
- en: Major Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AI coding landscape evolves monthly, with new models regularly challenging
    established leaders. The competition has become so intense that developers benefit
    from unprecedented choice and capability improvements. What matters most isn’t
    picking the “perfect” model but understanding how to leverage the strengths of
    whatever tools are available.
  prefs: []
  type: TYPE_NORMAL
- en: Many development teams now use a portfolio approach—leveraging fast models for
    routine tasks, powerful models for complex challenges, and specialized models
    for specific domains like database optimization or frontend development. Some
    IDEs even allow seamless switching between models midtask.
  prefs: []
  type: TYPE_NORMAL
- en: Success comes from understanding these options and strategically applying them
    to accelerate your development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Google Gemini: The Multimodal Coding Powerhouse'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Google’s Gemini](https://gemini.google.com) family represents a fundamental
    shift in AI-assisted development through its native multimodal capabilities. Unlike
    models that were primarily trained on text and code, Gemini was architected from
    the ground up to seamlessly understand and work across text, code, images, video,
    and other data formats. This makes it exceptionally powerful for modern development
    workflows where visual context matters as much as textual information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The multimodal nature of Gemini proves particularly valuable in web development
    scenarios. Developers can share screenshots of design mockups, and Gemini can
    generate pixel-perfect implementations that match the visual style. It excels
    at understanding charts, diagrams, and UI elements, making it an ideal partner
    when translating visual designs into functional code. This capability extends
    beyond simple image recognition: Gemini can reason about visual elements, understand
    design patterns, and maintain aesthetic consistency across an entire project.'
  prefs: []
  type: TYPE_NORMAL
- en: Gemini’s integration with development workflows through popular editors (VSCode,
    Cursor, Windsurf) and plug-ins like Cline and Code Assist offers developers powerful
    customization options that scale from individual preferences to team-wide standards.
    Developers can create custom commands for repetitive tasks, establish rules that
    apply to every code generation, and maintain consistent coding patterns across
    large codebases. The generous free tier makes it accessible to students, hobbyists,
    and startups, while enterprise features support complex organizational requirements.
  prefs: []
  type: TYPE_NORMAL
- en: What distinguishes Gemini in the coding landscape is its ability to think deeply
    about problems while maintaining practical speed. The model can alternate between
    quick responses for simple tasks and extended reasoning for complex challenges,
    adapting its approach based on the problem at hand. This flexibility, combined
    with its visual understanding capabilities, makes it particularly effective for
    full stack development where both backend logic and frontend aesthetics matter
    equally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Claude: The Reasoning Virtuoso'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Anthropic Claude’s approach](https://anthropic.com/claude) to coding assistance
    centers on transparency and deep reasoning capabilities. The Claude family, particularly
    the Sonnet models, has established itself as exceptionally capable at complex
    software engineering tasks that require careful analysis and step-by-step problem
    solving. What sets Claude apart is its ability to show its thinking process, allowing
    developers to follow along with its reasoning and verify its logic before implementing
    solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: The Artifacts feature represents a paradigm shift in how developers interact
    with AI coding assistants. Rather than simply providing code in a chat interface,
    Claude creates a dedicated workspace where code can be viewed, edited, and previewed
    in real time. This interactive environment is particularly powerful for frontend
    development, data visualization, and any scenario where immediate visual feedback
    accelerates the development process. Developers can iterate on designs, test functionality,
    and refine implementations all within the same conversation.
  prefs: []
  type: TYPE_NORMAL
- en: Claude demonstrates exceptional performance on real-world software engineering
    benchmarks, consistently ranking among the top models for tasks like bug fixing,
    feature implementation, and code refactoring. Its strength lies not just in generating
    code but in understanding the broader context of software projects. Claude can
    analyze existing codebases, identify patterns and antipatterns, suggest architectural
    improvements, and maintain consistency with established coding styles. This makes
    it invaluable for both greenfield projects and legacy system maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: The model’s approach to memory and context management enables it to build understanding
    over extended coding sessions. When working with large projects, Claude can extract
    and retain key information about the codebase structure, design decisions, and
    project-specific patterns. This accumulated knowledge allows it to provide increasingly
    relevant and contextual suggestions as development progresses, making it feel
    more like a team member who grows familiar with the project over time rather than
    a stateless assistant.
  prefs: []
  type: TYPE_NORMAL
- en: 'ChatGPT: The Versatile Coding Companion'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[ChatGPT](https://oreil.ly/hZdNC) has established itself as the Swiss Army
    knife of AI coding assistants, valued not for specialized features but for its
    remarkable versatility and broad knowledge base. Its position in the developer
    toolkit is unique. While other models might integrate directly into IDEs or offer
    specialized coding environments, ChatGPT serves as an always available programming
    consultant that developers keep open in their browsers throughout the workday.'
  prefs: []
  type: TYPE_NORMAL
- en: The conversational interface of ChatGPT makes it exceptionally effective for
    exploratory problem solving and learning. Developers regularly use it for rubber-duck
    debugging, pasting in problematic code and thinking through issues in natural
    conversation. Its extensive training enables it to recognize patterns across virtually
    every programming language, framework, and tool in common use. Whether debugging
    a regex expression, understanding an obscure error message, or exploring unfamiliar
    library documentation, ChatGPT can provide relevant insights drawn from its comprehensive
    knowledge base.
  prefs: []
  type: TYPE_NORMAL
- en: ChatGPT’s strength lies in its ability to bridge the gap between human intent
    and code implementation. It excels at *bidirectional translation*—converting natural
    language descriptions into working code and explaining complex code in plain English.
    This makes it invaluable for documentation, code reviews, and knowledge transfer
    within teams. Developers can paste unfamiliar code and receive clear explanations
    of its functionality, or describe desired behavior and receive appropriate implementations
    across multiple programming paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: The model’s versatility extends beyond traditional programming languages to
    configuration files, scripts, data formats, and domain-specific languages. While
    specialized coding tools excel within their focused domains, ChatGPT provides
    valuable assistance across the entire spectrum of software development tasks.
    This breadth makes it particularly useful when working at the boundaries between
    different technologies or when encountering problems that span multiple domains.
    Its ability to maintain context across extended conversations allows developers
    to explore complex problems iteratively, refining solutions through collaborative
    dialogue.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the Right Model for Your Needs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The availability of these powerful AI coding assistants represents a fundamental
    shift in software development practices. Rather than viewing them as competing
    options, successful developers recognize that each model family brings unique
    strengths to different aspects of the development process. Google’s Gemini excels
    when visual context and multimodal understanding are crucial, particularly in
    UI/UX development and when working with design specifications. Anthropic’s Claude
    shines in scenarios requiring deep reasoning, complex refactoring, and transparent
    problem-solving approaches. The OpenAI family of models provides unmatched versatility
    and broad knowledge, making it ideal for learning, debugging, and cross-domain
    challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Many development teams now employ a portfolio approach, leveraging different
    models for different tasks within the same project. A typical workflow might involve
    using Gemini to translate design mockups into initial implementations, Claude
    for complex architectural decisions and code reviews, and ChatGPT for general
    problem solving and documentation. This multimodel approach maximizes productivity
    by matching each tool’s strengths to specific development challenges.
  prefs: []
  type: TYPE_NORMAL
- en: As these models continue to evolve, the key to effective AI-assisted development
    lies not in choosing a single “best” option but in understanding how to orchestrate
    multiple AI assistants to accelerate and enhance every aspect of the software
    development lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: This ecosystem is young and rapidly changing. New players and capabilities are
    emerging every few months. The key takeaway is that you don’t have to build your
    own AI from scratch to leverage programming with intent—there are plenty of tools
    that bring this power to your fingertips. Throughout this book, I’ll discuss various
    platforms and how they fit into the vibe-coding workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Benefits and Limitations of Vibe Coding: A Nuanced View'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s important to recognize the scenarios where AI-assisted development truly
    shines⁠—and where it might still fall flat. Let’s explore some ideal use cases
    where vibe coding excels, as well as situations where today’s AI still struggles
    or requires heavy human intervention.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal Use Cases for Vibe Coding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as certain architectures are suited for certain problems, vibe coding has
    its “sweet spots” in the software development landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Zero-to-one product development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vibe coding is a game changer for getting a brand-new project off the ground.
    The term *zero to one* (popularized by Peter Thiel) refers to creating something
    new from scratch. With AI, you can go from a blank canvas to a functional prototype
    at lightning speed. Need to stand up a web app that’s never existed before? You
    can generate boilerplate code for your frontend, backend, database schema, and
    even deployment scripts in one frenetic session of prompting. This is perfect
    for startups or hackathon projects where the goal is to validate an idea quickly.
    Instead of spending weeks setting up the “scaffolding” of a project (all the repetitive
    setup code), you can have the AI do it in minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers have recounted how they built an MVP over a weekend with the
    help of AI pair programmers—something that might have taken them a month working
    solo before. By quickly materializing the idea into a working product, you can
    start testing it with users or stakeholders much sooner. The AI is great at the
    generic stuff (setting up routing, basic UI components, standard CRUD operations),
    which frees you to focus on the novel aspects of your product.
  prefs: []
  type: TYPE_NORMAL
- en: However, once your MVP gains traction and moves toward production, your approach
    must shift. This is where AI-assisted engineering becomes essential. While vibe
    coding has helped you explore and validate quickly, scaling now requires more
    deliberate practices. You’ll need to refactor that rapidly generated code with
    proper error handling, add comprehensive test coverage, and establish clear architectural
    boundaries. The transition from prototype to product marks the natural evolution
    from vibe coding’s exploratory freedom to engineering’s structured discipline.
    Smart teams recognize this inflection point and adjust their AI usage accordingly—maintaining
    velocity while introducing the guardrails necessary for sustainable growth.
  prefs: []
  type: TYPE_NORMAL
- en: Feature prototyping and CRUD applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A lot of software engineering, especially in business apps, involves CRUD—create,
    read, update, delete—functionality around data. This is formulaic work that AI
    is exceptionally good at because it’s seen countless examples. If you need to
    add, say, a new “Inventory” module to your system with CRUD screens and APIs,
    vibe coding will handle that extremely well. It can produce database migrations,
    ORM models, API endpoints, and UI forms with validation—basically the full stack—largely
    error-free because these patterns are so common in its training data. Even if
    your app has custom rules, you can specify those in a prompt and get a decent
    first pass. The result: what used to be a week-long task of boring wiring-up becomes
    an afternoon of prompting and testing. For internal tools or admin panels (which
    are essentially big CRUD apps), you might almost entirely lean on AI to generate
    them, given how straightforward yet time-consuming they normally are.'
  prefs: []
  type: TYPE_NORMAL
- en: The engineering approach becomes crucial when these CRUD operations involve
    complex business logic, data validation rules, or integration with existing systems.
    While vibe coding can generate the basic structure quickly, AI-assisted engineering
    ensures that your inventory module properly handles edge cases like concurrent
    updates, maintains referential integrity, and follows your organization’s established
    patterns. For instance, you might use vibe coding to generate the initial CRUD
    scaffolding, then switch to engineering mode to implement domain-specific rules
    like inventory threshold alerts, multiwarehouse allocation logic, or integration
    with your existing authentication and authorization systems. The key is recognizing
    when to transition from rapid generation to careful refinement.
  prefs: []
  type: TYPE_NORMAL
- en: Glue code and integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Need to integrate two services or APIs together? That often involves reading
    docs and writing code to transform data from one format to another. AI models
    have often been trained on API documentation and code examples, meaning they can
    expedite integration work. Ask ChatGPT to show how to call Service A’s API from
    Language B—chances are it will produce example code with the right endpoints and
    maybe even an auth example. Combining multiple systems (like hooking up a payment
    gateway with your order system or connecting a third-party analytics SDK) becomes
    easier when the AI can suggest the boilerplate and edge cases to handle. It excels
    at these standard integration patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Modern framework utilization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'AI coding assistants have effectively read the manuals on all popular frameworks:
    React, Angular, Django, Rails, Node/Express, Flutter—you name it. This means that
    if you’re using well-known frameworks, the AI can generate idiomatic code for
    those frameworks. For instance, it can spit out a new React component with hooks
    and state management or a new Django model with the proper admin class and serializer.
    The benefit is you don’t have to remember every little detail—the AI fills in
    the gaps. Vibe coding performs especially well with modern web development tasks
    like generating HTML/JSX with the right classes or hooking up controller endpoints,
    because these are tasks AI models have seen over and over. It’s like having a
    framework expert always by your side to write the boilerplate while you decide
    on the specifics of what the feature should do.'
  prefs: []
  type: TYPE_NORMAL
- en: Repetitive code generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you need to create lots of similar code (like many similar endpoints
    or classes for each type in some schema). This can be tedious and error-prone
    for a human. AI, on the other hand, loves repetitive structures—once you show
    it one or two examples, it can churn out the rest consistently. This bulk code
    generation can save a ton of time. For instance, if you’re writing data model
    classes for 50 types of records, you can prompt one example and ask the AI to
    generate classes for all 50 types following that pattern. It will likely do so
    flawlessly and in seconds. The result: you avoid a whole day of monotonous coding.'
  prefs: []
  type: TYPE_NORMAL
- en: When AI-assisted engineering should take precedence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While vibe coding excels in certain scenarios, AI-assisted engineering becomes
    indispensable in others. Understanding these situations helps developers choose
    the right approach from the start, avoiding costly rewrites or technical debt.
    Complex algorithmic implementations require the engineering approach. When you’re
    building sophisticated data structures, implementing performance-critical algorithms,
    or solving novel computational problems, you need precise control over every aspect
    of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Here, AI serves as a knowledgeable assistant rather than a code generator. You
    might ask it to explain algorithmic approaches or review your implementation for
    correctness, but you maintain direct control over the architecture and optimization
    decisions. The AI helps you think through problems rather than solving them wholesale.
  prefs: []
  type: TYPE_NORMAL
- en: Mission-critical systems demand engineering rigor from the outset. Financial
    transactions, healthcare applications, security infrastructure, and other high-stakes
    domains cannot afford the exploratory nature of vibe coding. In these contexts,
    every line of code needs careful consideration, comprehensive testing, and often
    regulatory compliance. AI assists by suggesting best practices, identifying potential
    vulnerabilities, and helping ensure compliance with standards, but the developer
    maintains tight control over the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The cost of failure in these systems far outweighs any speed advantages from
    rapid generation. Legacy system integration presents unique challenges where engineering
    discipline proves essential. When working with decades-old codebases, proprietary
    protocols, or systems with extensive technical debt, vibe coding’s pattern matching
    often fails. These scenarios require deep understanding of existing constraints,
    careful planning of integration points, and methodical refactoring. AI can help
    by explaining legacy code patterns or suggesting modernization strategies, but
    the actual implementation requires the precision that only structured engineering
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: Performance optimization represents another domain where engineering trumps
    vibing. While AI can generate functional code quickly, it rarely produces optimal
    solutions for performance-critical paths. Tasks like memory management, cache
    optimization, parallel processing, and latency reduction require deep understanding
    of hardware, operating systems, and algorithmic complexity. Here, AI serves best
    as a research assistant, helping you explore optimization techniques or benchmark
    different approaches, while you make the informed decisions about implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In these scenarios, AI’s pattern recognition and speed align perfectly with
    the task. Essentially, vibe coding thrives on tasks that are well-trodden territory
    in programming (like CRUD or typical web app structures) and tasks that benefit
    from rapid trial and error (prototypes, new ideas). It’s like having a junior
    developer who has read every GitHub repo and can instantly recall how it’s usually
    done and write it for you to review. That’s incredibly powerful for getting things
    moving quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing the transition points
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The art of modern AI-enhanced development lies not in choosing one approach
    over the other but in recognizing *when to transition between them*. Successful
    developers develop an intuition for these inflection points. Starting a new feature?
    Begin with vibe coding to explore possibilities quickly. Notice the code becoming
    complex or touching critical systems? Shift to engineering mode. Building a proof
    of concept for a client demo? Vibe coding gets you there fast. Converting that
    proof of concept into a production system? Time for engineering discipline.
  prefs: []
  type: TYPE_NORMAL
- en: This fluidity—the ability to move seamlessly between rapid exploration and careful
    construction—distinguishes truly effective AI-augmented developers. They understand
    that vibe coding and AI-assisted engineering are complementary tools in their
    toolkit, each suited for different phases of the development lifecycle. The goal
    isn’t to pick a side but to leverage both approaches strategically, maximizing
    both velocity and quality throughout the software development process.
  prefs: []
  type: TYPE_NORMAL
- en: Where AI Still Struggles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As impressive as current AI coding tools are, they are not magic. There are
    classes of problems that remain difficult for AI to handle reliably, often requiring
    human insight or traditional coding techniques. Knowing these limitations helps
    set the right expectations and lets you plan when to lean in versus when to take
    back the reins.
  prefs: []
  type: TYPE_NORMAL
- en: 'The limitations include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Deeply complex systems
  prefs: []
  type: TYPE_NORMAL
- en: If you’re dealing with very complex algorithms or novel problems that the AI
    likely hasn’t seen, it may flounder. For example, writing a brand-new algorithm
    from a research paper or doing something like writing a compiler or highly concurrent
    system—these involve intricate logic that requires true understanding and often
    creative leaps. AI can try, but it might get things subtly wrong.
  prefs: []
  type: TYPE_NORMAL
- en: In complex domains like these, the AI’s tendency to make approximately correct
    but not exactly correct code can lead to a lot of back-and-forth. As Chapters
    [3](ch03.html#ch03_the_70_problem_ai_assisted_workflows_that_actual_1752630043200933)
    and [4](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362)
    will discuss, the final 30% or so of correctness is very hard for the AI to nail
    down. This is related to what I call the *70% problem*—AI gets you most of the
    way quickly, but the last part is tough. An experienced developer might use AI
    to generate skeletons or helper functions for such complex tasks but do the core
    logic themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Low-level optimizations and systems programming
  prefs: []
  type: TYPE_NORMAL
- en: Current AI models are primarily trained on high-level languages and abstractions.
    If you need to do low-level bit-twiddling, write highly optimized C code for a
    specific microcontroller, or generate vectorized SIMD instructions, the AI might
    not be reliable. It might produce code that looks plausible but isn’t truly optimal,
    or even correct, on a hardware level.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, for things like memory management or real-time constraints, the AI
    doesn’t have a real concept of those (it doesn’t simulate a CPU cache in its head).
    So for performance-critical code, you’ll want to either thoroughly test AI suggestions
    or write those parts manually. That said, AI might still help by providing a starting
    template or explaining assembly, but you cannot blindly trust it in these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Unique or niche frameworks
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using a very new or obscure framework that wasn’t around during the
    AI’s training, it won’t know about it. In such cases, the AI might try to generalize
    or might produce code that looks like it fits but actually call functions that
    don’t exist (hallucinations) or use outdated versions of the API. For example,
    if a new web framework version came out last month with breaking changes, the
    AI won’t know about those changes. It might give you code for the old version.
    In these cases, you have to fall back on documentation and perhaps even help train
    the AI by feeding it context from the docs within your prompt (basically teaching
    it on the fly).
  prefs: []
  type: TYPE_NORMAL
- en: Creative UI/UX design
  prefs: []
  type: TYPE_NORMAL
- en: If you ask AI to design a completely novel user interface or experience, it’s
    not great at that creative leap. It can generate UI code for known patterns (like
    a standard form or a dashboard), but if you want an innovative UI that doesn’t
    have clear precedents, the AI might not give you something inspiring. It might
    just stitch together familiar components. Human designers and frontend devs are
    still very much needed to dream up new user experiences. In coding terms, AI can
    make you a standard-looking interface quickly, but for that special custom feel,
    you’ll guide it or hand-tweak.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting intent and requirements
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes AI struggles when requirements are implicit or contradictory.  It
    has no true understanding of the end goal beyond what you explicitly tell it.
    If requirements are vague (“make it efficient”—what does that precisely mean?),
    the AI might guess incorrectly what you care about (memory versus speed, for instance).
    Humans are better at clarifying intent, especially with nontechnical stakeholders.
    AI can also misinterpret instructions, especially if there’s domain-specific context
    it’s unaware of (like business rules). It might produce a logically correct solution
    that doesn’t actually solve the real problem because the nuance was lost in translation.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example scenario combining these: imagine developing a new 3D graphics
    engine (complex system) in Rust (system-level, performance critical). You have
    novel algorithms for rendering (unique problems). AI could maybe help write some
    boilerplate, but you’d largely rely on human ingenuity for the core. The AI might
    get you started with setting up a window and a basic render loop (common tasks),
    but for the bespoke parts, you’d proceed with traditional careful coding and perhaps
    get some algorithmic help from AI in pseudocode form. And if you asked it to optimize
    a hot loop in assembly, you’d have to verify every instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: AI also lacks true problem-solving insight. At the end of the day, it’s pattern
    matching. So if your problem requires an *aha!* insight, the AI might just flail
    around, presenting things that look like code but don’t solve it. This is where
    a human stepping back, thinking abstractly, or drawing on real experience can
    save the day. Once you have the insight, you can then use the AI to implement
    it quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these strengths and weaknesses ensures you’ll deploy vibe-coding
    techniques in the right situations. To maximize success, leverage the AI for what
    it’s good at (the known patterns), and apply your creativity to the unique parts
    of your application. Be ready to intervene in those areas where AI is known to
    struggle. For instance, do a careful review of any security-sensitive code it
    writes, because it might miss an edge case or two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use AI to complement human strengths: let it handle breadth (lots of code,
    boilerplate) while you handle depth (complex logic, architecture). Use it as a
    booster where it excels, and don’t be afraid to take the wheel on those tougher
    stretches of the road. This plays to the strengths of both and yields the best
    outcome. Knowing when to use AI and when to rely on human skill is what will make
    you a highly effective developer in this new era.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every new technology comes with its advantages and its caveats. As we embrace
    the productivity and creativity boost from AI-assisted development, it’s important
    to approach it with a nuanced understanding of its limitations and trade-offs.
    Key benefits include:'
  prefs: []
  type: TYPE_NORMAL
- en: Faster development cycles
  prefs: []
  type: TYPE_NORMAL
- en: Projects can move from concept to prototype to finished product more quickly.
    AI can generate scaffolding code (like setting up the boilerplate for a new project)
    in a flash, so you spend more time on the unique parts of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced prototyping and experimentation
  prefs: []
  type: TYPE_NORMAL
- en: Because the cost of trying something is lower (just describe what you want to
    the AI and get a quick draft), developers may feel freer to experiment. You can
    prototype multiple approaches to a problem by prompting the AI in different ways,
    then pick the best one. This iterative ideation can lead to more creative solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge at your fingertips
  prefs: []
  type: TYPE_NORMAL
- en: LLMs are trained on a vast corpus of programming knowledge. It often “knows”
    obscure APIs or error message solutions. In practice, it can surface solutions
    or ideas you might not have thought of, making you a more effective problem solver.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency and standardization
  prefs: []
  type: TYPE_NORMAL
- en: In team settings, an AI assistant can help enforce coding standards and best
    practices by generating code in a consistent style. If configured with your project’s
    style guide, it could ensure everyone’s code follows similar patterns. Even without
    explicit training, AI models often produce idiomatic code (since they learned
    from millions of examples). This can reduce the effort involved in code reviews,
    since its functions may look familiar and adhere to common conventions by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the limitations and trade-offs to consider include:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable output quality
  prefs: []
  type: TYPE_NORMAL
- en: These models are not infallible. They might produce code that looks correct
    but has subtle bugs or inefficiencies. They might choose an outdated approach
    because their training data included a lot of older code. As a developer, you
    must remain vigilant. Just as you wouldn’t copy-paste code from the internet without
    understanding it, you shouldn’t accept AI code thoughtlessly. [Part II](part02.html#part02)
    of this book will discuss techniques to validate and test AI-generated code thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: Ambiguity in prompts leads to ambiguity in code
  prefs: []
  type: TYPE_NORMAL
- en: If your prompt is underspecified, the AI has to guess your intent—and it might
    guess wrong. For example, if you tell it to “sort a list of names,” it might default
    to alphabetical sorting, but maybe you meant something else (like sorting by the
    length of the name). The AI won’t know the difference unless you clarify it. This
    is why specificity in prompts ([Chapter 2](ch02.html#ch02_the_art_of_the_prompt_communicating_effectively_w_1752630042971067)’s
    topic) is vital—you’ll learn to anticipate what details you need to spell out.
  prefs: []
  type: TYPE_NORMAL
- en: Overreliance and skill atrophy
  prefs: []
  type: TYPE_NORMAL
- en: If new developers always rely on AI to write their code, will they develop the
    same depth of understanding of algorithms and debugging? There’s a risk of skill
    atrophy, similar to how relying on GPS for navigation might weaken your own sense
    of direction. To mitigate this, it’s important to use AI as a learning tool (pay
    attention to the code it provides and ask why) and sometimes practice coding without
    it to ensure you retain your fundamental skills.
  prefs: []
  type: TYPE_NORMAL
- en: Privacy and security concerns
  prefs: []
  type: TYPE_NORMAL
- en: Using cloud-based AI coding tools often means sending your code (which might
    be proprietary or sensitive) to a third-party service for analysis. Companies
    need to consider this. Many tools are addressing it by allowing on-premises models
    or giving assurances about not storing code, but it’s still a consideration. Also,
    there’s a risk that AI might inadvertently generate code that is very similar
    to something in its training data, which could be under an open source license
    (like GPL). While unlikely (and measures are in place to prevent verbatim long
    outputs), it highlights the need to review and understand what the AI produces
    before integrating it. [Chapter 8](ch08.html#ch08_security_maintainability_and_reliability_1752630044621528)
    dives into questions of security and reliability.
  prefs: []
  type: TYPE_NORMAL
- en: Bias in AI output
  prefs: []
  type: TYPE_NORMAL
- en: AI models can reflect biases present in their training data. In a coding context,
    this might be as benign as preferring certain variable names or as significant
    as using examples that assume particular user attributes. For instance, it might
    use `foo/bar` for every example variable (because many examples did), or it might
    assume things about user locales. It’s usually not a huge issue in code generation
    compared to other AI applications, but it’s worth being aware of this possibility.
    More subtly, the AI might be biased toward solutions it saw more often, even if
    those aren’t the best for your case. [Chapter 9](ch09.html#ch09_the_ethical_implications_of_vibe_coding_1752630044848930)
    discusses bias and other ethical considerations.
  prefs: []
  type: TYPE_NORMAL
- en: Human factors and trust
  prefs: []
  type: TYPE_NORMAL
- en: Not all developers are immediately comfortable with this style of work. Coding
    has a certain pleasure and artistry to it, and some may feel that is diminished
    by AI involvement. There can also be an initial lack of trust—“Did it really do
    this right?”—which only good practices and time can overcome. Teams adopting AI
    should allow a period of adjustment and encourage sharing of experiences and tips.
    Over time, as with any tool, most will find a balance where the AI’s contributions
    are valued and human expertise focuses on what humans do best.
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Next Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The vibe shift toward programming with intent offers tremendous potential to
    make software development faster, more accessible, and in many ways more enjoyable.
    But realizing that potential means understanding the new dynamics: how to communicate
    with AI effectively, how to verify its output, and how to integrate it responsibly
    into your development process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'My perspective, forged from working with these tools and observing many projects,
    is that AI’s best use lies in combining the creative “vibe” with solid engineering
    hygiene. Encourage the wild ideas and rapid drafts that AI can offer—those are
    the new superpowers at our disposal. But channel them with the wisdom that software
    development has accumulated over decades: the importance of planning, testing,
    and understanding what you build.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we strike that balance, we get the best of both worlds. We get software
    that is built faster and potentially more imaginatively but also software that
    we trust, maintain, and grow with confidence. That, ultimately, is how we elevate
    our craft in the age of AI: not by choosing vibes over engineering, or vice versa,
    but by mastering the whole spectrum between.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, [Chapter 2](ch02.html#ch02_the_art_of_the_prompt_communicating_effectively_w_1752630042971067)
    explores the art of crafting prompts and collaborating with AI. With the foundational
    concepts from this chapter in mind, you’re ready to explore the practical side
    of this new programming era. This will set the stage for hands-on examples and
    deeper prompting techniques in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
