- en: 'Chapter 1\. Introduction: What Is Vibe Coding?'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 简介：什么是氛围编码？
- en: AI is reshaping how we build software, introducing new paradigms for coding
    that range from free-form prompting to structured assistance. Imagine writing
    software by simply *describing* what you want it to do—almost like talking to
    a teammate—while an AI translates those ideas into code. This is the essence of
    *vibe coding*, a prompt-first, exploratory approach where you describe what you
    want in natural language and let a large language model (LLM) fill in the blanks.
    The term was recently [coined by AI pioneer Andrej Karpathy](https://oreil.ly/Ot6CR)
    to describe this new way of programming, where developers “fully give in to the
    vibes” of AI assistance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: AI正在重塑我们构建软件的方式，引入了从自由式提示到结构化辅助的各种新的编程范式。想象一下，通过简单地*描述*你希望软件执行的操作——几乎就像与队友交谈一样——而AI将这些想法转化为代码。这就是*氛围编码*的精髓，这是一种以提示为先、探索性的方法，你用自然语言描述你想要的内容，让大型语言模型（LLM）填补空白。这个术语最近由AI先驱安德烈·卡帕西（[Andrej
    Karpathy](https://oreil.ly/Ot6CR)）提出，用以描述这种新的编程方式，其中开发者“完全屈服于AI辅助的节奏”。
- en: In this book, I’ll dive deeper into what vibe coding means for professional
    developers and how it compares with—and complements—what I call *AI-assisted engineering*,
    a more formal augmented coding process. I’ll explore how the developer’s role
    is evolving in this AI-first era, what tools and workflows can maximize your effectiveness,
    and how to address the unique challenges of letting an AI loose on your codebase.
    I’ll also look at where vibe coding shines, where it struggles, and how to balance
    the speed of AI generation with the wisdom of human oversight. By the end, you
    should have a clear picture of how to harness “the vibes” in your own coding practice—responsibly
    and effectively—to become not just a faster coder but a more creative and impactful
    software product engineer in the age of AI.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我将更深入地探讨氛围编码对专业开发者意味着什么，以及它与我所称的*AI辅助工程*——一种更正式的增强编码过程——如何比较和补充。我将探讨在这个以AI为先的时期，开发者角色是如何演变的，哪些工具和工作流程可以最大化你的效率，以及如何应对在代码库中让AI自由发挥的独特挑战。我还会探讨氛围编码的优势、劣势，以及如何平衡AI生成的速度与人类监督的智慧。到那时，你应该对如何在你的编码实践中利用“氛围”——负责任且有效地——成为不仅速度更快，而且在AI时代更具创造力和影响力的软件产品工程师有一个清晰的了解。
- en: In this chapter, we explore how the role of the developer is transforming from
    writing detailed instructions for machines to collaborating with AI by expressing
    intent (see [Figure 1-1](#ch01_figure_1_1752630042312406)). We’ll see why this
    “vibe shift” in programming is such a big deal, how it works at a high level,
    and what opportunities and challenges it brings.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨开发者角色如何从为机器编写详细指令转变为通过表达意图与AI协作（参见[图1-1](#ch01_figure_1_1752630042312406)）。我们将了解这种编程中的“氛围转变”为何如此重要，它在高层次上是如何运作的，以及它带来了哪些机遇和挑战。
- en: '![](assets/bevc_0101.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/bevc_0101.png)'
- en: Figure 1-1\. A conceptual illustration of programming with intent. The developer
    provides a high-level specification (the “intent”), and the AI translates it into
    code. This highlights the shift from writing code line by line to guiding code
    generation at a high level.
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-1. 使用意图进行编程的概念性插图。开发者提供高级规范（“意图”），AI将其转换为代码。这突出了从逐行编写代码到在高级别引导代码生成的转变。
- en: 'The AI Coding Spectrum: From Vibe Coding to AI-Assisted Engineering'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI编码光谱：从氛围编码到AI辅助工程
- en: 'Over the past year, I’ve observed a fascinating split in how developers—especially
    intermediate and advanced web developers—embrace AI in their workflow. On one
    end of the spectrum lies vibe coding. On the other end is what I’ll call *AI-assisted
    engineering*: a disciplined method of weaving AI into each phase of software development,
    from design through testing, under clear constraints. Both approaches leverage
    powerful AI, but their goals, audiences, and expectations differ markedly. Throughout
    this book, I’ll explore these two extremes and what they mean for modern web development.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的一年里，我观察到开发者——尤其是中级和高级Web开发者——在他们的工作流程中拥抱AI的方式出现了有趣的分化。一端是氛围编码。另一端是我将称之为*AI辅助工程*的方法：一种将AI编织到软件开发每个阶段（从设计到测试）的纪律性方法，在明确的约束下进行。这两种方法都利用了强大的AI，但它们的目标、受众和期望有显著差异。在这本书中，我将探讨这两种极端，以及它们对现代Web开发的意义。
- en: 'The Vibe-Coding Approach: Code by Conversation'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 氛围编码方法：通过对话进行编码
- en: In vibe coding, you leverage powerful LLMs as coding partners, letting them
    handle the heavy lifting of code generation so you can focus on higher-level goals.
    As [one *Business Insider* summary puts it](https://oreil.ly/nvcFW), vibe coding
    “means using AI tools...for the heavy lifting in coding to quickly build software.”
    As NVIDIA’s CEO Jensen Huang says, thanks to AI, “the hottest new programming
    language” is English, not Java or Python. Instead of manually typing out every
    function and bug fix, you interact with the AI in natural language—sketching out
    features, reviewing suggestions, and iterating based on the AI’s output.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在振动编码中，你利用强大的LLM（大型语言模型）作为编码伙伴，让他们处理代码生成的繁重工作，这样你就可以专注于更高层次的目标。正如[Business Insider的一篇总结](https://oreil.ly/nvcFW)所说，振动编码“意味着使用AI工具...在编码中进行繁重工作，以快速构建软件。”正如NVIDIA的首席执行官黄仁勋所说，得益于AI，“最新的热门编程语言”是英语，而不是Java或Python。你不需要手动输入每个函数和错误修复，而是用自然语言与AI互动——勾勒出功能，审查建议，并根据AI的输出进行迭代。
- en: 'This approach represents a dramatic shift from traditional programming to AI-assisted
    development. Conventional coding demands careful planning, syntax precision, and
    often painstaking debugging. Vibe coding flips that script: “It’s not really coding—I
    just see stuff, say stuff, run stuff, and copy-paste stuff, and it mostly works,”
    Karpathy quipped to *Business Insider*, highlighting how AI can turn high-level
    instructions into working code with minimal manual effort.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法代表了从传统编程到AI辅助开发的重大转变。传统的编码需要仔细规划、语法精确性，以及通常痛苦的调试。振动编码颠覆了这一模式：“这实际上并不是编码——我只是看到东西，说出东西，运行东西，复制粘贴东西，大部分都奏效，”Karpathy对Business
    Insider开玩笑说，突出了AI如何将高级指令转化为几乎无需手动努力的工作代码。
- en: 'Developers move from writing detailed instructions for computers to *orchestrating
    outcomes* with the help of AI. As an example, [Karpathy describes](https://oreil.ly/Ki6iJ)
    building a web app by continually accepting the AI’s suggestions: “I ‘Accept All’
    always, I don’t read the diffs anymore.…When I get error messages, I just copy
    paste them in.…Sometimes the LLMs can’t fix a bug so I just work around it or
    ask for random changes until it goes away.” The code “grows” beyond what he’d
    normally write himself, yet the project comes together quickly through iterative
    prompting and fixing. Essentially, vibe coding treats coding as an interactive
    conversation with your AI pair programmer rather than as a solo slog through syntax
    and stack traces. The goal is speed and exploration—to get a working solution
    with minimal friction.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者从为计算机编写详细指令转变为在AI的帮助下*编排结果*。例如，[Karpathy描述](https://oreil.ly/Ki6iJ)通过不断接受AI的建议来构建一个网络应用程序：“我总是‘接受全部’，不再阅读差异了。……当我收到错误信息时，我只是复制粘贴它们。……有时LLM无法修复一个错误，所以我只是绕过去或者要求随机更改直到它消失。”代码“增长”超出了他通常自己编写的代码，但项目通过迭代提示和修复迅速完成。本质上，振动编码将编码视为与你的AI搭档程序员进行交互式对话，而不是作为独自通过语法和堆栈跟踪的苦行。
- en: Several trends converged to make vibe coding possible. First, modern AI coding
    assistants (like OpenAI’s Codex, ChatGPT, Anthropic’s Claude, etc.) have become
    astonishingly good at generating and correcting code. In the same post, Karpathy
    notes this is “possible because the LLMs…are getting too good”—they have ingested
    vast swaths of GitHub code and can produce plausible solutions for many tasks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 几个趋势汇聚在一起，使得振动编码成为可能。首先，现代AI编码助手（如OpenAI的Codex、ChatGPT、Anthropic的Claude等）在生成和纠正代码方面变得令人惊讶地出色。在同样的帖子中，Karpathy指出这是“因为LLM...变得太好了”——它们吞噬了大量的GitHub代码，并能针对许多任务产生合理的解决方案。
- en: Second, new developer tools have emerged to integrate these models seamlessly
    into the coding workflow (more on these tools in a moment). Finally, the developer
    community’s mindset is evolving to trust AI assistance for bigger and bigger chunks
    of work. It’s no longer just autocomplete on steroids; it’s handing over whole
    functions or files to the AI. In practical terms, vibe coding often feels like
    having an unlimited supply of eager junior developers to implement whatever you
    ask for—except they work at the speed of cloud computation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，新的开发者工具已经出现，可以将这些模型无缝集成到编码工作流程中（稍后将有更多关于这些工具的介绍）。最后，开发者社区的心态正在演变，开始信任AI在更大和更大的工作部分上的辅助。这不再仅仅是增强版的自动完成；它是将整个函数或文件交给AI。从实际的角度来看，振动编码常常感觉像是拥有无限供应的渴望的初级开发者来实施你要求的一切——除了它们以云计算的速度工作。
- en: One of the most eye-popping promises of vibe coding is the productivity boost.
    Early adopters report being able to create software features or prototypes ten
    to a hundred times faster than before. For instance, [Codeium Windsurf engineer
    John Hoestje muses](https://oreil.ly/_nfZn), “Why be a 10x engineer when you could
    be a 100x engineer?” This suggests that, with the right AI-powered IDE, extraordinary
    productivity is within reach. Tools like Windsurf, an AI-enhanced IDE, “can dramatically
    accelerate development time, allowing you to achieve that 100x productivity.”
    While 100x might be an extreme scenario, even more conservative studies find huge
    gains.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: vibe编码最令人瞩目的承诺之一是提高生产力。早期采用者报告称，他们能够以前十到一百倍的速度创建软件功能或原型。例如，[Codeium Windsurf工程师John
    Hoestje沉思](https://oreil.ly/_nfZn)，“为什么只做一个10倍工程师，而不做一个100倍工程师呢？”这表明，有了正确的AI驱动的IDE，非凡的生产力是触手可及的。像Windsurf这样的AI增强IDE，“可以显著加快开发时间，让你实现100倍的生产力。”虽然100倍可能是一个极端的场景，但即使是更保守的研究也发现了巨大的收益。
- en: Developers can generate boilerplate code in seconds, fix bugs in the blink of
    an eye, and even have AI write tests or docs, compressing workflows that used
    to take days into mere hours. No longer limited by typing speed or memory, a single
    developer armed with AI can often prototype a full stack application in a weekend—something
    that might have taken a small team weeks to accomplish in the past. It’s not just
    hype either; as I noted in a January 2025 [blog post for *Pragmatic Engineer*](https://oreil.ly/khEfs),
    surveys show that *75% of developers* have already integrated some form of AI
    into their workflows, and many companies report double- or triple-digit percentage
    improvements in development velocity. In short, AI pair programmers are turning
    the mythical “10x engineer” into a very real (and reachable) 100x engineer phenomenon.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以在几秒钟内生成样板代码，在眨眼间修复错误，甚至让AI编写测试或文档，将原本需要几天的工作流程压缩到仅仅几小时。不再受打字速度或记忆力的限制，一个配备AI的单个开发者通常可以在周末内原型化一个全栈应用——这在过去可能需要一个小团队几周时间才能完成。这不仅仅是炒作；正如我在2025年1月为*实用工程师*写的[博客文章](https://oreil.ly/khEfs)中提到的，调查显示，*75%的开发者*已经将某种形式的AI集成到他们的工作流程中，许多公司报告开发速度提高了两位数或三位数的百分比。简而言之，AI配对程序员正在将传说中的“10倍工程师”现象转变为一个真实且可触及的100倍工程师现象。
- en: 'To understand how revolutionary this is, consider a concrete example. A developer
    wants to build a simple web app that counts words in a podcast script and estimates
    reading time. Instead of starting from scratch, they open an AI-powered coding
    environment and *tell* the AI their idea. Within minutes, the AI produces a working
    prototype. The developer then says, “Make the stats counters bright colors and
    add a PDF export,” and the AI updates the code accordingly. The result is a functional
    tool, deployed with one click—all achieved in under 10 minutes. This real-world
    scenario ([reported by a creator using Replit’s AI](https://oreil.ly/guqFZ)) shows
    how vibe coding enables extremely rapid, iterative development driven by high-level
    requests. Similarly, nonengineers are jumping in: the same article describes one
    laid-off marketer with no coding background who used an AI coding assistant to
    build 100 simple web tools that collectively reached the top of Product Hunt.
    When the barrier to creating software drops this low, we’re not just increasing
    productivity for seasoned developers⁠—we’re fundamentally expanding who can develop
    software in the first place.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这是多么革命性的，可以考虑一个具体的例子。一个开发者想要构建一个简单的网页应用，用于统计播客脚本中的单词数并估算阅读时间。他们不是从头开始，而是打开一个AI驱动的编码环境，并*告诉*AI他们的想法。几分钟内，AI就产生了一个可工作的原型。然后开发者说，“让统计计数器的颜色鲜艳，并添加PDF导出功能”，AI就相应地更新了代码。结果是，一个功能性的工具，只需一键部署——所有这些都在10分钟内完成。这个现实世界的场景([由使用Replit的AI的创作者报道](https://oreil.ly/guqFZ))展示了如何通过高级请求驱动实现极快、迭代的开发。同样，非工程师也在加入：同一篇文章描述了一位没有编码背景的下岗营销人员，他使用AI编码助手构建了100个简单的网页工具，这些工具共同登上了Product
    Hunt的榜首。当创建软件的门槛降低到如此低的水平时，我们不仅提高了经验丰富的开发者的生产力——我们从根本上扩大了谁可以开发软件的范围。
- en: 'However, vibe coding comes with serious caveats. Because you’re deferring so
    much to the AI, you might end up with code that “works” in the happy path but
    hides a minefield of bugs or poor design decisions. Without a solid plan or constraints,
    an LLM might generate a solution that lacks proper error handling, security checks,
    or scalability. In fact, AI-generated code can sometimes be built on sand: it
    appears solid but has hidden issues that only surface under real-world conditions.
    I’ve seen cases where a developer vibed their way to a complete feature in record
    time, only to discover later that the code was inefficient and hard to maintain.
    This kind of “house of cards” code can collapse under pressure.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，vibe coding存在严重的警告。因为你将如此多的任务委托给了AI，你可能会得到一些“工作”的代码，但在快乐路径下隐藏了满地的地雷或糟糕的设计决策。没有稳固的计划或限制，LLM可能会生成缺乏适当错误处理、安全检查或可扩展性的解决方案。事实上，AI生成的代码有时可能建立在沙滩上：它看起来很坚固，但隐藏的问题只有在实际条件下才会暴露出来。我见过一些案例，开发者通过vibe
    coding在创纪录的时间内完成了一个完整的功能，但后来发现代码效率低下且难以维护。这种“纸牌屋”式的代码在压力下可能会崩溃。
- en: 'For example, imagine asking an AI to “whip up a user login system.” The AI
    might produce a working authentication flow quickly, but perhaps it uses a simplified
    encryption method or a known vulnerable library. If you deploy that without deeper
    inspection, you’re taking on faith that everything is sound. Seasoned engineers
    know that’s risky: code running in production has to be understood and trusted.
    As [one expert](https://oreil.ly/ppXCf) put it, “Vibe coding your way to a production
    codebase is clearly risky. Most of the work we do as software engineers involves
    evolving existing systems, where the quality and understandability of the underlying
    code is crucial.” Vibe coding, at its extreme, can bypass those quality gates.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下要求一个AI“快速制作一个用户登录系统”。AI可能会迅速生成一个工作的认证流程，但可能使用了简化的加密方法或已知的易受攻击的库。如果你在未进行深入检查的情况下部署它，你是在盲目地相信一切都很安全。经验丰富的工程师知道这是有风险的：在生产环境中运行的代码必须被理解和信任。正如[一位专家](https://oreil.ly/ppXCf)所说：“通过vibe
    coding直接进入生产代码库显然是危险的。我们作为软件工程师所做的许多工作都涉及现有系统的演变，其中底层代码的质量和可理解性至关重要。”vibe coding在极端情况下可能会绕过这些质量关卡。
- en: 'Another challenge is that vibe coding tends to downplay upfront planning. Traditional
    software engineering values designing for clarity and constraint-thinking through
    data models, choosing appropriate patterns, and writing out at least a minimal
    spec. Vibe coding flips this: it starts with *no scaffolding*, diving straight
    into implementation via prompts. That can lead to a meandering development process.
    You might prompt your way into a corner—say the AI chooses a state management
    approach or library you didn’t intend, and now you have to either steer it back
    or live with it. Without an initial blueprint, the final architecture might be
    haphazard. This is fine for a quick proof of concept, but it’s troublesome in
    a larger codebase where consistency matters.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个挑战是，vibe coding往往低估了前期规划的重要性。传统的软件工程重视清晰的设计和通过数据模型进行约束性思考，选择合适的模式，并至少编写出最小规格说明。vibe
    coding则相反：它从*无框架*开始，直接通过提示进入实现。这可能导致开发过程变得混乱。你可能会通过提示进入一个死角——比如说AI选择了一个你未打算使用的状态管理方法或库，现在你必须要么引导它回到正轨，要么忍受它。没有初始蓝图，最终的架构可能杂乱无章。这对于快速的概念验证来说是可行的，但在一个需要一致性的大型代码库中却是个麻烦。
- en: Vibe coding isn’t inherently “bad.” In fact, its emergence is part of the ongoing
    democratization of programming. It lowers the barrier to creating software, much
    like early low-code platforms or scripting languages did. A motivated nonengineer
    with a clear idea could potentially build a simple app through vibes alone. And
    for experienced developers, vibe coding can be a powerful brainstorming tool—it’s
    like pseudo coding but with immediate, runnable results. The key is recognizing
    its limits. Speed without discipline can lead to brittle software, so vibe coding
    requires a vigilant human in the loop. I often remind developers (and myself)
    that “vibe coding is not an excuse for low-quality work.” It should be the *start*
    of a solution, not the end.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Vibe coding本身并不是“坏”的。事实上，它的出现是编程民主化进程的一部分。它降低了创建软件的门槛，就像早期的低代码平台或脚本语言所做的那样。一个有明确想法的动机非工程师可能仅通过vibe
    coding就能构建一个简单的应用程序。对于经验丰富的开发者来说，vibe coding可以是一个强大的头脑风暴工具——它就像伪代码，但具有立即可运行的成果。关键是认识到它的局限性。没有纪律的速度可能导致软件脆弱，因此vibe
    coding需要一个警觉的人类参与其中。我经常提醒开发者（包括我自己），“vibe coding不是低质量工作的借口。”它应该是解决方案的*开始*，而不是结束。
- en: 'The AI-Assisted Engineering Approach: Structure with an AI Partner'
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人工智能辅助工程方法：与人工智能伙伴一起构建结构
- en: On the opposite end of our spectrum is *AI-assisted engineering*—a more structured,
    methodical way of building software with AI as a copilot at every step. Here,
    the developer remains very much in the driver’s seat. AI-assisted engineering
    includes using AI across the traditional software development lifecycle (SDLC),
    such as AI-powered autocomplete, chat, code migrations, bug detection, test generation,
    and both granular (function, module, component) and full code generation (see
    [Figure 1-2](#ch01_figure_2_1752630042312451)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的光谱的另一端是*人工智能辅助工程*——一种更结构化、更有条理的软件构建方式，其中人工智能作为每个步骤的副驾驶。在这里，开发者仍然牢牢掌握方向盘。人工智能辅助工程包括在传统的软件开发生命周期（SDLC）中使用人工智能，例如人工智能驱动的自动完成、聊天、代码迁移、错误检测、测试生成以及细粒度（功能、模块、组件）和完整代码生成（见[图1-2](#ch01_figure_2_1752630042312451)）。
- en: '![](assets/bevc_0102.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/bevc_0102.png)'
- en: 'Figure 1-2\. The plan-first AI-assisted engineering workflow: developers create
    specifications, provide targeted prompts to AI systems, review generated code
    snippets, and integrate approved solutions into their projects.'
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2\. 首先计划的人工智能辅助工程工作流程：开发者创建规范，向人工智能系统提供有针对性的提示，审查生成的代码片段，并将批准的解决方案集成到他们的项目中。
- en: You begin with a plan (even if it’s lightweight), outlining what you need to
    build and defining the constraints and acceptance criteria up front. Then you
    incorporate AI tools in a targeted manner to accelerate or enhance parts of that
    plan. In contrast to prompt-first vibe coding, we might call this “plan-first”
    development with AI support. This could be as formal as a mini-product requirements
    document (a short PRD for a feature) or as simple as a checklist of tasks. The
    crucial difference is that you ground the work in *clear intent and constraints*
    before letting the AI loose.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你从一份计划开始（即使它很轻量级），概述你需要构建的内容，并在一开始就定义约束和验收标准。然后，你以有针对性的方式整合人工智能工具来加速或增强该计划的某些部分。与“提示优先”的编码风格相比，我们可能会称之为“计划优先”的开发，并辅以人工智能支持。这可能是像迷你产品需求文档（一个特性的简短PRD）那样正式，或者只是一个任务清单。关键的区别在于，在让人工智能放手之前，你将工作建立在*明确的意图和约束*的基础上。
- en: 'Consider a React developer tasked with creating a new interactive dashboard
    component. In an AI-assisted engineering approach, they might begin by writing
    down the component’s responsibilities and API:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个被分配创建新交互式仪表板组件的React开发者。在人工智能辅助工程方法中，他们可能首先写下组件的职责和API：
- en: Dashboard component shows a list of analytics cards, supports filtering by date
    range, and has refresh and export buttons. It should fetch data from our API (with
    proper error handling), and it must follow our design system for styling.
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 仪表板组件显示分析卡片列表，支持按日期范围过滤，并具有刷新和导出按钮。它应从我们的API（带有适当的错误处理）获取数据，并且必须遵循我们的设计系统进行样式设计。
- en: 'This outline is essentially a spec. The developer might even sketch a quick
    data model or identify existing utility functions to reuse. Only then do they
    bring in the AI: for instance, using an AI-enabled IDE or coding assistant to
    generate the skeleton of the component based on that description. The AI might
    provide a starting implementation of the React component with placeholders for
    data fetching and stubbed event handlers. Because the developer provided clear
    guidance, the AI’s output is more likely to align with the project’s needs (such
    as using the right design system classes or calling the correct API endpoints).
    The code isn’t a surprise; it’s the product of a well-formed request.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个大纲本质上是一个规范。开发者甚至可能快速绘制一个数据模型或识别现有的实用函数以供重用。然后，他们才引入人工智能：例如，使用具有生成组件骨架功能的人工智能IDE或编码助手，基于该描述。人工智能可能会提供一个React组件的起始实现，其中包含数据获取占位符和模拟的事件处理程序。由于开发者提供了明确的指导，人工智能的输出更有可能与项目的需求一致（例如使用正确的设计系统类或调用正确的API端点）。代码不是惊喜；它是良好请求的结果。
- en: AI-assisted engineering doesn’t stop at code generation for a single component.
    It permeates the entire development lifecycle in a controlled fashion. For routine
    coding tasks, an AI autocompletion tool like GitHub Copilot can suggest the next
    few lines as you type, saving keystrokes when you’re implementing known patterns.
    For example, as you write a unit test, your AI helper might autosuggest assertions
    based on the function name. Speaking of tests, you might use AI to generate test
    cases once a feature is in place—feeding the component’s spec or code into a prompt
    to get suggestions for edge cases you should check. The idea is to *augment* the
    engineer’s work, not replace it. You’re still thinking through the logic and verifying
    correctness; the AI just offloads some of the grunt work.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: AI辅助工程不仅仅局限于生成单个组件的代码。它以一种受控的方式渗透整个开发周期。对于常规编码任务，GitHub Copilot这样的AI自动补全工具可以在你键入时建议接下来的几行，当你实现已知模式时节省按键。例如，当你编写单元测试时，你的AI助手可能会根据函数名自动建议断言。说到测试，一旦功能到位，你可以使用AI生成测试用例——将组件的规格或代码输入提示以获取应检查的边缘情况的建议。目的是**增强**工程师的工作，而不是取代它。你仍然在思考逻辑并验证正确性；AI只是卸载了一些繁琐的工作。
- en: When it comes to code migration or refactoring, AI can be a godsend. Imagine
    needing to convert a class-based React component to a modern function component
    with hooks. Rather than doing it all manually, you could ask an AI assistant to
    transform the code or at least outline the steps. With a good understanding of
    the old and new patterns, an LLM can produce a draft of the refactored code, which
    you then review and polish. This structured use of AI tackles well-defined tasks
    (like “migrate this code from Redux to React Context API”) one by one rather than
    handing the AI an open-ended “build whatever” mandate.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到代码迁移或重构时，AI可以是一个救星。想象一下，你需要将基于类的React组件转换为具有钩子的现代函数组件。而不是手动完成所有工作，你可以要求AI助手转换代码或至少概述步骤。有了对旧模式和新型模式的良好理解，LLM可以生成重构代码的草案，然后你对其进行审查和润色。这种结构化的AI使用方法逐个解决定义明确的任务（如“将此代码从Redux迁移到React
    Context API”），而不是给AI一个开放式的“构建任何东西”的命令。
- en: 'Perhaps the most dramatic form of AI-assisted engineering is using AI to generate
    a full mini-application or feature from a detailed specification. Several tools
    now allow you to input a description of an app, something akin to a mini-PRD,
    and get back a working codebase or prototype. For instance, a developer could
    supply a spec for:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: AI辅助工程最戏剧性的形式可能是使用AI从详细规格中生成完整的迷你应用程序或功能。现在有几款工具允许你输入应用程序的描述，类似于迷你PRD，然后得到一个可工作的代码库或原型。例如，开发者可以提供以下规格：
- en: a to-do list app with React frontend and Node.js backend, supporting user authentication
    and real-time updates
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个具有React前端和Node.js后端、支持用户身份验证和实时更新的待办事项应用程序
- en: The AI tool would scaffold the project, create the key components, and set up
    the database schema.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: AI工具将构建项目框架，创建关键组件，并设置数据库模式。
- en: This isn’t magic; it’s an accelerated version of what a diligent engineer might
    do when starting a new project (setting up directories, choosing libraries, writing
    boilerplate code). The important thing is that the AI’s creativity is *bounded
    by the constraints given in the spec*. The result is a minimum viable product
    (MVP) that adheres to the requirements you provide. An experienced developer,
    treating this output correctly, will not assume it’s production-ready on the first
    generation. Instead, they’ll treat it as a first draft. They’ll run the app, write
    or regenerate tests to validate each feature, review the code for any inconsistencies
    or insecure configurations, and refine as needed. In short, they’ll apply all
    their usual engineering rigor—just accelerated by an AI’s ability to produce bulk
    code from a blueprint.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是魔法；这只是勤奋的工程师在开始一个新项目时可能采取的加速版本（设置目录、选择库、编写样板代码）。重要的是，AI的创造力是**受限于规格中给出的约束**。结果是符合你提供要求的最低可行产品（MVP）。经验丰富的开发者，如果正确处理这个输出，不会假设它在一开始就适合生产。相反，他们会将其视为初稿。他们会运行应用程序，编写或重新生成测试以验证每个功能，检查代码中的任何不一致或不安全的配置，并在需要时进行改进。简而言之，他们会应用他们所有的常规工程严谨性——只是通过AI从蓝图生成大量代码的能力而加速。
- en: The goals of AI-assisted engineering are different from those of vibe coding.
    The aim here is not just to get *working* code quickly but to get *high-quality*
    code more efficiently. It’s about boosting productivity while preserving (or even
    improving) the reliability of the outcome. A team practicing AI-assisted engineering
    might say, “We want to deliver this feature two times faster but with zero compromise
    on our standards.”
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能辅助工程的目标与vibe coding的目标不同。这里的目的是不仅快速获得*可工作*的代码，而且更有效地获得*高质量*的代码。这是关于提高生产力同时保持（甚至提高）结果的可信度。实践人工智能辅助工程的团队可能会说：“我们希望以两倍的速度交付这个功能，但对我们标准零妥协。”
- en: The audience for this approach is typically professional developers and teams
    who have established processes (code review, testing, deployment pipelines) that
    they aren’t willing to abandon. These are intermediate to senior engineers who
    see AI as a powerful new tool in their toolbox, not a replacement for the toolbox.
    They likely have seen what happens when you cut corners, so they value practices
    that keep software maintainable. (By way of comparison, the audience for vibe
    coding includes solo developers hacking together demos, product-minded folks with
    some coding knowledge, and even relatively new programmers who leverage AI to
    compensate for gaps in their expertise.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的受众通常是那些已经建立了流程（代码审查、测试、部署管道）的专业开发者和团队，他们不愿意放弃这些流程。这些是中级到高级工程师，他们将人工智能视为工具箱中的一种强大新工具，而不是工具箱的替代品。他们可能已经看到了当你走捷径时会发生什么，因此他们重视保持软件可维护性的实践。（相比之下，vibe
    coding的受众包括独自开发演示的独立开发者、有一定编码知识的以产品为导向的人，甚至相对较新的程序员，他们利用人工智能来弥补他们专业知识中的不足。）
- en: The expectations in AI-assisted engineering are that humans remain in control
    of decisions, and the AI provides suggestions or accelerators. Code quality, performance,
    and security remain paramount, so every AI-generated piece is subject to the same
    scrutiny as if a junior developer wrote it. Treat the AI as your intern, not your
    replacement. You might delegate tasks to it, but you must review its work. Just
    as you’d never deploy code written by a human intern without a code review, you
    shouldn’t deploy AI-written code without understanding it. This mindset keeps
    the engineering discipline front and center.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在人工智能辅助工程中，人们的期望是保持人类对决策的控制，而人工智能提供建议或加速器。代码质量、性能和安全仍然至关重要，因此每个由人工智能生成的作品都应接受与初级开发者编写的作品相同的审查。将人工智能视为你的实习生，而不是你的替代者。你可能将任务委托给它，但必须审查其工作。就像你永远不会在没有代码审查的情况下部署由人类实习生编写的代码一样，你不应该在没有理解的情况下部署由人工智能编写的代码。这种心态将工程学科置于首位。
- en: Different Mindsets, Different Expectations
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的思维方式，不同的期望
- en: 'Vibe coding and AI-assisted engineering are two distinct mindsets. Vibe coding
    is top-down and exploratory: you start with a broad idea and let the implementation
    emerge through interaction with the AI. It’s a bit like improvisational jazz—minimal
    structure, lots of room for creative riffs, and you discover the shape of the
    song as you play. AI-assisted engineering is systematic and iterative: more like
    classical composition, where you begin with a theme or motif (your requirements)
    and methodically develop it, perhaps using some improvisation (AI suggestions)
    within the measures of a written score. Both can produce “music,” but the process
    and the kind of result will differ.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Vibe coding和人工智能辅助工程是两种不同的思维方式。Vibe coding是自上而下和探索性的：你从一个广泛的想法开始，通过与人工智能的交互来让实现出现。这有点像即兴爵士乐——结构最少，有大量的创意即兴空间，你在演奏的过程中发现歌曲的形状。人工智能辅助工程是系统性和迭代的：更像是古典作曲，你从一个主题或动机（你的需求）开始，并系统地发展它，也许在乐谱的范围内进行一些即兴创作（人工智能的建议）。两者都可以产生“音乐”，但过程和结果类型将不同。
- en: For an intermediate or advanced web developer, your expectations for each approach
    are key. If you’re vibe coding, you expect to be surprised. The AI might come
    up with an approach you wouldn’t have written yourself—maybe it uses a different
    library or a programming idiom you’re less familiar with. Part of the allure is
    learning from those surprises or quickly getting past things you find tedious.
    But you also need to expect hiccups. Vibe-coding enthusiasts should go in with
    eyes open that they’ll be responsible for that tricky last stretch. The magic
    is real, but it’s not total.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个中级或高级的Web开发者来说，你对每种方法的期望至关重要。如果你在“氛围式编码”，你期望会有惊喜。人工智能可能会提出你不会自己写的方案——也许它使用了你不太熟悉的库或编程习惯。吸引力的一部分在于从这些惊喜中学习，或者快速克服你发现乏味的事情。但你也需要预料到会有一些小插曲。热衷于氛围式编码的人应该带着清醒的头脑进入，知道他们将负责那个棘手的最后阶段。魔法是真实的，但并非万能。
- en: If you’re practicing AI-assisted engineering, your expectations are more measured
    and arguably more realistic for long-term projects. You expect the AI to save
    you time and perhaps inspire a solution or two but not to do your whole job. In
    fact, a good AI-assisted engineer might use vibe-style prompting in *microdoses*
    within a larger framework. For example, while implementing a well-specified module,
    they might momentarily switch into “vibe mode” to ask, “Hey AI, generate a quick
    utility function to format these dates,” then immediately switch back to engineer
    mode to integrate and check that function. The mindset is that AI is a collaborator
    that works under your guidance. You allocate tasks to it where it excels (like
    boilerplate, repetitive code, broad-stroke implementations), and you handle the
    rest yourself (critical logic, integration, final review).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在实践人工智能辅助的工程，你对长期项目的期望会更加谨慎，并且可以说是更加现实的。你期望人工智能能为你节省时间，也许能启发一两个解决方案，但不是完成整个工作。实际上，一个优秀的人工智能辅助工程师可能会在更大的框架内使用“氛围式提示”的“微剂量”。例如，在实现一个明确指定的模块时，他们可能会暂时切换到“氛围模式”，询问：“嘿，AI，生成一个快速的工具函数来格式化这些日期，”然后立即切换回工程师模式，整合并检查该函数。这种心态是，人工智能是一个在你的指导下工作的合作伙伴。你分配给它擅长完成的任务（如模板代码、重复性代码、粗略实现），而其余的你自己处理（关键逻辑、集成、最终审查）。
- en: 'Expectations here include improved productivity, fewer rote mistakes (an AI
    is less likely to misspell a variable name, for instance), and possibly a broader
    solution search space (the AI might suggest an algorithm you hadn’t thought of).
    But you also expect to invest time in validation.  Debugging AI-assisted code
    is still debugging: you run tests and step through the code in the debugger if
    needed. The difference is that you might find yourself debugging code the AI wrote
    for you, which is a new experience that comes with a learning curve. [Chapter 5](ch05.html#ch05_understanding_generated_code_review_refine_own_1752630043592278)
    will discuss this experience in detail.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的期望包括提高生产力、减少机械错误（例如，人工智能不太可能拼错变量名），以及可能更广泛的解决方案搜索空间（人工智能可能会提出你未曾考虑过的算法）。但你也期望在验证上投入时间。调试人工智能辅助的代码仍然是调试：你需要运行测试，并在需要时在调试器中逐步执行代码。区别在于，你可能会发现自己正在调试人工智能为你编写的代码，这是一种新的体验，需要一定的学习曲线。[第5章](ch05.html#ch05_understanding_generated_code_review_refine_own_1752630043592278)将详细讨论这一体验。
- en: 'The two approaches’ goals highlight a fundamental difference between them:
    vibe coding optimizes for *velocity in the short term*, whereas AI-assisted engineering
    optimizes for *sustained velocity and reliability*. A vibe coder might say, “I
    need to get this app running by tonight to see if the idea works.” An AI-assisted
    engineer would say, “I need to build this feature fast, but it should be robust
    enough to live in our codebase for years.” The former is satisfied if the code
    basically functions; the latter cares that the code is clean enough for others
    to build upon.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的目标突出了它们之间的一个基本区别：氛围式编码优化的是短期内的“速度”，而人工智能辅助的工程优化的是“持续的速度和可靠性”。一个氛围式编码者可能会说：“我需要今晚让这个应用运行起来，看看这个想法是否可行。”而一个人工智能辅助的工程师会说：“我需要快速构建这个功能，但它应该足够健壮，能在我们的代码库中存活多年。”前者如果代码基本能运行就满意了；而后者关心的是代码是否足够干净，以便其他人可以在此基础上构建。
- en: These differences naturally appeal to different audiences. Less-experienced
    developers or those outside the engineering discipline might lean toward vibe
    coding because it lowers the barrier to entry and provides instant gratification.
    I’ve met product managers and designers dabbling in code via vibe prompts, treating
    the AI almost like a superpowered Stack Overflow that gives them full solutions.
    On the flip side, seasoned developers and engineering teams tend to favor AI-assisted
    engineering. They’ve been burned by fragile code before, so they start from a
    place of “let’s do this right, even if we use new tools to go faster.” They put
    in a bit more effort up front (writing that mini-PRD, setting up the project structure)
    in exchange for long-term payoffs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异自然地吸引了不同的受众。经验较少的开发者或那些非工程学科的人可能会倾向于氛围编码，因为它降低了入门门槛并提供了即时满足感。我遇到过一些产品经理和设计师通过氛围提示尝试编码，几乎将AI当作一个超级强大的Stack
    Overflow，它为他们提供了完整的解决方案。另一方面，经验丰富的开发者和工程团队往往更喜欢AI辅助工程。他们之前曾因脆弱的代码而吃过亏，因此他们从“让我们正确地做这件事，即使我们使用新工具来加快速度”的角度出发。他们前期投入了更多努力（编写那个迷你PRD，设置项目结构），以换取长期回报。
- en: Finding Your Place on the Spectrum
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在光谱上找到你的位置
- en: 'It’s tempting to ask: which approach is better? The truth is, vibe coding and
    AI-assisted engineering aren’t mutually exclusive categories: they represent two
    ends of a spectrum, and real-world workflows often blend elements of both. A developer
    might start a project with a burst of vibe coding to scaffold something novel,
    then switch into engineering mode to firm it up. Or they might generally follow
    an AI-assisted discipline but occasionally—for a trivial one-off script or a throwaway
    prototype—say, “You know what, I’ll just vibe code this and see what I get.” The
    key is understanding the trade-offs and using the right approach for the right
    context.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易问：哪种方法更好？事实是，氛围编码和AI辅助工程并不是相互排斥的类别：它们代表了光谱的两端，现实世界的流程通常融合了两者的一些元素。开发者可能开始一个项目时用一阵氛围编码来构建一些新颖的东西，然后切换到工程模式来巩固它。或者，他们可能通常遵循AI辅助的学科，但偶尔——对于一个小型的单次脚本或一次性原型——可能会说：“你知道什么，我就这样氛围编码看看我能得到什么。”关键是理解权衡并使用适合特定情境的正确方法。
- en: 'Think of vibe coding as a high-speed exploratory vehicle: it can take you off
    the beaten path quickly, and it’s great for discovery. AI-assisted engineering
    is more like a reliable train on a track: you have to lay down rails first (plan),
    but it’s a safer bet and more likely to reach a defined destination without derailing.
    Intermediate and advanced developers should be capable of driving both vehicles,
    but they’ll choose based on the task at hand. If the goal is to innovate or ideate
    rapidly (say, in a hackathon or when validating an idea’s feasibility), vibe coding
    provides momentum. Just remember to tighten things up if you plan to reuse that
    code. If the goal is to build a maintainable product feature in a professional
    setting, leaning toward AI-assisted engineering ensures you don’t end up with
    a black-box chunk of code in your codebase that nobody truly understands.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将氛围编码视为一种高速的探索性车辆：它能够迅速带你离开常规路线，非常适合发现。AI辅助工程则更像是在轨道上的可靠火车：你必须先铺设轨道（规划），但这是一种更安全的赌注，更有可能在不脱轨的情况下到达一个明确的目的地。中级和高级开发者应该能够驾驶这两种车辆，但他们将根据手头的任务来选择。如果目标是快速创新或构思（比如在黑客马拉松或验证一个想法的可行性时），氛围编码提供了动力。但请记住，如果你打算重用那段代码，一定要确保代码整洁。如果目标是在一个专业环境中构建一个可维护的产品功能，那么倾向于AI辅助工程可以确保你不会在代码库中留下一个没有人真正理解的黑盒代码块。
- en: One fascinating thing I’ve observed is that as developers gain experience with
    AI tools, their usage often naturally shifts from the vibe end toward the engineering
    end. Initially, the novelty of having an AI generate entire blocks of code from
    a single prompt is alluring—who wouldn’t want to try essentially “talking” an
    app into existence?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我观察到的一个有趣的现象是，随着开发者对AI工具的实践经验增加，他们的使用往往自然地从氛围端转向工程端。最初，AI从单个提示中生成整个代码块的新奇性非常吸引人——谁不想尝试“谈话”一个应用出来呢？
- en: But after the honeymoon, pragmatism kicks in. Developers start to see where
    the AI shines and where it stumbles. They learn to break problems down and feed
    them to the AI in pieces rather than asking for the whole solution in one go.
    In effect, they move from being “prompt artists” to becoming AI “orchestra conductors”—still
    utilizing the AI’s creative power but guiding it with a skilled hand and following
    a clear score. In my own practice, I’ve become more deliberate with prompts, often
    writing small pieces of pseudocode or comments and asking the AI to complete them
    instead of just asking open-ended questions. This way, I get the benefits of vibe-like
    fluidity but within a structure I control.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但蜜月期过后，现实主义开始发挥作用。开发者开始看到人工智能的亮点和不足之处。他们学会了将问题分解成小块，并分批提供给人工智能，而不是一次性要求整个解决方案。实际上，他们从“提示艺术家”转变为成为人工智能“乐团指挥”——仍然利用人工智能的创造力，但用熟练的手法引导，并遵循清晰的乐谱。在我的实践中，我变得更加谨慎地使用提示，经常编写小块的伪代码或注释，并要求人工智能完成它们，而不是仅仅提出开放式问题。这样，我得到了类似vibe的流畅性，但又在可控的结构中。
- en: 'It’s also worth noting that tooling is evolving to support the entire spectrum.
    On one side, we have chat-based interfaces and natural-language coding environments
    explicitly designed for vibe coding, where you might not even see the code until
    you ask for it. On the other, IDEs are adding AI features that seamlessly blend
    into traditional coding: for example, AI linters that suggest improvements, documentation
    generators that explain code, and version-control bots that can automatically
    create a pull request and suggest changes for review. These tools encourage an
    engineering mindset by fitting into the usual development workflow (edit, review,
    test, etc.) while still leveraging AI.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，工具也在不断发展，以支持整个谱系。一方面，我们有基于聊天的界面和专门为vibe编码设计的自然语言编码环境，你可能甚至直到请求时才看到代码。另一方面，IDE正在添加人工智能功能，这些功能无缝地融入传统编码：例如，建议改进的人工智能代码检查器，解释代码的文档生成器，以及可以自动创建拉取请求并建议审查更改的版本控制机器人。这些工具通过适应常规的开发工作流程（编辑、审查、测试等）来鼓励工程思维，同时仍然利用人工智能。
- en: 'The distinction between vibe coding and AI-assisted engineering might even
    blur over time as best practices emerge. We may find that what today feels like
    “vibing” will gain more guardrails, and what feels like “structured engineering”
    will become more fluid. In fact, I’d argue that the ideal future is one where
    we can move up and down this spectrum effortlessly: exploring creative solutions
    with AI when we want to but always reining things in with solid engineering practices
    when it’s time to harden and ship the software.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 随着最佳实践的浮现，vibe编码和人工智能辅助工程之间的区别甚至可能随着时间的推移而变得模糊。我们可能会发现，今天感觉像“vibing”的东西将获得更多的约束，而感觉像“结构化工程”的东西将变得更加灵活。事实上，我会争辩说，理想未来的目标是我们能够轻松地在这一谱系中上下移动：当我们想要探索创造性解决方案时，与人工智能一起探索，但在需要将软件固化并发布时，始终用坚实的工程实践来控制一切。
- en: This spectrum of approaches represents a significant evolution in how we work
    with AI tools today. Yet even as we refine our techniques for collaborating with
    AI—whether through rapid vibe coding or structured engineering workflows—a more
    fundamental transformation is taking shape. The very nature of programming itself
    is changing. We’re moving away from the traditional paradigm where developers
    must translate their ideas into explicit instructions and toward a future where
    we can express our intentions directly and let AI handle the translation into
    code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法谱系代表了我们在今天如何与人工智能工具合作的重要演变。然而，即使我们改进了与人工智能协作的技术——无论是通过快速vibe编码还是结构化工程工作流程——一种更根本的变革正在形成。编程本身的本质正在改变。我们正在从开发者必须将他们的想法转化为明确指令的传统范式，转向一个未来，我们可以直接表达我们的意图，让人工智能处理代码的翻译。
- en: This shift challenges our most basic assumptions about what it means to be a
    programmer. For generations, our value has been tied to our ability to think like
    machines—to break down problems into discrete, logical steps that computers can
    execute. But what happens when machines become capable of understanding what we
    *want*, not just what we tell them to do? This is where *programming with intent*
    enters the picture, representing not just a new tool or technique but a fundamental
    reimagining of the developer’s role.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转变挑战了我们关于成为程序员意味着什么的最基本的假设。几代人以来，我们的价值与我们的能力紧密相连，即像机器一样思考——将问题分解成离散的逻辑步骤，让计算机执行。但当机器能够理解我们*想要*什么，而不仅仅是他们被告知做什么时，会发生什么呢？这就是*意图编程*出现的地方，它不仅仅代表了一种新的工具或技术，而是一种对开发者角色的根本性重新构想。
- en: 'Beyond Lines of Code: Programming with Intent'
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越代码行数：意图编程
- en: 'For decades, programming has meant writing instructions: line after line of
    code telling the computer *how* to do something. Each function, loop, and conditional
    had to be carefully crafted by a human. Programming with intent flips this script.
    Instead of focusing on the low-level implementation, the developer focuses on
    the outcome or goal: what you want the program to accomplish. You express that
    intent in a high-level way (often in natural language), and the AI system figures
    out the code to fulfill it.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，编程意味着编写指令：一行又一行的代码告诉计算机*如何*做某事。每个函数、循环和条件都必须由人类精心制作。意图编程翻转了这个剧本。开发者不再关注低级实现，而是关注结果或目标：你希望程序完成什么。你以高级方式（通常是用自然语言）表达这种意图，然后AI系统找出满足它的代码。
- en: 'Think of it this way: traditional coding is like giving someone step-by-step
    directions, while intent-based coding is like telling them your destination and
    letting them figure out the best route. By focusing on the *what* instead of the
    *how*, developers can work at a higher level of abstraction. This approach isn’t
    entirely new—tools like visual programming, low-code platforms, and code generators
    have long promised to raise the abstraction level. But today’s AI advancements
    are finally making it practical to describe complex behaviors in plain language
    and get working code in return.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这样想吧：传统的编码就像给某人提供一步一步的指示，而基于意图的编码就像告诉他们你的目的地，然后让他们找出最佳路线。通过关注*什么*而不是*如何*，开发者可以在更高的抽象级别上工作。这种方法并不完全新颖——像可视化编程、低代码平台和代码生成器这样的工具长期以来都承诺提高抽象级别。但今天的AI进步终于使以普通语言描述复杂行为并得到实际代码成为可能。
- en: 'The Rise of the Prompt: From Instructions to Descriptions'
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提示词的兴起：从指令到描述
- en: 'At the heart of this shift is the humble prompt. A *prompt* is the input or
    question you give to an AI coding system. In essence, it’s a description of what
    you want the program to do rather than an instruction for how to do it. This can
    feel very different from writing code. For example, instead of writing a loop
    to parse a file, you might prompt:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转变的核心是谦逊的提示词。*提示词*是你提供给AI编码系统的输入或问题。本质上，它是对你希望程序做什么的描述，而不是如何做的指令。这可能会感觉与编写代码非常不同。例如，你可能会提示而不是编写一个解析文件的循环：
- en: Read this CSV file and extract the email addresses of all users older than 18.
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 读取这个CSV文件并提取所有18岁以上的用户的电子邮件地址。
- en: The AI will attempt to generate code that accomplishes that description.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: AI将尝试生成完成该描述的代码。
- en: Why is this happening now? The rapid progress of LLMs in understanding and generating
    text, including programming languages, has been a game changer. These AI models
    have been trained on vast amounts of code and natural language text. They can
    interpret a prompt that looks like a description of software behavior and translate
    it into actual code that implements that behavior. In other words, they’ve learned
    the patterns of how humans describe tasks and how those tasks translate into code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么现在会发生这种情况？LLMs在理解和生成文本方面的快速进步，包括编程语言，已经是一个转折点。这些AI模型在大量代码和自然语言文本上进行了训练。它们可以解释看起来像软件行为描述的提示，并将其翻译成实现该行为的实际代码。换句话说，它们已经学会了人类描述任务的模式以及这些任务如何转化为代码。
- en: This rise of prompt-based development means that, as a developer, you increasingly
    write descriptions of features and logic in natural language or pseudocode and
    let the AI handle the heavy lifting of writing syntactically correct code. The
    prompt becomes your new unit of thought. It’s a concise expression of intent.
    We’ve gone from telling the computer, “Do X, then Y, then Z” to saying, “I need
    X, Y, and Z done” and trusting the AI to fill in the blanks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于提示的开发兴起意味着，作为开发者，你越来越多地用自然语言或伪代码来描述功能和逻辑，并让AI处理编写语法正确的代码的繁重工作。提示成为你新的思维单元。它是对意图的简洁表达。我们已从告诉电脑“先做X，然后做Y，接着做Z”转变为说“我需要完成X、Y和Z”，并相信AI会填补空白。
- en: It’s important to note that writing a good prompt is itself a skill (which we’ll
    dive into in [Chapter 3](ch03.html#ch03_the_70_problem_ai_assisted_workflows_that_actual_1752630043200933)).
    A vague prompt can lead to incorrect or inefficient code, just as a vague requirement
    can confuse a human programmer. The better you can articulate your intent in the
    prompt, the better the AI’s output will match your needs. This is why many are
    calling prompt writing the new programming literacy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，编写一个好的提示本身也是一种技能（我们将在[第3章](ch03.html#ch03_the_70_problem_ai_assisted_workflows_that_actual_1752630043200933)中深入探讨）。模糊的提示可能导致错误的或不高效的代码，就像模糊的需求可能会让人类程序员感到困惑一样。你能在提示中更好地表达你的意图，AI的输出就会更好地满足你的需求。这就是为什么许多人称提示编写为新的编程素养。
- en: 'How It Works: The Iterative Cycle and AI’s Role in Code Generation'
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的：迭代周期和AI在代码生成中的作用
- en: 'So how does an AI go from your free-form description to actual, functioning
    code? The magic lies in LLMs’ ability to interpret context and generate text.
    The *large* in “large language model” refers to the number of parameters (the
    internal configuration) it has, often billions or more, which enable it to capture
    the complexities of natural and programming languages. These models have been
    trained on public code repositories, forums, documentation, and Q&A sites, learning
    both the syntax of programming languages and the semantics of how code is used
    to solve problems. When you interact with an AI coder, you’re tapping into this
    expansive learned knowledge. Let’s break it down in simple terms:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，AI是如何从你的自由描述到实际、可运行的代码的呢？魔法在于LLM（大型语言模型）解释上下文和生成文本的能力。“大”在“大型语言模型”中指的是它拥有的参数数量（内部配置），通常是数十亿或更多，这使得它能够捕捉自然语言和编程语言的复杂性。这些模型已经在公共代码存储库、论坛、文档和问答网站上进行了训练，学习编程语言的语法以及代码如何用于解决问题的语义。当你与AI编码器互动时，你正在利用这种广泛的学习知识。让我们用简单的话来分解它：
- en: Understanding the prompt
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 理解提示
- en: When you provide a prompt (for example, “Generate a function that checks if
    a number is prime”), the AI model analyzes the text of that prompt. Modern models
    from Google, OpenAI, and Anthropic have been trained on countless examples of
    language and code, so they use statistical patterns to infer what you’re asking.
    Essentially, the AI tries to *predict* the most likely completion of the prompt
    with code that makes sense.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你提供一个提示（例如，“生成一个检查数字是否为素数的函数”）时，AI模型会分析该提示的文本。来自谷歌、OpenAI和Anthropic的现代模型已经在无数的语言和代码示例上进行了训练，因此它们使用统计模式来推断你提出的问题。本质上，AI试图*预测*提示最可能的代码完成，使其有意义。
- en: Leveraging context
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 利用上下文
- en: These AI systems often take into account additional context beyond just the
    single-line prompt. For instance, if you’re working in an IDE with an AI assistant,
    the model might also consider the current file content, your coding style, comments,
    and even related files. All this context helps the AI generate code that fits
    your project. It’s similar to how a human developer reads surrounding code and
    documentation to understand what to do next.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些AI系统通常还会考虑单行提示之外的其他上下文。例如，如果你在与AI助手一起工作的IDE中工作，模型可能还会考虑当前文件内容、你的编码风格、注释，甚至相关文件。所有这些上下文都有助于AI生成适合你项目的代码。这类似于人类开发者阅读周围的代码和文档来了解下一步该做什么。
- en: Generating code
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 生成代码
- en: Once the model has understood (or at least made a best guess about) your intent,
    it proceeds to generate code.  Under the hood, it does this one token at a time
    (a token is a piece of a word or code symbol) using probabilities learned during
    its training. The model doesn’t “think” in the conventional sense; it doesn’t
    have a compiler or runtime checking the code. It’s simply very good at continuing
    text in a way that has a high chance of being correct code because it has seen
    so many examples before. If the prompt and context are clear, the code it produces
    can be remarkably accurate and even follow best practices it has seen in its training
    data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模型理解了（或至少对您的意图做出了最佳猜测），它就会开始生成代码。在底层，它一次生成一个标记（标记是单词或代码符号的一部分）使用在训练期间学到的概率。模型并不以传统意义上的“思考”来“思考”；它没有编译器或运行时检查代码。它只是非常擅长以高概率继续文本，因为它之前已经看到了很多示例。如果提示和上下文清晰，它产生的代码可以非常准确，甚至可以遵循其在训练数据中看到的最佳实践。
- en: Validating with human oversight
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在人工监督下进行验证
- en: Importantly, the AI doesn’t run off and deploy your application for you. You
    remain in the loop. You review the generated code, test it, and can accept or
    modify it. In many cases, the AI might also offer an explanation of the code if
    asked, helping you understand the result. The AI’s role is like an assistant that
    drafts the code for you—but you, the developer, are still the decision maker who
    ensures the code is correct and fits the project’s needs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，AI不会自行运行并部署您的应用程序。您仍然处于循环中。您审查生成的代码，测试它，并可以接受或修改它。在许多情况下，如果被要求，AI也可能提供代码的解释，帮助您理解结果。AI的角色就像一个为您起草代码的助手——但您，作为开发者，仍然是确保代码正确并符合项目需求的决策者。
- en: What’s truly impressive is that this process happens in seconds or less. The
    high-level overview is that your description (prompt) goes into a prediction engine
    (the LLM), which produces likely code as output. While the inner workings of models
    involve complex math and neural network layers, at the user level, it feels almost
    like collaborating with an expert who can instantly recall how to implement just
    about anything.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 真正令人印象深刻的是，这个过程在几秒钟或更短的时间内完成。高级概述是，您的描述（提示）进入预测引擎（LLM），产生可能的代码作为输出。虽然模型的内部工作涉及复杂的数学和神经网络层，但在用户层面，它几乎感觉就像与一个能够立即回忆起如何实现几乎所有事情的专家合作。
- en: One of the key things to understand about vibe coding (intent-based programming)
    is that it’s an iterative, collaborative process between the human and the AI.
    You don’t just write one perfect prompt and then sit back as the AI writes an
    entire program flawlessly. In practice, you engage in a back-and-forth, a feedback
    loop that gradually takes a vague idea to polished code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于vibe coding（基于意图的编程）的一个关键理解是，它是在人类和AI之间的一种迭代、协作过程。您不仅仅写一个完美的提示，然后坐下来让AI完美地编写整个程序。在实践中，您参与来回交流，一个反馈循环，逐渐将一个模糊的想法转化为精炼的代码。
- en: 'Here’s how a typical cycle might look:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 典型周期可能看起来是这样的：
- en: 'Step 1: You describe what you want'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第1步：您描述您想要的内容
- en: 'This is your initial prompt or request. For example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的初始提示或请求。例如：
- en: Generate a function to calculate monthly loan payments given principal, interest
    rate, and term.
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 生成一个函数，根据本金、利率和期限计算月度贷款还款额。
- en: 'Step 2: AI provides an initial solution'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步：AI提供初始解决方案
- en: The AI generates code for that function, complete with parameters and formula
    for loan payments. It might even include comments explaining the formula.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: AI为该功能生成代码，包括贷款支付的参数和公式。甚至可能包含解释公式的注释。
- en: 'Step 3: You review and test'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步：您审查和测试
- en: 'You look at the code. Does it make sense? Does it handle edge cases? You run
    a quick test: what if the interest rate is 0? Does it behave correctly? You notice
    it might not handle that scenario well.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您查看代码。它有道理吗？它能处理边缘情况吗？您进行快速测试：如果利率为0呢？它表现正确吗？您注意到它可能无法很好地处理这种情况。
- en: 'Step 4: You refine your request or code'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步：您细化您的请求或代码
- en: If the code isn’t perfect (and often it won’t be on the first try), refine it.
    Maybe you prompt the AI again (“Modify the function to handle a 0% interest rate
    gracefully”), or edit the code yourself and tell the AI, “Explain this part,”
    if something is unclear. This guidance helps correct any misunderstandings.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码不完美（而且通常第一次尝试就不会完美），请对其进行细化。也许您再次提示AI（“修改函数以优雅地处理0%利率”），或者自己编辑代码并告诉AI，“解释这部分”，如果有什么不清楚的地方。这种指导有助于纠正任何误解。
- en: 'Step 5: AI refines the solution'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第5步：AI细化解决方案
- en: The AI takes your feedback or new prompt and adjusts the code. Now the function
    checks for zero interest and handles it appropriately.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能接收你的反馈或新的提示，并调整代码。现在函数检查零兴趣并适当地处理它。
- en: 'Step 6: Repeat as needed'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第6步：根据需要重复
- en: You continue this loop until satisfied. Perhaps next you ask the AI to also
    generate unit tests for this function to ensure it works correctly. It does so,
    and you run them to verify all is well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你继续这个循环，直到满意为止。也许接下来你会要求人工智能也为这个函数生成单元测试，以确保它正确工作。它做到了，然后你运行它们以验证一切正常。
- en: 'This collaboration is much like a pair-programming scenario where one partner
    is the human and the other is an AI assistant. The human sets the direction and
    knows the high-level requirements, while the AI offers suggestions, writes boilerplate,
    and speeds up the tedious parts. Neither is effective alone for complex tasks:
    the AI relies on the human for direction and validation, and the human offloads
    some work to the AI to move faster.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种合作类似于一种双人编程场景，其中一方是人类，另一方是人工智能助手。人类设定方向并了解高级需求，而人工智能提供建议、编写模板代码并加快繁琐部分的工作。单独使用任何一方对于复杂任务都是无效的：人工智能依赖人类的方向和验证，而人类将一些工作委托给人工智能以加快速度。
- en: Crucially, the iteration isn’t just about fixing errors; it’s also about evolving
    the solution. You might start with a very rough prompt and then progressively
    refine your intent as you see what the AI produces.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的是，迭代不仅仅是修复错误；它还涉及解决方案的演变。你可能从一个非常粗略的提示开始，然后随着你看到人工智能产生的结果，逐步细化你的意图。
- en: This encourages a mindset of experimentation. If the first attempt isn’t right,
    you haven’t wasted much time—just refine the prompt or tweak the code and try
    again. In traditional coding, writing a module only to throw it away can be frustrating,
    but with AI-generated code, the cost of a false start is low, encouraging exploration
    of different approaches.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这鼓励了一种实验心态。如果第一次尝试不正确，你并没有浪费太多时间——只需细化提示或调整代码再试一次。在传统的编码中，编写一个模块然后丢弃可能会令人沮丧，但有了人工智能生成的代码，错误开始的成本很低，鼓励探索不同的方法。
- en: Productivity, Accessibility, and the Changing Nature of Programming
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产力、可访问性和编程性质的转变
- en: 'Why is programming with intent such a big deal? This shift has several profound
    implications:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有意图的编程如此重要？这种转变有几个深远的影响：
- en: Boosting developer productivity
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 提高开发者生产力
- en: 'Perhaps the most immediate benefit is speed. Developers can accomplish tasks
    faster when the AI handles the rote work. Routine code that might take hours to
    write by hand (like setting up database models, API endpoints, or data cleaning
    scripts) can often be generated in minutes. Early studies on AI coding assistants
    back this up: developers using tools like GitHub Copilot have been shown to complete
    tasks significantly faster ([one study](https://oreil.ly/4Ksmy) found a 55% time
    reduction on a given task with Copilot assistance). When you multiply these gains
    across an entire project, it hints at a future where software development cycles
    shorten dramatically and teams can iterate more quickly.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的好处可能是速度。当人工智能处理常规工作时，开发者可以更快地完成任务。可能需要手动编写数小时才能完成的常规代码（如设置数据库模型、API端点或数据清洗脚本）通常可以在几分钟内生成。早期对人工智能编码助手的研究证实了这一点：使用GitHub
    Copilot等工具的开发者已经显示出完成任务速度显著提高（[一项研究](https://oreil.ly/4Ksmy)发现，在有Copilot辅助的情况下，某个特定任务的时间减少了55%）。当你将这些收益乘以整个项目时，它预示着一个未来，其中软件开发周期将大大缩短，团队可以更快地迭代。
- en: Keeping developers “in the flow”
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让开发者“保持流畅”
- en: Beyond raw speed, there’s a psychological benefit. Writing boilerplate or looking
    up syntax can break a programmer’s flow and train of thought. With an AI handling
    many of those interruptions, developers can stay focused on the problem they’re
    solving. [Many users report](https://oreil.ly/inQHR) that with AI help, they feel
    less frustrated by tedious tasks and can concentrate on the creative and design
    aspects of coding. In other words, it can make coding more enjoyable by offloading
    the boring parts, which in turn can improve the quality of the work (a happier
    coder often produces better code).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了原始速度之外，还有心理上的好处。编写模板代码或查找语法可能会打断程序员的流畅性和思维流程。有了人工智能处理许多这些中断，开发者可以专注于他们正在解决的问题。[许多用户报告](https://oreil.ly/inQHR)说，有了人工智能的帮助，他们感到不那么受繁琐任务的困扰，可以专注于编码的创造性和设计方面。换句话说，它可以通过卸载无聊的部分来使编码更加愉快，这反过来可以提高工作的质量（快乐的程序员往往能写出更好的代码）。
- en: Lowering the barrier to entry
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 降低入门门槛
- en: Programming has traditionally required learning the exacting grammar of code
    and the quirks of various libraries and frameworks. With intent-based programming,
    some of that burden shifts to the AI. A newcomer might not remember the exact
    syntax to open a file or the parameters of a graphing function, but if they can
    describe what they want, the AI can fill in those details. This doesn’t mean anyone
    can code complex systems with zero knowledge (you still need to understand what
    the program should do), but it does mean that the ramp-up to producing useful
    results is shorter. It’s conceivable that domain experts (like a biologist or
    an economist) could write prototypes in their field by describing their needs,
    even if they’re not professional developers. In this sense, programming becomes
    more accessible to people who have the ideas and intent but not deep coding skills.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的编程需要学习代码的严谨语法以及各种库和框架的怪癖。在基于意图的编程中，一些负担转移到了AI身上。新手可能记不住打开文件的确切语法或绘图函数的参数，但如果他们能描述他们想要的内容，AI就能填补这些细节。这并不意味着任何人都可以在没有知识的情况下编写复杂的系统（你仍然需要理解程序应该做什么），但这确实意味着产生有用结果的时间缩短了。可以想象，领域专家（如生物学家或经济学家）可以通过描述他们的需求来编写他们领域的原型，即使他们不是专业的开发者。从这个意义上说，编程对那些有想法和意图但没有深厚编码技能的人变得更加容易接近。
- en: Changing developer roles and skills
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者角色和技能的改变
- en: As AI takes on more code generation, the role of the human developer evolves.
    Skills like architectural design, problem decomposition, and validation become
    even more important. You might find yourself spending more time deciding *what*
    to build and reviewing *why* the code works (or doesn’t) than typing out the syntax.
    The nature of “knowing how to code” may shift toward “knowing how to get the AI
    to code.” This could democratize certain aspects of software development while
    also elevating the level at which professionals operate. We’ll likely see new
    best practices centered around how to effectively guide AI (a topic I’ll introduce
    in [Chapter 3](ch03.html#ch03_the_70_problem_ai_assisted_workflows_that_actual_1752630043200933)
    and revisit throughout the book).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 随着人工智能在代码生成方面的应用越来越广泛，人类开发者的角色也在不断演变。像架构设计、问题分解和验证这样的技能变得更加重要。你可能会发现自己花更多的时间在决定**要构建什么**以及审查**代码为什么能工作（或不能工作**）上，而不是在编写语法。"知道如何编码"的本质可能转向"知道如何让AI进行编码"。这可能会使软件开发的一些方面实现民主化，同时也会提升专业人士操作的水平。我们可能会看到围绕如何有效地引导AI（我将在[第三章](ch03.html#ch03_the_70_problem_ai_assisted_workflows_that_actual_1752630043200933)中介绍这一主题，并在整本书中回顾）的新最佳实践。
- en: Productivity versus creativity
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 生产力与创造力
- en: Interestingly, as AI handles more routine coding, human developers can focus
    on higher-level creative tasks like refining the user experience, brainstorming
    new features, or tackling tricky algorithmic problems that AI might not solve
    well on its own. In this ideal scenario, the AI increases productivity on the
    repetitive 80% of coding, freeing your mental energy for the inventive 20%. It’s
    a shift in how we allocate our effort.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，随着AI处理越来越多的常规编码，人类开发者可以专注于更高层次的创造性任务，如改进用户体验、头脑风暴新功能或解决AI可能无法独立解决的棘手算法问题。在这个理想场景中，AI提高了重复性80%的编码生产力，释放了你的脑力，用于创新性的20%。这是我们在分配精力方面的转变。
- en: 'However, it’s not all rainbows and sunshine. This new style of development
    also raises challenges:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非一切尽善尽美。这种新的开发方式也带来了挑战：
- en: Trust and correctness
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 信任与正确性
- en: Can you trust the code an AI writes? If you don’t see every line, there’s a
    risk of mistakes going unnoticed. Developers need to thoroughly test and review
    AI-generated code. The onus is on the human to ensure the output is correct, secure,
    and efficient. Blindly trusting AI output is risky, as we’ll discuss.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你能信任AI编写的代码吗？如果你没有看到每一行，可能会出现错误被忽视的风险。开发者需要彻底测试和审查AI生成的代码。确保输出正确、安全、高效的责任在于人类。盲目信任AI输出是有风险的，我们将在后面讨论。
- en: Losing some low-level skills
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 失去一些低级技能
- en: If you rely on AI for routine coding, will you gradually lose your ability to
    write that code from scratch or debug issues deep in the weeds? It’s a concern
    akin to overreliance on calculators weakening arithmetic skills. Developers will
    need to consciously balance convenience with maintaining a solid understanding
    of the fundamentals.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你依赖AI进行常规编码，你是否会逐渐失去从头编写代码或调试深层问题的能力？这是一个类似于过度依赖计算器削弱算术技能的担忧。开发者需要有意识地平衡便利性与保持对基础知识的牢固理解。
- en: Shifting job landscape
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 职业景观的变化
- en: As programming with intent becomes widespread, the industry might value different
    skills. There may be less demand for people who are good at just cranking out
    boilerplate logic, and more demand for those who can design systems, integrate
    components, and verify correctness. The nature of software jobs could shift, with
    AI handling more implementation and humans focusing on design and oversight.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 随着有意图的编程变得普遍，行业可能会重视不同的技能。对于仅仅擅长生成样板逻辑的人来说，需求可能会减少，而对于能够设计系统、集成组件和验证正确性的人来说，需求可能会增加。软件工作的性质可能会发生变化，人工智能将处理更多实现工作，而人类则专注于设计和监督。
- en: Additionally, one of the most critical factors in “vibe coding” is context window
    size. Gemini offers the longest context window of all AI models, which can be
    game changing when working with large projects. Some models now support context
    windows of over a million tokens, allowing them to maintain awareness of entire
    applications. Developers can feed entire codebases to an AI for comprehensive
    understanding.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，“感觉编码”中最关键的因素之一是上下文窗口大小。Gemini 提供了所有人工智能模型中最长的上下文窗口，这在处理大型项目时可能具有颠覆性的影响。一些模型现在支持超过一百万个标记的上下文窗口，这使得它们能够保持对整个应用程序的意识。开发者可以将整个代码库输入人工智能以获得全面的理解。
- en: We’ll delve into these trade-offs more at the end of the chapter. But first,
    let’s familiarize ourselves with the emerging tools that enable this new way of
    coding.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章末尾更深入地探讨这些权衡。但首先，让我们熟悉一下使这种新的编码方式成为可能的新兴工具。
- en: 'A Glimpse of the Tools: The Emerging Ecosystem'
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具的概览：新兴生态系统
- en: Vibe coding may be a philosophy, but it’s enabled by a new generation of AI-powered
    tools. Experienced developers who want to embrace this workflow will need to get
    acquainted with some key platforms and models that make AI-assisted coding effective.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 感觉编码可能是一种哲学，但它是由新一代人工智能工具所实现的。想要拥抱这种工作流程的资深开发者需要熟悉一些关键平台和模型，这些平台和模型使得人工智能辅助编码变得有效。
- en: This section is a quick tour of the essential tools in the vibe coder’s toolkit.
    These include Visual Studio Code (VSCode) with its growing ecosystem of AI features
    and extensions, next-gen AI-integrated IDEs like Cursor and Windsurf, LLMs like
    Claude (in its various versions), and ChatGPT. This section does not cover background
    coding agents, but I discuss them in detail in [Chapter 10](ch10.html#ch10_autonomous_background_coding_agents_1752630045087844).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是对感觉编码者工具箱中基本工具的快速浏览。这些工具包括拥有日益增长的 AI 功能和扩展的 Visual Studio Code (VSCode)，下一代人工智能集成
    IDE 如 Cursor 和 Windsurf，以及 Claude（其各种版本）和 ChatGPT。本节不涵盖背景编码代理，但我将在第 10 章（ch10.html#ch10_autonomous_background_coding_agents_1752630045087844）中详细讨论它们。
- en: As you read this section, don’t worry about memorizing specific tool names or
    features; the landscape is evolving fast. The goal is to understand the types
    of solutions available.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本节时，不必担心记住特定的工具名称或功能；这个领域正在快速发展。目标是了解可用的解决方案类型。
- en: 'VSCode + Copilot: Microsoft’s Integrated AI Development Platform'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VSCode + Copilot：微软的集成人工智能开发平台
- en: '[VSCode](https://code.visualstudio.com) has transformed from the world’s most
    popular code editor into a comprehensive AI-assisted development platform through
    its deep integration with GitHub Copilot. This evolution represents Microsoft’s
    vision for keeping AI capabilities within the familiar VSCode environment that
    millions of developers already use daily.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[VSCode](https://code.visualstudio.com) 通过与 GitHub Copilot 的深度集成，已经从世界上最受欢迎的代码编辑器转变为一个综合的人工智能辅助开发平台。这种演变代表了微软将人工智能能力保持在熟悉的环境中的愿景，这个环境是数百万开发者每天都在使用的。'
- en: GitHub Copilot is an AI-powered coding assistant integrated into VSCode. It
    provides code suggestions, explanations, and automated implementations based on
    natural language prompts and existing code context. What sets this integration
    apart is its seamless nature—Copilot isn’t just an add-on but feels like a natural
    extension of the editor itself.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Copilot 是一个集成到 VSCode 中的人工智能编码助手。它根据自然语言提示和现有代码上下文提供代码建议、解释和自动实现。这种集成与众不同的地方在于其无缝性——Copilot
    不仅仅是一个附加组件，它感觉像是编辑器本身的自然扩展。
- en: The core of VSCode’s AI capabilities centers on three main modes of interaction.
    First, there’s *inline code autocompletion*, where Copilot provides inline code
    suggestions as you type, ranging from single-line completions to entire function
    implementations. As you write code, ghost text appears with suggestions that you
    can accept with Tab or partially accept word by word.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: VSCode的AI能力核心集中在三种主要的交互模式。首先，是*内联代码自动补全*，Copilot在你键入时提供内联代码建议，从单行补全到整个函数实现。随着你编写代码，会出现带有建议的幽灵文本，你可以使用Tab键接受建议，或者逐字部分接受建议。
- en: Second, there’s the *chat interface*, accessible through a sidebar panel where
    you can have conversations about your code, ask questions, or request specific
    implementations. Third, and perhaps most powerful, is the *agent mode* that uses
    tool calling to access a growing set of capabilities inside Visual Studio. When
    given a goal, it selects and executes the right tools step-by-step. This agent
    mode can analyze your codebase, propose edits across multiple files, run terminal
    commands, respond to build errors, and self-correct in a loop until the task is
    completed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，是可访问的*聊天界面*，通过侧边栏面板进入，你可以就你的代码进行对话，提问，或请求特定的实现。第三，也许是最强大的，是*代理模式*，它通过工具调用访问Visual
    Studio内部不断增长的功能集。当给定一个目标时，它会逐步选择并执行正确的工具。这种代理模式可以分析你的代码库，在多个文件中提出编辑建议，运行终端命令，响应构建错误，并在循环中自我纠正，直到任务完成。
- en: What makes VSCode’s Copilot implementation particularly compelling is its support
    for the Model Context Protocol (MCP). MCP provides a standardized way for AI models
    to discover and interact with external tools, applications, and data sources.
    This means Copilot in VSCode can connect to databases, invoke APIs, access documentation,
    and integrate with your entire development ecosystem. For instance, with the GitHub
    MCP server enabled, you can ask Copilot to “create an issue for each bug we discussed,”
    and it will interact directly with GitHub’s API to create those issues. The extensibility
    through MCP transforms Copilot from a code generator into a comprehensive development
    assistant that understands not just your code but your entire workflow.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使VSCode的Copilot实现特别吸引人的是它对模型上下文协议（MCP）的支持。MCP为AI模型提供了一种标准化的方式来发现和交互外部工具、应用程序和数据源。这意味着VSCode中的Copilot可以连接到数据库，调用API，访问文档，并集成到你的整个开发生态系统中。例如，启用GitHub
    MCP服务器后，你可以要求Copilot“为每个我们讨论的bug创建一个issue”，它将直接与GitHub的API交互以创建这些issue。通过MCP的可扩展性，Copilot从代码生成器转变为一个全面的发展助手，它不仅理解你的代码，还理解你的整个工作流程。
- en: To leverage VSCode with Copilot effectively in professional development, start
    by exploring the different interaction modes based on your task complexity. For
    simple code completions and refactoring, rely on the inline suggestions and the
    sparkle icon that appears near errors—click it for AI-powered fixes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要在专业开发中有效地利用VSCode与Copilot，首先根据任务复杂度探索不同的交互模式。对于简单的代码补全和重构，依赖于内联建议和出现在错误附近的闪烁图标——点击它以获取AI驱动的修复。
- en: For more complex tasks, switch to agent mode by opening the chat panel and selecting
    “Agent” from the drop-down. Agent mode is optimized for making autonomous edits
    across multiple files in your project. It is particularly useful for complex tasks
    that require not only code edits but also the invocation of tools and terminal
    commands. The combination of VSCode’s familiar interface with Copilot’s evolving
    AI capabilities offers a compelling option for teams that want enterprise-grade
    AI assistance without leaving their established development environment.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的任务，通过打开聊天面板并从下拉菜单中选择“代理”来切换到代理模式。代理模式针对在项目中的多个文件上进行自主编辑进行了优化。它特别适用于需要不仅代码编辑，还需要调用工具和终端命令的复杂任务。VSCode熟悉的界面与Copilot不断发展的AI能力的结合，为希望在不离开既定开发环境的情况下获得企业级AI辅助的团队提供了一个有吸引力的选择。
- en: 'VSCode + Cline: The Open Source Autonomous Coding Agent'
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VSCode + Cline：开源自主编码代理
- en: Before exploring purpose-built AI IDEs, it’s worth examining how [Cline](https://cline.bot)
    (formerly Claude Dev) transforms VSCode into a powerful AI-assisted development
    environment. Cline represents a different philosophy from Microsoft’s Copilot.
    Rather than being a tightly integrated assistant, it functions as an autonomous
    coding agent that can take on complex, multistep development tasks from start
    to finish. This open source extension brings capabilities to VSCode that often
    exceed those found in proprietary AI editors, all while maintaining the flexibility
    and extensibility that VSCode users expect.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索专为 AI 设计的 IDE 之前，值得考察 [Cline](https://cline.bot)（以前称为 Claude Dev）如何将 VSCode
    转变为强大的 AI 辅助开发环境。Cline 代表了一种与微软的 Copilot 不同的哲学。它不是作为一个紧密集成的助手，而是一个可以承担从开始到结束的复杂、多步骤开发任务的自主编码代理。这个开源扩展为
    VSCode 带来了通常在专有 AI 编辑器中找不到的功能，同时保持了 VSCode 用户期望的灵活性和可扩展性。
- en: What distinguishes Cline is its truly agentic approach to software development.
    When you give Cline a high-level request like “Create a REST API for user management
    with authentication,” it doesn’t simply generate boilerplate code. Instead, it
    analyzes your project structure, plans the implementation across multiple files,
    creates proper folder hierarchies, installs necessary dependencies, and can even
    run tests to verify the implementation. Throughout this process, Cline maintains
    transparency by showing you each planned action—file creations, modifications,
    and terminal commands—and giving you the opportunity to approve or modify each
    step. This *human-in-the-loop* design provides the perfect balance between automation
    and control, allowing developers to leverage AI’s capabilities while maintaining
    oversight of their codebase.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Cline 的独特之处在于其对软件开发真正代理式的方法。当您给 Cline 一个高级请求，例如“创建一个具有身份验证功能的用户管理 REST API”，它不仅仅生成样板代码。相反，它会分析您的项目结构，跨多个文件规划实现，创建适当的文件夹层次结构，安装必要的依赖项，甚至可以运行测试以验证实现。在整个过程中，Cline
    通过显示每个计划的操作——文件创建、修改和终端命令——并给您机会批准或修改每个步骤来保持透明度。这种 *人工在环* 设计在自动化和控制之间提供了完美的平衡，允许开发者利用
    AI 的能力，同时保持对其代码库的监督。
- en: Cline’s technical capabilities extend far beyond code generation. It can use
    *browser automation* to research API documentation, debug complex issues by analyzing
    error traces across multiple files, and even interact with external services through
    its MCP support. For debugging, you can paste an error message, and Cline will
    trace through your codebase to identify the root cause, propose a fix, implement
    it, and add appropriate error handling to prevent similar issues. Its MCP integration
    means Cline can connect to your database to understand schemas before generating
    queries, access your project management tools to align implementations with requirements,
    or interact with any other MCP-compatible service. This extensibility transforms
    Cline from a code generator into a comprehensive development partner that understands
    your entire technical ecosystem.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Cline 的技术能力远不止代码生成。它可以利用 *浏览器自动化* 来研究 API 文档，通过分析多个文件中的错误跟踪来调试复杂问题，甚至可以通过其 MCP
    支持与外部服务进行交互。对于调试，您可以粘贴错误消息，Cline 将遍历您的代码库以确定根本原因，提出修复方案，实施修复，并添加适当的错误处理以防止类似问题。其
    MCP 集成意味着 Cline 可以连接到您的数据库以理解架构，在生成查询之前，访问您的项目管理工具以使实现与需求保持一致，或与任何其他 MCP 兼容的服务进行交互。这种可扩展性将
    Cline 从代码生成器转变为全面的发展伙伴，它了解您的整个技术生态系统。
- en: For teams, Cline offers several compelling advantages. Being open source, teams
    can inspect its code, contribute improvements, or fork it for custom needs—crucial
    for organizations with specific security or compliance requirements. It supports
    multiple AI providers including Anthropic’s Claude, OpenAI’s models, Google’s
    Gemini, and even local models through Ollama, giving teams flexibility in model
    selection based on performance, cost, or data residency requirements.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于团队来说，Cline 提供了几个令人信服的优势。作为开源软件，团队可以检查其代码，贡献改进，或根据定制需求进行分支——这对于具有特定安全或合规性要求的组织至关重要。它支持多个
    AI 提供商，包括 Anthropic 的 Claude、OpenAI 的模型、Google 的 Gemini，甚至可以通过 Ollama 使用本地模型，这为团队提供了根据性能、成本或数据驻留要求进行模型选择的灵活性。
- en: To use Cline effectively, craft detailed prompts that include project context
    and constraints, leverage its ability to analyze your entire codebase before making
    changes, and take advantage of its iterative development capabilities. After Cline
    implements a feature, you can immediately test it and request refinements in the
    same conversation context. The combination of VSCode’s mature ecosystem with Cline’s
    autonomous capabilities offers teams a powerful, flexible, and cost-effective
    path to AI-assisted development without abandoning their existing tools and workflows.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要有效地使用 Cline，请创建包含项目上下文和约束条件的详细提示，利用其分析您整个代码库的能力在做出更改之前，并利用其迭代开发功能。Cline 实现一个功能后，您可以立即测试它，并在相同的对话上下文中请求改进。将
    VSCode 的成熟生态系统与 Cline 的自主能力相结合，为团队提供了一条强大、灵活且成本效益高的 AI 辅助开发路径，而无需放弃他们现有的工具和工作流程。
- en: 'Cursor: The AI-Driven Code Editor'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cursor：AI 驱动的代码编辑器
- en: One of the flagship tools of the vibe-coding movement is Cursor, an AI-enhanced
    IDE that has quickly gained popularity among developers seeking a more fluid coding
    experience. Cursor is essentially an AI-first code editor (a fork of VSCode, in
    fact) that builds state-of-the-art code generation and understanding right into
    your development environment.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 感觉编码运动的旗舰工具之一是 Cursor，这是一个增强型 IDE，它迅速在寻求更流畅编码体验的开发者中获得了人气。Cursor 实质上是一个以 AI
    为首的代码编辑器（实际上是 VSCode 的分支），它将最先进的代码生成和理解直接构建到您的开发环境中。
- en: Its tagline is “The AI Code Editor,” and it’s designed to let you write and
    modify code using plain language instructions. For example, you can highlight
    a function and ask Cursor to “optimize this function” or “add error handling here,”
    and it will instantly suggest the code changes. Cursor’s AI is project-aware—it
    indexes your codebase and understands the context of your files, so it can make
    more relevant suggestions (far beyond a simple autocomplete). Cursor IDE integrates
    LLM capabilities into its core interface. It’s ChatGPT that knows your codebase.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它的标语是“AI 代码编辑器”，它旨在让您使用简单的语言指令编写和修改代码。例如，您可以突出显示一个函数并要求 Cursor“优化此函数”或“在此处添加错误处理”，它将立即建议代码更改。Cursor
    的 AI 能够识别项目——它索引您的代码库并理解您文件的上下文，因此可以提出更相关的建议（远超简单的自动完成）。Cursor IDE 将 LLM 功能集成到其核心界面中。它是了解您代码库的
    ChatGPT。
- en: Under the hood, Cursor leverages advanced language models (often Anthropic’s
    Claude or OpenAI’s models, depending on your setup) to power its features. It
    has a chat sidebar where you can have conversations about your code, and even
    a “Composer” mode for multistep code generation. Andrej Karpathy himself has used
    Cursor’s Composer with a model called “Sonnet” in his [vibe-coding experiments](https://oreil.ly/aFqAO).
    This setup allowed him to literally *talk* to the editor (using voice-to-text
    via “SuperWhisper”) and have code appear, which he would then accept or refine.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，Cursor 利用先进的语言模型（根据您的设置，通常是 Anthropic 的 Claude 或 OpenAI 的模型）来驱动其功能。它有一个聊天侧边栏，您可以在其中就您的代码进行对话，甚至还有一个用于多步代码生成的“作曲家”模式。安德烈·卡帕西本人就曾使用
    Cursor 的“作曲家”模式，配合名为“Sonnet”的模型进行他的[vibe-coding 实验](https://oreil.ly/aFqAO)。这种设置使他能够真正地“说话”（通过“SuperWhisper”的语音到文本功能）并与编辑器交流，代码随即出现，然后他会接受或改进。
- en: 'Cursor can not only generate code but also *edit existing code* when instructed.
    For example, you can ask:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Cursor 不仅能够生成代码，还可以根据指令*编辑现有代码*。例如，您可以要求：
- en: Could you make it easier to switch certificates in the transport listener?
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 能否使在传输监听器中切换证书更容易？
- en: Cursor will understand you’re referring to your code and propose direct edits
    in the relevant file or read from relevant files, such as a specification markdown
    file (see [Figure 1-3](#ch01_figure_3_1752630042312486)). In the free version,
    it often provides the diff in the chat for you to approve; in the pro version,
    it can auto-apply changes to your workspace.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Cursor 会理解您正在引用您的代码，并会在相关文件中提出直接编辑建议或从相关文件中读取，例如规范 Markdown 文件（见[图 1-3](#ch01_figure_3_1752630042312486)）。在免费版本中，它通常会提供差异比较供您批准；在专业版本中，它可以将更改自动应用到您的开发环境中。
- en: '![](assets/bevc_0103.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/bevc_0103.png)'
- en: Figure 1-3\. Cursor’s interface exemplifies the newer breed of IDEs integrating
    AI. By indexing your project and iterating on prompts, tools like Cursor enable
    “leaving your editor running, grabbing coffee, and coming back to fully working
    features,” delivering exponential productivity gains.
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-3\. Cursor 的界面展示了将 AI 集成到 IDE 中的新一代。通过索引您的项目并对提示进行迭代，Cursor 等工具能够“让您的编辑器持续运行，去拿咖啡，回来时发现功能已经完全可用”，从而带来指数级的生产力提升。
- en: 'To use Cursor effectively in a professional workflow, you should take advantage
    of its capabilities systematically. Start by opening a chat in Cursor and describe
    the feature or fix you want. For instance: add a user login form with email and
    password, including validation and error messages. Cursor will generate the needed
    code (creating new files or modifying existing ones) in a draft state. You can
    review these changes (it shows a diff or preview) and then hit “Apply” to merge
    them into your codebase. Many developers follow this loop: prompt → review → accept.
    If the suggestion isn’t perfect, you can refine your prompt (for instance, “Use
    Tailwind CSS for styling the form”) or just ask Cursor to fix any issues you spot
    (“Now, handle the case where the email is already registered”). In essence, you
    converse with your code until it looks good.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要在专业工作流程中有效地使用Cursor，你应该系统地利用其功能。首先，在Cursor中打开一个聊天窗口，描述你想要的功能或修复。例如：添加一个带有电子邮件和密码的用户登录表单，包括验证和错误信息。Cursor将以草稿状态生成所需的代码（创建新文件或修改现有文件）。你可以审查这些更改（显示差异或预览），然后点击“应用”将它们合并到你的代码库中。许多开发者遵循这个循环：提示
    → 审查 → 接受。如果建议不完美，你可以细化你的提示（例如，“使用Tailwind CSS来设置表单样式”）或者直接要求Cursor修复你发现的问题（“现在，处理电子邮件已注册的情况”）。本质上，你与你的代码进行对话，直到它看起来很好。
- en: 'Cursor also excels at understanding errors and logs. If you run your code and
    get a traceback or error message, you can paste it into the Cursor chat, and often
    the AI will analyze it and suggest a fix. This turns debugging into a [cooperative
    experience](https://oreil.ly/aFqAO): rather than you manually searching Google
    or Stack Overflow, Cursor’s AI can often pinpoint the problem and even write the
    patch. That said, it’s wise to verify the fixes, as the AI might not always get
    it right on the first try.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Cursor在理解错误和日志方面也表现出色。如果你运行代码并得到跟踪回溯或错误消息，你可以将其粘贴到Cursor聊天中，通常AI会分析它并提出修复建议。这使调试成为一个[协作体验](https://oreil.ly/aFqAO)：而不是你手动搜索Google或Stack
    Overflow，Cursor的AI通常可以定位问题，甚至编写补丁。但话说回来，验证修复是明智的，因为AI可能不会在第一次尝试时就完全正确。
- en: 'Another pro tip: use Cursor’s ability to take multiple files into account.
    You can select a set of files (or let it know about project context in the prompt)
    so that it considers your whole codebase when generating code. For example: add
    a new API endpoint in the backend to support the login form, and connect it to
    the frontend form we just made. Cursor will recall the frontend code it just wrote
    and help craft the corresponding backend logic. This project-wide context is a
    game changer compared to earlier coding assistants that only worked file by file.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个专业技巧：使用Cursor的多文件处理能力。你可以选择一组文件（或者在提示中告知项目上下文），这样它在生成代码时会考虑你的整个代码库。例如：在后端添加一个新的API端点以支持登录表单，并将其连接到我们刚刚创建的前端表单。Cursor将回忆起它刚刚编写的代码，并帮助构建相应的后端逻辑。与早期仅按文件工作的编码助手相比，这种项目级上下文是一个变革性的变化。
- en: 'In summary, Cursor is like having an AI pair programmer *inside* your IDE,
    24/7\. It’s intuitive (you chat with it in plain language), and it can update
    your code directly. The more you practice breaking down tasks and prompting Cursor
    with clear instructions, the more you’ll find you can accomplish in a short time.
    It’s particularly great for iterative development: you build a bit, run and see
    output, then immediately ask Cursor to adjust or extend the code, and repeat.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Cursor就像在你的IDE中拥有一个全天候的AI配对程序员。它是直观的（你可以用普通语言与之聊天），并且可以直接更新你的代码。你越练习分解任务并用清晰的指令提示Cursor，你就能在短时间内完成更多的事情。它特别适合迭代开发：你构建一小部分，运行并查看输出，然后立即要求Cursor调整或扩展代码，并重复。
- en: 'Windsurf: An AI-Powered IDE with Full Codebase Indexing'
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 风帆冲浪：一个具有完整代码库索引的AI驱动IDE
- en: Another rising star in the vibe-coding toolbox is Windsurf, an AI-driven development
    environment that takes code understanding to the next level. Windsurf is built
    by [the team behind Codeium](https://windsurf.com), and it differentiates itself
    by indexing your entire codebase and using retrieval techniques to feed the relevant
    pieces to the AI model as you work. In practical terms, this means Windsurf is
    extremely good at handling large projects where the answer to your question might
    be spread across many files. Its core uses something called *retrieval-augmented
    generation* (RAG), which is a fancy way of saying it looks up the parts of your
    code that are relevant to your prompt and provides that context to the AI so that
    its suggestions are consistent with your existing code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在vibe-coding工具箱中冉冉升起的新星是Windsurf，这是一个AI驱动的开发环境，将代码理解提升到了新的水平。Windsurf是由[Codeium背后的团队](https://windsurf.com)开发的，它通过索引你的整个代码库并使用检索技术在工作时将相关部分输送到AI模型来区分自己。从实际的角度来看，这意味着Windsurf在处理大型项目时非常出色，其中问题的答案可能分布在许多文件中。它的核心使用一种称为*检索增强生成*（RAG）的技术，这是一种更高级的说法，即它会查找与你的提示相关的代码部分，并将这些上下文提供给AI，以便其建议与你的现有代码保持一致。
- en: 'What does this look like for a developer? Let’s say you’re new to a big codebase
    and need to add a feature. With Windsurf, you can ask in natural language:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这对开发者来说意味着什么？假设你是一个新加入的大型代码库的开发者，需要添加一个功能。使用Windsurf，你可以用自然语言提问：
- en: Where in the codebase is the user authentication logic handled?
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在代码库中用户认证逻辑是在哪里处理的？
- en: 'It will search through the index and point you to the right file or even function.
    Then, you might open a chat (Windsurf calls it the “Cascade” view, triggered by
    Cmd+L) and say:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 它会搜索索引并指向正确的文件或甚至函数。然后，你可能会打开一个聊天（Windsurf称之为“Cascade”视图，通过Cmd+L触发）并说：
- en: Add a phone-based two-factor authentication to the login flow.
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在登录流程中添加基于电话的双因素认证。
- en: Because Windsurf has the context of your auth logic, it can generate changes
    spanning multiple files (database, API, frontend) to implement this, making informed
    choices that line up with how your system is structured.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Windsurf有你的认证逻辑上下文，它可以生成跨越多个文件（数据库、API、前端）的更改来实现这一点，做出与你的系统结构一致的有信息量的选择。
- en: 'Windsurf’s Write mode can boldly apply changes for you: it will create new
    files or edit existing ones automatically rather than just suggesting diffs in
    a sidebar. This can be a huge time-saver: instead of copy-pasting from suggestions,
    you see your project evolving in place. Windsurf essentially tries to take actions
    on your behalf when it’s confident, behaving like an autonomous junior dev implementing
    features across the codebase. (Cursor’s philosophy is a bit more conservative,
    asking for confirmation, although its Pro version has an “auto-apply” feature
    too.)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Windsurf的写模式可以大胆地为你应用更改：它会自动创建新文件或编辑现有文件，而不是仅仅在侧边栏中建议差异。这可以节省大量时间：你不需要从建议中复制粘贴，而是看到你的项目在原地演变。Windsurf本质上试图在你有信心时代表你采取行动，表现得像一个在代码库中实现功能的自主初级开发者。（Cursor的哲学稍微保守一些，会要求确认，尽管其Pro版本也有“自动应用”功能。）
- en: 'To leverage Windsurf effectively, it helps to understand its strengths:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地利用Windsurf，了解其优势很有帮助：
- en: Codebase Q&A
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库问答
- en: You can query your codebase in plain English, almost like a custom Stack Overflow
    for your project. This is great for large legacy projects where finding where
    something is defined can take hours. Windsurf will answer in seconds by pulling
    from the indexed code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用纯英文查询你的代码库，几乎就像是你项目的定制版Stack Overflow。这对于大型遗留项目来说非常棒，因为找到某个定义可能需要几个小时。Windsurf会通过从索引的代码中提取信息，在几秒钟内给出答案。
- en: Global context suggestions
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 全局上下文建议
- en: Because it feeds relevant files into the model, Windsurf can handle tasks like
    “Refactor the payment module to use the new logging utility we wrote” very well,
    as it knows about both the payment module and the logging utility.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它将相关文件输入到模型中，Windsurf可以很好地处理像“重构支付模块以使用我们编写的新的日志工具”这样的任务，因为它了解支付模块和日志工具。
- en: Modes of operation
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 操作模式
- en: Windsurf has multiple modes (Autocomplete, Chat, Command, and Cascade, as mentioned).
    The Cascade is like a superchat, where it can consider a broader context. The
    Write mode (within chat) actually executes changes. You, as the engineer, can
    decide how much autonomy to give it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Windsurf有多个模式（自动完成、聊天、命令和Cascade，如前所述）。Cascade就像是一个超级聊天，它可以考虑更广泛的环境。在聊天中的写模式实际上会执行更改。作为工程师的你，可以决定给它多少自主权。
- en: For a team, Windsurf can be integrated into daily development much like Cursor.
    When picking between them, some developers prefer Windsurf for its speed and boldness
    (noting that it feels faster to generate and apply changes) and for working with
    very large projects due to its indexing. On the other hand, Cursor’s interface
    might feel more familiar to VSCode users. It’s not necessarily an either/or choice—some
    engineers keep both handy, or teams might standardize on one.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于团队来说，Windsurf可以像Cursor一样集成到日常开发中。在选择它们之间时，一些开发者更喜欢Windsurf的速度和大胆（指出它生成和应用更改感觉更快），以及由于其索引而能够处理非常大的项目。另一方面，Cursor的界面可能对VSCode用户来说更熟悉。这并不一定是一个非此即彼的选择——一些工程师两者都备有，或者团队可能会标准化使用其中一个。
- en: In sum, Windsurf is an excellent tool if you want an AI coding assistant that
    truly “reads the docs/code” before writing. It minimizes the chances of hallucinated
    functions or misnamed variables because it can look things up. To get the most
    out of it, feed it clear instructions and let it rip in Write mode for big tasks,
    but also feel free to use it in a more controlled fashion for delicate changes.
    Always review the changes it makes (it will show them to you), especially for
    critical code. Windsurf is smart, but it’s not infallible. Used wisely, it’s like
    a hyperintelligent IDE that knows your entire project and can implement ideas
    across it, giving a serious boost to your throughput.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，如果你想要一个在编写代码前真正“阅读文档/代码”的AI编码助手，Windsurf是一个出色的工具。因为它可以查找信息，所以它最小化了产生幻觉功能或误命名的变量的可能性。为了充分利用它，提供清晰的指令，并在写模式下让它处理大型任务，但也请随意以更受控的方式使用它进行细微调整。始终审查它所做的更改（它会向您展示），特别是对于关键代码。Windsurf很聪明，但并非完美无缺。明智地使用它，就像一个了解您整个项目的超智能IDE，可以在其中实现想法，从而大大提高您的效率。
- en: 'AI Models: The Landscape for Code Generation'
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能模型：代码生成的领域
- en: The AI coding landscape has transformed dramatically, with multiple powerful
    models now competing for developers’ attention, including models from the Claude,
    Gemini, and OpenAI families. Where once a single model might have dominated, today’s
    ecosystem offers a rich selection of options, each with distinct strengths that
    make them suitable for different coding scenarios.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能编码领域发生了巨大变化，现在有多个强大的模型正在争夺开发者的关注，包括Claude、Gemini和OpenAI家族的模型。曾经可能由一个模型主导，但今天的生态系统提供了丰富的选择，每个选项都有独特的优势，使它们适合不同的编码场景。
- en: Understanding Model Categories
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解模型类别
- en: 'Today’s coding models generally fall into several categories based on their
    approach and strengths:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的编码模型通常根据其方法和优势分为几个类别：
- en: Speed optimized
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 速度优化
- en: These prioritize quick responses and are ideal for real-time code completion
    and rapid iteration. They typically offer lower latency at the cost of slightly
    reduced accuracy on complex tasks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型优先考虑快速响应，是实时代码完成和快速迭代的理想选择。它们通常在复杂任务上略微降低准确性，以换取更低的延迟。
- en: Deep reasoning
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 深度推理
- en: These take more time to “think through” problems but excel at complex debugging,
    architectural decisions, and multistep problem solving. Models with advanced reasoning
    capabilities can break down complex bugs step-by-step.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型需要更多时间来“思考”问题，但在复杂调试、架构决策和多步骤问题解决方面表现出色。具有高级推理能力的模型可以逐步分解复杂错误。
- en: Multimodal powerhouses
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 多模态巨头
- en: Some models can process not just code and text but also images, diagrams, and
    even video content. This makes them particularly valuable for understanding visual
    documentation or working with UI/UX elements.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模型不仅可以处理代码和文本，还可以处理图像、图表，甚至视频内容。这使得它们在理解视觉文档或与UI/UX元素一起工作时特别有价值。
- en: Open source alternatives
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 开源替代方案
- en: DeepSeek stands out by offering a comparable level of AI power to closed-source
    models without requiring payment or sign-up, though it may lack some features
    like image generation or web browsing capabilities.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: DeepSeek通过提供与闭源模型相当水平的AI能力，而不需要支付或注册，脱颖而出，尽管它可能缺少一些功能，如图像生成或网络浏览能力。
- en: Choosing the Right Model for Your Task
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择适合您任务的正确模型
- en: 'Rather than seeking a single “best” model, successful developers now match
    models to specific tasks:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与其寻求一个单一的“最佳”模型，成功的开发者现在会将模型与特定任务相匹配：
- en: For rapid prototyping and general coding, models optimized for speed and broad
    language support work well.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于快速原型设计和通用编码，针对速度和广泛语言支持进行优化的模型效果良好。
- en: For complex debugging and system design, deep reasoning models that can trace
    through logic methodically are a good choice.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于复杂的调试和系统设计，能够有系统地追踪逻辑的深度推理模型是一个不错的选择。
- en: For working with large codebases, choose models with extensive context windows
    that can maintain project-wide awareness.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于处理大型代码库，选择具有广泛上下文窗口的模型，这些模型可以保持项目全局意识。
- en: For budget-conscious teams, open source models provide excellent value without
    subscription costs.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于预算有限的团队，开源模型提供了无订阅成本的优秀价值。
- en: Many tools now support multiple AI models, including OpenAI, Claude, and Gemini
    variants, along with proprietary models, allowing developers to switch between
    them based on the task at hand.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 许多工具现在支持多个AI模型，包括OpenAI、Claude和Gemini变体，以及专有模型，允许开发者根据任务切换它们。
- en: Practical Tips for Any Model
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任何模型的实用技巧
- en: Regardless of which AI model you choose, certain practices consistently improve
    results. First, provide rich context. Don’t just ask for “a payment processing
    function.” Instead, share your data models, existing code patterns, error-handling
    approaches, and any specific requirements. The more context you provide, the better
    the output will align with your codebase.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪个AI模型，某些实践始终能提高结果。首先，提供丰富的上下文。不要只是要求“一个支付处理函数”。相反，分享你的数据模型、现有的代码模式、错误处理方法以及任何具体要求。你提供的上下文越多，输出与你的代码库的匹配度就越好。
- en: Most modern coding models excel at reviewing their own output. After receiving
    generated code, ask the model to check for potential issues, suggest improvements,
    or explain its reasoning. This self-critique often catches subtle bugs or suggests
    optimizations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代编码模型在审查自己的输出方面表现出色。在收到生成的代码后，请模型检查潜在的问题，提出改进建议或解释其推理。这种自我批评通常能捕捉到细微的缺陷或提出优化建议。
- en: Use the model’s ability to maintain conversation context. Start with a basic
    implementation, then progressively refine it through follow-up requests. This
    iterative approach often yields better results than trying to specify everything
    up front.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 利用模型维持对话上下文的能力。从一个基本的实现开始，然后通过后续请求逐步改进它。这种迭代方法通常比试图一次性指定所有内容能产生更好的结果。
- en: Each model has subtle differences in how it approaches problems. Some are more
    verbose in their explanations, while others are more concise. Some default to
    newer syntax, while others play it safe. Learning these tendencies helps you craft
    better prompts.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型在处理问题的方式上都有细微的差别。有些在解释上更加冗长，而有些则更加简洁。有些默认使用较新的语法，而有些则比较保守。了解这些倾向有助于你制作出更好的提示。
- en: Major Models
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要模型
- en: The AI coding landscape evolves monthly, with new models regularly challenging
    established leaders. The competition has become so intense that developers benefit
    from unprecedented choice and capability improvements. What matters most isn’t
    picking the “perfect” model but understanding how to leverage the strengths of
    whatever tools are available.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能编码领域每月都在演变，新的模型定期挑战既定的领导者。竞争已经变得如此激烈，以至于开发者能够从前所未有的选择和能力提升中受益。最重要的是不是选择“完美”的模型，而是理解如何利用任何可用工具的优势。
- en: Many development teams now use a portfolio approach—leveraging fast models for
    routine tasks, powerful models for complex challenges, and specialized models
    for specific domains like database optimization or frontend development. Some
    IDEs even allow seamless switching between models midtask.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发团队现在采用投资组合方法——利用快速模型处理常规任务，强大模型处理复杂挑战，以及针对特定领域（如数据库优化或前端开发）的专业模型。一些IDE甚至允许在任务进行中无缝切换模型。
- en: Success comes from understanding these options and strategically applying them
    to accelerate your development workflow.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 成功来自于理解这些选项并战略性地应用它们以加速你的开发工作流程。
- en: 'Google Gemini: The Multimodal Coding Powerhouse'
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Gemini：多模态编码的强大力量
- en: '[Google’s Gemini](https://gemini.google.com) family represents a fundamental
    shift in AI-assisted development through its native multimodal capabilities. Unlike
    models that were primarily trained on text and code, Gemini was architected from
    the ground up to seamlessly understand and work across text, code, images, video,
    and other data formats. This makes it exceptionally powerful for modern development
    workflows where visual context matters as much as textual information.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[Google的Gemini](https://gemini.google.com)系列通过其本地的多模态能力，代表了人工智能辅助开发的根本转变。与主要在文本和代码上训练的模型不同，Gemini从头开始设计，以无缝地理解和处理文本、代码、图像、视频和其他数据格式。这使得它在现代开发工作流程中特别强大，其中视觉上下文与文本信息一样重要。'
- en: 'The multimodal nature of Gemini proves particularly valuable in web development
    scenarios. Developers can share screenshots of design mockups, and Gemini can
    generate pixel-perfect implementations that match the visual style. It excels
    at understanding charts, diagrams, and UI elements, making it an ideal partner
    when translating visual designs into functional code. This capability extends
    beyond simple image recognition: Gemini can reason about visual elements, understand
    design patterns, and maintain aesthetic consistency across an entire project.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Gemini的多模态特性在Web开发场景中尤其有价值。开发者可以共享设计草图的屏幕截图，Gemini可以生成像素级匹配视觉风格的实现。它擅长理解图表、图表和UI元素，在将视觉设计转换为功能性代码时是一个理想的合作伙伴。这种能力不仅限于简单的图像识别：Gemini可以推理视觉元素，理解设计模式，并在整个项目中保持美学一致性。
- en: Gemini’s integration with development workflows through popular editors (VSCode,
    Cursor, Windsurf) and plug-ins like Cline and Code Assist offers developers powerful
    customization options that scale from individual preferences to team-wide standards.
    Developers can create custom commands for repetitive tasks, establish rules that
    apply to every code generation, and maintain consistent coding patterns across
    large codebases. The generous free tier makes it accessible to students, hobbyists,
    and startups, while enterprise features support complex organizational requirements.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Gemini通过流行的编辑器（如VSCode、Cursor、Windsurf）和插件（如Cline和Code Assist）与开发工作流程的集成，为开发者提供了从个人偏好到团队标准的强大定制选项。开发者可以为重复性任务创建自定义命令，为每次代码生成建立规则，并在大型代码库中保持一致的编码模式。慷慨的免费层使其对学生、爱好者和初创企业可访问，而企业功能支持复杂的组织需求。
- en: What distinguishes Gemini in the coding landscape is its ability to think deeply
    about problems while maintaining practical speed. The model can alternate between
    quick responses for simple tasks and extended reasoning for complex challenges,
    adapting its approach based on the problem at hand. This flexibility, combined
    with its visual understanding capabilities, makes it particularly effective for
    full stack development where both backend logic and frontend aesthetics matter
    equally.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码领域中，双子座（Gemini）之所以与众不同，在于它能够在保持实际速度的同时深入思考问题。该模型可以在快速响应简单任务和进行复杂挑战的深入推理之间切换，根据手头的问题调整其方法。这种灵活性，结合其视觉理解能力，使其在需要前后端逻辑和美学同等重要的全栈开发中特别有效。
- en: 'Claude: The Reasoning Virtuoso'
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Claude：推理大师
- en: '[Anthropic Claude’s approach](https://anthropic.com/claude) to coding assistance
    centers on transparency and deep reasoning capabilities. The Claude family, particularly
    the Sonnet models, has established itself as exceptionally capable at complex
    software engineering tasks that require careful analysis and step-by-step problem
    solving. What sets Claude apart is its ability to show its thinking process, allowing
    developers to follow along with its reasoning and verify its logic before implementing
    solutions.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[Anthropic Claude的编码辅助方法](https://anthropic.com/claude)侧重于透明度和深入的推理能力。Claude家族，特别是Sonnet模型，已经证明在需要仔细分析和逐步解决问题的复杂软件工程任务中特别有能力。Claude与众不同的地方在于它能够展示其思考过程，允许开发者跟随其推理，并在实施解决方案之前验证其逻辑。'
- en: The Artifacts feature represents a paradigm shift in how developers interact
    with AI coding assistants. Rather than simply providing code in a chat interface,
    Claude creates a dedicated workspace where code can be viewed, edited, and previewed
    in real time. This interactive environment is particularly powerful for frontend
    development, data visualization, and any scenario where immediate visual feedback
    accelerates the development process. Developers can iterate on designs, test functionality,
    and refine implementations all within the same conversation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: “工件”功能代表了开发者与AI编码助手交互方式的范式转变。而不是仅仅在聊天界面中提供代码，Claude创建了一个专用的代码工作区，其中代码可以实时查看、编辑和预览。这种交互式环境对于前端开发、数据可视化和任何需要即时视觉反馈以加速开发过程的情况特别强大。开发者可以在同一对话中迭代设计、测试功能并完善实现。
- en: Claude demonstrates exceptional performance on real-world software engineering
    benchmarks, consistently ranking among the top models for tasks like bug fixing,
    feature implementation, and code refactoring. Its strength lies not just in generating
    code but in understanding the broader context of software projects. Claude can
    analyze existing codebases, identify patterns and antipatterns, suggest architectural
    improvements, and maintain consistency with established coding styles. This makes
    it invaluable for both greenfield projects and legacy system maintenance.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Claude在现实世界的软件工程基准测试中表现出色，在诸如错误修复、功能实现和代码重构等任务中，始终位于顶级模型之列。它的优势不仅在于生成代码，还在于理解软件项目的更广泛背景。Claude可以分析现有的代码库，识别模式和反模式，提出架构改进，并保持与既定编码风格的一致性。这使得它在绿地项目和遗留系统维护中都非常有价值。
- en: The model’s approach to memory and context management enables it to build understanding
    over extended coding sessions. When working with large projects, Claude can extract
    and retain key information about the codebase structure, design decisions, and
    project-specific patterns. This accumulated knowledge allows it to provide increasingly
    relevant and contextual suggestions as development progresses, making it feel
    more like a team member who grows familiar with the project over time rather than
    a stateless assistant.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的记忆和上下文管理方法使其能够在长时间的编码会话中建立理解。当处理大型项目时，Claude可以提取并保留有关代码库结构、设计决策和特定项目模式的要点信息。这种累积的知识使它能够随着开发进程的推进提供越来越相关和上下文化的建议，使其更像是一个随着时间的推移逐渐熟悉项目的团队成员，而不是一个无状态的助手。
- en: 'ChatGPT: The Versatile Coding Companion'
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ChatGPT：多才多艺的编码伴侣
- en: '[ChatGPT](https://oreil.ly/hZdNC) has established itself as the Swiss Army
    knife of AI coding assistants, valued not for specialized features but for its
    remarkable versatility and broad knowledge base. Its position in the developer
    toolkit is unique. While other models might integrate directly into IDEs or offer
    specialized coding environments, ChatGPT serves as an always available programming
    consultant that developers keep open in their browsers throughout the workday.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[ChatGPT](https://oreil.ly/hZdNC) 已成为AI编码助手的瑞士军刀，其价值不在于专门的功能，而在于其非凡的通用性和广泛的知识库。它在开发者工具箱中的位置独一无二。虽然其他模型可能直接集成到IDE中或提供专门的编码环境，但ChatGPT作为一个始终可用的编程顾问，开发者会在整个工作日中将其保持在浏览器中打开。'
- en: The conversational interface of ChatGPT makes it exceptionally effective for
    exploratory problem solving and learning. Developers regularly use it for rubber-duck
    debugging, pasting in problematic code and thinking through issues in natural
    conversation. Its extensive training enables it to recognize patterns across virtually
    every programming language, framework, and tool in common use. Whether debugging
    a regex expression, understanding an obscure error message, or exploring unfamiliar
    library documentation, ChatGPT can provide relevant insights drawn from its comprehensive
    knowledge base.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT的对话界面使其在探索性问题解决和学习方面特别有效。开发者经常用它进行橡皮鸭调试，将问题代码粘贴进来，并通过自然对话思考问题。其广泛的训练使其能够识别几乎所有常用编程语言、框架和工具中的模式。无论是调试正则表达式、理解晦涩的错误消息，还是探索不熟悉的库文档，ChatGPT都能提供基于其全面知识库的相关见解。
- en: ChatGPT’s strength lies in its ability to bridge the gap between human intent
    and code implementation. It excels at *bidirectional translation*—converting natural
    language descriptions into working code and explaining complex code in plain English.
    This makes it invaluable for documentation, code reviews, and knowledge transfer
    within teams. Developers can paste unfamiliar code and receive clear explanations
    of its functionality, or describe desired behavior and receive appropriate implementations
    across multiple programming paradigms.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT的优势在于其能够弥合人类意图与代码实现之间的差距。它在双向翻译方面表现出色——将自然语言描述转换为工作代码，并以简单的英语解释复杂代码。这使得它在文档编写、代码审查和团队内部知识转移中非常有价值。开发者可以将不熟悉的代码粘贴进来，并收到对其功能性的清晰解释，或者描述所需的行为，并收到适用于多种编程范式的适当实现。
- en: The model’s versatility extends beyond traditional programming languages to
    configuration files, scripts, data formats, and domain-specific languages. While
    specialized coding tools excel within their focused domains, ChatGPT provides
    valuable assistance across the entire spectrum of software development tasks.
    This breadth makes it particularly useful when working at the boundaries between
    different technologies or when encountering problems that span multiple domains.
    Its ability to maintain context across extended conversations allows developers
    to explore complex problems iteratively, refining solutions through collaborative
    dialogue.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的灵活性不仅限于传统的编程语言，还包括配置文件、脚本、数据格式和特定领域的语言。虽然专门的编码工具在其专注的领域内表现出色，但ChatGPT在整个软件开发任务范围内提供了宝贵的帮助。这种广度使其在处理不同技术之间的边界问题或遇到跨越多个领域的问题时特别有用。它能够在扩展对话中保持上下文的能力，使开发者能够迭代地探索复杂问题，通过协作对话完善解决方案。
- en: Choosing the Right Model for Your Needs
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的需求选择合适的模型
- en: The availability of these powerful AI coding assistants represents a fundamental
    shift in software development practices. Rather than viewing them as competing
    options, successful developers recognize that each model family brings unique
    strengths to different aspects of the development process. Google’s Gemini excels
    when visual context and multimodal understanding are crucial, particularly in
    UI/UX development and when working with design specifications. Anthropic’s Claude
    shines in scenarios requiring deep reasoning, complex refactoring, and transparent
    problem-solving approaches. The OpenAI family of models provides unmatched versatility
    and broad knowledge, making it ideal for learning, debugging, and cross-domain
    challenges.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些强大的AI编码助手的出现代表了软件开发实践的根本转变。成功的开发者不会将它们视为相互竞争的选项，而是认识到每个模型系列为开发过程的各个方面带来了独特的优势。Google的Gemini在视觉上下文和多模态理解至关重要的情况下表现出色，尤其是在UI/UX开发和处理设计规范时。Anthropic的Claude在需要深入推理、复杂重构和透明问题解决方法的场景中闪耀。OpenAI的模型系列提供了无与伦比的灵活性和广泛的知识，使其成为学习、调试和跨领域挑战的理想选择。
- en: Many development teams now employ a portfolio approach, leveraging different
    models for different tasks within the same project. A typical workflow might involve
    using Gemini to translate design mockups into initial implementations, Claude
    for complex architectural decisions and code reviews, and ChatGPT for general
    problem solving and documentation. This multimodel approach maximizes productivity
    by matching each tool’s strengths to specific development challenges.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发团队现在采用组合方法，在同一个项目中利用不同的模型来完成不同的任务。一个典型的流程可能包括使用Gemini将设计原型转换为初始实现，Claude进行复杂的架构决策和代码审查，以及ChatGPT进行一般问题解决和文档编写。这种多模型方法通过将每个工具的优势与特定的开发挑战相匹配，最大化了生产力。
- en: As these models continue to evolve, the key to effective AI-assisted development
    lies not in choosing a single “best” option but in understanding how to orchestrate
    multiple AI assistants to accelerate and enhance every aspect of the software
    development lifecycle.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这些模型不断进化，有效AI辅助开发的关键不在于选择一个单一的“最佳”选项，而在于理解如何协调多个AI助手来加速并增强软件开发生命周期的各个方面。
- en: This ecosystem is young and rapidly changing. New players and capabilities are
    emerging every few months. The key takeaway is that you don’t have to build your
    own AI from scratch to leverage programming with intent—there are plenty of tools
    that bring this power to your fingertips. Throughout this book, I’ll discuss various
    platforms and how they fit into the vibe-coding workflow.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生态系统尚年轻且快速变化。每几个月就会涌现新的参与者和新能力。关键要点是，您不必从头开始构建自己的AI来利用有目的的编程——有很多工具将这种力量带到您的指尖。在这本书的整个过程中，我将讨论各种平台以及它们如何融入vibe编码的工作流程。
- en: 'The Benefits and Limitations of Vibe Coding: A Nuanced View'
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vibe编码的益处和局限：一种细微的观点
- en: It’s important to recognize the scenarios where AI-assisted development truly
    shines⁠—and where it might still fall flat. Let’s explore some ideal use cases
    where vibe coding excels, as well as situations where today’s AI still struggles
    or requires heavy human intervention.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 认识到AI辅助开发真正发光发热的场景——以及它可能仍然表现不佳的地方，这一点很重要。让我们探讨一些理想的使用案例，其中vibe编码表现出色，以及今天的人工智能仍然挣扎或需要大量人工干预的情况。
- en: Ideal Use Cases for Vibe Coding
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vibe编码的理想用例
- en: Just as certain architectures are suited for certain problems, vibe coding has
    its “sweet spots” in the software development landscape.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如某些架构适合某些问题一样，Vibe编码在软件开发领域也有其“甜蜜点”。
- en: Zero-to-one product development
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从零到一的产品开发
- en: Vibe coding is a game changer for getting a brand-new project off the ground.
    The term *zero to one* (popularized by Peter Thiel) refers to creating something
    new from scratch. With AI, you can go from a blank canvas to a functional prototype
    at lightning speed. Need to stand up a web app that’s never existed before? You
    can generate boilerplate code for your frontend, backend, database schema, and
    even deployment scripts in one frenetic session of prompting. This is perfect
    for startups or hackathon projects where the goal is to validate an idea quickly.
    Instead of spending weeks setting up the “scaffolding” of a project (all the repetitive
    setup code), you can have the AI do it in minutes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Vibe编码是启动全新项目的一个变革者。术语*从零到一*（由彼得·蒂尔普及）指的是从头开始创造新事物。借助AI，你可以以闪电般的速度从一张白纸到功能原型。需要建立一个以前从未存在过的Web应用？你可以在一次狂热的提示会话中生成前端、后端、数据库模式甚至部署脚本的样板代码。这对于初创公司或黑客马拉松项目来说非常完美，这些项目的目标是快速验证一个想法。你不必花费数周时间设置项目的“脚手架”（所有重复的设置代码），AI可以在几分钟内完成这些工作。
- en: Many developers have recounted how they built an MVP over a weekend with the
    help of AI pair programmers—something that might have taken them a month working
    solo before. By quickly materializing the idea into a working product, you can
    start testing it with users or stakeholders much sooner. The AI is great at the
    generic stuff (setting up routing, basic UI components, standard CRUD operations),
    which frees you to focus on the novel aspects of your product.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者都分享了他们如何借助AI配对程序员在周末构建了一个最小可行产品（MVP）的经历——这可能是他们独自工作一个月才能完成的事情。通过快速将想法转化为可工作的产品，你可以更早地开始与用户或利益相关者进行测试。AI在处理通用任务方面非常出色（如设置路由、基本UI组件、标准CRUD操作），这让你可以专注于产品的创新方面。
- en: However, once your MVP gains traction and moves toward production, your approach
    must shift. This is where AI-assisted engineering becomes essential. While vibe
    coding has helped you explore and validate quickly, scaling now requires more
    deliberate practices. You’ll need to refactor that rapidly generated code with
    proper error handling, add comprehensive test coverage, and establish clear architectural
    boundaries. The transition from prototype to product marks the natural evolution
    from vibe coding’s exploratory freedom to engineering’s structured discipline.
    Smart teams recognize this inflection point and adjust their AI usage accordingly—maintaining
    velocity while introducing the guardrails necessary for sustainable growth.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦你的MVP获得关注并转向生产，你的方法必须转变。这就是AI辅助工程变得至关重要的地方。虽然Vibe编码帮助你快速探索和验证，但扩展现在需要更谨慎的实践。你需要对快速生成的代码进行重构，添加适当的错误处理，增加全面的测试覆盖，并建立清晰的架构边界。从原型到产品的转变标志着从Vibe编码的探索自由到工程结构化纪律的自然演变。聪明的团队认识到这个转折点，并相应地调整他们的AI使用——在保持速度的同时引入可持续增长所需的护栏。
- en: Feature prototyping and CRUD applications
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能原型和CRUD应用
- en: 'A lot of software engineering, especially in business apps, involves CRUD—create,
    read, update, delete—functionality around data. This is formulaic work that AI
    is exceptionally good at because it’s seen countless examples. If you need to
    add, say, a new “Inventory” module to your system with CRUD screens and APIs,
    vibe coding will handle that extremely well. It can produce database migrations,
    ORM models, API endpoints, and UI forms with validation—basically the full stack—largely
    error-free because these patterns are so common in its training data. Even if
    your app has custom rules, you can specify those in a prompt and get a decent
    first pass. The result: what used to be a week-long task of boring wiring-up becomes
    an afternoon of prompting and testing. For internal tools or admin panels (which
    are essentially big CRUD apps), you might almost entirely lean on AI to generate
    them, given how straightforward yet time-consuming they normally are.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件工程，尤其是在商业应用程序中，涉及围绕数据的CRUD（创建、读取、更新、删除）功能。这是AI特别擅长的工作，因为它已经看到了无数示例。如果您需要向系统中添加一个新“库存”模块，带有CRUD屏幕和API，动态编码将处理得非常好。它可以生成数据库迁移、ORM模型、API端点和带有验证的UI表单——基本上是全栈——因为这些模式在其训练数据中非常常见，所以几乎不会出错。即使您的应用程序有自定义规则，您也可以在提示中指定这些规则，并获得一个不错的初步结果。结果是，过去需要一周时间完成的枯燥的连接任务现在只需要一个下午的提示和测试。对于内部工具或管理面板（本质上是大型的CRUD应用程序），鉴于它们通常既简单又耗时，您几乎可以完全依赖AI来生成它们。
- en: The engineering approach becomes crucial when these CRUD operations involve
    complex business logic, data validation rules, or integration with existing systems.
    While vibe coding can generate the basic structure quickly, AI-assisted engineering
    ensures that your inventory module properly handles edge cases like concurrent
    updates, maintains referential integrity, and follows your organization’s established
    patterns. For instance, you might use vibe coding to generate the initial CRUD
    scaffolding, then switch to engineering mode to implement domain-specific rules
    like inventory threshold alerts, multiwarehouse allocation logic, or integration
    with your existing authentication and authorization systems. The key is recognizing
    when to transition from rapid generation to careful refinement.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些CRUD操作涉及复杂业务逻辑、数据验证规则或与现有系统集成时，工程方法变得至关重要。虽然动态编码可以快速生成基本结构，但AI辅助工程确保您的库存模块正确处理边缘情况，如并发更新、维护引用完整性，并遵循您组织建立的模式。例如，您可能使用动态编码生成初始CRUD脚手架，然后切换到工程模式以实现特定领域的规则，如库存阈值警报、多仓库分配逻辑或与现有认证和授权系统的集成。关键是识别何时从快速生成过渡到精心细化。
- en: Glue code and integration
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粘合代码和集成
- en: Need to integrate two services or APIs together? That often involves reading
    docs and writing code to transform data from one format to another. AI models
    have often been trained on API documentation and code examples, meaning they can
    expedite integration work. Ask ChatGPT to show how to call Service A’s API from
    Language B—chances are it will produce example code with the right endpoints and
    maybe even an auth example. Combining multiple systems (like hooking up a payment
    gateway with your order system or connecting a third-party analytics SDK) becomes
    easier when the AI can suggest the boilerplate and edge cases to handle. It excels
    at these standard integration patterns.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 需要集成两个服务或API吗？这通常涉及阅读文档和编写代码，将数据从一种格式转换为另一种格式。AI模型通常是在API文档和代码示例上训练的，这意味着它们可以加速集成工作。让ChatGPT展示如何从语言B调用服务A的API——很可能它会生成带有正确端点和可能甚至有认证示例的示例代码。当AI能够建议样板代码和边缘情况处理时，结合多个系统（如将支付网关与您的订单系统连接或连接第三方分析SDK）变得更容易。它在这些标准集成模式上表现出色。
- en: Modern framework utilization
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现代框架利用
- en: 'AI coding assistants have effectively read the manuals on all popular frameworks:
    React, Angular, Django, Rails, Node/Express, Flutter—you name it. This means that
    if you’re using well-known frameworks, the AI can generate idiomatic code for
    those frameworks. For instance, it can spit out a new React component with hooks
    and state management or a new Django model with the proper admin class and serializer.
    The benefit is you don’t have to remember every little detail—the AI fills in
    the gaps. Vibe coding performs especially well with modern web development tasks
    like generating HTML/JSX with the right classes or hooking up controller endpoints,
    because these are tasks AI models have seen over and over. It’s like having a
    framework expert always by your side to write the boilerplate while you decide
    on the specifics of what the feature should do.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: AI编码助手已经有效地阅读了所有流行框架的说明书：React、Angular、Django、Rails、Node/Express、Flutter——你说的都对。这意味着如果你使用的是知名框架，AI可以为这些框架生成惯用的代码。例如，它可以生成带有钩子和状态管理的新的React组件，或者带有适当的admin类和序列化器的新的Django模型。好处是，你不必记住每一个小细节——AI填补了这些空白。**氛围编码**在处理现代Web开发任务时表现尤为出色，比如生成带有正确类的HTML/JSX或连接控制器端点，因为这些任务AI模型已经反复见过。这就像总有一个框架专家在你身边，在你决定功能应该做什么的具体细节时，帮你编写样板代码。
- en: Repetitive code generation
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复代码生成
- en: 'Sometimes you need to create lots of similar code (like many similar endpoints
    or classes for each type in some schema). This can be tedious and error-prone
    for a human. AI, on the other hand, loves repetitive structures—once you show
    it one or two examples, it can churn out the rest consistently. This bulk code
    generation can save a ton of time. For instance, if you’re writing data model
    classes for 50 types of records, you can prompt one example and ask the AI to
    generate classes for all 50 types following that pattern. It will likely do so
    flawlessly and in seconds. The result: you avoid a whole day of monotonous coding.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要创建大量的相似代码（比如在某个模式中为每种类型创建许多类似的端点或类）。对于人类来说，这可能既繁琐又容易出错。另一方面，AI喜欢重复的结构——一旦你向它展示一两个示例，它就可以持续地生成剩余的部分。这种批量代码生成可以节省大量时间。例如，如果你正在为50种记录类型编写数据模型类，你可以提示一个示例，并要求AI根据该模式生成所有50种类型的类。它很可能会完美无缺且在几秒钟内完成。结果是：你避免了整整一天的单调编码。
- en: When AI-assisted engineering should take precedence
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当AI辅助工程应优先考虑时
- en: While vibe coding excels in certain scenarios, AI-assisted engineering becomes
    indispensable in others. Understanding these situations helps developers choose
    the right approach from the start, avoiding costly rewrites or technical debt.
    Complex algorithmic implementations require the engineering approach. When you’re
    building sophisticated data structures, implementing performance-critical algorithms,
    or solving novel computational problems, you need precise control over every aspect
    of the implementation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**氛围编码**在某些场景中表现出色，但在其他情况下，AI辅助工程变得不可或缺。理解这些情况有助于开发者从一开始就选择正确的方法，避免昂贵的重写或技术债务。复杂的算法实现需要工程方法。当你构建复杂的数据结构、实现性能关键型算法或解决新颖的计算问题时，你需要对实现的每个方面都进行精确控制。
- en: Here, AI serves as a knowledgeable assistant rather than a code generator. You
    might ask it to explain algorithmic approaches or review your implementation for
    correctness, but you maintain direct control over the architecture and optimization
    decisions. The AI helps you think through problems rather than solving them wholesale.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，AI充当一个知识渊博的助手而不是代码生成器。你可以要求它解释算法方法或审查你的实现以检查正确性，但你保持对架构和优化决策的直接控制。AI帮助你思考问题而不是全面解决问题。
- en: Mission-critical systems demand engineering rigor from the outset. Financial
    transactions, healthcare applications, security infrastructure, and other high-stakes
    domains cannot afford the exploratory nature of vibe coding. In these contexts,
    every line of code needs careful consideration, comprehensive testing, and often
    regulatory compliance. AI assists by suggesting best practices, identifying potential
    vulnerabilities, and helping ensure compliance with standards, but the developer
    maintains tight control over the implementation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关键任务系统，从一开始就需要严格的工程方法。金融交易、医疗保健应用、安全基础设施和其他高风险领域无法承担**氛围编码**的探索性质。在这些环境中，每一行代码都需要仔细考虑、全面测试，并且通常需要符合监管要求。AI通过建议最佳实践、识别潜在漏洞并帮助确保符合标准来提供协助，但开发者对实现保持紧密控制。
- en: The cost of failure in these systems far outweighs any speed advantages from
    rapid generation. Legacy system integration presents unique challenges where engineering
    discipline proves essential. When working with decades-old codebases, proprietary
    protocols, or systems with extensive technical debt, vibe coding’s pattern matching
    often fails. These scenarios require deep understanding of existing constraints,
    careful planning of integration points, and methodical refactoring. AI can help
    by explaining legacy code patterns or suggesting modernization strategies, but
    the actual implementation requires the precision that only structured engineering
    provides.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统中的失败成本远超过快速生成的任何速度优势。遗留系统集成提出了独特的挑战，其中工程学科至关重要。当与几十年前的代码库、专有协议或技术债务庞大的系统一起工作时，感觉编码的模式匹配往往失败。这些场景需要深入理解现有约束，仔细规划集成点，以及有系统的重构。人工智能可以通过解释遗留代码模式或提出现代化策略来帮助，但实际实施需要只有结构化工程才能提供的精确度。
- en: Performance optimization represents another domain where engineering trumps
    vibing. While AI can generate functional code quickly, it rarely produces optimal
    solutions for performance-critical paths. Tasks like memory management, cache
    optimization, parallel processing, and latency reduction require deep understanding
    of hardware, operating systems, and algorithmic complexity. Here, AI serves best
    as a research assistant, helping you explore optimization techniques or benchmark
    different approaches, while you make the informed decisions about implementation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化是另一个领域，在这里工程学胜过感觉。虽然人工智能可以快速生成功能性代码，但它很少为性能关键路径产生最优解。像内存管理、缓存优化、并行处理和延迟降低这样的任务需要深入理解硬件、操作系统和算法复杂性。在这里，人工智能作为研究助理最为出色，帮助你探索优化技术或基准测试不同的方法，而你则做出关于实施的明智决策。
- en: In these scenarios, AI’s pattern recognition and speed align perfectly with
    the task. Essentially, vibe coding thrives on tasks that are well-trodden territory
    in programming (like CRUD or typical web app structures) and tasks that benefit
    from rapid trial and error (prototypes, new ideas). It’s like having a junior
    developer who has read every GitHub repo and can instantly recall how it’s usually
    done and write it for you to review. That’s incredibly powerful for getting things
    moving quickly.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些场景中，人工智能的模式识别和速度与任务完美匹配。本质上，感觉编码在编程的熟路领域（如CRUD或典型的Web应用结构）以及从快速试错中受益的任务（原型、新想法）中蓬勃发展。这就像有一个阅读过每个GitHub仓库的初级开发者，可以立即回忆起通常是如何做的，并为你编写以供审查。这对于快速推进事物来说非常强大。
- en: Recognizing the transition points
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认识到转换点
- en: The art of modern AI-enhanced development lies not in choosing one approach
    over the other but in recognizing *when to transition between them*. Successful
    developers develop an intuition for these inflection points. Starting a new feature?
    Begin with vibe coding to explore possibilities quickly. Notice the code becoming
    complex or touching critical systems? Shift to engineering mode. Building a proof
    of concept for a client demo? Vibe coding gets you there fast. Converting that
    proof of concept into a production system? Time for engineering discipline.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现代人工智能增强开发的技艺不在于选择一种方法而放弃另一种，而在于认识到*何时在它们之间进行转换*。成功的开发者对这些转折点有着直觉。开始一个新功能？从感觉编码开始，快速探索可能性。注意到代码变得复杂或触及关键系统？切换到工程模式。为客户演示构建原型？感觉编码能让你快速到达那里。将原型转换为生产系统？是时候采取工程纪律了。
- en: This fluidity—the ability to move seamlessly between rapid exploration and careful
    construction—distinguishes truly effective AI-augmented developers. They understand
    that vibe coding and AI-assisted engineering are complementary tools in their
    toolkit, each suited for different phases of the development lifecycle. The goal
    isn’t to pick a side but to leverage both approaches strategically, maximizing
    both velocity and quality throughout the software development process.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这种流动性——在快速探索和精心构建之间无缝切换的能力——区分了真正有效的AI增强开发者。他们明白，感觉编码和人工智能辅助工程是他们工具箱中的互补工具，各自适合开发生命周期的不同阶段。目标不是选择一方，而是战略性地利用两种方法，在整个软件开发过程中最大化速度和质量。
- en: Where AI Still Struggles
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AI仍面临的挑战
- en: As impressive as current AI coding tools are, they are not magic. There are
    classes of problems that remain difficult for AI to handle reliably, often requiring
    human insight or traditional coding techniques. Knowing these limitations helps
    set the right expectations and lets you plan when to lean in versus when to take
    back the reins.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管当前的AI编码工具非常令人印象深刻，但它们并不是魔法。有一些问题类别对于AI来说仍然难以可靠地处理，通常需要人类的洞察力或传统的编码技术。了解这些限制有助于设定正确的期望，并让你知道何时依赖AI，何时重新掌握控制权。
- en: 'The limitations include the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 限制包括以下内容：
- en: Deeply complex systems
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 深度复杂的系统
- en: If you’re dealing with very complex algorithms or novel problems that the AI
    likely hasn’t seen, it may flounder. For example, writing a brand-new algorithm
    from a research paper or doing something like writing a compiler or highly concurrent
    system—these involve intricate logic that requires true understanding and often
    creative leaps. AI can try, but it might get things subtly wrong.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处理的是非常复杂或AI可能未见过的创新问题，它可能会遇到困难。例如，从研究论文中编写全新的算法，或者做一些像编写编译器或高度并发系统的事情——这些涉及复杂的逻辑，需要真正的理解和经常性的创新飞跃。AI可以尝试，但可能会在细节上出现错误。
- en: In complex domains like these, the AI’s tendency to make approximately correct
    but not exactly correct code can lead to a lot of back-and-forth. As Chapters
    [3](ch03.html#ch03_the_70_problem_ai_assisted_workflows_that_actual_1752630043200933)
    and [4](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362)
    will discuss, the final 30% or so of correctness is very hard for the AI to nail
    down. This is related to what I call the *70% problem*—AI gets you most of the
    way quickly, but the last part is tough. An experienced developer might use AI
    to generate skeletons or helper functions for such complex tasks but do the core
    logic themselves.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些复杂的领域，AI倾向于生成大致正确但并非完全正确的代码，这可能导致很多来回。正如第[3](ch03.html#ch03_the_70_problem_ai_assisted_workflows_that_actual_1752630043200933)章和第[4](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362)章将要讨论的，正确性的最后30%左右对于AI来说非常难以确定。这与我所说的*70%问题*有关——AI可以快速带你走大部分路，但最后的部分很困难。经验丰富的开发者可能会使用AI生成这类复杂任务的框架或辅助函数，但核心逻辑则由自己完成。
- en: Low-level optimizations and systems programming
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 低级优化和系统编程
- en: Current AI models are primarily trained on high-level languages and abstractions.
    If you need to do low-level bit-twiddling, write highly optimized C code for a
    specific microcontroller, or generate vectorized SIMD instructions, the AI might
    not be reliable. It might produce code that looks plausible but isn’t truly optimal,
    or even correct, on a hardware level.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的AI模型主要是基于高级语言和抽象进行训练的。如果你需要进行低级位操作，为特定的微控制器编写高度优化的C代码，或者生成矢量化SIMD指令，AI可能不可靠。它可能会生成看似合理的代码，但在硬件层面上并不真正优化，甚至可能不正确。
- en: Similarly, for things like memory management or real-time constraints, the AI
    doesn’t have a real concept of those (it doesn’t simulate a CPU cache in its head).
    So for performance-critical code, you’ll want to either thoroughly test AI suggestions
    or write those parts manually. That said, AI might still help by providing a starting
    template or explaining assembly, but you cannot blindly trust it in these scenarios.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于像内存管理或实时约束这样的东西，AI并没有真正的概念（它不会在脑海中模拟CPU缓存）。因此，对于性能关键代码，你可能需要彻底测试AI的建议，或者手动编写这些部分。尽管如此，AI仍然可以通过提供起始模板或解释汇编来提供帮助，但在这些情况下你不能盲目地信任它。
- en: Unique or niche frameworks
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 独特或利基框架
- en: If you’re using a very new or obscure framework that wasn’t around during the
    AI’s training, it won’t know about it. In such cases, the AI might try to generalize
    or might produce code that looks like it fits but actually call functions that
    don’t exist (hallucinations) or use outdated versions of the API. For example,
    if a new web framework version came out last month with breaking changes, the
    AI won’t know about those changes. It might give you code for the old version.
    In these cases, you have to fall back on documentation and perhaps even help train
    the AI by feeding it context from the docs within your prompt (basically teaching
    it on the fly).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是AI训练期间不存在的非常新或晦涩的框架，它将不会了解它。在这种情况下，AI可能会尝试泛化，或者生成看起来似乎符合要求的代码，但实际上调用不存在的函数（幻觉）或使用API的过时版本。例如，如果上个月推出了一个新的Web框架版本，并带来了破坏性的变化，AI将不会了解这些变化。它可能会给你提供旧版本的代码。在这些情况下，你必须求助于文档，也许甚至可以通过在你的提示中提供文档中的上下文来帮助训练AI（基本上是在飞行中教学）。
- en: Creative UI/UX design
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 创意UI/UX设计
- en: If you ask AI to design a completely novel user interface or experience, it’s
    not great at that creative leap. It can generate UI code for known patterns (like
    a standard form or a dashboard), but if you want an innovative UI that doesn’t
    have clear precedents, the AI might not give you something inspiring. It might
    just stitch together familiar components. Human designers and frontend devs are
    still very much needed to dream up new user experiences. In coding terms, AI can
    make you a standard-looking interface quickly, but for that special custom feel,
    you’ll guide it or hand-tweak.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要求人工智能设计一个完全新颖的用户界面或体验，它在这方面并不擅长进行创造性飞跃。它可以生成已知模式的 UI 代码（如标准表单或仪表板），但如果你想要一个没有明确先例的创新
    UI，人工智能可能不会给你带来有启发性的东西。它可能只是将熟悉的部分拼接在一起。人类设计师和前端开发者仍然非常需要来构想新的用户体验。在编码术语中，人工智能可以快速让你拥有一个标准外观的界面，但为了那种特殊的定制感觉，你需要引导它或手动调整。
- en: Interpreting intent and requirements
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 解释意图和需求
- en: Sometimes AI struggles when requirements are implicit or contradictory.  It
    has no true understanding of the end goal beyond what you explicitly tell it.
    If requirements are vague (“make it efficient”—what does that precisely mean?),
    the AI might guess incorrectly what you care about (memory versus speed, for instance).
    Humans are better at clarifying intent, especially with nontechnical stakeholders.
    AI can also misinterpret instructions, especially if there’s domain-specific context
    it’s unaware of (like business rules). It might produce a logically correct solution
    that doesn’t actually solve the real problem because the nuance was lost in translation.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有时当需求是隐含的或矛盾的时，人工智能会感到困难。它对你明确告诉它的目标之外没有真正的理解。如果需求是模糊的（“让它更高效”——这究竟意味着什么？），人工智能可能会错误地猜测你关心的事情（例如，内存与速度）。人类在阐明意图方面更擅长，尤其是在非技术利益相关者中。人工智能也可能误解指令，特别是如果它不了解特定领域的上下文（如商业规则）。它可能产生一个逻辑上正确的解决方案，但实际上并没有解决真正的问题，因为细微差别在翻译中丢失了。
- en: 'A good example scenario combining these: imagine developing a new 3D graphics
    engine (complex system) in Rust (system-level, performance critical). You have
    novel algorithms for rendering (unique problems). AI could maybe help write some
    boilerplate, but you’d largely rely on human ingenuity for the core. The AI might
    get you started with setting up a window and a basic render loop (common tasks),
    but for the bespoke parts, you’d proceed with traditional careful coding and perhaps
    get some algorithmic help from AI in pseudocode form. And if you asked it to optimize
    a hot loop in assembly, you’d have to verify every instruction.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一个结合这些情况的良好示例场景：想象一下在 Rust（系统级，性能关键）中开发一个新的 3D 图形引擎（复杂系统）。你有一些独特的渲染算法（独特的问题）。人工智能可能有助于编写一些样板代码，但你主要会依赖人类的独创性来完成核心部分。人工智能可能会帮助你设置窗口和基本的渲染循环（常见任务），但对于定制部分，你会继续使用传统的谨慎编码，并可能从人工智能那里获得一些伪代码形式的算法帮助。如果你要求它用汇编语言优化一个热点循环，你必须验证每条指令。
- en: AI also lacks true problem-solving insight. At the end of the day, it’s pattern
    matching. So if your problem requires an *aha!* insight, the AI might just flail
    around, presenting things that look like code but don’t solve it. This is where
    a human stepping back, thinking abstractly, or drawing on real experience can
    save the day. Once you have the insight, you can then use the AI to implement
    it quickly.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能也缺乏真正的解决问题的洞察力。最终，它只是模式匹配。所以如果你的问题需要一种 *aha!* 的洞察力，人工智能可能只是四处乱撞，展示出看似代码但实际上无法解决问题的东西。这就是人类退后一步，抽象思考或借鉴实际经验可以拯救局面的地方。一旦你有了洞察力，你就可以利用人工智能快速实现它。
- en: Understanding these strengths and weaknesses ensures you’ll deploy vibe-coding
    techniques in the right situations. To maximize success, leverage the AI for what
    it’s good at (the known patterns), and apply your creativity to the unique parts
    of your application. Be ready to intervene in those areas where AI is known to
    struggle. For instance, do a careful review of any security-sensitive code it
    writes, because it might miss an edge case or two.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些优势和劣势确保你会在正确的情况下部署 vibe-coding 技巧。为了最大化成功，利用人工智能擅长的地方（已知模式），并将你的创造力应用于应用程序的独特部分。准备好在人工智能已知会挣扎的领域进行干预。例如，仔细审查它编写的任何安全敏感的代码，因为它可能遗漏了一些边缘情况。
- en: 'Use AI to complement human strengths: let it handle breadth (lots of code,
    boilerplate) while you handle depth (complex logic, architecture). Use it as a
    booster where it excels, and don’t be afraid to take the wheel on those tougher
    stretches of the road. This plays to the strengths of both and yields the best
    outcome. Knowing when to use AI and when to rely on human skill is what will make
    you a highly effective developer in this new era.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 利用AI来补充人类的优势：让它处理广度（大量代码、样板），而你则处理深度（复杂逻辑、架构）。在它擅长的领域使用它作为助推器，并且不要害怕在那些更艰难的道路上接管方向盘。这发挥了双方的优势，并产生最佳结果。知道何时使用AI以及何时依赖人类技能，将使你在这个新时代成为一个高效的开发者。
- en: 'Every new technology comes with its advantages and its caveats. As we embrace
    the productivity and creativity boost from AI-assisted development, it’s important
    to approach it with a nuanced understanding of its limitations and trade-offs.
    Key benefits include:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 每一项新技术都伴随着其优势和局限性。随着我们拥抱AI辅助开发带来的生产力和创造力提升，了解其局限性和权衡因素至关重要。主要好处包括：
- en: Faster development cycles
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 更快的开发周期
- en: Projects can move from concept to prototype to finished product more quickly.
    AI can generate scaffolding code (like setting up the boilerplate for a new project)
    in a flash, so you spend more time on the unique parts of your application.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 项目可以从概念快速过渡到原型，再到成品。AI可以瞬间生成脚手架代码（例如为新项目设置样板），这样你就有更多时间专注于应用程序的独特部分。
- en: Enhanced prototyping and experimentation
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 增强原型设计和实验
- en: Because the cost of trying something is lower (just describe what you want to
    the AI and get a quick draft), developers may feel freer to experiment. You can
    prototype multiple approaches to a problem by prompting the AI in different ways,
    then pick the best one. This iterative ideation can lead to more creative solutions.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于尝试某件事的成本较低（只需向AI描述你想要的内容并快速获得草稿），开发者可能会感到更自由地进行实验。你可以通过以不同的方式提示AI来原型化解决问题的多种方法，然后选择最好的一个。这种迭代式构思可以导致更具创造性的解决方案。
- en: Knowledge at your fingertips
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 知识触手可及
- en: LLMs are trained on a vast corpus of programming knowledge. It often “knows”
    obscure APIs or error message solutions. In practice, it can surface solutions
    or ideas you might not have thought of, making you a more effective problem solver.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 大型语言模型（LLMs）是在庞大的编程知识库上训练的。它通常“知道”一些不为人知的API或错误信息解决方案。在实践中，它可以提出你未曾想到的解决方案或想法，使你成为一个更有效的解决问题者。
- en: Consistency and standardization
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性和标准化
- en: In team settings, an AI assistant can help enforce coding standards and best
    practices by generating code in a consistent style. If configured with your project’s
    style guide, it could ensure everyone’s code follows similar patterns. Even without
    explicit training, AI models often produce idiomatic code (since they learned
    from millions of examples). This can reduce the effort involved in code reviews,
    since its functions may look familiar and adhere to common conventions by default.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队环境中，AI助手可以通过以一致的风格生成代码来帮助执行编码标准和最佳实践。如果配置了项目的风格指南，它可以确保每个人的代码都遵循类似的模式。即使没有明确的训练，AI模型通常也会产生符合习惯用法的代码（因为它们从数百万个示例中学习）。这可以减少代码审查的努力，因为其功能可能看起来很熟悉，并且默认遵循常见约定。
- en: 'Some of the limitations and trade-offs to consider include:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一些限制和权衡因素包括：
- en: Variable output quality
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 可变输出质量
- en: These models are not infallible. They might produce code that looks correct
    but has subtle bugs or inefficiencies. They might choose an outdated approach
    because their training data included a lot of older code. As a developer, you
    must remain vigilant. Just as you wouldn’t copy-paste code from the internet without
    understanding it, you shouldn’t accept AI code thoughtlessly. [Part II](part02.html#part02)
    of this book will discuss techniques to validate and test AI-generated code thoroughly.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型并非完美无缺。它们可能生成看起来正确但实际上存在细微错误或不效率的代码。它们可能会选择过时的方法，因为它们的训练数据包含大量旧代码。作为开发者，你必须保持警惕。正如你不会在没有理解的情况下从互联网上复制粘贴代码一样，你不应该无思考地接受AI生成的代码。[本书第二部分](part02.html#part02)将讨论验证和彻底测试AI生成代码的技术。
- en: Ambiguity in prompts leads to ambiguity in code
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 提示中的歧义会导致代码中的歧义
- en: If your prompt is underspecified, the AI has to guess your intent—and it might
    guess wrong. For example, if you tell it to “sort a list of names,” it might default
    to alphabetical sorting, but maybe you meant something else (like sorting by the
    length of the name). The AI won’t know the difference unless you clarify it. This
    is why specificity in prompts ([Chapter 2](ch02.html#ch02_the_art_of_the_prompt_communicating_effectively_w_1752630042971067)’s
    topic) is vital—you’ll learn to anticipate what details you need to spell out.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的提示不够具体，AI必须猜测你的意图——它可能会猜错。例如，如果你告诉它“对一组名字进行排序”，它可能会默认按字母顺序排序，但也许你指的是其他排序方式（比如按名字长度排序）。除非你澄清，否则AI不会知道区别。这就是为什么提示的具体性（[第2章](ch02.html#ch02_the_art_of_the_prompt_communicating_effectively_w_1752630042971067)的主题）至关重要——你将学会预测需要明确说明哪些细节。
- en: Overreliance and skill atrophy
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 过度依赖和技能退化
- en: If new developers always rely on AI to write their code, will they develop the
    same depth of understanding of algorithms and debugging? There’s a risk of skill
    atrophy, similar to how relying on GPS for navigation might weaken your own sense
    of direction. To mitigate this, it’s important to use AI as a learning tool (pay
    attention to the code it provides and ask why) and sometimes practice coding without
    it to ensure you retain your fundamental skills.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新开发者总是依赖AI来编写他们的代码，他们是否会发展出对算法和调试的同样深入理解？存在技能退化的风险，这类似于过度依赖GPS导航可能会削弱你自己的方向感。为了减轻这种风险，重要的是将AI作为学习工具使用（注意它提供的代码并询问原因），有时在没有它的帮助下进行编码练习，以确保你保留基本技能。
- en: Privacy and security concerns
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 隐私和安全问题
- en: Using cloud-based AI coding tools often means sending your code (which might
    be proprietary or sensitive) to a third-party service for analysis. Companies
    need to consider this. Many tools are addressing it by allowing on-premises models
    or giving assurances about not storing code, but it’s still a consideration. Also,
    there’s a risk that AI might inadvertently generate code that is very similar
    to something in its training data, which could be under an open source license
    (like GPL). While unlikely (and measures are in place to prevent verbatim long
    outputs), it highlights the need to review and understand what the AI produces
    before integrating it. [Chapter 8](ch08.html#ch08_security_maintainability_and_reliability_1752630044621528)
    dives into questions of security and reliability.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于云的AI编码工具通常意味着将你的代码（可能是专有或敏感的）发送到第三方服务进行分析。公司需要考虑这一点。许多工具通过允许本地模型或提供不存储代码的保证来解决这个问题，但这仍然是一个需要考虑的因素。此外，存在AI无意中生成与训练数据中某些内容非常相似的代码的风险，这些内容可能处于开源许可之下（如GPL）。虽然这种情况不太可能发生（并且有措施防止直接输出），但它突出了在集成之前审查和理解AI生成内容的需求。[第8章](ch08.html#ch08_security_maintainability_and_reliability_1752630044621528)深入探讨了安全和可靠性问题。
- en: Bias in AI output
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: AI输出中的偏见
- en: AI models can reflect biases present in their training data. In a coding context,
    this might be as benign as preferring certain variable names or as significant
    as using examples that assume particular user attributes. For instance, it might
    use `foo/bar` for every example variable (because many examples did), or it might
    assume things about user locales. It’s usually not a huge issue in code generation
    compared to other AI applications, but it’s worth being aware of this possibility.
    More subtly, the AI might be biased toward solutions it saw more often, even if
    those aren’t the best for your case. [Chapter 9](ch09.html#ch09_the_ethical_implications_of_vibe_coding_1752630044848930)
    discusses bias and other ethical considerations.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: AI模型可以反映出其训练数据中存在的偏见。在编码环境中，这可能是从偏好某些变量名到使用假设特定用户属性的示例，程度不同。例如，它可能对每个示例变量使用`foo/bar`（因为许多示例都是这样），或者它可能对用户地区有所假设。与其他AI应用相比，在代码生成中这通常不是一个大问题，但了解这种可能性是值得的。更微妙的是，AI可能倾向于它看到更频繁的解决方案，即使这些解决方案可能不是你案例中最好的。
    [第9章](ch09.html#ch09_the_ethical_implications_of_vibe_coding_1752630044848930)讨论了偏见和其他伦理考量。
- en: Human factors and trust
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 人类因素和信任
- en: Not all developers are immediately comfortable with this style of work. Coding
    has a certain pleasure and artistry to it, and some may feel that is diminished
    by AI involvement. There can also be an initial lack of trust—“Did it really do
    this right?”—which only good practices and time can overcome. Teams adopting AI
    should allow a period of adjustment and encourage sharing of experiences and tips.
    Over time, as with any tool, most will find a balance where the AI’s contributions
    are valued and human expertise focuses on what humans do best.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有开发者一开始都适应这种工作风格。编码有其特定的乐趣和艺术性，有些人可能会觉得这种乐趣因为AI的介入而减少了。也可能存在最初的信任缺失——“它真的这样做对了吗？”——这只有良好的实践和时间才能克服。采用AI的团队应该允许一段时间的调整，并鼓励分享经验和技巧。随着时间的推移，就像任何工具一样，大多数人会发现一个平衡点，在那里AI的贡献受到重视，而人类的专长则集中在人类最擅长的事情上。
- en: Summary and Next Steps
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和下一步
- en: 'The vibe shift toward programming with intent offers tremendous potential to
    make software development faster, more accessible, and in many ways more enjoyable.
    But realizing that potential means understanding the new dynamics: how to communicate
    with AI effectively, how to verify its output, and how to integrate it responsibly
    into your development process.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 趋向于有意图的编程的感觉转变为软件开发提供了巨大的潜力，使其更快、更易于访问，并在许多方面更加有趣。但实现这一潜力意味着理解新的动态：如何有效地与AI沟通，如何验证其输出，以及如何负责任地将它整合到你的开发过程中。
- en: 'My perspective, forged from working with these tools and observing many projects,
    is that AI’s best use lies in combining the creative “vibe” with solid engineering
    hygiene. Encourage the wild ideas and rapid drafts that AI can offer—those are
    the new superpowers at our disposal. But channel them with the wisdom that software
    development has accumulated over decades: the importance of planning, testing,
    and understanding what you build.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我的观点，是通过使用这些工具并观察许多项目形成的，那就是AI的最佳用途在于将创造性的“感觉”与坚实的工程卫生相结合。鼓励AI提供的狂野想法和快速草稿——这些是我们可利用的新超级力量。但要用软件开发几十年来积累的智慧来引导它们：规划、测试和了解你所构建的内容的重要性。
- en: 'When we strike that balance, we get the best of both worlds. We get software
    that is built faster and potentially more imaginatively but also software that
    we trust, maintain, and grow with confidence. That, ultimately, is how we elevate
    our craft in the age of AI: not by choosing vibes over engineering, or vice versa,
    but by mastering the whole spectrum between.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们达到这种平衡时，我们就能得到两者的最佳结合。我们得到的是构建更快、可能更具想象力的软件，同时也是我们信任、维护和有信心增长的软件。最终，这就是我们在AI时代提升我们技艺的方式：不是通过选择感觉胜过工程，或者相反，而是通过掌握两者之间的整个光谱。
- en: Next, [Chapter 2](ch02.html#ch02_the_art_of_the_prompt_communicating_effectively_w_1752630042971067)
    explores the art of crafting prompts and collaborating with AI. With the foundational
    concepts from this chapter in mind, you’re ready to explore the practical side
    of this new programming era. This will set the stage for hands-on examples and
    deeper prompting techniques in subsequent chapters.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，[第二章](ch02.html#ch02_the_art_of_the_prompt_communicating_effectively_w_1752630042971067)探讨了制作提示和与AI协作的艺术。带着本章的基础概念，你准备好探索这个新编程时代的实际应用。这将为后续章节中的实际示例和更深入的提示技术奠定基础。
