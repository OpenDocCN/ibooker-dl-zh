["```py\n@startgantt\nsaturday are closed  #1\nsunday are closed    \n\nheader ACH Dashboard Enhancements - Round 1 #2\n\nProject starts 2024-08-01 \n-- Exceptions Enhancement -- #3\n[Database Design] starts 2024-08-01 and lasts 2 days #4\n[Exception API Design] starts at [Database Design]'s#5\n➥ end and lasts 2 days  #5\n[ACH Processor] starts at [Exception API Design]'s #5\n➥ end and lasts 3 days #5\n[UI Exception Changes] starts at [ACH Processor]'s #5\n➥ end and lasts 3 days #5\n\n-- UI Enhancement –\n[Update fields screen] starts at 2024-08-01 and lasts 3 days\n[Update batch screen] starts at [Update fields screen]'s\n➥ end and lasts 3 days\n[Sprint Complete] happens at [UI Exception Changes]'s end\n@endgantt\n```", "```py\n  Scenario: Create an ACH file with a single batch and a single debit\n    Given I want to create an ACH file named \"ppd-single-debit.ach\"\n    And I want to have an immediate destination of \"123456789\"\n    And I want to have an immediate origin of \"987654321\"\n    And I want to have 1 batch with ACH debits only\n➥ and a standard entry class code of \"PPD\"\n    And I want 1 entries per batch with random amounts between 100 and 100\n    And I want to use individual names of \"John Doe\"\n    And I want to have company name \"My Company\"\n➥ and company id \"1234567890\"\n    When my ACH is created\n    Then I should have a file named \"ppd-single-debit.ach\"\n    And there should be 1 batch in the file\n    And there should be 1 entries in the file\n```", "```py\nCREATE TYPE ach_exception_severity AS ENUM\n➥ ('error', 'warning', 'info'); #1\n\nCREATE TABLE ach_exception_codes (\n    ach_exception_codes_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    exception_code VARCHAR(3) NOT NULL UNIQUE,\n    exception_severity ACH_EXCEPTION_SEVERITY NOT NULL, #2\n    exception_description VARCHAR(255) NOT NULL\n);\n```", "```py\nCREATE TABLE ach_exceptions (\n    ach_exceptions_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    ach_files_id UUID NOT NULL \n       REFERENCES ach_files(ach_files_id) \n       ON DELETE CASCADE ON UPDATE CASCADE,\n    ach_records_type_5_id UUID    #1\n       REFERENCES ach_records_type_5(ach_records_type_5_id)  #1\n       ON DELETE CASCADE ON UPDATE CASCADE,  #1\n    ach_records_type_6_id UUID REFERENCES     #1\n       ach_records_type_6(ach_records_type_6_id)   #1\n       ON DELETE CASCADE ON UPDATE CASCADE,  #1\n    record_number NUMERIC NOT NULL,\n    exception_code VARCHAR(3) NOT NULL REFERENCES  #2\n    ach_exception_codes(exception_code)              #2\n  ON UPDATE CASCADE   \n);\n```", "```py\nINSERT INTO ach_exception_codes (exception_code,#1\n  exception_severity, exception_description)  #2\nVALUES ('001', 'error', 'Record length is not 94 characters');  #2\nINSERT INTO ach_exception_codes\n (exception_code, exception_severity, exception_description)\n VALUES ('002', 'error', 'Record type was an unexpected value');\n…\n```", "```py\nEXECUTE (\n   SELECT 'TRUNCATE TABLE ' || \n          string_agg(quote_ident(table_name), ', ') || \n          ' CASCADE'\n   FROM information_schema.tables\n   WHERE table_schema = 'public'\n   AND table_type = 'BASE TABLE'\n   AND table_name NOT IN ( 'ach_exception_codes', #1\n                       'ach_recovery_options',    #1\n                       'bank_routing_numbers')   \n);\n```", "```py\nCREATE TABLE ach_recovery_options (\n    ach_recovery_options_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    exception_code VARCHAR(3) NOT NULL REFERENCES  #1\n       ach_exception_codes(exception_code) ON UPDATE CASCADE, \n  recovery_option VARCHAR NOT NULL #2\n);\n```", "```py\nINSERT INTO ach_recovery_options (exception_code, recovery_option)\n➥ VALUES ('001', 'Request a corrected file from the originator');\nINSERT INTO ach_recovery_options (exception_code, recovery_option)\n➥ VALUES ('002', 'Request a corrected file from the originator');\nINSERT INTO ach_recovery_options (exception_code, recovery_option)\n➥ VALUES ('004', 'Specify a new File ID Modifier');\n```", "```py\ndef test_incorrect_immediate_destination(parser):\n    ach_filename = \"invalid_immediate_destination.ach\" #1\n    dir_path = os.path.dirname(os.path.realpath(__file__))  #2\n    file_path = os.path.join(dir_path, \"data\", \"bad_files\",  #2\n                                             ach_filename)  #2\n\n    expected_exceptions_count: int = 1 \n    expected_exceptions_code: str = #2\n       AchExceptions.INVALID_IMMEDIATE_DESTINATION.value\n\n    ach_files_id = \n       SqlUtils.create_ach_file_record(filename, \"123456789\") #3\n\n    parser.parse(ach_files_id, file_path) #4\n    exceptions = SqlUtils.get_exceptions() #5\n\n    assert (          #6\n        len(exceptions) == expected_exceptions_count #6\n    ), f\"Expected {expected_exceptions_count}, #6\n➥ but got {len(exceptions)}\"  #6\n #6\n    assert (  #6\n        exceptions[0] == expected_exceptions_code #6\n    ), f\"Expected {expected_exceptions_code}, #6\n➥ but got {exceptions[0]}\"  #6\n```", "```py\ndef test_incorrect_file_id_modifier(parser):\n    process_file_and_verify_exception(       #1\n       ach_filename = \"invalid_file_id.ach\",  #1\n       expected_exceptions_count = 1,     #1\n       expected_exceptions_code =  #1\n          AchExceptions.INVALID_FILE_ID_MODIFIER.value,  #1\n       parser = parser)  #1\n\ndef process_file_and_verify_exception(ach_filename: str, #2\n   expected_exceptions_count: int,   #2\n   expected_exceptions_code: str,  #2\n #2\nparser: AchFileProcessor):  #2\n…\n```", "```py\nclass AchExceptionSchema(BaseModel):\n    ach_exceptions_id: Optional[UUID4] = Field(…)\n    ach_files_id: UUID4 = Field(…)  #1\n    ach_batch_id: Optional[UUID4] = Field(…)\n    ach_entry_id: Optional[UUID4] = Field(…)\n    record_number: int = Field(…) #2\n    exception_code: str = Field(…) #3\n```", "```py\nclass AchExceptionsSql: #1\n    @staticmethod\n    def insert_record(ach_file_exception: AchExceptionSchema) -> UUID:\n        with get_db_connection() as conn:\n            result = conn.execute(\n                \"\"\"\n           INSERT INTO ach_exceptions #2\n➥ (ach_files_id, record_number,  #2\n              exception_code)  #2\n           VALUES (%(ach_files_id)s,   #2\n➥%(record_number)s, %(exception_code)s)  #2\n           RETURNING ach_exceptions_id #2\n            \"\"\",\n                ach_file_exception.model_dump()\n            )\n\n        return result.fetchone()[0] #3\n\n    @staticmethod\n    def get_record(ach_exception_id: UUID) -> AchExceptionSchema:\n        with get_db_connection\n➥(row_factory=class_row(AchExceptionSchema)) as conn:\n            result = conn.execute(\n                \"\"\"\n                SELECT * FROM ach_exceptions #4\n                WHERE ach_exceptions_id = %s\n                \"\"\",\n                [ach_exception_id]\n            )\n\n            return result.fetchone()\n```", "```py\n    @staticmethod #1\n    def _add_exception(exception: AchExceptionSchema, #1\n➥ unparsed_record=None) -> None: \n        sql = AchExceptionsSql()\n        sql.insert_record(exception)\n        if unparsed_record is not None: #2\n            sql_invalid_rec = AchRecordsSqlTypeInvalid()  #2\n            sql_invalid_rec.insert_record #2\n➥(AchRecordTypeInvalidSchema(  #2\n                ach_files_id=exception.ach_files_id,  #2\n                unparsed_record=unparsed_record,  #2\n                sequence_number=exception.record_number,  #2\n            ))\n```", "```py\n    @staticmethod\n    def parse_file_header(\n            ach_records_type_1_id: UUID, record: str\n    ) -> AchFileHeaderSchema:\n        try:  #1\n            return AchFileHeaderSchema(  #1\n…  #1\n            ) \n        except ValidationError as e: #2\n            raise AchParsingValidationError( #3\n   message='Error parsing file header',  #3\n   validation_errors=e.errors())  \n```", "```py\nclass AchParsingValidationError(Exception): #1\n…\n    def get_exception_codes(self) -> list[str]: #2\n        exception_codes = []   \n        for error in self.validation_errors: #3\n            if error['loc'][0] == 'file_id_modifier': #4\nexception_codes.append(AchExceptions.  #4\n➥INVALID_FILE_ID_MODIFIER.value)  #4\n            elif error['loc'][0] == 'immediate_destination':   #4\nexception_codes.append(AchExceptions.  #4\n➥INVALID_IMMEDIATE_DESTINATION.value)  #4\n        return exception_codes\n```", "```py\ncase \"1\":\n   ach_record = AchRecordType1Schema(\n      ach_files_id=ach_file_id,\n      unparsed_record=line,\n      sequence_number=sequence_number)\n   ach_record_id = AchRecordsSqlType1().insert_record(ach_record)\n   current_file_header_id = ach_record_id\n   try:  #1\n      self._parse_file_header(ach_record_id, line)  \n   except AchParsingValidationError as e:  #2\n      for exception_code in e.get_exception_codes():  #2\n         self._add_exception(AchExceptionSchema(  #2\n            ach_files_id=ach_file_id,   #2\n            record_number=sequence_number,  #2\n            exception_code=exception_code,  #2\n            ))  #2\n```", "```py\nfile_id_modifier: Annotated[str, \n   StringConstraints(\n      pattern=r'^[A-Z0-9]$', #1\n      min_length=1, #2\n      max_length=1)] \n```", "```py\n@field_validator('immediate_destination') #1\n@classmethod \ndef validate_immediate_destination(cls, v):\n  try:\n      if BankRoutingSql().valid_bank_routing_number(v): #2\n         return v\n      else:  #3\n         raise ValueError('immediate_destination #3\n➥ is not a valid routing number') \n   except Exception: #4\n      raise ValueError('Unable to validate #4\n➥ immediate_destination') \n```", "```py\nScenario: I should get a file even when\n➥ it has an exception #1\n   Given that I have a clean database #2\n   And that I have posted the file \"invalid_file_id.ach\" \n   When I request a list of files #3\n   Then I should have a file that includes the\n➥ file \"invalid_file_id.ach\" #4\n```", "```py\nSELECT af.ach_files_id AS id,\n                       af.file_name AS filename,\n                       af.created_at AS date,    \n                       afh.immediate_origin_name AS originator,                 \n                       afcr.total_debit_entry_dollar_amount AS debit_total, \n                       afcr.total_credit_entry_dollar_amount\n➥ AS credit_total,\n                FROM ach_files AS af\n                INNER JOIN ach_records_type_1 AS art1 USING (ach_files_id)\n                INNER JOIN ach_records_type_9 AS art9 USING\n                                     (ach_records_type_1_id)\n                INNER JOIN ach_file_headers AS afh USING  #1\n                                     (ach_records_type_1_id)  #2\n                INNER JOIN ach_file_control_records AS afcr USING #2\n                                           (ach_records_type_9_id)   #2\n                ORDER BY af.created_at DESC\n```", "```py\nINNER JOIN ach_records_type_1 AS art1 USING (ach_files_id)\nINNER JOIN ach_records_type_9 AS art9 USING (ach_records_type_1_id)sd\nLEFT JOIN ach_file_control_records AS afcr#1\n➥ USING (ach_records_type_9_id)  #1\nLEFT JOIN ach_file_headers AS afh #1\n➥ USING (ach_records_type_1_id) \nORDER BY af.created_at DESC\n```", "```py\nFeature: Exceptions returned for files\n  Test the functionality of the exception returned for loaded ACH files\n\n  Scenario: I get a list of exceptions for a file #1\n    Given that I have a clean database #2\n    And that I have posted the file \"invalid_file_id.ach\" \n    When I request a list of exceptions for the#3\n➥ file \"invalid_file_id.ach\"  #3\n    Then I should receive an error of \"004\" and a #3\n➥ message of \"Invalid File ID Modifier\" \n```", "```py\n@when(parsers.parse('I request a list of exceptions\n➥ for the file \\\"{filename}\\\"'))\ndef get_list_of_exceptions_for_file(api_response, filename):\n    response = client.get(\"/api/v1/files/\")  #1\n    assert response.status_code == 200, response.text\n    file_id = response.json()[0][\"id\"] #2\n    response = client.get #3\n➥(f\"/api/v1/files/{file_id}/exceptions\")  #4\n    assert response.status_code == 200, response.text\n  api_response[\"response\"] = response.json() #4\n```", "```py\n@then(parsers.parse('I should receive an error \n➥ of \\\"{error_code}\\\" and a message of \\\"{error_message}\\\"')) \ndef check_error_code_exists_on_response(error_code, \n➥ error_message, api_response):\n    assert any( \n        error_code == response[\"exception_code\"]\n➥ for response in\napi_response[\"response\"] \n    ), f\"Expected {error_code} in\" \n➥ f\" {api_response['response']}\" \n    assert any(#1\n        error_message == response[\"description\"]\n➥ for response in api_response[\"response\"]\n    ), f\"Expected {error_message} in\" f\" {api_response['response']}\"\n```", "```py\n@router.get(   #1\n    path=\"/{file_id}/exceptions\",  #1\n    response_model=list[AchExceptionsResponse],  #1\n    summary=\"Retrieve ACH File Exceptions\",  #1\n    description=\"Retrieve the exceptions in an ACH file.\",  #1\n    response_description=  #1\n➥\"The exceptions in the requested ACH file.\",  #1\n    tags=[\"ACH Files\"],  #1\n)\nasync def read_exceptions_for_file(file_id: UUID) ->  #2\nlist[AchExceptionsResponse]:  #2\n    return AchExceptionsSql() #2\n➥.get_exceptions_response(file_id)  #2\n```", "```py\n    @staticmethod\n    def get_exceptions_response(ach_files_id: UUID = None) -> list[AchExceptionsResponse]:\n        query_parameters = []\n        sql = \"\"\"\n                    SELECT #1\n                        afe.ach_exceptions_id AS id, \n                        afe.ach_files_id AS file_id, \n                        afe.ach_records_type_5_id AS batch_id, \n                        afe.ach_records_type_6_id AS entry_id, \n                        afe.record_number AS record_number, \n                        afe.exception_code AS exception_code, \n aec.exception_description AS description\n FROM ach_exceptions AS afe #2\n INNER JOIN ach_exception_codes AS aec #3\n USING (exception_code) \n  \"\"\"\n        if ach_files_id is not None:    #4\n            sql += \" WHERE afe.ach_files_id = %s\"  #4\n            query_parameters.append(ach_files_id)  #4\n\n        with get_db_connection(row_factory=class_row(AchExceptionsResponse)) as conn:\n            result = conn.execute(sql, query_parameters) #5\n            return result.fetchall() \n```", "```py\n[{…, 'batch_id': None, 'entry_id': None,\n➥ 'record_number': 1, 'exception_code': '004',…}]\n```", "```py\n@router.get(\n    path=\"/{file_id}/exceptions\",\n    response_model=list[AchExceptionsResponse],\n    summary=\"Retrieve ACH File Exceptions\",\n    description=\"Retrieve the exceptions in an ACH file.\",\n    response_description=\"The exceptions in the requested ACH file.\",\n response_model_exclude_none=True, #1\n    tags=[\"ACH Files\"],\n)\n```", "```py\nScenario: I get the unparsed record for a\n➥ specific exception #1\n    Given that I have a clean database\n    And that I have posted the file \"invalid_file_id.ach\"\n    When I request the unparsed record for the exception code \"004\"\n    Then I should receive an\n➥ unparsed record of \"1…i…XXXXX\" #2\n```", "```py\n@when('I request the unparsed record for the exception code \"004\"')\ndef request_unparsed_record(api_response):\n    response = client.get(\"/api/v1/files/\") #1\n    assert response.status_code == 200, response.text #1\n    file_id = response.json()[0][\"id\"]  #1\n    response = client #1\n➥.get(f\"/api/v1/files/{file_id}/exceptions\")  #1\n    assert response.status_code == 200, response.text #1\n exception_id = response.json()[0][\"id\"] #1\n response = #1\n client.get(f\"/api/v1/files/{file_id}  #1\n➥/exceptions/{exception_id}\")  #1\n assert response.status_code == 200, response.text #1\n  api_response[\"response\"] = response.json() #2\n```", "```py\nExpected :200\nActual   :404\n```", "```py\n<ListItemButton onClick={() => route.push(\"/exceptions\")}>\n   <ListItemIcon>\n      <Error/>\n   </ListItemIcon>\n   <ListItemText primary=\"Exceptions\"/>\n</ListItemButton>\n```", "```py\n…\n    const [entries, setEntries] = useState<AchExceptionsResponse[]>([]);\n…\n    useEffect(() => {\n        const apiUrl = process.env #1\n➥.NEXT_PUBLIC_API_URL ?? ''; \n        axios.get<AchExceptionsResponse[]> #2\n➥(`${apiUrl}/files/exceptions`,  #2\n            {    #2\n            headers: {  #2\n                'Content-Type': 'application/json' #2\n            }  #2\n        })  #2\n            .then(response => {  #2\n                console.log(`Response data \n${JSON.stringify(response.data)}`);  #2\n                setEntries(response.data);  #2\n            })  #2\n            .catch(error => {  #2\n                console.log(error);  #2\n            });  #2\n    }, []); #2\n… #2\n```", "```py\n…\n    const columns: GridColDef[] = [\n        {field: 'view', headerName: 'View', \n➥ sortable: false, width: 10, renderCell: (params) => (\n                <IconButton  #1\n                    onClick={(e) => {  #1\n                        e.preventDefault();  #1\n                        setIsOpen(true);  #1\n                    }}  #1\n                    color=\"primary\"  #1\n                    ▶ #1\n <InfoIcon /> #1\n </IconButton> #1\n )},\n  {field: 'file_name', headerName: 'Filename', width: 150},\n        {field: 'created_at', headerName: 'Date',\n➥ width: 150, valueGetter: (params) => convertDateFormat(params.value)},\n        {field: 'record_number', headerName: 'Record Number', width: 150},\n        {field: 'exception_code', headerName: 'Code', width: 10},\n        {field: 'description', headerName: 'Description', width: 300},\n    ]\n…\n<DataGrid columns={columns} rows={entries}/> #2\n… \n            <AlertMessage open={isOpen} setOpen={setIsOpen} #3\n      message=\"Exception Record\" title=\"Record Exception\" /> \n…\n```", "```py\n<IconButton\n   onClick={(e) => {\n      e.preventDefault();\n      const fileId = params.row.file_id; #1\n      const exceptionId = params.row.id; \n      const apiUrl = process.env.NEXT_PUBLIC_API_URL ?? ''; #2\n      axios.get<AchExceptionDetailsResponse>( #3\n         `${apiUrl}/files/${fileId}/exceptions/ \n➥${exceptionId}`, { \n         headers: { \n            'Content-Type': 'application/json'\n         } \n      }) \n      .then(response => { #4\n         setUnparsedRecord(response.data.unparsed_record);  #4\n         setIsOpen(true);  #4\n      })  #4\n      .catch(error => { #5\n         setUnparsedRecord(error.message)  #5\n         setIsOpen(true);  #5\n      });  #5\n   }}\ncolor=\"primary\">\n…\n</IconButton>\n```", "```py\n  Scenario: I should not have any exceptions\n    Given that I have a clean database\n    And that I have posted the file \"sample.ach\"\n    When I request a list of files\n    Then the has_exceptions field should be False\n\n  Scenario: I should get a file even when it has an exception\n    Given that I have a clean database\n    And that I have posted the file \"invalid_file_id.ach\"\n    When I request a list of files\n    Then I should have a response that includes\n➥ the file \"invalid_file_id.ach\"\n    And the has_exceptions field should be True\n```", "```py\nWITH exceptions AS (  #1\n   SELECT DISTINCT(afe.ach_files_id)  #1\n   FROM ach_exceptions AS afe #1\n)  #1\nSELECT af.ach_files_id AS id,\n       af.file_name AS filename,\n       af.created_at AS date,    \n       afh.immediate_origin_name AS originator,                 \n       afcr.total_debit_entry_dollar_amount AS debit_total, \n       afcr.total_credit_entry_dollar_amount AS credit_total,\n       CASE #2\n          WHEN exceptions.ach_files_id IS NOT NULL THEN TRUE #3\n       ELSE FALSE #3\n       END AS has_exceptions #3\n       FROM ach_files AS af\nINNER JOIN ach_records_type_1 AS art1 USING (ach_files_id)\nINNER JOIN ach_records_type_9 AS art9 USING (ach_records_type_1_id)\nLEFT JOIN ach_file_headers AS afh USING (ach_records_type_1_id)\nLEFT JOIN ach_file_control_records AS afcr USING (ach_records_type_9_id) \nLEFT JOIN exceptions USING (ach_files_id) #3\nORDER BY af.created_at DESC\nLIMIT %s\nOFFSET %s   \n```", "```py\nconst transformedData: AchFiles[] = response.data.map\n➥((row: AchFilesResponse) => ({\n   id: row.id,\n   date: row.date,\n   filename: row.filename,\n   originator: row.originator,\n   creditTotal: new Decimal(row.credit_total),\n   debitTotal: new Decimal(row.debit_total),\n hasExceptions: row.has_exceptions #1\n}));\n```", "```py\nimport {ErrorOutlineOutlined} from \"@mui/icons-material\";\n…\n<TableCell>\n   <Link onClick={() => route.push(`/fileDetails/${file.id}`)} \n         sx={{ cursor: 'pointer' }}>{file.filename}</Link>\n {file.hasExceptions &&\n➥ <ErrorOutlineOutlined color=\"error\" />} #1\n</TableCell>\n```", "```py\n…\ninterface ExceptionsProps {\n    exceptions: AchExceptionsResponse[];\n}\n\nexport default function Exceptions({exceptions}:\n➥ Readonly<ExceptionsProps>) {\n\n    const [isOpen, setIsOpen] = useState(false);\n    const [unparsedRecord, setUnparsedRecord] = useState('');\n    const columns: GridColDef[] = [\n…\n           <DataGrid columns={columns} rows={exceptions}/>\n…\n           <AlertMessage open={isOpen} setOpen={setIsOpen}\n➥ message={unparsedRecord} title=\"Unparsed Record\" />\n…\n```", "```py\n…\nimport Exceptions from \"@/app/components/Exceptions\";\nimport {AchExceptionsResponse} from \"@/app/interfaces/AchExceptionsResponse\"; \n…  axios.get<AchExceptionsResponse[]>(`${apiUrl}/files/\n➥${fileId}/exceptions`, {\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        })\n            .then(response => {\n                console.log(`Response data ${JSON.stringify(response.data)}`);\n                setExceptions(response.data); #1\n            })\n            .catch(error => {\n                console.log(error);\n });\n\n }, []);\n…\n <Exceptions exceptions={exceptions} /> #2\n…\n```", "```py\nexport default function AchBatchStatistics({entries}:\n➥ Readonly<AchBatchStatisticsProps>) {\n\n    const computedBatchStatistics = #1\n➥ computeBatchStatistics(entries);  #1\n    const computedBatchTotals =  #1\n➥ computeBatchTotals(entries);  #1\n    const listItems =  #1\n➥ createListItems(computedBatchStatistics);  #1\n\n    return (\n        <>\n           <Title>Batch Statistics</Title>\n           <List dense={true}>\n              <ListItem key=\"creditTotal\">\n                 <ListItemText \n                    primary=\"Credit Total\" \n                secondary={`${formatCurrency(computedBatchTotals.credit)}`} \n                 />\n              </ListItem>\n              <ListItem key=\"debitsTotal\">\n                 <ListItemText\n                    primary=\"Debit Total\" \n                secondary={`${formatCurrency(computedBatchTotals.debit)}`} \n                 />\n              </ListItem>\n              <ListItem key=\"otherTotal\">\n                 <ListItemText \n                    primary=\"Other Total\" \n                 secondary={`${formatCurrency(computedBatchTotals.other)}`} \n                 />\n              </ListItem>\n                 {listItems} #2\n              </List>\n        </>\n    );\n}\n```", "```py\nfunction computeBatchTotals\n➥(entries: AchBatchEntriesResponse[]): BatchTotals {\n    const totals: BatchTotals = {  #1\n        debit: new Decimal(0),  #1\n        credit: new Decimal(0),  #1\n        other: new Decimal(0)  #1\n    };  #1\n    entries.forEach(entry => {\n        const cleanAmount = entry.amount.replace(/[$,]/g, ''); #2\n        const amount = new Decimal(cleanAmount);\n        if (entry.transaction_code === 22) {\n            totals.debit = totals.debit.plus(amount);\n        } else if (entry.transaction_code === 27) {\n            totals.credit = totals.credit.plus(amount);\n        } else {\n            totals.other = totals.other.plus(amount);\n        }\n    });\n    return totals; #3\n\n}\n```", "```py\nfunction computeBatchStatistics\n➥(entries: AchBatchEntriesResponse[]):\n➥ Map<string, BatchStatistics> {\n    const countMap = new Map<string, BatchStatistics>(); #1\n    entries.forEach(entry => {  #2\n        const cleanAmount = entry.amount.replace(/[$,]/g, ''); #3\n        const stats = countMap.get(entry.transaction_description)  #4\n➥ || { count: 0, amount: new Decimal(0) }; \n        stats.count += 1; #5\n        stats.amount = stats.amount.plus(cleanAmount); #6\n        countMap.set(entry.transaction_description, stats); #7\n    });\n    return countMap;\n}\n```", "```py\n…\ninterface BatchStatistics { #1\n    count: number;  #1\n    amount: Decimal;  #1\n}  #1\n…\nfunction createListItems\n➥(entries: Map<string, BatchStatistics>): React.ReactNode[] {\n    const listItems: React.ReactNode[] = []; #2\n    entries.forEach((entry: BatchStatistics, key: string) => {\n        const listItem = (<ListItem key={key}> #3\n            <ListItemText primary={key}   #3\n                  secondary={`Count: ${entry.count} Amount:  #3\n${formatCurrency(entry.amount)}`} />  #3\n        </ListItem>); \n        listItems.push(listItem); #4\n    });\n    return listItems; #5\n}\n```", "```py\n…\ndescribe('Compute Batch Totals', () => {\n   it('Has a debit for 1', () => {\n      const achBatchEntriesResponse: #1\n➥ AchBatchEntriesResponse[] = [{  #1\n         id: 'test1',  #1\n         transaction_code: 27,  #1\n         application: \"Checking\",  #1\n         transaction_description: \"Debit\",  #1\n         amount: \"1.00\",  #1\n         individual_name: \"John Doe\",  #1\n         account_number_last_4: \"*********1234\",  #1\n         addenda_count: 0 #1\n      }]  #1\n      const result = computeBatchTotals #2\n➥(achBatchEntriesResponse) \n      expect(result.debit.toNumber())   #3\n                         .toBe(new Decimal(\"1\").toNumber()) \n})\n```", "```py\nFeature: The /files/{fileId}/batches/{batchId}/entries endpoint\n  Test returning entries for a batch\n\n  Scenario: I want to check the entries for a Checking Application\n    Given that I have a clean database\n    And that I have posted the file \"ppd-single-credit.ach\"\n    When I request entries for a file and batch\n    Then I should have a response that includes all\n➥ applications of \"Checking\"\n```", "```py\n…\nscenarios(\"../features/ach_entries_endpoint.feature\")\n…\n@when('I request entries for a file and batch')\ndef request_unparsed_record(api_response):\n    response = client.get(\"/api/v1/files/\")\n assert response.status_code == 200, response.text\n file_id = response.json()[0][\"id\"]\n response = client.get(f\"/api/v1/files/{file_id}/batches\")\n assert response.status_code == 200, response.text\n  batch_id = response.json()[0][\"id\"]\n    response = client.get(f\"/api/v1/files/{file_id}/\n➥batches/{batch_id}/entries\")\n    assert response.status_code == 200, response.text\n    api_response[\"response\"] = response.json()\n\n@then(parsers.parse('I should have a response\n➥ that includes all applications of \\\"{application}\\\"'))\ndef response_that_includes_file(application, api_response):\n    assert all(\n        response[\"application\"] == application for\n➥ response in api_response[\"response\"]\n    ), f\"Expected {application} in\" f\" {api_response['response']}\"\n…\n```", "```py\n…\napplication: str = Field(\n   default=...,\n   description=\"The application that the entry is associated with.\",\n   title=\"Application\",\n   max_length=8, #1\n)\n…\n```", "```py\nCASE \n   WHEN aepd.transaction_code IN (31, 32, 33,\n➥ 34, 36, 37, 38, 39) #1\n      THEN 'Savings' #1\n   WHEN aepd.transaction_code IN (21, 22, 23, #1\n➥ 24, 26, 27, 28, 29)   #1\n      THEN 'Checking' #1\n   WHEN aepd.transaction_code IN (41, 42, 43, 46, 47, 48)   #1\n      THEN 'GL' #1\n   WHEN aepd.transaction_code IN (51, 52, 53, 55, 56 )  #1\n      THEN 'Loan' #1\n   ELSE 'Unknown' #1\nEND AS application,  #2\n```", "```py\nconst columns: GridColDef[] = [\n…\n   { field: 'application', #1\n headerName: 'Application', #1\n width: 150}, \n…\nexport interface AchBatchEntriesResponse {\n…\n    application: string;\n…\n}\n```", "```py\nimport React from 'react';\nimport { Paper, Typography } from '@mui/material';\nimport Grid from '@mui/material/Unstable_Grid2'; #1\n\nconst ResponsiveCards = () => {\n    return (\n        <Grid container spacing={2} sx={{pl: 1, pr: 1}}>  #2\n            {[1,2,3,4,5,6,7,8,9].map((value) => ( #3\n                <Grid xs={12} sm={6} md={4} \n➥lg={2} xl={1} key={value} > #4\n                    <Paper elevation={3} sx={{ padding: 2 }}>\n                        <Typography variant=\"h5\" component=\"h3\">\n                            Card {value}\n                        </Typography>\n                        <Typography component=\"p\">\n                            This is some content\n➥ inside card number {value}.\n                        </Typography>\n                    </Paper>\n                </Grid>\n            ))}\n        </Grid>\n    );\n};\nexport default ResponsiveCards;\n```", "```py\nreturn (\n   <Box sx={{ display: 'flex' }}>\n      <CssBaseline />\n      <StandardNavigation />\n      <Grid container spacing={{ xs: 2, md: 3 }} #1\n            columns={{ xs: 4, sm: 8, md: 12 }}   #1\n            sx={{mt: 8, pl: 1, pr: 1}}>  #1\n         <Grid xs={12} sm={6} key={1} > #2\n            <AchTransactionCodesPieChart entries={entries} />  #2\n         </Grid> #B #2\n         <Grid xs={12} sm={6} key={2} >  #2\n            <AchBatchStatistics entries={entries}/>  #2\n         </Grid>  #2\n         <Grid xs={12} key={3} >  #2\n            <Paper sx={{ minWidth: 1075 }}>  #2\n               <Title>Batch Entries</Title>  #2\n               <DataGrid columns={columns} rows={entries} />  #2\n            </Paper>\n         </Grid>\n      </Grid>\n   </Box>\n);\n```", "```py\nmt: {\n   xs: 4,\n   sm: 4,\n   md: 12,\n   lg: 12,\n   xl: 12\n},\n```", "```py\nconst theme = createTheme({\n  breakpoints: {\n    values: {\n      mobile: 0,\n      tablet: 640,\n      laptop: 1024,\n      desktop: 1200,\n    },\n  },\n});\n```"]