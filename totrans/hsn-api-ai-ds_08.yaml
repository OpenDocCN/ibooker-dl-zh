- en: 'Chapter 7\. Batteries Included: Creating a Python SDK'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make the right things easy and the wrong things hard.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Kathy Sierra
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To create an API data scientists will love, you should give them a *software
    development kit* (SDK) to call the API with. This is an extra step that most API
    producers do not take, but it makes life much easier for your users. In this chapter,
    you will learn the value of SDKs and benefit from practical tips from several
    experts, and then you will create a Python SDK for the SWC Fantasy Football API.
    Building an SDK is the capstone of your Part I portfolio project.
  prefs: []
  type: TYPE_NORMAL
- en: SDKs can include code examples, debuggers, and documentation, but the term commonly
    refers to a custom software library that acts as a wrapper for your API. It allows
    developers and data scientists to interact with your API directly in their programming
    language, without requiring extra code to handle API communication.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-1](#sdk_API_components_diagram) shows how your users will employ
    an SDK to call your API, instead of calling it directly.'
  prefs: []
  type: TYPE_NORMAL
- en: '![SDK Interacting with the API](assets/haad_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. SDK interacting with the API
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: SDKs Bridge the Gap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn the benefits of SDKs and tips for implementing them, I spoke to several
    experienced SDK developers and followed up with written questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Joey Greco is a software engineer who has created open source SDKs for several
    fantasy football league hosts, including [Sleeper](https://oreil.ly/8dXo_) and
    [MyFantasyLeague](https://oreil.ly/SIPsV). He explains how SDKs help users: “A
    well-built SDK takes care of all the nitty-gritty for you,” he said. “A well-built
    SDK gives me a few lines of code I can copy/paste on my machine along with a few
    examples of how to access and manipulate various data. It tells me what I need
    to do to authenticate (pass your API token into this function, etc.). It’s a great
    way to bridge the gap from an external service to the code that you’re writing.”'
  prefs: []
  type: TYPE_NORMAL
- en: It’s useful to remember that developers and data scientists aren’t using your
    API out of an interest in APIs—they have a job to do, and the API helps do the
    job. Wrapping the API in prebuilt program code makes that even simpler. I once
    conducted a usability session with a data-focused user of an API developer portal.
    I was surprised (and maybe slightly insulted) when she told me she didn’t care
    about my APIs—she just wanted the data. For a user like that who just wants the
    data, an SDK will be a time-saver.
  prefs: []
  type: TYPE_NORMAL
- en: Also, consider that your users may use multiple APIs and data sources from different
    providers. The time they spend learning how each API works and configuring their
    code for it is a diversion from their end goal. And not every developer or data
    scientist has experience in using APIs in a resilient and secure manner. A mature
    SDK can provide good software development practices to these users with a minimum
    of trouble.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simon Yu, cofounder of the SDK generation platform Speakeasy, shares additional
    benefits: “All the boilerplate code that API consumers needed to write before
    is already taken care of by the SDK library itself. Instead of every consumer
    re-inventing the wheel themselves (frustrating, time-consuming, error-prone),
    they simply import the SDK, call the correct method, and go.”'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another benefit too. When developers use an SDK in their IDE, they will
    get auto-complete and type hints while they code. This makes their development
    quicker and also enables generative AI tools such as GitHub CoPilot or AWS CodeWhisperer
    to generate accurate code for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Producers benefit from anything that makes it easier to use their APIs. Like
    good API docs, SDKs reduce the friction for new consumers, which reduces the time-to-hello-world
    metric discussed in [Chapter 5](ch05.html#chapter_5). Simon Yu said SDKs can be
    a profitable investment for API producers: “An API consumer (who might also be
    another large enterprise!) often won’t want to pay for a service until they are
    up and running in production. For many API providers, therefore, unblocking API
    consumers also unblocks revenue.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yu said SDKs can also reduce API support expenses: “Since SDKs provide a ready-made
    way to integrate with the API and eliminate the need to write custom integration
    code from scratch, they dramatically reduce the support burden required of API
    producers.” He added, “Without SDKs, if an integration doesn’t work, API producers
    often get pulled into 1:1 support, which is extremely costly.”'
  prefs: []
  type: TYPE_NORMAL
- en: An SDK is a good way to encourage users to use your APIs responsibly by conforming
    to call limits and sending correctly formatted requests. SDKs make doing the right
    thing the easy thing.
  prefs: []
  type: TYPE_NORMAL
- en: SDKs can be part of an overall API product strategy. One of the best examples
    I have seen is by [StatsBomb (now Hudl StatsBomb)](https://statsbomb.com), a sports
    data and analytics provider. StatsBomb provides football and soccer data with
    a strong emphasis on supporting research and education in the sports field. StatsBomb
    hosts a [sports analytics platform](https://oreil.ly/Orp-g) that provides in-depth
    analysis and visualizations about players and teams from around the world. StatsBomb
    also provides data through a [subscription-based API](https://oreil.ly/CzhyS)
    that allows its customers to pull data into their own analytics software. To support
    researchers and students, it also provides some of its data for free download
    on its [open data GitHub repository](https://oreil.ly/LPGZM).
  prefs: []
  type: TYPE_NORMAL
- en: 'For StatsBomb, SDKs tie the paid and free services together. The company maintains
    two SDKs for its APIs: [statsbombr](https://oreil.ly/IQO_f) and [statsbombpy](https://oreil.ly/0VOdS).
    As shown in [Figure 7-2](#Statsbombpy_repo), paid subscribers can use the SDK
    to get live data, while nonsubscribers can use the SDK to access static data for
    free. Internally, the SDK gets the paid data from an API and the free data from
    a file download. But this complexity is shielded from the SDK users: they just
    know they get the data they want.'
  prefs: []
  type: TYPE_NORMAL
- en: '![statsbombpy SDK documentation](assets/haad_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. The statsbombpy SDK documentation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Picking a Language for Your SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your SDK journey starts by knowing your developer audience and how they will
    utilize your APIs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SDKs.io
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The first decision that you will make when developing an SDK is which programming
    languages you will support. The SDK does not need to be written in the same language
    that the API is developed in. Instead, it needs to be written in the language
    that the API’s consumers use. They will import the SDK in their code, and use
    it to interact with your API, instead of calling the API directly.
  prefs: []
  type: TYPE_NORMAL
- en: API producers sometimes provide SDKs in multiple languages for different consumers.
    Zan Markan summarized this approach as “Go where the users are.” For data scientists,
    he said, “it’s going to be Python, and there might be some R. Python is so heavily
    used in that community that you want to focus on that.” His view is consistent
    with the “State of Data Science” survey discussed in [Chapter 1](ch01.html#chapter_1),
    which listed Python as the most common language used by data scientists. To get
    started with a Python SDK, an open source tool like the [OpenAPI Python client](https://oreil.ly/cnR-u)
    could be used to generate stubs that you could add more functionality to.
  prefs: []
  type: TYPE_NORMAL
- en: The more languages you create SDKs in, the more maintenance they require. Companies
    like [Speakeasy](https://oreil.ly/speasy), [APIMatic](https://oreil.ly/bpMKs)
    (publisher of SDKs.io), and [Fern](https://oreil.ly/fern) provide commercial tools
    that generate SDKs in multiple languages directly from the OpenAPI Specification
    (OAS) and keep them updated over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simon Yu explained the benefits of auto-generation services: “Getting the SDK
    design and implementation right is difficult. Maintaining and supporting them
    is even harder. What happens if the team member responsible for updating the SDK
    leaves? Now multiply this problem across all the languages you want to offer the
    SDK in,” he said. “This is where Speakeasy and other SDK generators come in.”'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with a Minimum Viable SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last piece of your Part I portfolio project is to create a Python SDK.
    Throughout this chapter, you will learn tips and tricks from API experts and implement
    Python features inspired by them: Francisco Goitia’s [statsbompy](https://oreil.ly/LUiJd),
    SDKs from Simon Yu’s company Speakeasy, and Joey Greco’s [pymfl](https://oreil.ly/ut2nK),
    along with additional reference documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: You will start with a very simple working SDK to make sure the project packaging
    is working. I’ll call this your *minimum viable SDK*. After you verify the package
    works and can be installed, you will add additional features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expert Tip: Making Your SDK Easy to Install'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '...if they can install a Python library with pip install and start using the
    data, it makes their life easier.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Francisco Goitia, StatsBomb
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Many programming languages have a standard method of downloading and installing
    libraries from an external repository, such as npm for Node.js and Maven for Java.
    Python SDKs are commonly published on the [Python Package Index (PyPI)](https://pypi.org).
    Hosting an SDK on PyPI enables Python developers to install the SDK into their
    environment using the `pip3` tool, as you have done in earlier chapters with libraries
    such as FastAPI and SQLAlchemy. The `pip3` tool can also install packages directly
    from a GitHub repository, if the project is structured correctly. This is how
    you will structure your SDK project and give instructions to users. As a bonus,
    this structure is what is needed to publish to PyPI if you choose to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the directory to *chapter7* and create the *sdk* folder. Then, change
    to the *sdk* directory and create a file named *pyproject.toml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The *pyproject.toml* file provides all the settings that tools like `pip3`
    need to package your code and install it correctly in Python environments. Add
    all of the following text to your *pyproject.toml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This section selects [setuptools](https://setuptools.pypa.io/en/latest/setuptools.html)
    as the build backend for your project. The Python Packaging Guide lists several
    other choices for the build backend, including Hatchling, Flit, and PDM. I have
    chosen setuptools because all of the example SDKs referenced in this chapter use
    it, and it is simple to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This section gives the basics about the package, including name, version, description,
    and author. (You should put your name there—it’s your portfolio project, after
    all.)
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The version should be updated each time major changes are applied.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This communicates the minimum Python version your package supports.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The development status `Alpha` shows that this SDK is in the early stages of
    development.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_batteries_included__creating_a_python_sdk_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: This section lists the Python libraries that are required for your package to
    work. This is the only section in this chapter that will list dependencies—there
    is no *requirements.txt* file used for the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expert Tip: Making the SDK Consistent and Idiomatic'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simon Yu said, “The SDK should be consistent and predictable. Naming conventions,
    error handling, and response format should be the same throughout the SDK to avoid
    unnecessary confusion to users.” For example, your SDK functions returning a single
    item will begin with `get_` and functions returning lists will begin with `list_`.
  prefs: []
  type: TYPE_NORMAL
- en: Sdks.io says you should make your SDK *idiomatic*, following the norms used
    by other programmers of that language. For a Python SDK, this means that your
    code should be *Pythonic*. This is a broad term, but it means that Python code
    should follow the conventions that other Python programmers and tools use. Python
    is a living language, with new features being added all the time, so the coding
    conventions try to keep up. Conventions are established in the Python community
    through Python Enhancement Proposals or PEPs. If you’d like to understand the
    process, check out [PEP 1 – PEP Purpose and Guidelines](https://oreil.ly/dgQ79).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the overall style of your SDK, you will be using [PEP 8 – Style Guide for
    Python Code](https://oreil.ly/oersV). The [official Python docs](https://oreil.ly/csNt5)
    provide a good summary of PEP 8 style: use 4-space indentations, keep lines to
    79 characters or less, and use `UpperCamelCase` for classes and `lowercase_with_underscores`
    for functions and methods.'
  prefs: []
  type: TYPE_NORMAL
- en: A few additional Pythonic conventions you will use in your SDK include [PEP
    202 – List Comprehensions](https://oreil.ly/7rivi), [PEP 343 – Context Managers](https://oreil.ly/bgVdx),
    [PEP 257 – Docstrings](https://oreil.ly/q5zA2), [PEP 518 – Build System Requirements](https://oreil.ly/WLYFx),
    and [PEP 484 – Type Hints](https://oreil.ly/RkeOY). These items will be explained
    as they are added to the code in your SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *swc_client.py* file is the primary client that will interact with your
    API. You will start with a very basic client. Create the directory structure,
    the package initialization file, and the starter Python client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Because your SDK will be a Python package, each directory that contains code
    will contain a file named *__init__.py*. An empty file can do this job for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin creating the minimal SDK, give the *swc_client.py* file just enough
    functionality to call the health check of the SWC API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: For now, your `import` statement only contains `httpx`, which is the core Python
    library you will use to interact with the API. The rest of this file defines the
    `SWCClient` class. Users of the SDK will create an instance of the class when
    they call the SDK, by executing the `SWCClient()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the class constructor, which is executed one time when a client instance
    is created. The method can be used to initiate methods and variables that are
    unique to an individual instance of the class, in contrast to the constant variable
    defined earlier. The `self` parameter is passed as the first parameter to every
    class method in Python, including the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor also receives the string parameter `swc_base_url`, which is
    the base address of the API to call. You set the class variable `self.swc_base_url`
    so that this value can be used in the `get_health_check()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This function calls the API’s health check endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `httpx.Client` has quite a few features available, but for now you are setting
    the base URL and using it to call the `"/"` endpoint, which is your API’s health
    check.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that you have configured your SDK package correctly, it’s time to
    install it in your Codespace with `pip3`. This will use the new source code and
    configuration files you created and install it as a library that you can access
    in Python files. It will also install the dependencies from the *pyproject.toml*
    file’s `dependencies` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now install your package locally with the `-e` option, which ensures that the
    package is updated locally as your code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `pip` package adds the version number on your Python package from the *py​pro⁠ject.toml*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations, you have created and installed a Python package! Take a look
    at the files you have created for this minimal SDK. Use the `tree` command, with
    a few options to filter out temporary files created by the build process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Building a Feature-Rich SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it’s time to turn the minimum viable SDK into one that is robust and feature
    rich. As you learn expert tips, you can implement them in your code. The goal
    is to make your SDK *batteries included*, which means it comes with all the functionality
    that users need for interacting with your API. This is where an SDK becomes a
    major selling point to your users, and it gives them the ability to get the most
    from your API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expert Tip: Using Sane Defaults'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A key to hiding complicated details is to implement sane defaults. This means
    that a user can use your SDK without specifying any parameters and it will work
    out of the box. One important default is that the SDK should know the base URL
    of the API without being told. This allows the user to `pip3` install it and use
    it without reading the documentation to know this address. If the SDK is a read-only
    wrapper for a public API, you’ll likely default the production API address. If
    the API requires authentication or is a read/write API, you may want to default
    to a sandbox environment to prevent accidents. The sane defaults will handle the
    *happy path*, the standard usage that 80% of your users will need. The remaining
    20% can be handled by allowing the user to change the configuration to override
    the defaults for special situations they have.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will add sane defaults that the user can override by creating a configuration
    class. Create a file named *swc_config.py* as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This file defines the `SWCConfig` class. The user will instantiate an instance
    of this class with their configuration settings, and then pass it to the `SWCClient`
    constructor. Then, they will use the `SWCClient` to call the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update *swc_config.py* with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This import will be used to get environment variables from the Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This statement loads external variables from a *.env* file or the operating
    systems environment.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `swc_base_url` will be used to access the API.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `swc_backoff` determines if the SDK should retry the call using backoff
    when errors occur.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `swc_backoff_max_time` The max number of seconds the SDK should keep trying
    an API call before stopping.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_batteries_included__creating_a_python_sdk_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `swc_bulk_file_format` sets the format for bulk files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_batteries_included__creating_a_python_sdk_CO4-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__` method is executed onced when this class is created. It is used
    to set the class variables from the parameters the user passes in. Default values
    are set in this method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_batteries_included__creating_a_python_sdk_CO4-8)'
  prefs: []
  type: TYPE_NORMAL
- en: This line sets the internal URL from a parameter that passed in the constructor,
    or from the environment if there is no parameter in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_batteries_included__creating_a_python_sdk_CO4-9)'
  prefs: []
  type: TYPE_NORMAL
- en: This statement checks if a URL has been provided through one of the methods
    described previously. If none is present, this raises an exception and the loading
    stops. This class can’t be used without a URL to access the API.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_batteries_included__creating_a_python_sdk_CO4-10)'
  prefs: []
  type: TYPE_NORMAL
- en: The `__str__` method is used by external programs to log the contents of this
    class. If you don’t provide a custom method like this, a default method would
    be created, but it might have less useful information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, modify the *__init__.py* file in the *chapter7/sdk/src/swcpy* directory
    so that it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These imports simplify the process of importing the classes in a user’s code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expert Tip: Providing Rich Functionality'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Simon Yu suggested that an SDK should be rich with features that save a significant
    amount of coding for developers. A survey of the SDKs I reviewed in this chapter
    found features such as handling versions, handling pagination, client-side caching,
    and authentication. You will include two advanced features: data type validation
    and retry/backoff logic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time-consuming for end users to add data validation in their code. They
    have to read the API documentation to determine valid data types and values, and
    then add a lot of code that checks values and throws errors. When SDK developers
    add data validation, this is a big benefit to users. The original API developers
    have detailed knowledge of the workings of the API, which makes it easier for
    them to add validations to the SDK. You have an additional advantage for this
    Python SDK: access to the original Pydantic classes the API was built with. You
    can reuse the Chapter 7 *schemas.py* file in your SDK, giving your SDK powerful
    data validation at a minimal effort.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a *schemas* folder and *__init__.py*file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the schemas file from the *chapter6* directory (or *chapter6/complete*
    if you haven’t finished [Chapter 6](ch06.html#chapter_6)) into this chapter’s
    directories as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you will rebuild the client from scratch, step by step. First, you will
    add the imports and the class constructor. Replace the entire *swc_client.py*
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This imports the *swc_config.py* file you created.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This is used to import the Pydantic schemas.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This is used for additional type hints for the Pydantic classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This is used to implement exponential backoff.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This import statement and the following line of code are used to log debug and
    error messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_batteries_included__creating_a_python_sdk_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: This adds class constants for all the API’s endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_batteries_included__creating_a_python_sdk_CO5-7)'
  prefs: []
  type: TYPE_NORMAL
- en: You need to replace the `*[github ID]*` with your GitHub ID so that the path
    to the bulk files works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_batteries_included__creating_a_python_sdk_CO5-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The `SWCClient` class constructor accepts an instance of `SWCConfig` now. The
    user puts all of their configuration in this object and passes it to the client.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_batteries_included__creating_a_python_sdk_CO5-9)'
  prefs: []
  type: TYPE_NORMAL
- en: This creates a dictionary of bulk filenames without a file extension.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_batteries_included__creating_a_python_sdk_CO5-10)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a conditional decorator, which will update the `call_api()` method to
    have backoff functionality if the user configures it. The backoff will be explained
    further later.
  prefs: []
  type: TYPE_NORMAL
- en: '[![11](assets/11.png)](#co_batteries_included__creating_a_python_sdk_CO5-11)'
  prefs: []
  type: TYPE_NORMAL
- en: This code appends a file extension of *.csv* or *.parquet* to the filenames
    dictionary. It uses a dictionary comprehension, which is an efficient and Pythonic
    way to update all the elements in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The retry and backoff functionality you added in the client has a few unexpected
    twists and turns. When you make an API call from your SDK, sometimes it may fail
    due to a temporary network hiccup or slowdown in the API. It might be due to a
    load-balancing issue or a service that is in the middle of bringing more servers
    online to handle increased load. If you are running a process that uses the API,
    you can make it more resilient by retrying a few times before giving up.
  prefs: []
  type: TYPE_NORMAL
- en: However, the way you retry may cause some unexpected consequences on the API
    provider. For example, you could decide that if an API call fails, you will continually
    retry every microsecond until it succeeds. This would be the equivalent of a web
    user clicking Refresh continually until the web page is back up. One user doing
    that might not cause that much of a headache. But what about when hundreds or
    thousands of users are retrying the API continually in the middle of a network
    outage, or when an API provider is trying to bring more resources online? These
    users will be hitting it with a massive load at a time when it’s least able to
    respond. This is like an accidental distributed denial-of-service (DDOS) attack
    from your own users.
  prefs: []
  type: TYPE_NORMAL
- en: API consumers and SDK developers can implement *exponential backoff* instead
    of simple retries. With this method, the time between retries gets exponentially
    longer with each failed attempt. This method recognizes that a service that is
    failing needs a break, and the more failures that happen, the more of a break
    it needs. For example, a client might double the time between retries each time
    it fails. Using this method, it would retry at 1 second, 2 seconds, 4 seconds,
    8 seconds, and so on until it reached a preset stopping point.
  prefs: []
  type: TYPE_NORMAL
- en: This is an improvement, but can you see any issue with everyone using this method?
    The problem is explained very clearly on AWS’s *Architecture* blog in [“Exponential
    Backoff And Jitter”](https://oreil.ly/tSRCm), and [Figure 7-3](#attempts_per_second_ch7)
    gives a simplified visualization. The numbers across the bottom are seconds after
    an outage, and the vertical bars are the number of retry attempts occurring in
    that second.
  prefs: []
  type: TYPE_NORMAL
- en: '![The problem with exponential backoff](assets/haad_0703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. The problem with exponential backoff
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see from the image, if multiple people are using the same settings
    for exponential backoff (as they would be if they’re all using your SDK with defaults),
    they are likely to still cluster around the same intervals to retry. This is because,
    when an outage occurs, it will probably hit many users at the same time, starting
    their retry clock. This is not what you want. The solution is to introduce *jitter*,
    which is a somewhat random element that is combined with the backoff. Using this
    method, you get the benefit of backing off retries without the clustering of retries
    in the same intervals. The best of both worlds is exponential backoff with jitter.
  prefs: []
  type: TYPE_NORMAL
- en: The code you added to *swc_client.py* implemented exponential backoff with random
    jitter using the [backoff Python library](https://oreil.ly/PUZbE). To use this
    library, you added the decorator `backoff.on_exception` onto the `call_api()`
    function. This wraps the function call with backoff, without having to make any
    changes to the function itself. If the SDK user uses backoff, the `call_api()`
    function will be wrapped with this additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take another look at the decorator you added to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: If an exception occurs, retry starting at 1 second, then doubling every retry.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Look for `RequestError` and `HTTPStatusError` exceptions from the `call_api`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Stop retrying after the `backoff_max_time` parameter (which defaults to 30 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Apply random jitter so that it varies slightly from the exact second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expert Tip: Performing Logging'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don’t want your SDK to be a black box—you want users to understand what’s
    occurring under the hood. One way to do this is by publishing the source code
    on a public repository. The other is by providing meaningful logging, which helps
    when the user is encountering errors or isn’t returning the results expected.
  prefs: []
  type: TYPE_NORMAL
- en: To be Pythonic, your SDK will use Python’s built-in *logging* library, and allow
    the users to configure what level of logging they want to print. For example,
    they may only want to log serious errors in production logs while logging debug
    messages during development. [Table 7-1](#python_logging_levels_ch7) shows the
    logging levels available, according to the [official Python docs](https://oreil.ly/CmUps).
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. Python logging levels
  prefs: []
  type: TYPE_NORMAL
- en: '| Level | What it means/when to use it |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `logging.DEBUG` | Detailed information, typically only of interest to a developer
    trying to diagnose a problem. |'
  prefs: []
  type: TYPE_TB
- en: '| `logging.INFO` | Confirmation that things are working as expected. |'
  prefs: []
  type: TYPE_TB
- en: '| `logging.WARNING` | An indication that something unexpected happened, or
    that a problem might occur in the near future (e.g., disk space low). The software
    is still working as expected. |'
  prefs: []
  type: TYPE_TB
- en: '| `logging.ERROR` | Indicates that, due to a more serious problem, the software
    has not been able to perform some function. |'
  prefs: []
  type: TYPE_TB
- en: '| `logging.CRITICAL` | A serious error, indicating that the program itself
    may be unable to continue running. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this chapter, you will see logging messages in the terminal when you run
    `pytest` if an error occurs. By default, any messages with a log level of `WARNING`
    or more severe will be displayed. If you want to see `INFO` or `DEBUG` messages,
    you can use the `--log-level` command-line option.
  prefs: []
  type: TYPE_NORMAL
- en: 'You added the import statements and created a `logger` object earlier in this
    chapter. You will see this functionality in action in a new method that you will
    create, named `call_api()`. Add the following code at the bottom of *swc_client.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Because this is a class method, the first parameter is always `self`, which
    represents the instance of this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter to this method is the individual endpoint you are calling.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The query string parameters for the API call are passed in as an optional dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a type hint that the method should return an `httpx.Response` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This dictionary comprehension removes any empty parameters before calling the
    API with them.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_batteries_included__creating_a_python_sdk_CO7-6)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a context manager that uses `httpx.Client` for the steps that follow.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_batteries_included__creating_a_python_sdk_CO7-7)'
  prefs: []
  type: TYPE_NORMAL
- en: This is logging at the `logging.DEBUG` level. The parameters are formatted with
    an F-string, which is a Pythonic way of formatting variable values.
  prefs: []
  type: TYPE_NORMAL
- en: The `call_api` function is used to make the API calls for each SDK function.
    By centralizing this work, you can apply additional error handling and logging
    without making your code too long. It adds `try…​except` logic around the API
    call. If the API call works, this function logs a `logging.DEBUG` level message
    with the data from the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at a key line of code in this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When a statement uses the `with…​as` format like this, it is using a Python
    object as a *context manager*, so that the object is initialized, then the statements
    inside it run, and then it is cleaned up along with any resources it used. Here,
    the `httpx.Client` is the context manager.
  prefs: []
  type: TYPE_NORMAL
- en: According to the [HTTPX documentation](https://oreil.ly/I-xln), the `httpx.Client`
    is an efficient way to make API calls using *httpx* because it pools resources
    between API calls. The `Client` constructor accepts the parameter `base_url` and
    will use it for all of the API calls it is used for.
  prefs: []
  type: TYPE_NORMAL
- en: This code is contained inside at `try…​except` block, so if the API call doesn’t
    work, the `except` first handles `httpx.HTTPStatusError`, which is a type of error
    that will have an HTTP status code. For this type of exception, it logs a `logging.ERROR`
    level message and then re-raises the exception. If it’s not that type of exception,
    it handles `httpx.RequestError` next. This type of exception doesn’t have an HTTP
    status code, so it just puts the body of the exception in the log message. Then
    it re-raises the exception. Re-raising the exception is important because you
    will be adding retry and backoff logic later in this chapter, and it will be looking
    for those exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expert Tip: Hiding Your API’s Complicated Details'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Joey Greco likes SDKs to handle some of the complexities of the underlying API.
    “As a data consumer, I don’t want to have to worry about API versioning, headers,
    authentication, rate-limiting, or hunting down the correct endpoints to use,”
    he said. “I just want to call some function and be able to do things that are
    meaningful to me.”
  prefs: []
  type: TYPE_NORMAL
- en: Now add the `get_health_check` and `list_leagues` methods to the bottom of the
    file. Endpoint methods like `get_health_check` and `list_leagues` wrap the API
    calls and shield users from complicated details such as endpoint names and return
    types. It’s not an exaggeration to say that methods like these are the reason
    that SDKs exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'These both use the `call_api` function that you created. The `list_leagues`
    method also uses Pydantic to validate the data returned from the API. If the data
    from the API does not match the Pydantic class definition, the client will throw
    an error that can be logged. Add the following code to the bottom of the *swc_client.py*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The new `get_health_check()` method uses the `call_api()` method, instead of
    calling the API directly as it did in the minimal SDK.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The type hint shows that the method should return a `List` of `League` objects.
    `League` is a Pydantic class defined in the *schemas.py* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The parameters will be passed in when users call this SDK method. This line
    of code builds a dictionary containing the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This method also calls the `call_api` method and passes in the query string
    parameters as a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO8-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This looks through the list of dictionaries returned in the API response and
    populates a `List` of `League` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the final line of code in `list_leagues()`, which packs a lot
    into a short syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Your goal in this statement is to iterate through the list of dictionaries returned
    from the API and create a list of Pydantic `League` objects. You use a [list comprehension](https://oreil.ly/Fpgem),
    which is a Pythonic way to build lists without using a recursive loop. Using the
    general syntax `list = [expression for item in iterable]`, you can create lists
    from other lists very easily.
  prefs: []
  type: TYPE_NORMAL
- en: As you iterate through, you want to create a Pydantic `League` object from each
    dictionary in the original list. You can do this with Python’s *unpacking operator*.
    The statement `League(**league)` uses two asterisks to unpack the original dictionary
    into key-value pairs that are passed to the `League()` constructor. Pydantic performs
    data validation during the process of creating these objects, so if any invalid
    data is in the API response, it will error out in this step. With this combination
    of list comprehension and the unpacking operator, you return a list of `League`
    objects that have been validated from the original list of dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expert Tip: Supporting Bulk Downloads'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a data scientist, I find the complexity of many open data services frustrating.
    I don’t want to have to learn how to query an endpoint, think about data types,
    or read through API documentation. Just give me the data!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Robin Linacre
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Bulk downloads are valuable for many API users, but data scientists especially
    like this feature. Data scientists often use full datasets for analysis and loading
    data, and they find it frustrating to call multiple endpoints to get subsets of
    the data. You could serve bulk downloads from an endpoint in your API using [FastAPI’s
    Static Files](https://oreil.ly/58q0a).
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, you will be serving bulk downloads from SDK methods. Your SDK will
    access the files from their web-hosted location in your GitHub repository. The
    URL for each file will be built using the `BULK_FILE_BASE_URL` and the `BULK_FILE_NAMES`
    dictionaries. Your repository contains two bulk files for each table you loaded
    in your SQLite database: one in *.csv* format and one in *.parquet* format. By
    providing these two options, your SDK serves a wide range of bulk data needs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bulk files are in the *bulk* folder of your repository. View the list of
    these files with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The files with the *.csv* extension are *comma-separated values* files. The
    following shows the first two rows of the *player_data.csv* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These are plain-text files with no compression of any kind. The first row contains
    the column names separated by commas. The remaining rows contain one row for each
    data record and the data values are separated by commas. CSV files are easily
    processed in Python libraries such as pandas or in software such as Microsoft
    Excel.
  prefs: []
  type: TYPE_NORMAL
- en: '*Parquet files* use an open source data format that is popular for a variety
    of data analysis tasks. Here is the official definition from the [Apache Parquet
    project page](https://oreil.ly/K4_0_): “Apache Parquet is an open source, column-oriented
    data file format designed for efficient data storage and retrieval. It provides
    high performance compression and encoding schemes to handle complex data in bulk
    and is supported in many programming language and analytics tools.”'
  prefs: []
  type: TYPE_NORMAL
- en: You will create a separate method to retrieve each file, but the method will
    retrieve either *.csv* or *.parquet* format files based upon the options provided
    in the `bulk_file_format` parameter the user selects in the `SWCConfig` class.
    The default value is *.csv* if the user does not provide this parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method at the bottom of *swc_client.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The type hint for this method is `bytes` because the Parquet file is a binary
    file, not text.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This statement builds the URL to an individual file from the web-hosted location
    in your GitHub repository using the `BULK_FILE_BASE_URL` and `BULK_FILE_NAMES`
    dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using the `call_api` method, like the other methods do, this method
    uses the `httpx.get()` method. The `follow_redirects` parameter handles any web
    redirects that occur when retrieving the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The method returns `response.content`, which will contain the binary file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have created methods that implement all the major functionality of your
    SDK, although you haven’t created methods for all the endpoints or bulk files
    yet. Update your *pyproject.toml* file to contain all the new libraries you’ve
    added, and increment your version number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Increment the version number of the library to reflect all the new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Import the Pydantic library for your data validation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Import the backoff library for your backoff and retry functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO10-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Import the PyArrow library for handling Parquet files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expert Tip: Documenting Your SDK'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as APIs need documentation, so does your SDK. Since your SDK will be used
    directly in program code, the first step to documenting your SDK is to add comprehensive
    docstrings to the methods that will be used by programmers. This is an important
    part of writing Pythonic code, and it helps data scientists using your SDK in
    an IDE like VS Code to get hints and code completion that make their work faster
    and more accurate. As more data scientists use generative AI in their development
    process, it allows AI assistants and copilots to infer accurate coding suggestions.
    You provided extensive docstrings in the *swc_client.py* and *swc_config.py* files.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to include a well-written *README.md* file that explains how to
    install the SDK and provides examples of using it. This file will be displayed
    by default in the GitHub repository for your SDK, and it will be the home page
    for your SDK if you publish it to PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the *README.md* file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following contents to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: SWC_API_BASE_URL={URL of your API}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]python'
  prefs: []
  type: TYPE_NORMAL
- en: from swcpy import SWCClient
  prefs: []
  type: TYPE_NORMAL
- en: from swcpy import SWCConfig
  prefs: []
  type: TYPE_NORMAL
- en: config = SWCConfig(swc_base_url="http://0.0.0.0:8000",backoff=False)
  prefs: []
  type: TYPE_NORMAL
- en: client = SWCClient(config)
  prefs: []
  type: TYPE_NORMAL
- en: leagues_response = client.list_leagues()
  prefs: []
  type: TYPE_NORMAL
- en: print(leagues_response)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]python'
  prefs: []
  type: TYPE_NORMAL
- en: import csv
  prefs: []
  type: TYPE_NORMAL
- en: import os
  prefs: []
  type: TYPE_NORMAL
- en: from io import StringIO
  prefs: []
  type: TYPE_NORMAL
- en: config = SWCConfig()
  prefs: []
  type: TYPE_NORMAL
- en: client = SWCClient(config)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"""Tests bulk player download through SDK"""'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: player_file = client.get_bulk_player_file()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write the file to disk to verify file download
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: output_file_path = data_dir + 'players_file.csv'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'with open(output_file_path, ''wb'') as f:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: f.write(player_file)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'One key section to notice in this file is that it explains to users how they
    can install your SDK from your GitHub repository. Here is that section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You have now created all the files you need and completed all of the coding
    for the first few endpoints. To see the new structure of your project, run the
    `tree` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To update your local system with the new version of the SDK using `pip`, you
    will use the `--upgrade` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Testing Your SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now you will test the SDK with pytest. Create a new directory and file with
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are different pytest layouts you can use to include the tests in your
    package. In this case, you are using the pytest layout style named “tests outside
    application” that is described in [pytest’s Good Integration Practices](https://oreil.ly/GM3HU).
    This means that when you run your tests, you are testing against the installed
    module instead of code in your local path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update *test_swcpy.py* with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The import statement is referencing the package that you installed locally in
    your environment.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This library is used for handling binary files like the Parquet file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This library is specifically used to process Parquet files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: You will use the pandas library to read the length of the Parquet files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO11-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This test method tests health check endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_batteries_included__creating_a_python_sdk_CO11-6)'
  prefs: []
  type: TYPE_NORMAL
- en: This test method tests the method calling your API.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_batteries_included__creating_a_python_sdk_CO11-7)'
  prefs: []
  type: TYPE_NORMAL
- en: This test method tests the Parquet bulk file download.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_batteries_included__creating_a_python_sdk_CO11-8)'
  prefs: []
  type: TYPE_NORMAL
- en: This sets the configuration option for Parquet files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_batteries_included__creating_a_python_sdk_CO11-9)'
  prefs: []
  type: TYPE_NORMAL
- en: These lines of code use PyArrow and pandas to read the Parquet file and count
    the records.
  prefs: []
  type: TYPE_NORMAL
- en: Now you will run your API in another terminal session so that your SDK can call
    it. Open a second terminal session in Codespaces using the split terminal command,
    as shown in [Figure 7-4](#split_terminal_ch7).
  prefs: []
  type: TYPE_NORMAL
- en: '![Opening second terminal session](assets/haad_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. Opening a second terminal session
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you have added the second terminal, you should see it in the split screen,
    as shown in [Figure 7-5](#split_terminal_2_ch7).
  prefs: []
  type: TYPE_NORMAL
- en: '![Split terminal session](assets/haad_0705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5\. The split terminal session
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you haven’t installed the API in your Codespace previously, you will need
    to run the command **`pip3 install -r`** **`require⁠ments​.txt`** in the *chapter6/complete*
    directory before running the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second window, change directories to *chapter6/complete* to use the
    completed API from the repository. Launch the API as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The *test_swcpy.py* file should use this address in the `swc_base_url=` parameter.
    If it doesn’t have that address, update *test_swcpy.py* to match the address here.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to click “Open in Browser” as in previous chapters, because you
    will be testing the API from the terminal using your SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the left terminal window, enter the **`pytest tests/test_swcpy.py`** command
    and you should see an output that looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You have added a lot of great functionality to your SDK. Way to go! Take a
    moment to consider expert tips and features that you have implemented for your
    SDK:'
  prefs: []
  type: TYPE_NORMAL
- en: Make your SDK easy to install.
  prefs: []
  type: TYPE_NORMAL
- en: You configured your project so that it can be installed using `pip3` directly
    from GitHub. You could also publish it to PyPI if you choose.
  prefs: []
  type: TYPE_NORMAL
- en: Be consistent and idiomatic.
  prefs: []
  type: TYPE_NORMAL
- en: You used PEP 8 style and consistent function naming. You used Pythonic techniques
    like list comprehensions, dictionary comprehensions, and context managers. And
    you used the Python standard logging function.
  prefs: []
  type: TYPE_NORMAL
- en: Use sane defaults.
  prefs: []
  type: TYPE_NORMAL
- en: You implemented the `SWCConfig` that will work out of the box with default values
    but can be customized with URL and other settings.
  prefs: []
  type: TYPE_NORMAL
- en: Provide extra functionality.
  prefs: []
  type: TYPE_NORMAL
- en: You provided data validation, exponential backoff with jitter, and bulk downloads.
  prefs: []
  type: TYPE_NORMAL
- en: Perform logging.
  prefs: []
  type: TYPE_NORMAL
- en: You implemented logging with multiple levels using Python’s built-in logging
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Hide your API’s complicated details.
  prefs: []
  type: TYPE_NORMAL
- en: You implemented methods that allow users to call the API endpoints without reading
    the API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Provide bulk downloads.
  prefs: []
  type: TYPE_NORMAL
- en: You made bulk files available for all your database tables in both *.csv* and
    *.parquet* formats.
  prefs: []
  type: TYPE_NORMAL
- en: Document your SDK.
  prefs: []
  type: TYPE_NORMAL
- en: You provided a *README.md* file that explains how to install and use the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Only one expert tip remains for your SDK, but it’s a big one. You will tackle
    it next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expert Tip: Supporting Every Task the API Supports'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ideally, users should be able to accomplish any task with the SDK that they
    could accomplish by directly using the API. This means every API endpoint and
    parameter should be supported by the SDK. You’ve probably noticed at this point
    that you’ve only implemented SDK functions for a couple of the API endpoints and
    one bulk file download. Unfortunately, there’s no room in this chapter to walk
    you through the remaining code. However, you are prepared to code the rest of
    the endpoints using the helper functions and naming standards I have demonstrated
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'I don’t want to leave you hanging completely, so here is some additional information
    you can use to continue building your SDK. To start with, here are the functions
    you need to create to cover all the API endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_health_check` (completed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list_leagues` (completed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_league_by_id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_counts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list_teams`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list_players`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_player_by_id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list_performances`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the bulk download functions you need to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_bulk_player_file` (completed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_bulk_league_file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_bulk_performance_file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_bulk_team_file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_bulk_team_player_file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I encourage you to take a shot at creating these endpoints following the examples
    I have given you. Be consistent and idiomatic. As with earlier chapters, the full
    completed code is available in the *chapter7/complete* directory if you would
    like to check your work.
  prefs: []
  type: TYPE_NORMAL
- en: Completing Your Part I Portfolio Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the creation of your SDK, you have finished all the coding you need for
    your portfolio project. Congratulations! Hopefully, you have been committing your
    code with frequent small commits, but be sure to commit any remaining changes
    you have.
  prefs: []
  type: TYPE_NORMAL
- en: To get your project repository ready to share, you are going to be moving the
    Chapters [6](ch06.html#chapter_6) and [7](#chapter_7) content to the root folder
    of your repository, and then removing all the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you make these changes, you’ll save a copy of your files to a separate
    GitHub *branch*, which is an isolated area in your repository. This will keep
    the original directory structure you used while working through your code. (You
    have been doing all your coding in the *main* branch so far.) Create the new branch
    from the command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Change to the root directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new branch named *learning-branch* locally based on the *main* branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Push this new branch to your remote repository on GitHub.com.
  prefs: []
  type: TYPE_NORMAL
- en: To verify that the branch was created on GitHub, go to your GitHub repository
    and click main. You should see a new branch, as shown in [Figure 7-6](#new_branch_ch7).
  prefs: []
  type: TYPE_NORMAL
- en: '![New branch created.](assets/haad_0706.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-6\. Newly created branch
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Back in Codespaces, you will move the Chapters [6](ch06.html#chapter_6) and
    [7](#chapter_7) files to the root of your repository. [Chapter 6](ch06.html#chapter_6)
    contains the final API files and [Chapter 7](#chapter_7) has the SDK files. Enter
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Switch your Codespace back to the *main* branch of your repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Move the API files into your root directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO14-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Move the SDK files into your *sdk* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO14-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Remove all the subdirectories and their files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the directory structure of the completed project, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To update your API documentation to mention your SDK, replace the bottom “Software
    Development Kit (SDK)” section of *README.md* with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You’ve performed some serious surgery to your *main* branch. Make one last commit
    to GitHub, and you’re all done. Congratulations on completing your Part I capstone!
  prefs: []
  type: TYPE_NORMAL
- en: Additional Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For advice on creating an SDK, see the [SDKs.io website](https://sdks.io) by
    APIMatic.
  prefs: []
  type: TYPE_NORMAL
- en: For more advice from Speakeasy on creating a Python SDK, read [“How to Build
    a Best in Class Python SDK” by Tristan Cartledge](https://oreil.ly/B-vKL).
  prefs: []
  type: TYPE_NORMAL
- en: For more advice on writing Pythonic code, check out [*The Hitchhiker’s Guide
    to Python*](https://oreil.ly/ddReB).
  prefs: []
  type: TYPE_NORMAL
- en: To review the benefits of Parquet files for bulk data, read [“Why parquet files
    are my preferred API for bulk open data” by Robin Linacre](https://oreil.ly/OmtmF).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned from experts in SDK development to identify the
    features that make a great Python SDK. Then, you went out and coded it! SDKs like
    the one you developed make life much easier for data scientists and other Python-centric
    users of your API. While coding the SDK, you applied PEP 8 code style and used
    a variety of Pythonic techniques such as list comprehensions and context managers.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](ch08.html#chapter_8), you will start looking at APIs from the
    perspective of the consumer instead of the producer. You will start by learning
    the skills that data scientists should know about APIs.
  prefs: []
  type: TYPE_NORMAL
