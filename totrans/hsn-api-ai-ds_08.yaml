- en: 'Chapter 7\. Batteries Included: Creating a Python SDK'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：内置电池：创建Python SDK
- en: Make the right things easy and the wrong things hard.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让正确的事情变得容易，错误的事情变得困难。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Kathy Sierra
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 凯西·西拉
- en: To create an API data scientists will love, you should give them a *software
    development kit* (SDK) to call the API with. This is an extra step that most API
    producers do not take, but it makes life much easier for your users. In this chapter,
    you will learn the value of SDKs and benefit from practical tips from several
    experts, and then you will create a Python SDK for the SWC Fantasy Football API.
    Building an SDK is the capstone of your Part I portfolio project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数据科学家会喜欢的API，您应该给他们一个用于调用API的*软件开发工具包*（SDK）。这是大多数API生产者不采取的额外步骤，但它使您的用户的生活变得更加容易。在本章中，您将了解SDK的价值，并从几位专家的实用技巧中受益，然后您将为SWC梦幻足球API创建一个Python
    SDK。构建SDK是您第一部分项目组合的顶峰。
- en: SDKs can include code examples, debuggers, and documentation, but the term commonly
    refers to a custom software library that acts as a wrapper for your API. It allows
    developers and data scientists to interact with your API directly in their programming
    language, without requiring extra code to handle API communication.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: SDK可以包括代码示例、调试器和文档，但这个术语通常指的是一个作为您API包装器的自定义软件库。它允许开发者和数据科学家直接在他们的编程语言中使用您的API，而无需编写额外的代码来处理API通信。
- en: '[Figure 7-1](#sdk_API_components_diagram) shows how your users will employ
    an SDK to call your API, instead of calling it directly.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-1](#sdk_API_components_diagram) 展示了用户如何使用SDK调用您的API，而不是直接调用。'
- en: '![SDK Interacting with the API](assets/haad_0701.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![SDK与API交互](assets/haad_0701.png)'
- en: Figure 7-1\. SDK interacting with the API
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-1\. SDK与API交互
- en: SDKs Bridge the Gap
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SDK架起桥梁
- en: To learn the benefits of SDKs and tips for implementing them, I spoke to several
    experienced SDK developers and followed up with written questions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解SDK的好处和实施它们的技巧，我采访了几位经验丰富的SDK开发者，并随后以书面问题的形式进行了跟进。
- en: 'Joey Greco is a software engineer who has created open source SDKs for several
    fantasy football league hosts, including [Sleeper](https://oreil.ly/8dXo_) and
    [MyFantasyLeague](https://oreil.ly/SIPsV). He explains how SDKs help users: “A
    well-built SDK takes care of all the nitty-gritty for you,” he said. “A well-built
    SDK gives me a few lines of code I can copy/paste on my machine along with a few
    examples of how to access and manipulate various data. It tells me what I need
    to do to authenticate (pass your API token into this function, etc.). It’s a great
    way to bridge the gap from an external service to the code that you’re writing.”'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 乔伊·格雷科是一位软件工程师，他为几个梦幻足球联赛主办方创建了开源SDK，包括[Sleeper](https://oreil.ly/8dXo_)和[MyFantasyLeague](https://oreil.ly/SIPsV)。他解释了SDK如何帮助用户：“一个构建良好的SDK为你处理了所有琐碎的事情，”他说。“一个构建良好的SDK给了我一些可以在我的机器上复制/粘贴的代码行，以及一些如何访问和操作各种数据的示例。它告诉我我需要做什么来认证（将您的API令牌传递到这个函数中等等）。这是从外部服务到您所编写的代码之间架起桥梁的绝佳方式。”
- en: It’s useful to remember that developers and data scientists aren’t using your
    API out of an interest in APIs—they have a job to do, and the API helps do the
    job. Wrapping the API in prebuilt program code makes that even simpler. I once
    conducted a usability session with a data-focused user of an API developer portal.
    I was surprised (and maybe slightly insulted) when she told me she didn’t care
    about my APIs—she just wanted the data. For a user like that who just wants the
    data, an SDK will be a time-saver.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点很有用：开发者和数据科学家使用您的API并不是出于对API的兴趣——他们有工作要做，API有助于完成这项工作。将API包装在预构建的程序代码中使这变得更加简单。我曾经与一个专注于数据的API开发者门户的用户进行了一次可用性测试。当她告诉我她对我的API不感兴趣——她只想得到数据时，我感到惊讶（也许还有点受辱）。对于这样一个只想得到数据的用户来说，SDK将是一个节省时间的选择。
- en: Also, consider that your users may use multiple APIs and data sources from different
    providers. The time they spend learning how each API works and configuring their
    code for it is a diversion from their end goal. And not every developer or data
    scientist has experience in using APIs in a resilient and secure manner. A mature
    SDK can provide good software development practices to these users with a minimum
    of trouble.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，考虑到您的用户可能会使用来自不同提供商的多个API和数据源。他们花费在了解每个API的工作方式以及为它配置代码上的时间，这会分散他们最终目标。并不是每个开发者和数据科学家都有在弹性且安全的方式使用API的经验。一个成熟的SDK可以在最小麻烦的情况下为这些用户提供良好的软件开发实践。
- en: 'Simon Yu, cofounder of the SDK generation platform Speakeasy, shares additional
    benefits: “All the boilerplate code that API consumers needed to write before
    is already taken care of by the SDK library itself. Instead of every consumer
    re-inventing the wheel themselves (frustrating, time-consuming, error-prone),
    they simply import the SDK, call the correct method, and go.”'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SDK生成平台Speakeasy的联合创始人Simon Yu分享了额外的益处：“API消费者之前需要编写的所有样板代码现在都由SDK库本身处理。消费者不必自己重新发明轮子（令人沮丧、耗时、易出错），他们只需导入SDK，调用正确的方法，然后继续。”
- en: There’s another benefit too. When developers use an SDK in their IDE, they will
    get auto-complete and type hints while they code. This makes their development
    quicker and also enables generative AI tools such as GitHub CoPilot or AWS CodeWhisperer
    to generate accurate code for them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个好处。当开发者在他们的IDE中使用SDK时，他们在编码过程中将获得自动完成和类型提示。这使得他们的开发速度更快，同时也使得GitHub CoPilot或AWS
    CodeWhisperer等生成式AI工具能够为他们生成准确的代码。
- en: 'Producers benefit from anything that makes it easier to use their APIs. Like
    good API docs, SDKs reduce the friction for new consumers, which reduces the time-to-hello-world
    metric discussed in [Chapter 5](ch05.html#chapter_5). Simon Yu said SDKs can be
    a profitable investment for API producers: “An API consumer (who might also be
    another large enterprise!) often won’t want to pay for a service until they are
    up and running in production. For many API providers, therefore, unblocking API
    consumers also unblocks revenue.”'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者从任何使其API更容易使用的因素中受益。就像好的API文档一样，SDK减少了新消费者的摩擦，从而降低了第5章中讨论的“hello-world时间”指标。Simon
    Yu表示，SDK可以成为API生产者的有利可图的投资：“API消费者（可能也是另一家大型企业！）通常不会在他们的生产环境中运行之前为服务付费。因此，对于许多API提供商来说，解除API消费者的限制也解除了收入的限制。”
- en: 'Yu said SDKs can also reduce API support expenses: “Since SDKs provide a ready-made
    way to integrate with the API and eliminate the need to write custom integration
    code from scratch, they dramatically reduce the support burden required of API
    producers.” He added, “Without SDKs, if an integration doesn’t work, API producers
    often get pulled into 1:1 support, which is extremely costly.”'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Yu表示SDK还可以减少API支持费用：“由于SDK提供了一种现成的与API集成的途径，并消除了从头编写自定义集成代码的需求，它们大大减少了API生产者所需的支持负担。”他补充说，“没有SDK，如果集成出现问题，API生产者经常会被拖入一对一的支持，这代价极高。”
- en: An SDK is a good way to encourage users to use your APIs responsibly by conforming
    to call limits and sending correctly formatted requests. SDKs make doing the right
    thing the easy thing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: SDK是一种鼓励用户负责任地使用你的API的好方法，通过遵守调用限制和发送正确格式化的请求。SDK使得做正确的事情变得容易。
- en: SDKs can be part of an overall API product strategy. One of the best examples
    I have seen is by [StatsBomb (now Hudl StatsBomb)](https://statsbomb.com), a sports
    data and analytics provider. StatsBomb provides football and soccer data with
    a strong emphasis on supporting research and education in the sports field. StatsBomb
    hosts a [sports analytics platform](https://oreil.ly/Orp-g) that provides in-depth
    analysis and visualizations about players and teams from around the world. StatsBomb
    also provides data through a [subscription-based API](https://oreil.ly/CzhyS)
    that allows its customers to pull data into their own analytics software. To support
    researchers and students, it also provides some of its data for free download
    on its [open data GitHub repository](https://oreil.ly/LPGZM).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SDK可以是整体API产品策略的一部分。我所见过的最佳例子之一是来自StatsBomb（现在为Hudl StatsBomb）的案例，它是一家体育数据和数据分析提供商。StatsBomb提供足球和足球数据，并强调支持体育领域的科研和教育。StatsBomb运营一个[体育数据分析平台](https://oreil.ly/Orp-g)，提供关于世界各地球员和球队的深入分析和可视化。StatsBomb还通过一个[基于订阅的API](https://oreil.ly/CzhyS)提供数据，允许其客户将数据拉入自己的分析软件。为了支持研究人员和学生，它还免费提供了一些数据，可在其[开源GitHub仓库](https://oreil.ly/LPGZM)上下载。
- en: 'For StatsBomb, SDKs tie the paid and free services together. The company maintains
    two SDKs for its APIs: [statsbombr](https://oreil.ly/IQO_f) and [statsbombpy](https://oreil.ly/0VOdS).
    As shown in [Figure 7-2](#Statsbombpy_repo), paid subscribers can use the SDK
    to get live data, while nonsubscribers can use the SDK to access static data for
    free. Internally, the SDK gets the paid data from an API and the free data from
    a file download. But this complexity is shielded from the SDK users: they just
    know they get the data they want.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于StatsBomb，SDK将付费和免费服务结合起来。公司为其API维护了两个SDK：[statsbombr](https://oreil.ly/IQO_f)和[statsbombpy](https://oreil.ly/0VOdS)。如图[图7-2](#Statsbombpy_repo)所示，付费订阅者可以使用SDK获取实时数据，而非订阅者可以使用SDK免费访问静态数据。内部，SDK从API获取付费数据，从文件下载获取免费数据。但这种复杂性被屏蔽在SDK用户之外：他们只知道他们得到了他们想要的数据。
- en: '![statsbombpy SDK documentation](assets/haad_0702.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![statsbombpy SDK文档](assets/haad_0702.png)'
- en: Figure 7-2\. The statsbombpy SDK documentation
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-2\. statsbombpy SDK文档
- en: Picking a Language for Your SDK
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的SDK选择一种语言
- en: Your SDK journey starts by knowing your developer audience and how they will
    utilize your APIs.
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您的SDK之旅从了解您的开发者受众以及他们将如何使用您的API开始。
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SDKs.io
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SDKs.io
- en: The first decision that you will make when developing an SDK is which programming
    languages you will support. The SDK does not need to be written in the same language
    that the API is developed in. Instead, it needs to be written in the language
    that the API’s consumers use. They will import the SDK in their code, and use
    it to interact with your API, instead of calling the API directly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发SDK时，您将做出的第一个决定是支持哪些编程语言。SDK不需要用与API开发相同的语言编写。相反，它需要用API消费者使用的语言编写。他们将导入SDK到他们的代码中，并使用它来与您的API交互，而不是直接调用API。
- en: API producers sometimes provide SDKs in multiple languages for different consumers.
    Zan Markan summarized this approach as “Go where the users are.” For data scientists,
    he said, “it’s going to be Python, and there might be some R. Python is so heavily
    used in that community that you want to focus on that.” His view is consistent
    with the “State of Data Science” survey discussed in [Chapter 1](ch01.html#chapter_1),
    which listed Python as the most common language used by data scientists. To get
    started with a Python SDK, an open source tool like the [OpenAPI Python client](https://oreil.ly/cnR-u)
    could be used to generate stubs that you could add more functionality to.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: API提供者有时会为不同的消费者提供多种语言的SDK。Zan Markan将这种方法总结为“去用户所在之处”。对于数据科学家来说，他说：“它将是Python，可能会有一些R。Python在该社区中应用广泛，因此您需要专注于这一点。”他的观点与[第1章](ch01.html#chapter_1)中讨论的“数据科学状态”调查一致，该调查将Python列为数据科学家最常用的语言。要开始使用Python
    SDK，可以使用像[OpenAPI Python客户端](https://oreil.ly/cnR-u)这样的开源工具来生成您可以添加更多功能的存根。
- en: The more languages you create SDKs in, the more maintenance they require. Companies
    like [Speakeasy](https://oreil.ly/speasy), [APIMatic](https://oreil.ly/bpMKs)
    (publisher of SDKs.io), and [Fern](https://oreil.ly/fern) provide commercial tools
    that generate SDKs in multiple languages directly from the OpenAPI Specification
    (OAS) and keep them updated over time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建的SDK语言越多，它们需要的维护就越多。像[Speakeasy](https://oreil.ly/speasy)、[APIMatic](https://oreil.ly/bpMKs)（SDKs.io的出版商）和[Fern](https://oreil.ly/fern)这样的公司提供商业工具，可以直接从OpenAPI规范（OAS）生成多种语言的SDK，并随着时间的推移保持它们更新。
- en: 'Simon Yu explained the benefits of auto-generation services: “Getting the SDK
    design and implementation right is difficult. Maintaining and supporting them
    is even harder. What happens if the team member responsible for updating the SDK
    leaves? Now multiply this problem across all the languages you want to offer the
    SDK in,” he said. “This is where Speakeasy and other SDK generators come in.”'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Simon Yu解释了自动生成服务的优势：“正确地设计SDK实现是困难的。维护和支持它们甚至更难。如果负责更新SDK的团队成员离开了会发生什么？现在将这个问题乘以您想要提供SDK的所有语言，”他说。“这就是Speakeasy和其他SDK生成器发挥作用的地方。”
- en: Starting with a Minimum Viable SDK
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从最小可行SDK开始
- en: 'The last piece of your Part I portfolio project is to create a Python SDK.
    Throughout this chapter, you will learn tips and tricks from API experts and implement
    Python features inspired by them: Francisco Goitia’s [statsbompy](https://oreil.ly/LUiJd),
    SDKs from Simon Yu’s company Speakeasy, and Joey Greco’s [pymfl](https://oreil.ly/ut2nK),
    along with additional reference documentation.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你第一部分项目组合的最后一部分是创建一个Python SDK。在本章中，你将学习API专家的技巧和窍门，并实现受他们启发的Python功能：Francisco
    Goitia的 [statsbompy](https://oreil.ly/LUiJd)、Simon Yu公司的SDK以及Joey Greco的 [pymfl](https://oreil.ly/ut2nK)，以及额外的参考文档。
- en: You will start with a very simple working SDK to make sure the project packaging
    is working. I’ll call this your *minimum viable SDK*. After you verify the package
    works and can be installed, you will add additional features.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从一个非常简单的SDK开始工作，以确保项目打包正常工作。我将称之为你的**最小可行SDK**。在验证包可以正常工作并安装后，你将添加额外的功能。
- en: 'Expert Tip: Making Your SDK Easy to Install'
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专家技巧：使你的SDK易于安装
- en: '...if they can install a Python library with pip install and start using the
    data, it makes their life easier.'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '...如果他们可以使用pip install安装Python库并开始使用数据，这将使他们的生活更轻松。'
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Francisco Goitia, StatsBomb
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 弗朗西斯科·戈伊蒂亚，StatsBomb
- en: Many programming languages have a standard method of downloading and installing
    libraries from an external repository, such as npm for Node.js and Maven for Java.
    Python SDKs are commonly published on the [Python Package Index (PyPI)](https://pypi.org).
    Hosting an SDK on PyPI enables Python developers to install the SDK into their
    environment using the `pip3` tool, as you have done in earlier chapters with libraries
    such as FastAPI and SQLAlchemy. The `pip3` tool can also install packages directly
    from a GitHub repository, if the project is structured correctly. This is how
    you will structure your SDK project and give instructions to users. As a bonus,
    this structure is what is needed to publish to PyPI if you choose to.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言都有从外部存储库下载和安装库的标准方法，例如Node.js的npm和Java的Maven。Python SDK通常发布在 [Python包索引（PyPI）](https://pypi.org)。在PyPI上托管SDK允许Python开发者使用
    `pip3` 工具将SDK安装到他们的环境中，就像你在前面的章节中用FastAPI和SQLAlchemy等库所做的那样。如果项目结构正确，`pip3` 工具还可以直接从GitHub存储库安装包。这就是你将如何构建你的SDK项目并向用户提供说明。作为额外的好处，如果你选择这样做，这种结构也是发布到PyPI所需的。
- en: 'Change the directory to *chapter7* and create the *sdk* folder. Then, change
    to the *sdk* directory and create a file named *pyproject.toml*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将目录更改为 *chapter7* 并创建 *sdk* 文件夹。然后，切换到 *sdk* 目录并创建一个名为 *pyproject.toml* 的文件：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The *pyproject.toml* file provides all the settings that tools like `pip3`
    need to package your code and install it correctly in Python environments. Add
    all of the following text to your *pyproject.toml* file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**pyproject.toml** 文件提供了工具如 `pip3` 需要的所有设置，以便正确打包你的代码并在Python环境中安装它。将以下所有文本添加到你的
    **pyproject.toml** 文件中：'
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO1-1)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO1-1)'
- en: This section selects [setuptools](https://setuptools.pypa.io/en/latest/setuptools.html)
    as the build backend for your project. The Python Packaging Guide lists several
    other choices for the build backend, including Hatchling, Flit, and PDM. I have
    chosen setuptools because all of the example SDKs referenced in this chapter use
    it, and it is simple to use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本节选择 [setuptools](https://setuptools.pypa.io/en/latest/setuptools.html) 作为你的项目的构建后端。Python打包指南列出了其他几个构建后端的选择，包括Hatchling、Flit和PDM。我选择setuptools是因为本章中引用的所有示例SDK都使用它，并且使用起来很简单。
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO1-2)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO1-2)'
- en: This section gives the basics about the package, including name, version, description,
    and author. (You should put your name there—it’s your portfolio project, after
    all.)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了包的基本信息，包括名称、版本、描述和作者。（你应该把你的名字放在那里——毕竟能是你的项目组合。）
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO1-3)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO1-3)'
- en: The version should be updated each time major changes are applied.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每次应用重大更改时，版本都应该更新。
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO1-4)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO1-4)'
- en: This communicates the minimum Python version your package supports.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明你的包支持的最低Python版本。
- en: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO1-5)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO1-5)'
- en: The development status `Alpha` shows that this SDK is in the early stages of
    development.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 开发状态`Alpha`表明此SDK处于开发初期阶段。
- en: '[![6](assets/6.png)](#co_batteries_included__creating_a_python_sdk_CO1-6)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png)[#co_batteries_included__creating_a_python_sdk_CO1-6]'
- en: This section lists the Python libraries that are required for your package to
    work. This is the only section in this chapter that will list dependencies—there
    is no *requirements.txt* file used for the SDK.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本节列出了您的包运行所需的Python库。这是本章中唯一列出依赖关系的部分——SDK不使用*requirements.txt*文件。
- en: 'Expert Tip: Making the SDK Consistent and Idiomatic'
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专家提示：使SDK统一和符合习惯用法
- en: Simon Yu said, “The SDK should be consistent and predictable. Naming conventions,
    error handling, and response format should be the same throughout the SDK to avoid
    unnecessary confusion to users.” For example, your SDK functions returning a single
    item will begin with `get_` and functions returning lists will begin with `list_`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 俞明说：“SDK应该是统一和可预测的。命名约定、错误处理和响应格式应贯穿整个SDK，以避免给用户带来不必要的困惑。”例如，您的SDK函数返回单个项目时将以`get_`开头，而返回列表的函数将以`list_`开头。
- en: Sdks.io says you should make your SDK *idiomatic*, following the norms used
    by other programmers of that language. For a Python SDK, this means that your
    code should be *Pythonic*. This is a broad term, but it means that Python code
    should follow the conventions that other Python programmers and tools use. Python
    is a living language, with new features being added all the time, so the coding
    conventions try to keep up. Conventions are established in the Python community
    through Python Enhancement Proposals or PEPs. If you’d like to understand the
    process, check out [PEP 1 – PEP Purpose and Guidelines](https://oreil.ly/dgQ79).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Sdks.io建议您使您的SDK*符合习惯用法*，遵循该语言其他程序员的规范。对于Python SDK，这意味着您的代码应该是*Pythonic*。这是一个广泛的概念，但意味着Python代码应遵循其他Python程序员和工具使用的约定。Python是一种活的语言，不断添加新功能，因此编码约定试图跟上。约定是通过Python社区中的Python增强提案（PEP）建立的。如果您想了解这个过程，请查看[PEP
    1 – PEP目的和指南](https://oreil.ly/dgQ79)。
- en: 'For the overall style of your SDK, you will be using [PEP 8 – Style Guide for
    Python Code](https://oreil.ly/oersV). The [official Python docs](https://oreil.ly/csNt5)
    provide a good summary of PEP 8 style: use 4-space indentations, keep lines to
    79 characters or less, and use `UpperCamelCase` for classes and `lowercase_with_underscores`
    for functions and methods.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您SDK的整体风格，您将使用[PEP 8 – Python代码风格指南](https://oreil.ly/oersV)。[官方Python文档](https://oreil.ly/csNt5)提供了PEP
    8风格的良好总结：使用4个空格缩进，保持行长度不超过79个字符，并为类使用`UpperCamelCase`，为函数和方法使用`lowercase_with_underscores`。
- en: A few additional Pythonic conventions you will use in your SDK include [PEP
    202 – List Comprehensions](https://oreil.ly/7rivi), [PEP 343 – Context Managers](https://oreil.ly/bgVdx),
    [PEP 257 – Docstrings](https://oreil.ly/q5zA2), [PEP 518 – Build System Requirements](https://oreil.ly/WLYFx),
    and [PEP 484 – Type Hints](https://oreil.ly/RkeOY). These items will be explained
    as they are added to the code in your SDK.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的SDK中，您将使用的一些额外的Pythonic约定包括[PEP 202 – 列推导式](https://oreil.ly/7rivi)、[PEP
    343 – 上下文管理器](https://oreil.ly/bgVdx)、[PEP 257 – 文档字符串](https://oreil.ly/q5zA2)、[PEP
    518 – 构建系统要求](https://oreil.ly/WLYFx)和[PEP 484 – 类型提示](https://oreil.ly/RkeOY)。这些内容将在将它们添加到您的SDK代码中时进行解释。
- en: 'The *swc_client.py* file is the primary client that will interact with your
    API. You will start with a very basic client. Create the directory structure,
    the package initialization file, and the starter Python client:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*swc_client.py*文件是主要的客户端，将与您的API交互。您将从一个非常基础的客户端开始。创建目录结构、包初始化文件和起始Python客户端：'
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO2-1)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_batteries_included__creating_a_python_sdk_CO2-1]'
- en: Because your SDK will be a Python package, each directory that contains code
    will contain a file named *__init__.py*. An empty file can do this job for now.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您的SDK将是一个Python包，所以包含代码的每个目录都将包含一个名为*__init__.py*的文件。现在可以使用一个空文件来完成这项工作。
- en: 'To begin creating the minimal SDK, give the *swc_client.py* file just enough
    functionality to call the health check of the SWC API:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建最小化的SDK，给*swc_client.py*文件添加足够的功能以调用SWC API的健康检查：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO3-1)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_batteries_included__creating_a_python_sdk_CO3-1]'
- en: For now, your `import` statement only contains `httpx`, which is the core Python
    library you will use to interact with the API. The rest of this file defines the
    `SWCClient` class. Users of the SDK will create an instance of the class when
    they call the SDK, by executing the `SWCClient()` method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你的 `import` 语句只包含 `httpx`，这是你将用于与 API 交互的核心 Python 库。本文件的其余部分定义了 `SWCClient`
    类。当 SDK 用户调用 SDK 时，通过执行 `SWCClient()` 方法来创建类的实例。
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO3-2)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_batteries_included__creating_a_python_sdk_CO3-2]'
- en: This is the class constructor, which is executed one time when a client instance
    is created. The method can be used to initiate methods and variables that are
    unique to an individual instance of the class, in contrast to the constant variable
    defined earlier. The `self` parameter is passed as the first parameter to every
    class method in Python, including the constructor.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类构造函数，它在创建客户端实例时执行一次。该方法可以用来初始化类中特定实例的方法和变量，与之前定义的常量变量相对。`self` 参数作为 Python
    中每个类方法（包括构造函数）的第一个参数传递。
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO3-3)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_batteries_included__creating_a_python_sdk_CO3-3]'
- en: The constructor also receives the string parameter `swc_base_url`, which is
    the base address of the API to call. You set the class variable `self.swc_base_url`
    so that this value can be used in the `get_health_check()` method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数还接收一个字符串参数 `swc_base_url`，这是要调用的 API 的基本地址。您设置类变量 `self.swc_base_url`，以便这个值可以在
    `get_health_check()` 方法中使用。
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO3-4)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_batteries_included__creating_a_python_sdk_CO3-4]'
- en: This function calls the API’s health check endpoint.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数调用 API 的健康检查端点。
- en: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO3-5)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)[#co_batteries_included__creating_a_python_sdk_CO3-5]'
- en: The `httpx.Client` has quite a few features available, but for now you are setting
    the base URL and using it to call the `"/"` endpoint, which is your API’s health
    check.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpx.Client` 有很多可用功能，但就目前而言，你正在设置基本 URL 并使用它来调用 `"/"` 端点，这是你的 API 的健康检查。'
- en: To ensure that you have configured your SDK package correctly, it’s time to
    install it in your Codespace with `pip3`. This will use the new source code and
    configuration files you created and install it as a library that you can access
    in Python files. It will also install the dependencies from the *pyproject.toml*
    file’s `dependencies` section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你已经正确配置了 SDK 包，现在是时候使用 `pip3` 在你的 Codespace 中安装它。这将使用你创建的新源代码和配置文件，并将其安装为
    Python 文件中可以访问的库。它还将从 *pyproject.toml* 文件的 `dependencies` 部分安装依赖项。
- en: 'Now install your package locally with the `-e` option, which ensures that the
    package is updated locally as your code changes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用 `-e` 选项本地安装你的包，这确保了随着代码的变化，包在本地得到更新：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `pip` package adds the version number on your Python package from the *py​pro⁠ject.toml*
    file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip` 包从 *pyproject.toml* 文件中添加了 Python 包的版本号。'
- en: 'Congratulations, you have created and installed a Python package! Take a look
    at the files you have created for this minimal SDK. Use the `tree` command, with
    a few options to filter out temporary files created by the build process:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经创建并安装了一个 Python 包！看看你为这个最小 SDK 创建的文件。使用 `tree` 命令，加上一些选项来过滤掉构建过程中创建的临时文件：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Building a Feature-Rich SDK
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建功能丰富的 SDK
- en: Now it’s time to turn the minimum viable SDK into one that is robust and feature
    rich. As you learn expert tips, you can implement them in your code. The goal
    is to make your SDK *batteries included*, which means it comes with all the functionality
    that users need for interacting with your API. This is where an SDK becomes a
    major selling point to your users, and it gives them the ability to get the most
    from your API.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将最小可行 SDK 转变为一个强大且功能丰富的 SDK。随着你学习专家技巧，你可以在你的代码中实现它们。目标是使你的 SDK *内置电池*，这意味着它包含了用户与你的
    API 交互所需的所有功能。这就是 SDK 成为用户主要卖点的地方，它使他们能够从你的 API 中获得最大收益。
- en: 'Expert Tip: Using Sane Defaults'
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专家技巧：使用合理的默认值
- en: A key to hiding complicated details is to implement sane defaults. This means
    that a user can use your SDK without specifying any parameters and it will work
    out of the box. One important default is that the SDK should know the base URL
    of the API without being told. This allows the user to `pip3` install it and use
    it without reading the documentation to know this address. If the SDK is a read-only
    wrapper for a public API, you’ll likely default the production API address. If
    the API requires authentication or is a read/write API, you may want to default
    to a sandbox environment to prevent accidents. The sane defaults will handle the
    *happy path*, the standard usage that 80% of your users will need. The remaining
    20% can be handled by allowing the user to change the configuration to override
    the defaults for special situations they have.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏复杂细节的关键是实施合理的默认设置。这意味着用户可以在不指定任何参数的情况下使用您的SDK，并且它将直接工作。一个重要的默认设置是SDK应该知道API的基本URL，而无需告知。这允许用户使用`pip3`安装它并使用它，而无需阅读文档来了解此地址。如果SDK是公共API的只读包装器，您可能会默认生产API地址。如果API需要身份验证或是一个读写API，您可能希望默认使用沙盒环境以防止意外。合理的默认设置将处理*快乐路径*，即80%的用户将需要的标准用法。剩余的20%可以通过允许用户更改配置以覆盖特殊情况的默认值来处理。
- en: 'You will add sane defaults that the user can override by creating a configuration
    class. Create a file named *swc_config.py* as shown:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您将添加用户可以通过创建配置类来覆盖的合理默认设置。创建一个名为*swc_config.py*的文件，如下所示：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This file defines the `SWCConfig` class. The user will instantiate an instance
    of this class with their configuration settings, and then pass it to the `SWCClient`
    constructor. Then, they will use the `SWCClient` to call the API.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件定义了`SWCConfig`类。用户将使用他们的配置设置实例化此类的实例，并将其传递给`SWCClient`构造函数。然后，他们将使用`SWCClient`来调用API。
- en: 'Update *swc_config.py* with the following content:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下内容更新*swc_config.py*：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO4-1)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_batteries_included__creating_a_python_sdk_CO4-1]'
- en: This import will be used to get environment variables from the Python environment.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此导入将用于从Python环境中获取环境变量。
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO4-2)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_batteries_included__creating_a_python_sdk_CO4-2]'
- en: This statement loads external variables from a *.env* file or the operating
    systems environment.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句从*.env*文件或操作系统的环境中加载外部变量。
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO4-3)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_batteries_included__creating_a_python_sdk_CO4-3]'
- en: The `swc_base_url` will be used to access the API.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`swc_base_url` 将用于访问API。'
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO4-4)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_batteries_included__creating_a_python_sdk_CO4-4]'
- en: The `swc_backoff` determines if the SDK should retry the call using backoff
    when errors occur.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`swc_backoff` 决定在发生错误时SDK是否应使用退避策略重试调用。'
- en: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO4-5)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)[#co_batteries_included__creating_a_python_sdk_CO4-5]'
- en: The `swc_backoff_max_time` The max number of seconds the SDK should keep trying
    an API call before stopping.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`swc_backoff_max_time` 是SDK在停止尝试API调用之前应保持尝试的最大秒数。'
- en: '[![6](assets/6.png)](#co_batteries_included__creating_a_python_sdk_CO4-6)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png)[#co_batteries_included__creating_a_python_sdk_CO4-6]'
- en: The `swc_bulk_file_format` sets the format for bulk files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`swc_bulk_file_format` 设置批量文件的格式。'
- en: '[![7](assets/7.png)](#co_batteries_included__creating_a_python_sdk_CO4-7)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![7](assets/7.png)[#co_batteries_included__creating_a_python_sdk_CO4-7]'
- en: The `__init__` method is executed onced when this class is created. It is used
    to set the class variables from the parameters the user passes in. Default values
    are set in this method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__` 方法在创建此类时执行一次。它用于从用户传递的参数设置类变量。默认值在此方法中设置。'
- en: '[![8](assets/8.png)](#co_batteries_included__creating_a_python_sdk_CO4-8)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![8](assets/8.png)[#co_batteries_included__creating_a_python_sdk_CO4-8]'
- en: This line sets the internal URL from a parameter that passed in the constructor,
    or from the environment if there is no parameter in the constructor.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此行将内部URL设置为构造函数中传递的参数，或在没有参数的情况下从环境中获取。
- en: '[![9](assets/9.png)](#co_batteries_included__creating_a_python_sdk_CO4-9)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![9](assets/9.png)[#co_batteries_included__creating_a_python_sdk_CO4-9]'
- en: This statement checks if a URL has been provided through one of the methods
    described previously. If none is present, this raises an exception and the loading
    stops. This class can’t be used without a URL to access the API.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句检查是否通过之前描述的方法之一提供了URL。如果没有提供，则引发异常并停止加载。此类不能在没有访问API的URL的情况下使用。
- en: '[![10](assets/10.png)](#co_batteries_included__creating_a_python_sdk_CO4-10)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![10](assets/10.png)[#co_batteries_included__creating_a_python_sdk_CO4-10]'
- en: The `__str__` method is used by external programs to log the contents of this
    class. If you don’t provide a custom method like this, a default method would
    be created, but it might have less useful information.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`__str__` 方法被外部程序用于记录此类的内容。如果你不提供这样的自定义方法，将会创建一个默认方法，但它可能包含较少有用的信息。'
- en: 'Next, modify the *__init__.py* file in the *chapter7/sdk/src/swcpy* directory
    so that it looks like the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改 *chapter7/sdk/src/swcpy* 目录中的 *__init__.py* 文件，使其看起来如下：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These imports simplify the process of importing the classes in a user’s code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些导入简化了在用户的代码中导入类的过程。
- en: 'Expert Tip: Providing Rich Functionality'
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专家提示：提供丰富的功能
- en: 'Simon Yu suggested that an SDK should be rich with features that save a significant
    amount of coding for developers. A survey of the SDKs I reviewed in this chapter
    found features such as handling versions, handling pagination, client-side caching,
    and authentication. You will include two advanced features: data type validation
    and retry/backoff logic.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 西蒙·余建议，一个SDK应该具有丰富的功能，以显著减少开发者的编码工作。在本章中，我对所审查的SDK进行了调查，发现了一些功能，例如处理版本、处理分页、客户端缓存和身份验证。你将包括两个高级功能：数据类型验证和重试/退避逻辑。
- en: 'It is time-consuming for end users to add data validation in their code. They
    have to read the API documentation to determine valid data types and values, and
    then add a lot of code that checks values and throws errors. When SDK developers
    add data validation, this is a big benefit to users. The original API developers
    have detailed knowledge of the workings of the API, which makes it easier for
    them to add validations to the SDK. You have an additional advantage for this
    Python SDK: access to the original Pydantic classes the API was built with. You
    can reuse the Chapter 7 *schemas.py* file in your SDK, giving your SDK powerful
    data validation at a minimal effort.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最终用户来说，在他们的代码中添加数据验证是耗时的工作。他们必须阅读API文档以确定有效的数据类型和值，然后添加大量检查值并抛出错误的代码。当SDK开发者添加数据验证时，这对用户来说是一个很大的好处。原始API开发者对API的工作原理有详细的了解，这使得他们更容易在SDK中添加验证。对于这个Python
    SDK，你还有一个额外的优势：可以访问API构建时使用的原始Pydantic类。你可以在你的SDK中重用第7章的 *schemas.py* 文件，以最小的努力为你的SDK提供强大的数据验证。
- en: 'Create a *schemas* folder and *__init__.py*file as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 *schemas* 文件夹和 *__init__.py* 文件，如下所示：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Copy the schemas file from the *chapter6* directory (or *chapter6/complete*
    if you haven’t finished [Chapter 6](ch06.html#chapter_6)) into this chapter’s
    directories as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *chapter6* 目录（或 *chapter6/complete*，如果你还没有完成[第6章](ch06.html#chapter_6)）中的
    schemas 文件复制到本章目录中，如下所示：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now you will rebuild the client from scratch, step by step. First, you will
    add the imports and the class constructor. Replace the entire *swc_client.py*
    file with the following content:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将从头开始逐步重建客户端。首先，你将添加导入和类构造函数。用以下内容替换整个 *swc_client.py* 文件：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO5-1)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_batteries_included__creating_a_python_sdk_CO5-1]'
- en: This imports the *swc_config.py* file you created.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这导入了你创建的 *swc_config.py* 文件。
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO5-2)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_batteries_included__creating_a_python_sdk_CO5-2]'
- en: This is used to import the Pydantic schemas.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于导入Pydantic模式。
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO5-3)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_batteries_included__creating_a_python_sdk_CO5-3]'
- en: This is used for additional type hints for the Pydantic classes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于为Pydantic类提供额外的类型提示。
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO5-4)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_batteries_included__creating_a_python_sdk_CO5-4]'
- en: This is used to implement exponential backoff.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于实现指数退避。
- en: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO5-5)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)[#co_batteries_included__creating_a_python_sdk_CO5-5]'
- en: This import statement and the following line of code are used to log debug and
    error messages.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入语句和随后的代码行用于记录调试和错误信息。
- en: '[![6](assets/6.png)](#co_batteries_included__creating_a_python_sdk_CO5-6)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png)[#co_batteries_included__creating_a_python_sdk_CO5-6]'
- en: This adds class constants for all the API’s endpoints.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这为API的所有端点添加了类常量。
- en: '[![7](assets/7.png)](#co_batteries_included__creating_a_python_sdk_CO5-7)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![7](assets/7.png)[#co_batteries_included__creating_a_python_sdk_CO5-7]'
- en: You need to replace the `*[github ID]*` with your GitHub ID so that the path
    to the bulk files works correctly.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将 `*[github ID]*` 替换为你的GitHub ID，以确保批量文件的路径正确。
- en: '[![8](assets/8.png)](#co_batteries_included__creating_a_python_sdk_CO5-8)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![8](assets/8.png)(#co_batteries_included__creating_a_python_sdk_CO5-8)'
- en: The `SWCClient` class constructor accepts an instance of `SWCConfig` now. The
    user puts all of their configuration in this object and passes it to the client.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`SWCClient`类构造函数现在接受`SWCConfig`实例。用户将所有配置放入此对象中，并将其传递给客户端。'
- en: '[![9](assets/9.png)](#co_batteries_included__creating_a_python_sdk_CO5-9)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![9](assets/9.png)(#co_batteries_included__creating_a_python_sdk_CO5-9)'
- en: This creates a dictionary of bulk filenames without a file extension.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个不带文件扩展名的批量文件名字典。
- en: '[![10](assets/10.png)](#co_batteries_included__creating_a_python_sdk_CO5-10)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![10](assets/10.png)(#co_batteries_included__creating_a_python_sdk_CO5-10)'
- en: This is a conditional decorator, which will update the `call_api()` method to
    have backoff functionality if the user configures it. The backoff will be explained
    further later.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个条件装饰器，如果用户配置它，将更新`call_api()`方法以具有回退功能。回退功能将在稍后进一步解释。
- en: '[![11](assets/11.png)](#co_batteries_included__creating_a_python_sdk_CO5-11)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![11](assets/11.png)(#co_batteries_included__creating_a_python_sdk_CO5-11)'
- en: This code appends a file extension of *.csv* or *.parquet* to the filenames
    dictionary. It uses a dictionary comprehension, which is an efficient and Pythonic
    way to update all the elements in a dictionary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将*.csv*或*.parquet*文件扩展名追加到文件名字典中。它使用字典推导式，这是一种高效且Pythonic的方式来更新字典中的所有元素。
- en: The retry and backoff functionality you added in the client has a few unexpected
    twists and turns. When you make an API call from your SDK, sometimes it may fail
    due to a temporary network hiccup or slowdown in the API. It might be due to a
    load-balancing issue or a service that is in the middle of bringing more servers
    online to handle increased load. If you are running a process that uses the API,
    you can make it more resilient by retrying a few times before giving up.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你在客户端添加的重试和回退功能有几个意想不到的转折。当你从你的SDK中发起API调用时，有时可能会因为暂时的网络故障或API的减速而失败。这可能是因为负载均衡问题，或者是因为服务正在中间阶段上线更多服务器以处理增加的负载。如果你正在运行使用API的过程，你可以在放弃之前尝试重试几次，使其更具弹性。
- en: However, the way you retry may cause some unexpected consequences on the API
    provider. For example, you could decide that if an API call fails, you will continually
    retry every microsecond until it succeeds. This would be the equivalent of a web
    user clicking Refresh continually until the web page is back up. One user doing
    that might not cause that much of a headache. But what about when hundreds or
    thousands of users are retrying the API continually in the middle of a network
    outage, or when an API provider is trying to bring more resources online? These
    users will be hitting it with a massive load at a time when it’s least able to
    respond. This is like an accidental distributed denial-of-service (DDOS) attack
    from your own users.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你的重试方式可能会对API提供商产生一些意想不到的后果。例如，你可能会决定如果API调用失败，你将不断地每毫秒重试，直到成功。这相当于一个网络用户不断地点击刷新，直到网页恢复。一个用户这样做可能不会造成太大的麻烦。但是，当数百或数千个用户在断网期间不断地重试API，或者当API提供商试图上线更多资源时，会发生什么？这些用户将在它最无法响应的时候给它带来巨大的负载。这就像是你自己的用户意外地发起了一次分布式拒绝服务（DDOS）攻击。
- en: API consumers and SDK developers can implement *exponential backoff* instead
    of simple retries. With this method, the time between retries gets exponentially
    longer with each failed attempt. This method recognizes that a service that is
    failing needs a break, and the more failures that happen, the more of a break
    it needs. For example, a client might double the time between retries each time
    it fails. Using this method, it would retry at 1 second, 2 seconds, 4 seconds,
    8 seconds, and so on until it reached a preset stopping point.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: API消费者和SDK开发者可以实施指数回退而不是简单的重试。使用这种方法，每次失败尝试之间的时间会指数级地变长。这种方法认识到一个失败的服务需要休息，并且发生的失败越多，它需要的休息就越多。例如，客户端可能会在每次失败时将重试之间的时间加倍。使用这种方法，它会在1秒、2秒、4秒、8秒等重试，直到达到预设的停止点。
- en: This is an improvement, but can you see any issue with everyone using this method?
    The problem is explained very clearly on AWS’s *Architecture* blog in [“Exponential
    Backoff And Jitter”](https://oreil.ly/tSRCm), and [Figure 7-3](#attempts_per_second_ch7)
    gives a simplified visualization. The numbers across the bottom are seconds after
    an outage, and the vertical bars are the number of retry attempts occurring in
    that second.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种改进，但你能否看到使用这种方法可能存在的问题？问题在AWS的 *架构* 博客中解释得非常清楚，在“指数退避与抖动”（[“Exponential
    Backoff And Jitter”](https://oreil.ly/tSRCm)）中，[图7-3](#attempts_per_second_ch7)
    提供了一个简化的可视化。底部数字是故障后的秒数，垂直条是那一秒内发生的重试尝试次数。
- en: '![The problem with exponential backoff](assets/haad_0703.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![指数退避的问题](assets/haad_0703.png)'
- en: Figure 7-3\. The problem with exponential backoff
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-3. 指数退避的问题
- en: As you can see from the image, if multiple people are using the same settings
    for exponential backoff (as they would be if they’re all using your SDK with defaults),
    they are likely to still cluster around the same intervals to retry. This is because,
    when an outage occurs, it will probably hit many users at the same time, starting
    their retry clock. This is not what you want. The solution is to introduce *jitter*,
    which is a somewhat random element that is combined with the backoff. Using this
    method, you get the benefit of backing off retries without the clustering of retries
    in the same intervals. The best of both worlds is exponential backoff with jitter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，如果多个人使用相同的指数退避设置（如果他们都使用你的SDK默认设置，这种情况很常见），他们很可能会在相同的间隔内进行重试。这是因为，当出现故障时，它可能会同时影响许多用户，开始他们的重试计时器。这不是你想要的。解决方案是引入
    *抖动*，这是一个与退避相结合的随机元素。使用这种方法，你可以在不重试相同间隔的情况下获得退避重试的好处。这是两者的最佳结合：指数退避与抖动。
- en: The code you added to *swc_client.py* implemented exponential backoff with random
    jitter using the [backoff Python library](https://oreil.ly/PUZbE). To use this
    library, you added the decorator `backoff.on_exception` onto the `call_api()`
    function. This wraps the function call with backoff, without having to make any
    changes to the function itself. If the SDK user uses backoff, the `call_api()`
    function will be wrapped with this additional functionality.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加到 *swc_client.py* 中的代码实现了使用 [backoff Python库](https://oreil.ly/PUZbE) 的指数退避和随机抖动。为了使用这个库，你在
    `call_api()` 函数上添加了装饰器 `backoff.on_exception`。这会将退避功能包装在函数调用中，而无需对函数本身进行任何修改。如果SDK用户使用退避，`call_api()`
    函数将被包装上这个额外的功能。
- en: 'Take another look at the decorator you added to your code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视你添加到代码中的装饰器：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO6-1)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_batteries_included__creating_a_python_sdk_CO6-1]'
- en: If an exception occurs, retry starting at 1 second, then doubling every retry.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生异常，从1秒开始重试，然后每次重试加倍。
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO6-2)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_batteries_included__creating_a_python_sdk_CO6-2]'
- en: Look for `RequestError` and `HTTPStatusError` exceptions from the `call_api`
    function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `call_api` 函数中查找 `RequestError` 和 `HTTPStatusError` 异常。
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO6-3)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_batteries_included__creating_a_python_sdk_CO6-3]'
- en: Stop retrying after the `backoff_max_time` parameter (which defaults to 30 seconds).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `backoff_max_time` 参数（默认为30秒）后停止重试。
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO6-4)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_batteries_included__creating_a_python_sdk_CO6-4]'
- en: Apply random jitter so that it varies slightly from the exact second.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 应用随机抖动，使其与精确的秒数略有不同。
- en: 'Expert Tip: Performing Logging'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专家提示：执行日志记录
- en: You don’t want your SDK to be a black box—you want users to understand what’s
    occurring under the hood. One way to do this is by publishing the source code
    on a public repository. The other is by providing meaningful logging, which helps
    when the user is encountering errors or isn’t returning the results expected.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望你的SDK成为一个黑盒——你希望用户理解底层发生了什么。实现这一目标的一种方式是将源代码发布在公共仓库上。另一种方式是提供有意义的日志记录，这有助于用户在遇到错误或未返回预期结果时。
- en: To be Pythonic, your SDK will use Python’s built-in *logging* library, and allow
    the users to configure what level of logging they want to print. For example,
    they may only want to log serious errors in production logs while logging debug
    messages during development. [Table 7-1](#python_logging_levels_ch7) shows the
    logging levels available, according to the [official Python docs](https://oreil.ly/CmUps).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了 Pythonic，您的 SDK 将使用 Python 的内置 *logging* 库，并允许用户配置他们想要打印的日志级别。例如，他们可能只想在生产日志中记录严重错误，而在开发期间记录调试消息。[表
    7-1](#python_logging_levels_ch7) 显示了可用的日志级别，根据 [官方 Python 文档](https://oreil.ly/CmUps)。
- en: Table 7-1\. Python logging levels
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1\. Python 日志级别
- en: '| Level | What it means/when to use it |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 级别 | 它的含义/何时使用 |'
- en: '| --- | --- |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `logging.DEBUG` | Detailed information, typically only of interest to a developer
    trying to diagnose a problem. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `logging.DEBUG` | 详细信息，通常只有试图诊断问题的开发者感兴趣。 |'
- en: '| `logging.INFO` | Confirmation that things are working as expected. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `logging.INFO` | 确认事情按预期进行。 |'
- en: '| `logging.WARNING` | An indication that something unexpected happened, or
    that a problem might occur in the near future (e.g., disk space low). The software
    is still working as expected. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `logging.WARNING` | 表明发生了意外情况，或者可能在不久的将来发生问题（例如，磁盘空间低）。软件仍在按预期工作。 |'
- en: '| `logging.ERROR` | Indicates that, due to a more serious problem, the software
    has not been able to perform some function. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `logging.ERROR` | 表示由于更严重的问题，软件无法执行某些功能。 |'
- en: '| `logging.CRITICAL` | A serious error, indicating that the program itself
    may be unable to continue running. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `logging.CRITICAL` | 严重错误，表明程序本身可能无法继续运行。 |'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, you will see logging messages in the terminal when you run
    `pytest` if an error occurs. By default, any messages with a log level of `WARNING`
    or more severe will be displayed. If you want to see `INFO` or `DEBUG` messages,
    you can use the `--log-level` command-line option.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，如果您在运行 `pytest` 时发生错误，您将在终端中看到日志消息。默认情况下，任何具有 `WARNING` 或更高级别日志级别的消息都将显示。如果您想看到
    `INFO` 或 `DEBUG` 消息，可以使用 `--log-level` 命令行选项。
- en: 'You added the import statements and created a `logger` object earlier in this
    chapter. You will see this functionality in action in a new method that you will
    create, named `call_api()`. Add the following code at the bottom of *swc_client.py*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本书前面添加了导入语句并创建了一个 `logger` 对象。您将在创建的新方法 `call_api()` 中看到此功能的应用。在 *swc_client.py*
    的底部添加以下代码：
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO7-1)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO7-1)'
- en: Because this is a class method, the first parameter is always `self`, which
    represents the instance of this class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个类方法，第一个参数总是 `self`，它代表这个类的实例。
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO7-2)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO7-2)'
- en: The second parameter to this method is the individual endpoint you are calling.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的第二个参数是您要调用的单个端点。
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO7-3)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO7-3)'
- en: The query string parameters for the API call are passed in as an optional dictionary.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: API调用的查询字符串参数以可选字典的形式传递。
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO7-4)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO7-4)'
- en: This is a type hint that the method should return an `httpx.Response` object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个类型提示，表示该方法应返回一个 `httpx.Response` 对象。
- en: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO7-5)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO7-5)'
- en: This dictionary comprehension removes any empty parameters before calling the
    API with them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字典推导式在调用 API 之前移除了任何空参数。
- en: '[![6](assets/6.png)](#co_batteries_included__creating_a_python_sdk_CO7-6)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_batteries_included__creating_a_python_sdk_CO7-6)'
- en: This is a context manager that uses `httpx.Client` for the steps that follow.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个上下文管理器，它使用 `httpx.Client` 执行后续步骤。
- en: '[![7](assets/7.png)](#co_batteries_included__creating_a_python_sdk_CO7-7)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_batteries_included__creating_a_python_sdk_CO7-7)'
- en: This is logging at the `logging.DEBUG` level. The parameters are formatted with
    an F-string, which is a Pythonic way of formatting variable values.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 `logging.DEBUG` 级别的日志记录。参数使用 F-string 格式化，这是一种格式化变量值的 Pythonic 方法。
- en: The `call_api` function is used to make the API calls for each SDK function.
    By centralizing this work, you can apply additional error handling and logging
    without making your code too long. It adds `try…​except` logic around the API
    call. If the API call works, this function logs a `logging.DEBUG` level message
    with the data from the response.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`call_api` 函数用于为每个SDK函数进行API调用。通过集中这项工作，你可以应用额外的错误处理和日志记录，而不会使你的代码太长。它围绕API调用添加了
    `try…​except` 逻辑。如果API调用成功，这个函数会记录一个 `logging.DEBUG` 级别的消息，包含响应中的数据。'
- en: 'Let’s take a closer look at a key line of code in this method:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个方法中的一条关键代码行：
- en: '[PRE14]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When a statement uses the `with…​as` format like this, it is using a Python
    object as a *context manager*, so that the object is initialized, then the statements
    inside it run, and then it is cleaned up along with any resources it used. Here,
    the `httpx.Client` is the context manager.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个语句使用 `with…​as` 这种格式时，它使用Python对象作为 *上下文管理器*，这样对象就会被初始化，然后运行其中的语句，然后清理它所使用的任何资源。在这里，`httpx.Client`
    是上下文管理器。
- en: According to the [HTTPX documentation](https://oreil.ly/I-xln), the `httpx.Client`
    is an efficient way to make API calls using *httpx* because it pools resources
    between API calls. The `Client` constructor accepts the parameter `base_url` and
    will use it for all of the API calls it is used for.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 [HTTPX 文档](https://oreil.ly/I-xln)，`httpx.Client` 是使用 *httpx* 进行API调用的有效方式，因为它在API调用之间池化资源。`Client`
    构造函数接受 `base_url` 参数，并将用于它所使用的所有API调用。
- en: This code is contained inside at `try…​except` block, so if the API call doesn’t
    work, the `except` first handles `httpx.HTTPStatusError`, which is a type of error
    that will have an HTTP status code. For this type of exception, it logs a `logging.ERROR`
    level message and then re-raises the exception. If it’s not that type of exception,
    it handles `httpx.RequestError` next. This type of exception doesn’t have an HTTP
    status code, so it just puts the body of the exception in the log message. Then
    it re-raises the exception. Re-raising the exception is important because you
    will be adding retry and backoff logic later in this chapter, and it will be looking
    for those exceptions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含在 `try…​except` 块中，所以如果API调用不成功，`except` 首先处理 `httpx.HTTPStatusError`，这是一种将带有HTTP状态码的错误类型。对于这种类型的异常，它会记录一个
    `logging.ERROR` 级别的消息，然后重新抛出异常。如果不是那种类型的异常，它接下来处理 `httpx.RequestError`。这种异常没有HTTP状态码，所以它只是在日志消息中放入异常的正文。然后重新抛出异常。重新抛出异常是很重要的，因为你在本章后面将添加重试和退避逻辑，并且它将寻找那些异常。
- en: 'Expert Tip: Hiding Your API’s Complicated Details'
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专家提示：隐藏你的API复杂细节
- en: Joey Greco likes SDKs to handle some of the complexities of the underlying API.
    “As a data consumer, I don’t want to have to worry about API versioning, headers,
    authentication, rate-limiting, or hunting down the correct endpoints to use,”
    he said. “I just want to call some function and be able to do things that are
    meaningful to me.”
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 乔伊·格雷科喜欢SDK处理底层API的一些复杂性。“作为一个数据消费者，我不想担心API版本、头信息、身份验证、速率限制或寻找正确的端点来使用，”他说。“我只希望调用一些函数，并能够做对我有意义的事情。”
- en: Now add the `get_health_check` and `list_leagues` methods to the bottom of the
    file. Endpoint methods like `get_health_check` and `list_leagues` wrap the API
    calls and shield users from complicated details such as endpoint names and return
    types. It’s not an exaggeration to say that methods like these are the reason
    that SDKs exist.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将 `get_health_check` 和 `list_leagues` 方法添加到文件的底部。像 `get_health_check` 和 `list_leagues`
    这样的端点方法封装了API调用，并保护用户免受复杂的细节，如端点名称和返回类型。说这些方法的存在是SDK存在的原因并不夸张。
- en: 'These both use the `call_api` function that you created. The `list_leagues`
    method also uses Pydantic to validate the data returned from the API. If the data
    from the API does not match the Pydantic class definition, the client will throw
    an error that can be logged. Add the following code to the bottom of the *swc_client.py*
    file:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都使用了你创建的 `call_api` 函数。`list_leagues` 方法还使用 Pydantic 验证API返回的数据。如果API的数据与Pydantic类定义不匹配，客户端将抛出一个错误，可以被记录。将以下代码添加到
    *swc_client.py* 文件的底部：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO8-1)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)(#co_batteries_included__creating_a_python_sdk_CO8-1)'
- en: The new `get_health_check()` method uses the `call_api()` method, instead of
    calling the API directly as it did in the minimal SDK.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `get_health_check()` 方法使用 `call_api()` 方法，而不是像最小SDK那样直接调用API。
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO8-2)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO8-2)'
- en: The type hint shows that the method should return a `List` of `League` objects.
    `League` is a Pydantic class defined in the *schemas.py* file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示显示，该方法应返回一个`List`类型的`League`对象列表。`League`是一个在`*schemas.py*`文件中定义的Pydantic类。
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO8-3)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO8-3)'
- en: The parameters will be passed in when users call this SDK method. This line
    of code builds a dictionary containing the parameters.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户调用此SDK方法时，参数将被传递。这一行代码构建了一个包含参数的字典。
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO8-4)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO8-4)'
- en: This method also calls the `call_api` method and passes in the query string
    parameters as a dictionary.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法还调用了`call_api`方法，并将查询字符串参数作为字典传递。
- en: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO8-5)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO8-5)'
- en: This looks through the list of dictionaries returned in the API response and
    populates a `List` of `League` objects.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这将遍历API响应中返回的字典列表，并填充一个`List`类型的`League`对象列表。
- en: 'Take a look at the final line of code in `list_leagues()`, which packs a lot
    into a short syntax:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`list_leagues()`函数中的最后一行代码，它在一个简短的语法中包含了大量内容：
- en: '[PRE16]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Your goal in this statement is to iterate through the list of dictionaries returned
    from the API and create a list of Pydantic `League` objects. You use a [list comprehension](https://oreil.ly/Fpgem),
    which is a Pythonic way to build lists without using a recursive loop. Using the
    general syntax `list = [expression for item in iterable]`, you can create lists
    from other lists very easily.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语句中，您的目标是遍历API返回的字典列表，创建一个Pydantic `League`对象列表。您使用了一个[列表推导](https://oreil.ly/Fpgem)，这是一种不使用递归循环的Pythonic方式来构建列表。使用通用语法`list
    = [expression for item in iterable]`，您可以从其他列表中非常容易地创建列表。
- en: As you iterate through, you want to create a Pydantic `League` object from each
    dictionary in the original list. You can do this with Python’s *unpacking operator*.
    The statement `League(**league)` uses two asterisks to unpack the original dictionary
    into key-value pairs that are passed to the `League()` constructor. Pydantic performs
    data validation during the process of creating these objects, so if any invalid
    data is in the API response, it will error out in this step. With this combination
    of list comprehension and the unpacking operator, you return a list of `League`
    objects that have been validated from the original list of dictionaries.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代过程中，您希望从原始列表中的每个字典创建一个Pydantic `League`对象。您可以使用Python的*解包运算符*来完成此操作。语句`League(**league)`使用两个星号将原始字典解包成键值对，这些键值对被传递给`League()`构造函数。Pydantic在创建这些对象的过程中执行数据验证，因此如果API响应中存在任何无效数据，它将在这一步出错。通过这种列表推导和解包运算符的组合，您返回一个经过验证的`League`对象列表，这些对象来自原始的字典列表。
- en: 'Expert Tip: Supporting Bulk Downloads'
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专家技巧：支持批量下载
- en: As a data scientist, I find the complexity of many open data services frustrating.
    I don’t want to have to learn how to query an endpoint, think about data types,
    or read through API documentation. Just give me the data!
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为一名数据科学家，我发现许多公开数据服务的复杂性令人沮丧。我不想学习如何查询端点、考虑数据类型或阅读API文档。只给我数据！
- en: ''
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Robin Linacre
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 罗宾·林内克
- en: Bulk downloads are valuable for many API users, but data scientists especially
    like this feature. Data scientists often use full datasets for analysis and loading
    data, and they find it frustrating to call multiple endpoints to get subsets of
    the data. You could serve bulk downloads from an endpoint in your API using [FastAPI’s
    Static Files](https://oreil.ly/58q0a).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 批量下载对许多API用户来说非常有价值，但数据科学家尤其喜欢这个功能。数据科学家经常使用完整的数据集进行分析和数据加载，他们发现调用多个端点以获取数据子集非常令人沮丧。您可以使用[FastAPI的静态文件](https://oreil.ly/58q0a)从API的端点提供批量下载。
- en: 'Instead, you will be serving bulk downloads from SDK methods. Your SDK will
    access the files from their web-hosted location in your GitHub repository. The
    URL for each file will be built using the `BULK_FILE_BASE_URL` and the `BULK_FILE_NAMES`
    dictionaries. Your repository contains two bulk files for each table you loaded
    in your SQLite database: one in *.csv* format and one in *.parquet* format. By
    providing these two options, your SDK serves a wide range of bulk data needs.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您将通过 SDK 方法提供批量下载。您的 SDK 将从您 GitHub 仓库中的网络托管位置访问文件。每个文件的 URL 将使用 `BULK_FILE_BASE_URL`
    和 `BULK_FILE_NAMES` 字典构建。您的仓库包含您在 SQLite 数据库中加载的每个表的两个批量文件：一个为 *.csv* 格式，另一个为
    *.parquet* 格式。通过提供这两种选项，您的 SDK 能够满足广泛的批量数据需求。
- en: 'The bulk files are in the *bulk* folder of your repository. View the list of
    these files with the following commands:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 批量文件位于您的仓库的 *bulk* 文件夹中。使用以下命令查看这些文件的列表：
- en: '[PRE17]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The files with the *.csv* extension are *comma-separated values* files. The
    following shows the first two rows of the *player_data.csv* file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 具有 *.csv* 扩展名的文件是 *逗号分隔值* 文件。以下显示了 *player_data.csv* 文件的头两行：
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These are plain-text files with no compression of any kind. The first row contains
    the column names separated by commas. The remaining rows contain one row for each
    data record and the data values are separated by commas. CSV files are easily
    processed in Python libraries such as pandas or in software such as Microsoft
    Excel.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是没有任何压缩的纯文本文件。第一行包含用逗号分隔的列名。其余行包含每个数据记录的一行，数据值由逗号分隔。CSV 文件在 Python 库（如 pandas）或软件（如
    Microsoft Excel）中很容易处理。
- en: '*Parquet files* use an open source data format that is popular for a variety
    of data analysis tasks. Here is the official definition from the [Apache Parquet
    project page](https://oreil.ly/K4_0_): “Apache Parquet is an open source, column-oriented
    data file format designed for efficient data storage and retrieval. It provides
    high performance compression and encoding schemes to handle complex data in bulk
    and is supported in many programming language and analytics tools.”'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*Parquet 文件* 使用一种开源数据格式，这种格式在多种数据分析任务中都很受欢迎。以下是来自 [Apache Parquet 项目页面](https://oreil.ly/K4_0_)
    的官方定义：“Apache Parquet 是一种开源的列式数据文件格式，旨在高效地存储和检索数据。它提供了高性能的压缩和编码方案来处理大量复杂数据，并且被许多编程语言和数据分析工具所支持。”'
- en: You will create a separate method to retrieve each file, but the method will
    retrieve either *.csv* or *.parquet* format files based upon the options provided
    in the `bulk_file_format` parameter the user selects in the `SWCConfig` class.
    The default value is *.csv* if the user does not provide this parameter.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您将创建一个单独的方法来检索每个文件，但该方法将根据用户在 `SWCConfig` 类中选择的 `bulk_file_format` 参数来检索 *.csv*
    或 *.parquet* 格式的文件。如果用户未提供此参数，则默认值为 *.csv*。
- en: 'Add the following method at the bottom of *swc_client.py*:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *swc_client.py* 的底部添加以下方法：
- en: '[PRE19]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO9-1)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO9-1)'
- en: The type hint for this method is `bytes` because the Parquet file is a binary
    file, not text.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的类型提示为 `bytes`，因为 Parquet 文件是二进制文件，而不是文本。
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO9-2)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO9-2)'
- en: This statement builds the URL to an individual file from the web-hosted location
    in your GitHub repository using the `BULK_FILE_BASE_URL` and `BULK_FILE_NAMES`
    dictionaries.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句使用 `BULK_FILE_BASE_URL` 和 `BULK_FILE_NAMES` 字典从您的 GitHub 仓库的网络托管位置构建单个文件的
    URL。
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO9-3)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO9-3)'
- en: Instead of using the `call_api` method, like the other methods do, this method
    uses the `httpx.get()` method. The `follow_redirects` parameter handles any web
    redirects that occur when retrieving the file.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他方法不同，此方法使用 `httpx.get()` 方法，而不是 `call_api` 方法。`follow_redirects` 参数处理在检索文件时发生的任何网页重定向。
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO9-4)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO9-4)'
- en: The method returns `response.content`, which will contain the binary file.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回 `response.content`，其中将包含二进制文件。
- en: 'You have created methods that implement all the major functionality of your
    SDK, although you haven’t created methods for all the endpoints or bulk files
    yet. Update your *pyproject.toml* file to contain all the new libraries you’ve
    added, and increment your version number:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经创建了实现您SDK所有主要功能的方法，尽管您还没有为所有端点或批量文件创建方法。更新您的*pyproject.toml*文件以包含您已添加的所有新库，并增加版本号：
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO10-1)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO10-1)'
- en: Increment the version number of the library to reflect all the new functionality.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将库的版本号增加以反映所有新的功能。
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO10-2)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO10-2)'
- en: Import the Pydantic library for your data validation.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 导入用于数据验证的Pydantic库。
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO10-3)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO10-3)'
- en: Import the backoff library for your backoff and retry functionality.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 导入用于回退和重试功能的backoff库。
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO10-4)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO10-4)'
- en: Import the PyArrow library for handling Parquet files.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 导入PyArrow库以处理Parquet文件。
- en: 'Expert Tip: Documenting Your SDK'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专家提示：记录您的SDK
- en: Just as APIs need documentation, so does your SDK. Since your SDK will be used
    directly in program code, the first step to documenting your SDK is to add comprehensive
    docstrings to the methods that will be used by programmers. This is an important
    part of writing Pythonic code, and it helps data scientists using your SDK in
    an IDE like VS Code to get hints and code completion that make their work faster
    and more accurate. As more data scientists use generative AI in their development
    process, it allows AI assistants and copilots to infer accurate coding suggestions.
    You provided extensive docstrings in the *swc_client.py* and *swc_config.py* files.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 就像API需要文档一样，您的SDK也需要。由于您的SDK将直接用于程序代码中，记录您的SDK的第一步是为程序员将使用的方法添加全面的docstrings。这是编写Pythonic代码的重要部分，它有助于使用VS
    Code等IDE的数据科学家使用您的SDK时获得提示和代码补全，从而加快他们的工作速度并提高准确性。随着越来越多的数据科学家在开发过程中使用生成式AI，它允许AI助手和共飞行员推断出准确的编码建议。您在*swc_client.py*和*swc_config.py*文件中提供了广泛的docstrings。
- en: You also need to include a well-written *README.md* file that explains how to
    install the SDK and provides examples of using it. This file will be displayed
    by default in the GitHub repository for your SDK, and it will be the home page
    for your SDK if you publish it to PyPI.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要包括一个编写良好的*README.md*文件，解释如何安装SDK并提供使用示例。此文件将默认显示在您的SDK的GitHub仓库中，如果您将其发布到PyPI，它将是SDK的主页。
- en: 'Create the *README.md* file as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式创建*README.md*文件：
- en: '[PRE21]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following contents to this file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到该文件中：
- en: '[PRE22]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: SWC_API_BASE_URL={URL of your API}
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: SWC_API_BASE_URL={您的API的URL}
- en: '[PRE23]python'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]python'
- en: from swcpy import SWCClient
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: from swcpy import SWCClient
- en: from swcpy import SWCConfig
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: from swcpy import SWCConfig
- en: config = SWCConfig(swc_base_url="http://0.0.0.0:8000",backoff=False)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: config = SWCConfig(swc_base_url="http://0.0.0.0:8000",backoff=False)
- en: client = SWCClient(config)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: client = SWCClient(config)
- en: leagues_response = client.list_leagues()
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: leagues_response = client.list_leagues()
- en: print(leagues_response)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: print(leagues_response)
- en: '[PRE24]python'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE24]python'
- en: import csv
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: import csv
- en: import os
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: import os
- en: from io import StringIO
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: from io import StringIO
- en: config = SWCConfig()
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: config = SWCConfig()
- en: client = SWCClient(config)
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: client = SWCClient(config)
- en: '"""Tests bulk player download through SDK"""'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"""通过SDK测试批量玩家下载"""'
- en: player_file = client.get_bulk_player_file()
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: player_file = client.get_bulk_player_file()
- en: Write the file to disk to verify file download
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文件写入磁盘以验证文件下载
- en: output_file_path = data_dir + 'players_file.csv'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: output_file_path = data_dir + 'players_file.csv'
- en: 'with open(output_file_path, ''wb'') as f:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'with open(output_file_path, ''wb'') as f:'
- en: f.write(player_file)
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: f.write(player_file)
- en: '[PRE25]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'One key section to notice in this file is that it explains to users how they
    can install your SDK from your GitHub repository. Here is that section:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中需要注意的一个关键部分是它解释了用户如何从您的GitHub仓库安装您的SDK。以下是该部分内容：
- en: '[PRE26]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You have now created all the files you need and completed all of the coding
    for the first few endpoints. To see the new structure of your project, run the
    `tree` command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经创建了所有需要的文件，并完成了前几个端点的所有编码。要查看您项目的新的结构，运行`tree`命令：
- en: '[PRE27]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To update your local system with the new version of the SDK using `pip`, you
    will use the `--upgrade` option:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`pip`更新您的本地系统以使用SDK的新版本，您将使用`--upgrade`选项：
- en: '[PRE28]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Testing Your SDK
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试您的SDK
- en: 'Now you will test the SDK with pytest. Create a new directory and file with
    the following commands:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将使用 pytest 测试 SDK。使用以下命令创建一个新的目录和文件：
- en: '[PRE29]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-287
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are different pytest layouts you can use to include the tests in your
    package. In this case, you are using the pytest layout style named “tests outside
    application” that is described in [pytest’s Good Integration Practices](https://oreil.ly/GM3HU).
    This means that when you run your tests, you are testing against the installed
    module instead of code in your local path.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用不同的 pytest 布局来将测试包含在你的包中。在这种情况下，你正在使用名为“tests outside application”的 pytest
    布局样式，该样式在[pytest 的良好集成实践](https://oreil.ly/GM3HU)中有描述。这意味着当你运行测试时，你是在测试已安装的模块，而不是本地路径中的代码。
- en: 'Update *test_swcpy.py* with the following contents:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下内容更新 *test_swcpy.py* 文件：
- en: '[PRE30]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO11-1)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_batteries_included__creating_a_python_sdk_CO11-1]'
- en: The import statement is referencing the package that you installed locally in
    your environment.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 导入语句正在引用你在环境中本地安装的包。
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO11-2)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_batteries_included__creating_a_python_sdk_CO11-2]'
- en: This library is used for handling binary files like the Parquet file.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库用于处理像 Parquet 文件这样的二进制文件。
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO11-3)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_batteries_included__creating_a_python_sdk_CO11-3]'
- en: This library is specifically used to process Parquet files.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库专门用于处理 Parquet 文件。
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO11-4)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_batteries_included__creating_a_python_sdk_CO11-4]'
- en: You will use the pandas library to read the length of the Parquet files.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 pandas 库来读取 Parquet 文件的长度。
- en: '[![5](assets/5.png)](#co_batteries_included__creating_a_python_sdk_CO11-5)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)[#co_batteries_included__creating_a_python_sdk_CO11-5]'
- en: This test method tests health check endpoints.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试方法测试了健康检查端点。
- en: '[![6](assets/6.png)](#co_batteries_included__creating_a_python_sdk_CO11-6)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png)[#co_batteries_included__creating_a_python_sdk_CO11-6]'
- en: This test method tests the method calling your API.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试方法测试了调用你的 API 的方法。
- en: '[![7](assets/7.png)](#co_batteries_included__creating_a_python_sdk_CO11-7)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![7](assets/7.png)[#co_batteries_included__creating_a_python_sdk_CO11-7]'
- en: This test method tests the Parquet bulk file download.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试方法测试了 Parquet 批量文件下载。
- en: '[![8](assets/8.png)](#co_batteries_included__creating_a_python_sdk_CO11-8)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![8](assets/8.png)[#co_batteries_included__creating_a_python_sdk_CO11-8]'
- en: This sets the configuration option for Parquet files.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了 Parquet 文件的配置选项。
- en: '[![9](assets/9.png)](#co_batteries_included__creating_a_python_sdk_CO11-9)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![9](assets/9.png)[#co_batteries_included__creating_a_python_sdk_CO11-9]'
- en: These lines of code use PyArrow and pandas to read the Parquet file and count
    the records.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码行使用 PyArrow 和 pandas 读取 Parquet 文件并计数记录。
- en: Now you will run your API in another terminal session so that your SDK can call
    it. Open a second terminal session in Codespaces using the split terminal command,
    as shown in [Figure 7-4](#split_terminal_ch7).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将在另一个终端会话中运行你的 API，以便你的 SDK 可以调用它。在 Codespaces 中使用分割终端命令打开第二个终端会话，如图 [图
    7-4](#split_terminal_ch7) 所示。
- en: '![Opening second terminal session](assets/haad_0704.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![打开第二个终端会话](assets/haad_0704.png)'
- en: Figure 7-4\. Opening a second terminal session
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-4\. 打开第二个终端会话
- en: When you have added the second terminal, you should see it in the split screen,
    as shown in [Figure 7-5](#split_terminal_2_ch7).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加了第二个终端后，你应该能在分割屏幕中看到它，如图 [图 7-5](#split_terminal_2_ch7) 所示。
- en: '![Split terminal session](assets/haad_0705.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![分割终端会话](assets/haad_0705.png)'
- en: Figure 7-5\. The split terminal session
  id: totrans-314
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-5\. 分割终端会话
- en: Tip
  id: totrans-315
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you haven’t installed the API in your Codespace previously, you will need
    to run the command **`pip3 install -r`** **`require⁠ments​.txt`** in the *chapter6/complete*
    directory before running the API.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有在 Codespace 中安装 API，你需要在运行 API 之前，在 *chapter6/complete* 目录中运行命令 **`pip3
    install -r requirements.txt`**。
- en: 'In the second window, change directories to *chapter6/complete* to use the
    completed API from the repository. Launch the API as shown:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个窗口中，切换到 *chapter6/complete* 目录以使用存储库中的完整 API。按照以下方式启动 API：
- en: '[PRE31]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO12-1)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_batteries_included__creating_a_python_sdk_CO12-1]'
- en: The *test_swcpy.py* file should use this address in the `swc_base_url=` parameter.
    If it doesn’t have that address, update *test_swcpy.py* to match the address here.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '*test_swcpy.py* 文件应该在 `swc_base_url=` 参数中使用此地址。如果没有这个地址，更新 *test_swcpy.py*
    以匹配这里的地址。'
- en: You don’t need to click “Open in Browser” as in previous chapters, because you
    will be testing the API from the terminal using your SDK.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要像前几章那样点击“在浏览器中打开”，因为你将使用你的SDK在终端测试API。
- en: 'In the left terminal window, enter the **`pytest tests/test_swcpy.py`** command
    and you should see an output that looks similar to this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧终端窗口中，输入**`pytest tests/test_swcpy.py`**命令，你应该会看到类似以下输出的内容：
- en: '[PRE32]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You have added a lot of great functionality to your SDK. Way to go! Take a
    moment to consider expert tips and features that you have implemented for your
    SDK:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经为你的SDK添加了许多出色的功能。做得好！花点时间考虑一下你已经为你的SDK实现的专家提示和功能：
- en: Make your SDK easy to install.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的SDK易于安装。
- en: You configured your project so that it can be installed using `pip3` directly
    from GitHub. You could also publish it to PyPI if you choose.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你配置了你的项目，使其可以直接使用`pip3`从GitHub安装。如果你选择，你也可以将其发布到PyPI。
- en: Be consistent and idiomatic.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 保持一致性和地道性。
- en: You used PEP 8 style and consistent function naming. You used Pythonic techniques
    like list comprehensions, dictionary comprehensions, and context managers. And
    you used the Python standard logging function.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用了PEP 8样式和一致的函数命名。你使用了Pythonic技术，如列表推导、字典推导和上下文管理器。并且你使用了Python标准日志函数。
- en: Use sane defaults.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用合理的默认值。
- en: You implemented the `SWCConfig` that will work out of the box with default values
    but can be customized with URL and other settings.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你实现了`SWCConfig`，它将使用默认值直接工作，但可以通过URL和其他设置进行自定义。
- en: Provide extra functionality.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 提供额外的功能。
- en: You provided data validation, exponential backoff with jitter, and bulk downloads.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你提供了数据验证、带抖动的指数退避和批量下载。
- en: Perform logging.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 执行日志记录。
- en: You implemented logging with multiple levels using Python’s built-in logging
    library.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用Python内置的日志库实现了多级日志记录。
- en: Hide your API’s complicated details.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏你API的复杂细节。
- en: You implemented methods that allow users to call the API endpoints without reading
    the API documentation.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你实现了允许用户调用API端点而不必阅读API文档的方法。
- en: Provide bulk downloads.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 提供批量下载。
- en: You made bulk files available for all your database tables in both *.csv* and
    *.parquet* formats.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你为所有数据库表提供了*.csv*和*.parquet*格式的批量文件。
- en: Document your SDK.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 记录你的SDK。
- en: You provided a *README.md* file that explains how to install and use the SDK.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你提供了一个*README.md*文件，解释了如何安装和使用SDK。
- en: Only one expert tip remains for your SDK, but it’s a big one. You will tackle
    it next.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的SDK，只剩下一个专家提示，但它很重要。你将在下一个任务中解决它。
- en: 'Expert Tip: Supporting Every Task the API Supports'
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专家提示：支持API支持的每个任务
- en: Ideally, users should be able to accomplish any task with the SDK that they
    could accomplish by directly using the API. This means every API endpoint and
    parameter should be supported by the SDK. You’ve probably noticed at this point
    that you’ve only implemented SDK functions for a couple of the API endpoints and
    one bulk file download. Unfortunately, there’s no room in this chapter to walk
    you through the remaining code. However, you are prepared to code the rest of
    the endpoints using the helper functions and naming standards I have demonstrated
    so far.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，用户应该能够使用SDK完成他们通过直接使用API所能完成的任何任务。这意味着每个API端点和参数都应该由SDK支持。你可能已经注意到，到目前为止，你只为几个API端点和一次批量文件下载实现了SDK函数。不幸的是，本章没有足够的空间带你了解剩余的代码。然而，你已经准备好使用我迄今为止展示的辅助函数和命名标准来编写其余端点的代码。
- en: 'I don’t want to leave you hanging completely, so here is some additional information
    you can use to continue building your SDK. To start with, here are the functions
    you need to create to cover all the API endpoints:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想让你完全处于困境中，所以这里有一些你可以用来继续构建你的SDK的附加信息。首先，以下是你需要创建以涵盖所有API端点的函数：
- en: '`get_health_check` (completed)'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_health_check`（已完成）'
- en: '`list_leagues` (completed)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list_leagues`（已完成）'
- en: '`get_league_by_id`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_league_by_id`'
- en: '`get_counts`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_counts`'
- en: '`list_teams`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list_teams`'
- en: '`list_players`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list_players`'
- en: '`get_player_by_id`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_player_by_id`'
- en: '`list_performances`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list_performances`'
- en: 'Here are the bulk download functions you need to create:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你需要创建的批量下载函数：
- en: '`get_bulk_player_file` (completed)'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_bulk_player_file`（已完成）'
- en: '`get_bulk_league_file`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_bulk_league_file`'
- en: '`get_bulk_performance_file`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_bulk_performance_file`'
- en: '`get_bulk_team_file`'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_bulk_team_file`'
- en: '`get_bulk_team_player_file`'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_bulk_team_player_file`'
- en: I encourage you to take a shot at creating these endpoints following the examples
    I have given you. Be consistent and idiomatic. As with earlier chapters, the full
    completed code is available in the *chapter7/complete* directory if you would
    like to check your work.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您尝试根据我给出的示例创建这些端点。保持一致性和地道性。与前面的章节一样，如果您想检查您的代码，完整的完成代码可在 *chapter7/complete*
    目录中找到。
- en: Completing Your Part I Portfolio Project
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成 Part I 的项目组合
- en: With the creation of your SDK, you have finished all the coding you need for
    your portfolio project. Congratulations! Hopefully, you have been committing your
    code with frequent small commits, but be sure to commit any remaining changes
    you have.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建 SDK，您已经完成了您的项目组合所需的全部编码。恭喜！希望您已经通过频繁的小提交提交了您的代码，但请确保提交任何剩余的更改。
- en: To get your project repository ready to share, you are going to be moving the
    Chapters [6](ch06.html#chapter_6) and [7](#chapter_7) content to the root folder
    of your repository, and then removing all the previous chapters.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的项目仓库准备好分享，您需要将第 [6](ch06.html#chapter_6) 章和第 [7](ch06.html#chapter_7) 章的内容移动到您仓库的根文件夹，然后删除所有之前的章节。
- en: 'Before you make these changes, you’ll save a copy of your files to a separate
    GitHub *branch*, which is an isolated area in your repository. This will keep
    the original directory structure you used while working through your code. (You
    have been doing all your coding in the *main* branch so far.) Create the new branch
    from the command line as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改之前，您需要将文件的一个副本保存到 GitHub 的一个单独的 *branch* 中，这是一个在您的仓库中的隔离区域。这将保持您在编写代码时使用的原始目录结构。（您到目前为止一直在
    *main* 分支上编写所有代码。）以下是从命令行创建新分支的步骤：
- en: '[PRE33]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO13-1)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO13-1)'
- en: Change to the root directory.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到根目录。
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO13-2)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO13-2)'
- en: Create a new branch named *learning-branch* locally based on the *main* branch.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地基于 *main* 分支创建一个名为 *learning-branch* 的新分支。
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO13-3)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO13-3)'
- en: Push this new branch to your remote repository on GitHub.com.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个新分支推送到您在 GitHub.com 上的远程仓库。
- en: To verify that the branch was created on GitHub, go to your GitHub repository
    and click main. You should see a new branch, as shown in [Figure 7-6](#new_branch_ch7).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证分支已在 GitHub 上创建，请转到您的 GitHub 仓库并点击 main。您应该会看到一个新分支，如图 7-6 所示 [新分支 ch7](#new_branch_ch7)。
- en: '![New branch created.](assets/haad_0706.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![新分支创建。](assets/haad_0706.png)'
- en: Figure 7-6\. Newly created branch
  id: totrans-373
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-6\. 新创建的分支
- en: 'Back in Codespaces, you will move the Chapters [6](ch06.html#chapter_6) and
    [7](#chapter_7) files to the root of your repository. [Chapter 6](ch06.html#chapter_6)
    contains the final API files and [Chapter 7](#chapter_7) has the SDK files. Enter
    the following commands:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Codespaces 中，您将把第 [6](ch06.html#chapter_6) 章和第 [7](#chapter_7) 章的文件移动到您仓库的根目录。第
    [6](ch06.html#chapter_6) 章包含最终的 API 文件，而第 [7](#chapter_7) 章包含 SDK 文件。输入以下命令：
- en: '[PRE34]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO14-1)'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_batteries_included__creating_a_python_sdk_CO14-1)'
- en: Switch your Codespace back to the *main* branch of your repository.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的 Codespace 切换回仓库的 *main* 分支。
- en: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO14-2)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_batteries_included__creating_a_python_sdk_CO14-2)'
- en: Move the API files into your root directory.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 将 API 文件移动到您的根目录。
- en: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO14-3)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_batteries_included__creating_a_python_sdk_CO14-3)'
- en: Move the SDK files into your *sdk* directory.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 将 SDK 文件移动到您的 *sdk* 目录中。
- en: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO14-4)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_batteries_included__creating_a_python_sdk_CO14-4)'
- en: Remove all the subdirectories and their files.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 删除所有子目录及其文件。
- en: 'To see the directory structure of the completed project, run the following
    command:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完成项目的目录结构，请运行以下命令：
- en: '[PRE35]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To update your API documentation to mention your SDK, replace the bottom “Software
    Development Kit (SDK)” section of *README.md* with the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新您的 API 文档以提及您的 SDK，请将 *README.md* 中的底部“软件开发工具包 (SDK)”部分替换为以下内容：
- en: '[PRE36]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You’ve performed some serious surgery to your *main* branch. Make one last commit
    to GitHub, and you’re all done. Congratulations on completing your Part I capstone!
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经对 *main* 分支进行了重大修改。最后提交一次到 GitHub，您就完成了。恭喜您完成 Part I 的综合项目！
- en: Additional Resources
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: For advice on creating an SDK, see the [SDKs.io website](https://sdks.io) by
    APIMatic.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建 SDK 的建议，请参阅 APIMatic 的 [SDKs.io 网站](https://sdks.io)。
- en: For more advice from Speakeasy on creating a Python SDK, read [“How to Build
    a Best in Class Python SDK” by Tristan Cartledge](https://oreil.ly/B-vKL).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 想从 Speakeasy 获取更多关于创建 Python SDK 的建议，请阅读 [Tristan Cartledge 的“如何构建一流的 Python
    SDK”](https://oreil.ly/B-vKL)。
- en: For more advice on writing Pythonic code, check out [*The Hitchhiker’s Guide
    to Python*](https://oreil.ly/ddReB).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于编写 Pythonic 代码的建议，请查看 [*《Python 漫游指南》*](https://oreil.ly/ddReB)。
- en: To review the benefits of Parquet files for bulk data, read [“Why parquet files
    are my preferred API for bulk open data” by Robin Linacre](https://oreil.ly/OmtmF).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Parquet 文件在批量数据中的优势，请阅读 [Robin Linacre 的“为什么 parquet 文件是我首选的批量开放数据 API”](https://oreil.ly/OmtmF)。
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned from experts in SDK development to identify the
    features that make a great Python SDK. Then, you went out and coded it! SDKs like
    the one you developed make life much easier for data scientists and other Python-centric
    users of your API. While coding the SDK, you applied PEP 8 code style and used
    a variety of Pythonic techniques such as list comprehensions and context managers.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您从 SDK 开发专家那里学习，以识别使 Python SDK 伟大的特性。然后，您走出去了，并编写了代码！您开发的 SDK 等产品使数据科学家和您的
    API 的其他以 Python 为中心的用户的生活变得更加容易。在编写 SDK 的过程中，您应用了 PEP 8 代码风格，并使用了各种 Pythonic 技术，如列表推导式和上下文管理器。
- en: In [Chapter 8](ch08.html#chapter_8), you will start looking at APIs from the
    perspective of the consumer instead of the producer. You will start by learning
    the skills that data scientists should know about APIs.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](ch08.html#chapter_8) 中，您将从消费者的角度而不是生产者的角度开始研究 API。您将首先学习数据科学家应该了解的关于
    API 的技能。
