["```py\n<!DOCTYPE html><html><head><script src=\"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.7.0/dist/tf.min.js\"></script><script src=\"https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@1.0.0\"></script>![1](assets/1.png)<script>mobilenet.load().then(model=>{constimg=document.getElementById('myImage');![2](assets/2.png)// Classify the image\nmodel.classify(img).then(predictions=>{console.log('Predictions: ',predictions);// Was there a truck?\nletfoundATruckpredictions.forEach(p=>{foundATruck=foundATruck||p.className.includes(\"truck\")![3](assets/3.png)})// TRUCK ALERT!\nif(foundATruck)alert(\"TRUCK DETECTED!\")![4](assets/4.png)});});</script></head><body><h1>Is this a truck?</h1><imgid=\"myImage\"src=\"truck.jpg\"width=\"100%\"></img></body></html>\n```", "```py\nconst callMeMaybe = tf.tensor([8367677, 4209111, 4209111, 8675309, 8367677])\nconst uniqueTensor = tf.unique(callMeMaybe).values\nconst result = uniqueTensor.arraySync()\nconsole.log(`There are ${result.length} unique values`, result)\n```", "```py\nconstrando=tf.randomUniform([400,400])![1](assets/1.png)constsorted=tf.topk(rando,400).values![2](assets/2.png)constanswer=sorted.reshape([400,400,1])![3](assets/3.png)\n```", "```py\ntf.topk(tf.randomUniform([400, 400]), 400).values\n```", "```py\n// Same bounding calculations but for the tensor consttHeight=myTensor.shape[0]![1](assets/1.png)consttWidth=myTensor.shape[1]consttStartX=box[0]*tWidthconsttStartY=box[1]*tHeightconstcropLength=parseInt((box[2]-box[0])*tWidth,0)![2](assets/2.png)constcropHeight=parseInt((box[3]-box[1])*tHeight,0)conststartPos=[tStartY,tStartX,0]constcropSize=[cropHeight,cropLength,3]constcropped=tf.slice(myTensor,startPos,cropSize)// Prepare for next model input constreadyFace=tf.image.resizeBilinear(cropped,[96,96],true).reshape([1,96,96,3]);![3](assets/3.png)\n```", "```py\nconst { indices, values } = tf.topk(t)\nconst topvals = values.squeeze()\nconst sorted = tf.topk(topvals, 3)\n// prints [3, 4, 2]\nsorted.indices.print()\n```", "```py\nconst model = tf.sequential();\n\nmodel.add(\n  tf.layers.dense({\n    inputShape: 5,\n    units: 10,\n    activation: \"sigmoid\"\n  })\n);\n\nmodel.add(\n  tf.layers.dense({\n    units: 7,\n    activation: \"relu\"\n  })\n);\n\nmodel.add(\n  tf.layers.dense({\n    units: 4,\n    activation: \"softmax\"\n  })\n);\n\nmodel.compile({\n  optimizer: \"adam\",\n  loss: \"categoricalCrossentropy\"\n});\n```", "```py\n_________________________________________________________________\nLayer (type)                 Output shape              Param #\n=================================================================\ndense_Dense33 (Dense)        [null,10]                 60\n_________________________________________________________________\ndense_Dense34 (Dense)        [null,7]                  77\n_________________________________________________________________\ndense_Dense35 (Dense)        [null,4]                  32\n=================================================================\nTotal params: 169\nTrainable params: 169\nNon-trainable params: 0\n_________________________________________________________________\n```", "```py\nmega_df['Name'] = mega_df['Name'].apply((x) => x.split(/,\\s(.*?)\\./)[1])\ngrp = mega_df.groupby(['Name'])\ntable(grp.col(['Survived']).mean())\n```", "```py\n// initialize best at zero\nlet best = 0\n\n//...\n\n// In the callback object add the onEpochEnd save condition\nonEpochEnd: async (_epoch, logs) => {\n  if (logs.val_acc > best) {\n    console.log(\"SAVING\")\n    model.save(savePath)\n    best = logs.val_acc\n  }\n}\n```", "```py\nconst dfy = await dfd.read_csv('labels.csv')\nconst dfx = await dfd.read_csv('images.csv')\n\nconst Y = dfy.tensor\nconst X = dfx.tensor.reshape([dfx.shape[0], 28, 28, 1])\n```", "```py\nconst model = await tf.loadLayersModel('sorting_hat/model.json')\nconst layer = model.getLayer('max_pooling2d_MaxPooling2D3')\nconst shaved = tf.model({\n  inputs: model.inputs,\n  outputs: layer.output\n})\n// Run data through shaved model to get features\nconst XFEATURES = shaved.predict(X)\n```", "```py\ntransferModel = tf.sequential({\n  layers: [\n    tf.layers.flatten({ inputShape: shaved.outputs[0].shape.slice(1) }),\n    tf.layers.dense({ units: 128, activation: 'relu' }),\n    tf.layers.dense({ units: 3, activation: 'softmax' }),\n  ],\n})\ntransferModel.compile({\n  optimizer: 'adam',\n  loss: 'categoricalCrossentropy',\n  metrics: ['accuracy'],\n})\n```", "```py\nawait transferModel.fit(XFEATURES, Y, {\n  epochs: 10,\n  validationSplit: 0.1,\n  callbacks: {\n    onEpochEnd: console.log,\n  },\n})\n```", "```py\n// Simply read from the DOM\nconst inputImage = document.getElementById('input')\nconst inTensor = tf.browser.fromPixels(inputImage, 1)\n\n// Binarize\nconst threshold = 50\nconst light = tf.onesLike(inTensor).asType('float32')\nconst dark = tf.zerosLike(inTensor)\nconst simpleBinarized = tf.where(\n  tf.less(inTensor, threshold),\n  dark, // False Case: place zero\n  light, // True Case: place one\n)\n\n// Show results\nconst myCanvas = document.getElementById('output')\ntf.browser.toPixels(simpleBinarized, myCanvas)\n```"]