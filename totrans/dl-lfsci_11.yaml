- en: Chapter 11\. A Virtual Screening Workflow Example
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。虚拟筛选工作流程示例
- en: Virtual screening can provide an efficient and cost-effective means of identifying
    starting points for drug discovery programs. Rather than carrying out an expensive,
    experimental high-throughput screen (HTS), we can use computational methods to
    virtually evaluate millions, or even tens of millions, of molecules. Virtual screening
    methods are often grouped into two categories, structure-based virtual screening
    and ligand-based virtual screening.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟筛选可以提供一种高效且具有成本效益的方法，用于确定药物发现项目的起始点。我们可以使用计算方法来虚拟评估数百万甚至数千万分子，而不是进行昂贵的实验高通量筛选（HTS）。虚拟筛选方法通常分为两类，即基于结构的虚拟筛选和基于配体的虚拟筛选。
- en: In a structure-based virtual screen, computational methods are used to identify
    molecules that will optimally fit into a cavity, known as a binding site, in a
    protein. The binding of a molecule into the protein binding site can often inhibit
    the function of the protein. For instance, proteins known as enzymes catalyze
    a variety of physiological chemical reactions. By identifying and optimizing inhibitors
    of these enzymatic processes, scientists have been able to develop treatments
    for a wide range of diseases in oncology, inflammation, infection, and other therapeutic
    areas.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于结构的虚拟筛选中，使用计算方法来识别最佳适合蛋白质中的一个被称为结合位点的空腔的分子。分子结合到蛋白质结合位点中通常会抑制蛋白质的功能。例如，酶类蛋白质催化各种生理化学反应。通过识别和优化这些酶过程的抑制剂，科学家已经能够开发用于肿瘤学、炎症、感染和其他治疗领域的广泛疾病的治疗方法。
- en: In a ligand-based virtual screen, we search for molecules that function similarly
    to one or more known molecules. We may be looking to improve the function of an
    existing molecule, to avoid pharmacological liabilities associated with a known
    molecule, or to develop novel intellectual property. A ligand-based virtual screen
    typically starts with a set of known molecules identified through any of a variety
    of experimental methods. Computational methods are then used to develop a model
    based on experimental data, and this model is used to virtually screen a large
    set of molecules to find new chemical starting points.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于配体的虚拟筛选中，我们搜索与一个或多个已知分子功能类似的分子。我们可能正在寻找改进现有分子的功能，避免与已知分子相关的药理学风险，或开发新的知识产权。基于配体的虚拟筛选通常从通过各种实验方法确定的一组已知分子开始。然后使用计算方法基于实验数据开发模型，并使用该模型虚拟筛选大量分子以找到新的化学起始点。
- en: In this chapter, we will walk through a practical example of a virtual screening
    workflow. We will examine the code used to carry out components of the virtual
    screen as well as the thought process behind decisions made throughout the analysis.
    In this particular case, we will carry out a ligand-based virtual screen. We will
    use a set of molecules known to bind to a particular protein, as well as a set
    of molecules assumed to not bind, to train a convolutional neural network to identify
    new molecules with the potential to bind to the target.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过一个虚拟筛选工作流程的实际示例。我们将检查用于执行虚拟筛选各个组件的代码，以及整个分析过程中所做决策背后的思考过程。在这种特定情况下，我们将进行基于配体的虚拟筛选。我们将使用已知结合到特定蛋白质的一组分子，以及一组假定不结合的分子，来训练一个卷积神经网络，以识别具有结合到目标的潜力的新分子。
- en: Preparing a Dataset for Predictive Modeling
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为预测建模准备数据集
- en: As a first step, we will build a graph convolution model to predict the ability
    of molecules to inhibit a protein known as ERK2\. This protein, also known as
    mitogen-activated protein kinase 1, or MAPK1, plays an important role in the signaling
    pathways that regulate how cells multiply. ERK2 has been implicated in a number
    of cancers, and ERK2 inhibitors are currently being tested in clinical trials
    for non-small-cell lung cancer and melanoma (skin cancer).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们将构建一个图卷积模型，以预测分子抑制一种名为ERK2的蛋白质的能力。这种蛋白质，也称为有丝分裂原活化蛋白激酶1或MAPK1，在调节细胞增殖的信号通路中发挥重要作用。ERK2已被牵涉到多种癌症，并且ERK2抑制剂目前正在临床试验中用于非小细胞肺癌和黑色素瘤（皮肤癌）。
- en: We will train the model to distinguish a set of ERK2 active compounds from a
    set of decoy compounds. The active and decoy compounds are derived from the [DUD-E
    database](http://dud.docking.org/), which is designed for testing predictive models.
    In practice, we would typically obtain active and inactive molecules from the
    scientific literature, or from a database of biologically active molecules such
    as the [ChEMBL database](https://www.ebi.ac.uk/chembl/) from the European Bioinformatics
    Institute (EBI). In order to generate the best model, we would like to have decoys
    with property distributions similar to those of our active compounds. Let’s say
    this was not the case and the inactive compounds had lower molecular weight than
    the active compounds. In this case, our classifier might be trained simply to
    separate low molecular weight compounds from high molecular weight compounds.
    Such a classifier would have very limited utility in practice.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将训练模型区分一组ERK2活性化合物和一组假化合物。活性和假化合物来源于[DUD-E数据库](http://dud.docking.org/)，该数据库旨在测试预测模型。在实践中，我们通常会从科学文献或来自欧洲生物信息学研究所（EBI）的[ChEMBL数据库](https://www.ebi.ac.uk/chembl/)等生物活性分子数据库中获取活性和非活性分子。为了生成最佳模型，我们希望假分子的属性分布与我们的活性化合物相似。假设这不是这种情况，非活性化合物的分子量低于活性化合物。在这种情况下，我们的分类器可能只是简单地训练以区分低分子量化合物和高分子量化合物。这样的分类器在实践中的效用非常有限。
- en: In order to better understand the dataset, let’s examine a few calculated properties
    of our active and decoy molecules. To build a reliable model, we need to ensure
    that the properties of the active molecules are similar to those of the decoy
    molecules.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解数据集，让我们检查一下我们的活性和假分子的一些计算属性。为了构建可靠的模型，我们需要确保活性分子的属性与假分子的属性相似。
- en: 'First, let’s import the necessary libraries:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入必要的库：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this exercise, molecules are represented using SMILES strings. For more
    information on SMILES, please see [Chapter 4](ch04.xhtml#machine_learning_for_molecules).
    We can now read a SMILES file into a Pandas dataframe and add an RDKit molecule
    to the dataframe. While the input SMILES file is not technically a CSV file, the
    Pandas `read_CSV()` function can read it as long as we specify the delimiter,
    which in this case is a space:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，分子使用SMILES字符串表示。有关SMILES的更多信息，请参阅[第4章](ch04.xhtml#machine_learning_for_molecules)。现在我们可以将一个SMILES文件读入Pandas数据框，并将一个RDKit分子添加到数据框中。虽然输入的SMILES文件在技术上不是CSV文件，但只要我们指定分隔符，Pandas的`read_CSV()`函数就可以读取它，这种情况下分隔符是空格：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s define a function to add the calculated properties to a dataframe:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个函数，将计算的属性添加到数据框中：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With this function in hand, we can calculate the molecular weight, LogP, and
    formal charge of the molecules. These properties encode the size of a molecule,
    its ability to partition from an oily substance (octanol) to water, and whether
    the molecule has a positive or negative charge. Once we have these properties
    we can compare the distributions for the active and decoy sets:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个函数，我们可以计算分子的分子量、LogP和形式电荷。这些属性编码了分子的大小、从油性物质（辛醇）到水的分配能力，以及分子是否带有正电荷或负电荷。一旦我们有了这些属性，我们就可以比较活性和诱饵集的分布：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s look at the first few rows of our dataframe to ensure that the contents
    of the dataframe match the input file (see [Table 11-1](#active_d_img)):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看数据框的前几行，以确保数据框的内容与输入文件匹配（见[表11-1](#active_d_img)）：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Table 11-1\. The first few lines of the active_df dataframe.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-1。active_df数据框的前几行。
- en: '|   | SMILES | ID | ChEMBL_ID | label |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|   | SMILES | ID | ChEMBL_ID | label |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | Cn1ccnc1Sc2ccc(cc2Cl)Nc3c4cc(c(cc4ncc3C#N)OCCCN5CCOCC5)OC | 168691 |
    CHEMBL318804 | Active |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 0 | Cn1ccnc1Sc2ccc(cc2Cl)Nc3c4cc(c(cc4ncc3C#N)OCCCN5CCOCC5)OC | 168691 |
    CHEMBL318804 | Active |'
- en: '| 1 | C[C@@]12[C@@H]([C@@H](CC(O1)n3c4ccccc4c5c3c6n2c7ccccc7c6c8c5C(=O)NC8)NC)OC
    | 86358 | CHEMBL162 | Active |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 1 | C[C@@]12[C@@H]([C@@H](CC(O1)n3c4ccccc4c5c3c6n2c7ccccc7c6c8c5C(=O)NC8)NC)OC
    | 86358 | CHEMBL162 | Active |'
- en: '| 2 | Cc1cnc(nc1c2cc([nH]c2)C(=O)N[C@H](CO)c3cccc(c3)Cl)Nc4cccc5c4OC(O5)(F)F
    | 575087 | CHEMBL576683 | Active |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Cc1cnc(nc1c2cc([nH]c2)C(=O)N[C@H](CO)c3cccc(c3)Cl)Nc4cccc5c4OC(O5)(F)F
    | 575087 | CHEMBL576683 | Active |'
- en: '| 3 | Cc1cnc(nc1c2cc([nH]c2)C(=O)N[C@H](CO)c3cccc(c3)Cl)Nc4cccc5c4OCO5 | 575065
    | CHEMBL571484 | Active |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Cc1cnc(nc1c2cc([nH]c2)C(=O)N[C@H](CO)c3cccc(c3)Cl)Nc4cccc5c4OCO5 | 575065
    | CHEMBL571484 | Active |'
- en: '| 4 | Cc1cnc(nc1c2cc([nH]c2)C(=O)N[C@H](CO)c3cccc(c3)Cl)Nc4cccc5c4CCC5 | 575047
    | CHEMBL568937 | Active |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Cc1cnc(nc1c2cc([nH]c2)C(=O)N[C@H](CO)c3cccc(c3)Cl)Nc4cccc5c4CCC5 | 575047
    | CHEMBL568937 | Active |'
- en: 'Now let’s do the same thing with the decoy molecules:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们对诱饵分子做同样的事情：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In order to build a model, we need a single dataframe with the active and decoy
    molecules. We can use the Pandas `append` function to add the two dataframes and
    create a new dataframe called `tmp_df`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建模型，我们需要一个包含活性和诱饵分子的单个数据框。我们可以使用Pandas的`append`函数将两个数据框添加到一起，创建一个名为`tmp_df`的新数据框：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With properties calculated for both the active and decoy sets, we can compare
    the properties of the two sets of molecules. To do the comparison, we will use
    violin plots. A violin plot is analogous to a boxplot. The violin plot provides
    a mirrored, horizontal view of a frequency distribution. Ideally, we would like
    to see similar distributions for the active and decoy sets. The results are shown
    in [Figure 11-1](#mw-violin-plot):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 计算了活性和诱饵集的属性后，我们可以比较两组分子的属性。为了进行比较，我们将使用小提琴图。小提琴图类似于箱线图。小提琴图提供了频率分布的镜像、水平视图。理想情况下，我们希望看到活性和诱饵集的分布相似。结果显示在[图11-1](#mw-violin-plot)中：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](Images/dlls_1101.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dlls_1101.png)'
- en: Figure 11-1\. Violin plots of molecular weight for the active and decoy sets.
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-1。活性和诱饵集的分子量小提琴图。
- en: An examination of these plots shows that the molecular weight distributions
    for the two sets are roughly equivalent. The decoy set has more low molecular
    weight molecules, but the center of the distribution, shown as a box in the middle
    of each violin plot, is in a similar location in both plots.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些图的检查显示，两组分子的分子量分布大致相等。诱饵集中有更多低分子量的分子，但在每个小提琴图中间显示的箱子的中心位置是相似的。
- en: 'We can use violin plots to perform a similar comparison of the LogP distributions
    ([Figure 11-2](#logp-violin-plot)). Again, we can see that the distributions are
    similar, with a few more of the decoy molecules at the lower end of the distribution:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用小提琴图对LogP分布进行类似的比较（[图11-2](#logp-violin-plot)）。同样，我们可以看到分布是相似的，诱饵分子中有更多分布在分布的低端：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Violin plots of LogP for the active and decoy sets.](Images/dlls_1102.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![活性和诱饵集的LogP小提琴图。](Images/dlls_1102.png)'
- en: Figure 11-2\. Violin plots of LogP for the active and decoy sets.
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-2。活性和诱饵集的LogP小提琴图。
- en: 'Finally, we perform the same comparison with the formal charges of the molecules
    ([Figure 11-3](#charge-violin-plot)):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对分子的形式电荷进行相同的比较（[图11-3](#charge-violin-plot)）：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Violin plots of formal charge for the active and decoy sets.](Images/dlls_1103.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![活性和诱饵集的形式电荷小提琴图。](Images/dlls_1103.png)'
- en: Figure 11-3\. Violin plots of formal charge for the active and decoy sets.
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-3。活性和诱饵集的形式电荷小提琴图。
- en: 'In this case, we see a significant difference. All of the active molecules
    are neutral, having charges of 0, while some of the decoys are charged, with charges
    of +1 or –1\. Let see what fraction of the decoy molecules are charged. We can
    do this by creating a new dataframe with just the charged molecules:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们看到了显著的差异。所有活性分子都是中性的，电荷为0，而一些诱饵是带电的，电荷为+1或-1。让我们看看多少比例的诱饵分子是带电的。我们可以通过创建一个只包含带电分子的新数据框来做到这一点：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A Pandas dataframe has a property, `shape`, that returns the number of rows
    and columns in the dataframe. As such, element `[0]` in the `shape` property will
    be the number of rows. Let’s divide the number of rows in our dataframe of charged
    molecules by the total number of rows in the decoy dataframe:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This returns 0.162\. As we saw in the violin plot, approximately 16% of the
    decoy molecules are charged. This appears to be because the active and decoy sets
    were not prepared in a consistent fashion. We can address this problem by modifying
    the chemical structures of the decoy molecules to neutralize their charges. Fortunately
    we can do this easily with the `NeutraliseCharges()` function from the [RDKit
    Cookbook](https://www.rdkit.org/docs/Cookbook.html):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In order to avoid confusion, we create a new dataframe with the SMILES stings,
    IDs, and labels for the decoys:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this new dataframe in hand, we can replace the original SMILES strings
    with the strings for the neutral forms of the molecules. The `NeutraliseCharges`
    function returns two values. The first is the SMILES string for the neutral form
    of the molecule and the second is a Boolean variable indicating whether the molecule
    was changed. In the following code, we only need the SMILES string, so we use
    the first element of the tuple returned by `NeutraliseCharges`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once we’ve replaced the SMILES strings, we can add a molecule column to our
    new dataframe and calculate the properties again:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can then append the dataframe with the active molecules to the one with
    the revised, neutral decoys:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we can generate a new boxplot to compare the charge distributions of
    the active molecules with those of our neutralized decoys ([Figure 11-4](#revised-charge-violin)):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Violin plots of the charge distribution for our revised decoy set.](Images/dlls_1104.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: Figure 11-4\. Violin plots of the charge distribution for our revised decoy
    set.
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'An examination of the plots shows that there are now very few charged molecules
    in the decoy set. We can use the same technique we used earlier to create a dataframe
    with only the charged molecules. We then use this dataframe to determine the number
    of charged molecules remaining in the set:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The result now is 0.003\. We have reduced the fraction of charged molecules
    from 16% to 0.3%. We can now be confident that our active and decoy sets are reasonably
    well balanced.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use these datasets with DeepChem, we need to write the molecules
    out as a CSV file containing for each molecule the SMILES string, ID, Name, and
    an integer value indicating whether the compounds are active (labeled as 1) or
    inactive (labeled as 0):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first five lines are shown in [Table 11-2](#first-lines-of-dataframe).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Table 11-2\. The first few lines of our new combined dataframe
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '|   | SMILES | ID | is_active |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| 0 | Cn1 ccnc1Sc2ccc(cc2Cl}Nc3c4cc(c(cc4ncc3C#N}OCCCN5CCOCC5)OC | 168691 |
    1 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| 1 | C[C@@]12[C@@H]([C@@H](CC(O1)n3c4ccccc4c5c3c6n2c7ccccc7c6c8c5C(=O)NC8)NC)OC
    | 86358 | 1 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| 2 | Cc1cnc(nc1c2cc([nH]c2)C(=0) N[C@H](CO)c3cccc(c3}Cl}Nc4cccc5c4OC(O5)(F)F
    | 575087 | 1 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| 3 | CCc1cnc(nc1c2cc([nH]c2)C(=O)N[C@H](CO)c3cccc(c3}Cl}Nc4cccc5c4OCO5 | 575065
    | 1 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| 4 | Cc1cnc(nc1c2cc([nH]c2)C(=0) N[C@H](CO)c3cccc(c3}Cl}Nc4cccc5c4CCC5 | 575047
    | 1 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: 'Our final step in this section is to save our new `combined_df` as a CSV file.
    The `index=False` option causes Pandas to not include the row number in the first
    column:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Training a Predictive Model
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have taken care of formatting, we can use this data to train a
    graph convolution model. First, we need to import the necessary libraries. Some
    of these libraries were imported in the first section, but let’s assume we are
    starting with the CSV file we created in the previous section:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now let’s define a function to create a `GraphConvModel`. In this case, we
    will be creating a classification model. Since we will apply the model later on
    a different dataset, it’s a good idea to create a directory in which to store
    the model. You will need to change the directory to something accessible on your
    filesystem:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一个函数来创建一个`GraphConvModel`。在这种情况下，我们将创建一个分类模型。由于我们将在以后的不同数据集上应用该模型，因此最好创建一个目录来存储模型。您需要将目录更改为您的文件系统上可访问的内容：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to train the model, we first read in the CSV file we created in the
    previous section:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了训练模型，我们首先读取在上一节中创建的CSV文件：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now that we have the dataset loaded, let’s build a model. We will create training
    and test sets to evaluate the model’s performance. In this case, we will use the
    `RandomSplitter` (DeepChem offers a number of other splitters too, such as the
    `ScaffoldSplitter`, which divides the dataset by chemical scaffold, and the `ButinaSplitter`,
    which first clusters the data then splits the dataset so that different clusters
    end up in the training and test sets):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了数据集，让我们构建一个模型。我们将创建训练集和测试集来评估模型的性能。在这种情况下，我们将使用`RandomSplitter`（DeepChem还提供许多其他分割器，如`ScaffoldSplitter`，它通过化学支架划分数据集，以及`ButinaSplitter`，它首先对数据进行聚类，然后将数据集分割，使不同的聚类最终出现在训练集和测试集中）：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the dataset split, we can train a model on the training set and test that
    model on the validation set. At this point, we need to define some metrics and
    evaluate the performance of our model. In this case, our dataset is unbalanced:
    we have a small number of active compounds and a large number of inactive compounds.
    Given this difference, we need to use a metric that reflects the performance on
    unbalanced datasets. One metric that is appropriate for datasets like this is
    the Matthews correlation coefficient (MCC):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据集的拆分，我们可以在训练集上训练模型，然后在验证集上测试该模型。在这一点上，我们需要定义一些指标并评估我们模型的性能。在这种情况下，我们的数据集是不平衡的：我们有少量活性化合物和大量非活性化合物。鉴于这种差异，我们需要使用一个反映不平衡数据集性能的指标。适合这种数据集的一个指标是马修斯相关系数（MCC）：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In order to evaluate the performance of our model, we will perform 10 folds
    of cross validation, where we train a model on the training set and validate on
    the validation set:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估我们模型的性能，我们将执行10次交叉验证，其中我们在训练集上训练模型并在验证集上验证：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To visualize the performance of our model on the training and test data, we
    can make boxplots. The results are shown in [Figure 11-5](#train-validation-scores):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化我们模型在训练和测试数据上的性能，我们可以制作箱线图。结果显示在[图11-5](#train-validation-scores)中：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Boxplots of scores for the training and validation sets.](Images/dlls_1105.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![训练集和验证集的分数的箱线图。](Images/dlls_1105.png)'
- en: Figure 11-5\. Boxplots of scores for the training and validation sets.
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-5。训练集和验证集的分数的箱线图。
- en: The plots indicate that, as expected, the performance on the training set is
    superior to that on the validation set. However, the performance on the validation
    set is still quite good. At this point, we can be confident in the performance
    of our model.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图表表明，如预期的那样，训练集上的性能优于验证集上的性能。然而，验证集上的性能仍然相当不错。在这一点上，我们可以对我们模型的性能感到自信。
- en: 'It is also useful to visualize the results of our model. In order to do this,
    we will generate a set of predictions for a validation set:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化我们模型的结果也是有用的。为了做到这一点，我们将为验证集生成一组预测：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To make processing easier, we’ll create a Pandas dataframe with the predictions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使处理更容易，我们将使用预测创建一个Pandas数据框架：
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can easily add the activity class (1 = active, 0 = inactive) and the SMILES
    strings for our predicted molecules to the dataframe:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地将活动类别（1 = 活性，0 = 非活性）和我们预测的分子的SMILES字符串添加到数据框架中：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It’s always a good idea to look at the first few lines of the dataframe to ensure
    that the data makes sense. [Table 11-3](#predicted-dataframe) shows the results.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 查看数据框架的前几行总是一个好主意，以确保数据是合理的。[表11-3](#predicted-dataframe)显示了结果。
- en: Table 11-3\. The first few lines of the dataframe containing the predictions
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-3。包含预测的数据框架的前几行
- en: '|   | neg | pos | active | SMILES |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|   | neg | pos | active | SMILES |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | 0.906081 | 0.093919 | 1 | Cn1ccnc1Sc2ccc(cc2Cl)Nc3c4cc(c(cc4ncc3C#N)OCCC...
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0.906081 | 0.093919 | 1 | Cn1ccnc1Sc2ccc(cc2Cl)Nc3c4cc(c(cc4ncc3C#N)OCCC...
    |'
- en: '| 1 | 0.042446 | 0.957554 | 1 | Cc1cnc(nc1c2cc([nH]c2)C(=O)N[C@H](CO)c3cccc(c3...
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0.042446 | 0.957554 | 1 | Cc1cnc(nc1c2cc([nH]c2)C(=O)N[C@H](CO)c3cccc(c3...
    |'
- en: '| 2 | 0.134508 | 0.865492 | 1 | Cc1cccc(c1)[C@@H](CO)NC(=O)c2cc(c[nH]2)c3c(cnc...
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0.134508 | 0.865492 | 1 | Cc1cccc(c1)[C@@H](CO)NC(=O)c2cc(c[nH]2)c3c(cnc...
    |'
- en: '| 3 | 0.036508 | 0.963492 | 1 | Cc1cnc(nc1c2cc([nH]c2)C(=O)N[C@H](CO)c3ccccc3)...
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0.036508 | 0.963492 | 1 | Cc1cnc(nc1c2cc([nH]c2)C(=O)N[C@H](CO)c3ccccc3)...
    |'
- en: '| 4 | 0.940717 | 0.059283 | 1 | c1c\2c([nH]c1Br)C(=O)NCC/C2=C/3\C(=O)N=C(N3)N
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0.940717 | 0.059283 | 1 | c1c\2c([nH]c1Br)C(=O)NCC/C2=C/3\C(=O)N=C(N3)N
    |'
- en: Creating boxplots enables us to compare the predicted values for the active
    and inactive molecules (see [Figure 11-6](#positive-scores)).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建箱线图使我们能够比较活性和非活性分子的预测值（请参见[图11-6](#positive-scores)）。
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Positive scores for the predicted molecules.](Images/dlls_1106.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![预测分子的正分数。](Images/dlls_1106.png)'
- en: Figure 11-6\. Positive scores for the predicted molecules.
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-6。预测分子的正分数。
- en: 'The performance of our model is very good: we can see a clear separation between
    the active and inactive molecules. When building a predictive model it is often
    important to examine inactive molecules that are predicted as active (false positives)
    as well as active molecules that are predicted as inactive (false negatives).
    It appears that only one of our active molecules received a low positive score.
    In order to look more closely, we will create a new dataframe containing all of
    the active molecules with a positive score < 0.5):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型表现非常好：我们可以看到活性和非活性分子之间有明显的区分。在构建预测模型时，通常重要的是检查被预测为活性的非活性分子（假阳性）以及被预测为非活性的活性分子（假阴性）。看起来只有一个我们的活性分子得到了低正分数。为了更仔细地观察，我们将创建一个新的数据框架，其中包含所有得分<0.5的活性分子：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To inspect the chemical structures of the molecules in our dataframe, we use
    the `PandasTools` module from RDKit:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查数据框架中分子的化学结构，我们使用RDKit中的PandasTools模块：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s look at the new dataframe ([Figure 11-7](#false-negative)):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看新的数据框架（图11-7）：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![False negative predictions.](Images/dlls_1107.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![假阴性预测。](Images/dlls_1107.png)'
- en: Figure 11-7\. False negative predictions.
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-7. 假阴性预测。
- en: In order to fully take advantage of the information in this dataframe, we need
    to have some knowledge of medicinal chemistry. It is often informative to look
    at the chemical structures of the false negative molecules and compare these with
    the chemical structures of the true positive molecules. This may provide some
    insight into the reasons that molecules were not predicted correctly. Often it
    may be the case that the false negative molecules are not similar to any of the
    true positive molecules. In this case, it may be worth performing additional literature
    searches to increase the diversity of the molecules in the training set.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用这个数据框架中的信息，我们需要对药物化学有一些了解。查看假阴性分子的化学结构并将其与真阳性分子的化学结构进行比较通常是有益的。这可能会提供一些关于为什么分子没有被正确预测的原因的见解。通常情况下，假阴性分子可能与任何真阳性分子都不相似。在这种情况下，值得进行额外的文献搜索，以增加训练集中分子的多样性。
- en: 'We can use a similar approach to examine the false positive molecules, which
    are inactive but received a positive score > 0.5 (see [Figure 11-8](#false-positive)).
    Again, comparison with the chemical structures of the true positive molecules
    may be informative:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的方法来检查假阳性分子，这些分子是非活性的，但得到了>0.5的正分数。再次与真阳性分子的化学结构进行比较可能会提供信息：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![A false positive molecule.](Images/dlls_1108.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![一个假阳性分子。](Images/dlls_1108.png)'
- en: Figure 11-8\. A false positive molecule.
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-8. 一个假阳性分子。
- en: 'During the model training phase, our objective was to evaluate the performance
    of our model. As such, we trained the model on a portion of the data and validated
    the model on the remainder. Now that we have evaluated the performance, we want
    to generate the most effective model. In order to do this, we will train the model
    on all of the data:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型训练阶段，我们的目标是评估模型的性能。因此，我们在部分数据上训练模型，并在其余数据上验证模型。现在我们已经评估了性能，我们希望生成最有效的模型。为了做到这一点，我们将在所有数据上训练模型：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This gives us an accuracy score of 91%. Finally, we save the model to disk
    so that we can use it to make future predictions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个准确度得分为91%。最后，我们将模型保存到磁盘上，以便将来进行预测使用：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Preparing a Dataset for Model Prediction
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为模型预测准备数据集
- en: Now that we’ve created a predictive model, we can apply this model to a new
    set of molecules. In many cases, we will build a predictive model based on literature
    data, then apply that model to a set of molecules that we want to screen. The
    molecules we want to screen may come from an internal database or from a commercially
    available screening collection. As an example, we will use the predictive model
    we created to screen a small sample of 100,000 compounds from the ZINC database,
    a collection of more than 1 billion commercially available molecules.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个预测模型，我们可以将这个模型应用到一组新的分子上。在许多情况下，我们会基于文献数据构建一个预测模型，然后将该模型应用到我们想要筛选的一组分子上。我们想要筛选的分子可能来自内部数据库或商业可用的筛选集合。例如，我们将使用我们创建的预测模型来筛选来自ZINC数据库的100,000个化合物的小样本，这是一个包含超过10亿种商业可用分子的集合。
- en: One potential source of difficulty when carrying out a virtual screen is the
    presence of molecules that have the potential to interfere with biological assays.
    Over the last 25 years, many groups within the scientific community have developed
    sets of rules to identify potentially reactive or problematic molecules. Several
    of these rule sets, which are encoded as SMARTS strings, have been collected by
    the group that curates the ChEMBL database. These rule sets have been made available
    through a Python script called *rd_filters.py*. In this example, we will use *rd_filters.py*
    to identify potentially problematic molecules in our set of 100,000 molecules
    from the ZINC database.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行虚拟筛选时，一个潜在的困难源可能是存在可能干扰生物测定的分子。在过去的25年里，科学界内的许多团体已经制定了一套规则，用于识别可能具有反应性或问题的分子。这些规则集中的几个，被编码为SMARTS字符串，已经被负责维护ChEMBL数据库的团体收集起来。这些规则集已经通过一个名为rd_filters.py的Python脚本提供。在这个例子中，我们将使用rd_filters.py来识别来自ZINC数据库的100,000个分子集合中可能存在问题的分子。
- en: The *rd_filters.py* script and associated data files are available on our [GitHub
    repository](https://github.com/deepchem/DeepLearningLifeSciences).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*rd_filters.py*脚本和相关数据文件可以在我们的[GitHub存储库](https://github.com/deepchem/DeepLearningLifeSciences)上找到。'
- en: The available modes and arguments for the script can be obtained by calling
    it with the `-h` flag.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`-h`标志调用脚本可以获得脚本的可用模式和参数。
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To call the script on our input file, which is called *zinc_100k.smi*, we can
    specify the input file and a prefix for output filenames. The `filter` argument
    calls the script in “filter” mode, where it identifies potentially problematic
    molecules. The `--prefix` argument indicates that the output file names will start
    with the prefix *zinc*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output indicates the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The script is running on 24 cores. It runs in parallel across multiple cores,
    and the number of cores can be selected with the `-np` flag.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The script is using the “Inpharmatica” set of rules. This rule set covers a
    large range of chemical functionality that has been shown to be problematic in
    biological assays. In addition to the Inpharmaticia set, the script has seven
    other rule sets available. Please see the *rd_filters.py* documentation for more
    information.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMILES strings for the molecules passing the filters were written to a file
    called *zinc.smi*. We will use this as the input when we use the predictive model.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailed information on which compounds triggered particular structural alerts
    was written to a file called *zinc.CSV*.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 69% of the molecules passed the filters, and 31% were considered problematic.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is informative to take a look at the reasons why 31% of the molecules were
    rejected. This can let us know whether we need to adjust any of the filters. We
    will use a bit of Python code to look at the first few lines of output, shown
    in [Table 11-4](#filters-table).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Table 11-4\. The first few lines of the dataframe created from zinc.CSV
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '|   | SMILES | NAME | FILTER | MW | LogP | HBD |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| 0 | CN(CCO)C[C@@H](O)Cn1cnc2c1c(=O)n(C)c(=O)n2C | ZINC000000000843 | Filter82_pyridinium
    >0 | 311.342 | –2.2813 | 2 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| 1 | O=c1[nH]c(=O)n([C@@H]2C[C@@H](O)[C@H](CO)O2)cc1Br | ZINC000000001063
    | Filter82_pyridinium >0 | 307.100 | –1.0602 | 3 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| 2 | Cn1c2ncn(CC(=O)N3CCOCC3)c2c(=O)n(C)c1=O | ZINC000000003942 | Filter82_pyridinium
    >0 | 307.310 | –1.7075 | 0 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| 3 | CN1C(=O)C[C@H](N2CCN(C(=O)CN3CCCC3)CC2)C1=O | ZINC000000036436 | OK |
    308.382 | –1.0163 | 0 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| 4 | CC(=O)NC[C@H](O)[C@H]1O[C@H]2OC(C)(C)O[C@H]2[C... | ZINC 000000041101
    | OK | 302.327 | -1.1355 | 3 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: 'The dataframe has six columns:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: SMILES
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: the SMILES strings for each molecule.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: NAME
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: the molecule NAME, as listed in the input file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: FILTER
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: the reason the molecule was rejected, or “OK” if the molecule was not rejected.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: MW
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: the molecular weight of the molecule. By default, molecules with molecular weight
    greater than 500 are rejected.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: LogP
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: the calculated octanol/water partition coefficient of the molecule. By default,
    molecules with LogP greater than five are rejected.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: HBD
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: the number of hydrogen bond donors. By default, molecules with more than 5 hydrogen
    bond donors are rejected.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `Counter` class from the Python `collections` library to identify
    which filters were responsible for removing the largest numbers of molecules (see
    [Table 11-5](#filter-results)):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Table 11-5\. Counts of the number of molecules selected by the top 5 filters
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Rule | Count |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| 1 | OK | 69156 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| 6 | Filter41_12_dicarbonyl > O | 19330 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| 0 | Filter82_pyridinium > O | 7761 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| 10 | Filter93_acetyl_urea > O | 1541 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| 11 | Filter78_bicyclic_lmide > O | 825 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: 'The first line in the table, labeled as “OK,” indicates the number of molecules
    that were not eliminated by any of the filters. From this, we can see that 69,156
    of the molecules in our input passed all of the filters. The largest number of
    molecules (19,330) were rejected because they contained a 1,2-dicarbonyl group.
    Molecules of this type may react and form covalent bonds with protein residues
    such as serine and cysteine. We can find the SMARTS pattern used to identify these
    molecules by looking for the string “Filter41_12_dicarbonyl” in the *filter_collection.CSV*
    file that is part of the *rd_filters.py* distribution. The SMARTS pattern is “*C(=O)C(=O)*”,
    which represents:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Any atom, connected to
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: carbon double bonded to oxygen, connected to
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碳双键氧，连接到
- en: carbon double bonded to oxygen, connected to
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碳双键氧，连接到
- en: any atom.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何原子。
- en: 'It is always good to look at the data and ensure that everything is working
    as expected. We can use the `highlightAtomLists` argument to RDKit’s `MolsToGridImage()`
    function to highlight the 1,2-dicarbonyl functionality (see [Figure 11-9](#dicarbonyl-matches)):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 查看数据并确保一切按预期工作总是好的。我们可以使用RDKit的`MolsToGridImage()`函数的`highlightAtomLists`参数来突出显示1,2-二羰基功能（参见[图11-9](#dicarbonyl-matches)）：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can see that the molecules do indeed have dicarbonyl groups, as highlighted
    in the figure. If we wanted to, we could similarly evaluate other filters. At
    this point, however, we can be satisfied with the results of the filtering. We
    have removed the problematic molecules from the set we plan to use for our virtual
    screen. We can now use this set, which is in the file *zinc.smi*, in the next
    step of this exercise.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到分子确实具有二羰基基团，如图中所示。如果我们愿意，我们也可以类似地评估其他过滤器。然而，在这一点上，我们可以对过滤结果感到满意。我们已经从我们计划用于虚拟筛选的集合中删除了有问题的分子。我们现在可以使用这个集合，在文件*zinc.smi*中，在这个练习的下一步中使用。
- en: '![Molecules containing a 1,2-dicarbonyl group.](Images/dlls_1109.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![含有1,2-二羰基基团的分子。](Images/dlls_1109.png)'
- en: Figure 11-9\. Molecules containing a 1,2-dicarbonyl group.
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-9。含有1,2-二羰基基团的分子。
- en: Applying a Predictive Model
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用预测模型
- en: 'The `GraphConvMdel` we created can now be used to search the set of commercially
    available compounds we just filtered. Applying the model requires a few steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`GraphConvMdel`现在可以用于搜索我们刚刚过滤的商业化合物集合。应用模型需要几个步骤：
- en: Load the model from disk.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从磁盘加载模型。
- en: Create a featurizer.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个特征化器。
- en: Read and featurize the molecules that will run through the model.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取并对将通过模型运行的分子进行特征化。
- en: Examine the scores for the predictions.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查预测的得分。
- en: Examine the chemical structures of the top predicted molecules.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查预测分子的化学结构。
- en: Cluster the selected molecules.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对选择的分子进行聚类。
- en: Write the selected molecules from each cluster to a CSV file.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个簇中选择的分子写入CSV文件。
- en: 'We begin by importing the necessary libraries:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入必要的库：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'and loading the model we generated earlier:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 并加载我们之前生成的模型：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To generate predictions from our model, we first need to featurize the molecules
    we plan to use to generate predictions. We do this by instantiating a DeepChem
    `ConvMolFeaturizer`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的模型生成预测，我们首先需要对我们计划用来生成预测的分子进行特征化。我们通过实例化一个DeepChem `ConvMolFeaturizer`
    来实现这一点：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In order to featurize the molecules, we need to transform our SMILES file into
    a CSV file. In order to create a DeepChem featurizer we also require an activity
    column, so we add one, then write the file to CSV:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对分子进行特征化，我们需要将我们的SMILES文件转换为CSV文件。为了创建一个DeepChem特征化器，我们还需要一个活动列，因此我们添加一个，然后将文件写入CSV：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As before, we should look at the first few lines of the file (shown in [Table 11-6](#input-dataframe))
    to make sure everything is as we had expect:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们应该查看文件的前几行（在[表11-6](#input-dataframe)中显示）以确保一切如我们所期望的那样：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Table 11-6\. The first few lines of the input file
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-6。输入文件的前几行
- en: '|   | SMILES | Name | Val |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|   | SMILES | Name | Val |'
- en: '| --- | --- | --- | --- |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | CN1C(=O)C[C@H](N2CCN(C(=O)CN3CCCC3)CC2)C1=O | ZINC000000036436 | 0 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CN1C(=O)C[C@H](N2CCN(C(=O)CN3CCCC3)CC2)C1=O | ZINC000000036436 | 0 |'
- en: '| 1 | CC(=O)NC[C@H](O)[C@H]1O[C@H]2OC(C)(C)O[C@H]2[C@@H]1NC(C)=O | ZINC000000041101
    | 0 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 1 | CC(=O)NC[C@H](O)[C@H]1O[C@H]2OC(C)(C)O[C@H]2[C@@H]1NC(C)=O | ZINC000000041101
    | 0 |'
- en: '| 2 | C1CN(c2nc(-c3nn[nH]n3)nc(N3CCOCC3)n2)CCO1 | ZINC000000054542 | 0 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 2 | C1CN(c2nc(-c3nn[nH]n3)nc(N3CCOCC3)n2)CCO1 | ZINC000000054542 | 0 |'
- en: '| 3 | OCCN(CCO)c1nc(Cl)nc(N(CCO)CCO)n1 | ZINC000000109481 | 0 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 3 | OCCN(CCO)c1nc(Cl)nc(N(CCO)CCO)n1 | ZINC000000109481 | 0 |'
- en: '| 4 | COC(=O)c1ccc(S(=O)(=O)N(CCO)CCO)n1C | ZINC000000119782 | 0 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 4 | COC(=O)c1ccc(S(=O)(=O)N(CCO)CCO)n1C | ZINC000000119782 | 0 |'
- en: 'Note that the Val column is just a placeholder to keep the DeepChem featurizer
    happy. The file looks good, so we will write it as a CSV file to use as input
    for DeepChem. We use the `index=False` argument to prevent Pandas from writing
    the row numbers as the first column:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Val列只是一个占位符，以使DeepChem特征化器保持正常。文件看起来不错，因此我们将其写为CSV文件以用作DeepChem的输入。我们使用`index=False`参数来防止Pandas将行号写为第一列：
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can use DeepChem to read this CSV file with a loader and featurize the molecules
    we plan to predict:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用DeepChem读取此CSV文件并对我们计划预测的分子进行特征化：
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The featurized molecules can be used to generate predictions with the model:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 特征化的分子可以用来生成模型的预测：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For convenience,we will put the predictions into a Pandas dataframe:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们将预测放入Pandas数据框中：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The distribution plot, available in the Seaborn library, provides a nice overview
    of the distribution of scores. Unfortunately, in virtual screening, there are
    no clear rules for defining an activity cutoff. Often the best strategy is to
    look at the distribution of scores, then select a set of the top-scoring molecules.
    If we look at the plot in [Figure 11-10](#distplot), we can see that there are
    only a small number of molecules with scores above 0.3\. We can use this value
    as a preliminary cutoff for molecules that we may want to screen experimentally.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 分布图，可在Seaborn库中找到，提供了得分分布的良好概述。不幸的是，在虚拟筛选中，没有明确的规则来定义活性截断。通常最好的策略是查看得分的分布，然后选择一组得分最高的分子。如果我们查看[图11-10](#distplot)中的图表，我们可以看到只有少数得分高于0.3的分子。我们可以将此值用作我们可能希望在实验中筛选的分子的初步截断值。
- en: '![Distribution plot of the scores for the predicted molecules.](Images/dlls_1110.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![预测分子得分的分布图。](Images/dlls_1110.png)'
- en: Figure 11-10\. Distribution plot of the scores for the predicted molecules.
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-10。预测分子得分的分布图。
- en: 'We can join the dataframe with the scores to the dataframe with the SMILES
    strings. This gives us the ability to view the chemical structures of the top-scoring
    molecules:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将具有得分的数据框与具有SMILES字符串的数据框连接起来。这使我们能够查看得分最高的分子的化学结构：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As we saw earlier, adding a molecule column to the dataframe enables us to look
    at the chemical structures of the hits (see [Figure 11-11](#structure-table)).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，向数据框添加一个分子列使我们能够查看命中的化学结构(见[图11-11](#structure-table))。
- en: '![Chemical structures of the top-scoring molecules.](Images/dlls_1111.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![得分最高分子的化学结构。](Images/dlls_1111.png)'
- en: Figure 11-11\. Chemical structures of the top-scoring molecules.
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-11。得分最高分子的化学结构。
- en: 'Based on what we see here, it looks like many of the hits are similar. Let’s
    look at a few more molecules ([Figure 11-12](#structure-grid)):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在这里看到的情况，许多结果很相似。让我们看一些更多的分子([图11-12](#structure-grid))：
- en: '[PRE55]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![Structure grid with top-scoring hits. Values below the structures are model
    scores.](Images/dlls_1112.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![具有得分最高命中的结构网格。结构下方的值是模型得分。](Images/dlls_1112.png)'
- en: Figure 11-12\. Structure grid with top-scoring hits. Values below the structures
    are model scores.
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-12。具有得分最高命中的结构网格。结构下方的值是模型得分。
- en: 'Indeed, many of the molecules are very similar and might end up being redundant
    in our screen. One way to be more efficient would be to cluster the molecules
    and only screen the highest-scoring molecule in each cluster. RDKit has an implementation
    of the Butina clustering method, one of the most highly used methods in cheminformatics.
    In the Butina clustering method, we group molecules based on their chemical similarity,
    which is calculated using a comparison of bit vectors (arrays of 1 and 0), also
    known as *chemical fingerprints* that represent the presence or absence of patterns
    of connected atoms in a molecule. These bit vectors are typically compared using
    a metric known as the *Tanimoto coefficient*, which is defined as:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，许多分子非常相似，可能最终在我们的筛选中是多余的。更有效的方法之一是对分子进行聚类，仅筛选每个聚类中得分最高的分子。RDKit具有Butina聚类方法的实现，这是化学信息学中最常用的方法之一。在Butina聚类方法中，我们根据化学相似性对分子进行分组，该相似性是使用比较位向量（由1和0组成的数组），也称为*化学指纹*来计算的，这些化学指纹表示分子中连接的原子模式的存在或不存在。通常使用的度量标准是*Tanimoto系数*，定义如下：
- en: <math><mrow><mi>T</mi> <mi>a</mi> <mi>n</mi> <mi>i</mi> <mi>m</mi> <mi>o</mi>
    <mi>t</mi> <mi>o</mi> <mo>=</mo> <mfrac><mrow><mi>A</mi><mo>∩</mo><mi>B</mi></mrow>
    <mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow></mfrac></mrow></math>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mrow><mi>T</mi> <mi>a</mi> <mi>n</mi> <mi>i</mi> <mi>m</mi> <mi>o</mi>
    <mi>t</mi> <mi>o</mi> <mo>=</mo> <mfrac><mrow><mi>A</mi><mo>∩</mo><mi>B</mi></mrow>
    <mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow></mfrac></mrow></math>
- en: The numerator of the equation is the intersection, or the number of bits that
    are 1 in both bit vectors *A* and *B*. The denominator is the number of bits that
    are 1 in either vector *A* or vector *B*. The Tanimoto coefficient can range between
    0, indicating that the molecules have no patterns of atoms in common, and 1, indicating
    that all of the patterns contained in molecule *A* are also contained in molecule
    *B*. As an example,we can consider the bit vectors shown in [Figure 11-13](#tanimoto-fixed).
    The intersection of the two vectors is 3 bits, while the union is 5\. The Tanimoto
    coefficient is then 3/5, or 0.6\. Note that the example shown here has been simplified
    for demonstration purposes. In practice, these bit vectors can contain hundreds
    or even thousands of bits.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 方程的分子是交集，或者在位向量*A*和*B*中都为1的位数。分母是在向量*A*或向量*B*中为1的位数。Tanimoto系数的范围可以在0到1之间，表示分子中没有共同的原子模式，1表示分子*A*中包含的所有模式也包含在分子*B*中。例如，我们可以考虑[图11-13](#tanimoto-fixed)中显示的位向量。两个向量的交集是3位，而并集是5。因此，Tanimoto系数为3/5，即0.6。请注意，此处显示的示例已经简化以进行演示。在实践中，这些位向量可以包含数百甚至数千位。
- en: '![Calculating a Tanimoto coefficient.](Images/dlls_1113.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![计算Tanimoto系数。](Images/dlls_1113.png)'
- en: Figure 11-13\. Calculating a Tanimoto coefficient.
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-13。计算Tanimoto系数。
- en: 'A small amount of code is necessary to cluster a set of molecules. The only
    parameter required for Butina clustering is the cluster cutoff. If the Tanimoto
    similarity of two molecules is greater than the cutoff, the molecules are put
    into the same cluster. If the similarity is less than the cutoff, the molecules
    are put into different clusters:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对一组分子进行聚类需要一小段代码。Butina聚类所需的唯一参数是聚类截止值。如果两个分子的Tanimoto相似度大于截止值，则将这些分子放入同一聚类中。如果相似度小于截止值，则将这些分子放入不同的聚类中：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Before clustering, we will create a new dataframe with only the 100 top-scoring
    molecules. Since `combo_df` is already sorted, we only have to use the `head`
    function to select the first 100 rows in the dataframe:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行聚类之前，我们将创建一个只包含前100个得分最高的分子的新数据框。由于`combo_df`已经排序，我们只需使用`head`函数选择数据框中的前100行：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can then create a new column containing the cluster identifier for each
    compound:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个新列，为每个化合物包含聚类标识符：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As always, it’s good to take a look and make sure everything worked. We now
    see that in addition to the SMILES string, molecule name, and predicted values,
    we also have a cluster identifier (see [Figure 11-14](#butina_img)).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，查看并确保一切正常是很重要的。现在我们看到，除了SMILES字符串、分子名称和预测值之外，我们还有一个聚类标识符(见[图11-14](#butina_img))。
- en: '![The first few rows of the clustered dataset.](Images/dlls_1114.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![聚类数据集的前几行。](Images/dlls_1114.png)'
- en: Figure 11-14\. The first few rows of the clustered dataset.
  id: totrans-251
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-14。聚类数据集的前几行。
- en: 'We can use the Pandas `unique` function to determine that we have 55 unique
    clusters:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Pandas的`unique`函数确定我们有55个唯一的聚类：
- en: '[PRE59]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Ultimately, we would like to purchase these compounds and screen them experimentally.
    In order to do this, we need to save a CSV file listing the molecules we plan
    to purchase. The `drop_duplicates` function can be used to select one molecule
    per cluster. By default, the function starts from the top of the table and removes
    rows with values that have already been seen:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们希望购买这些化合物并进行实验筛选。为了做到这一点，我们需要保存一个CSV文件，列出我们计划购买的分子。`drop_duplicates`函数可用于选择每个聚类中的一个分子。默认情况下，该函数从表的顶部开始，并删除已经看到的值的行：
- en: '[PRE60]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Just to make sure that this operation worked, let’s use the `shape` parameter
    to get the number of rows and columns in the new dataframe:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这个操作有效，让我们使用`shape`参数来获取新数据框中的行数和列数：
- en: '[PRE61]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we can write out a CSV file with the molecules we want to screen:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以写出一个CSV文件，其中包含我们想要筛选的分子：
- en: '[PRE62]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Conclusion
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: At this point, we have followed all the steps of a ligand-based virtual screening
    workflow. We used deep learning to build a classification model that was capable
    of distinguishing active from inactive molecules. The process began with evaluating
    our training data and ensuring that the molecular weight, LogP, and charge distributions
    were balanced between the active and decoy sets. Once we’d made the necessary
    adjustments to the chemical structures of the decoy molecules, we were ready to
    build a model.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经按照基于配体的虚拟筛选工作流程的所有步骤进行了操作。我们使用深度学习构建了一个能够区分活性和非活性分子的分类模型。该过程始于评估我们的训练数据，并确保活性和诱饵集之间的分子量、LogP和电荷分布平衡。一旦我们对诱饵分子的化学结构进行了必要的调整，我们就准备构建模型了。
- en: The first step in building the model was generating a set of chemical features
    for the molecules being used. We used the DeepChem `GraphConv` featurizer to generate
    a set of appropriate chemical features. These features were then used to build
    a graph convolution model, which was subsequently used to predict the activity
    of a set of commercially available molecules. In order to avoid molecules that
    could be problematic in biological assays, we used a set of computational rules
    encoded as SMARTS patterns to identify molecules containing chemical functionality
    previously known to interfere with assays or create subsequent liabilities.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 构建模型的第一步是为使用的分子生成一组化学特征。我们使用DeepChem的`GraphConv`特征生成器来生成一组适当的化学特征。然后使用这些特征构建了一个图卷积模型，随后用于预测一组商业可用分子的活性。为了避免可能在生物分析中出现问题的分子，我们使用一组编码为SMARTS模式的计算规则来识别含有先前已知干扰分析或产生后续风险的化学功能的分子。
- en: With our list of desired molecules in hand, we are in a position to test these
    molecules in biological assays. Typically the next step in our workflow would
    be to obtain samples of the chemical compounds for testing. If the molecules came
    from a corporate compound collection, a robotic system would collect the samples
    and prepare them for testing. If the molecules were purchased from commercial
    sources, additional weighing and dilution with buffered water or another solvent
    would be necessary.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们手头的期望分子列表，我们可以在生物分析中测试这些分子。通常，我们工作流程中的下一步是获取化合物样品进行测试。如果这些分子来自公司化合物库，机器人系统将收集样品并为其进行测试准备。如果这些分子是从商业来源购买的，还需要额外称重并用缓冲水或其他溶剂稀释。
- en: Once the samples are prepared, they are tested in biological assays. These assays
    can cover a wide range of endpoints, ranging from inhibiting bacterial growth
    to preventing the proliferation of cancer cells. While the testing of these molecules
    is the final step in our virtual screening exercise, it is far from the end of
    the road for a drug discovery project. Once we have run the initial biological
    assay on the molecules we identified through virtual screening, we analyze the
    results of the screen. If we find experimentally active molecules, we will typically
    identify and test other similar molecules that will enable us to understand the
    relationships between different parts of the molecule and the biological activity
    that we are measuring. This optimization process often involves the synthesis
    and testing of hundreds or even thousands of molecules to identify those with
    the desired combination of safety and biological activity.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦样品准备好，它们就会在生物分析中进行测试。这些分析可以涵盖从抑制细菌生长到阻止癌细胞增殖的各种终点。虽然测试这些分子是我们虚拟筛选练习的最后一步，但对于药物发现项目来说，这远非终点。一旦我们对通过虚拟筛选确定的分子进行了初步生物分析，我们会分析筛选结果。如果我们发现实验活性分子，通常会识别和测试其他类似的分子，以帮助我们理解分子不同部分与我们正在测量的生物活性之间的关系。这个优化过程通常涉及合成和测试数百甚至数千个分子，以确定具有所需安全性和生物活性组合的分子。
