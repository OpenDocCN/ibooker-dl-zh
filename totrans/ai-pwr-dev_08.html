<html><head></head><body>
  <h1 class="tochead" id="heading_id_2">6 <a id="idTextAnchor000"/><a id="idTextAnchor001"/><a id="idTextAnchor002"/><a id="idTextAnchor003"/><a id="idTextAnchor004"/><a id="idTextAnchor005"/><a id="idTextAnchor006"/>Testing, assessing, and explaining with large language models</h1>

  <p class="co-summary-head">This chapter covers<a id="idIndexMarker000"/><a id="marker-115"/></p>

  <ul class="calibre5">
    <li class="co-summary-bullet">Drafting unit tests with ease</li>

    <li class="co-summary-bullet">Generating integration tests</li>

    <li class="co-summary-bullet">Determining code quality and coverage</li>

    <li class="co-summary-bullet">Assessing software complexity</li>

    <li class="co-summary-bullet">Translating code and text</li>
  </ul>

  <p class="body">This chapter will explore a critical aspect of software engineering: testing. The act of testing software serves multiple essential purposes. First and foremost, it aids in the identification of bugs, errors, and problems that can potentially affect the software’s functionality, usability, or performance. Furthermore, it ensures that the software adheres to the required quality standards. By conducting thorough tests, we can verify whether the software meets the specified requirements, functions as intended, and produces the expected outcomes. Through comprehensive testing, developers can evaluate software’s reliability, accuracy, efficiency, security, and compatibility across various platforms and environments. Detecting and resolving software defects early in the development process can result in significant time and cost savings.</p>

  <p class="body">Once we have finished formulating our tests, we will evaluate the quality of our code. You will be introduced to several metrics that are helpful in assessing software quality and complexity. Additionally, if we need clarification on the purpose of our code or are reviewing it for the first time, we will seek an explanation to ensure thorough understanding.</p>

  <h2 class="fm-head" id="heading_id_3">6.1 Testing, testing … one, two, three types</h2>

  <p class="body">Testing plays a vital role in software engineering; therefore, we will explore various types of testing in detail. These include unit tests, integration tests, and behavior tests. To start, we will use Copilot Chat to help us create a <i class="fm-italics">unit test</i>. <a id="idIndexMarker001"/><a id="idIndexMarker002"/><a id="marker-116"/></p>

  <p class="fm-callout"><span class="fm-callout-head">Definition</span> A <i class="fm-italics">unit test</i> focuses on testing individual components or units of code to ensure that they function correctly in isolation. Developers usually run unit tests to help identify bugs and problems in specific software units.<a id="idIndexMarker003"/></p>

  <h3 class="fm-head1" id="heading_id_4">6.1.1 Unit testing</h3>

  <p class="body">In this section, we will create unit tests to test our software components. Several unit-testing frameworks are available for Python. Each has unique features and is suitable for different scenarios. We will examine each of them briefly before settling on a specific framework based on the recommendation provided by our AI tool.<a id="idIndexMarker004"/><a id="idIndexMarker005"/></p>

  <p class="body">The first framework is <code class="fm-code-in-text">unittest</code>. This is Python’s standard library for creating unit tests. It comes bundled with Python and doesn’t need to be installed separately. <code class="fm-code-in-text">unittest</code> provides a rich set of assertions and is great for writing simple to complex test cases, but it can be verbose. It is a good choice for writing basic unit tests, especially if you don’t want to introduce additional dependencies in your project. It’s useful in any scenario where you need to confirm the functionality of individual units of code in isolation from the rest of the system.<a id="idIndexMarker006"/></p>

  <p class="body">Next, let’s examine <code class="fm-code-in-text">pytest</code>. It is a popular third-party library that can be used for unit testing, although it’s versatile enough to handle more than just unit tests. It requires less boilerplate code than <code class="fm-code-in-text">unittest</code> and has powerful features like fixtures for setup and teardown, parameterized testing, and the ability to run <code class="fm-code-in-text">unittest</code> and <code class="fm-code-in-text">nose</code> test suites. p<code class="fm-code-in-text">ytest</code> is great for both simple and complex unit test cases. It’s also useful for functional and integration tests. If you value simplicity and ease of use, and your project is not restricted to using only the Python standard library, <code class="fm-code-in-text">pytest</code> is an excellent choice.<a id="idIndexMarker007"/></p>

  <p class="body"><code class="fm-code-in-text">nose2</code> is the successor to the deprecated <code class="fm-code-in-text">nose</code> testing framework. It extends <code class="fm-code-in-text">unittest</code> and makes testing easier. It’s known for its test discovery feature, which automatically finds your project’s tests so you don’t have to manually list them. <code class="fm-code-in-text">nose2</code> is good for larger projects where test discovery can save time. Like <code class="fm-code-in-text">pytest</code>, it can run <code class="fm-code-in-text">unittest</code> test suites, so it’s also a good choice if you’re migrating from <code class="fm-code-in-text">unittest</code> but want to keep your existing tests.<a id="idIndexMarker008"/></p>

  <p class="body">Finally, there is <code class="fm-code-in-text">doctest</code>. This is another module that’s part of the Python standard library. It’s not a full-featured testing framework like the others, but it allows you to write tests directly in your docstrings. <code class="fm-code-in-text">doctest</code> is best suited for simple cases where you want to demonstrate how to use a function or module and confirm that the example code works as expected. It’s a great way to ensure that your documentation stays up to date with your code.<a id="idIndexMarker009"/></p>

  <p class="body">Copilot Chat recommended that we use <code class="fm-code-in-text">unittest</code>, so we will. You might try to ask it yourself and see if it reaches a different conclusion, which it may, depending on how you frame the question.</p>

  <p class="body">First we will define test cases by creating classes that inherit from the <code class="fm-code-in-text">unittest.TestCase</code> class. In writing our first unit test, we will uncover a rather pernicious bug that has thus far eluded us; we will get to that shortly. Finally, we are going to test the correctness of the <code class="fm-code-in-text">DepartmentStatisticsVisitor</code> class. <a id="idIndexMarker010"/><a id="idIndexMarker011"/><a id="marker-117"/></p>

  <p class="body">We start with a prompt asking Copilot Chat to create a unit test for <code class="fm-code-in-text">DepartmentStatisticsVisitor</code>. The response will be a reminder of the importance of context. Copilot Chat, given that we began a new chat session, will attempt to create this unit test, but it lacks the definition of any of our classes.</p>

  <p class="fm-code-listing-caption">Listing 6.1 First attempt to define a unit test</p>
  <pre class="programlisting">import unittest
from department_visitor import DepartmentStatisticsVisitor
  
class TestDepartmentStatisticsVisitor(unittest.TestCase):
    def test_visit_department(self):
        visitor = DepartmentStatisticsVisitor()
        department = {'name': 'Sales', 'employees': 
            [{'name': 'John', 'salary': 50000}, 
            {'name': 'Jane', 'salary': 60000}]}
        visitor.visit_department(department)
        self.assertEqual(visitor.total_salaries, 110000)
        self.assertEqual(visitor.num_employees, 2)
        self.assertEqual(visitor.avg_salary, 55000)</pre>

  <p class="body">We proceed by inputting definitions into Copilot Chat so that it can refine the test case. We can tell it more about the visitor class:</p>
  <pre class="programlisting">The DepartmentStatisticsVisitor class visits to determine the total asset depreciation based off of the asset allocation for each department</pre>

  <p class="body">With this updated information, Copilot Chat can better estimate how our unit test should function.</p>

  <p class="fm-code-listing-caption">Listing 6.2 The result of a unit test prompt</p>
  <pre class="programlisting">import unittest
from department_visitor import DepartmentStatisticsVisitor, Asset
  
class TestDepartmentStatisticsVisitor(unittest.TestCase):
    def test_visit(self):
        visitor = DepartmentStatisticsVisitor()
        asset1 = Asset(1000, 500, 0.5)
        asset2 = Asset(2000, 1000, 0.3)
        visitor.visit(asset1)
        visitor.visit(asset2)
        self.assertEqual(visitor.get_total_cost(), 3000)
        self.assertEqual(visitor.get_total_depreciation(), 1500)
        self.assertEqual(visitor.get_total_allocation(), 0.8)</pre>

  <p class="body">The unit test is close to what we need; however, the definition of <code class="fm-code-in-text">Asset</code> is incorrect. We can enter the proper definition from our asset.py class, and Copilot Chat will continue to refine the unit test.<a id="marker-118"/></p>

  <p class="fm-code-listing-caption">Listing 6.3 Next attempt to define a unit test, with <code class="fm-code-in-text">Asset</code> definition</p>
  <pre class="programlisting">import unittest
from datetime import date
from typing import List
from dataclasses import dataclass
  
@dataclass
class Location:
    name: str
    address: str
  
@dataclass
class Asset:
    id: int
    name: str
    status: str
    category: str
    cost: float
    useful_life: int
    salvage_value: float
    purchase_date: date
    locations: List[Location]
  
class TestAsset(unittest.TestCase):
    def test_asset(self):
        location1 = Location('Office', '123 Main St')
        location2 = Location('Warehouse', '456 Elm St')
        asset = Asset(1, 'Computer', 
            'In use', 'Hardware',
             1000.0, 3, 100.0, date.today(), 
            [location1, location2])
        self.assertEqual(asset.id, 1)
        self.assertEqual(asset.name, 'Computer')
        self.assertEqual(asset.status, 'In use')
        self.assertEqual(asset.category, 'Hardware')
        self.assertEqual(asset.cost, 1000.0)
        self.assertEqual(asset.useful_life, 3)
        self.assertEqual(asset.salvage_value, 100.0)
        self.assertEqual(asset.purchase_date, date.today())
        self.assertEqual(asset.locations, [location1, location2])</pre>

  <p class="body">This is closer. We also need to remind Copilot Chat that the <code class="fm-code-in-text">Asset</code> class has a class called <code class="fm-code-in-text">FundingDetails</code>. Let’s provide the definition of <code class="fm-code-in-text">FundingDetails</code> and inform Copilot Chat that it should be part of <code class="fm-code-in-text">Asset</code>. <a id="idIndexMarker012"/><a id="marker-119"/></p>

  <p class="fm-code-listing-caption">Listing 6.4 Third attempt at a unit test, which comes reasonably close</p>
  <pre class="programlisting">import unittest
from department_visitor import 
    DepartmentStatisticsVisitor, Asset, 
    FundingDetails
from datetime import date
from typing import List, Dict
from dataclasses import dataclass
 
@dataclass
class Location:
    name: str
    address: str
  
class TestDepartmentStatisticsVisitor(unittest.TestCase):
    def test_visit(self):
        visitor = DepartmentStatisticsVisitor()
        location1 = Location('Office', '123 Main St')
        location2 = Location('Warehouse', '456 Elm St')
        asset1 = Asset(1, 'Computer', 'In use', 
            'Hardware', 1000.0, 3, 
            100.0, date.today(), 
            [location1, location2])
        asset2 = Asset(2, 'Printer', 'In use', 
            'Hardware', 500.0, 2, 50.0, 
            date.today(), [location1])
        funding_details1 = FundingDetails(
            asset1, 'Straight Line', 
            0.33, { 'IT': 0.5, 'HR': 0.5 })
        funding_details2 = FundingDetails(
            asset2, 'Double Declining Balance', 
            0.25, { 'IT': 0.3, 'HR': 0.7 })
        visitor.visit(asset1, funding_details1)
        visitor.visit(asset2, funding_details2)
        self.assertEqual(visitor.get_total_cost(), 1500.0)
        self.assertEqual(visitor.get_total_depreciation(), 550.0)
        self.assertEqual(visitor.get_total_allocation(), 0.8)</pre>

  <p class="body">All that remains is to manually update the <code class="fm-code-in-text">import</code> statements.</p>

  <p class="fm-callout"><span class="fm-callout-head">NOTE</span> Let this exercise be a cautionary tale in the usage of large language models: coercing them to behave with respect to highly focused tasks can be very challenging, to the point of not being worth the effort. In the real world, no one will blame you for abandoning the prompt engineering and going back to just coding out this test. However, with some persistence, you can build a template library that you can use to build a suite of unit tests for similarly shaped classes. Also note that Copilot Chat can and will generate a test for the file in the editor window if you instruct it to <span>Generate (a) unit test for my code</span>, but it will mock all objects/properties that are not directly part of the class under test. Depending on what you are attempting to test, the utility of this feature may be questionable. Another common problem specific to Python is that the indentation is frequently incorrect with code copied from Copilot Chat.</p>

  <p class="body">When we attempt to run this test, we discover that there is a <i class="fm-italics">circular dependency</i> between the visitor, asset, funding details, and depreciation strategy. A circular dependency is a situation in which two or more modules or components depend on each other directly or indirectly. In our case, when Python tries to instantiate <code class="fm-code-in-text">Asset</code>, it loads the definition of <code class="fm-code-in-text">FundingDetails</code>. We can fix this by moving away from a direct instantiation or reference to the <code class="fm-code-in-text">FundingDetails</code> class. <a id="idIndexMarker013"/><a id="idIndexMarker014"/><a id="marker-120"/></p>

  <p class="fm-code-listing-caption">Listing 6.5 Updated <code class="fm-code-in-text">Asset</code>, no direct reference to <code class="fm-code-in-text">FundingDetails</code></p>
  <pre class="programlisting">@dataclass
class Asset():
    id: int
    name: str
    status: str
    category: str
    cost: float
    useful_life: int
    salvage_value: float
    purchase_date: date
    locations: List[Location]
    funding_details: None or 'itam.domain.funding_details.FundingDetails'</pre>

  <p class="body">We need to do the same for the <code class="fm-code-in-text">FundingDetails</code> class. It should not directly reference the <code class="fm-code-in-text">DepreciationStrategy</code> class.<a id="idIndexMarker015"/><a id="idIndexMarker016"/></p>

  <p class="fm-code-listing-caption">Listing 6.6 <code class="fm-code-in-text">FundingDetails</code>, no direct ref to <code class="fm-code-in-text">DepreciationStrategy</code></p>
  <pre class="programlisting">@dataclass
class FundingDetails:
    depreciation_rate: float
    department_allocations: Dict[Department, float]
    depreciation_strategy: DepreciationStrategy or 'itam.domain.depreciation_strategy.DepreciationStrategy'
    asset: None or 'itam.domain.asset.Asset'</pre>

  <p class="body">As we’ve seen, we were able to create a unit test using Copilot Chat. However, we would likely have been able to create it more easily if we had written it without Copilot. The tool is surprisingly good at providing guidance as to when and how to test your code, but the implementation (at least currently) leaves something to be desired.</p>

  <p class="body">In the real world, we would continue to add unit tests to build up a substantial body of tests. How many tests is <i class="fm-italics">substantial</i>, you ask? We will explore this shortly. However, we first turn our attention to the next type of test: the <i class="fm-italics">integration test</i>.<a id="idIndexMarker017"/></p>

  <p class="fm-callout"><span class="fm-callout-head">Definition</span> <i class="fm-italics">Integration testing</i> involves testing the interaction between different components or modules of the software to ensure that they work together seamlessly. It verifies that the integrated system functions as expected and detects any inconsistencies or communication problems between modules.<a id="idIndexMarker018"/></p>

  <h3 class="fm-head1" id="heading_id_5">6.1.2 Integration testing</h3>

  <p class="body"><a id="marker-121"/>In this section, we will develop an integration test that will allow us to test the end-to-end system. Fortunately, <code class="fm-code-in-text">fastapi</code> comes with its own test client, which will aid us in creating this test.<a id="idIndexMarker019"/><a id="idIndexMarker020"/><a id="idIndexMarker021"/><a id="idIndexMarker022"/></p>

  <p class="body">We begin by copying in the definition of <code class="fm-code-in-text">AssetController</code> into the Copilot Chat window. We can then ask Copilot Chat how to create an integration test for this controller. Given that we included the routes in the definition, Copilot Chat should be able to provide us with accurate integration tests. We need to specify that we will use the <code class="fm-code-in-text">InMemoryAssetRepository</code> class or fix this after the test has been generated.<a id="idIndexMarker023"/></p>

  <p class="fm-code-listing-caption">Listing 6.7 Copilot Chat-generated integration test of <code class="fm-code-in-text">AssetController</code></p>
  <pre class="programlisting">from fastapi.testclient import TestClient
from itam.infrastructure.adapters.memory_asset_repository import MemoryAssetRepository
from itam.infrastructure.ports.asset_rest_port import AssetRestPort
from itam.interfaces.asset_controller import AssetController
  
def test_get_assets():
    # Create an instance of the InMemoryAssetRepository
    asset_repository = InMemoryAssetRepository()
  
    # Add some assets to the repository
    asset_repository.create(Asset(name="Asset 1", unit_cost=1000))
    asset_repository.create(Asset(name="Asset 2", unit_cost=2000))
  
    # Create an instance of the AssetRestPort using the MemoryAssetRepository
    asset_rest_port = AssetRestPort(asset_repository)
  
    # Create an instance of the AssetController using the AssetRestPort
    asset_controller = AssetController(asset_rest_port)
  
    # Create a TestClient instance using the AssetController's router
    client = TestClient(asset_controller.get_router())
  
    # Send a GET request to the /assets endpoint
    response = client.get("/assets")
  
    # Check that the response status code is 200 OK
    assert response.status_code == 200
  
    # Check that the response body contains the expected assets
    assert response.json() == [
        {"id": 1, "name": "Asset 1", "unit_cost": 1000},
        {"id": 2, "name": "Asset 2", "unit_cost": 2000},</pre>

  <p class="body">We will now turn our attention to the final type of testing that we’ll examine: <i class="fm-italics">behavior testing</i>.</p>

  <p class="fm-callout"><span class="fm-callout-head">Definition</span> <i class="fm-italics">Behavior testing</i> focuses on the behavior of a system as a whole from the perspective of an end user. It is typically used to test the functionality of a system and to ensure that the system meets the requirements and specifications defined for it.</p>

  <h3 class="fm-head1" id="heading_id_6">6.1.3 Behavior testing</h3>

  <p class="body">In a sense, all testing is behavior testing, as tests verify the behavior of the system. However, behavior testing is unique in some respects. Let’s summarize the different types of testing that we have encountered thus far and contrast them against behavior tests. <a id="idIndexMarker024"/><a id="marker-122"/></p>

  <p class="body">Unit testing focuses on testing individual units or components of a system in isolation, typically using automated tests. Unit tests are designed to test the functionality of individual functions or methods and to ensure that they behave correctly under a variety of conditions.</p>

  <p class="body">Integration testing, on the other hand, focuses on testing the interactions between different components or units of a system. Integration testing is typically used to test the interfaces between different components or units and to ensure that they work together correctly. Integration testing can be performed manually or using automated tests, and it typically involves testing the interactions between different components or units of a system rather than the system as a whole.</p>

  <p class="body">Behavioral testing focuses on defining the behavior of the software in terms of user stories or scenarios. These scenarios are written in a specific format called <i class="fm-italics">given-when-then</i> (GWT) and are used to drive the development process. The GWT format describes the preconditions (given), the actions (when), and the expected outcomes (then) of a particular scenario.<a id="idIndexMarker025"/></p>

  <p class="body">As we progress with our testing, we may find that some behaviors or components are difficult to set up in our test. Additionally, it may be tricky to isolate the behavior of a particular object or module and test the interactions between different objects. To address this limitation, we can use a <i class="fm-italics">mock object</i>.</p>

  <p class="fm-callout"><span class="fm-callout-head">Definition</span> A <i class="fm-italics">mock object</i> is a test double that simulates the behavior of a real object in a controlled way. Mock objects can also be used to simulate error conditions or edge cases that are difficult to reproduce with real objects. They can be created manually using a mocking library such as <code class="fm-code-in-text">unittest.mock</code> or <code class="fm-code-in-text">pytest-mock</code>. These libraries provide functions and classes for creating and configuring mock objects. Mock objects can be configured to return specific values or raise specific exceptions when their methods are called. They can also be used to record the calls made to their methods so that you can verify that the correct methods were called with the correct parameters.<a id="idIndexMarker026"/><a id="idIndexMarker027"/><a id="idIndexMarker028"/></p>

  <p class="body">We will incorporate mock objects into the prompt to create a behavior test for <code class="fm-code-in-text">AssetManager</code>:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="7%"/>
      <col class="contenttable-0-col" span="1" width="93%"/>
    </colgroup>

    <tbody class="calibre7">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figure1"><img alt="" class="calibre8" src="../Images/logo-NC.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-table-bodyt">We have a class called AssetManager. AssetManager's constructor takes two classes BaseRepository and AssetLocationMediator. The BaseRepository is a repository in which Assets are stored. We want to use InMemoryAssetRepository, which is a subclass of BaseRepository that stores the Assets in memory. Use a mock object for AssetLocationMediator. The AssetManager stores Assets using the method create and gets all of the Assets using the method get_assets. An asset has 10 required positional arguments: 'id', 'name', 'status', 'category', 'cost', 'useful_life', 'salvage_value', 'purchase_date', 'locations', and 'funding_details'. Use named parameters to make it clear which param is going where. Create a BDD script that will add two Assets to the AssetManager, confirming that all Assets cost $4000.00. This should be implemented in Python. Take it step by step, telling us the tools and libraries you will use.</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">Copilot Chat tells us that we need to create a new file (a <i class="fm-italics">feature file</i>) called <code class="fm-code-in-text">asset_manager.feature</code>. In this file, we will define <code class="fm-code-in-text">AssetManager</code>’<code class="fm-code-in-text">s</code> attributes (and any supporting classes). For example, the feature file defines a scenario that adds two assets to <code class="fm-code-in-text">AssetManager</code>, confirms that the total cost of all assets is $4,000.00, and mocks the <code class="fm-code-in-text">AssetLocationMediator</code> class.<a id="idIndexMarker029"/><a id="marker-123"/></p>

  <p class="fm-code-listing-caption">Listing 6.8 <code class="fm-code-in-text">asset_manager.feature</code> file according to Copilot Chat</p>
  <pre class="programlisting">Feature: Asset Manager
  As an IT Asset Manager
  I want to be able to manage assets
  So that I can keep track of all IT assets in my organization
  
  Scenario: Add two assets to the Asset Manager
    Given the Asset Manager is running
    And the InMemoryAssetRepository is initialized
    And the AssetLocationMediator is mocked
    When I create an asset with a cost of $2000.00
    And I create another asset with a cost of $2000.00
    Then the total cost of all assets should be $4000.00</pre>

  <p class="body">We need to create a directory called features at the root of our project and place this file in that directory. Additionally, we need to add a subdirectory called steps. Next we create a new Python file called steps.py and place it in the steps directory. This Python file defines the step implementations for the scenario in the feature file. The <code class="fm-code-in-text">AssetManager</code>, <code class="fm-code-in-text">InMemoryAssetRepository</code>, <code class="fm-code-in-text">AssetLocationMediator</code>, and <code class="fm-code-in-text">Asset</code> classes are imported, and six functions are defined to correspond to the steps in the scenario. These functions use the context object to store and retrieve data between steps. The <code class="fm-code-in-text">Mock</code> class from the <code class="fm-code-in-text">unittest.mock</code> library is used to create a mock object for the <code class="fm-code-in-text">AssetLocationMediator</code> class. The <code class="fm-code-in-text">Asset</code> class is instantiated using named parameters to clarify which parameter belongs to which attribute. If we ask Copilot Chat for the contents of the steps.py file, we will see output similar to the following listing.<a id="idIndexMarker030"/></p>

  <p class="fm-code-listing-caption">Listing 6.9 Implementation details for behavior test defined in steps.py<a id="marker-124"/></p>
  <pre class="programlisting">from behave import given, when, then
from itam.service.asset_manager import AssetManager
from itam.infrastructure.repository.in_memory_asset_repository 
    import InMemoryAssetRepository
from itam.domain.asset import Asset
from itam.infrastructure.mediators.asset_location_mediator 
    import AssetLocationMediator
from unittest.mock import Mock
  
@given('the Asset Manager is running')
def step_impl(context):
    context.asset_repository = InMemoryAssetRepository()
    context.asset_location_mediator = Mock(spec=AssetLocationMediator)
    context.asset_manager = AssetManager(
            context.asset_repository, 
            context.asset_location_mediator)
  
@given('the InMemoryAssetRepository is initialized')
def step_impl(context):
    pass
  
@given('the AssetLocationMediator is mocked')
def step_impl(context):
    pass
  
@when('I create an asset with a cost of ${cost}')
def step_impl(context, cost):
    asset = Asset(id=1, name='Test Asset 1', status='Available',
        category='Test Category', cost=float(cost), useful_life=5,
        salvage_value=0, purchase_date='2022-01-01', 
        locations=['Test Location'], 
        funding_details={'Test Funding': 1000})
    context.asset_manager.create(asset)
  
@when('I create another asset with a cost of ${cost}')
def step_impl(context, cost):
    asset = Asset(id=2, name='Test Asset 2', status='Available',
        category='Test Category', cost=float(cost), useful_life=5,
        salvage_value=0, purchase_date='2022-01-01', 
        locations=['Test Location'], 
        funding_details={'Test Funding': 1000})
    context.asset_manager.create(asset)
  
@then('the total cost of all assets need to be ${total_cost}')
def step_impl(context, total_cost):
    assets = context.asset_manager.get_assets()
    assert sum(asset.cost for asset in assets) == float(total_cost)</pre>

  <p class="body">If you do not have it installed already, you need to install the <code class="fm-code-in-text">behave</code> library using pip: <code class="fm-code-in-text">pip install behave</code>. Additionally, add it to the requirements.txt file to ensure that it will be pulled in when we later build a deployable version of this application. We run the behavior test by issuing the following command from the root directory of our project.<a id="idIndexMarker031"/></p>

  <p class="fm-code-listing-caption">Listing 6.10 Running the behavior test, and the resulting output</p>
  <pre class="programlisting">% behave features
Feature: Asset Manager # features/asset_manager.feature:1
  As an IT Asset Manager
  I want to be able to manage assets
  So that I can keep track of all IT assets in my organization
  Scenario: Add two assets to the Asset Manager          
    # features/asset_manager.feature:6
    Given the Asset Manager is running                   
# features/steps/steps.py:8 0.000s
    And the InMemoryAssetRepository is initialized       
# features/steps/steps.py:14 0.000s
    And the AssetLocationMediator is mocked              
# features/steps/steps.py:18 0.000s
    When I create an asset with a cost of $2000.00       
# features/steps/steps.py:22 0.000s
    And I create another asset with a cost of $2000.00   
# features/steps/steps.py:27 0.000s
    Then the total cost of all assets should be $4000.00 
# features/steps/steps.py:32 0.000s
  
1 feature passed, 0 failed, 0 skipped
1 scenario passed, 0 failed, 0 skipped
6 steps passed, 0 failed, 0 skipped, 0 undefined
Took 0m0.001s</pre>

  <p class="body">In this section, we have laid a foundation for good software development by using three types of tests: unit, integration, and behavior. Some may quibble that it came very late in the development lifecycle of this project, and they would not be wrong. In the real world, we develop our tests as we develop our code. Some may argue that we need to build our tests <i class="fm-italics">before</i> our code. You may or may not hold this belief, but either way, you need to test early and test often.</p>

  <p class="body">In the next section, we dive into some metrics that can be used to determine the overall quality of our software, and we will ask Copilot to help us assess the quality of our code thus far.</p>

  <h2 class="fm-head" id="heading_id_7">6.2 Assessing quality</h2>

  <p class="body"><a id="marker-125"/>Understanding the performance, reliability, maintainability, and overall quality of software applications is a crucial aspect of software engineering. This section delves into the fascinating and intricate domain of software quality metrics—the quantitative standards and benchmarks that guide our understanding of the quality of a software system.<a id="idIndexMarker032"/></p>

  <p class="body">Software quality metrics are essential tools that allow stakeholders—developers, testers, managers, and users—to assess a software product’s state, identifying its strengths and areas for improvement. They provide an empirical foundation for various processes such as product development, testing, debugging, maintenance, and improvement initiatives. By quantifying specific characteristics of the software, these metrics provide a tangible means to understand the otherwise abstract concept of software quality.</p>

  <p class="body">In this section, we explore several important categories of software quality metrics, including product metrics, process metrics, and project metrics. We’ll analyze their significance, methodologies for their calculation, and how they can be effectively utilized to evaluate and enhance software quality. This exploration will include both static metrics, which are applied to the static software system, and dynamic metrics, which assess the system’s behavior during execution.</p>

  <p class="body">Software quality metrics not only contribute to the technical soundness of a software system but also help ensure customer satisfaction, profitability, and long-term business success. Therefore, developing an understanding of these metrics is invaluable to anyone involved in the field of software development, from engineers and project managers to executives and software users.</p>

  <p class="body">We will examine a few common measures of complexity and maintainability of the class or code. Complex software can be difficult to comprehend, which makes it challenging for developers, particularly new ones, to grasp how different parts of the software interact with each other. This can slow down the onboarding process and development time.</p>

  <p class="body">Complex code often leads to more maintenance: modifications or bug fixes can take longer because it’s harder to predict the effects of changing a single piece of the system. This can result in higher costs over the software’s lifecycle.</p>

  <p class="body">Complex software also tends to be more error-prone. Because it’s harder to understand, developers are more likely to introduce bugs when making changes. Also, complex code can have many interdependencies, and a change in one area may have unexpected effects elsewhere.</p>

  <p class="body">The more complex the software, the more test cases are required to achieve thorough testing. It may also be harder to write these test cases due to the complexity of the logic involved.</p>

  <p class="body">Writing simple and maintainable code should be one of our highest priorities. Observing the change in the metric that accompanies our code should aid us in this endeavor. Toward this objective, the first metric that we can (and should) use is <i class="fm-italics">cyclomatic complexity</i>.<a id="idIndexMarker033"/><a id="marker-126"/></p>

  <p class="fm-callout"><span class="fm-callout-head">Definition</span> <i class="fm-italics">Cyclomatic complexity</i> is a metric that quantifies the number of independent paths through a software module. It measures the complexity of decision-making in the code, including loops, conditionals, and branches. A higher cyclomatic complexity value indicates increased complexity and suggests the potential for more bugs and challenges in understanding and maintaining the code.<a id="idIndexMarker034"/></p>

  <p class="body">Enter the following prompt anywhere in the file department_visitor.py. Copilot will immediately output the answer:</p>
  <pre class="programlistinge"># Question: What is the cyclomatic complexity of the class Department- StatisticsVisitor?
# Answer: 1</pre>

  <p class="body">Copilot tells us that the complexity of this class is 1. You may or may not be aware of the meaning of this value. If the latter, you can ask Copilot to elaborate:</p>
  <pre class="programlistinge"># Question: Is 1 an excellent cyclomatic complexity?
# Answer: Yes

# Question: Why is 1 a good value for cyclomatic complexity?
# Answer: Because it is low</pre>

  <p class="body">Copilot informs us that cyclomatic complexity is good if it is low. Intuitively, this makes sense. Code with low complexity means it is simpler to understand and therefore reason about. It is likely easier to maintain as well. Next we will explore the <i class="fm-italics">Halstead complexity measures.</i><a id="idIndexMarker035"/><a id="marker-127"/></p>

  <p class="fm-callout"><span class="fm-callout-head">Definition</span> <i class="fm-italics">Halstead complexity measures</i> assess the complexity of a software program based on the number of unique operators and operands used in the code. These measures include metrics such as program length (N1), program vocabulary (n1), volume (V), difficulty (D), effort (E), and others. These metrics provide insights into the size and cognitive complexity of the code.<a id="idIndexMarker036"/></p>

  <p class="body">Similar to last time, we will start with a prompt asking Copilot to determine the Halstead complexity measure for our visitor class:</p>
  <pre class="programlistinge"># Question: What is the Halstead Complexity Measure of the class Department-StatisticsVisitor?
# Answer: 2

# Question: What is the Halstead Difficulty Measure of the class Department-StatisticsVisitor?
# Answer: 1

# Question: Is 2 a good Halstead Complexity Measure?
# Answer: Yes

# Question: Is 1 a good Halstead Difficulty Measure?
# Answer: Yes

# Question: What is a bad Halstead Difficulty Measure?
# Answer: 10

# Question: What is a bad Halstead Complexity Measure?
# Answer: 10

# Question: What does a high Halstead Difficulty Measure mean?
# Answer: It means the code is hard to understand</pre>

  <p class="body">You may want to continue this Q&amp;A session for a while to see what information can be gleaned from Copilot. Once you are ready to continue, there is one more metric to explore: the <i class="fm-italics">maintainability index.</i><i class="fm-italics"><a id="idIndexMarker037"/></i></p>

  <p class="fm-callout"><span class="fm-callout-head">Definition</span> The <i class="fm-italics">maintainability index</i> is a composite metric that combines several factors, including cyclomatic complexity, lines of code, and Halstead complexity measures, to provide an overall measure of software maintainability. A higher maintainability index suggests easier maintenance and potentially lower complexity.<a id="idIndexMarker038"/><a id="marker-128"/></p>

  <p class="body">Start a similar discussion for the maintainability index in the visitor file:</p>
  <pre class="programlistinge"># Question: What is the maintainability index of the class Department-StatisticsVisitor?
# Answer: 100

# Question: Do we want a high Maintainability Index or low Maintainability Index?
# Answer: high

# Question: Why do we want a high Maintainability Index?
# Answer: Because it is easier to maintain</pre>

  <p class="body">If we get a low maintainability index, we can refactor to reduce this number.</p>

  <p class="body">A metric is useful in that it gives us a nail to hang our hat on; that is, we can take that measure and perform some action to improve it. Metrics move us beyond pure aesthetics or the subjectivity of an individual. A metric is real, actionable data. But Copilot has (at least) one more trick up its proverbial sleeve. Copilot is capable of doing more than just writing and assessing our code: it can also address the code’s flaws. Let’s bug hunt.<a id="idIndexMarker039"/></p>

  <h2 class="fm-head" id="heading_id_8">6.3 Hunting for bugs</h2>

  <p class="body">In this section, we will use an elementary (albeit contrived) example to demonstrate how we can use Copilot to find and fix problems in our code. This code is supposed to loop a the list of integers and calculate the sum. However, there is a “blink and you’ll miss it” bug: the sum is assigned the value of <code class="fm-code-in-text">i</code> rather than adding the value of <code class="fm-code-in-text">i</code> to the running total. <a id="idIndexMarker040"/><a id="idIndexMarker041"/></p>

  <p class="fm-code-listing-caption">Listing 6.11 Looping over a list of integers and calculating the sum</p>
  <pre class="programlisting">l = [1, 2, 3, 4, 5]
  
if __name__ == '__main__':
    sum = 0
    for i in l:
        sum = i
    
    print("sum is", sum)</pre>

  <p class="body">To debug this problem, we will introduce a new tool: Copilot Labs. Prior to Copilot Chat, Copilot Labs was the only means by which certain features were available in an IDE (specifically, Visual Studio Code). For example, we need to use Copilot Labs to find and fix bugs. The main advantage that Copilot Labs still offers today is that it can access the highlighted contents of your editor pane. This feature allows Copilot Labs to operate directly on the editable code in your IDE.</p>

  <p class="body">Once you install the extension into your IDE, you should see a Copilot Labs toolkit on the left side of the IDE, as shown in figure 6.1. If you need a reminder about how to install an extension into your IDE, see appendices A–C for instructions.<a id="marker-129"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH06_F01_Crocker2.png"/></p>

    <p class="figurecaption">Figure 6.1 The Copilot Labs toolkit menu, which includes options for finding and fixing bugs. The toolkit also provides facilities to enhance your code as well as document it.</p>
  </div>

  <p class="body">We will temporarily change the contents of the main.py file to the code listed in listing 6.11. Once you have made this change, highlight the code and click the Fix Bug button in the Copilot Labs toolkit. You should see output like that in figure 6.2. Copilot Labs was able to determine the problem in this code and provides a suggestion as to how to fix it.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH06_F02_Crocker2.png"/></p>

    <p class="figurecaption">Figure 6.2 Copilot Labs, using the GPT model, has identified the bug and how to address it.</p>
  </div>

  <p class="body">Alternatively, you could copy this code into ChatGPT and ask it to find the bug. However, it is arguable that doing so is less convenient as you would have to know there was a bug in your code before asking ChatGPT to fix it.</p>

  <h2 class="fm-head" id="heading_id_9">6.4 Covering code</h2>

  <p class="body"><i class="fm-italics">Code coverage</i> is a measure of how much of your code is being exercised by your tests. It is typically expressed as a percentage and represents the proportion of your code that your tests execute.<a id="idIndexMarker042"/><a id="idIndexMarker043"/><a id="marker-130"/></p>

  <p class="body">Code coverage can be used as a metric to evaluate the effectiveness of your tests. If your code coverage is low, it may indicate that parts of your code are not being tested, which can lead to uncaught bugs and other problems. Alternatively, with high code coverage, you can rest assured that your code is well-tested. This does not guarantee that your code is bug-free, but it should give you a high degree of confidence that if there are bugs, they will be caught in a test.</p>

  <p class="body">To determine the code coverage in our Python project, we will use the code coverage tool provided in the <code class="fm-code-in-text">coverage</code> library. The <code class="fm-code-in-text">coverage</code> library works by instrumenting our code to collect coverage data as it runs. It can collect coverage data for any Python code, including tests, scripts, and modules. By using a code coverage tool like <code class="fm-code-in-text">coverage</code>, we can better understand how much of our code is being exercised by our tests and identify areas of our code that may need more testing.<a id="idIndexMarker044"/></p>

  <p class="body">First, let’s install <code class="fm-code-in-text">coverage</code> using pip: <code class="fm-code-in-text">pip install coverage</code>. Next, let’s run our tests with coverage: <code class="fm-code-in-text">coverage run -m pytest</code>. This runs your tests and collects coverage data.</p>

  <p class="body">Now we will generate a coverage report (see figure 6.3). The coverage report shows the code coverage for each file in our project. We can create a text-based coverage report using the <code class="fm-code-in-text">coverage report</code> command or generate an HTML version of the report using the <code class="fm-code-in-text">coverage html</code> command. The HTML version of the report is in the htmlcov directory.<a id="idIndexMarker045"/><a id="idIndexMarker046"/><a id="marker-131"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH06_F03_Crocker2.png"/></p>

    <p class="figurecaption">Figure 6.3 The code coverage report showing the coverage for each file in our ITAM system project</p>
  </div>

  <p class="body">Code coverage of 70% is a good start. In the real world, we would continue working with our team and generative AI pals to bring this measure up into the high 90s. Now we will transition to a new topic: using generative AI to describe a code listing to us.</p>

  <h2 class="fm-head" id="heading_id_10">6.5 Transliterating code—from code to descriptions</h2>

  <p class="body">Often, we are handed existing source code. Determining the exact entry point of this code, the purpose of the code, and the overall structure of a brownfield project can be challenging. Fortunately, this is one of the areas in which generative AIs truly excel: translating code into textual descriptions. <a id="idIndexMarker047"/><a id="idIndexMarker048"/></p>

  <p class="body">To begin, we will copy the (buggy) code from the previous section into the Copilot Chat dialog box, prefixed with the following prompt (see figure 6.4):</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="7%"/>
      <col class="contenttable-0-col" span="1" width="93%"/>
    </colgroup>

    <tbody class="calibre7">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figure1"><img alt="" class="calibre8" src="../Images/logo-NC.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-table-bodyt">What does this code do?</p>
        </td>
      </tr>
    </tbody>
  </table>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH06_F04_Crocker2.png"/></p>

    <p class="figurecaption">Figure 6.4 The buggy code from the last section with a prompt asking Copilot Chat to explain this code to us</p>
  </div>

  <p class="body"><a id="marker-132"/>What is striking about the explanation in figure 6.5 is that Copilot Chat detects a bug in the code and offers suggestions for how to fix it.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH06_F05_Crocker2.png"/></p>

    <p class="figurecaption">Figure 6.5 Copilot Chat explains the code’s purpose, identifies the bug, and suggests a fix.</p>
  </div>

  <p class="body">Next we will ask it something more challenging: to explain the behavior test from listing 6.9 into the Copilot Chat window, and ask it what this class does. You will likely receive a response similar to the following.</p>

  <p class="fm-code-listing-caption">Listing 6.12 Copilot Chat explaining the behavior test we wrote earlier</p>
  <pre class="programlisting">The code you provided is not a class but a series of step definitions for a Behavior-Driven Development (BDD) test using the Behave framework in Python. These steps correspond to a specific scenario written in Gherkin language (Given, When, Then format).<a id="idIndexMarker049"/>
  
These step definitions describe how to interact with an AssetManager class and an InMemoryAssetRepository class. They're meant to test the creation of assets and the calculation of the total cost of all assets.
  
Let's go through each step:
  
@given('the Asset Manager is running'): This sets up the initial state for the test. It initializes the AssetManager with an InMemoryAssetRepository (which presumably stores assets in memory during the execution of the test) and a mocked AssetLocationMediator.
  
@given('the InMemoryAssetRepository is initialized') and @given('the AssetLocationMediator is mocked'): These steps appear to be placeholders, as they don't execute any actions.
 
@when('I create an asset with a cost of ${cost}') and @when('I create another asset with a cost of ${cost}'): These steps create Asset instances with the given cost and add them to the AssetManager.
  
@then('the total cost of all assets should be ${total_cost}'): This step retrieves all the assets from the AssetManager, calculates the total cost, and checks that it matches the expected total cost.
  
This sequence of steps allows the user to test the process of creating assets and validating the total cost of all assets in the AssetManager.
  
    <b class="fm-bold"># Question: What does this method do?</b>
    # Answer: This code defines an asynchronous method get_asset that
      takes an integer asset_id as input. The method first calls the
      _asset_rest_port.read method with the asset_id to retrieve an
      asset from a REST API. If the asset is not found (i.e., the
      REST API returns None), the method raises an
      HTTPException with a 404 status code and a "Asset not
      found" detail message. Otherwise, the method returns the
      asset converted to a domain object using the from_asset
      function. The implementation of the from_asset function is
      not shown in the code snippet.    <a id="idIndexMarker050"/>
  
async def get_asset(self, asset_id: int):
        asset = self._asset_rest_port.read(asset_id)
        if asset is None:
            raise HTTPException(status_code=404, detail="Asset not found")
        return from_asset(asset)<a id="idIndexMarker051"/><a id="idIndexMarker052"/><a id="marker-133"/></pre>

  <h2 class="fm-head" id="heading_id_11">6.6 Translating from one language to another</h2>

  <p class="body">As remote as this may seem, you may find yourself looking through a code base written in a programming language with which you have only a passing familiarity. Alternatively, you may pine for a specific function from another language to be available in your current language. For example, what would the <code class="fm-code-in-text">Asset</code> and <code class="fm-code-in-text">FundingDetails</code> classes look like if they were rewritten in JavaScript? Well, let’s ask Copilot Chat.<a id="idIndexMarker053"/><a id="idIndexMarker054"/><a id="idIndexMarker055"/><a id="marker-134"/></p>

  <p class="fm-code-listing-caption">Listing 6.13 <code class="fm-code-in-text">Asset</code> and <code class="fm-code-in-text">FundingDetails</code> translated to JavaScript.</p>
  <pre class="programlisting">class Asset {
  constructor(id, name, status, category, cost, 
        useful_life, salvage_value, 
        purchase_date, locations, 
        funding_details) {
    this.id = id;
    this.name = name;
    this.status = status;
    this.category = category;
    this.cost = cost;
    this.useful_life = useful_life;
    this.salvage_value = salvage_value;
    this.purchase_date = purchase_date;
    this.locations = locations;
    this.funding_details = funding_details;
  }
}
  
class FundingDetails {
  constructor(asset, funding_source, funding_amount) {
    this.asset = asset;
    this.funding_source = funding_source;
    this.funding_amount = funding_amount;
  }
}</pre>

  <p class="body">You may think that translating a class or two is too easy. Well, we will attempt something more complex:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="7%"/>
      <col class="contenttable-0-col" span="1" width="93%"/>
    </colgroup>

    <tbody class="calibre7">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figure1"><img alt="" class="calibre8" src="../Images/logo-NC.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-table-bodyt">What would the AssetManager behavior test look like if written in JavaScript?</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="fm-code-listing-caption">Listing 6.14 <code class="fm-code-in-text">AssetManager</code> behavior test translated into JavaScript</p>
  <pre class="programlisting">const AssetManager = require('./asset_manager');
const Asset = require('./asset');
  
describe('AssetManager', () =&gt; {
  let assetManager;
  
  beforeEach(() =&gt; {
    assetManager = new AssetManager();
  });
  
  describe('addAsset', () =&gt; {
    it('should add an asset to the asset list', () =&gt; {
      const asset = new Asset(1, 'Computer', 'Active', 
            'Hardware', 1000.0, 5, 100.0, 
            new Date(), [], null);
      assetManager.addAsset(asset);
      expect(assetManager.assets.length).toBe(1);
      expect(assetManager.assets[0]).toBe(asset);
    });
  });
  
  describe('removeAsset', () =&gt; {
    it('should remove an asset from the asset list', () =&gt; {
      const asset = new Asset(1, 'Computer', 'Active', 
            'Hardware', 1000.0, 5, 100.0, 
            new Date(), [], null);
      assetManager.addAsset(asset);
      assetManager.removeAsset(asset);
      expect(assetManager.assets.length).toBe(0);
    });
  });
  
  describe('getAssetById', () =&gt; {
    it('should return the asset with the given ID', () =&gt; {
      const asset1 = new Asset(1, 'Computer', 'Active', 
            'Hardware', 1000.0, 5, 100.0, 
            new Date(), [], null);
      const asset2 = new Asset(2, 'Printer', 'Active', 
            'Hardware', 500.0, 3, 50.0, 
            new Date(), [], null);
      assetManager.addAsset(asset1);
      assetManager.addAsset(asset2);
      const result = assetManager.getAssetById(2);
      expect(result).toBe(asset2);
    });
  
    it('should return null if no asset with the given ID is found', () =&gt; {
      const result = assetManager.getAssetById(1);
      expect(result).toBeNull();
    });
  });
});</pre>

  <p class="body">Additionally, you may wish to have GPT rewrite the code in idiomatic JavaScript. You need only say<a id="marker-135"/></p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="7%"/>
      <col class="contenttable-0-col" span="1" width="93%"/>
    </colgroup>

    <tbody class="calibre7">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figure1"><img alt="" class="calibre8" src="../Images/logo-NC.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-table-bodyt">Write AssetManager in idiomatic JavaScript</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">Copilot Chat will inform you that it will define the <code class="fm-code-in-text">AssetManager</code> class using the class syntax introduced in ES6.<a id="idIndexMarker056"/></p>

  <p class="fm-code-listing-caption">Listing 6.15 <code class="fm-code-in-text">AssetManager</code> class rewritten in idiomatic JavaScript</p>
  <pre class="programlisting">class AssetManager {
  constructor() {
    this.assets = [];
  }
  
  addAsset(asset) {
    this.assets.push(asset);
  }
  
  removeAsset(asset) {
    const index = this.assets.indexOf(asset);
    if (index !== -1) {
      this.assets.splice(index, 1);
    }
  }
  
  getAssetById(id) {
    return this.assets.find(asset =&gt; asset.id === id) || null;
  }
}</pre>

  <p class="body"><a id="marker-136"/>Here’s an example of what the <code class="fm-code-in-text">AssetManager</code> behavior test might look like in JavaScript using the Jest testing framework (which Copilot Chat included without our suggestion).</p>

  <p class="fm-code-listing-caption">Listing 6.16 <code class="fm-code-in-text">AssetManager</code> behavior test in idiomatic JavaScript</p>
  <pre class="programlisting">const AssetManager = require('./asset_manager');
const Asset = require('./asset');
describe('AssetManager', () =&gt; {
  let assetManager;
  beforeEach(() =&gt; {
    assetManager = new AssetManager();
  });
  describe('addAsset', () =&gt; {
    it('should add an asset to the asset list', () =&gt; {
      const asset = new Asset(1, 'Computer', 'Active', 
            'Hardware', 1000.0, 5, 100.0, 
            new Date(), [], null);
      assetManager.addAsset(asset);
      expect(assetManager.assets.length).toBe(1);
      expect(assetManager.assets[0]).toBe(asset);
    });
  });
  describe('removeAsset', () =&gt; {
    it('should remove an asset from the asset list', () =&gt; {
      const asset = new Asset(1, 'Computer', 'Active', 
            'Hardware', 1000.0, 5, 100.0, 
            new Date(), [], null);
      assetManager.addAsset(asset);
      assetManager.removeAsset(asset);
      expect(assetManager.assets.length).toBe(0);
    });
  });
  describe('getAssetById', () =&gt; {
    it('should return the asset with the given ID', () =&gt; {
      const asset1 = new Asset(1, 'Computer', 'Active', 
            'Hardware', 1000.0, 5, 100.0, 
            new Date(), [], null);
      const asset2 = new Asset(2, 'Printer', 'Active', 
            'Hardware', 500.0, 3, 50.0, 
            new Date(), [], null);
      assetManager.addAsset(asset1);
      assetManager.addAsset(asset2);
      const result = assetManager.getAssetById(2);
      expect(result).toBe(asset2);
    });
    it('should return null if no asset with the given ID is found', () =&gt; {
      const result = assetManager.getAssetById(1);
      expect(result).toBeNull();
    });
  });
});</pre>

  <p class="body">In this example, we use the Jest testing framework to define a set of behavior tests for the <code class="fm-code-in-text">AssetManager</code> class. We are using the <code class="fm-code-in-text">describe</code> library to determine test suites and individual tests.<a id="idIndexMarker057"/><a id="idIndexMarker058"/><a id="marker-137"/></p>

  <p class="body">In each test, we create an instance of the <code class="fm-code-in-text">AssetManager</code> class and perform some operation on it, such as adding or removing an asset. We then use the <code class="fm-code-in-text">expect</code> function to make assertions about the behavior of the <code class="fm-code-in-text">AssetManager</code> class, such as checking that an asset was added to the asset list or that an asset was removed from the asset list. Note that the syntax for defining classes and constructors is slightly different in JavaScript than in Python, and we are using the required function to import the <code class="fm-code-in-text">AssetManager</code> and <code class="fm-code-in-text">Asset</code> classes from their respective modules.<a id="idIndexMarker059"/><a id="idIndexMarker060"/><a id="idIndexMarker061"/><a id="idIndexMarker062"/></p>

  <p class="body">Finally, time for the big finale: we will start a new ChatGPT 4.0 session and paste in our Mermaid diagram from chapter 3. Lead with this prompt:<a id="idIndexMarker063"/></p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="7%"/>
      <col class="contenttable-0-col" span="1" width="93%"/>
    </colgroup>

    <tbody class="calibre7">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figure1"><img alt="" class="calibre8" src="../Images/logo-NC.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-table-bodyt">Here is a mermaid diagram of my application. Please implement in Golang.</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">Marvel as it returns the code, rendered in Golang.</p>

  <p class="fm-code-listing-caption">Listing 6.17 <code class="fm-code-in-text">Asset</code> class rewritten in idiomatic Golang</p>
  <pre class="programlisting">type Asset struct {
    id            int
    name          string
    status        string
    category      string
    fundingDetails *FundingDetails
}
  
func NewAsset(name, status, category string, 
    fundingDetails *FundingDetails) *Asset {
    return &amp;Asset{
        name:          name,
        status:        status,
        category:      category,
        fundingDetails: fundingDetails,
    }
}</pre>

  <p class="body">Next, tell it to switch to Java.</p>

  <p class="fm-code-listing-caption">Listing 6.18 <code class="fm-code-in-text">Asset</code> class rewritten in idiomatic Java<a id="idIndexMarker064"/><a id="idIndexMarker065"/><a id="marker-138"/></p>
  <pre class="programlisting">class Asset {
    private int id;
    private String name;
    private String status;
    private String category;
    private FundingDetails fundingDetails;
  
    public Asset(String name, String status, String category, FundingDetails fundingDetails) {
        this.name = name;
        this.status = status;
        this.category = category;
        this.fundingDetails = fundingDetails;
    }</pre>

  <h2 class="fm-head" id="heading_id_12">Summary</h2>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">Unit testing focuses on testing individual components or units of code to identify bugs and problems in specific units. Unit tests will be the most numerous in your codebase.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Integration testing tests the interaction between different components or modules of the software to ensure seamless integration and detect communication problems.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Behavior testing tests a system’s functionality from an end user’s perspective, ensuring that it meets requirements and specifications.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Mock objects simulate the behavior of natural objects in a controlled way and are useful for testing and simulating error conditions. Mock objects are especially good at mimicking parts of the system that are needed for the test to run but are outside the scope of the test: for example, if your class has a constructor argument for a database, but you do not want to test the database directly because the data may change, causing your test to be inconclusive, nonrepeatable, or nondeterministic.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Cyclomatic complexity measures the number of independent paths through a software module, indicating complexity and potential for bugs.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Halstead complexity measures assess software complexity based on unique operators and operands, providing insights into code size and cognitive complexity.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The maintainability index combines factors like cyclomatic complexity, lines of code, and Halstead measures to evaluate software maintainability.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Code coverage is a metric for evaluating test effectiveness, indicating the extent to which code is tested and the potential for uncaught bugs. Generally, higher is better.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Large language models allow you to navigate code in an unfamiliar programming language or translate features from another language in the current or preferred one.<a id="marker-139"/></p>
    </li>
  </ul>
</body></html>