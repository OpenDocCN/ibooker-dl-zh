["```py\nimport torch\n\nX = get_data()                                      ①\n\nX_mean = X.mean(axis=0)                             ②\n\nX = X - X_mean                                      ③\n\nU, S, Vh = torch.linalg.svd(X, full_matrices=False) ④\n\nV = Vh.T                                            ⑤\n\nV_trimmed =  V[:, 0: 2]                             ⑥\n\nX_proj = torch.matmul(X, V_trimmed)                 ⑦\n\nX_proj = torch.cat([X_proj,                         ⑧\n              torch.zeros((X_proj.shape[0], 1))], axis=1)\n\nX_recon = torch.matmul(X_proj, Vh)                  ⑨\n\nX_recon = X_recon + X_mean                          ⑩\n```", "```py\nfrom torch import nn\nnz = 10\ninput_image_size = (1, 32, 32)            ①\nconv_encoder = nn.Sequential(\n            nn.Conv2d(in_channels, 32, kernel_size=3, stride=1, padding=1),\n            nn.BatchNorm2d(32),\n            nn.ReLU(),\n            nn.MaxPool2d(kernel_size=2),  ②\n            nn.Conv2d(32, 128, kernel_size=3, stride=1, padding=1),\n            nn.BatchNorm2d(128),\n            nn.ReLU(),\n            nn.MaxPool2d(kernel_size=2),  ③\n            nn.Conv2d(128, 256, kernel_size=3, stride=1, padding=1),\n            nn.BatchNorm2d(256),\n            nn.ReLU(),\n            nn.MaxPool2d(kernel_size=2),  ④\n\n            nn.Flatten()                  ⑤\n        )\nfc = nn.Linear(4096, nz)                  ⑥\n```", "```py\nfrom torch import nn\ndecoder = nn.Sequential(\n            nn.ConvTranspose2d(self.nz, out_channels=256,\n             kernel_size=4, stride=1,\n             padding=0, bias=False),            ①\n\n            nn.BatchNorm2d(256),\n            nn.ReLU(True),\n            nn.ConvTranspose2d(256, 128, kernel_size=2,\n              stride=2, padding=0, bias=False), ②\n            nn.BatchNorm2d(128),\n            nn.ReLU(True),\n            nn.ConvTranspose2d(128, 32, kernel_size=2,\n              stride=2, padding=0, bias=False), ③\n            nn.BatchNorm2d(32),\n            nn.ReLU(True),\n            nn.ConvTranspose2d(32, in_channels, kernel_size=2,\n              stride=2, padding=0, bias=False), ④\n            nn.Sigmoid()\n        )\n```", "```py\nfrom torch import nn\nfrom torch.nn import functional as F\n\nconv_out = conv_encoder(X)     ①\n\nz =  fc(conv_out)              ②\nXr = decoder(z)                ③\n\nrecon_loss = F.mse_loss(Xr, X) ④\n```", "```py\ndef reparameterize(mu, log_var):\n        std = torch.exp(0.5 * log_var) ①\n\n        eps = torch.randn_like(std)    ②\n\n        return mu + eps * std          ③\n```", "```py\nfrom torch import nn\nnz = 10\ninput_image_size = (1, 32, 32)            ①\nconv_encoder = nn.Sequential(\n            nn.Conv2d(in_channels, 32, kernel_size=3, stride=1, padding=1),\n            nn.BatchNorm2d(32),\n            nn.ReLU(),\n            nn.MaxPool2d(kernel_size=2),  ②\n            nn.Conv2d(32, 128, kernel_size=3, stride=1, padding=1),\n            nn.BatchNorm2d(128),\n            nn.ReLU(),\n            nn.MaxPool2d(kernel_size=2),  ③\n            nn.Conv2d(128, 256, kernel_size=3, stride=1, padding=1),\n            nn.BatchNorm2d(256),\n            nn.ReLU(),\n            nn.MaxPool2d(kernel_size=2),  ④\n\n            nn.Flatten()                  ⑤\n        )\nmu_fc = nn.Linear(4096, nz)               ⑥\nlogvar_fc = nn.Linear(4096, nz)           ⑦\n```", "```py\nfrom torch import nn\ndecoder = nn.Sequential(\n            nn.ConvTranspose2d(self.nz, out_channels=256,\n             kernel_size=4, stride=1,\n             padding=0, bias=False),            ①\n            nn.BatchNorm2d(256),\n            nn.ReLU(True),\n            nn.ConvTranspose2d(256, 128, kernel_size=2,\n              stride=2, padding=0, bias=False), ②\n            nn.BatchNorm2d(128),\n            nn.ReLU(True),\n            nn.ConvTranspose2d(128, 32, kernel_size=2,\n              stride=2, padding=0, bias=False), ③\n            nn.BatchNorm2d(32),\n            nn.ReLU(True),\n            nn.ConvTranspose2d(32, in_channels, kernel_size=2,\n              stride=2, padding=0, bias=False), ④\n            nn.Sigmoid()\n        )\n```", "```py\nrecon_loss = F.binary_cross_entropy(Xr, X,\n                     reduction=\"sum\")                     ①\n\nkld_loss = -0.5 * torch.sum(1 + log_var\n                             - mu.pow(2) - log_var.exp()) ②\n\ntotal_loss = recon_loss + beta * kld_loss                 ③\n```", "```py\nconv_out = conv_encoder(X)                ①\n\nmu = mu_fc(conv_out)                      ②\nlog_var = logvar_fc(conv_out)             ③\n\nz = reparameterize(mu, log_var)           ④\n\nXr = self.decoder(z)                      ⑤\n\ntotal_loss = recon_loss + beta * kld_loss ⑥\n```"]