<html><head></head><body>
<div id="sbo-rt-content"><div class="readable-text" id="p1">
<h1 class="readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">9</span> </span><span class="chapter-title-text">Searching and auditing</span></h1>
</div>
<div class="introduction-summary">
<h3 class="introduction-header"><span class="CharOverride-1">This chapter covers</span><span class="CharOverride-1"/></h3>
<ul>
<li class="readable-text" id="p2"><span class="CharOverride-2">Another iteration on our ACH dashboard</span></li>
<li class="readable-text" id="p3"><span class="CharOverride-2">Adding searching capabilities for ACH transactions</span></li>
<li class="readable-text" id="p4"><span class="CharOverride-2">Auditing of user actions</span></li>
</ul>
</div>
<div class="readable-text" id="p5">
<p>In previous chapters, we built the minimum viable product (MVP) and went through an iteration where we received feedback and used it to drive the next set of enhancements. This chapter continues using the same concepts. With the release of expanded support for exceptions and various UI/UX tweaks, we should expect feedback on those features and other functionality that users need.</p>
</div>
<div class="readable-text intended-text" id="p6">
<p>Users would like to be able to search for transactions based on several criteria as they need to handle customer complaints about when a transaction was processed. In addition, other stakeholders have asked for the ability to audit interactions with the dashboard to gauge customer engagement and set up user tracking in the future. </p>
</div>
<div class="readable-text" id="p7">
<h2 class="readable-text-h2"><span class="num-string">9.1</span> Sprint planning</h2>
</div>
<div class="readable-text" id="p8">
<p>In the Agile world, the team needs to prepare for the sprint before starting any work. We already have an idea of what needs to be accomplished with this sprint but also have to define stories to know exactly what is expected in any given story and identify any acceptance criteria that may go along with it. We continue to follow the standard format for our stories: <code>As</code> <code>a</code> <code>[role],</code> <code>I</code> <code>[want</code> <code>to],</code> <code>[so</code> <code>that]</code>. For instance, to add search capabilities to our product, we may have something similar to <code>As</code> <code>a</code> <code>user,</code> <code>I</code> <code>want</code> <code>to</code> <code>be</code> <code>able</code> <code>to</code> <code>search</code> <code>for</code> <code>transactions,</code> <code>so</code> <code>that</code> <code>I</code> <code>can</code> <code>better</code> <code>research</code> <code>customer inquiries</code> <code>about</code> <code>their</code> <code>transactions</code>. Feel free to practice the phrasing for the additional user stories (even if it is just in your head) for the remaining tasks we cover in this chapter.</p>
</div>
<div class="readable-text intended-text" id="p9">
<p>We take a moment to visualize the changes using another Gantt chart. Again, the chart presents a timeline of our changes, which can be shown to any stakeholders interested in the project. In our experience, this is one of the most effective means of communicating to stakeholders when the project is going to be complete. Often, stakeholders outside our team are not familiar with more Agile ways of tracking progress and just want to know when our code will be available. A simple Gantt chart gives them an idea of how the work should be progressing. The following listing shows the Gantt chart definition in PlantUML.</p>
</div>
<div class="browsable-container listing-container" id="p10">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.1<span class="CharOverride-3"> </span>PlantUML Gantt chart definition</h5>
<div class="code-area-container">
<pre class="code-area">@startgantt    #1
saturday are closed  #2
sunday are closed    

header ACH Dashboard Enhancements - Round 2  #3

Project starts 2024-08-15
-- Searching Enhancement --    #4
[Search API Design] starts 2024-08-15 and lasts 2 days   #5
[UI Design/Changes] starts at \   #5
            [Search API Design]'s end and lasts 4 days   #5

-- Auditing Enhancement -- #5
[Database Design] starts at 2024-08-15 and lasts 2 days #5
[Review APIs] starts at [Database Design]'s #5
<span class="CharOverride-5">➥</span> end and lasts 1 days #5
[Add Auditing logic] starts at [Review APIs]'s end #5
<span class="CharOverride-5">➥</span> and lasts 3 days #5
[UI Support for Auditing] starts at \   #5
            [Add Auditing logic]'s end and lasts 3 days  #5

[Sprint Complete] happens at 2024-08-28   #6

@endgantt  #7</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Begins the Gantt </span>
<span class="CharOverride-4">chart definition</span>
<br/>#2 
     <span class="CharOverride-4">Defines days that should be skipped</span>
<br/>#3 
     <span class="CharOverride-4">Title for our chart</span>
<br/>#4 
     <span class="CharOverride-4">Defines timeline </span>
<span class="CharOverride-4">for searching enhancements; note that long lines can be split into multiple lines using the backslash character. Any trailing space after the backslash can cause parsing errors.</span>
<br/>#5 
     <span class="CharOverride-4">Defines timeline for auditing enhancements</span>
<br/>#6 
     <span class="CharOverride-4">Defines a milestone</span>
<br/>#7 
     <span class="CharOverride-4">Ends the Gantt </span>
<span class="CharOverride-4">chart definition</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p11">
<p>Figure 9.1 shows the generated Gantt chart. Not only does it provide a roadmap for where we are in the development process, but creating the chart helps us start thinking about the steps and requirements for any given enhancement.</p>
</div>
<div class="browsable-container figure-container" id="p12">
<img alt="A screenshot of a calendar  Description automatically generated" height="429" src="../Images/CH09_F01_Kardell.png" style="width: 100%; max-width: max-content;" width="457"/>
<h5 class="figure-container-h5">Figure 9.1 Gantt chart showing timeframes</h5>
</div>
<div class="readable-text" id="p13">
<p>We should now have an idea of the steps we need to take for the various enhancements and can get straight to work.</p>
</div>
<div class="readable-text" id="p14">
<h2 class="readable-text-h2"><span class="num-string">9.2</span> Searching ACH transactions</h2>
</div>
<div class="readable-text" id="p15">
<p>Which file contained that transaction? When was that transaction loaded? These are the types of questions we want to be able to answer with this enhancement. Throughout this book, we have focused on Prearranged Payment and Deposit (PPD) batches, which contain payments for payroll, utilities, and mortgage payments, among the rest. If a customer’s utility payment is not processed correctly, and their water/electricity gets turned off, we can be sure we are going to hear about it. Of course, that is an extreme case. It is more likely that the customer has been alerted by a particular company that their payment was not received, and they have to pay late fees. Either way, the customer will not be too happy when they call. </p>
</div>
<div class="readable-text intended-text" id="p16">
<p>We need to look at adding the ability to search our loaded files for both names and amounts. This feature will require changes to the UI as we will need to be able to enter search information and a new API to support the actual search and returning of results. Our immediate concern is the ability to find transactions within our limited dataset. In practice, ACH records should be kept for six years from the date of the receipt, and with billions of payments moving through the ACH network every year, chances are we will have sizeable datasets to search. We need to evaluate other mechanisms for searching, in addition to our real-time method before this project is ready for production. </p>
</div>
<div class="readable-text" id="p17">
<h3 class="readable-text-h3"><span class="num-string">9.2.1</span> BDD testing for searching</h3>
</div>
<div class="readable-text" id="p18">
<p>Before putting together a feature to help validate the new (yet to be written) search API, we first must create a file we can use with our feature. We can use our existing file creation feature (ach_file_creation.feature) and add a new scenario to create a file for a specific user with a known amount. While we could search within one of the existing files, it is likely cleaner to keep the files associated with features separated so that our tests will remain more robust. The following listing shows creating a file for customer Sally Saver, with a single dollar transaction, which should be more than enough to get us started.</p>
</div>
<div class="browsable-container listing-container" id="p19">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.2<span class="CharOverride-3"> </span>Creating a file for Sally Saver</h5>
<div class="code-area-container">
<pre class="code-area">Scenario: Create an ACH file with a single transaction
<span class="CharOverride-5">➥</span> for customer "Sally Saver"
   Given I want to create an ACH file named "sally_saver.ach"
   And I want to have an immediate destination of "990000013"
   And I want to have an immediate origin of "987654321"
   And I want to have 1 batch with ACH credits only and
<span class="CharOverride-5">➥</span> a standard entry class code of "PPD"
   And I want 1 entries per batch with random amounts between 100 and 100
   And I want to use individual names of "Sally Saver"
   And I want to have company name "My Company" and company id "1234567890"
   When my ACH is created
   Then I should have a file of the same name
   And there should be 1 batch in the file
   And there should be 1 entries in the file</pre>
</div>
</div>
<div class="readable-text" id="p20">
<p>With our file created, we can now work on setting up our BDD test to search for transactions. This should provide us with some insights into how we want the process to work in general. For instance, we know that we want to be able to search by at least the individual name and an amount. A couple of questions that should be up for discussion with various stakeholders in our project may be along the lines of</p>
</div>
<ul>
<li class="readable-text" id="p21">Are we going to separate these searches out on the API side (e.g., allowing query parameters of <code>customer</code> and <code>amount</code>)? Or will we allow one search field and have the backend try to query the correct field?</li>
<li class="readable-text" id="p22">Are fields mutually exclusive? If we are searching for a customer, can we also search for an account? </li>
<li class="readable-text" id="p23">If we allow searching using multiple fields, will these be combined using AND or OR? Should that be determined by the user?</li>
</ul>
<div class="readable-text" id="p24">
<p>Asking those questions (and the answers to them) will help guide our design process. For now, we will take the approach where a user will be shown a single search box that will support any searches we want to perform. We will also put the responsibility of deciding what the user wants to search for on the server side instead of on the UI. Another approach would be to have the UI split the fields and allow the API to accept different query parameters. With an approach to our search in mind, we can create a scenario to test our API search using a customer name.</p>
</div>
<div class="browsable-container listing-container" id="p25">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.3<span class="CharOverride-3"> </span>Search by individual name</h5>
<div class="code-area-container">
<pre class="code-area">Scenario: Search by individual name
   Given that I have a clean database
   And that I have posted the file "sally_saver.ach"
   When I search for transactions with search criteria "Sally Saver"
   Then I should receive a list of "1"
<span class="CharOverride-5">➥</span> transaction with the amount of "1.00"</pre>
</div>
</div>
<div class="readable-text" id="p26">
<p>There was a need to add new syntax for the <code>When</code> and <code>Then</code> clauses to support our transaction search. The code is shown in the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p27">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.4<span class="CharOverride-3"> </span>Updates to test_file_api.py</h5>
<div class="code-area-container">
<pre class="code-area">…
scenarios("../features/search_ach_transactions.feature") #1
…
@when(parsers.parse('I search for transactions #2
<span class="CharOverride-5">➥</span> with search criteria \"{search_criteria}\"')) 
def search_request_for_transactions(api_response, #3
<span class="CharOverride-5">➥</span> search_criteria):  #3
    response =  #3
 client.get(f"/api/v1/files/transactions/search?  #3
<span class="CharOverride-5">➥</span> criteria={search_criteria}")  #3
    <span>assert response.status_code == 200, response.text</span> #3
<span>    </span>api_response["response"] = response.json()  #3
…
@then(parsers.parse('I should receive a list of #4
<span class="CharOverride-5">➥</span> \"{transaction_count}\" transaction with the amount of #5
<span class="CharOverride-5">➥</span> \"{transaction_amount}\"')) 
def has_expected_transaction_and_amount(api_response, transaction_count, transaction_amount): #5
    assert len(api_response["response"]) == 1, f"Expected #5
{transaction_count} transaction, but got #5
<span class="CharOverride-5">➥</span> {len(api_response['response'])}"  #5
    response = api_response["response"][0]["amount"]  #5
    assert transaction_amount == response,  #5
<span class="CharOverride-5">➥</span> f"Expected {transaction_amount} in {response}"  #5</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Ensures the new scenario is loaded </span>
<br/>#2 
     <span class="CharOverride-4">Annotates the method with </span>
<span class="CharOverride-4">@when and parses the line</span>
<br/>#3 
     <span class="CharOverride-4">Defines a function to call our method and saves the response</span>
<br/>#4 
     <span class="CharOverride-4">Annotates the method with </span>
<span class="CharOverride-4">@then and parses the line</span>
<br/>#5 
     <span class="CharOverride-4">Defines a function to validate the results of the API response</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p28">
<p>Now that we have the supporting code behind the test, what should we expect to see if we were to run it? That’s right—a <code>404 error</code> will be returned! That is to be expected because we have not yet defined the endpoint. In the next section, we will address this problem by adding the API.</p>
</div>
<div class="readable-text" id="p29">
<h3 class="readable-text-h3"><span class="num-string">9.2.2</span> Search API</h3>
</div>
<div class="readable-text" id="p30">
<p>At this point, we want to have an API that takes some input from the user and then searches the database for a transaction. As previously mentioned, we are only going to search for individual names and amounts. We expect the API to be called with a single query parameter named <code>criteria</code>. The API will determine whether the argument is applicable to an individual name or an amount. </p>
</div>
<div class="readable-text intended-text" id="p31">
<p>This is not the only approach that we could have taken. We could also have split the search criteria into separate fields that would make the server side a bit easier but may have made searching more cumbersome from the user’s perspective. Another method would be to blend specifying search criteria with keywords (e.g., allowing for searches such as <code>individual</code> <code>name</code> <code>=</code> <code>"user"</code> <code>and</code> <code>amount</code> <code>=</code> <code>$1.00</code>). Then we would have more parsing to do to get the fields we want to use. Another consideration is whether we want to use <code>GET</code> or <code>POST</code>. As mentioned, our example uses <code>GET</code>, and we pass a query parameter, which is what we will be searching for. This approach works, but the URL with the query parameters may appear on the web server, firewall, application, and third-party logs. If we enable searching for potentially sensitive information, such as account and tax identification numbers, we may want to reconsider this approach since we do not want such sensitive information showing in logs. There is no wrong answer—depending on our audience and what we expect to be searching, we may be told to go with a specific approach.</p>
</div>
<div class="readable-text intended-text" id="p32">
<p>We first build a simple endpoint to work past the <code>404</code> <code>HTTP</code> status code being currently returned. The following listing shows the initial implementation of the endpoint.</p>
</div>
<div class="browsable-container listing-container" id="p33">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.5<span class="CharOverride-3"> </span>Initial endpoint definition for searches</h5>
<div class="code-area-container">
<pre class="code-area">@router.get(   #1
    path="/transactions/search",  #1
    response_model=list[str],  #1
    summary="Retrieve ACH Transactions",  #1
    description=  #1
      "Retrieve the transactions matching #1
<span class="CharOverride-5">➥</span> the specified criteria.",  #1
    response_description="ACH Transactions.", #1
    response_model_exclude_none=True, #1
    tags=["ACH Files"], #1
) #1
async def get_ach_transactions(criteria: str = Query(..., #2
  description="Search criteria for transactions")) #2
<span class="CharOverride-5">➥</span> -&gt; list[str]: 
    return [f"ACH Transactions for {criteria}"] #3</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Defines a GET request with supporting documentation</span>
<br/>#2 
     <span class="CharOverride-4">Defines the method specifying the query parameter</span>
<br/>#3 
     <span class="CharOverride-4">Returns a hardcoded array entry containing the query parameter</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p34">
<p>While this code may get us past the <code>404 error</code>, it does not do much to help us create a useful endpoint. For that, we need to build both the SQL queries and response objects to return the data. We start by creating a <code>TransactionSearchResponse</code> class to hold our data. The following listing shows the <code>TransactionSearchResponse</code> and the expected fields. If we find that we are missing something, we can always come back and add it.</p>
</div>
<div class="browsable-container listing-container" id="p35">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.6<span class="CharOverride-3"> </span>The <code>TransactionSearchResponse </code>class</h5>
<div class="code-area-container">
<pre class="code-area">from decimal import Decimal   #1
from typing import Annotated #1
from pydantic import BaseModel, Field, UUID4


class TransactionSearchResponse(BaseModel): #2
    file_id: UUID4 = Field( #3
        ..., description=  #3
<span class="CharOverride-5">➥</span>"Unique identifier for the ACH file.",  #3
        title="File ID"  #3
    )  #3
    batch_header_id: UUID4 = Field(  #3
        ...,  #3
        description=  #3
<span class="CharOverride-5">➥</span>"Unique identifier for the ACH Batch Header.",  #3
        title="Batch Header ID",  #3
    )  #3
    entry_id: UUID4 = Field(  #3
        ...,  #3
        description=  #3
<span class="CharOverride-5">➥</span>"Unique identifier for the ACH Entry Detail.",  #3
        title="Entry Detail ID",  #3
    )  #3
    filename: str = Field(  #3
        ..., description="The name of the ACH file.",   #3
        title="Filename", max_length=255 #3
    )  #3
    individual_name: str = Field(  #3
        ...,  #3
        description=  #3
<span class="CharOverride-5">➥</span>"The name of the individual or company for the entry.",  #3
        title="Individual Name",  #3
        max_length=22,  #3
    )  #3
    amount: Annotated[  #3
        Decimal,  #3
        Field(  #3
            ...,  #3
            description="The amount of the entry.",  #3
            title="Amount",  #3
            max_digits=10,  #3
            decimal_places=2,  #3
        ),  #3
    ]  #3
 #3
    class Config:  #3#4
        json_schema_extra = { 
            "example": { 
                <span>"file_id":  </span>
<span class="CharOverride-5">➥</span><span>"123e4567-e89b-12d3-a456-426614174000", </span>#5
<span>                </span>"record_type_5_id": 
<span class="CharOverride-5">➥</span> "123e4567-e89b-12d3-a456-426614174001", 
                "record_type_6_id":  
<span class="CharOverride-5">➥</span>"123e4567-e89b-12d3-a456-426614174002", 
                "filename": "test.ach", 
                "individual_name": "John Doe", 
                "amount": "100.00", 
            } 
        } </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Our standard import statements for Pydantic fields</span>
<br/>#2 
     <span class="CharOverride-4">Defines the class using the BaseModel from Pydantic as the base</span>
<br/>#3 
     <span class="CharOverride-4">Defines the various fields and constraints for our class</span>
<br/>#4 
     <span class="CharOverride-4">Provides an example of the response object for use with our documentation</span>
<br/>#5 
     <span class="CharOverride-4">Provides an example of the response object for use with our documentation</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p36">
<p>Now that we have a place to store our response, we need to populate it. We do this by using a new class called <code>TransactionSearchSql</code>, which will store any code dealing with transaction search. We wanted to keep things simple with our first search attempt, so we handle the following three scenarios:</p>
</div>
<ul>
<li class="readable-text" id="p37">Searching by a single amount</li>
<li class="readable-text" id="p38">Searching by an amount range</li>
<li class="readable-text" id="p39">Searching by an individual name</li>
</ul>
<div class="readable-text" id="p40">
<p>We created a method called <code>get_transactions</code>, as shown in the following listing. Here, we have two regular expressions to determine whether an amount was passed or a range of amounts was used. Otherwise, we default to using the name. For most people, the trickiest part of the code is likely to be the use of regular expressions. </p>
</div>
<div class="browsable-container listing-container" id="p41">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.7<span class="CharOverride-3"> </span>The <code>get_transaction</code> method</h5>
<div class="code-area-container">
<pre class="code-area">def get_transactions(self, criteria: str) -&gt; #1
   list[TransactionSearchResponse]: 
   amount_pattern = r"^\d+\.\d{2}$" #2
   multiple_amounts_pattern = #3
<span class="CharOverride-5">➥</span> r"(^\d+\.\d{2})\s+(\d+\.\d{2})$" 
   if re.match(amount_pattern, criteria): #4
      return self._get_transactions_using_amount(criteria) 
   elif match := re.match(multiple_amounts_pattern,  #5
<span class="CharOverride-5">➥</span> criteria): 
      begin_amount, end_amount = match.groups() #6
      return self._get_transactions_using_amount_range #7
<span class="CharOverride-5">➥</span>(begin_amount,<span class="CharOverride-5">➥</span> #8
 end_amount) 
   else: #8
      return self._get_transactions_using_<span class="CharOverride-5">➥</span> #9
<span class="CharOverride-5">➥</span>individual_name(criteria) </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Defines a function that returns a list of transactions</span>
<br/>#2 
     <span class="CharOverride-4">A pattern to match </span>
<span class="CharOverride-4">a single amount</span>
<br/>#3 
     <span class="CharOverride-4">A pattern to match two amounts</span>
<br/>#4 
     <span class="CharOverride-4">Checks the criteria against a single amount and calls the appropriate method</span>
<br/>#5 
     <span class="CharOverride-4">Uses the walrus operator to store the match results for the multiple_amounts_pattern</span>
<br/>#6 
     <span class="CharOverride-4">Retrieves the amounts using the groups() method from match</span>
<br/>#7 
     <span class="CharOverride-4">Calls the method with the retrieved arguments</span>
<br/>#8 
     <span class="CharOverride-4">Otherwise, no amounts matched, and we should use the individual name.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p42">
<p>Before moving on, let’s break down the regular expressions to ensure you understand their usage. Here are the important points:</p>
</div>
<ul>
<li class="readable-text" id="p43">Each pattern string is prefixed by <code>r</code> to denote a raw string, which prevents us from having to escape any strings. Otherwise, we would have to use <code>\\</code> instead of <code>\</code>.</li>
<li class="readable-text" id="p44">The characters <code>^</code> and <code>$</code> are input boundary assertions, indicating the start and end of the string, respectively. These help us eliminate matching strings that contain characters other than the pattern we are interested in.</li>
<li class="readable-text" id="p45">The <code>\d</code> matches any digit (0–9), and <code>+</code> is a quantifier that means to match one or more occurrences of the preceding atom (the most basic unit of a regular expression).</li>
<li class="readable-text" id="p46">The <code>\.</code> matches the literal period character because a single period will otherwise match any character.</li>
<li class="readable-text" id="p47">The <code>\d</code> matches any digit (0–9), and adding the <code>{2}</code> is another quantifier that specifies the count of atoms to match.</li>
<li class="readable-text" id="p48">The <code>\s</code> matches any whitespace. Again, we see the plus sign quantifier, which allows the two amounts to be separated by at least one character and up to any amount of whitespace.</li>
<li class="readable-text" id="p49">Wrapping a portion of the regular expression in parentheses creates a capture group. These groups can then be referenced later, as you’ll see when we use <code>match.groups()</code> to extract the found values.</li>
</ul>
<div class="readable-text" id="p50">
<p>Regular expressions are not limited to the financial industry, and you will find them throughout your career. While they can be difficult to grasp, generative AI tools are a great way to help break down regular expressions and provide more insight into them. Practice makes perfect, and to get more hands-on experience with regular expressions, you may want to check out <em>Regular Expression Puzzles and AI Coding Assistant</em>s (2023, Manning) by David Mertz.</p>
</div>
<div class="readable-text intended-text" id="p51">
<p>With that behind us, let’s take a look at the functions that are actually retrieving the transactions based on the search criteria provided. In our cases, the queries themselves remain much the same with only the <code>Where</code> clauses being unique for each query. The following listing shows the <code>_get_transactions_using_amount</code> function that looks for an exact amount and returns any results.</p>
</div>
<div class="browsable-container listing-container" id="p52">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.8<span class="CharOverride-3"> </span>Retrieving transactions by amount</h5>
<div class="code-area-container">
<pre class="code-area">    def _get_transactions_using_amount(
        self, criteria: str
    ) -&gt; list[TransactionSearchResponse]:
        with get_db_connection(
            row_factory=class_row(TransactionSearchResponse) #1
        ) as conn:
            sql = self.get_sql_selection_query() #2
            sql += "WHERE aepd.amount = %s" #3
            result = conn.execute(sql, [criteria]) #4
            return result.fetchall() #5</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">We declare that the row will be of type TransactionSearchResponse.</span>
<br/>#2 
     <span class="CharOverride-4">The standard columns that we are trying to select</span>
<br/>#3 
     <span class="CharOverride-4">Appends the Where clause for the query</span>
<br/>#4 
     <span class="CharOverride-4">Uses the criteria that we want to pass to the query</span>
<br/>#5 
     <span class="CharOverride-4">Gets all rows and returns the response</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p53">
<p>We have factored out the common portion of the SQL query into the <code>get_sql_selection_query</code> method, which allows the <code>Where</code> clause to be added to the query. When searching for transactions by amount, we used an exact match. When using a range of amounts, we employ the Postgres syntax and use the keyword <code>BETWEEN</code>. </p>
</div>
<div class="browsable-container listing-container" id="p54">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.9<span class="CharOverride-3"> </span>Using the <code>BETWEEN </code>keyword</h5>
<div class="code-area-container">
<pre class="code-area">sql += "WHERE aepd.amount BETWEEN %s AND %s" #1</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Uses BETWEEN to search between two amounts; often more concise and readable than multiple conditions</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p55">
<p>Similarly, when searching for an individual name, we use the <code>ILIKE</code> keyword, as shown in listing 9.10. Using <code>ILIKE</code> allows us to do a case-insensitive search—otherwise, we are searching for the same string. Note that ILIKE is a Postgres-specific command. Other databases such as MySQL use the <code>LIKE</code> keyword, but it is case-insensitive by default. Still, other databases such as Oracle are case-sensitive and require the <code>UPPER</code> function in the comparison to achieve a case-insensitive search. So, always be aware of the database you are using.</p>
</div>
<div class="readable-text intended-text" id="p56">
<p>We may consider appending a percentage sign (<code>%)</code> to the criteria, which is a SQL wildcard and would match the individual name if anything appeared after it. Or perhaps we could replace any spaces found in the string with the wildcard to expand our search results. Those are just some basic starting points if additional search capabilities are required.</p>
</div>
<div class="browsable-container listing-container" id="p57">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.10<span class="CharOverride-3"> </span>Case-insensitive search</h5>
<div class="code-area-container">
<pre class="code-area">sql += "WHERE aepd.individual_name ILIKE %s" #1</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Use ILIKE for a case-insensitive search of the individual name.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p58">
<p>The following listing shows the common portion of the query that retrieves the transaction information. In addition to the need of joining records together to drill down to transaction details, we rename the fields to ensure they can be stored in our response object.</p>
</div>
<div class="browsable-container listing-container" id="p59">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.11<span class="CharOverride-3"> </span>Common transaction query selection criteria</h5>
<div class="code-area-container">
<pre class="code-area">def get_sql_selection_query(self):
   return """
          SELECT art1.ach_files_id AS file_id, #1
                 art5.ach_records_type_5_id AS batch_header_id,  #2
                 art6.ach_records_type_6_id AS entry_id,   #2
                 af.file_name AS filename,   #2
                 aepd.individual_name AS individual_name,  #2
                 aepd.amount AS amount   #2
            FROM ach_files af #2
      INNER JOIN ach_records_type_1 art1 #2
<span class="CharOverride-5">➥</span> USING ( ach_files_id )  #2
      INNER JOIN ach_records_type_5 art5 #2
<span class="CharOverride-5">➥</span> USING ( ach_records_type_1_id )  #2
      INNER JOIN ach_records_type_6 art6 #2
<span class="CharOverride-5">➥</span> USING ( ach_records_type_5_id )  #2
      INNER JOIN ach_entry_ppd_details aepd #2
<span class="CharOverride-5">➥</span> USING ( ach_records_type_6_id )  #2
   """</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">The selection criteria required for our object. The fields are prefixed to help determine the files they belong to. It is not always necessary when the names are unique but is helpful for maintaining the code.</span>
<br/>#2 
     <span class="CharOverride-4">Joining of the </span>
<span class="CharOverride-4">various records</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p60">
<p>With the queries working and returning our data, we should now see that all our tests have passed. Next, we look at how to add the search capability to our UI.</p>
</div>
<div class="readable-text" id="p61">
<h3 class="readable-text-h3"><span class="num-string">9.2.3</span> UI search page</h3>
</div>
<div class="readable-text" id="p62">
<p>To add search functionality to our page, we start by adding an icon to our sidebar navigation. This means we can update NavButtons.tsx to add a new button with an icon.</p>
</div>
<div class="browsable-container listing-container" id="p63">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.12<span class="CharOverride-3"> </span>Updating NavButtons.tsx</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">…
import {CloudUpload, Logout, Error, <strong>Search</strong>} from "@mui/icons-material"; #1
…
            &lt;ListItemButton onClick={() =&gt; route.push("/search")}&gt;
                &lt;ListItemIcon&gt;
<strong>                    &lt;Search/&gt; </strong>#2
                &lt;/ListItemIcon&gt;
                &lt;ListItemText primary="Search"/&gt;
            &lt;/ListItemButton&gt;
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Imports the search icon</span>
<br/>#2 
     <span class="CharOverride-4">Includes the search icon</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p64">
<p>Of course, if we try clicking the button, we receive a <code>404</code> <code>NOT</code> <code>FOUND</code> error message because we have yet to define our actual page. As with previous pages, we will create a simple page that will allow us to resolve the <code>404</code> error message and give us a starting point for developing the rest of the page. The following listing shows the src/app/search/page.tsx.</p>
</div>
<div class="browsable-container listing-container" id="p65">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.13<span class="CharOverride-3"> </span>Search page stub</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">export default function SearchPage() { #1

    return (
        &lt;ThemeProvider theme={defaultTheme}&gt;
            &lt;Box sx={{display: 'flex'}}&gt;
                &lt;CssBaseline/&gt;
                &lt;StandardNavigation/&gt;
                &lt;Box
                    component="main"
                    sx={{
                        backgroundColor: (theme) =&gt;
                            theme.palette.mode === 'light'
                                ? theme.palette.grey[100]
                                : theme.palette.grey[900],
                        flexGrow: 1,
                        height: '100vh',
                        overflow: 'auto',
                    }}
                &gt;
                    &lt;Toolbar /&gt;
<strong>                    &lt;Typography&gt;Search Page&lt;/Typography&gt; </strong>#2
                &lt;/Box&gt;
            &lt;/Box&gt;
        &lt;/ThemeProvider&gt;
    );
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Creates a simple </span>
<span class="CharOverride-4">search page</span>
<br/>#2 
     <span class="CharOverride-4">Something to identify the page so we know we navigated to it</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p66">
<p>With our page stubbed out, we can click the search button, and we should see our navigation and search page. Now, we can add the components that will give us the necessary functionality to create a search page capable of displaying our results. The hardest part is deciding how to layout the page. From previous API calls (such as returning exceptions in chapter 8), we already know how to fetch data from an API and display it within a DataGrid component. We will be following the same steps of defining an object to hold the data, a component to display the data, and then adding that to our search page.</p>
</div>
<div class="readable-text intended-text" id="p67">
<p>We start by defining an interface <code>AchTransactionSearchResponse</code> to hold the data that the API response will pass back. The following listing shows the fields and their data types.</p>
</div>
<div class="browsable-container listing-container" id="p68">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.14<span class="CharOverride-3"> </span>The <code>AchTransactionSearchResponse </code>interface</h5>
<div class="code-area-container">
<pre class="code-area">export interface AchTransactionSearchResponse { #1
    file_id: string;  #2
    batch_header_id: string;  #2
    entry_id: string;  #2
    filename: string;  #2
    individual_name: string;  #2
    amount: string;  #2
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Exports the AchTransactionSearchResponse so that it is available everywhere</span>
<br/>#2 
     <span class="CharOverride-4">The fields returned from the API</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p69">
<p>Once we have a place to hold the retrieved data, we can create a component that will display the data. This <code>AchTransactionSearchResults</code> component will be similar to other components we have created, where we pass the results of our API call into the component via the results object of <code>AchTransactionSearchResultsProps</code>. We utilize the <code>renderCell</code> property on the column definitions to add links that allow users to jump directly to the file or batch of a particular search result. Furthermore, since our results did not have an ID column, we have to define one to the DataGrid component using the <code>getRowId</code> property. The <code>entry_id</code> can act as our ID column because for each result, the <code>entry_id</code> is the UUID for the transaction, and that is unique. The following listing shows the more important parts of the component.</p>
</div>
<div class="browsable-container listing-container" id="p70">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.15<span class="CharOverride-3"> </span>The <code>AchTransactionSearchResults </code>component</h5>
<div class="code-area-container">
<pre class="code-area">interface AchTransactionSearchResultsProps {
    results: AchTransactionSearchResponse[];
}

export default function AchTransactionSearchResults #1
<span class="CharOverride-5">➥</span>({results}:  #1
Readonly&lt;AchTransactionSearchResultsProps&gt;) {  #1

    const route = useRouter(); #2

    const columns: GridColDef[] = [
        {field: 'filename', headerName: 'Filename', #3
<span class="CharOverride-5">➥</span> width: 150}, 
        …
        {field: 'viewFile', headerName: '',  #4
                 sortable: false, width: 150,   #4
                 renderCell: (params) =&gt; (   #4
            &lt;Link onClick={() =&gt;  #4
                route.push(`/fileDetails/${params.row.file_id}`)}  #4
                sx={{ cursor: 'pointer' }}&gt;Jump to file...&lt;/Link&gt;  #4
            )},  #4
        {field: 'viewBatch', headerName: '', #5#6
                 sortable: false, width: 150,   #6
                 renderCell: (params) =&gt; (  #6
            &lt;Link onClick={() =&gt;   #6
route.push(`/fileDetails/${params.row.file_id}/   #6
<span class="CharOverride-5">➥</span>batchDetails/${params.row.batch_header_id}`)}   #6
              sx={{ cursor: 'pointer' }}&gt;Jump to batch...&lt;/Link&gt;  #6
            )}  #6
    ];

    return (
…
       &lt;DataGrid columns={columns} 
                 rows={results} 
                 getRowId={(row) =&gt; row.entry_id} #7
       /&gt;
…
    );
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Exports the search results function and declares the parameters read only</span>
<br/>#2 
     <span class="CharOverride-4">Uses the router for navigation purposes</span>
<br/>#3 
     <span class="CharOverride-4">Begins defining columns to show</span>
<br/>#4 
     <span class="CharOverride-4">Defines a column that will create a link, which will navigate to the file details page when clicked </span>
<br/>#5 
     <span class="CharOverride-4"> </span>
<span class="CharOverride-4">Defines a column that will create a link, which will navigate to the batch details page when clicked</span>
<br/>#6 
     <span class="CharOverride-4"> </span>
<br/>#7 
     <span class="CharOverride-4">Since there is no specific parameter named id, we specify which field can be used.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p71">
<p>Now that we have a place to store the data and a way to present them, all that is left is to make the API call and pass it to our component. For that, we updated our search page to have a text input field and a search button to make the actual API call. We use the <code>onChange</code> event of the <code>TextField</code> to store the text entered by the user into the <code>searchCriteria</code> field. When the user clicks the search button, the <code>onClick</code> event is fired, and the <code>handleSearch</code> is executed. The <code>handleSearch</code> makes a call to our API and stores the result. The important pieces of the updated search page are shown in the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p72">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.16<span class="CharOverride-3"> </span>Updated search page</h5>
<div class="code-area-container">
<pre class="code-area">…
export default function SearchPage() {
    const [searchCriteria, setSearchCriteria] = #1
<span class="CharOverride-5">➥</span> useState&lt;string&gt;(''); 
    const [results, setResults] = #2
useState&lt;AchTransactionSearchResponse[]&gt;([]); 

    const handleChange = (event: { target: { value: #3
React.SetStateAction&lt;string&gt;; }; }) =&gt; {  #3
        setSearchCriteria(event.target.value);  #3
    };  #3

    const handleSearch = async () =&gt; { #4
        …        axios.get&lt;AchTransactionSearchResponse[]&gt; #5
<span class="CharOverride-5">➥</span>(`${apiUrl}/files/transactions/search?criteria=${searchCriteria}`, { 
…
    return (
…
       &lt;Box sx={{display: 'flex', 
                 flexDirection: 'column', 
                 alignItems: 'center', gap: 2}}&gt;
          &lt;TextField id="search" #6
                     label="Search"  #6
                     variant="standard"   #6
                     onChange={handleChange}   #6
                     sx={{ width: '40%' }} /&gt;  #6
          &lt;Button variant="outlined" #7
                  color="primary" onClick={handleSearch}&gt;  #7
             Search #7
          &lt;/Button&gt; 
       &lt;/Box&gt;
       &lt;AchTransactionSearchResults results={results}/&gt; #8
…
    );
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Initializes the searchCriteria to an empty string</span>
<br/>#2 
     <span class="CharOverride-4">Initializes the results to an empty string</span>
<br/>#3 
     <span class="CharOverride-4">The handleChange function saves the entered text to be used later.</span>
<br/>#4 
     <span class="CharOverride-4">The handleSearch function calls the API and saves the results using setResults.</span>
<br/>#5 
     <span class="CharOverride-4">Uses axios to get the response</span>
<br/>#6 
     <span class="CharOverride-4">Defines a TextField element for a user to enter a search string</span>
<br/>#7 
     <span class="CharOverride-4">Defines a button element that will search for the entered string</span>
<br/>#8 
     <span class="CharOverride-4">A component that takes the results to display them</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p73">
<p>We now have a search page that can perform basic transaction searches and provides the ability to jump directly to the file or batch where the transactions were found. Next, we reinforce testing with Playwright to get some integration-level tests for our search capabilities.</p>
</div>
<div class="readable-text" id="p74">
<h3 class="readable-text-h3"><span class="num-string">9.2.4</span> Integration testing with Playwright</h3>
</div>
<div class="readable-text" id="p75">
<p>After we make searching for our transaction possible, it would be nice to add an integration test that we can use for integration and regression testing. We set up a test that requires us to</p>
</div>
<ol>
<li class="readable-text" id="p76">Upload a file to parse</li>
<li class="readable-text" id="p77">Navigate to the search page</li>
<li class="readable-text" id="p78">Populate the search page</li>
<li class="readable-text" id="p79">Wait for an ACH response</li>
<li class="readable-text" id="p80">Validate the result is populated</li>
<li class="readable-text" id="p81">Take a screenshot</li>
</ol>
<div class="readable-text" id="p82">
<p>We created a Python script named test_search_page.py to perform all these necessary steps. In addition, we want to have the option to debug our test with the browser window displayed; to accomplish that, we need to create a few Pytest fixtures.</p>
</div>
<div class="browsable-container listing-container" id="p83">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.17<span class="CharOverride-3"> </span>Pytest fixtures for Playwright</h5>
<div class="code-area-container">
<pre class="code-area">@pytest.fixture(scope="session") #1
def browser(): #2
    with sync_playwright() as p:  #3
        browser = p.chromium.launch(headless=False) 
        yield browser #3
        browser.close() #4

#5
<span>@pytest.fixture(scope="function") </span>
<span>def page(browser): </span>#6
<span>    </span><span>context = browser.new_context() </span> #7
<span>    pages = context.pages</span>
<span>    page = pages[0] if pages else context.new_page() </span>#7
<span>    </span>yield page #8
    context.close() #9</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Defines a fixture with the scope session, which will cause the fixture to persist for the length of the test session</span>
<br/>#2 
     <span class="CharOverride-4">Defines a function named browser that creates a browser instance. We use headless=False to step through the test session and see what the browser is doing. Using headless=True </span>
<span class="CharOverride-4">will hide the browser window and is the </span>
<span class="CharOverride-4">default way of running unit tests.</span>
<br/>#3 
     <span class="CharOverride-4">The yield browser command will return the browser object.</span>
<br/>#4 
     <span class="CharOverride-4">When all tests are finished, </span>
<span class="CharOverride-4">the browser is closed.</span>
<br/>#5 
     <span class="CharOverride-4">Defines a fixture with the scope of function, which is the default scope</span>
<br/>#6 
     <span class="CharOverride-4">Creates a page that will be used with the test</span>
<br/>#7 
     <span class="CharOverride-4">Uses the default tab </span>
<span class="CharOverride-4">if it exists; otherwise, creates a new one</span>
<br/>#8 
     <span class="CharOverride-4">Returns the page using yield, so it is available to the test</span>
<br/>#9 
     <span class="CharOverride-4">Clears the context </span>
<span class="CharOverride-4">after the test is run</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p84">
<p>That is enough to get the Playwright structure set up. Now, we want to ensure our database is empty and that we load our ACH file before starting our integration test.</p>
</div>
<div class="browsable-container listing-container" id="p85">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.18<span class="CharOverride-3"> </span>Clearing the database and loading our file</h5>
<div class="code-area-container">
<pre class="code-area">@pytest.fixture(autouse=True) #1
def setup_teardown_method():
    SqlUtils.truncate_all() #2

    ach_file = "./data/sally_saver.ach" #3
    file_path = get_absolute_path("./data/sally_saver.ach")  #3
    parser = AchFileProcessor()  #3
    ach_files_id = SqlUtils.create_ach_file_record #3
<span class="CharOverride-5">➥</span>(ach_file, str(randint(1, 99999999)))  #3
    parser.parse(ach_files_id, file_path)  #3
    yield #3

def get_absolute_path(relative_path): #4
    return current_file_dir / relative_path</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Define a fixture with autouse set to True. This causes it to be included for every test by default.</span>
<br/>#2 
     <span class="CharOverride-4">Clears our database</span>
<br/>#3 
     <span class="CharOverride-4">Loads a file for the test into the database</span>
<br/>#4 
     <span class="CharOverride-4">Ensures the path is correct based on where we are running from</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p86">
<p>Now that the setup is done, we can start the actual testing with Playwright.</p>
</div>
<div class="browsable-container listing-container" id="p87">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.19<span class="CharOverride-3"> </span>Playwright testing</h5>
<div class="code-area-container">
<pre class="code-area">def test_dashboard(page: Page):
    page.goto("http://localhost:3000/search") #1
    page.expect_navigation(wait_until="load") 
    expect(page).to_have_url("http://localhost:3000/search") #2
    search_criteria = page.get_by_role("textbox") #3
    search_criteria.fill("sally saver") 
    search_button = page.locator("#searchbtn") #4
    with page.expect_response("**/files/transactions/search*") #5
<span class="CharOverride-5">➥</span> as response_info:  #6
        search_button.click() 

    response = response_info.value #6
    assert response.status == 200
    search_result = page.locator('div[title="Sally Saver"]') #7
    expect(search_result).to_be_visible() 
    page.screenshot(path="screenshots/search_results.png") #8</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Navigates to the search screen and ensures the page is loaded</span>
<br/>#2 
     <span class="CharOverride-4">Validates that we are on the correct page</span>
<br/>#3 
     <span class="CharOverride-4">Finds the textbox and </span>
<span class="CharOverride-4">enters the text “sally saver”</span>
<br/>#4 
     <span class="CharOverride-4">Finds the search button</span>
<br/>#5 
     <span class="CharOverride-4">Expects an API response from the search button when it is clicked</span>
<br/>#6 
     <span class="CharOverride-4">Checks that the response was 200</span>
<br/>#7 
     <span class="CharOverride-4">We should be able to see an entry with the text “Sally Saver.”</span>
<br/>#8 
     <span class="CharOverride-4">Takes a screenshot </span>
<span class="CharOverride-4">for posterity</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p88">
<p>Now you know how to perform some integration testing where you may need to make API calls and validate the results. In the next section, we look at another critical aspect of development in many industries: keeping an audit trail.</p>
</div>
<div class="readable-text" id="p89">
<h2 class="readable-text-h2"><span class="num-string">9.3</span> Auditing user interactions</h2>
</div>
<div class="readable-text" id="p90">
<p>One of the critical security controls put forth by The Center for Internet Security is that of audit log management (<a href="https://mng.bz/gaGE"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/mng.bz/gaGE</span></a>). While we won’t be covering all the aspects, we will at least begin the journey by ensuring that we are collecting data about the usage of our application. Keep in mind that collecting data is the first step. If we do not have a strategy to monitor, review, and receive alerts as necessary, the logs are useless.</p>
</div>
<div class="readable-text intended-text" id="p91">
<p>Many times, we have worked on a problem where we were put on the wrong path initially because someone had identified an error occurring in a log. Further research showed that the error had been occurring for many months (as far back as logs were readily available) and was not the source of the current problem. Sometimes, in the heat of a production incident, you can easily fall into that type of trap because of the need to resolve the problem quickly. With proper audit log management, you can gain a better understanding of the baseline application behavior and monitor for application misuse, among many other benefits.</p>
</div>
<div class="readable-text intended-text" id="p92">
<p>While there are many commercial off-the-shelf tools (COTS) such as Splunk, Dynatrace, DataDog, and Sentry that help with logging and observability, we focus primarily on logging our data into the database and growing from there if necessary. </p>
</div>
<div class="readable-text" id="p93">
<h3 class="readable-text-h3"><span class="num-string">9.3.1</span> Database design</h3>
</div>
<div class="readable-text" id="p94">
<p>If we want to get started with auditing, we need to create a new database table to store our data. It will be based on the needs of your application and on what you are trying to accomplish. In our case, we are going to keep track of the API requests coming into the system. We introduce a new data type for dealing with hosts and networks—the <code>INET</code> data type for the <code>ip_address</code> field. While using a string data type for <code>ip_address</code> would certainly work as well, there are additional comparisons and functions in Postgres for dealing with <code>INET</code> that can make life easier. For instance, we could search for all addresses in a given range by using <code>WHERE ip_address</code> <code>&lt;&lt;</code> <code>'192.168.1.0/24'</code>. This search may be helpful if we wanted to see activity coming from a list of addresses that we suspect of abusing our application. The following listing shows the creation of the table.</p>
</div>
<div class="browsable-container listing-container" id="p95">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.20<span class="CharOverride-3"> </span>The <code>audit_log</code> table</h5>
<div class="code-area-container">
<pre class="code-area">CREATE TABLE audit_log ( #1
    audit_log_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    created_at TIMESTAMP NOT NULL DEFAULT NOW(), #2
    user_id VARCHAR(25) DEFAULT NULL,
    ip_address INET DEFAULT NULL, #3
    <span>user_agent VARCHAR(255) DEFAULT NULL,</span>
<span>    http_request VARCHAR(10) DEFAULT NULL,</span>
<span>    </span>url VARCHAR(255) DEFAULT NULL,
    message TEXT NOT NULL
);</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Creates a table named audit_log</span>
<br/>#2 
     <span class="CharOverride-4">Saves when the record has been created using a TIMESTAMP datatype. We also use NOT NULL so that the field must always be populated. Finally, we default to using the NOW() function in Postgres, which will populate the field with the current date/time when records are inserted without a value.</span>
<br/>#3 
     <span class="CharOverride-4">Creates a field named ip_address with the INET data type, which is a handy type </span>
<span class="CharOverride-4">for network addresses</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p96">
<p>With the table in place, we can create the code necessary to write these audit records out.</p>
</div>
<div class="readable-text" id="p97">
<h3 class="readable-text-h3"><span class="num-string">9.3.2</span> TDD testing for auditing</h3>
</div>
<div class="readable-text" id="p98">
<p>We create the unit tests for our API first and then add the required code to make our tests pass. Should we also consider the BDD-style testing? The answer to that depends on how the business will choose to use the audit log. If the log will serve primarily as something that developers use, then the business will likely not need to work with us to develop tests. In contrast, if the business plans to use the audit log to pull the activity to help determine metrics, we may need to work with them to develop tests. We could easily see the business making that type of request and the need to update our tests to read something along the lines of <code>WHEN</code> <code>I</code> <code>REQUEST</code> <code>A</code> <code>LIST</code> <code>OF</code> <code>FILES</code> <code>THEN</code> <code>I</code> <code>SHOULD</code> <code>SEE AN</code> <code>AUDIT</code> <code>LOG</code> <code>RECORD</code> <code>INDICATING</code> <code>FILES</code> <code>WERE</code> <code>SHOWN</code>. For now, we will stick with our standard unit testing. The unit test defines a record and then retrieves it so that we can compare the fields. We currently have a field for <code>user_id</code>, but since we are not tracking users at the moment, we will leave it empty.</p>
</div>
<div class="browsable-container listing-container" id="p99">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.21<span class="CharOverride-3"> </span>Unit test for the audit log</h5>
<div class="code-area-container">
<pre class="code-area">class TestAuditLog:
    @pytest.fixture(autouse=True) #1
    def setup_teardown_method(self):  #1
        SqlUtils.truncate_all()  #1
        yield #1

    def test_insert_record(self): 
        log_record = AuditLogRecord( #2
            ip_address="192.168.1.0/24",  #2
            user_agent="Mozilla/5.0",  #2
            http_request="GET",  #2
            http_response=200,  #2
            url="/api/v1/files",  #2
            message="Test audit log insert",  #2
        )  #2
        logger = AuditLog() #3
        audit_record_id = logger.log_record(log_record)  #3
        retrieved_record =   #3
<span class="CharOverride-5">➥</span>logger.get_log_record(audit_record_id)  #3
        excluded_fields = {"audit_log_id", "created_at"} #4
        assert SqlUtils.get_row_count_of_1("audit_log") is True
<span class="CharOverride-5">➥</span>, "Expected 1 record" 
        assert retrieved_record.dict(exclude=excluded_fields) 
<span class="CharOverride-5">➥</span> == #D
     log_record.dict( 
            exclude=excluded_fields
        ), f"Expected {log_record}, 
<span class="CharOverride-5">➥</span> but got {retrieved_record}" </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Clears the database each time</span>
<br/>#2 
     <span class="CharOverride-4">Creates a dummy record</span>
<br/>#3 
     <span class="CharOverride-4">Uses the AuditLog class to create and retrieve a record</span>
<br/>#4 
     <span class="CharOverride-4">Excludes the specified fields from the dictionary as these are populated by the database and do not affect the comparison; then asserts the record match</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p100">
<p>The unit test requires an object for <code>AuditLogRecord</code>, which is a standard Pydantic model to hold our data. We use two new data types in this model—<code>IPvAnyNetwork</code> and <code>AnyUrl</code> (both available as imports from Pydantic). The <code>IPvAnyNetwork</code> works well for representing the <code>INET</code> field we defined in the table and provides validation as expected for IP addresses, regardless of whether they are defined as a single address (e.g., <code>127.0.0.1</code>) or a range of them (e.g., <code>192.168.1.0/24</code>). Of course, we would not expect to see a range of addresses in this field for an audit record. The <code>AnyUrl</code> field similarly provides validation of URLs, saving us from having to write regular expressions to validate the field. Listing 9.22 shows our <code>AuditLogRecord</code> class, with some less interesting fields removed for brevity.</p>
</div>
<div class="browsable-container listing-container" id="p101">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.22<span class="CharOverride-3"> </span>The <code>AuditLogRecord</code> class</h5>
<div class="code-area-container">
<pre class="code-area">class AuditLogRecord(BaseModel):
…
    ip_address: Optional[IPvAnyNetwork] = Field( #1
        None,
        title="IP Address",
        description="IP address from which the request originated.",
    )
…
    url: Optional[AnyUrl] = Field( #2
        None, 
        title="URL", 
        description="URL accessed by the request.", max_length=255
    )
…
    @field_validator("url", mode="before") #3
    @classmethod #3
    def convert_url_to_str(cls, v: AnyUrl) -&gt; str:  #3
        return str(v) </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Defines the ip_address as a type of IPvAnyNetwork, which allows Pydantic to validate IP addresses and networks </span>
<br/>#2 
     <span class="CharOverride-4">Defines the URL as a type of AnyUrl, which allows Pydantic to validate whether the URL is properly formatted </span>
<br/>#3 
     <span class="CharOverride-4">Defines a field validator so that the URL is converted to a string to be stored in the database</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p102">
<p>As shown in listing 9.22, we also use a field validator to return the URL field as a string. This is because we will receive an error when attempting to insert it into the database because the URL datatype is not compatible with a string. We could have explicitly coded for it in the audit log class responsible for inserting the record, but this approach wraps up everything nicely, and other developers do not have to worry about it, which helps reduce cognitive load.</p>
</div>
<div class="readable-text intended-text" id="p103">
<p>The final step of being able to write records and get this unit test to pass is generating an actual class to be inserted into the database. In the following listing, we create an <code>AuditLog</code> class that contains a <code>log_record</code> and <code>get_log_record</code> methods. For other database records, we specifically used <code>Sql</code> as part of the name. In this case, we did not necessarily want to tie it to a database.</p>
</div>
<div class="browsable-container listing-container" id="p104">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.23<span class="CharOverride-3"> </span>The <code>AuditLog </code>class</h5>
<div class="code-area-container">
<pre class="code-area">class AuditLog:
    @staticmethod
    def log_record(log_record: AuditLogRecord):
        with get_db_connection(row_factory=dict_row) as conn: #1
            log_record_dict = log_record.dict()  #1
            log_record_dict["url"] = str(log_record_dict["url"]) 
            result = conn.execute( #2
                """  #2
           INSERT INTO audit_log (user_id, ip_address,  #2
                       <span>user_agent, http_request, http_response, </span> #2
<span>                       </span>url, message)  #2
           VALUES (%(user_id)s,  #2
                %(ip_address)s,  #2
                %(user_agent)s,  #2
                %(http_request)s,  #2
                %(http_response)s,  #2
                %(url)s,  #2
                %(message)s #2
                )  #2
           RETURNING audit_log_id #2
            """,  #2
                log_record_dict,  #2
            )  #2
 #2
        return result.fetchone()["audit_log_id"] #3

    @staticmethod
    def get_log_record(audit_log_id: str):
        with get_db_connection(row_factory=
<span class="CharOverride-5">➥</span>class_row(AuditLogRecord)) as conn:
            result = conn.execute(
                """
                SELECT *
                FROM audit_log
                WHERE audit_log_id = %(audit_log_id)s
                """,
                {"audit_log_id": audit_log_id},
            )

        return result.fetchone()</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Defines a </span>
<span class="CharOverride-4">dictonary </span>
<span class="CharOverride-4">to use</span>
<br/>#2 
     <span class="CharOverride-4">Defines the fields to insert; we will return the audit_log_id we obtained from the database.</span>
<br/>#3 
     <span class="CharOverride-4">Because we used a dict_row for row_factory, we can reference the audit_log_id directly.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p105">
<p>With that in place, our unit test is passing, and we can add audit records wherever we want. Now, let’s see how to integrate what we know with the FastAPI framework.</p>
</div>
<div class="readable-text" id="p106">
<h3 class="readable-text-h3"><span class="num-string">9.3.3</span> Auditing logic</h3>
</div>
<div class="readable-text" id="p107">
<p>The most obvious way to add auditing to our application is by making a call to the <code>log_record</code> method and passing an <code>AuditLogRecord</code>, as seen from our unit test. We could certainly take one of our existing endpoints and add the call into it, ending up with something akin to the following listing, which allows us to write a message but does not capture some of the other potentially useful information we defined fields for.</p>
</div>
<div class="browsable-container listing-container" id="p108">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.24<span class="CharOverride-3"> </span>One way to add logging of our API</h5>
<div class="code-area-container">
<pre class="code-area">async def read_files() -&gt; list[AchFilesResponse]:
    AuditLog().log_record( #1
        AuditLogRecord(  #1
            message="User retrieved ACH files -test"  #1
        )  #1
    )  #1
    return AchFileSql().get_files_response()</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Manually calls the log_record method whenever the API is executed, but we are missing many of the interesting fields</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p109">
<p>We could enhance the previous listing by including the request field. Then we can pull the additional information from the request object.</p>
</div>
<div class="browsable-container listing-container" id="p110">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.25<span class="CharOverride-3"> </span>Including request information in our API</h5>
<div class="code-area-container">
<pre class="code-area">async def read_files(request: Request) -&gt; #1
<span class="CharOverride-5">➥</span> list[AchFilesResponse]: 
    AuditLog().log_record(
        AuditLogRecord(
            ip_address=request.client.host, #2
            message="User retrieved ACH files -test"
        )
    )
    return AchFileSql().get_files_response()</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Updates the method to </span>
<span class="CharOverride-4">include the Request object </span>
<br/>#2 
     <span class="CharOverride-4">We now have access to some of the interesting fields</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p111">
<p>While that works, it requires the developers to add more boilerplate logic than we would prefer. Since we are primarily interested in auditing the usage of our APIs, we can take another approach.</p>
</div>
<div class="readable-text" id="p112">
<h2 class="readable-text-h2"><span class="num-string">9.4</span> Using middleware for our logging</h2>
</div>
<div class="readable-text" id="p113">
<p>With the goal of logging the API requests, we can look at adding a middleware function that has the sole purpose of logging our requests. We can employ both the request and response, which allows us to capture the response code as well. While we could also look at configuring our Nginx logs to capture the information in the production environment, seeing how to accomplish this in FastAPI is also helpful since it can be widely applied for other requirements. We use the <code>@app.middleware</code> notation to write our log record.</p>
</div>
<div class="browsable-container listing-container" id="p114">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.26<span class="CharOverride-3"> </span>The middleware layer for logging</h5>
<div class="code-area-container">
<pre class="code-area">@app.middleware("http") #1
async def log_requests(request: Request, call_next): #2
    response = await call_next(request) #3
    log_message = getattr(request.state, 'log_message', #4
                  "Default audit log message") 
    log_record = AuditLogRecord( #5
        ip_address=request.client.host,  #5
        user_agent=request.headers.get #5
<span class="CharOverride-5">➥</span>('user-agent', 'unknown'),  #5
        <span>http_request=request.method, </span> #5
<span>        http_response=response.status_code, </span> #5
<span>        url=str(request.url), </span> #5
<span>        message=log_message, </span> #5
<span>    </span>)
    logger = AuditLog() #6
    logger.log_record(log_record) 
    return response #7</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Defines a middleware component that executes for every HTTP request</span>
<br/>#2 
     <span class="CharOverride-4">Defines a method </span>
<span class="CharOverride-4">to log requests</span>
<br/>#3 
     <span class="CharOverride-4">Passes the request </span>
<span class="CharOverride-4">on to the next layer</span>
<br/>#4 
     <span class="CharOverride-4">Gets the </span>
<span class="CharOverride-4">log_message that was defined in the request.state and defaults if not present</span>
<br/>#5 
     <span class="CharOverride-4">Builds an AuditLogRecord with our desired request fields</span>
<br/>#6 
     <span class="CharOverride-4">Writes the log messages</span>
<br/>#7 
     <span class="CharOverride-4">Returns the response</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p115">
<p>It is relatively easy to insert that middleware layer and have it perform the logging. Then we can log all the calls that are coming in, which removes the need for the boilerplate code. Moreover, it keeps our code cleaner and lets the developers focus on their code. The only drawback is that adding a message would take a little more effort. Of course, the message is going to reflect what the <code>REST</code> <code>API</code> call is doing. So, in some respect, it is redundant (and a waste of space) to log a message. For instance, do we need to know someone viewed ACH files when the log also shows that they were performing a <code>GET</code> on <code>/api/v1/files</code>? Of course, we may need to do it for business reasons because it is easier for people unfamiliar with the data to interpret the message when being reviewed. Rather than waste the storage, we may decide to have a utility method that could perform that interpretation and insert the appropriate message during an extract. The use cases could vary, of course, and we only want to illustrate some of the alternatives. In this case, we do want to store the text in the database table, and we are going to accomplish that using a decorator. The following listing shows how to include a message in the request state using a <code>log_message</code> annotation we defined.</p>
</div>
<div class="browsable-container listing-container" id="p116">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.27<span class="CharOverride-3"> </span>The <code>log_message</code> annotation</h5>
<div class="code-area-container">
<pre class="code-area">def log_message(message: str):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            request: Request = kwargs.get("request", None)
            if request: #1
                request.state.log_message = message
            return await func(*args, **kwargs)

        return wrapper

    return decorator</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">If we have a request, it saves the message that was passed.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p117">
<p>Finally, we only need to make some minor changes to the API. By using our new annotation, we can customize the message written to the database. The next listing shows the final changes to our API call.</p>
</div>
<div class="browsable-container listing-container" id="p118">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.28<span class="CharOverride-3"> </span>Final changes for logging</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area"><strong>@log_message("Retrieving ACH files") </strong>#1
async def read_files(<strong>request: Request</strong>) -&gt; #2
<span class="CharOverride-5">➥</span> list[AchFilesResponse]: 
    return AchFileSql().get_files_response()</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Annotates each of our API calls with a unique message</span>
<br/>#2 
     <span class="CharOverride-4">Ensures the request object is part of the method</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p119">
<p>Adding that little bit of logic completes the logging of our API messages. Now, log messages are written out for any APIs we annotate with <code>@log_message</code>. This is just the beginning of tracing and auditing your application. You can vastly expand collecting data in your application by exploring projects such as OpenTelemetry, OpenTracing, or Prometheus, to name just a few.</p>
</div>
<div class="readable-text" id="p120">
<h2 class="readable-text-h2"><span class="num-string">9.5</span> Viewing the audit log</h2>
</div>
<div class="readable-text" id="p121">
<p>Now that we have the application logging API requests, let’s add the ability to view the log in our application. This page will function in much the same way the exceptions page from chapter 8 did. We need to retrieve the audit records and place them in a DataGrid to be viewed. Of course, we can expand the functionality as needed, but for now, simply returning the data is all that we need to accomplish. </p>
</div>
<div class="readable-text" id="p122">
<h3 class="readable-text-h3"><span class="num-string">9.5.1</span> Creating the page</h3>
</div>
<div class="readable-text" id="p123">
<p>We create the page.tsx under <code>src/app/audit</code>. This page will be responsible for making a request to the API and then passing the returned data down to a component that can display the records. The following listing shows the basic page.</p>
</div>
<div class="browsable-container listing-container" id="p124">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.29<span class="CharOverride-3"> </span>Audit page</h5>
<div class="code-area-container">
<pre class="code-area">export default function AuditPage() {

    <span>const [entries, setEntries] = useState&lt;AuditResponse[]&gt;([]);</span>

<span>    </span>useEffect(() =&gt; {
        const apiUrl = process.env.NEXT_PUBLIC_API_URL ?? '';
        axios.get&lt;AuditResponse[]&gt;(`${apiUrl}/audits`, { #1
            headers: {
                'Content-Type': 'application/json'
            }
        })
            .then(response =&gt; {
                console.log(`Response data ${JSON.stringify(response.data)}`);
                setEntries(response.data);
            })
            .catch(error =&gt; {
                console.log(error);
            });
    }, []);

    return (
…
       &lt;AuditRecords records={entries}/&gt; #2
…
    );
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Gets the audit records from the database</span>
<br/>#2 
     <span class="CharOverride-4">Displays the audit records</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p125">
<p>To finish this page, we also want to create the <code>AuditResponse</code> interface, as shown in listing 9.30. We keep the names aligned with those from the API because there is less work for us. However, in previous chapters, we have shown the process of mapping fields to internal representations of the data, and that is still valid here. Keep in mind the tradeoffs we incur by exactly matching the API—the biggest problem being when the API changes or when we move to another vendor where the field names may change. These changes must be propagated throughout the application instead of at a single point. We recommend always trying to use a layer of abstraction to prevent these types of problems. Nobody wants to spend their time changing <code>created_at</code> to <code>created_on</code> and having to retest everywhere it may touch.</p>
</div>
<div class="browsable-container listing-container" id="p126">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.30<span class="CharOverride-3"> </span>The <code>AuditResponse</code> interface</h5>
<div class="code-area-container">
<pre class="code-area">export interface AuditResponse {
    audit_log_id: string;
    created_at: Date;
    user_id: string;
    ip_address: string;
    user_agent: string;
    http_request: string;
    http_response: number;
    url: string;
    message: string;
}</pre>
</div>
</div>
<div class="readable-text" id="p127">
<h3 class="readable-text-h3"><span class="num-string">9.5.2</span> Creating the page components</h3>
</div>
<div class="readable-text" id="p128">
<p>We pass the data down to our <code>AuditLogRecords</code> component so that the presentation logic is taken care of. At this point, we should hopefully see how components help break our code apart into smaller, more manageable pieces. We try to keep the pages responsible for retrieving the data, while components on the page are responsible for presenting that data. We tend to have more duplicated code when applications are first being developed. This is often due to developers trying to rush to meet deadlines. As the code matures (and the developers get a better sense of the application), we can often start to create more generalized code. Breaking down our code into components helps us get to that point quicker. The next listing shows the code for the presentation of an audit record.</p>
</div>
<div class="browsable-container listing-container" id="p129">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.31<span class="CharOverride-3"> </span>The A<code>uditLogRecords</code> component</h5>
<div class="code-area-container">
<pre class="code-area">interface AuditRecordsProps {
    records: AuditResponse[];
}

export default function AuditRecords({records}: Readonly&lt;AuditRecordsProps&gt;) {

    const [isOpen, setIsOpen] = useState&lt;boolean&gt;(false); #1
    const [auditDetails, setAuditDetails] = #2
                   useState&lt;AuditResponse | null&gt;(null); 
    const columns: GridColDef[] = [
        {field: 'view', headerName: 'View',
<span class="CharOverride-5">➥</span> sortable: false, width: 10, renderCell: (params) =&gt; (
                &lt;IconButton
                    onClick={(e) =&gt; { #3
                        e.preventDefault();  #3
                        setAuditDetails(params.row);  #3
                        setIsOpen(true);  #3
                    }}
                    color="primary"
                &gt;
                    &lt;InfoIcon /&gt;
                &lt;/IconButton&gt;
            )},
        {field: 'created_at', headerName: 'Date',
<span class="CharOverride-5">➥</span> width: 150, valueGetter: (params) =&gt; 
convertDateFormat(params.value)},
<span class="CharOverride-5">➥</span>        {field: 'ip_address', 
<span class="CharOverride-5">➥</span>headerName: 'IP Address', width: 150, valueGetter: (params) =&gt; 
<span class="CharOverride-5">➥</span> stripSubnet(params.value)},
        {field: 'message', headerName: 'Audit Message', width: 300},
    ];

    return (
        &lt;ThemeProvider theme={defaultTheme}&gt;
            &lt;Box sx={{display: 'flex'}}&gt;
                &lt;CssBaseline/&gt;
                    &lt;Container maxWidth="lg" sx={{mt: 4, mb: 4, ml: 4}}&gt;
                        &lt;Paper
                            sx={{
                                p: 2,
                                display: 'flex',
                                flexDirection: 'column',
                                height: 480,
                                width: '100%'
                            }}
                        &gt;
                            &lt;DataGrid columns={columns} #4
<span class="CharOverride-5">➥</span> rows={records} getRowId={(row) =&gt; row.audit_log_id} /&gt; 
                        &lt;/Paper&gt;
                    &lt;/Container&gt;
            &lt;/Box&gt;
            &lt;AuditModal open={isOpen} #5
<span class="CharOverride-5">➥</span>] onClose={setIsOpen.bind({}, false)} auditData={auditDetails} /&gt; 
        &lt;/ThemeProvider&gt;
    );
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Defines a field to keep track of the modal</span>
<br/>#2 
     <span class="CharOverride-4">Defines the contents of the audit details for the modal</span>
<br/>#3 
     <span class="CharOverride-4">When the button is clicked, passes information to the modal and sets that it is now open</span>
<br/>#4 
     <span class="CharOverride-4">Uses the DataGrid element to display the text</span>
<br/>#5 
     <span class="CharOverride-4">Includes the AuditModal component to display the detailed contents</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p130">
<p>There is an extra utility method we have also built as part of the component—the <code>stripSubnet</code> method. The code for this method is shown in the following listing. Note it only removes a trailing <code>/32</code>, so why do we have a function to remove it, and why exactly is it there?</p>
</div>
<div class="browsable-container listing-container" id="p131">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.32<span class="CharOverride-3"> </span>The <code>stripSubnet</code> utility method</h5>
<div class="code-area-container">
<pre class="code-area">export function stripSubnet(ipWithSubnet: string): string {
  const [ip, subnet] = ipWithSubnet.split('/'); #1

  if (subnet === '32' ) { #2
    return ip; #3
  } else {
    return ipWithSubnet; #4
  }

}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Splits the IP address </span>
<span class="CharOverride-4">on the slash</span>
<br/>#2 
     <span class="CharOverride-4">If the subnet is 32, that indicates a single IP address.</span>
<br/>#3 
     <span class="CharOverride-4">Returns the IP only when </span>
<span class="CharOverride-4">it is a single IP address</span>
<br/>#4 
     <span class="CharOverride-4">Otherwise, returns the string as it came through</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p132">
<p>The <code>/32</code> is part of the Classless Inter-Domain Routing (CIDR) notation, which is a way to define IP address ranges. The <code>/32</code> means that the given address is a single address, and it is just an explicit way to indicate that. To illustrate, we could represent the addresses between <code>192.168.1.0</code> and <code>192.168.1.255</code> with <code>192.168.1.0/24</code>. That explains what the <code>/32</code> is but not why it is there. We are seeing the <code>/32</code> because we chose to represent the IP address in our Pydantic model with <code>IPvAnyNetwork</code>.</p>
</div>
<div class="readable-text intended-text" id="p133">
<p>Pydantic supports many network types. The ones that we are primarily concerned with at this point are <code>IPvAnyAddress</code> and <code>IPvAnyNetwork</code>. The decision to use <code>INET</code> for our <code>ip_address</code> column was the catalyst for the problem. The <code>INET</code> datatype supports storing IP addresses using the CIDR notation. For that reason, we chose to use a datatype in Pydantic that closely modeled that functionality, even though we should only have a single IP address in our table. We used this example to illustrate how design decisions can have a downstream effect. The <code>INET</code> requirement for the column may be set because there is a need to be able to query for ranges of IP addresses, and having an <code>INET</code> data type makes sense even though there is no business need for the audit record to contain more than a single IP address. Perhaps, the decisions were already made (for better or worse) by the time the UI piece lands on our plate. The business does not want users to see the <code>/32</code> as part of the IP address because most users will not understand the notation, so we need to correct the display.</p>
</div>
<div class="readable-text intended-text" id="p134">
<p>The following listing shows some additional unit tests that help illustrate the difference between the Pydantic types of <code>IPvAnyAddress</code> and <code>IPvAnyNetwork</code>.</p>
</div>
<div class="browsable-container listing-container" id="p135">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.33<span class="CharOverride-3"> </span>Unit testing of the network types</h5>
<div class="code-area-container">
<pre class="code-area">class IpModel(BaseModel):
    ip_any_address: IPvAnyAddress
    ip_any_network: IPvAnyNetwork


class TestPydanticNetworkTypes:

    def test_valid_any_address(self):
        my_address = IpModel(ip_any_address="127.0.0.1",
<span class="CharOverride-5">➥</span> ip_any_network="127.0.0.1")
        assert str(my_address.ip_any_address) == "127.0.0.1"

    def test_invalid_any_address(self):
        with pytest.raises(ValueError):
            IpModel(ip_any_address="127.0.0.256",
<span class="CharOverride-5">➥</span> ip_any_network="127.0.0.1")

    def test_valid_any_network(self):
        my_address = IpModel(ip_any_address="127.0.0.1",
<span class="CharOverride-5">➥</span> ip_any_network="127.0.0.1")
        assert str(my_address.ip_any_network) == "127.0.0.1/32"

    def test_invalid_any_network(self):
        with pytest.raises(ValueError):
            IpModel(ip_any_address="127.0.0.1",
<span class="CharOverride-5">➥</span> ip_any_network="127.0.0.256")</pre>
</div>
</div>
<div class="readable-text" id="p136">
<p>Another custom component we make use of is <code>AuditModal</code>. When the details of an audit record are clicked, we want to display a formatted window with the audit information (listing 9.34). This is meant to be a more complete view of the audit record, so we do not need to clutter up the initial view. <code>AuditModal</code> is a relatively straightforward component. As we already have the entire record returned, this is just a presentation of the data, as opposed to the previous chapter where we specifically retrieved the ACH record data when the user clicked the view icon. Remember, the difference was that we did not want to return possible NPI data unless the user requested it. Now we have the ability to view audit information, monitor for users requesting NPI data, and address any potential misuse (whether intentional or not) of the data. </p>
</div>
<div class="browsable-container listing-container" id="p137">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.34<span class="CharOverride-7"> </span>The <code>AuditRecords</code> component</h5>
<div class="code-area-container">
<pre class="code-area">interface AuditRecordsProps {
    records: AuditResponse[];
}

export default function AuditRecords({records}:
<span class="CharOverride-5">➥</span> Readonly&lt;AuditRecordsProps&gt;) {

    const [isOpen, setIsOpen] = useState&lt;boolean&gt;(false);
    const [auditDetails, setAuditDetails] =
<span class="CharOverride-5">➥</span> useState&lt;AuditResponse | null&gt;(null);
    const columns: GridColDef[] = [
        {field: 'view', headerName: 'View', sortable: false,
<span class="CharOverride-5">➥</span> width: 10, renderCell: (params) =&gt; (
                &lt;IconButton #1
                    onClick={(e) =&gt; { 
                        e.preventDefault(); 
                        setAuditDetails(params.row); 
                        setIsOpen(true); #2
                    }} 
                    color="primary" 
                &gt; 
                    &lt;InfoIcon /&gt;
                &lt;/IconButton&gt;
            )},
        {field: 'created_at', headerName: 'Date', width: 150,
<span class="CharOverride-5">➥</span> valueGetter: (params) =&gt; convertDateFormat(params.value)},
<span class="CharOverride-5">➥</span>        {field: 'ip_address', headerName: 'IP Address',
<span class="CharOverride-5">➥</span> width: 150, valueGetter: (params) =&gt; stripSubnet(params.value)},
        {field: 'message', headerName: 'Audit Message', width: 300},
    ];

    return (
        &lt;ThemeProvider theme={defaultTheme}&gt;
            &lt;Box sx={{display: 'flex'}}&gt;
                &lt;CssBaseline/&gt;
                    &lt;Container maxWidth="lg" sx={{mt: 4, mb: 4, ml: 4}}&gt;
                        &lt;Paper
                            sx={{
                                p: 2,
                                display: 'flex',
                                flexDirection: 'column',
                                height: 480,
                                width: '100%'
                            }}
                        &gt;
                            &lt;DataGrid columns={columns}
<span class="CharOverride-5">➥</span> rows={records} getRowId={(row) =&gt; row.audit_log_id} /&gt; #3
                        &lt;/Paper&gt;
                    &lt;/Container&gt;
            &lt;/Box&gt;
            &lt;AuditModal open={isOpen} onClose=
<span class="CharOverride-5">➥</span>{setIsOpen.bind({}, false)} auditData={auditDetails} /&gt;  #4
        &lt;/ThemeProvider&gt;
    );
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Clickable button that displays detailed information on the audit record</span>
<br/>#2 
     <span class="CharOverride-4"> Clickable button that displays detailed information on the audit record</span>
<br/>#3 
     <span class="CharOverride-4">DataGrid element that displays all the audit record results</span>
<br/>#4 
     <span class="CharOverride-4">AuditModal component that displays when the icon is clicked</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p138">
<p>With the ability to pull and view audit data, we are missing one critical piece to our puzzle—let’s add the API endpoint to retrieve our data.</p>
</div>
<div class="readable-text" id="p139">
<h3 class="readable-text-h3"><span class="num-string">9.5.3</span> Adding the APIs for the audit log</h3>
</div>
<div class="readable-text" id="p140">
<p>While we built the initial SQL calls that retrieved records and the UI layers to display the data, we have not built the API itself yet. We now need to ensure we can call the API and return the data. The following listing shows that all it takes is a few lines to accomplish this task, and most of those are helping document the API for others to use. We created the audit API in its own file named routers/audit.py. Because this endpoint has nothing to do with ACH files, we wanted to separate it.</p>
</div>
<div class="browsable-container listing-container" id="p141">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.35<span class="CharOverride-3"> </span>Audit router</h5>
<div class="code-area-container">
<pre class="code-area">@router.get(
    path="",
    response_model=list[AuditLogRecord],
    summary="Retrieve Audit Information",
    description="Retrieve audit records for the ACH API.",
    response_description="The overview of the requested audit records.",
    <span>tags=["Audit"],</span>
<span>)</span>
<span>@log_message("Audit Information")</span>
async def read_audit_information(request: Request) -&gt; list[AuditLogRecord]:
    return AuditLog().get_all_log_records() #1</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Simple call to get and return all audit records</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p142">
<p>Since we separated our code for easier maintenance, the API will not be reachable until we add it using an <code>include_router</code> method. We had initially done this for the router/files.py file, and all our APIs up until this point have been put into that file, meaning there has been no need to revisit the main.py file until now. The next listing shows the additional line needed to access our API.</p>
</div>
<div class="browsable-container listing-container" id="p143">
<h5 class="listing-container-h5 browsable-container-h5">Listing 9.36<span class="CharOverride-3"> </span>Adding the router</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">app = FastAPI()

app.include_router(files.router)
<strong>app.include_router(audit.router) </strong>#1

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,  # List of origins that should be allowed
    allow_credentials=False,  # Allows cookies to be included
    allow_methods=["*"],  # List of HTTP methods allowed for CORS
    allow_headers=["*"],  # List of HTTP headers allowed for CORS
)</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">The additional router to handle the audit API requests</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p144">
<p>That was the final piece to put into place. Now we should have fully functioning audit capabilities. We can expand on this with additional logging and more specific logging of business scenarios, such as invalid input and other scenarios where we may want to log more than just confirmation that an API was accessed.</p>
</div>
<div class="readable-text" id="p145">
<h2 class="readable-text-h2">Summary</h2>
</div>
<ul>
<li class="readable-text" id="p146">Each successive iteration helps improve the functionality of our application. We looked to address requests/concerns brought up by the end-users, new functionality required by the business, and technical debt.</li>
<li class="readable-text" id="p147">Being able to search is a necessary feature of our application. Transactions are loaded at various times through different files throughout the day. If a customer has a question about when a transaction was loaded, we need to be able to provide an answer quickly.</li>
<li class="readable-text" id="p148">Whether we are working toward protecting our application from intruders or disgruntled employees to gain deeper insight into the application, it all starts with proper auditing for security and compliance, accompanied by general analysis. </li>
<li class="readable-text" id="p149">We touched on the importance of not just logging but also of how having a successful strategy for managing logs will play a part in our success. We should not trust that the application is working or not being attacked—instead, we must have the data and analyze it.</li>
<li class="readable-text" id="p150">You were shown the importance of expanding exception handling and enhancing UI/UX based on user feedback to improve overall user satisfaction and system functionality.</li>
<li class="readable-text" id="p151">The significance of enabling transaction search by multiple criteria was highlighted in addressing customer complaints effectively and ensuring better UX.</li>
<li class="readable-text" id="p152">Stakeholder requests for audit capabilities emphasized the value of tracking dashboard interactions for understanding user engagement and planning future system improvements.</li>
<li class="readable-text" id="p153">We focused on the importance of Agile sprint planning, including defining clear user stories and acceptance criteria to ensure alignment and successful delivery of sprint goals.</li>
<li class="readable-text" id="p154">Gantt charts are effective in visualizing project timelines, aiding in stakeholder communication and expectation management.</li>
<li class="readable-text" id="p155">The requirement for robust search capabilities in large datasets underscores the need for an efficient search API, which prompted us to explore UI changes and real-time search methods.</li>
<li class="readable-text" id="p156">Developing BDD tests illustrated the critical role of testing in validating new search functionalities, ensuring they meet specified scenarios and user needs.</li>
<li class="readable-text" id="p157">Implementing a search API involved understanding various approaches for criteria handling, highlighting the importance of flexible and user-friendly search functionalities.</li>
<li class="readable-text" id="p158">The exploration of logging and auditing emphasized the significance of security practices in monitoring API usage and user interactions to ensure safe and accountable system behavior.</li>
<li class="readable-text" id="p159">Designing a database for audit logs reinforced the need to capture detailed request information such as user agent and IP address for comprehensive security and analysis.</li>
<li class="readable-text" id="p160">Using middleware in FastAPI demonstrated how to streamline logging processes, which reduces redundant code and enhances code maintainability.</li>
<li class="readable-text" id="p161">Integrating an audit log view into the application showed the value of transparency and monitoring of system activities to support ongoing improvement and accountability.</li>
</ul>
</div></body></html>