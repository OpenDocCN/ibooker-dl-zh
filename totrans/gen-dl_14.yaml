- en: Chapter 10\. Advanced GANs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.xhtml#chapter_gan) introduced generative adversarial networks
    (GANs), a class of generative model that has produced state-of-the-art results
    across a wide variety of image generation tasks. The flexibility in the model
    architecture and training process has led academics and deep learning practitioners
    to find new ways to design and train GANs, leading to many different advanced
    *flavors* of the architecture that we shall explore in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Explaining all GAN developments and their repercussions in detail could easily
    fill another book. The [GAN Zoo repository](https://oreil.ly/Oy6bR) on GitHub
    contains over 500 distinct examples of GANs with linked papers, ranging from ABC-GAN
    to ZipNet-GAN!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will cover the main GANs that have been influential in the
    field, including a detailed explanation of the model architecture and training
    process for each.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first explore three important models from NVIDIA that have pushed the
    boundaries of image generation: ProGAN, StyleGAN, and StyleGAN2\. We will analyze
    each of these models in enough detail to understand the fundamental concepts that
    underpin the architectures and see how they have each built on ideas from earlier
    papers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also explore two other important GAN architectures that incorporate
    attention: the Self-Attention GAN (SAGAN) and BigGAN, which built on many of the
    ideas in the SAGAN paper. We have already seen the power of the attention mechanism
    in the context of Transformers in [Chapter 9](ch09.xhtml#chapter_transformer).'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we will cover VQ-GAN and ViT VQ-GAN, which incorporate a blend of ideas
    from variational autoencoders, Transformers, and GANs. VQ-GAN is a key component
    of Google’s state-of-the-art text-to-image generation model Muse.^([1](ch10.xhtml#idm45387005226448))
    We will explore so-called multimodal models in more detail in [Chapter 13](ch13.xhtml#chapter_multimodal).
  prefs: []
  type: TYPE_NORMAL
- en: Training Your Own Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For conciseness I have chosen not to include code to directly build these models
    in the code repository for this book, but instead will point to publicly available
    implementations where possible, so that you can train your own versions if you
    wish.
  prefs: []
  type: TYPE_NORMAL
- en: ProGAN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ProGAN is a technique developed by NVIDIA Labs in 2017^([2](ch10.xhtml#idm45387005216528))
    to improve both the speed and stability of GAN training. Instead of immediately
    training a GAN on full-resolution images, the ProGAN paper suggests first training
    the generator and discriminator on low-resolution images of, say, 4 × 4 pixels
    and then incrementally adding layers throughout the training process to increase
    the resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the concept of *progressive training* in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Training Your Own ProGAN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an excellent tutorial by Bharath K on training your own ProGAN using
    Keras available on the [Paperspace blog](https://oreil.ly/b2CJm). Bear in mind
    that training a ProGAN to achieve the results from the paper requires a significant
    amount of computing power.
  prefs: []
  type: TYPE_NORMAL
- en: Progressive Training
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As always with GANs, we build two independent networks, the generator and discriminator,
    with a fight for dominance taking place during the training process.
  prefs: []
  type: TYPE_NORMAL
- en: In a normal GAN, the generator always outputs full-resolution images, even in
    the early stages of training. It is reasonable to think that this strategy might
    not be optimal—the generator might be slow to learn high-level structures in the
    early stages of training, because it is immediately operating over complex, high-resolution
    images. Wouldn’t it be better to first train a lightweight GAN to output accurate
    low-resolution images and then see if we can build on this to gradually increase
    the resolution?
  prefs: []
  type: TYPE_NORMAL
- en: This simple idea leads us to *progressive training*, one of the key contributions
    of the ProGAN paper. The ProGAN is trained in stages, starting with a training
    set that has been condensed down to 4 × 4–pixel images using interpolation, as
    shown in [Figure 10-1](Images/#condensed_images).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. Images in the dataset can be compressed to lower resolution using
    interpolation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can then initially train the generator to transform a latent input noise
    vector <math alttext="z"><mi>z</mi></math> (say, of length 512) into an image
    of shape 4 × 4 × 3\. The matching discriminator will need to transform an input
    image of size 4 × 4 × 3 into a single scalar prediction. The network architectures
    for this first step are shown in [Figure 10-2](#progan_4).
  prefs: []
  type: TYPE_NORMAL
- en: The blue box in the generator represents the convolutional layer that converts
    the set of feature maps into an RGB image (`toRGB`), and the blue box in the discriminator
    represents the convolutional layer that converts the RGB images into a set of
    feature maps (`fromRGB`).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. The generator and discriminator architectures for the first stage
    of the ProGAN training process
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the paper, the authors train this pair of networks until the discriminator
    has seen 800,000 real images. We now need to understand how the generator and
    discriminator are expanded to work with 8 × 8–pixel images.
  prefs: []
  type: TYPE_NORMAL
- en: To expand the generator and discriminator, we need to blend in additional layers.
    This is managed in two phases, transition and stabilization, as shown in [Figure 10-3](#progan_training_gen).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3\. The ProGAN generator training process, expanding the network from
    4 × 4 images to 8 × 8 (dotted lines represent the rest of the network, not shown)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s first look at the generator. During the *transition phase*, new upsampling
    and convolutional layers are appended to the existing network, with a residual
    connection set up to maintain the output from the existing trained `toRGB` layer.
    Crucially, the new layers are initially masked using a parameter <math alttext="alpha"><mi>α</mi></math>
    that is gradually increased from 0 to 1 throughout the transition phase to allow
    more of the new `toRGB` output through and less of the existing `toRGB` layer.
    This is to avoid a *shock* to the network as the new layers take over.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, there is no flow through the old `toRGB` layer and the network enters
    the *stabilization phase*—a further period of training where the network can fine-tune
    the output, without any flow through the old `toRGB` layer.
  prefs: []
  type: TYPE_NORMAL
- en: The discriminator uses a similar process, as shown in [Figure 10-4](#progan_training_dis).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-4\. The ProGAN discriminator training process, expanding the network
    from 4 × 4 images to 8 × 8 (dotted lines represent the rest of the network, not
    shown)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, we need to blend in additional downscaling and convolutional layers. Again,
    the layers are injected into the network—this time at the start of the network,
    just after the input image. The existing `fromRGB` layer is connected via a residual
    connection and gradually phased out as the new layers take over during the transition
    phase. The stabilization phase allows the discriminator to fine-tune using the
    new layers.
  prefs: []
  type: TYPE_NORMAL
- en: All transition and stabilization phases last until the discriminator has been
    shown 800,000 real images. Note that even through the network is trained progressively,
    no layers are *frozen*. Throughout the training process, all layers remain fully
    trainable.
  prefs: []
  type: TYPE_NORMAL
- en: This process continues, growing the GAN from 4 × 4 images to 8 × 8, then 16
    × 16, 32 × 32, and so on, until it reaches full resolution (1,024 × 1,024), as
    shown in [Figure 10-5](#progan).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-5\. The ProGAN training mechanism, and some example generated faces
    (source: [Karras et al., 2017](https://arxiv.org/abs/1710.10196))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The overall structure of the generator and discriminator after the full progressive
    training process is complete is shown in [Figure 10-6](#progan_network_diagram).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-6\. The ProGAN generator and discriminator used to generate 1,024
    × 1,024–pixel CelebA faces (source: [Karras et al., 2018](https://arxiv.org/abs/1812.04948))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The paper also makes several other important contributions, namely minibatch
    standard deviation, equalized learning rates, and pixelwise normalization, which
    are described briefly in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Minibatch standard deviation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *minibatch standard deviation* layer is an extra layer in the discriminator
    that appends the standard deviation of the feature values, averaged across all
    pixels and across the minibatch as an additional (constant) feature. This helps
    to ensure the generator creates more variety in its output—if variety is low across
    the minibatch, then the standard deviation will be small, and the discriminator
    can use this feature to distinguish the fake batches from the real batches! Therefore,
    the generator is incentivized to ensure it generates a similar amount of variety
    as is present in the real training data.
  prefs: []
  type: TYPE_NORMAL
- en: Equalized learning rates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All dense and convolutional layers in ProGAN use *equalized learning rates*.
    Usually, weights in a neural network are initialized using a method such as *He
    initialization*—a Gaussian distribution where the standard deviation is scaled
    to be inversely proportional to the square root of the number of inputs to the
    layer. This way, layers with a greater number of inputs will be initialized with
    weights that have a smaller deviation from zero, which generally improves the
    stability of the training process.
  prefs: []
  type: TYPE_NORMAL
- en: The authors of the ProGAN paper found that this was causing problems when used
    in combination with modern optimizers such as Adam or RMSProp. These methods normalize
    the gradient update for each weight, so that the size of the update is independent
    of the scale (magnitude) of the weight. However, this means that weights with
    a larger dynamic range (i.e., layers with fewer inputs) will take comparatively
    longer to adjust than weights with a smaller dynamic range (i.e., layers with
    more inputs). It was found that this causes an imbalance between the speed of
    training of the different layers of the generator and discriminator in ProGAN,
    so they used *equalized learning rates* to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: In ProGAN, weights are initialized using a simple standard Gaussian, regardless
    of the number of inputs to the layer. The normalization is applied dynamically,
    as part of the call to the layer, rather than only at initialization. This way,
    the optimizer sees each weight as having approximately the same dynamic range,
    so it applies the same learning rate. It is only when the layer is called that
    the weight is scaled by the factor from the He initializer.
  prefs: []
  type: TYPE_NORMAL
- en: Pixelwise normalization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lastly, in ProGAN *pixelwise normalization* is used in the generator, rather
    than batch normalization. This normalizes the feature vector in each pixel to
    a unit length and helps to prevent the signal from spiraling out of control as
    it propagates through the network. The pixelwise normalization layer has no trainable
    weights.
  prefs: []
  type: TYPE_NORMAL
- en: Outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the CelebA dataset, ProGAN was also applied to images from the
    Large-scale Scene Understanding (LSUN) dataset with excellent results, as shown
    in [Figure 10-7](#progan_examples). This demonstrated the power of ProGAN over
    earlier GAN architectures and paved the way for future iterations such as StyleGAN
    and StyleGAN2, which we shall explore in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-7\. Generated examples from a ProGAN trained progressively on the
    LSUN dataset at 256 × 256 resolution (source: [Karras et al., 2017](https://arxiv.org/abs/1710.10196))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: StyleGAN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: StyleGAN^([3](ch10.xhtml#idm45387005140128)) is a GAN architecture from 2018
    that builds on the earlier ideas in the ProGAN paper. In fact, the discriminator
    is identical; only the generator is changed.
  prefs: []
  type: TYPE_NORMAL
- en: Often when training GANs it is difficult to separate out vectors in the latent
    space corresponding to high-level attributes—they are frequently *entangled*,
    meaning that adjusting an image in the latent space to give a face more freckles,
    for example, might also inadvertently change the background color. While ProGAN
    generates fantastically realistic images, it is no exception to this general rule.
    We would ideally like to have full control of the style of the image, and this
    requires a disentangled separation of features in the latent space.
  prefs: []
  type: TYPE_NORMAL
- en: 'StyleGAN achieves this by explicitly injecting style vectors into the network
    at different points: some that control high-level features (e.g., face orientation)
    and some that control low-level details (e.g., the way the hair falls across the
    forehead).'
  prefs: []
  type: TYPE_NORMAL
- en: The overall architecture of the StyleGAN generator is shown in [Figure 10-8](#stylegan_arch).
    Let’s walk through this architecture step by step, starting with the mapping network.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-8\. The StyleGAN generator architecture (source: [Karras et al.,
    2018](https://arxiv.org/abs/1812.04948))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Training Your Own StyleGAN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an excellent tutorial by Soon-Yau Cheong on training your own StyleGAN
    using Keras available on the [Keras website](https://oreil.ly/MooSe). Bear in
    mind that training a StyleGAN to achieve the results from the paper requires a
    significant amount of computing power.
  prefs: []
  type: TYPE_NORMAL
- en: The Mapping Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *mapping network* <math alttext="f"><mi>f</mi></math> is a simple feed-forward
    network that converts the input noise <math alttext="bold z element-of script
    upper Z"><mrow><mi>𝐳</mi> <mo>∈</mo> <mi>𝒵</mi></mrow></math> into a different
    latent space <math alttext="bold w element-of script upper W"><mrow><mi>𝐰</mi>
    <mo>∈</mo> <mi>𝒲</mi></mrow></math> . This gives the generator the opportunity
    to disentangle the noisy input vector into distinct factors of variation, which
    can be easily picked up by the downstream style-generating layers.
  prefs: []
  type: TYPE_NORMAL
- en: The point of doing this is to separate out the process of choosing a style for
    the image (the mapping network) from the generation of an image with a given style
    (the synthesis network).
  prefs: []
  type: TYPE_NORMAL
- en: The Synthesis Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The synthesis network is the generator of the actual image with a given style,
    as provided by the mapping network. As can be seen from [Figure 10-8](#stylegan_arch),
    the style vector <math alttext="bold w"><mi>𝐰</mi></math> is injected into the
    synthesis network at different points, each time via a differently densely connected
    layer <math alttext="upper A Subscript i"><msub><mi>A</mi> <mi>i</mi></msub></math>
    , which generates two vectors: a bias vector <math alttext="bold y Subscript b
    comma i"><msub><mi>𝐲</mi> <mrow><mi>b</mi><mo>,</mo><mi>i</mi></mrow></msub></math>
    and a scaling vector <math alttext="bold y Subscript s comma i"><msub><mi>𝐲</mi>
    <mrow><mi>s</mi><mo>,</mo><mi>i</mi></mrow></msub></math> . These vectors define
    the specific style that should be injected at this point in the network—that is,
    they tell the synthesis network how to adjust the feature maps to move the generated
    image in the direction of the specified style.'
  prefs: []
  type: TYPE_NORMAL
- en: This adjustment is achieved through *adaptive instance normalization* (AdaIN)
    layers.
  prefs: []
  type: TYPE_NORMAL
- en: Adaptive instance normalization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An AdaIN layer is a type of neural network layer that adjusts the mean and
    variance of each feature map <math alttext="bold x Subscript i"><msub><mi>𝐱</mi>
    <mi>i</mi></msub></math> with a reference style bias <math alttext="bold y Subscript
    b comma i"><msub><mi>𝐲</mi> <mrow><mi>b</mi><mo>,</mo><mi>i</mi></mrow></msub></math>
    and scale <math alttext="bold y Subscript s comma i"><msub><mi>𝐲</mi> <mrow><mi>s</mi><mo>,</mo><mi>i</mi></mrow></msub></math>
    , respectively.^([4](ch10.xhtml#idm45387005090240)) Both vectors are of length
    equal to the number of channels output from the preceding convolutional layer
    in the synthesis network. The equation for adaptive instance normalization is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  AdaIN left-parenthesis bold x Subscript
    i Baseline comma bold y right-parenthesis equals bold y Subscript s comma i Baseline
    StartFraction bold x Subscript i Baseline minus mu left-parenthesis bold x Subscript
    i Baseline right-parenthesis Over sigma left-parenthesis bold x Subscript i Baseline
    right-parenthesis EndFraction plus bold y Subscript b comma i Baseline EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mtext>AdaIN</mtext>
    <mrow><mo>(</mo> <msub><mi>𝐱</mi> <mi>i</mi></msub> <mo>,</mo> <mi>𝐲</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>𝐲</mi> <mrow><mi>s</mi><mo>,</mo><mi>i</mi></mrow></msub>
    <mfrac><mrow><msub><mi>𝐱</mi> <mi>i</mi></msub> <mo>-</mo><mi>μ</mi><mrow><mo>(</mo><msub><mi>𝐱</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow> <mrow><mi>σ</mi><mo>(</mo><msub><mi>𝐱</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mfrac> <mo>+</mo> <msub><mi>𝐲</mi> <mrow><mi>b</mi><mo>,</mo><mi>i</mi></mrow></msub></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: The adaptive instance normalization layers ensure that the style vectors that
    are injected into each layer only affect features at that layer, by preventing
    any style information from leaking through between layers. The authors show that
    this results in the latent vectors <math alttext="bold w"><mi>𝐰</mi></math> being
    significantly more disentangled than the original <math alttext="bold z"><mi>𝐳</mi></math>
    vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Since the synthesis network is based on the ProGAN architecture, it is trained
    progressively. The style vectors at earlier layers in the synthesis network (when
    the resolution of the image is lowest—4 × 4, 8 × 8) will affect coarser features
    than those later in the network (64 × 64 to 1,024 × 1,024–pixel resolution). This
    means that not only do we have complete control over the generated image through
    the latent vector <math alttext="bold w"><mi>𝐰</mi></math> , but we can also switch
    the <math alttext="bold w"><mi>𝐰</mi></math> vector at different points in the
    synthesis network to change the style at a variety of levels of detail.
  prefs: []
  type: TYPE_NORMAL
- en: Style mixing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The authors use a trick known as *style mixing* to ensure that the generator
    cannot utilize correlations between adjacent styles during training (i.e., the
    styles injected at each layer are as disentangled as possible). Instead of sampling
    only a single latent vector <math alttext="bold z"><mi>𝐳</mi></math> , two are
    sampled <math alttext="left-parenthesis bold z bold 1 comma bold z bold 2 right-parenthesis"><mrow><mo>(</mo>
    <msub><mi>𝐳</mi> <mn mathvariant="bold">1</mn></msub> <mo>,</mo> <msub><mi>𝐳</mi>
    <mn mathvariant="bold">2</mn></msub> <mo>)</mo></mrow></math> , corresponding
    to two style vectors <math alttext="left-parenthesis bold w bold 1 comma bold
    w bold 2 right-parenthesis"><mrow><mo>(</mo> <msub><mi>𝐰</mi> <mn mathvariant="bold">1</mn></msub>
    <mo>,</mo> <msub><mi>𝐰</mi> <mn mathvariant="bold">2</mn></msub> <mo>)</mo></mrow></math>
    . Then, at each layer, either <math alttext="left-parenthesis bold w bold 1"><mrow><mo>(</mo>
    <msub><mi>𝐰</mi> <mn mathvariant="bold">1</mn></msub></mrow></math> or <math alttext="bold
    w bold 2 right-parenthesis"><mrow><msub><mi>𝐰</mi> <mn mathvariant="bold">2</mn></msub>
    <mrow><mo>)</mo></mrow></mrow></math> is chosen at random, to break any possible
    correlation between the vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Stochastic variation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The synthesizer network adds noise (passed through a learned broadcasting layer
    <math alttext="upper B"><mi>B</mi></math> ) after each convolution to account
    for stochastic details such as the placement of individual hairs, or the background
    behind the face. Again, the depth at which the noise is injected affects the coarseness
    of the impact on the image.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that the initial input to the synthesis network can simply be
    a learned constant, rather than additional noise. There is enough stochasticity
    already present in the style inputs and the noise inputs to generate sufficient
    variation in the images.
  prefs: []
  type: TYPE_NORMAL
- en: Outputs from StyleGAN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 10-9](#stylegan_w) shows StyleGAN in action.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-9\. Merging styles between two generated images at different levels
    of detail (source: [Karras et al., 2018](https://arxiv.org/abs/1812.04948))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, two images, source A and source B, are generated from two different <math
    alttext="bold w"><mi>𝐰</mi></math> vectors. To generate a merged image, the source
    A <math alttext="bold w"><mi>𝐰</mi></math> vector is passed through the synthesis
    network but, at some point, switched for the source B <math alttext="bold w"><mi>𝐰</mi></math>
    vector. If this switch happens early on (4 × 4 or 8 × 8 resolution), coarse styles
    such as pose, face shape, and glasses from source B are carried across onto source
    A. However, if the switch happens later, only fine-grained detail is carried across
    from source B, such as colors and microstructure of the face, while the coarse
    features from source A are preserved.
  prefs: []
  type: TYPE_NORMAL
- en: StyleGAN2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final contribution in this chain of important GAN papers is StyleGAN2.^([5](ch10.xhtml#idm45387005019232))
    This builds further upon the StyleGAN architecture, with some key changes that
    improve the quality of the generated output. In particular, StyleGAN2 generations
    do not suffer as greatly from *artifacts*—water droplet–like areas of the image
    that were found to be caused by the adaptive instance normalization layers in
    StyleGAN, as shown in [Figure 10-10](#artifacts_stylegan).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-10\. An artifact in a StyleGAN-generated image of a face (source:
    [Karras et al., 2019](https://arxiv.org/abs/1912.04958))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Both the generator and the discriminator in StyleGAN2 are different from the
    StyleGAN. In the next sections we will explore the key differences between the
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Training Your Own StyleGAN2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official code for training your own StyleGAN using TensorFlow is available
    on [GitHub](https://oreil.ly/alB6w). Bear in mind that training a StyleGAN2 to
    achieve the results from the paper requires a significant amount of computing
    power.
  prefs: []
  type: TYPE_NORMAL
- en: Weight Modulation and Demodulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The artifact problem is solved by removing the AdaIN layers in the generator
    and replacing them with weight modulation and demodulation steps, as shown in
    [Figure 10-11](#stylegan2_styleblock). <math alttext="bold w"><mi>𝐰</mi></math>
    represents the weights of the convolutional layer, which are directly updated
    by the modulation and demodulation steps in StyleGAN2 at runtime. In comparison,
    the AdaIN layers of StyleGAN operate on the image tensor as it flows through the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: The AdaIN layer in StyleGAN is simply an instance normalization followed by
    style modulation (scaling and bias). The idea in StyleGAN2 is to apply style modulation
    and normalization (demodulation) directly to the weights of the convolutional
    layers at runtime, rather than the output from the convolutional layers, as shown
    in [Figure 10-11](#stylegan2_styleblock). The authors show how this removes the
    artifact issue while retaining control of the image style.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1011.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-11\. A comparison between the StyleGAN and StyleGAN2 style blocks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In StyleGAN2, each dense layer <math alttext="upper A"><mi>A</mi></math> outputs
    a single style vector <math alttext="s Subscript i"><msub><mi>s</mi> <mi>i</mi></msub></math>
    , where <math alttext="i"><mi>i</mi></math> indexes the number of input channels
    in the corresponding convolutional layer. This style vector is then applied to
    the weights of the convolutional layer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="w Subscript i comma j comma k Superscript prime Baseline equals
    s Subscript i Baseline dot w Subscript i comma j comma k" display="block"><mrow><msubsup><mi>w</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow> <msup><mo>'</mo></msup></msubsup>
    <mo>=</mo> <msub><mi>s</mi> <mi>i</mi></msub> <mo>·</mo> <msub><mi>w</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Here, <math alttext="j"><mi>j</mi></math> indexes the output channels of the
    layer and <math alttext="k"><mi>k</mi></math> indexes the spatial dimensions.
    This is the *modulation* step of the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to normalize the weights so that they again have a unit standard
    deviation, to ensure stability in the training process. This is the *demodulation*
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="w Subscript i comma j comma k Superscript double-prime Baseline
    equals StartFraction w Subscript i comma j comma k Superscript prime Baseline
    Over StartRoot sigma-summation Underscript i comma k Endscripts w Subscript i
    comma j comma k Superscript prime Baseline squared plus epsilon EndRoot EndFraction"
    display="block"><mrow><msubsup><mi>w</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow>
    <msup><mrow><mo>'</mo><mo>'</mo></mrow></msup></msubsup> <mo>=</mo> <mfrac><msubsup><mi>w</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow> <msup><mo>'</mo></msup></msubsup>
    <msqrt><mrow><munder><mo>∑</mo> <mrow><mi>i</mi><mo>,</mo><mi>k</mi></mrow></munder>
    <msup><mrow><msubsup><mi>w</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow>
    <msup><mo>'</mo></msup></msubsup></mrow> <mn>2</mn></msup> <mo>+</mo><mi>ε</mi></mrow></msqrt></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where <math alttext="epsilon"><mi>ϵ</mi></math> is a small constant value that
    prevents division by zero.
  prefs: []
  type: TYPE_NORMAL
- en: In the paper, the authors show how this simple change is enough to prevent water-droplet
    artifacts, while retaining control over the generated images via the style vectors
    and ensuring the quality of the output remains high.
  prefs: []
  type: TYPE_NORMAL
- en: Path Length Regularization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another change made to the StyleGAN architecture is the inclusion of an additional
    penalty term in the loss function—*this is known as path length regularization*.
  prefs: []
  type: TYPE_NORMAL
- en: We would like the latent space to be as smooth and uniform as possible, so that
    a fixed-size step in the latent space in any direction results in a fixed-magnitude
    change in the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To encourage this property, StyleGAN2 aims to minimize the following term,
    alongside the usual Wasserstein loss with gradient penalty:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="double-struck upper E Subscript w comma y Baseline left-parenthesis
    parallel-to bold upper J Subscript w Superscript down-tack Baseline y parallel-to
    Subscript 2 Baseline minus a right-parenthesis squared" display="block"><mrow><msub><mi>𝔼</mi>
    <mrow><mi>𝑤</mi><mo>,</mo><mi>𝑦</mi></mrow></msub> <msup><mfenced separators=""
    open="(" close=")"><msub><mfenced separators="" open="∥" close="∥"><msubsup><mi>𝐉</mi>
    <mi>𝑤</mi> <mi>⊤</mi></msubsup> <mi>𝑦</mi></mfenced> <mn>2</mn></msub> <mo>-</mo><mi>a</mi></mfenced>
    <mn>2</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Here, <math alttext="w"><mi>𝑤</mi></math> is a set of style vectors created
    by the mapping network, <math alttext="y"><mi>𝑦</mi></math> is a set of noisy
    images drawn from <math alttext="script upper N left-parenthesis 0 comma bold
    upper I right-parenthesis"><mrow><mi>𝒩</mi> <mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>𝐈</mi>
    <mo>)</mo></mrow></math> , and <math alttext="bold upper J Subscript w Baseline
    equals StartFraction normal partial-differential g Over normal partial-differential
    w EndFraction"><mrow><msub><mi>𝐉</mi> <mi>𝑤</mi></msub> <mo>=</mo> <mfrac><mrow><mi>∂</mi><mi>g</mi></mrow>
    <mrow><mi>∂</mi><mi>𝑤</mi></mrow></mfrac></mrow></math> is the Jacobian of the
    generator network with respect to the style vectors.
  prefs: []
  type: TYPE_NORMAL
- en: The term <math alttext="parallel-to bold upper J Subscript w Superscript down-tack
    Baseline y parallel-to Subscript 2"><msub><mfenced separators="" open="∥" close="∥"><msubsup><mi>𝐉</mi>
    <mi>𝑤</mi> <mi>⊤</mi></msubsup> <mi>𝑦</mi></mfenced> <mn>2</mn></msub></math>
    measures the magnitude of the images <math alttext="y"><mi>𝑦</mi></math> after
    transformation by the gradients given in the Jacobian. We want this to be close
    to a constant <math alttext="a"><mi>a</mi></math> , which is calculated dynamically
    as the exponential moving average of <math alttext="parallel-to bold upper J Subscript
    w Superscript down-tack Baseline y parallel-to Subscript 2"><msub><mfenced separators=""
    open="∥" close="∥"><msubsup><mi>𝐉</mi> <mi>𝑤</mi> <mi>⊤</mi></msubsup> <mi>𝑦</mi></mfenced>
    <mn>2</mn></msub></math> as the training progresses.
  prefs: []
  type: TYPE_NORMAL
- en: The authors find that this additional term makes exploring the latent space
    more reliable and consistent. Moreover, the regularization terms in the loss function
    are only applied once every 16 minibatches, for efficiency. This technique, called
    *lazy regularization*, does not cause a measurable drop in performance.
  prefs: []
  type: TYPE_NORMAL
- en: No Progressive Growing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another major update is in how StyleGAN2 is trained. Rather than adopting the
    usual progressive training mechanism, StyleGAN2 utilizes skip connections in the
    generator and residual connections in the discriminator to train the entire network
    as one. It no longer requires different resolutions to be trained independently
    and blended as part of the training process.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-12](#stylegan2_gen_dis) shows the generator and discriminator blocks
    in StyleGAN2.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1012.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-12\. The generator and discriminator blocks in StyleGAN2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The crucial property that we would like to be able to preserve is that the StyleGAN2
    starts by learning low-resolution features and gradually refines the output as
    training progresses. The authors show that this property is indeed preserved using
    this architecture. Each network benefits from refining the convolutional weights
    in the lower-resolution layers in the earlier stages of training, with the skip
    and residual connections used to pass the output through the higher-resolution
    layers mostly unaffected. As training progresses, the higher-resolution layers
    begin to dominate, as the generator discovers more intricate ways to improve the
    realism of the images in order to fool the discriminator. This process is demonstrated
    in [Figure 10-13](#stylegan2_contrib).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1013.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-13\. The contribution of each resolution layer to the output of the
    generator, by training time (adapted from [Karras et al., 2019](https://arxiv.org/pdf/1912.04958.pdf))
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Outputs from StyleGAN2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some examples of StyleGAN2 output are shown in [Figure 10-14](#stylegan2_output).
    To date, the StyleGAN2 architecture (and scaled variations such as StyleGAN-XL^([6](ch10.xhtml#idm45387004898624)))
    remain state of the art for image generation on datasets such as Flickr-Faces-HQ
    (FFHQ) and CIFAR-10, according to the benchmarking website [Papers with Code](https://oreil.ly/VwH2r).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-14\. Uncurated StyleGAN2 output for the FFHQ face dataset and LSUN
    car dataset (source: [Karras et al., 2019](https://arxiv.org/pdf/1912.04958.pdf))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Other Important GANs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore two more architectures that have also contributed
    significantly to the development of GANs—SAGAN and BigGAN.
  prefs: []
  type: TYPE_NORMAL
- en: Self-Attention GAN (SAGAN)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Self-Attention GAN (SAGAN)^([7](ch10.xhtml#idm45387004886752)) is a key
    development for GANs as it shows how the attention mechanism that powers sequential
    models such as the Transformer can also be incorporated into GAN-based models
    for image generation. [Figure 10-15](#sagan_attention) shows the self-attention
    mechanism from the paper introducing this architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-15\. The self-attention mechanism within the SAGAN model (source:
    [Zhang et al., 2018](https://arxiv.org/abs/1805.08318))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The problem with GAN-based models that do not incorporate attention is that
    convolutional feature maps are only able to process information locally. Connecting
    pixel information from one side of an image to the other requires multiple convolutional
    layers that reduce the size of the image, while increasing the number of channels.
    Precise positional information is reduced throughout this process in favor of
    capturing higher-level features, making it computationally inefficient for the
    model to learn long-range dependencies between distantly connected pixels. SAGAN
    solves this problem by incorporating the attention mechanism that we explored
    earlier in this chapter into the GAN. The effect of this inclusion is shown in
    [Figure 10-16](Images/#sagan_images).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-16\. A SAGAN-generated image of a bird (leftmost cell) and the attention
    maps of the final attention-based generator layer for the pixels covered by the
    three colored dots (rightmost cells) (source: [Zhang et al., 2018](https://arxiv.org/abs/1805.08318))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The red dot is a pixel that is part of the bird’s body, and so attention naturally
    falls on the surrounding body cells. The green dot is part of the background,
    and here the attention actually falls on the other side of the bird’s head, on
    other background pixels. The blue dot is part of the bird’s long tail and so attention
    falls on other tail pixels, some of which are distant from the blue dot. It would
    be difficult to maintain this long-range dependency for pixels without attention,
    especially for long, thin structures in the image (such as the tail in this case).
  prefs: []
  type: TYPE_NORMAL
- en: Training Your Own SAGAN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official code for training your own SAGAN using TensorFlow is available
    on [GitHub](https://oreil.ly/rvej0). Bear in mind that training a SAGAN to achieve
    the results from the paper requires a significant amount of computing power.
  prefs: []
  type: TYPE_NORMAL
- en: BigGAN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BigGAN,^([8](ch10.xhtml#idm45387004870736)) developed at DeepMind, extends the
    ideas from the SAGAN paper. [Figure 10-17](#biggan_examples) shows some of the
    images generated by BigGAN, trained on the ImageNet dataset at 128 × 128 resolution.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-17\. Examples of images generated by BigGAN (source: [Brock et al.,
    2018](https://arxiv.org/abs/1809.11096))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As well as some incremental changes to the base SAGAN model, there are also
    several innovations outlined in the paper that take the model to the next level
    of sophistication. One such innovation is the so-called *truncation trick*. This
    is where the latent distribution used for sampling is different from the <math
    alttext="z tilde script upper N left-parenthesis 0 comma bold upper I right-parenthesis"><mrow><mi>z</mi>
    <mo>∼</mo> <mi>𝒩</mi> <mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>𝐈</mi> <mo>)</mo></mrow></math>
    distribution used during training. Specifically, the distribution used during
    sampling is a *truncated normal distribution* (resampling values of <math alttext="z"><mi>z</mi></math>
    that have magnitude greater than a certain threshold). The smaller the truncation
    threshold, the greater the believability of generated samples, at the expense
    of reduced variability. This concept is shown in [Figure 10-18](#truncation).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-18\. The truncation trick: from left to right, the threshold is set
    to 2, 1, 0.5, and 0.04 (source: [Brock et al., 2018](https://arxiv.org/abs/1809.11096))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Also, as the name suggests, BigGAN is an improvement over SAGAN in part simply
    by being *bigger*. BigGAN uses a batch size of 2,048—8 times larger than the batch
    size of 256 used in SAGAN—and a channel size that is increased by 50% in each
    layer. However, BigGAN additionally shows that SAGAN can be improved structurally
    by the inclusion of a shared embedding, by orthogonal regularization, and by incorporating
    the latent vector <math alttext="z"><mi>z</mi></math> into each layer of the generator,
    rather than just the initial layer.
  prefs: []
  type: TYPE_NORMAL
- en: For a full description of the innovations introduced by BigGAN, I recommend
    reading the original paper and [accompanying presentation material](https://oreil.ly/vPn8T).
  prefs: []
  type: TYPE_NORMAL
- en: Using BigGAN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A tutorial for generating images using a pre-trained BigGAN is available on
    [the TensorFlow website](https://oreil.ly/YLbLb).
  prefs: []
  type: TYPE_NORMAL
- en: VQ-GAN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important type of GAN is the Vector Quantized GAN (VQ-GAN), introduced
    in 2020.^([9](ch10.xhtml#idm45387004838864)) This model architecture builds upon
    an idea introduced in the 2017 paper “Neural Discrete Representation Learning”^([10](ch10.xhtml#idm45387004834704))—namely,
    that the representations learned by a VAE can be discrete, rather than continuous.
    This new type of model, the Vector Quantized VAE (VQ-VAE), was shown to generate
    high-quality images while avoiding some of the issues often seen with traditional
    continuous latent space VAEs, such as *posterior collapse* (where the learned
    latent space becomes uninformative due to an overly powerful decoder).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first version of DALL.E, a text-to-image model released by OpenAI in 2021
    (see [Chapter 13](ch13.xhtml#chapter_multimodal)), utilized a VAE with a discrete
    latent space, similar to VQ-VAE.
  prefs: []
  type: TYPE_NORMAL
- en: By a *discrete latent space*, we mean a learned list of vectors (the *codebook*),
    each associated with a corresponding index. The job of the encoder in a VQ-VAE
    is to collapse the input image to a smaller grid of vectors that can then be compared
    to the codebook. The closest codebook vector to each grid square vector (by Euclidean
    distance) is then taken forward to be decoded by the decoder, as shown in [Figure 10-19](#vqvae).
    The codebook is a list of learned vectors of length <math alttext="d"><mi>d</mi></math>
    (the embedding size) that matches the number of channels in the output of the
    encoder and input to the decoder. For example, <math alttext="e 1"><msub><mi>e</mi>
    <mn>1</mn></msub></math> is a vector that can be interpreted as *background*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1019.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-19\. A diagram of a VQ-VAE
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The codebook can be thought of as a set of learned discrete concepts that are
    shared by the encoder and decoder in order to describe the contents of a given
    image. The VQ-VAE must find a way to make this set of discrete concepts as informative
    as possible so that the encoder can accurately *label* each grid square with a
    particular code vector that is meaningful to the decoder. The loss function for
    a VQ-VAE is therefore the reconstruction loss added to two terms (alignment and
    commitment loss) that ensure that the output vectors from the encoder are as close
    as possible to vectors in the codebook. These terms replace the the KL divergence
    term between the encoded distribution and the standard Gaussian prior in a typical
    VAE.
  prefs: []
  type: TYPE_NORMAL
- en: However, this architecture poses a question—how do we sample novel code grids
    to pass to the decoder to generate new images? Clearly, using a uniform prior
    (picking each code with equal probability for each grid square) will not work.
    For example in the MNIST dataset, the top-left grid square is highly likely to
    be coded as *background*, whereas grid squares toward the center of the image
    are not as likely to be coded as such. To solve this problem, the authors used
    another model, an autoregressive PixelCNN (see [Chapter 5](ch05.xhtml#chapter_autoregressive)),
    to predict the next code vector in the grid, given previous code vectors. In other
    words, the prior is learned by the model, rather than static as in the case of
    the vanilla VAE.
  prefs: []
  type: TYPE_NORMAL
- en: Training Your Own VQ-VAE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an excellent tutorial by Sayak Paul on training your own VQ-VAE using
    Keras available on the [Keras website](https://oreil.ly/dmcb4).
  prefs: []
  type: TYPE_NORMAL
- en: The VQ-GAN paper details several key changes to the VQ-VAE architecture, as
    shown in [Figure 10-20](#vqgan).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-20\. A diagram of a VQ-GAN: the GAN discriminator helps to encourage
    the VAE to generate less blurry images through an additional adversarial loss
    term'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Firstly, as the name suggests, the authors include a GAN discriminator that
    tries to distinguish between the output from the VAE decoder and real images,
    with an accompanying adversarial term in the loss function. GANs are known to
    produce sharper images than VAEs, so this addition improves the overall image
    quality. Notice that despite the name, the VAE is still present in a VQ-GAN model—the
    GAN discriminator is an additional component rather than a replacement of the
    VAE. The idea of combining a VAE with a GAN discriminator (VAE-GAN) was first
    introduced by Larsen et al. in their 2015 paper.^([11](ch10.xhtml#idm45387004808112))
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the GAN discriminator predicts if small patches of the images are
    real or fake, rather than the entire image at once. This idea (*PatchGAN*) was
    applied in the successful *pix2pix* image-to-image model introduced in 2016 by
    Isola et al.^([12](ch10.xhtml#idm45387004801680)) and was also successfully applied
    as part of *CycleGAN*,^([13](ch10.xhtml#idm45387004798080)) another image-to-image
    style transfer model. The PatchGAN discriminator outputs a prediction vector (a
    prediction for each patch), rather than a single prediction for the overall image.
    The benefit of using a PatchGAN discriminator is that the loss function can then
    measure how good the discriminator is at distinguishing images based on their
    *style*, rather than their *content*. Since each individual element of the discriminator
    prediction is based on a small square of the image, it must use the style of the
    patch, rather than its content, to make its decision. This is useful as we know
    that VAEs produce images that are stylistically more blurry than real images,
    so the PatchGAN discriminator can encourage the VAE decoder to generate sharper
    images than it would naturally produce.
  prefs: []
  type: TYPE_NORMAL
- en: Thirdly, rather than use a single MSE reconstruction loss that compares the
    input image pixels with the output pixels from the VAE decoder, VQ-GAN uses a
    *perceptual loss* term that calculates the difference between feature maps at
    intermediate layers of the encoder and corresponding layers of the decoder. This
    idea is from the 2016 paper by Hou et al.,^([14](ch10.xhtml#idm45387004793216))
    where the authors show that this change to the loss function results in more realistic
    image generations.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, instead of PixelCNN, a Transformer is used as the autoregressive part
    of the model, trained to generate sequences of codes. The Transformer is trained
    in a separate phase, after the VQ-GAN has been fully trained. Rather than use
    all previous tokens in a fully autoregressive manner, the authors choose to only
    use tokens that fall within a sliding window around the token to be predicted.
    This ensures that the model scales to larger images, which require a larger latent
    grid size and therefore more tokens to be generated by the Transformer.
  prefs: []
  type: TYPE_NORMAL
- en: ViT VQ-GAN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One final extension to the VQ-GAN was made by Yu et al. in their 2021 paper
    entitled “Vector-Quantized Image Modeling with Improved VQGAN.”^([15](ch10.xhtml#idm45387004783968))
    Here, the authors show how the convolutional encoder and decoder of the VQ-GAN
    can be replaced with Transformers as shown in [Figure 10-21](#vit_vqgan).
  prefs: []
  type: TYPE_NORMAL
- en: For the encoder, the authors use a *Vision Transformer* (ViT).^([16](ch10.xhtml#idm45387004780000))
    A ViT is a neural network architecture that applies the Transformer model, originally
    designed for natural language processing, to image data. Instead of using convolutional
    layers to extract features from an image, a ViT divides the image into a sequence
    of patches, which are tokenized and then fed as input to an encoder Transformer.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, in the ViT VQ-GAN, the nonoverlapping input patches (each of size
    8 × 8) are first flattened, then projected into a low-dimensional embedding space,
    where positional embeddings are added. This sequence is then fed to a standard
    encoder Transformer and the resulting embeddings are quantized according to a
    learned codebook. These integer codes are then processed by a decoder Transformer
    model, with the overall output being a sequence of patches that can be stitched
    back together to form the original image. The overall encoder-decoder model is
    trained end-to-end as an autoencoder.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-21\. A diagram of a ViT VQ-GAN: the GAN discriminator helps to encourage
    the VAE to generate less blurry images through an additional adversarial loss
    term (source: [Yu and Koh, 2022](https://ai.googleblog.com/2022/05/vector-quantized-image-modeling-with.html))^([17](ch10.xhtml#idm45387004774560))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with the original VQ-GAN model, the second phase of training involves using
    an autoregressive decoder Transformer to generate sequences of codes. Therefore
    in total, there are three Transformers in a ViT VQ-GAN, in addition to the GAN
    discriminator and learned codebook. Examples of images generated by the ViT VQ-GAN
    from the paper are shown in [Figure 10-22](#vit_vqgan_ex).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/gdl2_1022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-22\. Example images generated by a ViT VQ-GAN trained on ImageNet
    (source: [Yu et al., 2021](https://arxiv.org/pdf/2110.04627.pdf))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have taken a tour of some of the most important and influential
    GAN papers since 2017\. In particular, we have explored ProGAN, StyleGAN, StyleGAN2,
    SAGAN, BigGAN, VQ-GAN, and ViT VQ-GAN.
  prefs: []
  type: TYPE_NORMAL
- en: We started by exploring the concept of progressive training that was pioneered
    in the 2017 ProGAN paper. Several key changes were introduced in the 2018 StyleGAN
    paper that gave greater control over the image output, such as the mapping network
    for creating a specific style vector and synthesis network that allowed the style
    to be injected at different resolutions. Finally, StyleGAN2 replaced the adaptive
    instance normalization of StyleGAN with weight modulation and demodulation steps,
    alongside additional enhancements such as path regularization. The paper also
    showed how the desirable property of gradual resolution refinement could be retained
    without having to the train the network progressively.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how the concept of attention could be built into a GAN, with the
    introduction of SAGAN in 2018\. This allows the network to capture long-range
    dependencies, such as similar background colors over opposite sides of an image,
    without relying on deep convolutional maps to spread the information over the
    spatial dimensions of the image. BigGAN was an extension of this idea that made
    several key changes and trained a larger network to improve the image quality
    further.
  prefs: []
  type: TYPE_NORMAL
- en: In the VQ-GAN paper, the authors show how several different types of generative
    models can be combined to great effect. Building on the original VQ-VAE paper
    that introduced the concept of a VAE with a discrete latent space, VQ-GAN additionally
    includes a discriminator that encourages the VAE to generate less blurry images
    through an additional adversarial loss term. An autoregressive Transformer is
    used to construct a novel sequence of code tokens that can be decoded by the VAE
    decoder to produce novel images. The ViT VQ-GAN paper extends this idea even further,
    by replacing the convolutional encoder and decoder of VQ-GAN with Transformers.
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch10.xhtml#idm45387005226448-marker)) Huiwen Chang et al., “Muse: Text-to-Image
    Generation via Masked Generative Transformers,” January 2, 2023, [*https://arxiv.org/abs/2301.00704*](https://arxiv.org/abs/2301.00704).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch10.xhtml#idm45387005216528-marker)) Tero Karras et al., “Progressive
    Growing of GANs for Improved Quality, Stability, and Variation,” October 27, 2017,
    [*https://arxiv.org/abs/1710.10196*](https://arxiv.org/abs/1710.10196).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch10.xhtml#idm45387005140128-marker)) Tero Karras et al., “A Style-Based
    Generator Architecture for Generative Adversarial Networks,” December 12, 2018,
    [*https://arxiv.org/abs/1812.04948*](https://arxiv.org/abs/1812.04948).
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch10.xhtml#idm45387005090240-marker)) Xun Huang and Serge Belongie, “Arbitrary
    Style Transfer in Real-Time with Adaptive Instance Normalization,” March 20, 2017,
    [*https://arxiv.org/abs/1703.06868*](https://arxiv.org/abs/1703.06868).
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch10.xhtml#idm45387005019232-marker)) Tero Karras et al., “Analyzing and
    Improving the Image Quality of StyleGAN,” December 3, 2019, [*https://arxiv.org/abs/1912.04958*](https://arxiv.org/abs/1912.04958).
  prefs: []
  type: TYPE_NORMAL
- en: '^([6](ch10.xhtml#idm45387004898624-marker)) Axel Sauer et al., “StyleGAN-XL:
    Scaling StyleGAN to Large Diverse Datasets,” February 1, 2022, [*https://arxiv.org/abs/2202.00273v2*](https://arxiv.org/abs/2202.00273v2).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch10.xhtml#idm45387004886752-marker)) Han Zhang et al., “Self-Attention
    Generative Adversarial Networks,” May 21, 2018, [*https://arxiv.org/abs/1805.08318*](https://arxiv.org/abs/1805.08318).
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch10.xhtml#idm45387004870736-marker)) Andrew Brock et al., “Large Scale
    GAN Training for High Fidelity Natural Image Synthesis,” September 28, 2018, [*https://arxiv.org/abs/1809.11096*](https://arxiv.org/abs/1809.11096).
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch10.xhtml#idm45387004838864-marker)) Patrick Esser et al., “Taming Transformers
    for High-Resolution Image Synthesis,” December 17, 2020, [*https://arxiv.org/abs/2012.09841*](https://arxiv.org/abs/2012.09841).
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch10.xhtml#idm45387004834704-marker)) Aaron van den Oord et al., “Neural
    Discrete Representation Learning,” November 2, 2017, [*https://arxiv.org/abs/1711.00937v2*](https://arxiv.org/abs/1711.00937v2).
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch10.xhtml#idm45387004808112-marker)) Anders Boesen Lindbo Larsen et
    al., “Autoencoding Beyond Pixels Using a Learned Similarity Metric,” December
    31, 2015, [*https://arxiv.org/abs/1512.09300*](https://arxiv.org/abs/1512.09300).
  prefs: []
  type: TYPE_NORMAL
- en: ^([12](ch10.xhtml#idm45387004801680-marker)) Phillip Isola et al., “Image-to-Image
    Translation with Conditional Adversarial Networks,” November 21, 2016, [*https://arxiv.org/abs/1611.07004v3*](https://arxiv.org/abs/1611.07004v3).
  prefs: []
  type: TYPE_NORMAL
- en: ^([13](ch10.xhtml#idm45387004798080-marker)) Jun-Yan Zhu et al., “Unpaired Image-to-Image
    Translation using Cycle-Consistent Adversarial Networks,” March 30, 2017, [*https://arxiv.org/abs/1703.10593*](https://arxiv.org/abs/1703.10593).
  prefs: []
  type: TYPE_NORMAL
- en: ^([14](ch10.xhtml#idm45387004793216-marker)) Xianxu Hou et al., “Deep Feature
    Consistent Variational Autoencoder,” October 2, 2016, [*https://arxiv.org/abs/1610.00291*](https://arxiv.org/abs/1610.00291).
  prefs: []
  type: TYPE_NORMAL
- en: ^([15](ch10.xhtml#idm45387004783968-marker)) Jiahui Yu et al., “Vector-Quantized
    Image Modeling with Improved VQGAN,” October 9, 2021, [*https://arxiv.org/abs/2110.04627*](https://arxiv.org/abs/2110.04627).
  prefs: []
  type: TYPE_NORMAL
- en: '^([16](ch10.xhtml#idm45387004780000-marker)) Alexey Dosovitskiy et al., “An
    Image Is Worth 16x16 Words: Transformers for Image Recognition at Scale,” October
    22, 2020, [*https://arxiv.org/abs/2010.11929v2*](https://arxiv.org/abs/2010.11929v2).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([17](ch10.xhtml#idm45387004774560-marker)) Jiahui Yu and Jing Yu Koh, “Vector-Quantized
    Image Modeling with Improved VQGAN,” May 18, 2022, [*https://ai.googleblog.com/2022/05/vector-quantized-image-modeling-with.html*](https://ai.googleblog.com/2022/05/vector-quantized-image-modeling-with.html).
  prefs: []
  type: TYPE_NORMAL
