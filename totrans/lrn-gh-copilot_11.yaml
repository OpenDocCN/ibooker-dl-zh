- en: Chapter 10\. Extending Copilot’s Functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub Copilot is an amazingly useful tool. It can be made even more useful
    by extending its capabilities through integration with other tools. This includes
    ones you can write. The mechanisms for doing this are called *extensions*.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot extensions enhance the functionality of GitHub Copilot by tailoring
    it to specific use cases or environments. For example, extensions can integrate
    custom or third-party applications with Copilot through the chat interface. As
    an example, you can install a [Copilot Docker extension](https://oreil.ly/QS54S)
    and then ask questions via chat like “@Docker, how do I containerize this project?”
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll examine what extensions for GitHub Copilot are and how
    to find and work with public ones from the marketplace. Then we’ll progress to
    understanding details about the various types, how they work, and their advantages
    and disadvantages. And we’ll cover some details on simple, yet useful, implementation
    examples. But before we cover those topics, we need to clarify some possibly confusing
    terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot Extensions Versus VS Code Extensions for Copilot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extensions for Copilot’s functionality can be implemented for one of two different
    targets. They can be engineered to work on any platform where Copilot Chat is
    supported (IDEs, GitHub.com, etc.), independent of the platform. Or they can be
    targeted for VS Code to leverage its underlying functions and only run on that
    platform (or on another IDE if ported).
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ll use the terms *VS Code extensions for Copilot*
    or c*hat participants* when referring to the ones implemented via VS Code. For
    the *native* Copilot ones (implemented to be independent of the platform), we’ll
    use the shorter term *Copilot extensions*.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the extension’s functionality is surfaced through Copilot’s chat
    interface. VS Code extensions for Copilot simply utilize its functionality for
    both hosting and execution. Copilot extensions require a separately configured
    and dedicated GitHub App to bridge between the chat interface and the backend
    code.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be discussing the details of implementation and configuration for both
    types of extensions later in this chapter. That will include information on what
    GitHub Apps are and how they are used with Copilot extensions. But, first, let’s
    learn more about what Copilot extensions are in general.
  prefs: []
  type: TYPE_NORMAL
- en: Server-Based and Client-Based Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may be helpful to think of Copilot extensions as *server-based*, in the sense
    of needing to communicate back to the app running on the GitHub side to function
    (although that’s not an official description). Likewise, VS Code extensions for
    Copilot could be thought of as *client-based* since they function utilizing the
    APIs of the VS Code client where they are installed.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Copilot Extensions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copilot has a framework of APIs and lower-level capabilities that underlie its
    user-facing functionality. That framework can be used by third parties and users
    to extend Copilot’s capabilities. This framework allows other applications to
    provide their services through Copilot Chat directly to the user. As the user,
    you get the benefit of being able to invoke and converse with the other tooling,
    similar to the way you interact with the Copilot AI out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extensions have multiple use cases, as noted in Copilot’s [documentation](https://oreil.ly/B7yAU).
    They include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Querying documentation
  prefs: []
  type: TYPE_NORMAL
- en: Allowing Copilot Chat to query a third-party documentation service to find information
    about a specific topic.
  prefs: []
  type: TYPE_NORMAL
- en: AI-assisted coding
  prefs: []
  type: TYPE_NORMAL
- en: Using a third-party AI model to provide code suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: Data retrieval
  prefs: []
  type: TYPE_NORMAL
- en: A Copilot extension can allow Copilot Chat to query a third-party data service
    to retrieve information about a specific topic.
  prefs: []
  type: TYPE_NORMAL
- en: Action execution
  prefs: []
  type: TYPE_NORMAL
- en: Allowing Copilot Chat to execute a specific action, such as posting to a message
    board or updating a tracking item in an external system.
  prefs: []
  type: TYPE_NORMAL
- en: Think of using Copilot extensions as giving Copilot Chat additional knowledge
    of another application or set of data, and adding specialized skills that you
    can invoke to help when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot extensions are built to provide cross-platform compatibility, app management,
    and support. They work anywhere that chat does. They can be private, public and
    shareable, and listed on GitHub Marketplace, if desired. In fact, the marketplace
    is a good place to start learning about extensions and the public ones available
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Copilot Extensions from the Marketplace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can write your own extensions (as you’ll see later in this chapter), and
    organizations or companies can create *private* extensions. In addition, *public*
    extensions from third-party companies and organizations are already available.
    To see these, go to [GitHub Marketplace](https://github.com/marketplace) and select
    Copilot in the left column. [Figure 10-1](#copilot-extensions-on) shows the main
    screen for Copilot extensions in the marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. Copilot extensions on the marketplace
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From here, we’ll pick the PerplexityAI extension. This extension allows for
    gathering responses through real-time web searches. Clicking the link in the marketplace
    opens up the extension’s details page with information about what the extension
    is and what it can do ([Figure 10-2](#extension-main-page)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. Extension main page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Clicking the Add button (in the upper right) or scrolling to the bottom takes
    you to the section of the page where you can install the extension ([Figure 10-3](#extension-install-pag)).
    This one is free.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3\. Extension installation page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some extensions may require you to select the user or organization that will
    be authorized to use the extension. You can see an example of that if you choose
    to install the Docker extension ([Figure 10-4](#docker-extension-inst)). In the
    case of the PerplexityAI extension, its functionality is general search, so it
    is usable for all repos associated with the user who is installing it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-4\. Installing the Docker extension with the user or organization
    selected
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Most Copilot extensions get access to repositories and your account through
    the use of a *GitHub App*. These are basically backend applications installed
    and authorized in your GitHub account to work with your repositories. For Copilot
    extensions that use an app, the app serves as the bridge between the chat interface
    and the code that implements the extension’s functionality. The app provides the
    access and control layer between Copilot and the extension’s operations.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the app integration once you’ve done the initial install for the
    extension. You’ll be asked to authorize the associated GitHub App for the account
    by authenticating to GitHub. After authorizing, you’ll be taken to the configuration
    page for the installed app, as shown in [Figure 10-5](#perplexity-ais-githu1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1005.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-5\. PerplexityAI’s GitHub App configuration
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: On this page, you can select specific permissions for the app and/or specific
    repositories for the app to access. In the case of the app for the PerplexityAI
    extension, it simply applies to all repositories and does not have any specific
    permission requirements, so we are good to go. You can also suspend or uninstall
    the app from this page.
  prefs: []
  type: TYPE_NORMAL
- en: Changing App Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you later need to change the configuration settings for the app and are logged
    in, you can go to the [applications portion of your settings](https://oreil.ly/WOBZf)
    to modify an installed app’s configuration.
  prefs: []
  type: TYPE_NORMAL
- en: After the install and authorization steps are complete, start or restart any
    instances of applications where GitHub Copilot is active. Then, type the **`@`**
    sign and the extension’s name in the chat interface to start using the newly installed
    extension, as shown in [Figure 10-6](#invoking-the-perplexi).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1006.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-6\. Invoking the PerplexityAI app in chat
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first time you attempt to use the new extension via the app after restarting,
    you may get prompted to authorize it—either for the selected workspace or for
    all workspaces ([Figure 10-7](#authorization-for-wor)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-7\. Authorization for workspace
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is done in a similar manner to the initial authorization. Once the authorization
    is completed, you can pose your prompt again, and you should be able to get a
    response ([Figure 10-8](#perplexityai-response)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1008.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-8\. PerplexityAI response after authorization
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The number of public Copilot extensions is growing regularly. If they fit with
    an application or purpose you need, they can be a useful option. But if you need
    functionality that is not already available or need an integration more directly
    with your data or processes, you may want to consider developing and using your
    own Copilot extension. To understand more about that option, let’s first talk
    about the two *implementation* types of Copilot extensions that can exist.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Copilot Extension Implementation Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Copilot extensions can be implemented as one of two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Agent
  prefs: []
  type: TYPE_NORMAL
- en: An extension implemented as an agent serves as a full AI assistant. This means
    it can handle complex chat conversations, execute custom code, and return very
    tailored responses.
  prefs: []
  type: TYPE_NORMAL
- en: Skillsets
  prefs: []
  type: TYPE_NORMAL
- en: An extension implemented as a skillset can invoke one or more API endpoints
    behind the scenes to retrieve specific information or perform basic actions.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see examples of how to build each implementation type later in the chapter.
    But for now, let’s level-set on the general advantages and disadvantages of each.
  prefs: []
  type: TYPE_NORMAL
- en: Agents are the original type of Copilot extension and can provide the most extensive
    functionality if you need complex or custom processing and integration. They provide
    full control but also can be complex to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Skillsets make it easy to call other APIs or perform basic operations. They
    are simpler to implement while being more limited in what they can do and how
    much control they provide.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10-1](#comparison-of-copilot) compares the two implementation choices.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-1\. Comparison of Copilot extension types
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Copilot agents | Copilot skillsets |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Complexity | Requires more development effort to manage the entire user interaction
    flow response and response generation | Designed for easy integration with minimal
    setup |'
  prefs: []
  type: TYPE_TB
- en: '| Control | Provides full control over how requests are processed and responses
    are generated | Limited control over the user interaction, focus is on data retrieval
    and basic actions |'
  prefs: []
  type: TYPE_TB
- en: '| Use cases | Suitable for complex scenarios where you need to implement custom
    logic, integrate with other AI models, and manage conversation context | Straightforward
    tasks like fetching data from an external API or performing simple operations,
    |'
  prefs: []
  type: TYPE_TB
- en: '| Interfaces available | All (GitHub, IDEs) | All (GitHub, IDEs) |'
  prefs: []
  type: TYPE_TB
- en: '| Support | GitHub | GitHub |'
  prefs: []
  type: TYPE_TB
- en: Now that you understand these types, we can look at implementation. The first
    step in that process is making sure you are clear on some of the building blocks
    when you are assembling a Copilot extension.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling Building Blocks for Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Building blocks* are the components that need to be assembled to allow the
    extension to be accessed and function. At the core, these are the parts we need
    when working with a Copilot extension:'
  prefs: []
  type: TYPE_NORMAL
- en: A GitHub App with a specific endpoint that handles interactions between the
    extension and Copilot Chat.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A server process capable of hosting the backend and making endpoints available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A backend implementation that provides the functionality for the extension.
    This functionality can involve calls to the LLM along with integration with external
    tools, services, or APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 10-9](#overview-building-blocks) shows an overview of the building
    blocks we’ll be using to construct extensions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1009.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-9\. Overview of our building blocks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While GitHub apps and endpoint servers are required for agent and skillset extensions,
    those constructs are not unique to extensions. Next up is some clarification on
    how these are used for enabling extensions.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *GitHub App* is a tool that integrates with GitHub to extend GitHub’s functionality.
    It can do this in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Automating tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with APIs and webhooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the GitHub workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once created, installed, and registered, a GitHub App can act, independently
    of the user, as an authorized process to do the type of operations described in
    the preceding list. The steps involve registering the app (including any manual
    configuration, if needed), writing any needed code for the functionality, and
    then setting it up to run via a webhook, callback URL, etc. The App also serves
    as a gateway for getting authorization to access resources.
  prefs: []
  type: TYPE_NORMAL
- en: Callback URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of GitHub Copilot extensions, a *callback URL *is a URL that
    your custom Copilot extension provides to GitHub. The URL serves as the destination
    where the system will redirect the user after successfully authenticating with
    your extension. It acts like a *return address* once the authorization is complete.
  prefs: []
  type: TYPE_NORMAL
- en: The app for the PerplexityAI extension discussed previously is a good example.
    After installing the extension, go to your GitHub profile, and, from the left
    menu, under Integrations, choose Applications. You’ll then see the installed app
    for that extension ([Figure 10-10](#perplexityai-app-inst)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1010.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-10\. PerplexityAI app installed via extension
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Link to Install Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are logged into GitHub, you can also access the list of installed applications
    via [the Installations page](https://oreil.ly/WOBZf).
  prefs: []
  type: TYPE_NORMAL
- en: For existing GitHub extensions that are available publicly or in your organization
    or enterprise, the app is installed and configured automatically as part of the
    extension’s installation and authorization process. For extensions that you implement,
    you’ll need to create and configure a new app as a part of the overall process.
    We’ll cover the creation and configuration steps in more detail later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s talk about another important piece of how extensions work: the
    endpoint server.'
  prefs: []
  type: TYPE_NORMAL
- en: Endpoint Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In simplest terms, an agent or skillset Copilot extension can be viewed as an
    app that connects to an endpoint which handles interactions between the extension
    and Copilot Chat. The *endpoint* is the API for code that processes a chat input,
    does some processing, and then streams the output back to the chat. So, having
    the endpoint available is a key requirement for the flow.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of an extension that you install from the marketplace or an enterprise/organization
    site, the server will have already been set up and configured. If you are creating
    your own extension, you need to have it hosted on a publicly accessible server
    (e.g., via deploying on a cloud service or tunneling). For example, you can use
    a simple service such as [Cloudflare](https://oreil.ly/m1eVi) or [ngrok](https://ngrok.com)
    to expose a public URL for development and testing.
  prefs: []
  type: TYPE_NORMAL
- en: Both of those services require signing up and then logging in to utilize. Another
    option, if you are using VS Code or a GitHub Codespace for development and testing,
    is to expose the port and enable [port forwarding](https://oreil.ly/jgyG3). This
    method is free and suitable for use before converting to a formal location when
    the extension is made public. The key thing to remember if using this method is
    that the port’s visibility must be changed to `public` from the default `private`.
  prefs: []
  type: TYPE_NORMAL
- en: While the app and endpoint provide a way to exchange information with the chat
    interface, the real work happens with the backend code that implements the endpoint.
    The rest of this chapter is devoted to looking at and understanding how to do
    these implementations, starting with creating an extension as an agent.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an Extension as an Agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Copilot Agent is a custom tool embedded in a Copilot extension. Agents augment
    the capabilities of Copilot by allowing you to build and integrate custom features
    into the Copilot Chat interface.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot Agent Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html#ch04), we discussed Copilot’s built-in *Agent mode*
    that allows it to autonomously create code and terminal commands repeatedly to
    achieve a goal. In this chapter, we’re talking about agents again, but as separate
    functions built for use by extensions.
  prefs: []
  type: TYPE_NORMAL
- en: An agent implementation is appropriate when you need more control over how a
    request is processed or how a response is generated during a chat interaction.
    Agents can implement custom logic, integrate with other LLMs and the Copilot API,
    help with the context for chat conversations, and manage the interaction. But
    they are also more complex to create and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a Basic Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll see how to implement a basic but useful agent-based
    extension named `@meta-files`. Given a programming language in the prompt, our
    extension will generate example *.gitignore* and *.gitattributes* files. Alternatively,
    if the user provides an open source license name as part of the prompt, the extension
    will generate an example of the open source license. If the license has a placeholder
    for the user’s name and the current year, the extension will attempt to fill those
    in. Finally, the extension will also provide some guidance on when that type of
    license is useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of using the extension are shown in Figures [10-11](#extension-generating)
    and [10-12](#extension-generating-license). The prompts used to invoke the extension
    are shown in the upper right: `@meta-files Python` for [Figure 10-11](#extension-generating)
    and `@meta-files MIT` for [Figure 10-12](#extension-generating-license). The code
    is based on examples in the [Copilot extensions](https://oreil.ly/pWQcX) and can
    be found in [the book’s GitHub repository](https://oreil.ly/93ZY_).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1011.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-11\. Extension generating meta files for Python
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![](assets/lghc_1012.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-12\. Extension generating license information
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 10-13](#agent-extension-overview) shows at a high level how an agent
    extension works. I’ll have more to say about the individual pieces in the following
    sections.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1013.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-13\. Agent extension overview
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For the sake of brevity, we won’t dive into all the code here. We’ll just hit
    some key points. This example is written in JavaScript, but your extension can
    be written in nearly any modern language.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple example focuses on only two standard JavaScript files: [*package.json*](https://oreil.ly/vowZU)
    and [*index.js*](https://oreil.ly/k16Kn). Let’s take a look at the *package.json*
    contents first. The contents are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The structure of this is standard boilerplate for this type of file. We could
    have multiple other fields, but we’re keeping the example simple. The only pieces
    that warrant additional explanation are the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '[Express](https://expressjs.com) is a simple, backend web application framework.
    It’s designed to make it easy to build web apps and APIs with Node.js. When we
    create our agent extension, we are essentially creating a web app with an endpoint
    that is surfaced via the GitHub App.'
  prefs: []
  type: TYPE_NORMAL
- en: The other dependency we’re using, [Octokit](https://github.com/octokit), is
    a set of libraries provided by GitHub to let code interact with its REST and GraphQL
    APIs. It facilitates programmatically automating tasks and managing repositories
    and allows you to manipulate GitHub resources like pull requests and issues in
    code. We use it here to help get and work with a token for the user’s information.
  prefs: []
  type: TYPE_NORMAL
- en: The file with our main logic is *index.js*. You can look at the [file in GitHub](https://oreil.ly/GJW8z)
    if you want to see the entire code. The logic at the top of the file does the
    necessary imports, starts an Express app, posts a welcome message, and then goes
    into the main processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main processing uses Octokit to get a token, then moves into a standard
    cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the payload coming to us from the chat interface (via the GitHub App)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augmenting the prompt to tell the AI what we’re looking for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending the prompt off to the underlying LLM to get a response from the AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing the response to the chat interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The mechanics are fairly straightforward. The real magic happens where we augment
    the prompt to tell the AI what we’re looking for. Here’s the code for that part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We are adding content to the prompt we received from the chat to tell the LLM
    what we want it to look for and how to respond. This is the key to making an agent
    extension work—providing a detailed prompt to the LLM to tell it what we want
    it to pay attention to and the kind of output we require. Think of it as similar
    to interacting directly with a model like ChatGPT. The more details we can provide
    in our prompt conversation, the better response we can expect from the AI. The
    logic we use in our agent code to get the desired outcome really comes down to
    crafting a good prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting a Good Prompt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any number of resources are available with guidance on crafting a good prompt.
    Ultimately, the best prompt is the one that works as you intend in terms of parsing
    out the right information and returning a meaningful response.
  prefs: []
  type: TYPE_NORMAL
- en: One simple approach to this is trying out and then refining your prompt through
    the Copilot Chat interface (or an AI model) directly first. Once you have found
    a prompt that works, you can add it into your extension’s code.
  prefs: []
  type: TYPE_NORMAL
- en: With this basic setup, we have the core code we need for our extension. The
    necessary code for running this extension was created in a *nonproduction* environment.
    Taking this to production would require more implementation.
  prefs: []
  type: TYPE_NORMAL
- en: To help simplify the larger implementation for production, GitHub has made an
    SDK available that implements some of the core functionality needed for production
    extensions. At the time of this writing, the SDK is only an alpha release and
    only suitable for extensions implemented as agents. You can learn more about it
    in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: We need a server and an app to complete the implementation. Let’s look at how
    those can be set up.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a GitHub App for a Copilot Agent Extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we’re leveraging a GitHub Codespace to provide the runtime
    environment and server for the endpoint. Using a codespace is not something you
    would do in production use, but it simplifies the process quite a bit for our
    basic demo and testing scenarios. You could also use a service like ngrok if you
    preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for creating a codespace from a GitHub repository are outlined [in
    the documentation](https://oreil.ly/DCh4K). Once the codespace is started, you
    just need two commands to get the server going:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Node App and npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code here is a [node app](https://nodejs.org/en/about), and [npm](https://npmjs.com)
    is a node tool used to run it.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you’ll have a server running from the codespace on port 3000\.
    You need to take two steps prior to configuring a GitHub App for the extension.
    First, you need to make the port serving the endpoint *public* instead of *private*.
    To do that, switch to the Ports tab in the codespace, right-click the port in
    the list, and change its Port Visibility setting to Public, as shown in [Figure 10-14](#changing-port-to-publ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1014.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-14\. Changing the port to public
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Then copy the server address from the same location ([Figure 10-15](#copying-the-port-addr)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1015.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-15\. Copying the port address
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Behind the Scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to understand more about how the codespace is configured and how
    the server is started, the port selected, etc., take a look at the files [*.devcontainer/devcontainer.json*](https://oreil.ly/E9daL)
    and [*.vscode/launch.json*](https://oreil.ly/HTlM8) in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: With the code implemented for the extension agent and the server running, we’re
    now ready to complete the implementation of the extension itself by creating and
    configuring a corresponding GitHub App.
  prefs: []
  type: TYPE_NORMAL
- en: For Development and Test Purposes Only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our examples in this chapter, we are creating code, setting up simple servers,
    and implementing user-specific agents for demo purposes. To convert these examples
    to production-ready instances, you would need to add functionality for security,
    hosting, and more.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the app, log into GitHub with the same ID as the the one used to run
    the codespace. Then go to your developer settings and create a new app. The shortcut
    link for this is [*https://github.com/settings/apps/new*](https://github.com/settings/apps/new).
  prefs: []
  type: TYPE_NORMAL
- en: Next, fill in the required fields. The App Name should be a unique name. This
    is the name that you will use in the Copilot Chat interface to invoke your extension.
    For example, if you choose *my-app* for the name, you would use `@my-app` in the
    chat interface to invoke your extension.
  prefs: []
  type: TYPE_NORMAL
- en: For the Homepage URL field, you can provide a URL that goes to a web page about
    your app/extension if you have a page. If not, you can just put in the link to
    the GitHub repository for your extension or even just [*https://github.com*](https://github.com).
  prefs: []
  type: TYPE_NORMAL
- en: The Callback URL field is where you place the public URL address from the port
    you set as public in the codespace. This must be in place in order for your extension
    to send and receive responses for its code. You should also add `/callback` at
    the end of the URL.
  prefs: []
  type: TYPE_NORMAL
- en: For the examples we’re using here, we can disable any other selected options
    on this page, such as *Webhooks*. Next is the app’s visibility setting. You can
    make it accessible only to you for development and testing purposes. Later, you
    can enable public access when you’re ready to share. [Figure 10-16](#initial-agent-extensi)
    shows an example page with completed fields.
  prefs: []
  type: TYPE_NORMAL
- en: When you have completed this screen, you can click Create GitHub App to complete
    the registration.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1016.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-16\. Initial agent extension configuration
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At this point, you’ll need to generate a private key in order to install your
    app and sign access tokens. GitHub will provide you with a link to generate and
    download the key ([Figure 10-17](#generate-a-private-ke)). The key will then be
    automatically added to your app’s configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1017.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-17\. Generating a private key to install the app
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once you’ve created the app on the General page, you need to do a bit more configuration
    by using the selections on the left. On the Permissions & Events page, the only
    option you must set for dev/test purposes is in the Account Permissions section.
    Give Copilot Chat read-only permissions ([Figure 10-18](#adding-permissions-fo)).
    Then save those changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1018.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-18\. Adding permissions for Copilot Chat
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: On the Copilot-specific settings page, change the app type from Disabled to
    Agent (since we’re implementing our extension as an agent). Then, in the URL section,
    paste the public URL from your codespace.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly on this page, add content in the “Inference description” field. This
    information is used to provide a brief description of your agent to help users
    understand the purpose of the extension. The contents are displayed to users when
    they hover over the extension’s slug in the chat area. After completing this,
    you can save your changes. [Figure 10-19](#copilot-settings-for) shows the completed
    page.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1019.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-19\. Copilot settings for the app
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These are all the required fields you need to set up for the app to work with
    your agent. An Optional Features page only allows you to opt out of token expiration,
    and an Advanced page handles Danger Zone types of options for transferring ownership
    of the app, deleting the app, or making it public.
  prefs: []
  type: TYPE_NORMAL
- en: After completing the preceding steps, you can install the app in your personal
    or organizational account for testing. To do this, click the Install App page
    and follow the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The first time you attempt to use the extension, you’ll need to authorize access
    for it to continue ([Figure 10-20](#connecting-the-app-on)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1020.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-20\. Connecting the app on the first use
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After clicking the Connect button, you’ll need to authorize the app to access
    the relevant resources ([Figure 10-21](#authorizing-app)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1021.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-21\. Authorizing the app
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once the app is authorized, you’re ready to use the extension as shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to create an extension is to utilize the *skillsets* pattern. This
    implementation choice works well for allowing Copilot to get real-time targeted
    information or do simple API processing easily. But while it can be a simpler
    coding implementation, it does require a more complex app configuration. We’ll
    explore extensions implemented via skillsets in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an Extension via Skillsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While agents provide a powerful and flexible architecture for implementing Copilot
    extensions, they can be overkill. If all you need to do in response to a chat
    prompt is invoke a specific tool or call an API, you can implement your extension
    by using skillsets instead.
  prefs: []
  type: TYPE_NORMAL
- en: A single *skill* in Copilot is a tool that the model calls to do a specific
    task in response to a prompt—for example, calling an external API. A collection
    of up to five skills is called a *skillset*. These skillsets allow for integration
    of external services or custom API endpoints into the Copilot workflow, without
    the complexity of agents.
  prefs: []
  type: TYPE_NORMAL
- en: Skillsets are more lightweight and simpler than agents. They are a better architecture
    choice when you need to do simple, specific tasks without a lot of setup. They
    can automatically handle tasks like routing, prompt crafting, function evaluation,
    and response generation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-22](#overview-skillset-extension) shows at a high level how a skillset
    extension works. I’ll have more to say about the individual pieces in the following
    sections.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1022.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-22\. Overview of a skillset extension
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Performing a Basic Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example for the book, I’ve created a simple Copilot extension, implemented
    with skillsets, that allows you to do three basic operations for Go releases:'
  prefs: []
  type: TYPE_NORMAL
- en: Find out the latest release of Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find out the currently supported releases of Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine whether a given release of Go is supported or when it reached its
    end of life (EOL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this example lives in [book’s GitHub repository](https://oreil.ly/n13JY).
    To show an example of implementing an extension in a different language, the code
    for the `gover-ext` extension is written in Go. It is modeled after the Copilot
    [skillset extension example](https://oreil.ly/WWZxW).
  prefs: []
  type: TYPE_NORMAL
- en: 'A [*main.go file*](https://oreil.ly/8dk9j) *registers* handler functions for
    specific URL patterns related to each of the capabilities of the extension. The
    core logic is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For each of the handlers, we implement a separate function that invokes an API,
    checks for errors, and returns the desired results. For example, in the handler
    for getting the latest version—[LatestVersionGo](https://oreil.ly/TxXMz)—the key
    parts of the code are implemented as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we implement a structure to hold the version and make a call to the
    Go site’s API to get the latest version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing some error checking to make sure the call was successful, we buffer
    the response and then parse it to get the latest version and write that back to
    the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The handler for the supported versions query uses a similar approach. There’s
    a structure to hold the data and a call to a different API to get the raw information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then after some error checking to make sure the call was successful, and buffering
    the response, the results are parsed and converted into a single string that is
    written back to the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The flow for the other function to determine whether a version is supported
    or has reached EOL is similar.
  prefs: []
  type: TYPE_NORMAL
- en: Since the coding is pretty basic and makes no mention of the AI or inferences,
    you may be wondering how the prompts in Copilot Chat ultimately end up invoking
    the respective handlers. The secret is in the GitHub App configuration when you
    are creating an extension that uses skillsets.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a GitHub App for a Copilot Extension Using Skillsets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like extensions that are implemented as agents, extensions implemented as skillsets
    need a GitHub App to act as a bridge between Copilot’s chat interface and the
    underlying extension implementation. Much of the setup is similar to that done
    for agents, but we’ll cover some significant differences here. (For any other
    details on app setup and configuration, you can refer back to [“Configuring a
    GitHub App for a Copilot Agent Extension”](#configuring-github-app).)
  prefs: []
  type: TYPE_NORMAL
- en: The first difference is that, on the General page, you do not have to put in
    an extension-specific Callback URL. You will need a callback URL for authentication,
    but it can be a simple URL like [*https://github.com*](https://github.com).
  prefs: []
  type: TYPE_NORMAL
- en: The other changes for configuring the app, and the most significant ones, are
    done on the Copilot page. On this page, you need to set the App Type field to
    Skillset. Doing this will then bring up a section called Skill definitions ([Figure 10-23](#copilot-page-for-skil)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1023.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-23\. The Copilot page for setting up the skillset app
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The “Skill definitions” section is where the mapping happens from the prompt
    in chat to the handlers in the code. For each skill that we are handling in our
    code, we need to go through the process of adding a new skill. We’ll look at one
    as an example. The others follow the same pattern.
  prefs: []
  type: TYPE_NORMAL
- en: When you click the “Add new skill” button, you get a dialog with various fields
    to fill in, including Name, Inference description, URL, and Parameters ([Figure 10-24](#new-skill-definition)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1024.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-24\. New skill definition screen for the app
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the Name field, we put the name of the skill to be used by the model, and
    that is shown to the user when it is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: In the “Inference description” field, we are explaining to the model *what/when/how*
    this skill should be invoked. This description should be meaningful enough that
    the model can understand what is intended.
  prefs: []
  type: TYPE_NORMAL
- en: Think of this as the direct prompt that you might supply to the model if you
    wanted it to execute this skill. While we are using a simple prompt here, depending
    on what your skill does and how complex it is, you may want to define additional
    details. Examples could include expected inputs and outputs, especially if other
    skillsets are very similar. [Figure 10-25](#skill-definition-in-a) shows an example
    definition including the inference description matching one of the skills we are
    using.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1025.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-25\. Skill definition in the app
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Based on the prompt in the chat and how well the model can match it up with
    the Inference description, the process will invoke the endpoint specified in the
    URL field. This field is where you put the endpoint server address with the path
    specified in the extension code. In this case, since our extension code is looking
    for `latest-version-go` to know to invoke the handler for getting the latest Go
    version, we can put the API endpoint in this field with `latest-version-go` at
    the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'In production, we would have a designated public URL that this would be directed
    to. But if we’re using ngrok, a codespace, or something similar to serve this,
    we would put the public URL being served from those applications with *latest-version-go*
    appended. For an [ngrok](https://ngrok.com) instance, the entire URL would look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Localhost URL and ngrok
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*ngrok* lets you create secure tunnels from a public internet endpoint to a
    locally running service on your machine. This cross-platform tool lets you easily
    expose local web servers to the internet for testing and sharing without having
    to set up complex networking configurations.'
  prefs: []
  type: TYPE_NORMAL
- en: While you would typically start ngrok serving on localhost:8080, you cannot
    use localhost in the skill configuration because it is not publicly reachable.
    Instead, you’ll need to grab the actual public URL that ngrok is forwarding to
    localhost:8080.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were using a codespace, the URL might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The Parameters section is for defining the parameters of the skill in JSON.
    Since each of our skillsets keys off the prompt string, we can simply use the
    following in this field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the implementation completed and the app set up and configured,
    we can run the app in the same way as we did for the agent one. [Figure 10-26](#running-the-go-versio)
    shows an example of trying out the various skills from the extension. Notice the
    specific prompts that are being used: “@go-versions supported versions” and “@go-versions
    1.21” (as shown on the right).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1026.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-26\. Running the `go-versions` extension
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Extensions implemented as agents and skillsets provide maximum flexibility with
    their ability to be run in any of the integrated chat interfaces (GitHub, IDEs).
    Now that we’ve covered those, it’s time to look at the other alternative for adding
    capabilities into the IDE mentioned at the start of the chapter—VS Code extensions
    for Copilot.
  prefs: []
  type: TYPE_NORMAL
- en: Creating VS Code Extensions for Copilot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like Copilot extensions, VS Code extensions for Copilot provide additional capabilities
    for the user through Copilot Chat. Unlike Copilot extensions, VS Code extensions
    are implemented using the VS Code platform and APIs. Because of that implementation
    approach, the VS Code extensions have access to broad and deep VS Code functionality
    and can have tight integration. And they don’t require a separate GitHub App to
    use. The disadvantage is that you can’t use them in other non-IDE clients (like
    a chat interface in GitHub). [Table 10-2](#comparison2-of-copilot) shows an updated
    version of our earlier comparison table with an added column for VS Code extensions
    for Copilot.
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-2\. Comparison of Copilot extension types
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Copilot agents | Copilot skillsets | VS Code extensions for Copilot
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Complexity | Requires more development effort to manage the entire user interaction
    flow response and response generation | Designed for easy integration with minimal
    setup | Can be complex or simple, depending on VS Code APIs used |'
  prefs: []
  type: TYPE_TB
- en: '| Control | Provides full control over how requests are processed and how responses
    are generated | Limited control over the user interaction, focus is on data retrieval
    and basic actions | Most control as written for VS Code only |'
  prefs: []
  type: TYPE_TB
- en: '| Use cases | Suitable for complex scenarios where you need to implement custom
    logic, integrate with other AI models, and manage conversation context | Straightforward
    tasks like fetching data from an external API or performing simple operations
    | Tasks for working with code in the IDE and, optionally, providing additional
    commands for the participant |'
  prefs: []
  type: TYPE_TB
- en: '| Interfaces available | All (GitHub, IDEs) | All (GitHub, IDEs) | Limited
    to VS Code to get full advantage of all VS Code APIs |'
  prefs: []
  type: TYPE_TB
- en: '| Support | GitHub | GitHub | VS Code Team   |'
  prefs: []
  type: TYPE_TB
- en: Ultimately, what the user sees when we add a VS Code extension for Copilot is
    a new chat participant.
  prefs: []
  type: TYPE_NORMAL
- en: A *chat participant* is a domain expert that can answer questions about a specific
    topic, or perform specific tasks, when you are working with Copilot Chat in an
    IDE. We’ve discussed these before in the context of participants that come built-in
    with Copilot (see [Chapter 3](ch03.html#ch03)). For example, the built-in `@workspace`
    participant can respond relative to your entire VS Code workspace. To do this,
    it uses integrated tools such as semantic search and code indexes. Other examples
    we’ve discussed include `@termi⁠nal` and `@vscode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chat participants are invoked using the same `@identifier` syntax as for other
    extensions. Once a participant is invoked and passed a prompt, the code for the
    participant can use one of several approaches to handle the prompt. These include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling an AI model to interpret and respond
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forwarding the request to a backend service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using built-in logic and/or APIs to do the processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the underlying tight integration with VS Code, chat participants
    can return responses that include interactive elements like buttons, file trees,
    or progress updates. The chat participants can also provide follow-up suggestions
    and their own slash commands (as in previous examples, such as `/explain` and
    `/fix`) that are related to the participant’s domain.
  prefs: []
  type: TYPE_NORMAL
- en: In short, VS Code extensions for Copilot can provide rich *client-side* experiences.
    These extensions have access to the VS Code client context and interfaces on the
    frontend, while utilizing the power of Copilot on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Chat Participants in Other IDEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we are focusing on VS Code in this chapter, chat participants are available
    in other IDEs as well. Likewise, depending on the capabilities of the underlying
    IDE platform, VS Code extensions for Copilot could be ported to other IDEs where
    Copilot also runs.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation example we’ll use for this extension is an *API finder*.
    This extension, when installed in VS Code, allows the user to search for APIs
    that perform a certain function and stream back information in the chat interface
    on the APIs and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-27](#overview-vscode-extension) shows at a high level how a VS Code
    extension for Copilot works. I’ll have more to say about the individual pieces
    in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1027.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-27\. Overview of a VS Code extension
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 10-28](#using-the-apifinder-c) shows an example of using the extension’s
    user-facing functionality to find suitable APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1028.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-28\. Using the API Finder chat participant to find weather APIs
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This extension also has an additional command built-in that can be invoked as
    `/⁠exam⁠ples`. [Figure 10-29](#using-the-command-fro) shows an example usage of
    the command.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lghc_1029.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-29\. Using the command from our chat participant
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The code for the extension is located in [the book’s GitHub repository](https://oreil.ly/RUAtr).
    This one is implemented in TypeScript, with the main logic in the file [*src/extension.ts*](https://oreil.ly/VSPMM).
    This is based on the [example](https://oreil.ly/uRBxt) in the VS Code extension
    examples in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code starts off by importing dependencies from VS Code’s libraries. Then
    it defines the prompt to send to the model for the base functionality and the
    one to send for the code font command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are being explicit about how we want the LLM to process our query
    by supplying detailed prompts to use.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the Language for /examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example shown in [Figure 10-29](#using-the-command-fro), we
    specified the language `Go` as a second argument on the prompt to `@apifinder
    /⁠examples`. However, our prompt does not explicitly reference the programming
    language. This is a benefit of using the AI to handle the request. It infers additional
    context and meaning that we don’t have to explicitly call out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code at the bottom of the file instantiates the chat handler and adds an icon
    to it for use in chat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The main processing function selects the prompt (based on whether we want the
    core functionality or are using the `examples` command). It then combines the
    prompt and any previous messages, sends that to the model, and streams the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Testing this extension is as simple as opening the folder in VS Code, installing
    the dependencies with `npm install`, compiling the code via `npm run compile`,
    and then running the extension in a new VS Code instance.
  prefs: []
  type: TYPE_NORMAL
- en: Running a Participant with the Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably the simplest way to test your participant code is to load it into a
    VS Code instance, run the `npm` commands, and then use the Start Debugging option
    from the Run menu to spin up a new instance of VS Code. The new debug instance
    will have the participant installed and active, so you can use it in that instance’s
    chat interface. Instructions can be found in the repository’s [README file](https://oreil.ly/QXsC_).
  prefs: []
  type: TYPE_NORMAL
- en: As with the other types of extensions, you would want to make additional changes
    before rolling this out to production, such as ensuring that authentication works
    as needed. The [VS Code documentation](https://oreil.ly/UH18y) describes implementation
    in much more detail. You can also find information on publishing your finished
    extension to the [VS Code Marketplace](https://oreil.ly/HGZkA).
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub Copilot extensions and VS Code extensions for Copilot provide a way to
    augment the built-in capabilities of GitHub Copilot. These extensions are accessed
    via the Copilot Chat interface and the `@` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: The backend code for Copilot extensions can be architected in one of two ways.
    Agents are the most flexible option but also the most complex in general to implement.
    Extensions that use the skillsets architecture call one or more skills on the
    backend to get additional information. A skill can be as simple as an API call.
  prefs: []
  type: TYPE_NORMAL
- en: VS Code extensions for Copilot are architected on top of VS Code’s platform.
    They have full access to the underlying VS Code APIs and rely on VS Code to function.
    From a user-facing perspective, they provide VS Code chat participants, similar
    to the built-in ones like `@workspace` and `@terminal`.
  prefs: []
  type: TYPE_NORMAL
- en: The backend code for extensions can be implemented in several languages, including
    JavaScript, TypeScript, and Go. For extensions using the agent approach and JavaScript,
    GitHub has provided an early version of an SDK that can be used to simplify coding
    and help fill in production needs like authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot extensions (implemented as either agents or skillsets) require a GitHub
    App to bridge the connection between the Copilot chat interface and the backend
    code. While both use GitHub Apps, the configuration for each is different. Agents
    rely on a single callback URL defined in the app. Apps for skillsets require additional
    inference details in their configuration so that the AI can map the prompt to
    the correct skill API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Since Copilot extensions utilize a GitHub App, they can run in any Copilot chat
    interface, including in an IDE or on GitHub. In contrast, since VS Code extensions
    for Copilot rely on VS Code APIs and functions, they can only be used in that
    environment.
  prefs: []
  type: TYPE_NORMAL
