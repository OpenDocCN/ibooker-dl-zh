<html><head></head><body>
<div id="sbo-rt-content"><div class="readable-text" id="p1">
<h1 class="readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">6</span> </span><span class="chapter-title-text">Taking the next step with Next.js</span></h1>
</div>
<div class="introduction-summary">
<h3 class="introduction-header"><span class="CharOverride-1">This chapter covers</span></h3>
<ul>
<li class="readable-text" id="p2"><span class="CharOverride-2">Using Next.js to build a dashboard</span></li>
<li class="readable-text" id="p3"><span class="CharOverride-2">Using Material UI components</span></li>
<li class="readable-text" id="p4"><span class="CharOverride-2">Using WireMock to help stub our API calls</span></li>
</ul>
</div>
<div class="readable-text" id="p5">
<p>Until this point, we have worked through research spikes to explore creating and parsing an ACH file, creating a database, and generating APIs to access our data. In this final research spike, we’ll start working on our application dashboard. A dashboard is the user interface (UI) from which it is possible to upload and view files, view records, and obtain any other useful information. While there are plenty of options available for creating a UI, we have decided to go with Next.js as it is built on React, which is also very popular. However, since everything is powered by APIs, the UI could be swapped with Remix, Vue, Angular, or any other technology used in our company.</p>
</div>
<div class="readable-text intended-text" id="p6">
<p>Chapter 4 showed us how to take an API-driven design approach. While we have not built all our APIs by switching to the UI yet, we will begin to see what data we want (or need) to be returned as part of our APIs. By stubbing out the data fields, we can ensure our UI is making exactly the same calls required for the real APIs.</p>
</div>
<div class="readable-text" id="p7">
<h2 class="readable-text-h2"><span class="num-string">6.1</span> Getting started with Next.js</h2>
</div>
<div class="readable-text" id="p8">
<p>Getting started with Next.js is very easy, and we chose it partly because it is easy to get an application up and running, but also because it can grow to support any application we care to create. Next.js is a full stack React framework. React itself is a library used for building web interfaces. Although it is simple to learn, it does require a basic understanding of some common web technologies such as</p>
</div>
<ul>
<li class="readable-text" id="p9"><em>Hypertext Markup Language (HTML</em><em>)</em>—The standard markup language for building web pages</li>
<li class="readable-text" id="p10"><em>Cascading Style Sheets (CSS</em><em>)</em>—A way to describe how HTML elements should be displayed</li>
<li class="readable-text" id="p11"><em>Document Object Model (DOM</em><em>)</em>—Defines properties, methods, and events for HTML elements and allows languages such as JavaScript to add/change/remove HTML elements and attributes, as well as react to HTML events</li>
</ul>
<div class="readable-text" id="p12">
<p>React builds and improves on the listed web technologies by providing additional concepts to facilitate UI development. Some key concepts of React are</p>
</div>
<ul>
<li class="readable-text" id="p13"><em>Component</em><em>s</em>—Reusable and self-contained pieces of code that render parts of the UI. They are the building blocks of our application.</li>
<li class="readable-text" id="p14"><em>Stat</em><em>e</em>—Holds dynamic information within a component, which can be used to change its behavior and trigger rendering.</li>
<li class="readable-text" id="p15"><em>Hook</em><em>s</em>—Help manage the state and lifecycle of components.</li>
</ul>
<div class="readable-text" id="p16">
<p>All of this may seem like a lot to digest, especially if you are new to UI development. The truth is that you should still be able to walk through this research spike and gain a basic understanding of these concepts. </p>
</div>
<div class="readable-text intended-text" id="p17">
<p>So, how does Next.js fit into all of this? The React web site (<a href="https://react.dev"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/react.dev</span></a>) recommends using Next.js (or Remix) because it is a full-featured production-grade React framework. That means that Next.js comes with a lot of powerful features, such as</p>
</div>
<ul>
<li class="readable-text" id="p18">File-system-based routing that supports multiple layouts, nested routing, and error handling</li>
<li class="readable-text" id="p19">Client-side rendering (CSR) and server-side rendering (SSR), depending on the needs of the application </li>
<li class="readable-text" id="p20">Data fetching with <code>async</code>/<code>await</code> </li>
<li class="readable-text" id="p21">Support for multiple styling methods such as CSS Modules, Tailwind CSS, and CSS-in-JS</li>
<li class="readable-text" id="p22">Optimization for images, fonts, and scripts</li>
</ul>
<div class="readable-text" id="p23">
<p>To get started, we have to ensure that we have Node.js installed (<a href="https://nodejs.org/en"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/nodejs.org/en</span></a>) because we need access to its tools, beginning with the <code>npx</code> command. <code>npx</code> is a command line tool that helps simplify the running of <code>npm</code> (Node Package Manager) commands.</p>
</div>
<div class="readable-text intended-text" id="p24">
<p>We can execute <code>npx</code> <code>create-next-app@latest</code> to answer a few questions and then start the project with <code>npm</code> <code>run</code> <code>dev</code>. We should be able now to log in to http://localhost:3000 and see whether the default page comes up. Of course, the default page is a test to make sure we have our setup correctly. We want to develop a UI that allows a user to easily load files and review associated data. Usually, the business already has a design in mind that is based on existing standards. As we are not required to follow any particular design, a good option is to start using a sample template. There are plenty of options out there, but a great way to get started is by using the dashboard template provided by Material UI at <a href="https://mng.bz/Xx66"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/mng.bz/Xx66</span></a>. We pulled the template for MUI 5.x, which can be viewed at <a href="https://mng.bz/yWnq"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/mng.bz/yWnq</span></a>. As previously mentioned, we are not limited to this particular template, but it does provide us with a basic layout that we can quickly customize to create our final project. </p>
</div>
<div class="readable-text intended-text" id="p25">
<p>We recommend grabbing the TypeScript versions of the template as we will be using TypeScript throughout the project. TypeScript is a superset of JavaScript, which means that your existing JavaScript skills can be employed when using TypeScript. The benefit of TypeScript is that it adds explicit types to JavaScript (among other things). We believe that the explicit types help with the maintainability of the code over the long term by helping catch errors earlier during development. The long-term maintainability of the code is very important, especially when we consider how long our code may be out in the field, and given FinTech, that can be a long time! While we will get the basics of TypeScripts within this project, <em>Essential TypeScript 5</em> (2023, Manning) by Adam Freeman is a great resource, or you can check out the TypeScript tutorial available at <a href="https://www.typescripttutorial.net/"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/www.typescripttutorial.net/</span></a>.</p>
</div>
<div class="readable-text intended-text" id="p26">
<p>Before we can get the project started with the sample template, we need to ensure the dependencies are installed, which can be done with the command line in the next listing. This command installs a few requirements for Material UI, as well as for <code>recharts</code> (for our visualization needs) and <code>axios</code> (for making API calls). These packages were chosen because we have seen them in use in FinTech, and they have solid documentation to help us if we get stuck.</p>
</div>
<div class="browsable-container listing-container" id="p27">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.1<span class="CharOverride-3"> </span>Installing dependencies for our dashboard</h5>
<div class="code-area-container">
<pre class="code-area">npm install @mui/icons-material @mui/material @emotion/styled <br/>@emotion/react recharts axios #1</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Installs all the components needed for our dashboard</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p28">
<p>With that complete, the project should be up and running. Now we only need to customize the dashboard and add additional functionality.</p>
</div>
<div class="readable-text intended-text" id="p29">
<p>One of the ways we like to begin with new code is to dive right into it and start adding additional functionality or refactoring existing code. Let’s jump right in!</p>
</div>
<div class="readable-text" id="p30">
<h2 class="readable-text-h2"><span class="num-string">6.2</span> Creating an upload page</h2>
</div>
<div class="readable-text" id="p31">
<p>To help you get started, Next.js has extensive documentation and a great tutorial (<a href="https://nextjs.org/learn"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/nextjs.org/learn</span></a>) if you are completely new to React and web development. We begin with Next.js routing as we find it straightforward and just need to create a simple structure on our filesystem. We can easily create a page that will handle our ACH file uploads, as shown in the next listing. The page.tsx is key to having our web page displayed. TSX is a syntax extension for TypeScript that lets us write HTML-like markup inside the Typescript file. You may also see JSX pages in various tutorials, which are just the JavaScript equivalents.</p>
</div>
<div class="browsable-container listing-container" id="p32">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.2<span class="CharOverride-3"> </span>Our directory structure for the upload page</h5>
<div class="code-area-container">
<pre class="code-area">src/
├─ app/
│  ├─ uploads/            #1
│  │  ├─ page.tsx         </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">This file-based routing will cause Next.js to display page.tsx when we navigate to /uploads.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p33">
<p>We want to create a simple page that allows us to drag and drop files onto the page to be uploaded. We will stay away from the actual file uploading for now to focus on some of the design first. Given the structure from listing 6.2, we want to be able to navigate to http://localhost:3000/uploads, so we put a placeholder in page.tsx to ensure we can confirm things are working.</p>
</div>
<div class="browsable-container listing-container" id="p34">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.3<span class="CharOverride-3"> </span>Placeholder upload page</h5>
<div class="code-area-container">
<pre class="code-area">import Typography from "@mui/material/Typography";
import * as React from "react";

export default function Uploads() { #1
    return (
        &lt;Typography variant="h1"&gt;Hello, Uploads!
<span class="CharOverride-5">➥</span>&lt;/Typography&gt; #2
    )
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">We export a default function named Uploads.</span>
<br/>#2 
     <span class="CharOverride-4">Typography is a component from MUI that allows us to create text; here, we are using a variant of h1, which will give us a very long text, just like the HTML h1 tag would.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p35">
<p>With that in place, you should be able to navigate to the upload endpoint and see “Hello, Uploads!”</p>
</div>
<div class="readable-text" id="p36">
<h3 class="readable-text-h3"><span class="num-string">6.2.1</span> Testing our upload page</h3>
</div>
<div class="readable-text" id="p37">
<p>Even though we have not created a substantial page, let’s take a moment to see how we may test our pages in React. We will use Jest, a popular option for testing React apps. First, we need to install the required dependencies.</p>
</div>
<div class="browsable-container listing-container" id="p38">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.4<span class="CharOverride-3"> </span>Jest dependencies</h5>
<div class="code-area-container">
<pre class="code-area">npm install -D jest jest-environment-jsdom 
<span class="CharOverride-5">➥</span>@testing-library/react @testing-library/jest-dom ts-node #1</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Additional libraries to help support testing efforts</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p39">
<p>Next, we generate a basic configuration with <code>npm init jest@latest</code>. Then, we create a directory structure where we keep our tests.</p>
</div>
<div class="browsable-container listing-container" id="p40">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.5<span class="CharOverride-3"> </span>Test directory structure</h5>
<div class="code-area-container">
<pre class="code-area">__tests__/
├─ pages/
│  ├─ uploads.test.tsx</pre>
</div>
</div>
<div class="readable-text" id="p41">
<p>As shown in listing 6.5, the standard procedure is to create a high-level <code>__tests__</code> directory as the subdirectories do not matter then (you only want them to make sense). The uploads.test.tsx will store our actual test code. For now, we only want to ensure that our “Hello, Uploads!” text is displayed when the upload component is rendered. To accomplish that, the following listing shows the sample test.</p>
</div>
<div class="browsable-container listing-container" id="p42">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.6<span class="CharOverride-3"> </span>Simple Jest test</h5>
<div class="code-area-container">
<pre class="code-area">import { render, screen } from '@testing-library/react' #1
import Uploads from "@/app/uploads/page";  #1
import '@testing-library/jest-dom/jest-globals';  #1
import '@testing-library/jest-dom';  #1
import {describe, it} from "@jest/globals";  #1
import expect from "expect";  #1
#2
describe('Upload Page', () =&gt; {  
    it('renders a heading', () =&gt; { #3
        render(&lt;Uploads /&gt;)  #4

        const heading = screen.getByRole('heading', { level: 1 }) #5

        expect(heading).toBeDefined();  #6
        expect(heading).toHaveTextContent(/^Hello, Uploads!$/); #7
    })
})</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">The needed import statements for our test</span>
<br/>#2 
     <span class="CharOverride-4">The describe keyword allows us to group tests, which will be displayed under the title “Upload Page.”</span>
<br/>#3 
     <span class="CharOverride-4">The it keyword starts our test, along with the header of 'renders a heading’.</span>
<br/>#4 
     <span class="CharOverride-4">Renders our component</span>
<br/>#5 
     <span class="CharOverride-4">Retrieves the h</span>
<span class="CharOverride-6">1</span>
<span class="CharOverride-4"> tag using the ARIA role. The level parameter corresponds to the size of the header: h</span>
<span class="CharOverride-6">1</span>
<span class="CharOverride-4">, h2, and h3 would use levels </span>
<span class="CharOverride-6">1</span>
<span class="CharOverride-4">, 2, and 3, respectively.</span>
<br/>#6 
     <span class="CharOverride-4">Ensures the variable is defined</span>
<br/>#7 
     <span class="CharOverride-4">Uses a regular expression to ensure the text matches our expected text</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p43">
<p>The unit test defined in listing 6.6 should look somewhat familiar, given the test scripts we created in Python with <code>pytest</code>. Of course, the syntax may differ slightly, but the approach is the same. It would be interesting to revisit the <code>getByRole</code> method used to get our header tag and its contents. This method uses the role defined by the Accessible Rich Internet Applications (ARIA) standard. By creating our unit tests using <code>getByRole</code>, we take an accessibility-first approach to our web page design. Assistive technologies will be interacting with our web UI through ARIA tags.</p>
</div>
<div class="browsable-container figure-container" id="p44">
<img alt="A screenshot of a computer program  Description automatically generated" height="171" src="../Images/CH06_F01_Kardell.png" style="width: 100%; max-width: max-content;" width="351"/>
<h5 class="figure-container-h5"><span class="">Figure 6.1</span><span class=""> </span><span class="">Output from running our Jest test</span></h5>
</div>
<div class="readable-text intended-text" id="p45">
<p>If you are developing within an IDE such as JetBrains, WebStorm, or VS Code, you may be able to run these tests directly from within the IDE. Or, you could execute the command <code>npm</code> <code>run</code> <code>test</code> from the command line. Executing from the command line helps illustrate the importance of the <code>describe</code> and <code>it</code> keywords. As shown in listing 6.6, the <code>Upload</code> <code>Page</code> heading is pulled from the <code>describe</code> keyword. Each test defined by the <code>it</code> keywords is also represented, As shown in figure 6.1, these keywords keep our tests organized and the output readable.</p>
</div>
<div class="readable-text" id="p46">
<p>As we can see, unit testing is not just important for our backend Python code, but for the UI as well.</p>
</div>
<div class="readable-text intended-text" id="p47">
<p>If you have directly browsed the uploads page, you can see that we have lost our navigation bars for the page. The next section shows how to add them back.</p>
</div>
<div class="readable-text" id="p48">
<h2 class="readable-text-h2"><span class="num-string">6.3</span> Refactoring our navigation</h2>
</div>
<div class="readable-text" id="p49">
<p>As with any code we did not write ourselves, we need to poke around to get a feel for the layout and structure. Since we will be customizing the dashboard for our own needs, we need to understand how the dashboard navigates between components. This may take some detective work, but it’s worth it. After some digging, we find that the navigation for our pages is controlled by two components that we can see in our Dashboard.tsx—the <code>AppBar</code> and the <code>Drawer</code>. We can start by refactoring them into their own components. After we perform the refactoring, we can decide how to include them on subsequent pages.</p>
</div>
<div class="readable-text intended-text" id="p50">
<p>The first order of the business is to extract the <code>AppBar</code> tag from Dashboard.tsx and move it to its own component in <code>src/app/components/navigation/TopMenuBar.tsx</code>. The directory structure and naming conventions can be anything within reason. The component then contains the existing <code>AppBar</code> logic with a few updates to handle, regardless of whether the drawer is open or closed.</p>
</div>
<div class="browsable-container listing-container" id="p51">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.7<span class="CharOverride-3"> </span>Navigation menu bar</h5>
<div class="code-area-container">
<pre class="code-area">…
interface TopMenuBarProps {  #1
    toggleDrawer(): void;     #1
    drawerOpen: boolean;     
}
…
export default function TopMenuBar({toggleDrawer, drawerOpen}:
<span class="CharOverride-5">➥</span> TopMenuBarProps) {

    const [open, setOpen] = useState(drawerOpen); #2

    useEffect(() =&gt; {        #3
        setOpen(drawerOpen);  #3
    }, [drawerOpen]);        

    return (
    &lt;AppBar position="absolute" open={open}&gt; #4
…
&lt;IconButton edge="start" color="inherit" aria-label="open drawer"
<span class="CharOverride-5">➥</span> onClick={toggleDrawer}&gt; #5
…
    &lt;/AppBar&gt;
    );
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Defines an interface for the TopMenuBar that takes </span>
<span class="CharOverride-4">a function to execute when the button is clicked and </span>
<span class="CharOverride-4">a boolean to determine whether the drawer is open</span>
<br/>#2 
     <span class="CharOverride-4">Maintains the state </span>
<span class="CharOverride-4">in the component</span>
<br/>#3 
     <span class="CharOverride-4">When the parameter drawerOpen </span>
<span class="CharOverride-4">changes, updates the state accordingly</span>
<br/>#4 
     <span class="CharOverride-4">The AppBar’s open parameter is our internal state.</span>
<br/>#5 
     <span class="CharOverride-4">When the icon is clicked, the toggleDrawer function that was passed in is executed.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p52">
<p>We also want to do something similar for the sidebar navigation, so we refactor the <code>Drawer</code> tag from Dashboard.tsx, moving it to its own component.</p>
</div>
<div class="browsable-container listing-container" id="p53">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.8<span class="CharOverride-3"> </span>Sidebar navigation</h5>
<div class="code-area-container">
<pre class="code-area">…
interface SideBarNavProps {  #1
    toggleDrawer(): void;     #1
    drawerOpen?: boolean;     #1
}
…
export default function SideBarNav({toggleDrawer, drawerOpen}:
<span class="CharOverride-5">➥</span> SideBarNavProps) { #2

    const [open, setOpen] = useState(drawerOpen); #3

    useEffect(() =&gt; {         #4
        setOpen(drawerOpen);   #4
    }, [drawerOpen]);          #4

    return (
    &lt;Drawer variant="permanent" open={open}&gt; #5
…
            &lt;IconButton onClick={toggleDrawer}&gt; #6
…
    &lt;/Drawer&gt;
    );
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Defines an interface for the SideBarNavProps that takes </span>
<span class="CharOverride-4">a function to execute when the button is clicked and </span>
<span class="CharOverride-4">a boolean to determine whether the drawer is open</span>
<br/>#2 
     <span class="CharOverride-4">Unpacks the SideBarNavProps as part of the function call</span>
<br/>#3 
     <span class="CharOverride-4">Maintains the state </span>
<span class="CharOverride-4">in the component</span>
<br/>#4 
     <span class="CharOverride-4">When the parameter drawerOpen changes, </span>
<span class="CharOverride-4">updates the state accordingly</span>
<br/>#5 
     <span class="CharOverride-4">Our open state is used to determine the Drawer state.</span>
<br/>#6 
     <span class="CharOverride-4">When the icon is clicked, the toggleDrawer function that was passed in is executed.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p54">
<p>We can then use these components in the Dashboard.tsx as shown in the next listing.</p>
</div>
<div class="browsable-container listing-container" id="p55">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.9<span class="CharOverride-3"> </span>Updated Dashboard.tsx</h5>
<div class="code-area-container">
<pre class="code-area">…    
const [open, setOpen] = useState(true);  #1
const toggleDrawer = () =&gt; {      #2
    setOpen(!open);                #2
};                                 #2
…
       &lt;TopMenuBar toggleDrawer={toggleDrawer}
<span class="CharOverride-5">➥</span> drawerOpen={open} /&gt; #3
       &lt;SideBarNav toggleDrawer={toggleDrawer} #3
<span class="CharOverride-5">➥</span> drawerOpen={open} /&gt;  #3
… #3</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Stores the state of the drawer</span>
<br/>#2 
     <span class="CharOverride-4">Creates an arrow function named toggleDrawer we </span>
<span class="CharOverride-4">call to set the open state</span>
<br/>#3 
     <span class="CharOverride-4">Uses our refactored components which accept a function to show/hide the drawer and the current state of the drawer</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p56">
<p>Working through this refactoring exercise introduced us to Material UI and Next.js. In addition, we are now obviously able to include these components in our upload page, which was our original goal. While we have refactored the code, there is some noticeable duplication handling regarding whether the drawer is open. With the way we have it at the moment, we will need to duplicate the <code>open</code> state and <code>toggleDrawer</code> function in each component we choose to use them in, which is less than ideal since they will always need to be used together.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p57">
<h5 class="callout-container-h5 readable-text-h5">Navigation component challenge</h5>
</div>
<div class="readable-text" id="p58">
<p>While there may be the occasional need to duplicate code, we probably do not need or want to do it in this case. There are a few ways we may want to handle this (maybe we do not want to break out the <code>AppBar</code> and <code>Drawer</code> elements). If we refactor them into a single component, we would only have to import that single component. Or perhaps, since we have them broken apart already, can we just wrap them into a single component? The goal of this exercise is to eliminate the need to duplicate the <code>open</code> state and <code>toggleDrawer</code> function in every component.</p>
</div>
</div>
<div class="readable-text" id="p59">
<h2 class="readable-text-h2"><span class="num-string">6.4</span> Converting recent order to recent ACH uploads</h2>
</div>
<div class="readable-text" id="p60">
<p>Now that we dipped our toes into some Next.js, let’s take a look at reworking the <code>Recent</code> <code>Order</code> component to list our recent ACH uploads instead. As always, we are looking to work in short development cycles. This means we first use the hardcoded data that is part of the template and update it to fit our needs. Then, we replace the hardcoded data with a mocked API call. The template has a function to create the rows of data, as shown in the next listing.</p>
</div>
<div class="browsable-container listing-container" id="p61">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.10<span class="CharOverride-3"> </span><code>createData</code> function</h5>
<div class="code-area-container">
<pre class="code-area">function createData(       #1
  id: number,              
  date: string,            
  name: string,            
  shipTo: string,          
  paymentMethod: string,   
  amount: number,          
) {                        
  return { id, date, name, shipTo, paymentMethod, amount }; #2
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">The existing parameters </span>
<span class="CharOverride-4">we need to update</span>
<br/>#2 
     <span class="CharOverride-4">The existing return statement we need to update</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p62">
<p>We repurpose this code to include fields that we want to see when viewing loaded files for the day. For now, we can imagine that we would like to see the date the file was loaded (possibly the time as well), the name of the file, and both the credit/debit amounts for the file. The required updates are shown in the next listing.</p>
</div>
<div class="browsable-container listing-container" id="p63">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.11 Updated<span class="CharOverride-3"> </span><code>createData</code> function</h5>
<div class="code-area-container">
<pre class="code-area">function createData(      #1
    id: number,            #1
    date: string,          #1
    name: string,          #1
    creditAmount: number,  #1
    debitAmount: number,   #1
) {
    return { id, date, name, creditAmount, debitAmount }; #2
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Updates parameters for createData. We do not necessarily need to worry about the data types </span>
<span class="CharOverride-4">at this point. We just use the standard types of number and string. We could define the date as </span>
<span class="CharOverride-4">a Date type but that is unnecessary at this point.</span>
<br/>#2 
     <span class="CharOverride-4">Updated return statement</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p64">
<p>Next, we create our rows of data with the new amounts. Note that we have two amount fields, and whenever we have amounts, we want to include a variety of them to ensure the data will display as desired (determined by the stakeholders in the project). Depending on the API and datatype we use, there could be some look and feel problems with the UI when displaying amounts. Therefore, listing 6.12 shows data we are passing, and we want to be sure we hit some of the edge cases such as</p>
</div>
<ul>
<li class="readable-text" id="p65">Trailing zero, which will likely be thrown out when using a numeric datatype</li>
<li class="readable-text" id="p66">Dollar amounts greater than $999 to see a separator (such as a comma) for the amount</li>
</ul>
<div class="browsable-container listing-container" id="p67">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.12<span class="CharOverride-3"> </span>Sample data</h5>
<div class="code-area-container">
<pre class="code-area">createData(
    1,
    '03/20/2023',  #1
    'sample1.ach',
    1866.90, #2
    1234.10  
)</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Returns a date; this may come through from the API as a timestamp we’ll need to handle.</span>
<br/>#2 
     <span class="CharOverride-4">Ensures our numeric values cover some of the use cases we outlined</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p68">
<p>Depending on the API, you may be receiving a formatted amount, in which case, you obviously do not need to worry about the mentioned problems. However, when we design APIs, we usually try to keep the formatting to a minimum and not enforce formatting/locale specifics unless necessary. So, we favor returning <code>1000.0</code> for $1,000.00 because, depending on the location, we may use a space and/or decimal to separate numbers. Of course, use cases differ from one company to another and one project to another. In our situation, we are in the unique position of having control over both the UI and the backend, which means we could return our amount exactly how we want it displayed and just put it directly onto the page.</p>
</div>
<div class="readable-text intended-text" id="p69">
<p>Although unlikely to be a problem with this application, localization (L10n) may be a concern to us since ACH deals with US-based financial institutions, which is why we favor the unformatted amounts being returned from the API. Perhaps we plan for our dashboard to be abstract enough to be easily adapted to SEPA or BECS, so we need to ensure flexibility in our application.</p>
</div>
<div class="readable-text intended-text" id="p70">
<p>Next, we update the table to display the updated rows. We take the data stored in <code>rows</code> and use the <code>map</code> function to take each row and create our table rows.</p>
</div>
<div class="browsable-container listing-container" id="p71">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.13<span class="CharOverride-3"> </span>Updated table</h5>
<div class="code-area-container">
<pre class="code-area">&lt;Table size="small"&gt;
   &lt;TableHead&gt;
      &lt;TableRow&gt;
         &lt;TableCell&gt;Date&lt;/TableCell&gt;                       #1
         &lt;TableCell&gt;Filename&lt;/TableCell&gt;                    #1
         &lt;TableCell align="right"&gt;Credit Total&lt;/TableCell&gt;  #1
         &lt;TableCell align="right"&gt;Debit Total&lt;/TableCell&gt;   #1
      &lt;/TableRow&gt;
   &lt;/TableHead&gt;
   &lt;TableBody&gt;
      {rows.map((row) =&gt; (          #2
         &lt;TableRow key={row.id}&gt;    #3
            &lt;TableCell&gt;{row.date}&lt;/TableCell&gt; #4
            &lt;TableCell&gt;{row.name}&lt;/TableCell&gt; 
            &lt;TableCell align="right"&gt;         #5
               {`${row.creditAmount}`}         #5
            &lt;/TableCell&gt;                       #5
            &lt;TableCell align="right"&gt;          #5
               {`${row.debitAmount}`}          #5
            &lt;/TableCell&gt;                       #5
         &lt;/TableRow&gt;
      ))}
   &lt;/TableBody&gt;
&lt;/Table&gt;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">The updated </span>
<span class="CharOverride-4">table headers</span>
<br/>#2 
     <span class="CharOverride-4">We use map to create a new array of &lt;TableRow&gt; tags for each element.</span>
<br/>#3 
     <span class="CharOverride-4">Each table row contains a key property.</span>
<br/>#4 
     <span class="CharOverride-4">Using our row data </span>
<span class="CharOverride-4">for date and name</span>
<br/>#5 
     <span class="CharOverride-4">We display the amount fields as-is to see how they look.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p72">
<p>At this point, if we view our web page, we should notice that we are experiencing the problems we mentioned—truncating the trailing zero and missing a thousands separator, as shown in figure 6.2.</p>
</div>
<div class="readable-text" id="p73">
<p>We could accomplish some basic formatting by using <code>toFixed</code> and a hardcoded dollar sign, as in listing 6.14.</p>
</div>
<div class="browsable-container figure-container" id="p74">
<img alt="A white background with black lines  Description automatically generated" height="247" src="../Images/CH06_F02_Kardell.png" style="width: 100%; max-width: max-content;" width="878"/>
<h5 class="figure-container-h5"><span class="">Figure 6.2</span><span class=""> </span><span class="">Unformatted credit and debit totals</span></h5>
</div>
<div class="browsable-container listing-container" id="p75">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.14<span class="CharOverride-3"> </span>Basic formatting</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">&lt;TableCell align="right"&gt;
   {<strong>`$</strong>${row.creditAmount<strong>.toFixed(2)</strong>}<strong>`</strong>}     #1
&lt;/TableCell&gt;                                 #1
&lt;TableCell align="right"&gt;                    #1
   {<strong>`$</strong>${row.debitAmount<strong>.toFixed(2)</strong>}<strong>`</strong>}        #1
&lt;/TableCell&gt;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Performs some initial formatting on the amounts, forcing the use of the dollar sign and ensuring we see two decimal places by using toFixed(2)</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p76">
<p>This code gets us basic formatting with only the thousands separator. Instead of having to remember to format currency everywhere, which can lead to inconsistencies and lock us into a locale, let’s define a function we can call whenever we want to format a currency. Not only will this provide consistency in our presentation of currencies, but it should also allow us to find places where we are displaying currencies in our code (should we ever need to).</p>
</div>
<div class="readable-text intended-text" id="p77">
<p>To accomplish this, we will be using <code>Intl.NumberFormat,</code> which not only can format currencies for different locations but also for other units of measurements such as mph/kh and liter/gallon. The following listing shows our simple exported function that wraps <code>Intl.NumberFormat</code>.</p>
</div>
<div class="browsable-container listing-container" id="p78">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.15<span class="CharOverride-3"> </span>Wrapper for <code>Intl.NumberFormat</code></h5>
<div class="code-area-container">
<pre class="code-area">export function formatCurrency(value: number,  #1
           currency: string = "USD", #2
           locale: string = 'en-US'): string {  #3
    return new Intl.NumberFormat(locale, { #4
        style: 'currency',                  #4
        currency: currency                  #4
    }).format(value);                       #4
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">The function takes </span>
<span class="CharOverride-4">in a number.</span>
<br/>#2 
     <span class="CharOverride-4">Different currencies can be passed in but default to USD.</span>
<br/>#3 
     <span class="CharOverride-4">Locale can be controlled as well, defaulting to en-US.</span>
<br/>#4 
     <span class="CharOverride-4">The actual work is done by Intl.NumberFormat that we style as currency.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p79">
<p>We can also create some Jest tests to ensure we understand how this code functions, as well as confirm that we are seeing the expected formatting. The following listing shows example Jest tests we may want to use to confirm formatting is taking place. </p>
</div>
<div class="browsable-container listing-container" id="p80">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.16<span class="CharOverride-3"> </span>Jest tests for our <code>formatCurrency</code> routine</h5>
<div class="code-area-container">
<pre class="code-area">import {describe, it} from "@jest/globals";               #1
import expect from "expect";                               #1
import {formatCurrency} from "@/app/utils/CurrencyUtils"; 

describe('Formatting Currency', () =&gt; {              #2
    it('Has trailing zeros', () =&gt; {          #3
        const result = formatCurrency(1.0)     #3
 #3
        expect(result).toBe('$1.00')           #3
    })                                         #3

    it('Default currency is USD', () =&gt; {    #4
        const result = formatCurrency(1.1)    #4
 #4
        expect(result).toBe('$1.10')          #4
    })                                        #4

    it('Has comma separator', () =&gt; {          #5
        const result = formatCurrency(1000.0)   #5
 #5
        expect(result).toBe('$1,000.00')        #5
    })                                          #5

    it('Has comma separators for large numbers', () =&gt; {  #6
        const result = formatCurrency(1000000.0)           #6
 #6
        expect(result).toBe('$1,000,000.00')               #6
    })            #6

    it('German formatting', () =&gt; {   #7
        const result = formatCurrency(1000000.0, 'EUR', 'de-DE')   #8
 #8
        expect(result).toBe('1.000.000,00\u00A0€')       #8
    })                                                   #8
})</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Imports the </span>
<span class="CharOverride-4">necessary functions</span>
<br/>#2 
     <span class="CharOverride-4">Uses describe to group the tests together</span>
<br/>#3 
     <span class="CharOverride-4">Ensures the trailing zeroes are not dropped</span>
<br/>#4 
     <span class="CharOverride-4">Ensures the </span>
<span class="CharOverride-4">defaults are taken</span>
<br/>#5 
     <span class="CharOverride-4">Checks that a </span>
<span class="CharOverride-4">comma is included</span>
<br/>#6 
     <span class="CharOverride-4">Checks that multiple commas are added</span>
<br/>#7 
     <span class="CharOverride-4">Tests out German formatting in euros. The \u00A0 is a Unicode notation for no-break space.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p81">
<p>After confirming our tests run successfully, we can replace our table cells that called <code>toFixed(2)</code> with a call to our new <code>formatCurrency</code> routine.</p>
</div>
<div class="browsable-container listing-container" id="p82">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.17<span class="CharOverride-3"> </span>Using the new <code>formatCurrency</code> function</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">&lt;TableCell align="right"&gt;                #1
   {{<strong>formatCurrency(</strong>row.creditAmount<strong>)</strong>}}   #1
&lt;/TableCell&gt;                             
&lt;TableCell align="right"&gt;
   {{<strong>formatCurrency(</strong>row.debitAmount<strong>)</strong>}}
&lt;/TableCell&gt;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Replaces the manual formatting with a call to our new function</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p83">
<p>Figure 6.3 shows our amounts formatted exactly the way we wanted it, with commas and two significant digits after the decimal.</p>
</div>
<div class="browsable-container figure-container" id="p84">
<img alt="A white background with black lines  Description automatically generated" height="256" src="../Images/CH06_F03_Kardell.png" style="width: 100%; max-width: max-content;" width="866"/>
<h5 class="figure-container-h5"><span class="">Figure 6.3</span><span class=""> </span><span class="">Formatted credit and debit totals</span></h5>
</div>
<div class="readable-text" id="p85">
<p>It is often easier to use an existing component as a starting point and customize it to meet our needs. After our customizations, we have a working component capable of displaying our uploaded ACH files to the user.</p>
</div>
<div class="readable-text" id="p86">
<h2 class="readable-text-h2"><span class="num-string">6.5</span> Mocking our ACH uploads data</h2>
</div>
<div class="readable-text" id="p87">
<p>In the previous section, we customized our component to fit our particular use case of viewing recent ACH file uploads. However, we used hardcoded values, and while that helped us get a feel for the fields we need, it is not very useful for anything other than mocking up the UI. We have a database that we will want to retrieve this data from, but we are not quite there yet in terms of building APIs. As an intermediate step, let’s add the API call but have it retrieve mocked data instead of actually hitting the endpoint. Mocking data not only lets us get started quickly, but also has a variety of other uses such as for testing edge cases, simulating bad data, and other scenarios. So, learning about mocking data will have long-lasting benefits beyond this example.</p>
</div>
<div class="readable-text intended-text" id="p88">
<p>Why would we choose to do something like this? The reality is that projects can span multiple people, teams, departments, and even companies. It is entirely possible that we may be assigned to work on the UI, while the APIs and backend code are being developed in parallel. This type of parallel development is often going on when we are trying to bring our product to market as fast as possible, and we cannot wait for the APIs and backend to be finished before we start working on the frontend. Or perhaps, we need to call a third-party API, but contract negotiations are still ongoing, and we do not have access to the API. </p>
</div>
<div class="readable-text intended-text" id="p89">
<p>In these cases, a tool such as WireMock can allow our code to make the same API call but return a predefined response. We could also use this tool to obtain error responses or edge case data that we may not have readily available, which can help us test our code.</p>
</div>
<div class="readable-text" id="p90">
<h3 class="readable-text-h3"><span class="num-string">6.5.1</span> Adding WireMock to Docker</h3>
</div>
<div class="readable-text" id="p91">
<p>We add WireMock to our project in the same manner—by creating a Dockerfile first and then referencing it in our docker-compose.yml, as shown in the following two listings. The needed Dockerfile does not have much in it and could be contained in the docker-compose.yml, but we prefer to keep the docker-compose.yml as short as possible.</p>
</div>
<div class="browsable-container listing-container" id="p92">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.18<span class="CharOverride-3"> </span>Dockerfile for WireMock</h5>
<div class="code-area-container">
<pre class="code-area">FROM wiremock/wiremock:latest-alpine

ENTRYPOINT ["/docker-entrypoint.sh",
<span class="CharOverride-5">➥</span> "--global-response-templating", "--disable-gzip",
<span class="CharOverride-5">➥</span> "--verbose"]</pre>
</div>
</div>
<div class="readable-text" id="p93">
<p>Notice that in listing 6.19, we have introduced volumes to our WireMock service definition. These volumes exist on the local file system and are made available by mapping them to a directory in the container. Similar to the way ports are mapped, we specify the host directory first and then the directory it should map to in the container. WireMock allows us to specify stub mappings and file definition stubs (more on this later). Using volumes will allow us to make changes to the mappings without the need to build repeatedly. While a Dockerfile allows the <code>VOLUME</code> keyword where we could specify volumes, the recommended approach is to use the docker-compose.yml file because it allows for a separation of duties between building (Dockerfile) and runtime (docker-compose.yml).</p>
</div>
<div class="readable-text intended-text" id="p94">
<p>How about using <code>COPY</code> commands in the Dockerfile to move our mappings to the container? That would be another option to use if we were interested in building an image containing mappings that we would then distribute to our team. However, in this case, we are only interested in working with these mappings locally, and we do not need to rebuild our container whenever we want to utilize an updated mapping.</p>
</div>
<div class="browsable-container listing-container" id="p95">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.19<span class="CharOverride-3"> </span>Updates to docker-compose.yml</h5>
<div class="code-area-container">
<pre class="code-area">  wiremock:
    build:
      context: ./wiremock
      dockerfile: Dockerfile
    volumes:                                       #1
      - ./wiremock/__files:/home/wiremock/__files   #1
      - ./wiremock/mappings:/home/wiremock/mappings
    ports:
      - 8081:8080</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Map locations on our </span>
<span class="CharOverride-4">filesystem to our container</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p96">
<p>With that complete, we can start our Docker containers again and navigate over to http://localhost:8081/__admin/, where we should receive a response similar to the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p97">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.20<span class="CharOverride-3"> </span>WireMock admin response</h5>
<div class="code-area-container">
<pre class="code-area">{
  "mappings" : [ ],
  "meta" : {
    "total" : 0
  }
}</pre>
</div>
</div>
<div class="readable-text" id="p98">
<p>This code confirms that we indeed have WireMock up and running. Perhaps not unsurprisingly, we do not have any mappings defined yet. So, let’s tackle that in the next section.</p>
</div>
<div class="readable-text" id="p99">
<h3 class="readable-text-h3"><span class="num-string">6.5.2</span> Setting up mappings in WireMock</h3>
</div>
<div class="readable-text" id="p100">
<p>WireMock is a powerful tool, and we only scratch the surface in this section. However, it should be enough to get us started, and we can always investigate its additional features as we need more functionality (remember our YAGNI principle from chapter 3). We are primarily interested in stubbing out mock responses so that when our UI makes an API call, we are returning some meaningful data. We start by creating a simple stub in the <code>./wiremock/mappings</code> directory named hello_world.json. The name is not extremely important at this point. The next listing shows the contents of the file.</p>
</div>
<div class="browsable-container listing-container" id="p101">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.21<span class="CharOverride-3"> </span>Our first stub</h5>
<div class="code-area-container">
<pre class="code-area">{
    "request": {
        "method": "GET",
        "url": "/api/v1/hello/world"
    },
    "response": {
        "status": 200,
        "body": "Hello World!",
        "headers": {
            "Content-Type": "text/plain"
        }
    }
}</pre>
</div>
</div>
<div class="readable-text" id="p102">
<p>If we try to access http://localhost:8081/api/v1/hello/world, we receive a response such as <code>No</code> <code>response</code> <code>could</code> <code>be</code> <code>served</code> <code>as</code> <code>there</code> <code>are</code> <code>no</code> <code>stub</code> <code>mappings</code> <code>in</code> <code>this</code> <code>WireMock</code> <code>instance</code>. What gives? We need to make an empty <code>POST</code> call to http://localhost:8081/__admin/mappings/reset for WireMock to be able to pick up our changes. There are some Postman samples associated with this text that can get you started. After that call, you should be able to access the endpoint again and see “Hello, World!” Furthermore, if you request the mappings from http://localhost:8081/__admin/, you will see something similar to the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p103">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.22<span class="CharOverride-3"> </span>WireMock admin response with our new stub</h5>
<div class="code-area-container">
<pre class="code-area"><span>{</span>
<span>    "mappings": [</span>
<span>        {</span>
<span>            "id": "ac60ce7e-63f4-417e-894b-3e25ad496c42",</span>
<span>            </span>"request": {
                "url": "/api/v1/hello/world",
                "method": "GET"
            },
            "response": {
                "status": 200,
                "body": "Hello World!",
                "headers": {
                    "Content-Type": "text/plain"
                }
            },
            "uuid": "ac60ce7e-63f4-417e-894b-3e25ad496c42"
        }
    ],
    "meta": {
        "total": 1
    }
}</pre>
</div>
</div>
<div class="readable-text" id="p104">
<p>That should be painless. Now, let’s look at how we might want to mock our response to obtain the information for uploaded ACH files. We should already have a good idea of the fields we want to return because we have already used hardcoded data when building the UI. So, we will use that data and create ach_files_response.json in the <code>__files</code> directory this time. By defining responses in the <code>__files</code> directory, it will save us from complicating our mappings and allow other APIs to reuse responses as necessary. A response sample is shown in the next listing, and we can use as much or as little data as we want.</p>
</div>
<div class="browsable-container listing-container" id="p105">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.23<span class="CharOverride-3"> </span>Sample ACH response body</h5>
<div class="code-area-container">
<pre class="code-area">[
    {                                                   #1
        "id": "45bc2000-0a14-4c0a-ae7f-938b3fdab575",    #1
        "date": "03/01/2024",                            #1
        "filename": "sample.ach",                        #1
        "creditTotal": 312.40,                           #1
        "debitTotal": 100.20                             #1
    },                                                   #1
…
]</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Sample JSON that contains our test data</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p106">
<p>Now that we have the contents of the response defined, we need to define a mapping for it. The mapping is similar to what we have already seen, except that we now specify the <code>bodyFileName</code> in the response with the filename of ach_files_response.json we defined before.</p>
</div>
<div class="browsable-container listing-container" id="p107">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.24<span class="CharOverride-3"> </span>ACH response mapping</h5>
<div class="code-area-container">
<pre class="code-area">{
    "request": {
        "method": "GET",         #1
        "url": "/api/v1/files"   #2
    },
    "response": {
        "status": 200,           #3
        "headers": {                           #4
            "Content-Type": "application/json"  #4
        },                                     
        "bodyFileName": "ach_files_response.json"  #5
    }
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">The request will only execute on a GET.</span>
<br/>#2 
     <span class="CharOverride-4">Further refines the mapping with the URL</span>
<br/>#3 
     <span class="CharOverride-4">The response will be </span>
<span class="CharOverride-4">a status code 200.</span>
<br/>#4 
     <span class="CharOverride-4">Defines any headers </span>
<span class="CharOverride-4">that are needed</span>
<br/>#5 
     <span class="CharOverride-4">Uses bodyFileName and specifies a name in the __files directory to return</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p108">
<p>With that defined, we just need to refresh our mappings for the changes to take effect. We can use multiple methods, and they are listed in the order of their impact on the overall environment (from least to most impactful):</p>
</div>
<ol>
<li class="readable-text" id="p109">The Admin API can be restarted to reload the mappings.</li>
<li class="readable-text" id="p110">Restart the container.</li>
<li class="readable-text" id="p111">Restart our Docker compose instance completely.</li>
</ol>
<div class="readable-text" id="p112">
<p>Once the mappings have been refreshed, navigating to http://localhost:8081/api/v1/files will show the response. Figure 6.4 illustrates the response using Postman, which provides some highlighting/formatting of the output and allows us to check returned headers easily.</p>
</div>
<div class="readable-text" id="p113">
<p>WireMock is a powerful tool, and we only scratched its surface. For now, it is enough to get us going with building the UI. Next, we look at how to make requests to the backend.</p>
</div>
<div class="readable-text" id="p114">
<h3 class="readable-text-h3"><span class="num-string">6.5.3</span> Accessing endpoints with axios</h3>
</div>
<div class="readable-text" id="p115">
<p>The first thing we need to do, if not done already, is ensure axios is installed with <code>npm</code> <code>install</code> <code>axios</code>. After that, we can import it into our components as needed and get to work!</p>
</div>
<div class="readable-text intended-text" id="p116">
<p>Now we can open the RecentAchUploads.tsx, remove the <code>createData</code> function, and clear out our test data since we will be retrieving our data from the WireMock instance. Instead of hardcoded data, we will define our rows to be an array of <code>AchUploads</code> (listing 6.25).</p>
</div>
<div class="browsable-container figure-container" id="p117">
<img alt="A screenshot of a computer  Description automatically generated" height="355" src="../Images/CH06_F04_Kardell.png" style="width: 100%; max-width: max-content;" width="850"/>
<h5 class="figure-container-h5"><span class="">Figure 6.4</span><span class=""> </span><span class="">Response from our </span><span class=""><code>/api/v1/files</code></span><span class=""> endpoint as viewed in Postman</span></h5>
</div>
<div class="browsable-container listing-container" id="p118">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.25<span class="CharOverride-3"> </span>Preparing our component to receive data</h5>
<div class="code-area-container">
<pre class="code-area">…
import {useState} from "react";
…
interface AchUpload {         #1
    id: number;                #1
    date: string;              #1
    name: string;              #1
    creditAmount: number;      #1
    debitAmount: number;       #1
}                              #1

export default function RecentAchUploads() {

    const [rows, setRows] = useState&lt;AchUpload[]&gt;([]);  #2
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Defines a structure for our data so we can type it appropriately</span>
<br/>#2 
     <span class="CharOverride-4">Our rows data will be stored in an array of type ACHUpload.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p119">
<p>Now, we can make our request to populate data. </p>
</div>
<div class="browsable-container listing-container" id="p120">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.26<span class="CharOverride-3"> </span>Making an API call with axios</h5>
<div class="code-area-container">
<pre class="code-area">useEffect(() =&gt; {   #1
   axios.get('http://localhost:8081/api/v1/files') #2
   .then(response =&gt; {              #3
      console.log(`Response data #3
<span class="CharOverride-5">➥</span> ${JSON.stringify(response.data)}`);   #3
         setRows(response.data);      #3
      })                              #3
   .catch(error =&gt; {                 #4
         console.log(error);         
   });
}, []);                              #5</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">useEffect is a perfect React function for making API calls.</span>
<br/>#2 
     <span class="CharOverride-4">Uses axios to get </span>
<span class="CharOverride-4">our files listing</span>
<br/>#3 
     <span class="CharOverride-4">Handles the returned Promise by displaying the data and setting rows to the returned data</span>
<br/>#4 
     <span class="CharOverride-4">Logs any problems to the console</span>
<br/>#5 
     <span class="CharOverride-4">The empty array [] tells React to execute this only once.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p121">
<p>Usually, we recommend that these API calls are offloaded and called from a single location instead of being embedded in the components, but for now, it is okay to have them inside the component. For instance, we often create <code>api</code> folder or equivalent where these functions can be imported from. This allows the API calls to be easily accessed from multiple locations. </p>
</div>
<div class="readable-text intended-text" id="p122">
<p>However, our more immediate concern is that we have a hardcoded URL pointed to the localhost (http://localhost:8081), which will certainly change when we deploy the Dashboard to Docker. So for the time being, let’s take advantage of Next.js to store our variables, and then, we’ll be able to configure them for Docker easily. Thus, we create an .env.local file.</p>
</div>
<div class="browsable-container listing-container" id="p123">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.27<span class="CharOverride-3"> </span>Our .env.local file</h5>
<div class="code-area-container">
<pre class="code-area">NEXT_PUBLIC_API_URL=http://localhost:8081/api/v1</pre>
</div>
</div>
<div class="readable-text" id="p124">
<p>We can now update our code to use the environment variable in our URL.</p>
</div>
<div class="browsable-container listing-container" id="p125">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.28<span class="CharOverride-3"> </span>Updated API call</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">    useEffect(() =&gt; {
<strong>        const apiUrl = process.env.NEXT_PUBLIC_API_URL ?? ''; </strong>#1
        axios.get(<strong>`${apiUrl}</strong>/files<strong>`</strong>)       #2</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Returns the environment variable or sets it to the empty string when undefined</span>
<br/>#2 
     <span class="CharOverride-4">Updates the axios call to use the new apiUrl</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p126">
<p>With this code, we can test our API and still see the sample files we are returning from WireMock. We are now able to change the URL our APIs hit when we are building our Docker containers.</p>
</div>
<div class="readable-text" id="p127">
<h2 class="readable-text-h2"><span class="num-string">6.6</span> Expanding the UI with an ACH batch view</h2>
</div>
<div class="readable-text" id="p128">
<p>Now that you understand these pieces, let’s take a look at combining Next.js, Recharts, Axios, and WireMock to create a view of ACH batches. On the dashboard, we would like to be able to click one of the file names presented to view the batches for that file. The view will display a scatterplot and provide the ability to display more details about the batches for each company in the ACH file, as shown in figure 6.5. Providing information on the characteristics of the batches (in this case their size based on their amount and number of entries) can help us start putting controls in place for tasks such as fraud detection and risk management in the future as we expand the application. The scatterplot allows us to easily spot batches with larger dollar amounts or with higher item counts. Eventually, if we were to mix in historical data, we could then analyze patterns for these companies and highlight unusual activity patterns.</p>
</div>
<div class="browsable-container figure-container" id="p129">
<img alt="" height="660" src="../Images/CH06_F05_Kardell.png" style="width: 100%; max-width: max-content;" width="872"/>
<h5 class="figure-container-h5"><span class="">Figure 6.5</span><span class=""> </span><span class="">An ACH batch view</span></h5>
</div>
<div class="readable-text" id="p130">
<h3 class="readable-text-h3"><span class="num-string">6.6.1</span> Defining our WireMock data for the ACH batch view</h3>
</div>
<div class="readable-text" id="p131">
<p>Our JSON data will essentially be an array of arrays. We also know that there can be multiple batches in an ACH file. Each batch has an associated company, and the company may have multiple batches in a file. We want to have the batches returned and grouped by the company. So, something like the following listing should work.</p>
</div>
<div class="browsable-container listing-container" id="p132">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.29<span class="CharOverride-3"> </span>Sample ACH batch data</h5>
<div class="code-area-container">
<pre class="code-area">{
    "batches" : [         #1
        {
            "companyName": "Foodyum",  #2
            "companyBatches": [        #3
                {
                    "batchId": "de444a20-d303-4b72-8d8d-48af7a58630d", #4
                    "batchNumber": "1",                                 #5
                    "recordCount": 680,                                 #5
                    "totalDebitAmount": 500.00,                         #5
                    "totalCreditAmount": 1000.25   #5
                },
                {
                    "batchId": "57e38258-b0d9-414a-80ff-8c59f2a4a357",        
                    "batchNumber": "2",
                    "recordCount": 120,
                    "totalDebitAmount": 500.00,
                    "totalCreditAmount": 500.25
                }
            ]
        },
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">We return an array of all batches </span>
<span class="CharOverride-4">in a file grouped by company.</span>
<br/>#2 
     <span class="CharOverride-4">The company name </span>
<span class="CharOverride-4">of each batch is present.</span>
<br/>#3 
     <span class="CharOverride-4">An array of all batches for a company called companyBatches</span>
<br/>#4 
     <span class="CharOverride-4">Multiple JSON objects containing our batch data</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p133">
<p>We define some batches we are going to associate with the stubbed data we used for the file. Specifically, we want to return this data when someone queries an API endpoint such as <code>/api/v1/files/{fileId}/batches</code>. As we saw in WireMock, we could define hardcoded paths for all the <code>fileId</code>s we were interested in. However, that would result in a lot of mappings. Instead, we can dynamically match these fields using templating and return specific responses for each. We define ach_files_batches.json in the following listing. Note that we use <code>urlPathTemplate</code> and specify <code>{fileId}</code>. Then we also use <code>{{request.path.fileId}}</code> in the <code>bodyFileName</code> of the response, which allows us to extract the dynamic UUID we expect to receive and use it in a response we would then define in the <code>__files</code> directory.</p>
</div>
<div class="browsable-container listing-container" id="p134">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.30<span class="CharOverride-3"> </span>WireMock templating example</h5>
<div class="code-area-container">
<pre class="code-area">{
    "request": {
        "method": "GET",
        "urlPathTemplate": "/api/v1/files/{fileId}/batches"  #1
    },
    "response": {
        "status": 200,
        "headers": {
            "Content-Type": "application/json"
        },
        "bodyFileName": "ach_files_batches
<span class="CharOverride-5">➥</span>{{request.path.fileId}}.json" #2
    }
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Uses urlPathTemplate to allow the use of parameters</span>
<br/>#2 
     <span class="CharOverride-4">The request.path.fileId references the variable </span>
<span class="CharOverride-4">defined in the urlPathTemplate.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p135">
<p>With all said, we would have the ability to define specific responses to API calls. Figure 6.6 illustrates this concept better. Note that we are not actually saving anything into WireMock. We are using canned responses we have prepopulated in the WireMock <code>__files</code> directory.</p>
</div>
<div class="browsable-container figure-container" id="p136">
<img alt="A screenshot of a diagram  Description automatically generated" height="536" src="../Images/CH06_F06_Kardell.png" style="width: 100%; max-width: max-content;" width="864"/>
<h5 class="figure-container-h5"><span class="">Figure 6.6</span><span class=""> </span><span class="">WireMock sequence</span></h5>
</div>
<div class="readable-text" id="p137">
<p>Now that we are able to return data, we can define a component that can display it.</p>
</div>
<div class="readable-text" id="p138">
<h3 class="readable-text-h3"><span class="num-string">6.6.2</span> Updating the dashboard to take us to the batches screen</h3>
</div>
<div class="readable-text" id="p139">
<p>We update the RecentAchUploads.tsx so that the filename becomes a link.</p>
</div>
<div class="browsable-container listing-container" id="p140">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.31<span class="CharOverride-3"> </span>Updated <code>RecentAchUploads</code></h5>
<div class="code-area-container">
<pre class="code-area">&lt;TableCell&gt;
   &lt;Link onClick={() =&gt;                      #1
      route.push(`/fileDetails/${row.id}`)}&gt;  #1
         {row.filename}                      
   &lt;/Link&gt;
&lt;/TableCell&gt;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Updates the text to be a link that will use the file ID</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p141">
<p>The <code>fileDetails</code> screen takes the UUID of the file, which will help drive the resulting queries. Next.js uses file-based routing that lets us define the URL using a simple folder structure. In this case, including the UUID as part of the URL is denoted by a directory in square brackets. The following listing is the folder structure we need to create.</p>
</div>
<div class="browsable-container listing-container" id="p142">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.32<span class="CharOverride-3"> </span>Folder structure for the file details page</h5>
<div class="code-area-container">
<pre class="code-area">src/
├─ app/
│  ├─ fileDetails/
│  │  ├─ [id]/          #1
│  │  │  ├─ page.tsx</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">The square brackets denote a parameter on the URL we can access.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p143">
<p>The <code>[id]</code> is a dynamic parameter in our URL. For example, with this structure, we should be able to navigate to URLs such as <code>/fileDetails/0854b018-c5ce-4e00-8a4f-d268a1a85aa2</code> or <code>/fileDetails/d11fb49c-4a07-4b96-88cc-db1fc7277bfa</code>, assuming those were valid UUIDs for our ACH files.</p>
</div>
<div class="readable-text" id="p144">
<h3 class="readable-text-h3"><span class="num-string">6.6.3</span> Displaying batch details</h3>
</div>
<div class="readable-text" id="p145">
<p>The page.tsx will contain the logic to retrieve the batch information and display it.</p>
</div>
<div class="browsable-container listing-container" id="p146">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.33<span class="CharOverride-3"> </span>Batch details</h5>
<div class="code-area-container">
<pre class="code-area">…
export interface AchBatchInfo {           #1
    companyName: string;                   #2
    companyBatches: AchBatchDetails[];     #2
}
…
export interface AchBatchDetails {    
    batchId: string;                  
    companyName: string;              
    recordCount: number;              
    totalDebitAmount: number;         
    totalCreditAmount: number;        
}
…
interface AchBatchInfoResponse {  
    batches: AchBatchInfo[];      
}
…
export default function FileDetails({params}: any) { #4

    const id: string | string[] = params.id; #5
    const [batches, setBatches] =
<span class="CharOverride-5">➥</span> useState&lt;AchBatchInfo[]&gt;([]); #6

    useEffect(() =&gt; {        #7
        const apiUrl = process.env.NEXT_PUBLIC_API_URL ?? '';
        axios.get&lt;AchBatchInfoResponse&gt;(`${apiUrl}/files/${id}/batches`)
            .then(response =&gt; {
                console.log(`Response data
<span class="CharOverride-5">➥</span> ${JSON.stringify(response.data.batches)}`);
                setBatches(response.data.batches);
            })
            .catch(error =&gt; {
                console.log(error);
            });
    }, []);
…
                    {batches.map((item, index) =&gt; (          #8
                            &lt;Accordion key={item.companyName}&gt;
                                &lt;AccordionSummary
<span class="CharOverride-5">➥</span> expandIcon={&lt;ExpandMoreIcon /&gt;}&gt;
                                    &lt;Typography&gt;{item.companyName}&lt;/Typography&gt;
                                &lt;/AccordionSummary&gt;
                                &lt;AccordionDetails&gt;
{item.companyBatches.map((companyBatch, index) =&gt; (
                                    &lt;&gt;
                                        &lt;Typography&gt;
                                  Batch ID:
<span class="CharOverride-5">➥</span> {companyBatch.batchId}&lt;br /&gt;
                                  Record Count:
<span class="CharOverride-5">➥</span> {companyBatch.recordCount}&lt;br /&gt;
                                  Total Debit Amount:
<span class="CharOverride-5">➥</span> {formatCurrency(companyBatch.totalDebitAmount)}&lt;br /&gt;
                                  Total Credit Amount:
<span class="CharOverride-5">➥</span> {formatCurrency(companyBatch.totalCreditAmount)}
                                        &lt;/Typography&gt;
                                        &lt;Link&gt;View Batch&lt;/Link&gt;
                                        &lt;Divider /&gt;
                                    &lt;/&gt;
                                )
                                )}
                                &lt;/AccordionDetails&gt;
                            &lt;/Accordion&gt;
                        ))}
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Defines our JSON structure so that we can strongly type the response</span>
<br/>#4 
     <span class="CharOverride-4">Allows the URL parameters to be accessed</span>
<br/>#5 
     <span class="CharOverride-4">References the URL parameter by the same name we defined in square brackets</span>
<br/>#6 
     <span class="CharOverride-4">Stores the batches with useState like we did in other components</span>
<br/>#7 
     <span class="CharOverride-4">Uses useEffect to gather the data from the API</span>
<br/>#8 
     <span class="CharOverride-4">Maps the returned batches to display the UI elements</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p147">
<p>This component presents the accordion view showed earlier in the chapter as part of figure 6.5 for the companies in the ACH file. An important takeaway from this component is seeing how we can dynamically create layout elements on our page. In other components, we will use DataGrid views that provide a table structure for viewing dynamic data. However, it is helpful to know that we can create layouts with dynamic data manually, as well when the need arises.</p>
</div>
<div class="readable-text" id="p148">
<h2 class="readable-text-h2"><span class="num-string">6.7</span> Creating a ScatterPlot component</h2>
</div>
<div class="readable-text" id="p149">
<p>Finally, we want to add a scatterplot to the page that shows the items in the batch versus the total amount of debits and credits. The following listing shows the directory structure we will be creating. You may create another subdirectory to store specific scatterplot-related files. Since we have not reached the point where this directory contains a lot of files, we will leave this as is for the time being.</p>
</div>
<div class="browsable-container listing-container" id="p150">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.34<span class="CharOverride-3"> </span>Directory structure for our charts</h5>
<div class="code-area-container">
<pre class="code-area">src/
├─ app/
│  ├─ components/
│  │  ├─ charts/
│  │  │  ├─ AchBatchesScatterPlot.tsx
│  │  │  ├─ AchBatchesScatterTooltip.tsx
│  │  │  ├─ CurrencyTick.tsx</pre>
</div>
</div>
<div class="readable-text" id="p151">
<h3 class="readable-text-h3"><span class="num-string">6.7.1</span> Scatterplot component</h3>
</div>
<div class="readable-text" id="p152">
<p>A scatterplot is useful for showing the possible correlation between variables. In our case, we may not necessarily be interested in the analytic aspect. However, the scatterplot also provides a way to identify batches with a high number of items or with a large dollar amount, which may be interesting to our users. Certainly, there may also be an opportunity for us to display trends in the batches for a particular company, which may also help our users perform analysis.</p>
</div>
<div class="readable-text intended-text" id="p153">
<p>In the meantime, this component provides an opportunity to explore using colors, custom tooltips, and custom ticks on the axis. These features are discussed in subsequent sections. The initial code for the scatterplot is shown in listing 6.35, with the actual component rendering shown in listing 6.36.</p>
</div>
<div class="readable-text intended-text" id="p154">
<p>The component defines an interface called <code>AchBatchesScatterPlotProps</code> so that it can set the types properly. In addition, it is important that this component accepts the batches as a read-only parameter rather than making any API calls inside the component. We could have just as easily made the API calls inside the component. However, if we had multiple components that wanted to make use of this data, we would end up with repeated API calls to gather the same data. We also marked the data as read-only to help enforce the concept of the component only utilizing the data and not introducing unintended consequences by being used. However, note that <code>Readonly</code> is a compile-time feature for TypeScript, and the resulting JavaScript will not have it. Finally, since we are interested in the total dollar amount of the batch, we add the credit and debit amounts together and store them into <code>totalCreditAndDebits</code>.</p>
</div>
<div class="browsable-container listing-container" id="p155">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.35<span class="CharOverride-3"> </span>Scatterplot component</h5>
<div class="code-area-container">
<pre class="code-area">…
interface AchBatchesScatterPlotProps {  #1
    batches: AchBatchInfo[];             #1
}                                       

export default function AchBatchesScatterPlot({batches}:
<span class="CharOverride-5">➥</span> Readonly&lt;AchBatchesScatterPlotProps&gt;) { #2

    const plotData = batches.map(batch =&gt; {
        const updatedCompanyBatches =
<span class="CharOverride-5">➥</span> batch.companyBatches.map(companyBatch =&gt; {
            return {
                ...companyBatch,   #3
                totalCreditAndDebits:
<span class="CharOverride-5">➥</span> companyBatch.totalCreditAmount + companyBatch.totalDebitAmount #4
            };
        });
        return {
            ...batch, #5
            companyBatches: updatedCompanyBatches #6
        };
    });

    return (
    # Refer to AchBatchesScatterPlot.tsx source code for this logic
    );
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Defines an interface for the component properties, so we can strongly type them</span>
<br/>#2 
     <span class="CharOverride-4">Accepts the properties as Readonly so we do not modify them</span>
<br/>#3 
     <span class="CharOverride-4">Spreads the contents of the companyBatch object</span>
<br/>#4 
     <span class="CharOverride-4">Adds a new property to the object named totalCreditAndDebits</span>
<br/>#5 
     <span class="CharOverride-4">Spreads the content </span>
<span class="CharOverride-4">of the batch object</span>
<br/>#6 
     <span class="CharOverride-4">Replaces the existing companyBatches with the new batches containing the totalCreditAndDebits</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p156">
<p>In the following listing, we have the component that renders the actual scatterplot. Here we take advantage of the flexibility of recharts by defining custom tooltip content by passing a component called <code>AchBatchesScatterTooltip</code> and by defining a custom tick mark component for the <code>YAxis</code> called <code>CurrencyTick</code>. Furthermore, we assign a different color to each company when placing the point on the plot (more about these custom components in the following sections).</p>
</div>
<div class="browsable-container listing-container" id="p157">
<h5 class="listing-container-h5 browsable-container-h5">Lisitng 6.36<span class="CharOverride-3"> </span>Scatterplot render</h5>
<div class="code-area-container">
<pre class="code-area">&lt;&gt;
   &lt;Title&gt;ACH Batches&lt;/Title&gt;
   &lt;ResponsiveContainer&gt;
      &lt;ScatterChart
         width={400}
         height={400}
         margin={{
            top: 20,
            right: 20,
            bottom: 20,
            left: 20,
         }}&gt;
      &lt;Legend /&gt;
      &lt;CartesianGrid /&gt;
      &lt;XAxis type="number" dataKey="recordCount" name="Count" unit="" /&gt;
      &lt;YAxis type="number"
             tick={&lt;CurrencyTick/&gt;}   #1
             dataKey="totalCreditAndDebits" name="Total Amount" unit="" /&gt;
      &lt;Tooltip cursor={{ strokeDasharray: '3 3' }} 
         content={&lt;AchBatchesScatterTooltip /&gt;} /&gt;   #2
         {plotData.map((entry, index) =&gt; (
            &lt;Scatter key={`${entry.companyName}`} 
                     name={`${entry.companyName}`} 
                     data={entry.companyBatches} 
                     fill={stringToColor(entry.companyName)}&gt;  #3
               &lt;Cell 
                  key={`cell-${entry.companyName}-${index}`} 
                            fill={stringToColor(entry.companyName)} /&gt;  
                      &lt;/Scatter&gt;
                   ))}
      &lt;/ScatterChart&gt;
   &lt;/ResponsiveContainer&gt;
&lt;/&gt;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Custom component for the ticks on the Y-axis</span>
<br/>#2 
     <span class="CharOverride-4">Custom tooltip when hovering over a data point</span>
<br/>#3 
     <span class="CharOverride-4">Custom color depending on the company</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p158">
<h3 class="readable-text-h3"><span class="num-string">6.7.2</span> Scatterplot custom tooltip</h3>
</div>
<div class="readable-text" id="p159">
<p>After defining our custom tooltip component in the next listing, we can customize the displayed tooltip. We kept it simple by using the components available in Material UI. We can also reuse the <code>formatCurrency</code> method that we had defined to ensure the correct display of data in the tooltip.</p>
</div>
<div class="browsable-container listing-container" id="p160">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.37<span class="CharOverride-3"> </span>Custom tooltip for scatterplot</h5>
<div class="code-area-container">
<pre class="code-area">export function AchBatchesScatterTooltip
<span class="CharOverride-5">➥</span> ({ active, payload, label }: TooltipProps&lt;string, string&gt;)  {
    if (active &amp;&amp; payload &amp;&amp; payload.length) {
        const value = payload[1].value ?? '0.0';
        return (
            &lt;Tooltip title={&lt;Typography&gt;{`Value: ${label}`}
<span class="CharOverride-5">➥</span>&lt;/Typography&gt;} arrow&gt;
                &lt;Paper sx={{ p: { xs: 1, sm: 2, md: 3 } }}&gt;
                    &lt;Typography variant="h6"&gt;Total Debits and
<span class="CharOverride-5">➥</span> Credits&lt;/Typography&gt;
                    {formatCurrency(Number.parseFloat(value))} #1
                &lt;/Paper&gt;
            &lt;/Tooltip&gt;
        );
    }

    return null;
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Reuses our formatCurrency routine to ensure consistency in displaying amounts</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p161">
<h3 class="readable-text-h3"><span class="num-string">6.7.3</span> Scatterplot custom ticks</h3>
</div>
<div class="readable-text" id="p162">
<p>Another way to customize charts in recharts is by defining a custom tick. Here we want our ticks to be formatted as currency instead of leaving them unformatted and adding a label to say “in dollars” or something similar. We define an interface that contains the passed data and then again use our <code>formatCurrency</code> utility (listing 6.38).</p>
</div>
<div class="readable-text intended-text" id="p163">
<p>This component uses both <code>Readonly</code> (to ensure that the component does not modify any parameters) and <code>Partial</code>. The <code>Partial</code> type is used because <code>recharts</code> is in control of the parameters passed. Furthermore, rather than marking each parameter as optional by using <code>?</code>, we can mark all parameters in <code>CurrencyTickProps</code> as optional by using <code>Partial&lt;CurrencyTickProps&gt;</code>.</p>
</div>
<div class="browsable-container listing-container" id="p164">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.38<span class="CharOverride-3"> </span>Custom currency tick</h5>
<div class="code-area-container">
<pre class="code-area">interface CurrencyTickProps { #1
    x: number;                 #1
    y: number;                 #1
    payload: {                 #1
        value: string;         #1
    };                         #1
}                              #1

export function CurrencyTick({ x, y, payload }:
<span class="CharOverride-5">➥</span> Readonly&lt;Partial&lt;CurrencyTickProps&gt;&gt;): React.JSX.Element { #2
    const value = payload?.value ?? '0.0';  #3
    return (
        &lt;g transform={`translate(${x},${y})`}&gt;
            &lt;text x={0} y={0} dy={16} textAnchor="end"
<span class="CharOverride-5">➥</span> fill="#666" transform="rotate(-35)"&gt;
                {formatCurrency(Number.parseFloat(value))} #4
            &lt;/text&gt;
        &lt;/g&gt;
    );</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Defines our properties so that they are strongly typed</span>
<br/>#2 
     <span class="CharOverride-4">Properties are marked as Readonly and Partial.</span>
<br/>#3 
     <span class="CharOverride-4">If the payload does not exist, substitute 0.0.</span>
<br/>#4 
     <span class="CharOverride-4">Uses our handy formatCurrency function</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p165">
<p>Obviously, the ability to customize our charts further using custom ticks is a powerful tool. Even if we chose to use the standard ticks, it is helpful to keep this type of customization in our back pocket for when the business makes a more specific request. In the next section, we will look at customizing colors for our charts.</p>
</div>
<div class="readable-text" id="p166">
<h3 class="readable-text-h3"><span class="num-string">6.7.4</span> Using colors for the chart</h3>
</div>
<div class="readable-text" id="p167">
<p>Colors are a very important part of any visualization. In our case, we do not limit the number of points in the scatterplot, so we do not necessarily know the number of companies that will have to be identified. We could always limit the visualization by saying it is a scatterplot of the “Top 10 companies” or the “Top 10 batches” so that we do not have to enumerate additional colors to handle an undetermined number of companies.</p>
</div>
<div class="readable-text intended-text" id="p168">
<p>The next listing shows how we may enumerate the colors and then the code will loop through these colors and reuse them as necessary as we are doing <code>COLORS[index</code> <code>% COLORS.length]</code>. This approach will work but also has the problem of repeating colors when there are more companies than colors defined, and that will obviously make the visualization difficult to understand from a user’s perspective.</p>
</div>
<div class="browsable-container listing-container" id="p169">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.39<span class="CharOverride-3"> </span>Enumerating colors</h5>
<div class="code-area-container">
<pre class="code-area">const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', 'red', 'blue'];
…
   &lt;Scatter key={`${entry.companyName}`}
            name={`${entry.companyName}`}
            data={entry.companyBatches}
            fill={COLORS[index % COLORS.length]}&gt;
      &lt;Cell key={`cell-${entry.companyName}-${index}`}
            fill={COLORS[index % COLORS.length]} /&gt;
   &lt;/Scatter&gt;</pre>
</div>
</div>
<div class="readable-text" id="p170">
<p>Another option we went with was computing the colors based on the company name, which provided us with a better opportunity to handle many companies in our visualization (although there will be a threshold where it is no longer valuable). However, as it stands, this approach also does not allow us to use names that may hash to the same value, nor does it necessarily give us the best colors in a visualization. Later, we may decide that showing the top 10 companies is the best way to handle the visualization. </p>
</div>
<div class="readable-text intended-text" id="p171">
<p>Listing 6.40 shows the code used to compute a hex color code from the company name (or any string). In this case, the implementation details on how we create a color code from a string are not so important. Rather, we want to understand different ways we may use when approaching a problem and try to understand the potential tradeoffs in each approach. In this case, we have lost control over the exact colors being used, which also means the colors may be indistinguishable or conflict with the rest of the visualization. However, this approach allows us to show many companies, also providing consistency in color for the company. So, the color could be consistent in other visualizations or just change every day.</p>
</div>
<div class="browsable-container listing-container" id="p172">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.40<span class="CharOverride-3"> </span>Using the company name to determine the color</h5>
<div class="code-area-container">
<pre class="code-area">export function stringToColor(str: string): string {
    let hash = 0;
    for (let i = 0; i &lt; str.length; i++) {
        hash = str.charCodeAt(i) + ((hash &lt;&lt; 5) - hash);
    }

    let color = '#';
    for (let i = 0; i &lt; 3; i++) {
        const value = (hash &gt;&gt; (i * 8)) &amp; 0xFF;
        color += ('00' + value.toString(16)).slice(-2);
    }
    return color;
}</pre>
</div>
</div>
<div class="readable-text" id="p173">
<p>How we display data is not only a matter of preference—our choice of layout, formatting, and colors can influence data interpretation. For instance,</p>
</div>
<ul>
<li class="readable-text" id="p174">Using a red/green color scheme makes it harder for individuals with color blindness to distinguish the colors in different categories.</li>
<li class="readable-text" id="p175">3D bar charts can be visually appealing but can lead to inaccurate interpretations of the data because the perspective can make bars appear larger/smaller than they are.</li>
<li class="readable-text" id="p176">In cherry-picked timeframes, data that does not fit a specific narrative is hidden or minimized.</li>
</ul>
<div class="readable-text" id="p177">
<p>For additional information on this topic, see <em>Everyday Data Visualization</em> (2024, Manning) by Desireé Abbott, especially if you want to take your visualizations to the next level.</p>
</div>
<div class="readable-text" id="p178">
<h2 class="readable-text-h2"><span class="num-string">6.8</span> Deploying the dashboard in Docker</h2>
</div>
<div class="readable-text" id="p179">
<p>As a final step, we want to deploy our code in Docker to tie all the pieces of our system together. The next chapter will focus on implementing the needed APIs, making sure components can communicate, and general housekeeping. For now, we only want to ensure the container is built correctly and can communicate with our WireMock instance.</p>
</div>
<div class="readable-text intended-text" id="p180">
<p>As you may recall, our API calls use the <code>NEXT_PUBLIC_API_URL</code>, which allows us to configure the base URL needed to communicate with the backend. Listing 6.41 shows the service implementation for our docker-compose.yml. We now introduce the use of the <code>args</code> parameter to pass in arguments to our build process. We have set the URL to the same endpoint that we had in our <code>.env.local</code> project setup. This is because the code will be running on the client side in the browser, which means we will need to use <code>localhost:8081</code> and not the internal reference to <code>wiremock:8080</code>, as you may initially imagine.</p>
</div>
<div class="browsable-container listing-container" id="p181">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.41<span class="CharOverride-3"> </span>Adding the dashboard to Docker</h5>
<div class="code-area-container">
<pre class="code-area">…
  dashboard:
    build: 
      context: ./dashboard
      dockerfile: Dockerfile
      args:  #1
        - NEXT_PUBLIC_API_URL=http://localhost:8081/api/v1
    ports:
      - 4000:3000</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Defines variables </span>
<span class="CharOverride-4">to pass to the build</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p182">
<p>In the following listing, we have the Dockerfile referenced in listing 6.41. This code takes care of setting our environment variable, and building and running the application. In this Dockerfile, we utilize the <code>NEXT_PUBLIC_API_URL</code> by showing how we may set a default value, as well as how to set it in the container.</p>
</div>
<div class="browsable-container listing-container" id="p183">
<h5 class="listing-container-h5 browsable-container-h5">Listing 6.42<span class="CharOverride-3"> </span>The Dockerfile for the dashboard</h5>
<div class="code-area-container">
<pre class="code-area">FROM node:alpine

ARG NEXT_PUBLIC_API_URL=
<span class="CharOverride-5">➥</span>'http://override-me-in-docker-compose' #1
ENV NEXT_PUBLIC_API_URL $NEXT_PUBLIC_API_URL     #2

WORKDIR /usr/src/app

COPY app/package*.json ./

RUN npm install

COPY app/. .

RUN npm run build

CMD [ "npm", "start" ]</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-4">Defines an argument that can be used or defaulted</span>
<br/>#2 
     <span class="CharOverride-4">Sets an environment variable that will contain our API URL</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p184">
<p>At this point, we should be able to build the containers and start them with <code>docker-compose</code> <code>down;</code> <code>docker-compose</code> <code>up</code> <code>--build</code> like before. Then, after navigating to http://localhost:4000, we should see our dashboard come up, displaying our WireMock data.</p>
</div>
<div class="readable-text" id="p185">
<h2 class="readable-text-h2">Summary</h2>
</div>
<ul>
<li class="readable-text" id="p186">The dashboard serves as the user interface for file uploads and data views, powered by APIs, and it can be developed using various technologies, with a current preference for Next.js.</li>
<li class="readable-text" id="p187">Next.js supports building interactive web applications with React by using HTML, CSS, and DOM principles and offering file-based routing, CSR, SSR, and multiple styling methods.</li>
<li class="readable-text" id="p188">Starting with Next.js involves setting up <code>Node.js</code>, creating a project using npx, and running a default application to verify setup correctness.</li>
<li class="readable-text" id="p189">The dashboard can be initialized using templates such as Material UI, and dependencies should be installed to support components and API calls.</li>
<li class="readable-text" id="p190">Incorporating TypeScript enhances maintainability by adding explicit types and catching errors during development.</li>
<li class="readable-text" id="p191">Jest is used for unit testing the UI, ensuring page functionality and accessibility through ARIA roles.</li>
<li class="readable-text" id="p192">Refactoring of navigation components warrants better code organization and inclusion in the upload page.</li>
<li class="readable-text" id="p193">Hardcoded data is initially used for UI development and then replaced with mocked API calls using tools such as WireMock for parallel development.</li>
<li class="readable-text" id="p194">Mocking APIs with WireMock involves setting up Docker, configuring stubs, and refreshing for changes to take effect, facilitating UI testing without complete backend availability.</li>
<li class="readable-text" id="p195">Deployment of the dashboard in Docker involves configuring environment variables and ensuring communication with mocked APIs for dynamic data display.</li>
</ul>
</div></body></html>