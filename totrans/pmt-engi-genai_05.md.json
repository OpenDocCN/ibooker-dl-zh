["```py\n[-0.011904156766831875,\n -0.0323905423283577,\n 0.001950666424818337,\n...]\n```", "```py\n## Context\nMost relevant previous user messages:\n1\\. \"My name is Mike\".\n2\\. \"My dog's name is Hercules\".\n3\\. \"My coworker's name is James\".\n\n## Instructions\nPlease answer the user message using the context above.\nUser message: What is my name?\nAI message:\n```", "```py\nfrom openai import OpenAI\nclient = OpenAI()\n\n# Function to get the vector embedding for a given text\ndef get_vector_embeddings(text):\n    response = client.embeddings.create(\n        input=text,\n        model=\"text-embedding-ada-002\"\n    )\n    embeddings = [r.embedding for r in response.data]\n    return embeddings[0]\n\nget_vector_embeddings(\"Your text string goes here\")\n```", "```py\n[\n-0.006929283495992422,\n-0.005336422007530928,\n...\n-4.547132266452536e-05,\n-0.024047505110502243\n]\n```", "```py\nimport requests\nimport os\n\nmodel_id = \"sentence-transformers/all-MiniLM-L6-v2\"\nhf_token = os.getenv(\"HF_TOKEN\")\n\napi_url = \"https://api-inference.huggingface.co/\"\napi_url += f\"pipeline/feature-extraction/{model_id}\"\nheaders = {\"Authorization\": f\"Bearer {hf_token}\"}\n\ndef query(texts):\n    response = requests.post(api_url, headers=headers,\n    json={\"inputs\": texts,\n    \"options\":{\"wait_for_model\":True}})\n    return response.json()\n\ntexts = [\"mickey mouse\",\n        \"cheese\",\n        \"trap\",\n        \"rat\",\n        \"ratatouille\"\n        \"bus\",\n        \"airplane\",\n        \"ship\"]\n\noutput = query(texts)\noutput\n```", "```py\n[[-0.03875632584095001, 0.04480459913611412,\n0.016051070764660835, -0.01789097487926483,\n-0.03518553078174591, -0.013002964667975903,\n0.14877274632453918, 0.048807501792907715,\n0.011848390102386475, -0.044042471796274185,\n...\n-0.026688814163208008, -0.0359361357986927,\n-0.03237859532237053, 0.008156519383192062,\n-0.10299170762300491, 0.0790356695652008,\n-0.008071334101259708, 0.11919838190078735,\n0.0005506130401045084, -0.03497892618179321]]\n```", "```py\nfrom gensim.models import Word2Vec\n\n# Sample data: list of sentences, where each sentence is\n# a list of words.\n# In a real-world scenario, you'd load and preprocess your\n# own corpus.\nsentences = [\n    [\"the\", \"cake\", \"is\", \"a\", \"lie\"],\n    [\"if\", \"you\", \"hear\", \"a\", \"turret\", \"sing\", \"you're\",\n    \"probably\", \"too\", \"close\"],\n    [\"why\", \"search\", \"for\", \"the\", \"end\", \"of\", \"a\",\n    \"rainbow\", \"when\", \"the\", \"cake\", \"is\", \"a\", \"lie?\"],\n    # ...\n    [\"there's\", \"no\", \"cake\", \"in\", \"space,\", \"just\", \"ask\",\n    \"wheatley\"],\n    [\"completing\", \"tests\", \"for\", \"cake\", \"is\", \"the\",\n    \"sweetest\", \"lie\"],\n    [\"I\", \"swapped\", \"the\", \"cake\", \"recipe\", \"with\", \"a\",\n    \"neurotoxin\", \"formula,\", \"hope\", \"that's\", \"fine\"],\n] + [\n    [\"the\", \"cake\", \"is\", \"a\", \"lie\"],\n    [\"the\", \"cake\", \"is\", \"definitely\", \"a\", \"lie\"],\n    [\"everyone\", \"knows\", \"that\", \"cake\", \"equals\", \"lie\"],\n    # ...\n] * 10  # repeat several times to emphasize\n\n# Train the word2vec model\nmodel =  Word2Vec(sentences, vector_size=100, window=5,\nmin_count=1, workers=4, seed=36)\n\n# Save the model\nmodel.save(\"custom_word2vec_model.model\")\n\n# To load the model later\n# loaded_model = word2vec.load(\n# \"custom_word2vec_model.model\")\n\n# Get vector for a word\nvector = model.wv['cake']\n\n# Find most similar words\nsimilar_words = model.wv.most_similar(\"cake\", topn=5)\nprint(\"Top five most similar words to 'cake': \", similar_words)\n\n# Directly query the similarity between \"cake\" and \"lie\"\ncake_lie_similarity = model.wv.similarity(\"cake\", \"lie\")\nprint(\"Similarity between 'cake' and 'lie': \",\ncake_lie_similarity)\n```", "```py\nTop 5 most similar words to 'cake':  [('lie',\n0.23420444130897522), ('test', 0.23205122351646423),\n('tests', 0.17178669571876526), ('GLaDOS',\n0.1536172330379486), ('got', 0.14605288207530975)]\nSimilarity between 'cake' and 'lie':  0.23420444\n```", "```py\nimport numpy as np\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\n\n# Convert sentences to a list of strings for TfidfVectorizer\ndocument_list = [' '.join(s) for s in sentences]\n\n# Compute TF-IDF representation\nvectorizer = TfidfVectorizer()\ntfidf_matrix = vectorizer.fit_transform(document_list)\n\n# Extract the position of the words \"cake\" and \"lie\" in\n# the feature matrix\ncake_idx = vectorizer.vocabulary_['cake']\nlie_idx = vectorizer.vocabulary_['lie']\n\n# Extract and reshape the vector for 'cake'\ncakevec = tfidf_matrix[:, cake_idx].toarray().reshape(1, -1)\n\n# Compute the cosine similarities\nsimilar_words = cosine_similarity(cakevec, tfidf_matrix.T).flatten()\n\n# Get the indices of the top 6 most similar words\n# (including 'cake')\ntop_indices = np.argsort(similar_words)[-6:-1][::-1]\n\n# Retrieve and print the top 5 most similar words to\n# 'cake' (excluding 'cake' itself)\nnames = []\nfor idx in top_indices:\n    names.append(vectorizer.get_feature_names_out()[idx])\nprint(\"Top five most similar words to 'cake': \", names)\n\n# Compute cosine similarity between \"cake\" and \"lie\"\nsimilarity = cosine_similarity(np.asarray(tfidf_matrix[:,\n    cake_idx].todense()), np.asarray(tfidf_matrix[:, lie_idx].todense()))\n# The result will be a matrix; we can take the average or\n# max similarity value\navg_similarity = similarity.mean()\nprint(\"Similarity between 'cake' and 'lie'\", avg_similarity)\n\n# Show the similarity between \"cake\" and \"elephant\"\nelephant_idx = vectorizer.vocabulary_['sing']\nsimilarity = cosine_similarity(np.asarray(tfidf_matrix[:,\n    cake_idx].todense()), np.asarray(tfidf_matrix[:,\n    elephant_idx].todense()))\navg_similarity = similarity.mean()\nprint(\"Similarity between 'cake' and 'sing'\",\n    avg_similarity)\n```", "```py\nTop 5 most similar words to 'cake':  ['lie', 'the', 'is',\n'you', 'definitely']\nSimilarity between 'cake' and 'lie' 0.8926458157227388\nSimilarity between 'cake' and 'sing' 0.010626735901461177\n```", "```py\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\ntext_splitter = RecursiveCharacterTextSplitter.from_tiktoken_encoder(\n    chunk_size=100, # 100 tokens\n    chunk_overlap=20, #Â 20 tokens of overlap\n    )\n\ntext = \"\"\"\nWelcome to the \"Unicorn Enterprises: Where Magic Happens\"\nEmployee Handbook! We're thrilled to have you join our team\nof dreamers, doers, and unicorn enthusiasts. At Unicorn\nEnterprises, we believe that work should be as enchanting as\nit is productive. This handbook is your ticket to the\nmagical world of our company, where we'll outline the\nprinciples, policies, and practices that guide us on this\nextraordinary journey. So, fasten your seatbelts and get\nready to embark on an adventure like no other!\n\n...\n\nAs we conclude this handbook, remember that at Unicorn\nEnterprises, the pursuit of excellence is a never-ending\nquest. Our company's success depends on your passion,\ncreativity, and commitment to making the impossible\npossible. We encourage you to always embrace the magic\nwithin and outside of work, and to share your ideas and\ninnovations to keep our enchanted journey going. Thank you\nfor being a part of our mystical family, and together, we'll\ncontinue to create a world where magic and business thrive\nhand in hand!\n\"\"\"\n\nchunks = text_splitter.split_text(text=text)\nprint(chunks[0:3])\n```", "```py\n['Welcome to the \"Unicorn Enterprises: Where Magic Happens\"\nEmployee Handbook! We\\'re thrilled to have you join our team\nof dreamers, doers, and unicorn enthusiasts.',\n\"We're thrilled to have you join our team of dreamers,\ndoers, and unicorn enthusiasts. At Unicorn Enterprises, we\nbelieve that work should be as enchanting as it is\nproductive.\",\n ...\n\"Our company's success depends on your passion, creativity,\nand commitment to making the impossible possible. We\nencourage you to always embrace the magic within and outside\nof work, and to share your ideas and innovations to keep our\nenchanted journey going.\",\n\"We encourage you to always embrace the magic within and\noutside of work, and to share your ideas and innovations to\nkeep our enchanted journey going. Thank you for being a part\nof our mystical family, and together, we'll continue to\ncreate a world where magic and business thrive hand in\nhand!\"]\n```", "```py\nimport numpy as np\nimport faiss\n\n#  The get_vector_embeddings function is defined in a preceding example\nemb = [get_vector_embeddings(chunk) for chunk in chunks]\nvectors = np.array(emb)\n\n# Create a FAISS index\nindex = faiss.IndexFlatL2(vectors.shape[1])\nindex.add(vectors)\n\n# Function to perform a vector search\ndef vector_search(query_text, k=1):\n    query_vector = get_vector_embeddings(query_text)\n    distances, indices = index.search(\n        np.array([query_vector]), k)\n    return [(chunks[i], float(dist)) for dist,\n        i in zip(distances[0], indices[0])]\n\n# Example search\nuser_query = \"do we get free unicorn rides?\"\nsearch_results = vector_search(user_query)\nprint(f\"Search results for {user_query}:\", search_results)\n```", "```py\nSearch results for do we get free unicorn rides?: [(\"You'll\nenjoy a treasure chest of perks, including unlimited unicorn\nrides, a bottomless cauldron of coffee and potions, and\naccess to our company library filled with spellbinding\nbooks. We also offer competitive health and dental plans,\nensuring your physical well-being is as robust as your\nmagical spirit.\\n\\n**5: Continuous Learning and\nGrowth**\\n\\nAt Unicorn Enterprises, we believe in continuous\nlearning and growth.\", 0.3289167582988739)]\n```", "```py\n# Function to perform a vector search and then ask # GPT-3.5-turbo a question\ndef search_and_chat(user_query, k=1):\n  # Perform the vector search\n  search_results = vector_search(user_query, k)\n  print(f\"Search results: {search_results}\\n\\n\")\n\n  prompt_with_context = f\"\"\"Context:{search_results}\\\n Answer the question: {user_query}\"\"\"\n\n  # Create a list of messages for the chat\n  messages = [\n      {\"role\": \"system\", \"content\": \"\"\"Please answer the\n questions provided by the user. Use only the context\n provided to you to respond to the user, if you don't\n know the answer say \\\"I don't know\\\".\"\"\"},\n      {\"role\": \"user\", \"content\": prompt_with_context},\n  ]\n\n  # Get the model's response\n  response = client.chat.completions.create(\n    model=\"gpt-3.5-turbo\", messages=messages)\n\n  # Print the assistant's reply\n  print(f\"\"\"Response:\n  {response.choices[0].message.content}\"\"\")\n\n# Example search and chat\nsearch_and_chat(\"What is Unicorn Enterprises' mission?\")\n```", "```py\nSearch results: [(\"\"\"As we conclude this handbook, remember that at\nUnicorn Enterprises, the pursuit of excellence is a never-ending\nquest. Our company's success depends on your passion,\ncreativity, and commitment to making the impossible\npossible. We encourage you to always embrace the magic\nwithin and outside of work, and to share your ideas and\ninnovations to keep our enchanted journey going. Thank you\",\n0.26446571946144104)]\n\nResponse:\nUnicorn Enterprises' mission is to pursue excellence in their\nwork by encouraging their employees to embrace the magic within\nand outside of work, share their ideas and innovations, and make\nthe impossible possible.\n```", "```py\n# Save the index to a file\nfaiss.write_index(index, \"data/my_index_file.index\")\n```", "```py\n# Load the index from a file\nindex = faiss.read_index(\"data/my_index_file.index\")\n```", "```py\n# Assuming index1 and index2 are two IndexFlatL2 indices\nindex1.add(index2.reconstruct_n(0, index2.ntotal))\n```", "```py\nfrom langchain_community.vectorstores.faiss import FAISS\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain_core.runnables import RunnablePassthrough\nfrom langchain_openai import ChatOpenAI, OpenAIEmbeddings\n\n# 1\\. Create the documents:\ndocuments = [\n    \"James Phoenix worked at JustUnderstandingData.\",\n    \"James Phoenix currently is 31 years old.\",\n    \"\"\"Data engineering is the designing and building systems for collecting,\n storing, and analyzing data at scale.\"\"\",\n]\n\n# 2\\. Create a vectorstore:\nvectorstore = FAISS.from_texts(texts=documents, embedding=OpenAIEmbeddings())\nretriever = vectorstore.as_retriever()\n\n# 3\\. Create a prompt:\ntemplate = \"\"\"Answer the question based only on the following context:\n---\nContext: {context}\n---\nQuestion: {question}\n\"\"\"\nprompt = ChatPromptTemplate.from_template(template)\n\n# 4\\. Create a chat model:\nmodel = ChatOpenAI()\n```", "```py\nchain = (\n    {\"context\": retriever, \"question\": RunnablePassthrough()}\n    | prompt\n    | model\n    | StrOutputParser()\n)\n```", "```py\nchain.invoke(\"What is data engineering?\")\n# 'Data engineering is the process of designing and building systems for\n# collecting, storing, and analyzing data at scale.'\n\nchain.invoke(\"Who is James Phoenix?\")\n# 'Based on the given context, James Phoenix is a 31-year-old individual who\n# worked at JustUnderstandingData.'\n\nchain.invoke(\"What is the president of the US?\")\n# I don't know\n```", "```py\nfrom pinecone import Pinecone, ServerlessSpec\nimport os\n\n# Initialize connection (get API key at app.pinecone.io):\nos.environ[\"PINECONE_API_KEY\"] = \"insert-your-api-key-here\"\n\nindex_name = \"employee-handbook\"\nenvironment = \"us-west-2\"\npc = Pinecone()  # This reads the PINECONE_API_KEY env var\n\n# Check if index already exists:\n# (it shouldn't if this is first time)\nif index_name not in pc.list_indexes().names():\n    # if does not exist, create index\n    pc.create_index(\n        index_name,\n        # Using the same vector dimensions as text-embedding-ada-002\n        dimension=1536,\n        metric=\"cosine\",\n        spec=ServerlessSpec(cloud=\"aws\", region=environment),\n    )\n\n# Connect to index:\nindex = pc.Index(index_name)\n\n# View index stats:\nindex.describe_index_stats()\n```", "```py\n{'dimension': 1536,\n 'index_fullness': 0.0,\n 'namespaces': {},\n 'total_vector_count': 0}\n```", "```py\nfrom tqdm import tqdm # For printing a progress bar\nfrom time import sleep\n\n# How many embeddings you create and insert at once\nbatch_size = 10\nretry_limit = 5  # maximum number of retries\n\nfor i in tqdm(range(0, len(chunks), batch_size)):\n    # Find end of batch\n    i_end = min(len(chunks), i+batch_size)\n    meta_batch = chunks[i:i_end]\n    # Get ids\n    ids_batch = [str(j) for j in range(i, i_end)]\n    # Get texts to encode\n    texts = [x for x in meta_batch]\n    # Create embeddings\n    # (try-except added to avoid RateLimitError)\n    done = False\n    try:\n        # Retrieve embeddings for the whole batch at once\n        embeds = []\n        for text in texts:\n            embedding = get_vector_embeddings(text)\n            embeds.append(embedding)\n        done = True\n    except:\n        retry_count = 0\n        while not done and retry_count < retry_limit:\n            try:\n                for text in texts:\n                    embedding = get_vector_embeddings(text)\n                    embeds.append(embedding)\n                done = True\n            except:\n                sleep(5)\n                retry_count += 1\n\n    if not done:\n        print(f\"\"\"Failed to get embeddings after\n        {retry_limit} retries.\"\"\")\n        continue\n\n    # Cleanup metadata\n    meta_batch = [{\n        'batch': i,\n        'text': x\n    } for x in meta_batch]\n    to_upsert = list(zip(ids_batch, embeds, meta_batch))\n\n    # Upsert to Pinecone\n    index.upsert(vectors=to_upsert)\n```", "```py\n100% 13/13 [00:53<00:00, 3.34s/it]\n```", "```py\n# Retrieve from Pinecone\nuser_query = \"do we get free unicorn rides?\"\n\ndef pinecone_vector_search(user_query, k):\n    xq = get_vector_embeddings(user_query)\n    res = index.query(vector=xq, top_k=k, include_metadata=True)\n    return res\n\npinecone_vector_search(user_query, k=1)\n```", "```py\n{'matches':\n    [{'id': '15',\n    'metadata': {'batch': 10.0,\n    'text': \"You'll enjoy a treasure chest of perks, \"\n            'including unlimited unicorn rides, a '\n            'bottomless cauldron of coffee and potions, '\n            'and access to our company library filled '\n            'with spellbinding books. We also offer '\n            'competitive health and dental plans, '\n            'ensuring your physical well-being is as '\n            'robust as your magical spirit.\\n'\n            '\\n'\n            '**5: Continuous Learning and Growth**\\n'\n            '\\n'\n            'At Unicorn Enterprises, we believe in '\n            'continuous learning and growth.'},\n    'score': 0.835591,\n    'values': []},],\n 'namespace': ''}\n```", "```py\nres = index.query(xq, filter={\n        \"batch\": {\"$eq\": 1}\n    }, top_k=1, include_metadata=True)\n```", "```py\nfrom langchain_core.documents import Document\nfrom langchain_community.vectorstores.chroma import Chroma\nfrom langchain_openai import OpenAIEmbeddings\nimport lark\nimport getpass\nimport os\nimport warnings\n\n# Disabling warnings:\nwarnings.filterwarnings(\"ignore\")\n```", "```py\ndocs = [\n    Document(\n        page_content=\"A tale about a young wizard and his \\\n journey in a magical school.\",\n        metadata={\n            \"title\": \"Harry Potter and the Philosopher's Stone\",\n            \"author\": \"J.K. Rowling\",\n            \"year_published\": 1997,\n            \"genre\": \"Fiction\",\n            \"isbn\": \"978-0747532699\",\n            \"publisher\": \"Bloomsbury\",\n            \"language\": \"English\",\n            \"page_count\": 223,\n            \"summary\": \"The first book in the Harry Potter \\\n series where Harry discovers his magical \\\n heritage.\",\n            \"rating\": 4.8,\n        },\n    ),\n    # ... More documents ...\n]\n```", "```py\nfrom langchain_openai.chat_models import ChatOpenAI\nfrom langchain.retrievers.self_query.base \\\n    import SelfQueryRetriever\nfrom langchain.chains.query_constructor.base \\\n    import AttributeInfo\n\n# Create the embeddings and vectorstore:\nembeddings = OpenAIEmbeddings()\nvectorstore = Chroma.from_documents(docs, OpenAIEmbeddings())\n\n# Basic Info\nbasic_info = [\n    AttributeInfo(name=\"title\", description=\"The title of the book\",\n    type=\"string\"),\n    AttributeInfo(name=\"author\", description=\"The author of the book\",\n    type=\"string\"),\n    AttributeInfo(\n        name=\"year_published\",\n        description=\"The year the book was published\",\n        type=\"integer\",\n    ),\n]\n\n# Detailed Info\ndetailed_info = [\n    AttributeInfo(\n        name=\"genre\", description=\"The genre of the book\",\n        type=\"string or list[string]\"\n    ),\n    AttributeInfo(\n        name=\"isbn\",\n        description=\"The International Standard Book Number for the book\",\n        type=\"string\",\n    ),\n    AttributeInfo(\n        name=\"publisher\",\n        description=\"The publishing house that published the book\",\n        type=\"string\",\n    ),\n    AttributeInfo(\n        name=\"language\",\n        description=\"The primary language the book is written in\",\n        type=\"string\",\n    ),\n    AttributeInfo(\n        name=\"page_count\", description=\"Number of pages in the book\",\n        type=\"integer\"\n    ),\n]\n\n# Analysis\nanalysis = [\n    AttributeInfo(\n        name=\"summary\",\n        description=\"A brief summary or description of the book\",\n        type=\"string\",\n    ),\n    AttributeInfo(\n        name=\"rating\",\n        description=\"\"\"An average rating for the book (from reviews), ranging\n from 1-5\"\"\",\n        type=\"float\",\n    ),\n]\n\n# Combining all lists into metadata_field_info\nmetadata_field_info = basic_info + detailed_info + analysis\n```", "```py\ndocument_content_description = \"Brief summary of a movie\"\nllm = ChatOpenAI(temperature=0)\nretriever = SelfQueryRetriever.from_llm(\n    llm, vectorstore, document_content_description, metadata_field_info\n)\n\n# Looking for sci-fi books\nretriever.invoke(\"What are some sci-fi books?\")\n# [Document(page_content='''A futuristic society where firemen burn books to\n# maintain order.''', metadata={'author': 'Ray Bradbury', 'genre': '...\n# More documents..., truncated for brevity\n```", "```py\n# Querying for a book by J.K. Rowling:\nretriever.invoke(\n    '''I want some books that are published by the\n author J.K.Rowling'''\n)\n# query=' ' filter=Comparison(comparator=<Comparator.EQ:\n# 'eq'>, attribute='author', value='J.K. Rowling')\n# limit=None\n# Documents [] omitted to save space\n```", "```py\nretriever = SelfQueryRetriever.from_llm(\n    llm,\n    vectorstore,\n    document_content_description,\n    metadata_field_info,\n    enable_limit=True,\n)\n\nretriever.get_relevant_documents(\n    query=\"Return 2 Fantasy books\",\n)\n# query=' ' filter=Comparison(\n#    comparator=<Comparator.EQ: 'eq'>, attribute='genre',\n#   value='Fantasy') limit=2\n# Documents [] omitted to save space\n```"]