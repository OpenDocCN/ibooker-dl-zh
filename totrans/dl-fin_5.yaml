- en: Chapter 6\. Introductory Python for Data Science
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。数据科学的Python入门
- en: One more stop to go before diving into the realm of machine and deep learning.
    This chapter is optional for experienced Python developers but is crucial for
    anyone without a solid programming background. Understanding the intuition behind
    the algorithms is a great advantage but it will not get you far if you fail to
    properly implement them. After all, these algorithms need code to work and do
    not function manually. Make sure to understand the basic syntax and how to manipulate
    data and transform it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入机器和深度学习领域之前还有一个停留。对于有经验的Python开发人员来说，本章是可选的，但对于没有扎实编程背景的任何人来说都是至关重要的。了解算法背后的直觉是一个很大的优势，但如果未能正确实现它们，这将无法让您走得更远。毕竟，这些算法需要代码来工作，而不是手动操作。确保了解基本语法以及如何操作数据和转换数据。
- en: As the book is not meant to be an A-Z guide to programming in Python, this chapter
    gently brushes on some essentials and a few more techniques that should help you
    navigate smoothly the subsequent chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书不是Python编程的A-Z指南，本章只是简要介绍了一些基本知识和一些技术，这些应该有助于您顺利地浏览后续章节。
- en: Downloading Python
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载Python
- en: '*Coding* is defined as a set of instructions designed to be executed by a computer.
    Generally, specific syntax is required so that the computer applies the set of
    instructions without errors. There are many coding languages and are divided into
    two broad categories:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*编码*被定义为一组旨在由计算机执行的指令。通常需要特定的语法，以便计算机应用这组指令而不出现错误。有许多编码语言，分为两大类：'
- en: Low-level coding languages
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 低级编码语言
- en: These are machine languages usually for operating systems and firmwares. They
    are very difficult to read. These languages have a sizable level of control over
    hardware. An example of a low-level language is assembly (with its various types).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通常是用于操作系统和固件的机器语言。它们很难阅读。这些语言对硬件有相当大的控制。低级语言的一个例子是汇编语言（及其各种类型）。
- en: High-level coding languages
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 高级编码语言
- en: These are user-friendly languages (with a high level of abstraction). They are
    generally used to code programs and softwares. An example of a high-level language
    is Python and Julia.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用户友好的语言（具有高度抽象）。它们通常用于编写程序和软件。高级语言的一个例子是Python和Julia。
- en: The coding language used in this book is *Python*, a popular and versatile language
    with many advantages and wide adoption in the research and professional community.
    As you have seen from the chapter’s name, you will see an introduction to Python
    with the necessary tools to start building your own scripts. But before that,
    let’s see how to actually download Python.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的编程语言是*Python*，这是一种流行且多功能的语言，具有许多优势，并在研究和专业社区中被广泛采用。正如您从章节名称中看到的那样，您将看到Python的简介以及开始构建自己脚本所需的必要工具。但在此之前，让我们看看如何实际下载Python。
- en: A *Python interpreter* is a software used to write and execute code written
    using Python syntax. I use a software called *Spyder*. Some people may be more
    familiar with other interpreters such as *Jupyter* and *PyCharm*, but the process
    is the same. You can download *Spyder* from the [official website](https://www.spyder-ide.org/) or,
    even better, download it as part of a bigger package called [Anaconda](https://oreil.ly/nI8Ed),
    which facilitates installation and offers more tools. Note that it is an open
    source and free-to-use software.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python解释器*是一种用于编写和执行使用Python语法编写的代码的软件。我使用一个名为*Spyder*的软件。有些人可能更熟悉其他解释器，如*Jupyter*和*PyCharm*，但过程是相同的。您可以从[官方网站](https://www.spyder-ide.org/)下载*Spyder*，或者更好地，将其作为一个更大的软件包的一部分下载，该软件包称为[Anaconda](https://oreil.ly/nI8Ed)，它简化了安装并提供了更多工具。请注意，这是一个开源且免费使用的软件。'
- en: '*Spyder’s* interface is split into three windows, as you can see in Figure
    6-1. The window on the left is used to write the code that is later executed (the
    algorithm is told to run and apply the code). Typically, you will see multiple
    lines of code in that area.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*Spyder*的界面分为三个窗口，如图6-1所示。左侧的窗口用于编写稍后执行的代码（告诉算法运行并应用代码）。通常，您会在该区域看到多行代码。'
- en: The window on the upper right is the *variable explorer*. Every time a variable
    is stored (defined), you can see it there. The window on the lower right is the
    *console* that shows the result of the code, whether it is an error or an output.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 右上角的窗口是*变量资源管理器*。每次存储（定义）一个变量，您都可以在那里看到它。右下角的窗口是*控制台*，显示代码的结果，无论是错误还是输出。
- en: '![](Images/dlf_0601.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dlf_0601.png)'
- en: Figure 6-1\. Spyder’s interface
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1。Spyder的界面
- en: 'Python files have the extension *name.py* and they allow you to save the code
    and refer to it at a later stage. You can also open multiple files of code and
    navigate between them. The outline of this chapter is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Python文件的扩展名为*name.py*，它们允许您保存代码并在以后引用它。您还可以打开多个代码文件并在它们之间导航。本章的大纲如下：
- en: Understand the language of Python and how to write error-free code.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 了解Python语言以及如何编写无错误的代码。
- en: Understand how to use control flow and its importance with time series analysis.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 了解如何使用控制流以及在时间序列分析中的重要性。
- en: Understand what are libraries and functions and their role in facilitating coding.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 了解库和函数是什么以及它们在促进编码中的作用。
- en: Understand how to handle errors and their different types.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 了解如何处理错误及其不同类型。
- en: Understand how to use data manipulation libraries such as `numpy` and `pandas`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 了解如何使用数据操作库，如`numpy`和`pandas`。
- en: Finally, see how to import historical financial time series data into Python
    so that it gets analyzed with the proper tools that you have seen in previous
    chapters but also in the coming chapters.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，看看如何将历史财务时间序列数据导入Python，以便使用您在之前章节和即将到来的章节中看到的适当工具进行分析。
- en: Basic Operations and Syntax
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本操作和语法
- en: '*Syntax* is the proper way of writing error-free code, it is the structure
    of statements needed to write code that functions. When you are communicating
    with a computer, you have to make sure it understands you and therefore, having
    a solid understanding of syntax is important.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*语法*是编写无错误代码的正确方式，它是编写功能代码所需的语句结构。当您与计算机交流时，必须确保它理解您，因此，对语法有扎实的理解很重要。'
- en: 'Understanding code comes with a useful action called comments. A *comment*
    is a non-executable code used to explain the executable code right after. This
    is used so other programmers understand the code. Comments are preceded by a hashtag
    **#**:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 理解代码伴随着一个有用的操作，称为注释。*注释*是用于解释紧随其后的可执行代码的非可执行代码。这是为了让其他程序员理解代码。注释前面有一个井号**#**：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you understand that comments are non-executable. This means that when
    you run (execute) the code, they will be ignored by the interpreter and they will
    not return an error.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您理解注释是不可执行的。这意味着当您运行（执行）代码时，解释器将忽略它们，不会返回错误。
- en: 'Sometimes you need to write documentation for your code which may require multiple
    lines of code (even paragraphs in some instances). Writing the hashtag symbol
    at every line can be tedious and cluttersome. This is why there is a way to write
    long comments. To do this you have to write your comments between three quotes
    at every end as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要为代码编写文档，这可能需要多行代码（甚至在某些情况下是段落）。在每一行写井号符号可能会很繁琐和混乱。这就是为什么有一种方法可以编写长注释。为此，您必须在每个末尾之间写三个引号：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is worth noting that triple quotes are considered *docstrings* and not really
    comments (according to the official Python documentation).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，三引号被认为是*文档字符串*，而不是真正的注释（根据官方Python文档）。
- en: 'Let’s discuss variables and constants. A *constant* is a fixed value that does
    not change while a *variable* takes on different values given an event. A constant
    can be the number 6 while a variable can be the letter *x* which takes on any
    number given a set of conditions or a state. A variable is defined using the ''=''
    operator:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论变量和常量。*常量*是一个固定值，不会改变，而*变量*在事件发生时会取不同的值。常量可以是数字6，而变量可以是字母*x*，根据一组条件或状态取任何数字。使用'='运算符定义变量：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running the previous code will store the variables *x* and *y* with their respective
    values (in the variable explorer). Simultaneously, the output of the code will
    be 6\. Variables are case sensitive, therefore:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码将在变量资源管理器中存储变量*x*和*y*及其相应的值。同时，代码的输出将是6。变量是区分大小写的，因此：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Variable declaration cannot start with a number but it can contain one in the
    middle or the end of its name:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明不能以数字开头，但可以在名称中间或结尾包含一个数字：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Variables can also contain underscores but nothing else:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以包含下划线，但不能包含其他内容：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is heavily recommended that variables are short and straightforward. For
    example, consider creating the variable that holds the lookback period of a certain
    moving average (a concept seen in Chapter 5):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议变量简短而直接。例如，考虑创建一个保存某个移动平均值的回溯期的变量（在第5章中介绍的概念）：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are several different data types with different characteristics:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同特征的数据类型：
- en: '*Numerical data types*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*数值数据类型*'
- en: This is simplest data type. It is formed exclusively from numbers. numerical
    data types are even further divided into integers, float numbers, and complex
    numbers. *Integers* are simple whole numbers (positive or negative). An example
    of an integer would be 6 and -19\. *Float numbers* are more precise than integers
    as they incorporate the values after the comma. An example of a float number would
    be 2.7 and -8.09\. *Complex numbers* include imaginary numbers^([1](ch06.xhtml#idm46147465834784))
    and are less relevant than the other two.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的数据类型。它完全由数字组成。数值数据类型进一步分为整数、浮点数和复数。*整数*是简单的整数（正数或负数）。整数的一个例子是6和-19。*浮点数*比整数更精确，因为它们包含逗号后的值。浮点数的一个例子是2.7和-8.09。*复数*包括虚数，比其他两种类型不太相关。
- en: '*Strings*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*'
- en: As you have seen previously with comments and docstrings, it is possible to
    write text next to the code without it interfering with the execution process.
    *Strings* are text structures that represent sequences of characters. Strings
    can be inputs and arguments of functions and not necessarily just comments.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您之前看到的注释和文档字符串一样，可以在代码旁边写文本而不会干扰执行过程。*字符串*是表示字符序列的文本结构。字符串可以是函数的输入和参数，而不仅仅是注释。
- en: '*Booleans*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*'
- en: This is a binary (true or false) data type used to evaluate the truth value
    of the given expression or condition. For example, you can use booleans to evaluate
    if the market price is above or below the 100-period moving average.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个二进制（真或假）数据类型，用于评估给定表达式或条件的真值。例如，您可以使用布尔值来评估市场价格是否高于或低于100周期移动平均线。
- en: '*Data collection*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据收集*'
- en: These are sequences that contain multiple data with each having a different
    and unique usage. An *array* is a sequence of elements of the same type (mostly
    numerical). Arrays will be used frequently in this book (used with a Python library
    called `numpy` that is discussed in this chapter). A *data frame* is a two-dimensional
    table of structured data that is also frequently used in this book (used with
    a Python library called `pandas` that is discussed in this chapter). A *set* is
    a sequence of unordered elements. A *list* is an ordered collection of elements
    that can be of different data types. A *tuple* is an ordered, immutable collection
    of elements that may be of different data types. It is used for storing a fixed
    sequence of values. A *range* is a built-in Python function that returns a sequence
    of numbers. The range function is mostly used in loops. A *dictionary* represents
    a collection of key-value pairs grouped together.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是包含多个具有不同和独特用途的数据的序列。*数组*是相同类型元素的序列（主要是数字）。数组将在本书中经常使用（与本章讨论的名为`numpy`的Python库一起使用）。*数据框*是结构化数据的二维表，也经常在本书中使用（与本章讨论的名为`pandas`的Python库一起使用）。*集合*是无序元素的序列。*列表*是可以是不同数据类型的有序元素集合。*元组*是有序的、不可变的元素集合，可以是不同数据类型。它用于存储一系列固定值。*范围*是一个内置的Python函数，返回一系列数字。范围函数在循环中经常使用。*字典*表示一组键值对组合。
- en: 'The following code snippet shows a few examples on the numerical data type:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了一些关于数值数据类型的示例：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output should be as follows (remember that anything after the hashtag symbol
    is a comment and will not be executed):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示（请记住井号符号后的任何内容都是注释，不会被执行）：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Strings are simply text. The most famous example of explaining a string is
    the "*Hello World*" phrase as explained in the following code snippet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串只是文本。解释字符串的最著名例子是"*Hello World*"短语，如下面的代码片段所解释的：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output should be as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Strings can also be used as arguments in functions, both concepts you will see
    later in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串也可以作为函数中的参数使用，这两个概念您将在本章后面看到。
- en: 'Booleans as mentioned in the previous list are either true or false values.
    The following code snippet shows an example of using them:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面列表中提到的，布尔值要么为真，要么为假。以下代码片段显示了使用它们的示例：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the previous code is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s discuss how operators work. You have actually already seen an example
    of an operator which is the assignement operator ''='' used to defined variables. *Operators*
    perform special mathematical and other tasks between variables, constants, and
    even data structures. There are different types of operators. Let’s start with
    *arithmetic operators* as shown in the following snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论运算符的工作原理。您实际上已经看到了一个运算符的示例，即用于定义变量的赋值运算符'='。*运算符*在变量、常量甚至数据结构之间执行特殊的数学和其他任务。有不同类型的运算符。让我们从*算术运算符*开始，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next type of operators is the *comparison operators* which are used to
    compare different elements. They are mostly used in control flow events as explained
    in the next section of this chapter. The following snippet shows a few comparison
    operators:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符是下一种运算符，用于比较不同的元素。它们主要用于控制流事件，如本章的下一部分所解释的那样。以下代码片段显示了一些比较运算符：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Logical operators* combine two or more conditions that are later evaluated.
    There are three logical operators: `and`, `or`, and `not`. The following code
    block shows an example of logical operators:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑运算符*结合两个或多个稍后进行评估的条件。有三个逻辑运算符：`and`、`or`和`not`。以下代码块显示了逻辑运算符的示例：'
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Data collection structures (arrays an data frames) are discussed in a later
    section as they require an in-depth presentation due to their complexity and unique
    tools. Let’s end this section with a code that englobes what has been discussed
    so far:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数据收集结构（数组和数据框）将在后面的部分中讨论，因为它们由于其复杂性和独特工具而需要深入介绍。让我们用一个代码来结束这一部分，总结到目前为止讨论的内容：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Control Flow
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: Conditional statements form the first part of what is known as control flow
    (the second part is loops). *Conditional statements* are the ancestors of today’s
    artificial intelligence as they only execute code if certain conditions are met.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句构成了所谓控制流的第一部分（第二部分是循环）。*条件语句*是今天人工智能的祖先，因为它们只在满足某些条件时执行代码。
- en: 'Conditional statements are managed using `if`, `elif`, and `else`. Take the
    following code snippet as an example to clear things out:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句使用`if`、`elif`和`else`进行管理。以以下代码片段为例来澄清事情：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Therefore, conditional statements start with `if`, then for every new unique
    and specific condition, `elif` is used, until it makes sense to use the rest of
    the probability universe as a condition on its own which is used by the `else`
    statement. Note that the `else` statement does not need a condition as it exist
    to cover the rest of the uncovered universe.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，条件语句以`if`开头，然后对于每个新的唯一和特定条件，使用`elif`，直到有意义使用概率宇宙的其余部分作为独立的条件，这是由`else`语句使用的。请注意，`else`语句不需要条件，因为它存在以覆盖未覆盖的宇宙的其余部分。
- en: '*Loops* are used to execute blocks of code repeatedly until a pre-defined condition
    is met. Loops are heavily used with time series to calculate indicators, verify
    states, and to back-test trading strategies.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环*用于重复执行代码块，直到满足预定义条件。循环在时间序列中广泛使用，用于计算指标、验证状态和回测交易策略。'
- en: 'Loops are managed using `for` (used to iterate over a finite and defined sequence
    or a range of elements) and `while` (used to continue the iteration until a condition
    is met) statements. Take as an example the following code that prints the values
    {1, 2, 3, 4} using a loop:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 循环使用`for`（用于迭代有限和定义的序列或一系列元素）和`while`（用于在满足条件之前继续迭代）语句进行管理。以打印值{1, 2, 3, 4}的循环为例：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `for` loop when translated is simply saying that for every element which
    is called `i` (or any other letter depending on the coder) in the range that starts
    at 1 and ends at 5 (excluded), print the value of `i` at every loop (hence, in
    the first loop, the value of `i` is equal to 1 and in the second loop, it is equal
    to 2).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当被翻译时，`for`循环简单地表示对于每个称为`i`（或者根据编码者而定的其他字母）的元素，在从1开始到5结束的范围内（不包括5），在每次循环中打印`i`的值（因此，在第一个循环中，`i`的值等于1，在第二个循环中，它等于2）。
- en: The `while` loop when translated is saying that starting from a value of `i
    = 1`, while looping, print its value and then add 1 to it before finishing the
    first loop. End the loop when `i` becomes greater than 4
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当被翻译时，`while`循环表示从`i = 1`的值开始，循环时，打印其值，然后在完成第一个循环之前将其加1。当`i`变大于4时结束循环。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Theoretically, a `while` loop is infinite until told otherwise.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，`while`循环是无限的，直到另有说明为止。
- en: 'It is worth noting that `i = i + 1` can also be expressed as `i += 1`. The
    goal of an algorithm is the ability to apply many operations recursively in an
    objective way which makes loops extremly useful especially when combined with
    conditional statements. Let’s take an example of a financial time series:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是`i = i + 1`也可以表示为`i += 1`。算法的目标是能够以客观的方式递归地应用许多操作，这使得循环特别有用，尤其是与条件语句结合时。让我们以一个金融时间序列的例子来说明：
- en: Create a range of values to simulate hypothetical daily close prices.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个值范围来模拟假设的每日收盘价。
- en: Loop through the range of the data while creating the condition that if the
    price rose from the last period, print 1\. Similarly, if the price fell from the
    last period, print -1\. Lastly, print 0 if the price didn’t change from last period.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建条件时循环遍历数据范围，如果价格从上一期上涨，则打印1。同样，如果价格从上一期下跌，则打印-1。最后，如果价格与上一期没有变化，则打印0。
- en: 'This can be done in the following code block:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在以下代码块中完成：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code defines a list of values (in this case, a time series called `time_series`),
    then loops around its length using the `len()` function to apply the conditions.
    Notice how at every loop, the current time step is referred to as `i` thus making
    the previous time step `i - 1`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码定义了一个值列表（在这种情况下，一个名为`time_series`的时间序列），然后使用`len()`函数循环遍历其长度以应用条件。请注意，在每次循环中，当前时间步被称为`i`，因此上一个时间步为`i
    - 1`。
- en: Libraries and Functions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库和函数
- en: A *library* in Python is a group of pre-written code that offers functionality
    to make the creation of applications easier. *Modules*, which are individual Python
    files with reusable code and data that can be imported and used in other Python
    code, are commonly found in libraries. A module is therefore a single Python file
    that contains functions and other types of code that may be used and imported
    by other Python programs. Large code bases are often easier to manage and maintain
    by using modules to divide similar code into different files.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，*库*是一组预先编写的代码，提供功能以使应用程序的创建更容易。*模块*是单独的Python文件，具有可重复使用的代码和数据，可以被导入和在其他Python代码中使用，通常在库中找到。因此，模块是一个包含函数和其他类型代码的单个Python文件，可以被其他Python程序使用和导入。通过使用模块将相似的代码分成不同的文件，通常更容易管理和维护大型代码库。
- en: Coding is all about simplifying tasks and making them clearer. When you have
    a recurring task such as calculating a moving average of a time series, you can
    use a function so that you do not have to write the moving average code all over
    again every time you want to use it. Instead, you define the function with the
    original code and then, you call it whenever you need to calculate the moving
    average. But what is a *function*? It is a block of reusable code that performs
    a specific task when called. It needs to be defined once.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 编码是简化任务并使其更清晰的过程。当你有一个重复的任务，比如计算时间序列的移动平均值时，你可以使用一个函数，这样你就不必每次想使用它时都重新编写移动平均代码。相反，你定义一个带有原始代码的函数，然后在需要计算移动平均值时调用它。但是什么是*函数*？它是一个可重复使用的代码块，当被调用时执行特定任务。它需要被定义一次。
- en: Multiple functions form a module and multiple modules form a library. A library
    is generally theme-oriented. For example, in this book, `sklearn` library will
    be used with machine learning models. Similarly, data manipulation and importing
    is done using `numpy` and `pandas`, two libraries discussed in a later section
    of this chapter. Plotting and charting is done using `matplotlib` library.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 多个函数形成一个模块，多个模块形成一个库。一个库通常是以主题为导向的。例如，在这本书中，将使用`sklearn`库与机器学习模型。类似地，数据操作和导入是使用`numpy`和`pandas`完成的，这两个库在本章的后面部分讨论。绘图和图表是使用`matplotlib`库完成的。
- en: 'Libraries must be imported first to the Python interpreter before being used.
    The syntax of doing this is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前，必须先将库导入到Python解释器中。这样做的语法如下：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Sometimes, you need to import just one function or module from a library. For
    this, you don’t need to import the totality of the library:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要从库中导入一个函数或模块。为此，你不需要导入整个库：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So, it is established that `math` is a Python library that harbors many mathematical
    functions, namely `sqrt` function which is used to find the square root of a given
    number. Let’s see how to define a function. A function is defined using `def`
    followed by the name of the function and any optional arguments. Consider the
    following example that creates a function that sums any two given variables:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，已经确定`math`是一个Python库，其中包含许多数学函数，即`sqrt`函数，用于找到给定数字的平方根。让我们看看如何定义一个函数。函数使用`def`后跟函数的名称和任何可选参数来定义。考虑以下示例，创建一个对任意两个给定变量求和的函数：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Calling a function means executing what it’s supposed to do. In other words,
    calling a function is simply using it. The time line of a function is getting
    defined and then getting called.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个函数意味着执行它应该做的事情。换句话说，调用一个函数就是使用它。函数的时间线是被定义然后被调用。
- en: 'Let’s see how to import a function from a library and use its functions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何从库中导入函数并使用它的函数：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As a side note, the *factorial* operation is a mathematical operation that used
    to calculate the product of all positive integers from 1 up to a certain number
    (which is the argument requested in `math.factorial()`).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一则旁注，*阶乘*操作是一种数学操作，用于计算从1到某个数字（在`math.factorial()`中请求的参数）的所有正整数的乘积。
- en: 'Libraries may not be as easy as one plus one. Sometimes, external libraries
    require installation first before being able to be imported to the Python interpreter.
    Installation can be done through the prompt using the following syntax:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 库可能不像1加1那么简单。有时，外部库在能够导入Python解释器之前需要先安装。安装可以通过提示符使用以下语法完成：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s revert back to Chapter 3 where the MIC was discussed. Prior to the following
    already seen code of the MIC:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到第3章讨论过的MIC。在MIC的以下已经看到的代码之前：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Importing the library directly will likely lead to an error as it has not been
    pip installed. Therefore, you must install it first using the following syntax
    on the prompt (not the Python interpreter):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 直接导入库可能会导致错误，因为它尚未通过pip安装。因此，您必须首先使用提示符上的以下语法进行安装（而不是Python解释器）：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It is also important to read the documentation that comes with libraries in
    order to use them correctly. *Documentation* helps knowing the aim of the functions
    and what arguments go inside. Furthermore, it tells you what type of arguments
    the function can accept (for example, strings or numerics). Let’s go back to functions
    now (notice how both are intertwined and discussing one may result in discussing
    the other).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是阅读随库提供的文档，以便正确使用它们。*文档*有助于了解函数的目的以及应该放入哪些参数。此外，它告诉您函数可以接受什么类型的参数（例如，字符串或数字）。现在让我们回到函数（注意它们是如何交织在一起的，讨论一个可能导致讨论另一个）。
- en: 'Functions can have a `return` statement which allows the result to be stored
    in a variable so that it can be used in other parts of the code. Let’s take two
    simple examples and then discuss them step-by-step:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以有一个`return`语句，允许将结果存储在一个变量中，以便在代码的其他部分中使用。让我们举两个简单的例子，然后逐步讨论它们：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The previous code defines the `sum_operation` function with two arguments,
    then stores the operation in a variable called `final_sum` before returning it
    so it can be stored externally. Afterwards, a new variable called `summed_value`
    is defined as the output of the function. Finally, another variable is created
    under the name of `double_summed_value` and is the result of `summed_value` multiplied
    by 2\. This is an example on how to use results from functions as variables in
    external operations. Now, let’s consider another example (while keeping in mind
    the previously defined `sum_operation` function):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码定义了`sum_operation`函数，带有两个参数，然后将操作存储在一个名为`final_sum`的变量中，然后返回它，以便可以将其存储在外部。然后，定义一个名为`summed_value`的新变量，作为函数的输出。最后，另一个名为`double_summed_value`的变量被创建，其结果是`summed_value`乘以2。这是一个关于如何在外部操作中使用函数结果作为变量的示例。现在，让我们考虑另一个示例（同时记住先前定义的`sum_operation`函数）：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The latest code snippet defines a function called `square_summed_value` which
    takes on two arguments. Furthermore, it uses a nested function inside which in
    this case is `sum_operation`. The result of the nested function is once again
    stored in a variable called `final_sum` which is used as an input in finding the
    `squared_sum variable`. The variable is found as `final_sum` to the power of two.
    This was an example on how to create functions out of other functions inside of
    them (in other words, nested functions).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的代码片段定义了一个名为`square_summed_value`的函数，它接受两个参数。此外，它在内部使用了一个嵌套函数，这种情况下是`sum_operation`。嵌套函数的结果再次存储在一个名为`final_sum`的变量中，该变量用作查找`squared_sum
    variable`的输入。该变量被找到为`final_sum`的平方。这是一个关于如何在函数内部创建其他函数的示例（换句话说，嵌套函数）。
- en: 'Let’s end the section with common libraries in Python and machine learning
    (other than `numpy` and `pandas`):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Python和机器学习中常见的库结束本节（除了`numpy`和`pandas`）：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Exceptions Handling and Errors
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理和错误
- en: 'Quite often you will run into errors due to issues with the code during execution.
    In other words, errors occur when the code is executed and the interpreter finds
    an obstacle that prevents it from continuing further. The most basic error is
    *SyntaxError* which occurs when there are misspelled words or missing elements
    which make the code unintelligible:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 经常会因为代码在执行过程中出现问题而遇到错误。换句话说，当代码执行时，解释器发现阻止其继续进行的障碍时，就会发生错误。最基本的错误是*SyntaxError*，当有拼写错误或缺少元素使代码无法理解时会发生：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see from the previous code, there is a missing parenthesis at the
    end of the second code line, which is not understood by the interpreter. This
    type of error is likely to be the most common one. Another common error is *NameError*
    which occurs when failing to define a variable before executing a code that contains
    it. Consider the following example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看到，第二行代码末尾缺少一个括号，这个错误解释器无法理解。这种类型的错误可能是最常见的。另一个常见的错误是*NameError*，当在执行包含它的代码之前未定义变量时会发生。考虑以下示例：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The previous code will give you a *NameError* because the interpreter does not
    know the value of `x` and `y` since they were not defined.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码会给出一个*NameError*，因为解释器不知道`x`和`y`的值，因为它们没有被定义。
- en: 'The *ModuleNotFoundError* occurs when the interpreter cannot find the library
    or module you are trying to import. This generally occurs when it is installed
    in the bad directory or when it is not properly installed. Common fixes for this
    issue include:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*ModuleNotFoundError*发生在解释器无法找到您尝试导入的库或模块时。这通常发生在它安装在错误的目录或未正确安装时。解决此问题的常见方法包括：'
- en: Verifying if the module’s name has been written correctly.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证模块的名称是否已正确书写。
- en: Verifying if the module has been correctly pip installed.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证模块是否已正确通过pip安装。
- en: Verifying if the module is installed in the correct location.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证模块是否安装在正确的位置。
- en: 'Another type of common errors is *TypeError* and it occurs when you apply a
    certain operation on an incompatible element such as summing an integer with a
    string. The following operation raises a *TypeError*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见错误类型是*TypeError*，当你在不兼容的元素上应用某种操作时会发生，比如将整数与字符串相加。以下操作会引发*TypeError*：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In time series analysis, you will likely to encounter these four errors:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列分析中，你可能会遇到这四种错误：
- en: '*IndexError*: This is raised referring to an index that is out of range regarding
    the current array or data frame. Imagine having an array of 300 values (rows).
    If you want to loop through them and at each loop, you want to input the number
    1 in the next cell (time step + 1), you are likely to encounter an *IndexError*
    as in the last loop, there is no next cell and the interpreter will raise this
    error.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IndexError*: 当涉及到当前数组或数据框范围之外的索引时，会引发此错误。想象一下有一个包含300个值（行）的数组。如果你想循环遍历它们，并在每次循环时将数字1输入到下一个单元格（时间步长+1），你很可能会遇到*IndexError*，因为在最后一个循环中，没有下一个单元格，解释器会引发此错误。'
- en: '*ValueError*: This is raised when you try to call a function with an invalid
    argument. An example of this would to be try to pass an integer element as a string
    when calling a function.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ValueError*: 当你尝试使用无效参数调用函数时会引发此错误。例如，尝试在调用函数时将整数元素传递为字符串。'
- en: '*KeyError*: This occurs when trying to access an element in a data frame that
    does not exist. For example, if you have three columns in the data frame and you
    refer to one that does not exist (maybe due to a syntax issue), you are likely
    to run into a *KeyError*.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*KeyError*: 当尝试访问数据框中不存在的元素时会发生此错误。例如，如果数据框中有三列，而你引用了一个不存在的列（可能是由于语法问题），你很可能会遇到*KeyError*。'
- en: '*ZeroDivisionError*: This error is intuitive and occurs when trying to divide
    a number by zero.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ZeroDivisionError*: 这个错误很直观，当尝试将一个数字除以零时会发生。'
- en: There are other types of errors that you may encounter. It is important to understand
    what they refer to so that you are able to fix them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到其他类型的错误。重要的是要理解它们指的是什么，这样你才能够修复它们。
- en: '*Exceptions* on the other hand may be not fatal to the code in the sense that
    they only show a warning but not necessarily terminate the code. Therefore, exceptions
    occurs during the execution (as opposed to errors which occur because the interpreter
    is unable to execute).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*Exceptions*可能对代码并不致命，因为它们只是显示一个警告，但不一定终止代码。因此，异常发生在执行过程中（与错误不同，错误是因为解释器无法执行）。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Understanding the error will help you fixing it and getting the code running
    again.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 理解错误将有助于你修复它并使代码重新运行。
- en: 'To ignore certain exceptions, the `try`  and `except` keywords are used. This
    is useful when you are certain that handling the exception will not alter the
    output of the code. Let’s take an example of creating a function that divides
    the first column of a time series by the next value of the second column. The
    first step is to define the time series as a data frame or as an array (or any
    other data collection structure):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了忽略某些异常，使用`try`和`except`关键字。当你确信处理异常不会改变代码的输出时，这是很有用的。让我们举一个例子，创建一个函数，将时间序列的第一列除以第二列的下一个值。第一步是将时间序列定义为数据框或数组（或任何其他数据集合结构）：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let’s write the division function which will take any value in the first
    column and divide it by the next value in the second column:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个除以第二列中的下一个值的除法函数，该函数将接受第一列中的任何值：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Running the two previous code blocks will give an *IndexError* because in the
    last loop, the function cannot find the next value of the second column because
    it simply does not exist:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前两个代码块将会产生*IndexError*，因为在最后一个循环中，函数找不到第二列的下一个值，因为它根本不存在：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Fixing this through `try` and `except` will ignore the last calculation that
    is causing the problem and will return the expected results:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`try`和`except`来修复这个问题将忽略导致问题的最后一个计算，并返回预期的结果：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This section discussed errors and exceptions and how you can handle such issues.
    In the coming chapters, such issues will be handled using `try` and `except` blocks
    due to their simplicity and effectiveness.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了错误和异常以及如何处理这些问题。在接下来的章节中，由于其简单性和有效性，这些问题将使用`try`和`except`块来处理。
- en: Data Structures in Numpy and Pandas
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Numpy和Pandas中的数据结构
- en: 'The words `numpy` and `pandas` may come familiar to you since I have used them
    in most of the code snippets in the previous chapters. Moreover, you now understand
    what a library is and therefore, you know that these two are the go-to libraries
    to manipulate, handle, and import data in Python. This section shows the differences
    between the two and their key functions that are definitely a great addition to
    your data analysis. But first, let’s define these two libraries:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy` 和 `pandas` 这两个词可能对你来说很熟悉，因为我在前几章的大部分代码片段中都用到了它们。此外，你现在了解了什么是库，因此你知道这两个库是用来在Python中操作、处理和导入数据的首选库。本节展示了这两者之间的区别以及它们的关键功能，这绝对是你数据分析的重要补充。但首先，让我们定义这两个库：'
- en: '*numpy*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*numpy*'
- en: NumPy (short for Numerical Python) is a Python library that allows working with
    multi-dimensional arrays and matrices. NumPy provides a powerful  interface for
    performing various operations on arrays and matrices.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy（Numerical Python的缩写）是一个允许处理多维数组和矩阵的Python库。NumPy提供了一个强大的接口，用于对数组和矩阵执行各种操作。
- en: '*pandas*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*pandas*'
- en: 'Pandas (short for Panel Data) is a Python library that allows working with
    data frames (a type of tabular data). Pandas provides two main data structures:
    series and data frames. A *series* is a one-dimensional array-like object that
    can hold any data type. A *data frame* is a two-dimensional table-like structure
    that consists of rows and columns (similar to a spreadsheet).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas（Panel Data的缩写）是一个允许处理数据框（一种表格数据类型）的Python库。Pandas提供了两种主要的数据结构：series和data
    frames。*series* 是一个类似于一维数组的对象，可以保存任何数据类型。*data frame* 是一个类似于二维表格的结构，由行和列组成（类似于电子表格）。
- en: Both libraries are very useful in analyzing time series data. Arrays hold only
    numerical type data and therefore, they do not really hold date type data as opposed
    to data frames. This may be one of the advantages of using `pandas` as opposed
    to `numpy` but both have the strengths and relative weaknesses. In the end, it
    is a matter of choice. This book will prioritize using numpy due to the simplicity
    and due to the fact that the machine learning models seen in the next chapter
    use `sklearn` library which is applied on arrays. This must not prevent you from
    using data frames until you are ready to apply the models.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个库在分析时间序列数据方面非常有用。数组仅包含数值类型数据，因此与数据框不同，它们实际上不包含日期类型数据。这可能是使用`pandas`相对于`numpy`的优势之一，但两者都有各自的优势和相对弱点。最终，这是一个选择的问题。本书将优先使用numpy，因为其简单性以及下一章中看到的机器学习模型使用`sklearn`库，该库适用于数组。这不应阻止您在准备应用模型之前使用数据框。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Switching between `numpy` and `pandas` requires converting the time series type.
    It is a relatively easy task but can sometimes cause loss of certain types of
    data (for example, date data).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`numpy`和`pandas`之间切换需要转换时间序列类型。这是一个相对容易的任务，但有时可能会导致某些类型数据的丢失（例如日期数据）。
- en: 'Let’s import both libraries before starting to see some of their potential:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在开始之前导入这两个库，看看它们的一些潜力：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following code creates two time series with two columns and three rows.
    The first time series is called `my_data_frame` and is created using the function
    `pd.DataFrame` of `pandas`. The second time series is called `my_array` and is
    created using the function `np.array` of `numpy`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了两个具有两列和三行的时间序列。第一个时间序列称为`my_data_frame`，使用`pandas`的`pd.DataFrame`函数创建。第二个时间序列称为`my_array`，使用`numpy`的`np.array`函数创建：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As can be seen from Figure 6-2, data frames have real indexes and can have
    column names. Arrays are purely numerical and do not allow for this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如图6-2所示，数据框具有真实的索引并且可以有列名。数组是纯数值的，不允许这样做：
- en: '![](Images/dlf_0506.PNG)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dlf_0506.PNG)'
- en: Figure 6-2\. On the left, a data frame (pandas) and on the right, an array (numpy)
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-2。左侧是数据框（pandas），右侧是数组（numpy）
- en: 'To switch between the two types of data, it is quite intuitive as you will
    be using the same two functions used in the previous code block:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种数据类型之间切换是非常直观的，因为您将使用前一个代码块中使用的相同两个函数：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can notice that `my_new_data_frame` does not have column names.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以注意到`my_new_data_frame`没有列名。
- en: 'Let’s now take a look at useful functions that will come in handy when dealing
    with models. Slicing, concatenating, and other tools are things that you must
    master in order to smoothly navigate through the data analysis part. Consider
    the following arrays:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一些在处理模型时会派上用场的有用函数。切片、连接和其他工具是您必须掌握的东西，以便顺利地在数据分析部分中导航。考虑以下数组：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Concatenation* is the act of fusing two datasets together either through rows
    (axis = 0) or through columns (axis = 1). Let’s do both of them:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*连接*是将两个数据集通过行（axis = 0）或列（axis = 1）融合在一起的行为。让我们都做一遍：'
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let’s do the same thing for data frames. Consider the following data frames:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为数据框做同样的事情。考虑以下数据框：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Concatenation is useful when you want to combine data into one structure. This
    is how it can be done with data frames (notice how it’s simply a change of syntax
    and function source):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要将数据合并到一个结构中时，连接是很有用的。这是如何在数据框中完成的（注意它只是一种语法和函数来源的变化）：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Remember that with time series, *rows* (horizontal cells) represent one time
    step (for example, hourly) with all the data inside while *columns* represent
    the different types of data (for example, open price and close price of a financial
    instrument). Now let’s see slicing techniques for arrays:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于时间序列，*行*（水平单元格）代表一个时间步长（例如，每小时），其中包含所有数据，而*列*代表不同类型的数据（例如，金融工具的开盘价和收盘价）。现在让我们看一下数组的切片技术：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to know that Python indexing starts at zero. This means that
    to refer to the first element in a data structure, you refer to its index as index
    = 0\. On another note, it is also worth noting that in ranges, the last element
    is excluded which means that the first three elements in a data structure are
    referred to as [0, 3] which will give the elements indexed at 0, 1, and 2.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道Python的索引从零开始。这意味着要引用数据结构中的第一个元素，您需要将其索引称为index = 0。另外，值得注意的是，在范围中，最后一个元素是排除在外的，这意味着数据结构中的前三个元素被称为[0,
    3]，这将给出索引为0、1和2的元素。
- en: 'Let’s see the same thing for data frames so that this section becomes a sort
    of a mini encyclopedia whenever you want to manipulate data structures:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看数据框的情况，以便在您想要操作数据结构时，本节成为一种小百科全书：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Try going back to the earlier chapters to execute the code given there. You
    should have a more solid understanding by now.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试回到之前的章节执行那里给出的代码。到现在为止，您应该有了更牢固的理解。
- en: Importing Financial Time Series in Python
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中导入金融时间序列
- en: This section presents a key part in deploying machine and deep learning algorithms.
    It deals with the historical OHLC data that is needed to run the models and evaluate
    their performance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了部署机器和深度学习算法的关键部分。它涉及到运行模型和评估其性能所需的历史OHLC数据。
- en: 'The first step is to prepare the environment and everything else necessary
    for the success of the algorithms. For this, you need two programs:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是准备环境和算法成功所需的一切。为此，您需要两个程序：
- en: A Python interpreter that you use to write and execute code. You have already
    completed this step.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您用于编写和执行代码的Python解释器。您已经完成了这一步。
- en: Charting and financial software that you use as a database. This part is covered
    in this section.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您使用作为数据库的图表和金融软件。这部分内容在本节中涵盖。
- en: 'Throughout the book, I use *MetaTrader 5*, a benchmark charting program used
    by many traders around the globe. Follow these steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我使用*MetaTrader 5*，这是许多全球交易员使用的基准图表程序。按照以下步骤操作：
- en: Download SPYDER and familiarize yourself with how it works.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载SPYDER并熟悉其工作方式。
- en: Download the MetaTrader 5 software.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载MetaTrader 5软件。
- en: Use SPYDER to import historical prices from MetaTrader 5.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用SPYDER从MetaTrader 5导入历史价格。
- en: From the [official website](https://www.metatrader5.com/en), download and install
    MetaTrader 5\. You need to create a demo account, which is simply a virtual account
    with imaginary money. The word *demo* does not refer to a limited duration of
    use but to the fact that it is not using real money.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从[官方网站](https://www.metatrader5.com/en)下载并安装MetaTrader 5。您需要创建一个演示账户，这只是一个带有虚拟货币的虚拟账户。单词*demo*并不是指使用的时间有限，而是指它不使用真实货币。
- en: To open an account, select *File* > *Open an Account*, choose MetaQuotes Software
    Corp, and then click *Next*. Then, choose the first option to open a demo account;
    this will let you trade virtual money. Finally, enter some basic information such
    as name, email, and account type. You will not receive a verification request
    or any type of confirmation as the demo should launch directly, allowing you to
    see the charts.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要开设账户，选择*File* > *Open an Account*，选择MetaQuotes Software Corp，然后单击*Next*。然后，选择第一个选项以开设演示账户；这将让您交易虚拟货币。最后，输入一些基本信息，如姓名、电子邮件和账户类型。您将不会收到验证请求或任何类型的确认，因为演示应该直接启动，让您看到图表。
- en: Figure 6-3 shows the platform’s interface. By default, MetaTrader 5 does not
    show all the markets it covers, so you need to make them accessible for import
    and visualization if necessary. Click *View*, click *Market Watch*, and then right-click
    any of the symbols shown in the new tab and choose *Show All*. This way you can
    see the extended list with more markets.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3显示了平台的界面。默认情况下，MetaTrader 5不显示其涵盖的所有市场，因此您需要使它们可供导入和可视化。单击*View*，单击*Market
    Watch*，然后右键单击新标签中显示的任何符号，并选择*Show All*。这样您就可以看到更多市场的扩展列表。
- en: '![](Images/dlf_0603.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dlf_0603.png)'
- en: Figure 6-3\. MetaTrader’s 5 interface
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-3. MetaTrader 5界面
- en: 'Before proceeding to the coding part, you need to install the MetaTrader 5
    Python integration library so you can use it later in Spyder. This is easy and
    requires one step. Open the Anaconda prompt and type:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行编码之前，您需要安装MetaTrader 5 Python集成库，以便以后在Spyder中使用。这很容易，只需一步。打开Anaconda提示符并键入：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Installation is the bridge that allows you to use Python modules and functions
    designed for MetaTrader 5 in the interpreter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 安装是一个桥梁，它允许您在解释器中使用为MetaTrader 5设计的Python模块和函数。
- en: 'The following code block uses the `import` built-in statement, which calls
    for internal (self-created) or external (created by third parties) libraries.
    A library is a store of functions, and thus, you need to import the libraries
    that are pertinent to what you want to do. For demonstration purposes, import
    the following modules, packages, and libraries:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块使用了`import`内置语句，该语句调用内部（自己创建的）或外部（由第三方创建的）库。库是函数的存储库，因此，您需要导入与您要做的事情相关的库。为了演示目的，导入以下模块、包和库：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The next step is to create the universe of the time frames that you will be
    able to import. Even though I will be showing you how to analyze and back-test
    hourly data, you can define a wider universe, as shown in the following code snippet:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建您可以导入的时间框架的范围。即使我将向您展示如何分析和回测每小时数据，您也可以定义一个更广泛的时间框架，如下面的代码片段所示：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The full code is found in the GitHub repository under the name *Master_Function.py*
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在GitHub存储库中找到，名称为*Master_Function.py*
- en: A *time frame* is the frequency with which you record the prices. With hourly
    data, you will record the last price printed every hour. This means that in a
    day, you can have up to 24 hourly prices. This allows you to see the intraday
    evolution of the price. The aim is to record the totality of the OHLC data within
    a specific period.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*time frame*是您记录价格的频率。使用每小时数据，您将每小时记录最后一个价格。这意味着在一天内，您可以有多达24个每小时的价格。这使您能够看到价格的日内演变。目标是记录特定时间段内的OHLC数据的全部内容。'
- en: 'The following code defines the current time, which is used so that the algorithm
    has a reference point when importing the data. Basically, you are creating a variable
    that stores the current time and date:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了当前时间，用于算法在导入数据时有一个参考点。基本上，您正在创建一个存储当前时间和日期的变量：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let’s now proceed to defining the universe of the financial instruments you
    want to back-test. In this book, the back-tests will be done exclusively on the
    FX market. Therefore, let’s create a variable that stores some key currency pairs:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续定义您想要进行回测的金融工具的范围。在本书中，回测将专门在外汇市场上进行。因此，让我们创建一个存储一些关键货币对的变量：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now that you have your time and asset variables ready, all you need is to create
    the structure of the importing algorithm. The `get_quotes()` function does this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好了时间和资产变量，您所需要做的就是创建导入算法的结构。`get_quotes()`函数完成了这个任务：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Notice that in the `get_quotes()` function, you use the `pytz`and `pandas` libraries.
    The function starts by defining the *Olson* time zone, which you can set yourself.
    Here is a brief, nonexhaustive list of what you can enter depending on your time
    zone:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`get_quotes()`函数中，您使用了`pytz`和`pandas`库。该函数首先通过定义*Olson*时区开始，您可以自行设置。以下是一个简要的、非详尽的列表，根据您的时区，您可以输入以下内容：
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Afterward, I define two variables called `time_from` and `time_to`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我定义了两个变量`time_from`和`time_to`：
- en: The `time_from` variable contains the datetime referring to the beginning of
    the import date (e.g., 01-01-2020).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time_from`变量包含了引用导入日期开始的日期时间（例如，2020年01月01日）。'
- en: The `time_to` variable contains the datetime referring to the end of the import
    date which uses the `now` variable to represent the current time and date.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time_to`变量包含了引用导入日期结束的日期时间，使用`now`变量表示当前时间和日期。'
- en: 'The next step is to create a variable that imports the financial data using
    the time periods you have specified. This is done through the `rates` variable
    using the `mt5.copy_rates_range()` function. Finally, using `pandas`, transform
    the data into a data frame. The final function required for the importing process
    is the `mass_import()` function. It lets you choose the time frame using the variable
    and then uses the `get_quotes()` function to import the data and format it to
    an array. The following code snippet defines the `mass_import()` function:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个变量，使用您指定的时间段导入金融数据。这是通过使用`mt5.copy_rates_range()`函数的`rates`变量完成的。最后，使用`pandas`将数据转换为数据框。导入过程所需的最终函数是`mass_import()`函数。它允许您使用变量选择时间范围，然后使用`get_quotes()`函数导入数据并将其格式化为数组。以下代码片段定义了`mass_import()`函数：
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `mass_import()` function automatically converts the data frame into an array,
    so you do not have to worry about conversion when using the automatic import.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`mass_import()`函数会自动将数据框转换为数组，因此在使用自动导入时无需担心转换问题。'
- en: Note
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The algorithm imports a number of historical data limited by MetaTrader 5\.
    Although that number is high, in time you may need to adjust the year argument
    higher in order to get the data. For instance, if you get an empty array using
    the `mass_import()` function, try putting a more recent year in the `get_quotes()` function
    (“2014” instead of “2013”).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法导入了一定数量的历史数据，受到MetaTrader 5的限制。尽管这个数字很高，但随着时间的推移，您可能需要调整年份参数以获取数据。例如，如果使用`mass_import()`函数时得到一个空数组，尝试在`get_quotes()`函数中放入一个更新的年份（比如“2014”而不是“2013”）。
- en: 'To import the historical hourly EURUSD data since beginning of 2014 to date,
    you may type the following (assuming `get_quotes()`, `now`, the frames, and the
    libraries are already defined):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入自2014年初以来的历史每小时EURUSD数据，您可以输入以下内容（假设`get_quotes()`、`now`、数据框和库已经定义）：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how the `return` statement is used in the `mass_import` function in order
    to store the historical data in chosen variables.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`return`语句如何在`mass_import`函数中用于将历史数据存储在选择的变量中。
- en: Even though there is a MAC version of MetaTrader 5, the Python library only
    works on Windows. It requires a Windows emulator on a Mac. For Mac users, you
    may want to try the manual import method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管MetaTrader 5有MAC版本，但Python库只能在Windows上运行。在Mac上需要使用Windows模拟器。对于Mac用户，您可能想尝试手动导入方法。
- en: Automatic import is a huge time saver but MAC users or even Windows users may
    run into frustrating errors. For this, I will show you the manual import way which
    you can use as a fix. In the GitHub link, you will find a folder called Historical
    Data. Inside the folder there is a selection of historical financial time series
    in the form of excel which you can download.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 自动导入是一个巨大的时间节省，但MAC用户甚至Windows用户可能会遇到令人沮丧的错误。因此，我将向您展示手动导入的方法，您可以将其用作修复。在GitHub链接中，您会找到一个名为Historical
    Data的文件夹。文件夹中有一些历史金融时间序列的excel形式，您可以下载。
- en: The manual way is to have an Excel file with OHLC data that you have downloaded
    from a third party (such as the excel files provided in the Github repository).
    In this case, you can use the `pandas` library to import it and transform it into
    an array.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 手动方式是使用从第三方下载的包含OHLC数据的Excel文件（例如GitHub存储库中提供的excel文件）的方法。在这种情况下，您可以使用`pandas`库导入并将其转换为数组。
- en: 'Let’s take an example of *eurusd_data**.* Download and the file and store it
    on your desktop. You now have to make sure that the Spyder’s directory is in the
    same place as the file (so, in the desktop). In layperson’s terms, Spyder must
    search the desktop for the Excel file. To choose the right directory, you must
    click the folder button next to the arrow, as shown in Figure 6-4:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以*eurusd_data*为例。下载文件并将其存储在桌面上。现在，您必须确保Spyder的目录与文件在同一位置（即桌面）。通俗地说，Spyder必须在桌面上搜索Excel文件。要选择正确的目录，您必须点击箭头旁边的文件夹按钮，如图6-4所示：
- en: '![](Images/dlf_0604.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dlf_0604.png)'
- en: Figure 6-4\. Directory tab
  id: totrans-235
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-4. 目录选项卡
- en: 'You should get a separate window where you can choose the desktop location
    and then validate the choice. Having done this, the tab should look like Figure
    6-5:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到一个单独的窗口，您可以在其中选择桌面位置，然后验证选择。完成这些步骤后，选项卡应该看起来像图6-5：
- en: '![](Images/dlf_0605.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dlf_0605.png)'
- en: Figure 6-5\. Directory tab
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-5. 目录选项卡
- en: 'You must use the `read_excel()` function (built-in in `pandas` and accessible
    after importing it) to get the values inside the Excel file. Follow this syntax:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须使用`read_excel()`函数（在导入后可访问的`pandas`内置函数）来获取Excel文件中的值。按照以下语法：
- en: '[PRE56]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Right about now, you have a data frame called `eurusd_data` with four different
    columns representing open, high, low, and close prices. You generally have to
    enter the library’s name before using a function that belongs to it; this is why `read_excel()` is
    preceded by `pd`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有一个名为`eurusd_data`的数据框，其中有四列，分别代表开盘价、最高价、最低价和收盘价。通常在使用属于库的函数之前，您必须输入库的名称；这就是为什么`read_excel()`前面有`pd`的原因。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: I recommend using the automatic way for Windows users and the manual way for
    macOS users due to compatibility issues.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议Windows用户使用自动方式，而macOS用户使用手动方式，因为兼容性问题。
- en: You can get an array directly in one line by just adding `.values` to `pd.read_excel('eurusd_data.xlsx')`,
    thus becoming `pd.read_excel('my_data.xlsx')``.values` and resulting in an array
    instead of a data frame.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将`.values`添加到`pd.read_excel('eurusd_data.xlsx')`来直接在一行中获取数组，从而变为`pd.read_excel('my_data.xlsx')``.values`，从而得到一个数组而不是数据框。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Python, one of the stars of coding languages. It did enjoy and still enjoys
    a widespread adoption by the developers’ community. Mastering it is key to unlocking
    huge potential in the data science world.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Python，编程语言之一的明星。它曾经受到并仍然受到开发者社区的广泛采用。掌握它是解锁数据科学世界巨大潜力的关键。
- en: The next chapter presents machine learning and different prediction algorithms.
    The main aim is to understand the intuition and be able to code the algorithms
    and run a back-test over financial data. You will see that once you start understanding
    the process, it becomes a matter of removing an algorithm an plugging another
    (in case they have the same assumptions). The warm-up chapters are over and it’s
    time to start coding.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章介绍机器学习和不同的预测算法。主要目的是理解直觉，并能够编写算法并在金融数据上运行回测。一旦您开始理解这个过程，就变成了删除一个算法并插入另一个算法的问题（如果它们有相同的假设）。热身章节已经结束，现在是开始编码的时候了。
- en: ^([1](ch06.xhtml#idm46147465834784-marker)) Imaginary numbers are a type of
    complex number that represent the square root of a negative number.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 虚数是一种代表负数的平方根的复数类型。
