- en: Chapter 6\. Introductory Python for Data Science
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One more stop to go before diving into the realm of machine and deep learning.
    This chapter is optional for experienced Python developers but is crucial for
    anyone without a solid programming background. Understanding the intuition behind
    the algorithms is a great advantage but it will not get you far if you fail to
    properly implement them. After all, these algorithms need code to work and do
    not function manually. Make sure to understand the basic syntax and how to manipulate
    data and transform it.
  prefs: []
  type: TYPE_NORMAL
- en: As the book is not meant to be an A-Z guide to programming in Python, this chapter
    gently brushes on some essentials and a few more techniques that should help you
    navigate smoothly the subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Coding* is defined as a set of instructions designed to be executed by a computer.
    Generally, specific syntax is required so that the computer applies the set of
    instructions without errors. There are many coding languages and are divided into
    two broad categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Low-level coding languages
  prefs: []
  type: TYPE_NORMAL
- en: These are machine languages usually for operating systems and firmwares. They
    are very difficult to read. These languages have a sizable level of control over
    hardware. An example of a low-level language is assembly (with its various types).
  prefs: []
  type: TYPE_NORMAL
- en: High-level coding languages
  prefs: []
  type: TYPE_NORMAL
- en: These are user-friendly languages (with a high level of abstraction). They are
    generally used to code programs and softwares. An example of a high-level language
    is Python and Julia.
  prefs: []
  type: TYPE_NORMAL
- en: The coding language used in this book is *Python*, a popular and versatile language
    with many advantages and wide adoption in the research and professional community.
    As you have seen from the chapter’s name, you will see an introduction to Python
    with the necessary tools to start building your own scripts. But before that,
    let’s see how to actually download Python.
  prefs: []
  type: TYPE_NORMAL
- en: A *Python interpreter* is a software used to write and execute code written
    using Python syntax. I use a software called *Spyder*. Some people may be more
    familiar with other interpreters such as *Jupyter* and *PyCharm*, but the process
    is the same. You can download *Spyder* from the [official website](https://www.spyder-ide.org/) or,
    even better, download it as part of a bigger package called [Anaconda](https://oreil.ly/nI8Ed),
    which facilitates installation and offers more tools. Note that it is an open
    source and free-to-use software.
  prefs: []
  type: TYPE_NORMAL
- en: '*Spyder’s* interface is split into three windows, as you can see in Figure
    6-1. The window on the left is used to write the code that is later executed (the
    algorithm is told to run and apply the code). Typically, you will see multiple
    lines of code in that area.'
  prefs: []
  type: TYPE_NORMAL
- en: The window on the upper right is the *variable explorer*. Every time a variable
    is stored (defined), you can see it there. The window on the lower right is the
    *console* that shows the result of the code, whether it is an error or an output.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Spyder’s interface
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Python files have the extension *name.py* and they allow you to save the code
    and refer to it at a later stage. You can also open multiple files of code and
    navigate between them. The outline of this chapter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the language of Python and how to write error-free code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understand how to use control flow and its importance with time series analysis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understand what are libraries and functions and their role in facilitating coding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understand how to handle errors and their different types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understand how to use data manipulation libraries such as `numpy` and `pandas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, see how to import historical financial time series data into Python
    so that it gets analyzed with the proper tools that you have seen in previous
    chapters but also in the coming chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Basic Operations and Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Syntax* is the proper way of writing error-free code, it is the structure
    of statements needed to write code that functions. When you are communicating
    with a computer, you have to make sure it understands you and therefore, having
    a solid understanding of syntax is important.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding code comes with a useful action called comments. A *comment*
    is a non-executable code used to explain the executable code right after. This
    is used so other programmers understand the code. Comments are preceded by a hashtag
    **#**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Make sure you understand that comments are non-executable. This means that when
    you run (execute) the code, they will be ignored by the interpreter and they will
    not return an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you need to write documentation for your code which may require multiple
    lines of code (even paragraphs in some instances). Writing the hashtag symbol
    at every line can be tedious and cluttersome. This is why there is a way to write
    long comments. To do this you have to write your comments between three quotes
    at every end as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that triple quotes are considered *docstrings* and not really
    comments (according to the official Python documentation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s discuss variables and constants. A *constant* is a fixed value that does
    not change while a *variable* takes on different values given an event. A constant
    can be the number 6 while a variable can be the letter *x* which takes on any
    number given a set of conditions or a state. A variable is defined using the ''=''
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the previous code will store the variables *x* and *y* with their respective
    values (in the variable explorer). Simultaneously, the output of the code will
    be 6\. Variables are case sensitive, therefore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Variable declaration cannot start with a number but it can contain one in the
    middle or the end of its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables can also contain underscores but nothing else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It is heavily recommended that variables are short and straightforward. For
    example, consider creating the variable that holds the lookback period of a certain
    moving average (a concept seen in Chapter 5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several different data types with different characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Numerical data types*'
  prefs: []
  type: TYPE_NORMAL
- en: This is simplest data type. It is formed exclusively from numbers. numerical
    data types are even further divided into integers, float numbers, and complex
    numbers. *Integers* are simple whole numbers (positive or negative). An example
    of an integer would be 6 and -19\. *Float numbers* are more precise than integers
    as they incorporate the values after the comma. An example of a float number would
    be 2.7 and -8.09\. *Complex numbers* include imaginary numbers^([1](ch06.xhtml#idm46147465834784))
    and are less relevant than the other two.
  prefs: []
  type: TYPE_NORMAL
- en: '*Strings*'
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen previously with comments and docstrings, it is possible to
    write text next to the code without it interfering with the execution process.
    *Strings* are text structures that represent sequences of characters. Strings
    can be inputs and arguments of functions and not necessarily just comments.
  prefs: []
  type: TYPE_NORMAL
- en: '*Booleans*'
  prefs: []
  type: TYPE_NORMAL
- en: This is a binary (true or false) data type used to evaluate the truth value
    of the given expression or condition. For example, you can use booleans to evaluate
    if the market price is above or below the 100-period moving average.
  prefs: []
  type: TYPE_NORMAL
- en: '*Data collection*'
  prefs: []
  type: TYPE_NORMAL
- en: These are sequences that contain multiple data with each having a different
    and unique usage. An *array* is a sequence of elements of the same type (mostly
    numerical). Arrays will be used frequently in this book (used with a Python library
    called `numpy` that is discussed in this chapter). A *data frame* is a two-dimensional
    table of structured data that is also frequently used in this book (used with
    a Python library called `pandas` that is discussed in this chapter). A *set* is
    a sequence of unordered elements. A *list* is an ordered collection of elements
    that can be of different data types. A *tuple* is an ordered, immutable collection
    of elements that may be of different data types. It is used for storing a fixed
    sequence of values. A *range* is a built-in Python function that returns a sequence
    of numbers. The range function is mostly used in loops. A *dictionary* represents
    a collection of key-value pairs grouped together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows a few examples on the numerical data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows (remember that anything after the hashtag symbol
    is a comment and will not be executed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings are simply text. The most famous example of explaining a string is
    the "*Hello World*" phrase as explained in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Strings can also be used as arguments in functions, both concepts you will see
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Booleans as mentioned in the previous list are either true or false values.
    The following code snippet shows an example of using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s discuss how operators work. You have actually already seen an example
    of an operator which is the assignement operator ''='' used to defined variables. *Operators*
    perform special mathematical and other tasks between variables, constants, and
    even data structures. There are different types of operators. Let’s start with
    *arithmetic operators* as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next type of operators is the *comparison operators* which are used to
    compare different elements. They are mostly used in control flow events as explained
    in the next section of this chapter. The following snippet shows a few comparison
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Logical operators* combine two or more conditions that are later evaluated.
    There are three logical operators: `and`, `or`, and `not`. The following code
    block shows an example of logical operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Data collection structures (arrays an data frames) are discussed in a later
    section as they require an in-depth presentation due to their complexity and unique
    tools. Let’s end this section with a code that englobes what has been discussed
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Control Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conditional statements form the first part of what is known as control flow
    (the second part is loops). *Conditional statements* are the ancestors of today’s
    artificial intelligence as they only execute code if certain conditions are met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditional statements are managed using `if`, `elif`, and `else`. Take the
    following code snippet as an example to clear things out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, conditional statements start with `if`, then for every new unique
    and specific condition, `elif` is used, until it makes sense to use the rest of
    the probability universe as a condition on its own which is used by the `else`
    statement. Note that the `else` statement does not need a condition as it exist
    to cover the rest of the uncovered universe.
  prefs: []
  type: TYPE_NORMAL
- en: '*Loops* are used to execute blocks of code repeatedly until a pre-defined condition
    is met. Loops are heavily used with time series to calculate indicators, verify
    states, and to back-test trading strategies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Loops are managed using `for` (used to iterate over a finite and defined sequence
    or a range of elements) and `while` (used to continue the iteration until a condition
    is met) statements. Take as an example the following code that prints the values
    {1, 2, 3, 4} using a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop when translated is simply saying that for every element which
    is called `i` (or any other letter depending on the coder) in the range that starts
    at 1 and ends at 5 (excluded), print the value of `i` at every loop (hence, in
    the first loop, the value of `i` is equal to 1 and in the second loop, it is equal
    to 2).
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop when translated is saying that starting from a value of `i
    = 1`, while looping, print its value and then add 1 to it before finishing the
    first loop. End the loop when `i` becomes greater than 4
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Theoretically, a `while` loop is infinite until told otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that `i = i + 1` can also be expressed as `i += 1`. The
    goal of an algorithm is the ability to apply many operations recursively in an
    objective way which makes loops extremly useful especially when combined with
    conditional statements. Let’s take an example of a financial time series:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a range of values to simulate hypothetical daily close prices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through the range of the data while creating the condition that if the
    price rose from the last period, print 1\. Similarly, if the price fell from the
    last period, print -1\. Lastly, print 0 if the price didn’t change from last period.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This can be done in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The code defines a list of values (in this case, a time series called `time_series`),
    then loops around its length using the `len()` function to apply the conditions.
    Notice how at every loop, the current time step is referred to as `i` thus making
    the previous time step `i - 1`.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries and Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *library* in Python is a group of pre-written code that offers functionality
    to make the creation of applications easier. *Modules*, which are individual Python
    files with reusable code and data that can be imported and used in other Python
    code, are commonly found in libraries. A module is therefore a single Python file
    that contains functions and other types of code that may be used and imported
    by other Python programs. Large code bases are often easier to manage and maintain
    by using modules to divide similar code into different files.
  prefs: []
  type: TYPE_NORMAL
- en: Coding is all about simplifying tasks and making them clearer. When you have
    a recurring task such as calculating a moving average of a time series, you can
    use a function so that you do not have to write the moving average code all over
    again every time you want to use it. Instead, you define the function with the
    original code and then, you call it whenever you need to calculate the moving
    average. But what is a *function*? It is a block of reusable code that performs
    a specific task when called. It needs to be defined once.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple functions form a module and multiple modules form a library. A library
    is generally theme-oriented. For example, in this book, `sklearn` library will
    be used with machine learning models. Similarly, data manipulation and importing
    is done using `numpy` and `pandas`, two libraries discussed in a later section
    of this chapter. Plotting and charting is done using `matplotlib` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Libraries must be imported first to the Python interpreter before being used.
    The syntax of doing this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, you need to import just one function or module from a library. For
    this, you don’t need to import the totality of the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'So, it is established that `math` is a Python library that harbors many mathematical
    functions, namely `sqrt` function which is used to find the square root of a given
    number. Let’s see how to define a function. A function is defined using `def`
    followed by the name of the function and any optional arguments. Consider the
    following example that creates a function that sums any two given variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Calling a function means executing what it’s supposed to do. In other words,
    calling a function is simply using it. The time line of a function is getting
    defined and then getting called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to import a function from a library and use its functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As a side note, the *factorial* operation is a mathematical operation that used
    to calculate the product of all positive integers from 1 up to a certain number
    (which is the argument requested in `math.factorial()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Libraries may not be as easy as one plus one. Sometimes, external libraries
    require installation first before being able to be imported to the Python interpreter.
    Installation can be done through the prompt using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s revert back to Chapter 3 where the MIC was discussed. Prior to the following
    already seen code of the MIC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Importing the library directly will likely lead to an error as it has not been
    pip installed. Therefore, you must install it first using the following syntax
    on the prompt (not the Python interpreter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It is also important to read the documentation that comes with libraries in
    order to use them correctly. *Documentation* helps knowing the aim of the functions
    and what arguments go inside. Furthermore, it tells you what type of arguments
    the function can accept (for example, strings or numerics). Let’s go back to functions
    now (notice how both are intertwined and discussing one may result in discussing
    the other).
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions can have a `return` statement which allows the result to be stored
    in a variable so that it can be used in other parts of the code. Let’s take two
    simple examples and then discuss them step-by-step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code defines the `sum_operation` function with two arguments,
    then stores the operation in a variable called `final_sum` before returning it
    so it can be stored externally. Afterwards, a new variable called `summed_value`
    is defined as the output of the function. Finally, another variable is created
    under the name of `double_summed_value` and is the result of `summed_value` multiplied
    by 2\. This is an example on how to use results from functions as variables in
    external operations. Now, let’s consider another example (while keeping in mind
    the previously defined `sum_operation` function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The latest code snippet defines a function called `square_summed_value` which
    takes on two arguments. Furthermore, it uses a nested function inside which in
    this case is `sum_operation`. The result of the nested function is once again
    stored in a variable called `final_sum` which is used as an input in finding the
    `squared_sum variable`. The variable is found as `final_sum` to the power of two.
    This was an example on how to create functions out of other functions inside of
    them (in other words, nested functions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s end the section with common libraries in Python and machine learning
    (other than `numpy` and `pandas`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions Handling and Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quite often you will run into errors due to issues with the code during execution.
    In other words, errors occur when the code is executed and the interpreter finds
    an obstacle that prevents it from continuing further. The most basic error is
    *SyntaxError* which occurs when there are misspelled words or missing elements
    which make the code unintelligible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the previous code, there is a missing parenthesis at the
    end of the second code line, which is not understood by the interpreter. This
    type of error is likely to be the most common one. Another common error is *NameError*
    which occurs when failing to define a variable before executing a code that contains
    it. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The previous code will give you a *NameError* because the interpreter does not
    know the value of `x` and `y` since they were not defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *ModuleNotFoundError* occurs when the interpreter cannot find the library
    or module you are trying to import. This generally occurs when it is installed
    in the bad directory or when it is not properly installed. Common fixes for this
    issue include:'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying if the module’s name has been written correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying if the module has been correctly pip installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying if the module is installed in the correct location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another type of common errors is *TypeError* and it occurs when you apply a
    certain operation on an incompatible element such as summing an integer with a
    string. The following operation raises a *TypeError*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In time series analysis, you will likely to encounter these four errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '*IndexError*: This is raised referring to an index that is out of range regarding
    the current array or data frame. Imagine having an array of 300 values (rows).
    If you want to loop through them and at each loop, you want to input the number
    1 in the next cell (time step + 1), you are likely to encounter an *IndexError*
    as in the last loop, there is no next cell and the interpreter will raise this
    error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ValueError*: This is raised when you try to call a function with an invalid
    argument. An example of this would to be try to pass an integer element as a string
    when calling a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*KeyError*: This occurs when trying to access an element in a data frame that
    does not exist. For example, if you have three columns in the data frame and you
    refer to one that does not exist (maybe due to a syntax issue), you are likely
    to run into a *KeyError*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ZeroDivisionError*: This error is intuitive and occurs when trying to divide
    a number by zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other types of errors that you may encounter. It is important to understand
    what they refer to so that you are able to fix them.
  prefs: []
  type: TYPE_NORMAL
- en: '*Exceptions* on the other hand may be not fatal to the code in the sense that
    they only show a warning but not necessarily terminate the code. Therefore, exceptions
    occurs during the execution (as opposed to errors which occur because the interpreter
    is unable to execute).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Understanding the error will help you fixing it and getting the code running
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ignore certain exceptions, the `try`  and `except` keywords are used. This
    is useful when you are certain that handling the exception will not alter the
    output of the code. Let’s take an example of creating a function that divides
    the first column of a time series by the next value of the second column. The
    first step is to define the time series as a data frame or as an array (or any
    other data collection structure):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s write the division function which will take any value in the first
    column and divide it by the next value in the second column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the two previous code blocks will give an *IndexError* because in the
    last loop, the function cannot find the next value of the second column because
    it simply does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixing this through `try` and `except` will ignore the last calculation that
    is causing the problem and will return the expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This section discussed errors and exceptions and how you can handle such issues.
    In the coming chapters, such issues will be handled using `try` and `except` blocks
    due to their simplicity and effectiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Data Structures in Numpy and Pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The words `numpy` and `pandas` may come familiar to you since I have used them
    in most of the code snippets in the previous chapters. Moreover, you now understand
    what a library is and therefore, you know that these two are the go-to libraries
    to manipulate, handle, and import data in Python. This section shows the differences
    between the two and their key functions that are definitely a great addition to
    your data analysis. But first, let’s define these two libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '*numpy*'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy (short for Numerical Python) is a Python library that allows working with
    multi-dimensional arrays and matrices. NumPy provides a powerful  interface for
    performing various operations on arrays and matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '*pandas*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pandas (short for Panel Data) is a Python library that allows working with
    data frames (a type of tabular data). Pandas provides two main data structures:
    series and data frames. A *series* is a one-dimensional array-like object that
    can hold any data type. A *data frame* is a two-dimensional table-like structure
    that consists of rows and columns (similar to a spreadsheet).'
  prefs: []
  type: TYPE_NORMAL
- en: Both libraries are very useful in analyzing time series data. Arrays hold only
    numerical type data and therefore, they do not really hold date type data as opposed
    to data frames. This may be one of the advantages of using `pandas` as opposed
    to `numpy` but both have the strengths and relative weaknesses. In the end, it
    is a matter of choice. This book will prioritize using numpy due to the simplicity
    and due to the fact that the machine learning models seen in the next chapter
    use `sklearn` library which is applied on arrays. This must not prevent you from
    using data frames until you are ready to apply the models.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Switching between `numpy` and `pandas` requires converting the time series type.
    It is a relatively easy task but can sometimes cause loss of certain types of
    data (for example, date data).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s import both libraries before starting to see some of their potential:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code creates two time series with two columns and three rows.
    The first time series is called `my_data_frame` and is created using the function
    `pd.DataFrame` of `pandas`. The second time series is called `my_array` and is
    created using the function `np.array` of `numpy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen from Figure 6-2, data frames have real indexes and can have
    column names. Arrays are purely numerical and do not allow for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_0506.PNG)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. On the left, a data frame (pandas) and on the right, an array (numpy)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To switch between the two types of data, it is quite intuitive as you will
    be using the same two functions used in the previous code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can notice that `my_new_data_frame` does not have column names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now take a look at useful functions that will come in handy when dealing
    with models. Slicing, concatenating, and other tools are things that you must
    master in order to smoothly navigate through the data analysis part. Consider
    the following arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Concatenation* is the act of fusing two datasets together either through rows
    (axis = 0) or through columns (axis = 1). Let’s do both of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s do the same thing for data frames. Consider the following data frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenation is useful when you want to combine data into one structure. This
    is how it can be done with data frames (notice how it’s simply a change of syntax
    and function source):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that with time series, *rows* (horizontal cells) represent one time
    step (for example, hourly) with all the data inside while *columns* represent
    the different types of data (for example, open price and close price of a financial
    instrument). Now let’s see slicing techniques for arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is important to know that Python indexing starts at zero. This means that
    to refer to the first element in a data structure, you refer to its index as index
    = 0\. On another note, it is also worth noting that in ranges, the last element
    is excluded which means that the first three elements in a data structure are
    referred to as [0, 3] which will give the elements indexed at 0, 1, and 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the same thing for data frames so that this section becomes a sort
    of a mini encyclopedia whenever you want to manipulate data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Try going back to the earlier chapters to execute the code given there. You
    should have a more solid understanding by now.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Financial Time Series in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section presents a key part in deploying machine and deep learning algorithms.
    It deals with the historical OHLC data that is needed to run the models and evaluate
    their performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to prepare the environment and everything else necessary
    for the success of the algorithms. For this, you need two programs:'
  prefs: []
  type: TYPE_NORMAL
- en: A Python interpreter that you use to write and execute code. You have already
    completed this step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Charting and financial software that you use as a database. This part is covered
    in this section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Throughout the book, I use *MetaTrader 5*, a benchmark charting program used
    by many traders around the globe. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download SPYDER and familiarize yourself with how it works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the MetaTrader 5 software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use SPYDER to import historical prices from MetaTrader 5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the [official website](https://www.metatrader5.com/en), download and install
    MetaTrader 5\. You need to create a demo account, which is simply a virtual account
    with imaginary money. The word *demo* does not refer to a limited duration of
    use but to the fact that it is not using real money.
  prefs: []
  type: TYPE_NORMAL
- en: To open an account, select *File* > *Open an Account*, choose MetaQuotes Software
    Corp, and then click *Next*. Then, choose the first option to open a demo account;
    this will let you trade virtual money. Finally, enter some basic information such
    as name, email, and account type. You will not receive a verification request
    or any type of confirmation as the demo should launch directly, allowing you to
    see the charts.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-3 shows the platform’s interface. By default, MetaTrader 5 does not
    show all the markets it covers, so you need to make them accessible for import
    and visualization if necessary. Click *View*, click *Market Watch*, and then right-click
    any of the symbols shown in the new tab and choose *Show All*. This way you can
    see the extended list with more markets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. MetaTrader’s 5 interface
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Before proceeding to the coding part, you need to install the MetaTrader 5
    Python integration library so you can use it later in Spyder. This is easy and
    requires one step. Open the Anaconda prompt and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Installation is the bridge that allows you to use Python modules and functions
    designed for MetaTrader 5 in the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block uses the `import` built-in statement, which calls
    for internal (self-created) or external (created by third parties) libraries.
    A library is a store of functions, and thus, you need to import the libraries
    that are pertinent to what you want to do. For demonstration purposes, import
    the following modules, packages, and libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create the universe of the time frames that you will be
    able to import. Even though I will be showing you how to analyze and back-test
    hourly data, you can define a wider universe, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The full code is found in the GitHub repository under the name *Master_Function.py*
  prefs: []
  type: TYPE_NORMAL
- en: A *time frame* is the frequency with which you record the prices. With hourly
    data, you will record the last price printed every hour. This means that in a
    day, you can have up to 24 hourly prices. This allows you to see the intraday
    evolution of the price. The aim is to record the totality of the OHLC data within
    a specific period.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code defines the current time, which is used so that the algorithm
    has a reference point when importing the data. Basically, you are creating a variable
    that stores the current time and date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now proceed to defining the universe of the financial instruments you
    want to back-test. In this book, the back-tests will be done exclusively on the
    FX market. Therefore, let’s create a variable that stores some key currency pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have your time and asset variables ready, all you need is to create
    the structure of the importing algorithm. The `get_quotes()` function does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in the `get_quotes()` function, you use the `pytz`and `pandas` libraries.
    The function starts by defining the *Olson* time zone, which you can set yourself.
    Here is a brief, nonexhaustive list of what you can enter depending on your time
    zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterward, I define two variables called `time_from` and `time_to`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `time_from` variable contains the datetime referring to the beginning of
    the import date (e.g., 01-01-2020).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `time_to` variable contains the datetime referring to the end of the import
    date which uses the `now` variable to represent the current time and date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next step is to create a variable that imports the financial data using
    the time periods you have specified. This is done through the `rates` variable
    using the `mt5.copy_rates_range()` function. Finally, using `pandas`, transform
    the data into a data frame. The final function required for the importing process
    is the `mass_import()` function. It lets you choose the time frame using the variable
    and then uses the `get_quotes()` function to import the data and format it to
    an array. The following code snippet defines the `mass_import()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `mass_import()` function automatically converts the data frame into an array,
    so you do not have to worry about conversion when using the automatic import.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The algorithm imports a number of historical data limited by MetaTrader 5\.
    Although that number is high, in time you may need to adjust the year argument
    higher in order to get the data. For instance, if you get an empty array using
    the `mass_import()` function, try putting a more recent year in the `get_quotes()` function
    (“2014” instead of “2013”).
  prefs: []
  type: TYPE_NORMAL
- en: 'To import the historical hourly EURUSD data since beginning of 2014 to date,
    you may type the following (assuming `get_quotes()`, `now`, the frames, and the
    libraries are already defined):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice how the `return` statement is used in the `mass_import` function in order
    to store the historical data in chosen variables.
  prefs: []
  type: TYPE_NORMAL
- en: Even though there is a MAC version of MetaTrader 5, the Python library only
    works on Windows. It requires a Windows emulator on a Mac. For Mac users, you
    may want to try the manual import method.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic import is a huge time saver but MAC users or even Windows users may
    run into frustrating errors. For this, I will show you the manual import way which
    you can use as a fix. In the GitHub link, you will find a folder called Historical
    Data. Inside the folder there is a selection of historical financial time series
    in the form of excel which you can download.
  prefs: []
  type: TYPE_NORMAL
- en: The manual way is to have an Excel file with OHLC data that you have downloaded
    from a third party (such as the excel files provided in the Github repository).
    In this case, you can use the `pandas` library to import it and transform it into
    an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take an example of *eurusd_data**.* Download and the file and store it
    on your desktop. You now have to make sure that the Spyder’s directory is in the
    same place as the file (so, in the desktop). In layperson’s terms, Spyder must
    search the desktop for the Excel file. To choose the right directory, you must
    click the folder button next to the arrow, as shown in Figure 6-4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_0604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. Directory tab
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You should get a separate window where you can choose the desktop location
    and then validate the choice. Having done this, the tab should look like Figure
    6-5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dlf_0605.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5\. Directory tab
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You must use the `read_excel()` function (built-in in `pandas` and accessible
    after importing it) to get the values inside the Excel file. Follow this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Right about now, you have a data frame called `eurusd_data` with four different
    columns representing open, high, low, and close prices. You generally have to
    enter the library’s name before using a function that belongs to it; this is why `read_excel()` is
    preceded by `pd`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I recommend using the automatic way for Windows users and the manual way for
    macOS users due to compatibility issues.
  prefs: []
  type: TYPE_NORMAL
- en: You can get an array directly in one line by just adding `.values` to `pd.read_excel('eurusd_data.xlsx')`,
    thus becoming `pd.read_excel('my_data.xlsx')``.values` and resulting in an array
    instead of a data frame.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python, one of the stars of coding languages. It did enjoy and still enjoys
    a widespread adoption by the developers’ community. Mastering it is key to unlocking
    huge potential in the data science world.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter presents machine learning and different prediction algorithms.
    The main aim is to understand the intuition and be able to code the algorithms
    and run a back-test over financial data. You will see that once you start understanding
    the process, it becomes a matter of removing an algorithm an plugging another
    (in case they have the same assumptions). The warm-up chapters are over and it’s
    time to start coding.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch06.xhtml#idm46147465834784-marker)) Imaginary numbers are a type of
    complex number that represent the square root of a negative number.
  prefs: []
  type: TYPE_NORMAL
