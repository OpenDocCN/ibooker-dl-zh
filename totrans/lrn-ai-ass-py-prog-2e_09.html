<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div class="readable-text" id="p1">
<h1 class="readable-text-h"><span class="calibre22"><span class="calibre22">10</span></span> <span class="calibre22">Making some games</span></h1>
</div>
<div class="readable-text">
<h3 class="introduction-header">This chapter covers</h3>
<ul class="calibre24">
<li class="readable-text1" id="p2">Adding randomness to our programs</li>
<li class="readable-text1" id="p3">Designing and programming a code-breaking logic game</li>
<li class="readable-text1" id="p4">Designing and programming a press-your-luck dice game</li>
</ul>
</div>
<div class="readable-text" id="p5">
<p class="calibre15">People learn to program for many reasons. Some people want to automate tedious tasks as we did in the previous chapter. Some people want to work with artificial intelligence (AI; you’ll get a taste of that in chapter 11). Other people want to make interactive websites, Android or iOS apps, or Alexa skills. There’s an endless amount of stuff that programmers can make.</p>
</div>
<div class="readable-text" id="p6">
<p class="calibre15">Another popular reason to learn programming is to create games. For that reason, we thought we’d continue our Copilot programming journey with you by designing two small computer games. The first is a code-breaking game where you use clues to identify the computer’s secret code. The second is a two-player dice game where each player needs to balance risk and luck to reach the required number of points before the other player does. Instead of using graphics and animation, these games use text. We’ve made this decision to help us stay focused on the game logic, rather than the way that the game is represented or the way that the player interacts with the games. Along the way, we offer some next steps if you’re interested in taking your game-making abilities further. And don’t worry, your current skills are a great start to that!</p>
</div>
<div class="readable-text" id="p7">
<h2 class="readable-text-h1" id="sigil_toc_id_147"><span class="calibre22">10.1</span> Game programs</h2>
</div>
<div class="readable-text" id="p8">
<p class="calibre15">If you think about playing a board game with your family or friends, you can break down what happens in two major phases. The first phase is game setup. This will include setting up the game board, giving each player starting funds or cards, and so on. The second phase is the playing of the game. In a board game, the game typically includes a person taking a turn and, assuming no one has won yet, another person taking a turn. With each turn, the game state (board, players’ funds, etc.) all change. We need to take care to implement each of these phases when programming a computer game as well.</p>
</div>
<div class="readable-text" id="p9">
<p class="calibre15">In many programming environments catered to video game design, the two phases are often separate standard functions. There’s a setup function for what is done to set up the game and an update function to change the state of the game either because a player has taken an action or because time has passed. Figure 10.1 shows the basic flow for video games.<span/></p>
</div>
<div class="browsable-container" id="p10">
<img alt="figure" src="../Images/10-1.png" class="calibre85"/>
<h5 class="figure-container-h"><span>Figure 10.1</span> Basic flow of most video games</h5>
</div>
<div class="readable-text" id="p11">
<p class="calibre15">Let’s focus on the update part of the game for a moment. Suppose a player can press a button on their keyboard to move forward in a 2D game. The update function will cause the player’s character to move forward and also check to see if the player’s movement caused the player to interact with something in the game world. Some games also change state based on time, regardless of a player’s actions. In those games, the update function would also update the state of the game itself (e.g., move the ghosts in a game of Pac-Man). At the end of every time step or user action, the game will check for end conditions. End conditions typically include the following:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p12"> A player won the game by achieving an objective. </li>
<li class="readable-text1" id="p13"> A player lost the game by falling off a cliff, running into a monster, and so on. </li>
<li class="readable-text1" id="p14"> A player chose to quit the game. </li>
</ul>
<div class="readable-text" id="p15">
<p class="calibre15">There are many programming environments that cater to game design, and we recommend the Python pygame module [1] as a good starting place. If you continue pursuing game design beyond that, we recommend checking out Unity [2] for 3D game design. In this chapter though, we’ll be working with just standard Python to show you how to design a basic game without having to dive into these new environments.</p>
</div>
<div class="readable-text" id="p16">
<h2 class="readable-text-h1" id="sigil_toc_id_148"><span class="calibre22">10.2</span> Adding randomness</h2>
</div>
<div class="readable-text" id="p17">
<p class="calibre15">Many games, including the two that we’ll build in this chapter, rely on randomness to make them fun. In our first game, we’ll need the computer to generate the random digits of the number that we’ll be deducing. In the second game, we’ll need to roll dice, which just amounts to generating random numbers between one and six. Enemy behavior, initial orientation of a puzzle, or amount of damage caused by attacks, that is, randomness, is typically involved in all of these and many other aspects of game design.</p>
</div>
<div class="readable-text" id="p18">
<p class="calibre15">We’ll therefore need to be able to generate random numbers in our Python programs. To learn how to do that, let’s use Copilot Chat, much as we did in the previous chapter.</p>
</div>
<div class="readable-text4" id="p19">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>I need to generate random numbers in my <strong class="calibre17"/>Python program. How can I do this?</p>
</div>
<div class="readable-text4" id="p20">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> You can use the random module in Python to generate random numbers. Here’s an example:</p>
</div>
<div class="browsable-container" id="p21">
<div class="readable-text">
<pre class="code-area"><em class="calibre18"><code class="calibre25"><em class="calibre18">```python</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">import random</em></code></em>

<em class="calibre18"><code class="calibre25"><em class="calibre18"># Generate a random integer between 1 and 10 (inclusive)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">random_number = random.randint(1, 10)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">print(random_number)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"> </em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18"># Generate a random float between 0 and 1</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">random_float = random.random()</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">print(random_float)</em></code></em>
<em class="calibre18"><code class="calibre25"><em class="calibre18">```</em></code></em></pre>
</div>
</div>
<div class="readable-text4" id="p22">
<p class="calibre54">This code imports the random module and then uses the <code class="calibre25">randint</code> function to generate a random integer between 1 and 10 (inclusive), and the <code class="calibre25">random</code> function to generate a random float between 0 and 1.</p>
</div>
<div class="readable-text" id="p23">
<p class="calibre15">Copilot suggests using functions inside of a module called random to generate the random numbers. Let’s check whether the random module is built into Python.</p>
</div>
<div class="readable-text4" id="p24">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>Is this random module built into Python?</p>
</div>
<div class="readable-text4" id="p25">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> Yes, the random module is a built-in module in Python, so you don’t need to install any additional modules to use it. You can simply import it in your Python code and start using its functions.</p>
</div>
<div class="readable-text" id="p26">
<p class="calibre15">We’ll follow Copilot’s suggestion and import this module to test the two functions that we just learned. We’ll do this at the Python &gt;&gt;&gt; prompt, which we’ve used in previous chapters to explore how Python features work. To get to the Python prompt, press Ctrl-Shift-P, type <code class="calibre25">REPL</code>, and then select Python: Start REPL.</p>
</div>
<div class="readable-text" id="p27">
<p class="calibre15">Based on Copilot’s response to our first question, we know that we can use the <code class="calibre25">randint</code> function to generate a random integer in a range from the lowest allowed number to the highest allowed number. We might use this function to generate individual digits that could be assembled into a larger number. Each digit is between 0 and 9, so we’ll ask <code class="calibre25">randint</code> for some random numbers between 0 and 9:</p>
</div>
<div class="browsable-container" id="p28">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; import random
&gt;&gt;&gt; random.randint(0, 9)
5
&gt;&gt;&gt; random.randint(0, 9)
1
&gt;&gt;&gt; random.randint(0, 9)
9                           <span/> #1
&gt;&gt;&gt; random.randint(0, 9)
9
&gt;&gt;&gt; random.randint(0, 9)
5
&gt;&gt;&gt; random.randint(0, 9)
0                          <span/> #2
&gt;&gt;&gt; random.randint(0, 9)
4</pre>
<div class="code-annotations-overlay-container">
     #1 We happened to get the maximum value.
     <br class="calibre1"/>#2 We happened to get the minimum value.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p29">
<p class="calibre15">Or, we might want to generate rolls of a die. Each roll is between 1 and 6, so we can ask <code class="calibre25">randint</code> for some random numbers between 1 and 6:</p>
</div>
<div class="browsable-container" id="p30">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; random.randint(1, 6)
2
&gt;&gt;&gt; random.randint(1, 6)
2
&gt;&gt;&gt; random.randint(1, 6)
4
&gt;&gt;&gt; random.randint(1, 6)
1
&gt;&gt;&gt; random.randint(1, 6)
5</pre>
</div>
</div>
<div class="readable-text" id="p31">
<p class="calibre15">The other function that Copilot told us about is called <code class="calibre25">random</code>. (Yes, both the module and this function are called <code class="calibre25">random</code>! So, we’ll need to use <code class="calibre25">random.random()</code> to call this function.) This one doesn’t generate a random integer; rather, it generates a random fractional number between 0 and 1 (not including 1). For example, rather than a random number like 5, you’ll get a random number like 0.1926502. These kinds of numbers, with decimals, are referred to as floats (or floating-point numbers). Here are a few calls of this function: </p>
</div>
<div class="browsable-container" id="p32">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; random.random()
0.03853937835258148
&gt;&gt;&gt; random.random()
0.44152027974631813
&gt;&gt;&gt; random.random()
0.774000627219771
&gt;&gt;&gt; random.random()
0.4388949032154501</pre>
</div>
</div>
<div class="readable-text" id="p33">
<p class="calibre15">We can imagine this function being useful for games as well. For example, you can think of these float values as probabilities that an event occurs, with higher numbers corresponding to higher probabilities. You could then use these floats to determine whether an event should happen or not. For the games in this chapter, though, we won’t need this function.</p>
</div>
<div class="readable-text" id="p34">
<h2 class="readable-text-h1" id="sigil_toc_id_149"><span class="calibre22">10.3</span> Example 1: Bulls and Cows</h2>
</div>
<div class="readable-text" id="p35">
<p class="calibre15"><em class="calibre18"/>Our first game will be based on an old code-breaking game called Bulls and Cows. It might remind you of the game Wordle (but don’t worry if you haven’t played Wordle before). We’ll be able to play this game against the computer. Randomness plays a critical role in this game, as we’ll see. </p>
</div>
<div class="readable-text" id="p36">
<h3 class="readable-text-h2" id="sigil_toc_id_150"><span class="calibre22">10.3.1</span> How the game works</h3>
</div>
<div class="readable-text" id="p37">
<p class="calibre15">In this game, Player 1 thinks up a secret code, which is a sequence of four digits. Player 2 has to figure out what that secret code is. In our version of the game, the computer will be Player 1, and the human player will be Player 2.</p>
</div>
<div class="readable-text" id="p38">
<p class="calibre15">Here’s how it works. The computer will randomly choose four distinct digits (duplicate digits aren’t allowed) as the secret code. For example, it might choose the digits 1862. Then, you’ll guess what you think the computer’s four digits are. For example, you might guess 3821.</p>
</div>
<div class="readable-text" id="p39">
<p class="calibre15">For each guess, you’re told two things. First, you’re told how many digits in your guess match the corresponding position in the secret code exactly. We’ll refer to digits that are in the correct place in the secret code as “correct.” Say that the secret code is 1862, and you guess 3821. The second digit in both your guess and the secret code is 8, so that’s a match. There are no other matches, so you would be told for this guess that the number of correct digits is 1.</p>
</div>
<div class="readable-text" id="p40">
<p class="calibre15">Second, you’re told how many digits in your guess exist at some other position in the secret code. We’ll refer to digits that are in the secret code but in a different location as “misplaced.” Let’s again use 1862 for the secret code and 3821 for your guess. The third digit in your guess is 2. It doesn’t match the third digit of the secret code (that’s a 6), but there is a 2 somewhere else in the secret code. Similarly, the fourth digit in your guess is a 1. It doesn’t match the fourth digit of the secret code, but there is a 1 somewhere else in the secret code. All told, two of your digits (1 and 2) exist in the secret code, although they don’t match their expected position. You would be told from this guess that the number of misplaced digits is 2. You can use these clues to narrow down what the secret code could be. </p>
</div>
<div class="callout-container">
<div class="readable-text" id="p41">
<h5 class="callout-container-h">Wordle</h5>
</div>
<div class="readable-text" id="p42">
<p class="calibre15">If you’ve played Wordle before, you might notice some similarities between Wordle and our game here. Wordle uses letters, and ours uses digits, but the type of feedback you receive for your guesses is similar. In both cases, you’re told about letters or digits that are in the right or wrong place. In Wordle, you’re given a clue about each of your letters on its own. For example, if the first letter of your guess is <em class="calibre18">h</em>, you might be told that the <em class="calibre18">h</em> is in the word but in the wrong place. By contrast, in our game, you’re not given hints about each digit individually but instead are given hints about your guess in aggregate. Still, we hope you’re struck by these similarities and by the fact that you’re building something that resembles a recent, worldwide phenomenon of a game!</p>
</div>
</div>
<div class="readable-text" id="p43">
<p class="calibre15">We found a free version of Bulls and Cows that you can play at <a href="http://www.mathsisfun.com/games/bulls-and-cows.xhtml">www.mathsisfun.com/games/bulls-and-cows.xhtml</a>. We recommend that you play a few rounds of the game before continuing, just so the way the game works is crystal clear in your head. (Note that they use the terminology <em class="calibre18">bulls</em> instead of <em class="calibre18">correct</em> and <em class="calibre18">cows</em> instead of <em class="calibre18">misplaced</em>.)</p>
</div>
<div class="readable-text" id="p44">
<p class="calibre15">In table 10.1, we’ve provided an example interaction with the game. We’ve included a Comments column to convey our thinking and what we learned from each guess.</p>
</div>
<div class="browsable-container" id="p45">
<h5 class="browsable-container-h"><span>Table 10.1</span> Example of playing the game</h5>
<table class="calibre36">
<thead class="calibre37">
<tr class="calibre38">
<th class="calibre39">
<div class="readable-text">
         Guess 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         Misplaced 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         Correct 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         Comments 
       </div></th>
</tr>
</thead>
<tbody class="calibre40">
<tr class="calibre38">
<td class="calibre41">  0123 <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
<td class="calibre41">  One of 0, 1, 2, 3 is in the answer; none are in the correct location. <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  4567 <br class="calibre1"/></td>
<td class="calibre41">  3 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
<td class="calibre41">  Three of 4, 5, 6, 7 are in the answer; none are in the correct location. <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  9045 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
<td class="calibre41">  Because one number from 0123 and three numbers from 4567 are in the answer, we know 8 and 9 aren’t in the answer. We know at least one of the numbers 4 or 5 must be in the answer from prior guesses and that 0 could be in the answer. One correct means that either 4 or 5 is in the correct location, either 4 or 5 isn’t present in the solution, and 0 isn’t in the solution. <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  9048 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
<td class="calibre41">  We know 8, 9, and 0 aren’t in the answer from prior guesses. Zero correct and zero misplaced tells us 4 is also not in the answer, and from the previous guess, we now know that 5 is the last digit. <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  1290 <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
<td class="calibre41">  Going back to the original guess, we want to know which digit of 1, 2, and 3 is in the answer. We know 9 and 0 aren’t in the answer, so one misplaced means either 1 or 2 is in the answer and 3 isn’t in the answer. In addition, whichever of the numbers 1 and 2 are in the answer, it’s currently in the wrong spot. <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  6715 <br class="calibre1"/></td>
<td class="calibre41">  2 <br class="calibre1"/></td>
<td class="calibre41">  1 <br class="calibre1"/></td>
<td class="calibre41">  Because 4 isn’t in the solution, we know from the second guess that 5, 6, and 7 are. Our guess here tells us that 1 isn’t in the answer and that 6 and 7 are in the wrong place. Since 1 isn’t in the answer, 2 must be (from the previous guess). Because 5 is at the end and we’ve tried 2 in the second and third position previously with zero correct, 2 must be in the first position. Because we’ve tried 6 in the first and third position and neither were correct, 6 must be in the second position. That leaves 7 for the third position. We’ve got it. <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  2675 <br class="calibre1"/></td>
<td class="calibre41">  0 <br class="calibre1"/></td>
<td class="calibre41">  4 <br class="calibre1"/></td>
<td class="calibre41">  Yes, this is correct. <br class="calibre1"/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p46">
<p class="calibre15">The challenge of the game is that you have a limited number of guesses in which you must successfully guess the computer’s secret code. In our example from table 10.1, we took seven guesses to guess the code 2675. For each guess, we were given the number of digits misplaced and the number of digits correct to guide our thinking.</p>
</div>
<div class="readable-text" id="p47">
<p class="calibre15">In the free version of the game that we just mentioned, you’re not allowed to include the same digit multiple times in your guess. For example, the guess 1231 wouldn’t be allowed because of the two 1s. We’ll maintain this restriction in our version of the game as well.</p>
</div>
<div class="readable-text" id="p48">
<h3 class="readable-text-h2" id="sigil_toc_id_151"><span class="calibre22">10.3.2</span> Top-down design</h3>
</div>
<div class="readable-text" id="p49">
<p class="calibre15">Our overall task is to write a program to play the Bulls and Cows game against the computer. Let’s do top-down design on this large task, just as we did in chapters 7 and 9. What has to happen during this game? Answering that question will help us break down the game into smaller tasks. To help us with this, we took the rules of the game and our example and thought through what happens at each step of the game. Each of those high-level steps appears in figure 10.2, so let’s break them down one by one.<span/></p>
</div>
<div class="browsable-container" id="p50">
<img alt="figure" src="../Images/10-2.png" class="calibre86"/>
<h5 class="figure-container-h"><span>Figure 10.2</span> Steps in the Bulls and Cows game</h5>
</div>
<div class="readable-text" id="p51">
<p class="calibre15">We’ll start with the setup. For us to be able to play the game, the computer has to randomly generate a secret code. We need to ensure that the secret code doesn’t have any duplicate digits. To us, this sounds like something that’s sufficiently complicated and self-contained, so it should be its own subtask function.</p>
</div>
<div class="readable-text" id="p52">
<p class="calibre15">After the computer generates its secret code, we can move to the gameplay itself. Here’s where the player starts making their guesses. We might think that we could just use <code class="calibre25">input</code> to ask the player for their guesses and thereby avoid having a separate function for this. But we do need to ensure that the player enters the correct number of digits and that they don’t include duplicate digits in their guess. This is more than we can do with a single call of <code class="calibre25">input</code>, so we’ll make this its own function as well.</p>
</div>
<div class="readable-text" id="p53">
<p class="calibre15">Once the player makes their valid guess, we need to figure out two things: How many digits are correct, and how many digits are misplaced? Should we have one function to carry out both of these tasks? Or, maybe we should have two functions, one for the correct information and one for the misplaced information? We see good arguments on each side. If we put the tasks together into the same function, we keep the player feedback centralized in one place, and that may make it easier for us to confirm it’s written correctly. On the other hand, having two separate functions would make it easier to test each type of feedback (correct or misplaced) at the expense of spreading out the logic for the feedback across two functions. We somewhat arbitrarily chose to use a single function here, but if you were hoping to have two separate functions, we encourage you to try that on your own after you finish working through this section.</p>
</div>
<div class="readable-text" id="p54">
<p class="calibre15">Let’s take stock. We have a function to generate the computer’s secret code. We have a function to get the player’s next guess. We have a function to get the correct/misplaced clues for the player’s guess. Those are three major subtasks that we’re happy to split out of our top-level function.</p>
</div>
<div class="readable-text" id="p55">
<p class="calibre15">Is there any other subtask to split out? There’s certainly a little more work to do in our top-level function. For example, we need to detect if the player’s guess matches the secret code and end the game in that case. We feel that we don’t need a separate function for that, though. To determine whether the user’s guess equals the secret code, we can use Python’s <code class="calibre25">==</code> operator, which tells us directly whether two values are equal. And to end the game, we can use a <code class="calibre25">return</code> statement to end the top-level game function and thereby stop the program. Similarly, if the player uses all of their guesses without getting the secret code, then we need to tell them that they lost the game, but again, we should be able to do this with a small amount of Python code. As such, we’ll stop here with our main top-level function calling three subtask functions.</p>
</div>
<div class="readable-text" id="p56">
<p class="calibre15">When we worked through our spelling suggestions problem in chapter 7, we needed to break one of our subtasks into sub-subtasks. But here, each of our three subtasks will be manageable as a single function.</p>
</div>
<div class="readable-text" id="p57">
<p class="calibre15">For example, let’s think again about our first subtask: generating the computer’s secret code, with no duplicate digits allowed. Could we split any sub-subtasks out of here? Maybe we could have a function to check whether there are any duplicate digits in a proposed secret code. Then, we could keep generating secret codes, calling our sub-subtask function until it tells us that there are no duplicates. That would work, but we could also just generate the secret code digit by digit and not allow a duplicate to be added to the code in the first place. This latter plan seems to not need any sub-subtask to be split.</p>
</div>
<div class="readable-text" id="p58">
<p class="calibre15">Now let’s think about our second subtask: getting the player’s next guess. We could split out a sub-subtask to tell us whether a guess is valid (i.e., it has the correct length and has no duplicates). While we could surely do that, it’s not much of a stretch to do this with a couple of checks in the subtask function itself. (Did your mind just go back to our example in chapter 7 about valid passwords and detecting valid passwords, where we split the check for validity into its own function? If so, the difference is that checking whether a password is valid is likely a more substantial task than the validity checks we need here.) It would certainly be okay to break this into another sub-subtask, but we’ll move forward without doing so. We’ve already argued that our third subtask is fine as is, so we’ll stop our top-down design here.</p>
</div>
<div class="readable-text" id="p59">
<p class="calibre15">We’ll name our top-level function <code class="calibre25">play</code>. In it, we’ll call three functions corresponding to the three subtasks that we just identified. We’ll call the function for our first subtask (generating the computer’s secret code) <code class="calibre25">random_string</code>, the function for our second subtask (getting the player’s next guess) <code class="calibre25">get_guess</code>, and the function for our third subtask (providing feedback to the player) <code class="calibre25">guess_result</code>. See figure 10.3 for this top-down design depicted as a tree.<span/></p>
</div>
<div class="browsable-container" id="p60">
<img alt="figure" src="../Images/10-3.png" class="calibre87"/>
<h5 class="figure-container-h"><span>Figure 10.3</span> Top-down design for the Bulls and Cows game. The top-most (left-most) function is <code class="calibre25">play</code>, which calls <code class="calibre25">random_string</code>, <code class="calibre25">get_guess</code>, and <code class="calibre25">guess_result</code>.</h5>
</div>
<div class="readable-text" id="p61">
<h3 class="readable-text-h2" id="sigil_toc_id_152"><span class="calibre22">10.3.3</span> Parameters and return types</h3>
</div>
<div class="readable-text" id="p62">
<p class="calibre15"><em class="calibre18"/>Normally, we define the types of parameters and return value for each function during the top-down design itself, but we wanted to discuss that separately here because there are some subtle aspects this time. For example, you may already be imagining that we’ll use integers to represent the secret code and guesses; but, as we’ll see shortly, this isn’t the best choice. We’ll make some decisions about how we’ll represent the data for all the functions before we write each one. </p>
</div>
<div class="readable-text" id="p63">
<p class="calibre15">The <code class="calibre25">play</code> function is our top-level function and the starting point for our game. It would be possible to have this function take no parameters. Somewhere in the code of the function, we’d have to hard-code the fact that the secret code has four digits and that the player gets, say, 10 guesses. But that wouldn’t be very flexible. What if we wanted to play a version of the game where the secret code is seven digits and the player gets 100 guesses? We’d have to go into the code and make all the necessary changes. So, to make the game easily configurable, we can provide some parameters to this function. For example, rather than always having the secret code be four digits, we could use a parameter to allow the length of the secret code to be set to whatever we want. Similarly, rather than putting the maximum number of player guesses directly into the function, we could make that a parameter as well so that we can easily change it. Then, all we need to do to alter the gameplay is to call this function with different values for these parameters, without having to mess around with the code of the function itself.</p>
</div>
<div class="callout-container">
<div class="readable-text" id="p64">
<h5 class="callout-container-h">Using parameters and variables to avoid magic numbers</h5>
</div>
<div class="readable-text" id="p65">
<p class="calibre15">The number of allowed guesses and the number of digits in the secret code are good examples that we can use to explain an important principle in code design. This principle is that when we write code, if a number can be a parameter or variable, it should be. This principle ensures the code is as versatile as possible. When programmers see a number being used, rather than a friendly name, they call this a “magic number” and that’s what we want to avoid. In our discussion about the number of guesses the player gets or the number of digits for the secret code, those should be parameters if we abide by this principle. At some point, these parameters need to be given concrete numbers for the code to work, but we should assign them values at the highest level of the code as possible (e.g., the player might set these parameters when the game starts).</p>
</div>
<div class="readable-text" id="p66">
<p class="calibre15">To help adhere to this general principle, whenever you see a raw number (e.g., 4) in the code, ask yourself if that could be a parameter or variable. More often than not, it should be.</p>
</div>
</div>
<div class="readable-text" id="p67">
<p class="calibre15">Adding these parameters is another example, as per our discussion in chapter 3, of making functions general purpose rather than unnecessarily restrictive. Our <code class="calibre25">random_string</code> function is the function that generates the computer’s secret code. Why did we put <code class="calibre25">string</code> in this function name? Shouldn’t we be returning a random integer, like 1862? What does a string have to do with this?</p>
</div>
<div class="readable-text" id="p68">
<p class="calibre15">Well, the problem with returning an integer is that the secret code might start with 0. A secret code like 0825 is a perfectly valid four-digit secret code. But 0825 as an integer is 825, which doesn’t have enough digits. The string <code class="calibre25">'0825'</code> is just four characters that happen to each be digits, so there’s no problem with starting a string like this with a <code class="calibre25">'0'</code>.</p>
</div>
<div class="readable-text" id="p69">
<p class="calibre15">Beyond that, let’s think ahead about what we’ll eventually need to be doing with the computer’s secret code. We’ll need to compare it digit by digit with the player’s guess to determine which digits match. Using indexing on strings will give us easy access to each character of the string, which is exactly what we need. It’s more challenging to access each individual digit of an integer: integers don’t support indexing!</p>
</div>
<div class="readable-text" id="p70">
<p class="calibre15">So, our <code class="calibre25">random_string</code> function will take the required number of digits of the secret code as a parameter and will return a random string of that length, where each character in the string is a digit character. When we talk about digits in a string, all we’re referring to are the characters of the string. They happen to be digit characters, but they’re still characters, just like <code class="calibre25">'a'</code> or <code class="calibre25">'*'</code>. Don’t be confused by the fact that the string might look like a number! Here’s an example showing that these strings work the same way every other string works:</p>
</div>
<div class="browsable-container" id="p71">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; s = '1862'
&gt;&gt;&gt; s[0]       <span/> #1
'1'
&gt;&gt;&gt; s[1]
'8'
&gt;&gt;&gt; s[2]
'6'
&gt;&gt;&gt; s[3]
'2'
&gt;&gt;&gt; s + 1          <span/> #2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can only concatenate str (not "int") to str
&gt;&gt;&gt; s + '1'             <span/> #3
'18621'</pre>
<div class="code-annotations-overlay-container">
     #1 We access characters of the string as we always do.
     <br class="calibre1"/>#2 We can’t add a string and an integer.
     <br class="calibre1"/>#3 This is string concatenation, not numeric addition.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p72">
<p class="calibre15">What about <code class="calibre25">get_guess</code>, the function to get the next guess from the player? As with <code class="calibre25">random_string</code>, this function will need to know the number of digits of a valid guess, so we’ll make that a parameter. It will return a string giving the player’s guess. </p>
</div>
<div class="readable-text" id="p73">
<p class="calibre15">Finally, let’s talk about <code class="calibre25">guess_result</code>, the function that tells us how many digits are correct and how many are misplaced. This function will need both the player’s guess string and the computer’s secret code string in order to make comparisons between them, so we’ll need this function to take those two parameters. We need to return two pieces of information—the number of digits that are correct and the number of digits that are misplaced—so we’ll return a list of two integers.</p>
</div>
<div class="readable-text" id="p74">
<h3 class="readable-text-h2" id="sigil_toc_id_153"><span class="calibre22">10.3.4</span> Implementing our functions</h3>
</div>
<div class="readable-text" id="p75">
<p class="calibre15">Having completed our top-down design, we can now work with Copilot to write the code for each of our functions. As always, we’re going to write the functions in order from bottom to top. This means that we’ll first implement our three subtask functions and then ultimately implement our top-level <code class="calibre25">play</code> function.</p>
</div>
<div class="readable-text" id="p76">
<h4 class="readable-text-h3">random_string</h4>
</div>
<div class="readable-text" id="p77">
<p class="calibre15">As always when working with Copilot to generate code, we provide the <code class="calibre25">def</code> line and docstring and then Copilot writes the code. In each code listing, we’ll also provide some guidance about how the code works.</p>
</div>
<div class="readable-text" id="p78">
<p class="calibre15">We want our <code class="calibre25">random_string</code> function to take the number of digits in a secret code as a parameter and return a random secret code without duplicates. In the code for this function, we might expect Copilot to use <code class="calibre25">random.randint</code> in a loop that continues running as long as we don’t have enough digits. To avoid adding duplicate digits, the code would add a random digit to the secret code only if that digit isn’t already in there. We found such a solution in our Copilot results, and that’s the one we’ve chosen to present in the following listing.</p>
</div>
<div class="browsable-container" id="p79">
<h5 class="listing-container-h"><span>Listing 10.1</span> Function <code class="calibre25">random_string</code> for generating a secret code</h5>
<div class="readable-text">
<pre class="code-area">import random          <span/> #1

<strong class="calibre17">def random_string(length):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    length is an integer.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Return a string of the given length, where each character</strong>
<strong class="calibre17">    is a digit from 0 to 9, and with no repeated digits.</strong>
<strong class="calibre17">    '''</strong>
    s = ''         <strong class="calibre17">              </strong><span/> #2
    while len(s) &lt; length:            <span/> #3
        r = random.randint(0, 9)    <span/> #4
        if str(r) not in s:       <span/> #5
            s += str(r)         <span/> #6
    return s          <span/> #7</pre>
<div class="code-annotations-overlay-container">
     #1 Don’t forget to import the random module.
     <br class="calibre1"/>#2 Starts with the empty string (no digits so far) as the secret code
     <br class="calibre1"/>#3 Loops while we still need digits
     <br class="calibre1"/>#4 Generates a random integer from 0 to 9
     <br class="calibre1"/>#5 If this digit isn’t already in the secret code . . .
     <br class="calibre1"/>#6 . . . add this digit to the secret code.
     <br class="calibre1"/>#7 Returns the secret code
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p80">
<p class="calibre15">We’re not focusing on testing in this chapter, but even if we were, we wouldn’t include exact tests in our docstring for this function. That’s because this function has a random result. Randomness can make testing functions difficult because it’s hard to control the random values you get. What we could do is add a test to our docstring that at least checks that the generated secret code contains the correct number of characters, that there are no duplicate characters, and that each character is a valid digit. You can also test such functions by running them and observing that their result is always within the bounds of your random range and that the results appear random. </p>
</div>
<div class="readable-text" id="p81">
<p class="calibre15">If you did carry through with testing, you’d find that we have a perfectly fine implementation of this function and that there’s no need to do more. If you just want the game to work, you can skip to where we start writing the <code class="calibre25">get_guess</code> function. If you’d like to learn more about Python and function design, we’d like to take this opportunity to spend a bit more time looking at different solutions to this function.</p>
</div>
<div class="readable-text" id="p82">
<p class="calibre15">We encourage you to check out the Copilot suggestions in the window that appears when you press Ctrl-Enter to see some of the other possibilities. For example, we can start with a list of all the integers from 0 to 9 and then use a function called <code class="calibre25">random.shuffle</code> to shuffle that list into random order. Then, all we do is take the first <code class="calibre25">length</code> integers from that shuffled list (where <code class="calibre25">length</code> is the length of the secret code), and that’s the secret code! We’re guaranteed not to get any duplicate digits because the original list that we shuffle doesn’t have any duplicate digits. That version of the function might look like the following listing.</p>
</div>
<div class="browsable-container" id="p83">
<h5 class="listing-container-h"><span>Listing 10.2</span> Alternative solution for the function <code class="calibre25">random_string</code></h5>
<div class="readable-text">
<pre class="code-area">import random
<strong class="calibre17">def random_string(length):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    length is an integer.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Return a string of the given length, where each character</strong>
<strong class="calibre17">    is a digit from 0 to 9, and with no repeated digits.</strong>
<strong class="calibre17">    '''</strong>
    digits = list(range(10))              <span/> #1
    random.shuffle(digits)            <strong class="calibre17">               </strong><span/> #2
    return ''.join(str(d) for d in digits[:length])   <span/> #3</pre>
<div class="code-annotations-overlay-container">
     #1 Creates the list [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     <br class="calibre1"/>#2 Shuffles the list in a random order
     <br class="calibre1"/>#3 Returns the first “length” digits from the shuffled list
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p84">
<p class="calibre15">If you want to learn more about what this code is doing, you have the tools to do that! Don’t assume that the code is out of your grasp. You can ask Copilot to explain the code. You might get an explanation like the following.</p>
</div>
<div class="readable-text4" id="p85">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>What does my <code class="calibre25">random_string</code> function do?</p>
</div>
<div class="readable-text4" id="p86">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> The code is a Python function called <code class="calibre25">random_string</code> that takes an integer <code class="calibre25">length</code> as input and returns a string of the given length, where each character is a digit from 0 to 9, and with no repeated digits.</p>
</div>
<div class="readable-text4" id="p87">
<p class="calibre54">The function first creates a list of digits from 0 to 9 using the <code class="calibre25">range</code> function and the <code class="calibre25">list</code> constructor. It then shuffles the list using the <code class="calibre25">shuffle</code> function from the random module. This ensures that the digits are in a random order.</p>
</div>
<div class="readable-text4" id="p88">
<p class="calibre54">Finally, the function uses a list comprehension to convert the first <code class="calibre25">length</code> digits of the shuffled list to strings and join them together into a single string using the <code class="calibre25">join</code> method.</p>
</div>
<div class="readable-text4" id="p89">
<p class="calibre54">Overall, the <code class="calibre25">random_string</code> function generates a random string of digits with no repeated digits, which can be useful for generating unique identifiers or passwords.</p>
</div>
<div class="readable-text" id="p90">
<p class="calibre15">What’s a <em class="calibre18">list comprehension</em>? You don’t need to figure this out on your own, you can ask Copilot to explain it.</p>
</div>
<div class="readable-text4" id="p91">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>How does that list comprehension work?</p>
</div>
<div class="readable-text4" id="p92">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>GitHub Copilot</span> The list comprehension in the <code class="calibre25">random_string</code> function is used to convert the first <code class="calibre25">length</code> digits of the shuffled list to strings and join them together into a single string using the <code class="calibre25">join</code> method.</p>
</div>
<div class="readable-text4" id="p93">
<p class="calibre54">Here’s a breakdown of how the list comprehension works:</p>
</div>
<ol class="calibre28">
<li class="readable-text5" id="p94"> <code class="calibre25">str(d)</code> for d in <code class="calibre25">digits[:length]</code> is the expression that generates the list of strings. It takes each digit in the first <code class="calibre25">length</code> elements of the <code class="calibre25">digits</code> list, converts it to a string using the <code class="calibre25">str</code> function, and returns the resulting string. </li>
<li class="readable-text5" id="p95"> <code class="calibre25">digits[:length]</code> is the iterable that the list comprehension operates on. It takes the first <code class="calibre25">length</code> elements of the <code class="calibre25">digits</code> list, which have been shuffled randomly. </li>
<li class="readable-text5" id="p96"> The entire list comprehension is enclosed in square brackets, which creates a new list from the elements generated by the expression. </li>
</ol>
<div class="readable-text4" id="p97">
<p class="calibre54">Finally, the <code class="calibre25">join</code> method is called on the resulting list of strings to join them together into a single string with no separator between them.</p>
</div>
<div class="readable-text" id="p98">
<p class="calibre15">Some of this text from Copilot may not be completely understandable, but you could keep asking it to explain what you’re unsure about until you’re satisfied you understand how this is working.</p>
</div>
<div class="readable-text" id="p99">
<p class="calibre15">We didn’t need to show this second working solution for this function, but we want to take this opportunity to remind you of how far you’ve come. As you’ve progressed through the book, you’ve been developing tools and techniques to understand and create software as well as the confidence to learn and keep learning more! Getting back to the problem at hand, let’s code our next function.</p>
</div>
<div class="readable-text" id="p100">
<h4 class="readable-text-h3">get_guess</h4>
</div>
<div class="readable-text" id="p101">
<p class="calibre15">Our <code class="calibre25">get_guess</code> function takes the number of required digits as a parameter and returns a valid guess from the player. Remember that for a guess to be valid, it must contain the right number of digits, and it must not have any duplicate digits. Here’s what we got from Copilot in the following listing.</p>
</div>
<div class="browsable-container" id="p102">
<h5 class="listing-container-h"><span>Listing 10.3</span> Function <code class="calibre25">get_guess</code> for user input</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def get_guess(length):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    length is an integer.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Keep asking the player to enter a string where each character </strong>
<strong class="calibre17">    is a digit from 0 to 9, until they enter a valid guess.</strong>
<strong class="calibre17">    A valid guess has the given length and has no repeated digits.</strong>
<strong class="calibre17">    '''</strong>
    guess = input('Enter a guess: ')                          <span/> #1
    while len(guess) != length or not guess.isdigit()\   <span/> #2
            or len(set(guess)) != length:                
        guess = input('Enter a guess: ')               <span/> #3
    return guess      <span/> #4</pre>
<div class="code-annotations-overlay-container">
     #1 First tries to get a valid guess from the player
     <br class="calibre1"/>#2 While length is wrong, or the guess isn’t all digits or has duplicates . . . 
     <br class="calibre1"/>#3 . . . subsequently tries to get a valid guess from the player
     <br class="calibre1"/>#4 Returns the valid guess
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p103">
<p class="calibre15">That <code class="calibre25">while-loop</code> condition is a complex one! The final part, <code class="calibre25">len(set(guess))</code> <code class="calibre25">!=</code> <code class="calibre25">length</code>, is responsible for checking whether the user entered any duplicate digits. It’s using a Python set to do that. We did see this trick back in chapter 7, section 7.7.7, but that was a while ago! So, if you need a refresher, don’t hesitate to ask Copilot for an explanation of that line. </p>
</div>
<div class="readable-text" id="p104">
<h4 class="readable-text-h3">guess_result</h4>
</div>
<div class="readable-text" id="p105">
<p class="calibre15">Our <code class="calibre25">guess_result</code> function takes two strings as parameters: the player’s most recent guess and the secret code. It returns a list of two integers: the number of correct digits and the number of misplaced digits.</p>
</div>
<div class="readable-text" id="p106">
<p class="calibre15">This is a tricky function to get right, so even though we haven’t been showing the tests we’d want to run in prior functions, we’re going to provide some explicit tests in the docstring for this function. We’re adding these docstring tests because the logic for this function is going to be complex enough that it will be hard to determine whether the code is correct by solely reading the code. For our docstring tests, we’ll need some good example cases of different secret codes and user guesses to ensure the number of correct and misplaced digits returned by the function are as expected. Of course, per chapter 6, you’d likely want to add even more test cases if you were interested in doing serious testing. Our first test case is</p>
</div>
<div class="browsable-container" id="p107">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; guess_result('3821', '1862')</pre>
</div>
</div>
<div class="readable-text" id="p108">
<p class="calibre15">The correct return value here is <code class="calibre25">[1,</code> <code class="calibre25">2]</code> because there’s one digit that’s correct (the 8), and two misplaced digits (the 2 and the 1). Our second test case is</p>
</div>
<div class="browsable-container" id="p109">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; guess_result('1234', '4321')</pre>
</div>
</div>
<div class="readable-text" id="p110">
<p class="calibre15">The correct return value this time is <code class="calibre25">[0,</code> <code class="calibre25">4]</code> because there are zero correct digits, but all four digits of the guess are misplaced. Here’s our complete docstring, including test cases, and the code from Copilot.</p>
</div>
<div class="browsable-container" id="p111">
<h5 class="listing-container-h"><span>Listing 10.4</span> Function <code class="calibre25">guess_result</code> to get the result of a guess</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def guess_result(guess, secret_code):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    guess and secret_code are strings of the same length.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Return a list of two values:</strong>
<strong class="calibre17">    the first value is the number of indices in guess where</strong>
<strong class="calibre17">    the character at that index matches the character at the</strong>
<strong class="calibre17">    same index in secret_code; the second value is the </strong>
<strong class="calibre17">    number of indices in guess where the character at that </strong>
<strong class="calibre17">    index exists at a different index in secret_code.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    &gt;&gt;&gt; guess_result('3821', '1862')</strong>
<strong class="calibre17">    [1, 2]</strong>
<strong class="calibre17">    &gt;&gt;&gt; guess_result('1234', '4321')</strong>
<strong class="calibre17">    [0, 4]</strong>
<strong class="calibre17">    '''</strong>
    correct = 0                    <span/> #1
    misplaced = 0         <strong class="calibre17">         </strong><span/> #2
    for i in range(len(guess)):            <span/> #3
        if guess[i] == secret_code[i]:   <span/> #4
            correct += 1       <span/> #5
        elif guess[i] in secret_code:    <span/> #6
            misplaced += 1            <strong class="calibre17">  </strong><span/> #7
    return [correct, misplaced]     <span/> #8</pre>
<div class="code-annotations-overlay-container">
     #1 This variable is for the correct digits.
     <br class="calibre1"/>#2 This variable is for the misplaced digits.
     <br class="calibre1"/>#3 Goes through each index of the digit strings
     <br class="calibre1"/>#4 This digit is correct.
     <br class="calibre1"/>#5 Increases correct count by 1
     <br class="calibre1"/>#6 This isn’t a match but is misplaced.
     <br class="calibre1"/>#7 Increases misplaced count by 1
     <br class="calibre1"/>#8 Returns both results in a list
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p112">
<p class="calibre15">The use of <code class="calibre25">elif</code> is subtle here. If it were written as <code class="calibre25">if</code> rather than <code class="calibre25">elif</code>, then the code would be wrong! Do you see why? If not, try conversing with Copilot before continuing to read our explanation here.</p>
</div>
<div class="readable-text" id="p113">
<p class="calibre15">Suppose that the <code class="calibre25">if</code> condition <code class="calibre25">guess[i]</code> <code class="calibre25">==</code> <code class="calibre25">secret_code[i]</code> is <code class="calibre25">True</code>. In that case, we increase <code class="calibre25">correct</code> by 1, and we skip the <code class="calibre25">elif</code> statements. (Remember, the <code class="calibre25">elif</code> statements run only if the preceding <code class="calibre25">if</code> and any preceding <code class="calibre25">elif</code> conditions are <code class="calibre25">False</code>.) </p>
</div>
<div class="readable-text" id="p114">
<p class="calibre15">Now, imagine we changed the <code class="calibre25">elif</code> to an <code class="calibre25">if</code>. If the <code class="calibre25">if</code> condition <code class="calibre25">guess[i]</code> <code class="calibre25">==</code> <code class="calibre25">secret_code[i]</code> is <code class="calibre25">True</code>, we’d still increase <code class="calibre25">correct</code> by 1. But then, we’d check the <code class="calibre25">guess[i]</code> <code class="calibre25">in</code> <code class="calibre25">secret_code</code> condition, and this one would be <code class="calibre25">True</code> as well. After all, we just said that <code class="calibre25">guess[i]</code> <code class="calibre25">==</code> <code class="calibre25">secret_code[i]</code>, which proves that <code class="calibre25">guess[i]</code> is indeed somewhere in <code class="calibre25">secret_code</code>. So, we’d erroneously do the <code class="calibre25">misplaced</code> <code class="calibre25">+=</code> <code class="calibre25">1</code>, which we certainly don’t want to do (it’s a matched digit, not a misplaced one too)!</p>
</div>
<div class="readable-text" id="p115">
<h4 class="readable-text-h3">play</h4>
</div>
<div class="readable-text" id="p116">
<p class="calibre15">We’re done with our subtask functions! Now all we need to do is write the <code class="calibre25">play</code> top-level function.</p>
</div>
<div class="readable-text" id="p117">
<p class="calibre15">Our <code class="calibre25">play</code> function takes two integers as parameters: the number of digits in the secret code and guesses, and the number of guesses that the player has to guess the secret code. It doesn’t return anything—it just plays the game! Our final prompt and code for this function is given in the following listing.</p>
</div>
<div class="browsable-container" id="p118">
<h5 class="listing-container-h"><span>Listing 10.5</span> Function <code class="calibre25">play</code> for playing the game</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def play(num_digits, num_guesses):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    Generate a random string with num_digits digits.</strong>
<strong class="calibre17">    The player has num_guesses guesses to guess the random </strong>
<strong class="calibre17">    string. After each guess, the player is told how many </strong>
<strong class="calibre17">    digits in the guess are in the correct place, and how </strong>
<strong class="calibre17">    many digits exist but are in the wrong place.</strong>
<strong class="calibre17">    '''</strong>
    answer = random_string(num_digits)                        <span/> #1
    print('I generated a random {}-digit number.'.format(num_digits))
    print('You have {} guesses to guess the number.'.format(num_guesses))
    for i in range(num_guesses):                       <span/> #2
        guess = get_guess(num_digits)           <strong class="calibre17">        </strong><span/> #3
        result = guess_result(guess, answer)         <span/> #4
        print('Correct: {}, Misplaced: {}'.format( \  <strong class="calibre17"> </strong><span/> #5
                            result[0], result[1]))    <strong class="calibre17"> </strong> #5
        if guess == answer:           <span/> #6
            print('You win!')
            return            <span/> #7
    print('You lose! The correct answer was \  <strong class="calibre17">  </strong><span/> #8
                     {}.'.format(answer))      <strong class="calibre17">  </strong> #8</pre>
<div class="code-annotations-overlay-container">
     #1 Generates the computer’s secret code
     <br class="calibre1"/>#2 Loops once for each possible player guess
     <br class="calibre1"/>#3 Gets the next valid guess from the player
     <br class="calibre1"/>#4 Gets the “correct” and “misplaced” feedback for this guess
     <br class="calibre1"/>#5 Tells the player the hints
     <br class="calibre1"/>#6 Player correctly guesses the secret code!
     <br class="calibre1"/>#7 Exits the function; this ends the game.
     <br class="calibre1"/>#8 If we get here, then the player ran out of guesses.
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p119">
<p class="calibre15">If we ran our program now, nothing would happen. That’s because we haven’t called the <code class="calibre25">play</code> function yet! We always need to remember to call our top-level function. To call it, we can add this line below the <code class="calibre25">play</code> function:</p>
</div>
<div class="browsable-container" id="p120">
<div class="readable-text">
<pre class="code-area">play(4, 10)</pre>
</div>
</div>
<div class="readable-text" id="p121">
<p class="calibre15">The <code class="calibre25">4</code> means that we’re playing with four-digit codes and guesses, and the <code class="calibre25">10</code> means that we have 10 guesses to correctly guess the secret code. You can change these arguments to tune the game how you like.</p>
</div>
<div class="readable-text" id="p122">
<p class="calibre15">Let’s give our game a whirl before we continue. We’ll show our first few guesses and then our final guess:</p>
</div>
<div class="browsable-container" id="p123">
<div class="readable-text">
<pre class="code-area">I generated a random 4-digit number.
You have 10 guesses to guess the number.
Enter a guess: 0123
Correct: 1, Misplaced: 0
Enter a guess: 4567
Correct: 1, Misplaced: 0
Enter a guess: 8901
Correct: 2, Misplaced: 0
Enter a guess: 8902
Correct: 2, Misplaced: 1
...
Enter a guess: 2897
Correct: 1, Misplaced: 3
You lose! The correct answer was 8927.</pre>
</div>
</div>
<div class="readable-text" id="p124">
<p class="calibre15">We’ve succeeded in designing a computer game, which is a very different kind of program than the other programs we’ve written in this book. Our computer game interacts with the user, has randomness, involves two players (the human player guessing and the computer player providing the correct/misplaced clues), and has winning and losing conditions. That’s a lot of new stuff! However, we also hope that you see how much we’ve learned and brought forward from prior chapters. We’re still doing top-down design, still designing functions, still testing code, still reading code, and still conversing with Copilot. You hadn’t written a game prior to this chapter, but essentially, you already had the skills to do that. Don’t let a seemingly new type of program or app stop you from trying to do it.</p>
</div>
<div class="readable-text" id="p125">
<h3 class="readable-text-h2" id="sigil_toc_id_154"><span class="calibre22">10.3.5</span> Adding a graphical interface for Bulls and Cows</h3>
</div>
<div class="readable-text" id="p126">
<p class="calibre15">You might be disappointed that our game doesn’t look much like a game you’ve recently played because there are no graphics, just text. For example, there’s no nice area to type in, no buttons to click, and no graphical interface at all. We’ve already argued why we focus on text games in this chapter, but it doesn’t mean that turning this game into a graphical interface version is entirely out of your grasp because you could interact with Copilot to see if it can help you get started. </p>
</div>
<div class="readable-text" id="p127">
<p class="calibre15">The challenge is that programmers create graphical user interfaces using a style of programming called <em class="calibre18">event-driven programming, </em>which we haven’t taught you yet and is too large to teach in this chapter. You can likely read through event-driven programming code and make some sense of it, and that’s what you’d need to do if you ask Copilot to write code to produce a graphical interface. That said, if Copilot doesn’t give you what you want, it may be difficult to fix without first becoming familiar with event-driven programming. There’s a nice book on game programming that includes graphical user interfaces and event-driven programming in Python called <em class="calibre18">Invent Your Own Computer Games with Python </em>[3] if you’d like to learn more.</p>
</div>
<div class="callout-container">
<div class="readable-text" id="p128">
<h5 class="callout-container-h">Event-driven programming </h5>
</div>
<div class="readable-text" id="p129">
<p class="calibre15">Event-driven programming is commonly used for programs that interact with users. At a high level, the program sets up a way for the user to interact with the program (e.g., by pressing buttons or entering text) and then just sits and waits for the user to do something, sometimes updating the state of the game while waiting for the user input. Once the human interacts with the game, the code recognizes this interaction as an <em class="calibre18">event</em>,<em class="calibre18"> </em>and each event has code associated with it that should execute when the event occurs. For example, when a user clicks the Quit Game button, it triggers the code that needs to be executed when the user wants to quit (e.g., saving the state of the game and exiting the program).</p>
</div>
</div>
<div class="readable-text" id="p130">
<p class="calibre15">We were quite impressed by what Copilot gave us when we asked it to create the graphical interface for Bulls and Cows, so we’d like to show you how well it did. The code is somewhat readable even without knowing event-driven programming. For example, you can probably find the title of the game and change it. To do this, we asked Copilot Chat the following question:</p>
</div>
<div class="readable-text4" id="p131">
<p class="calibre54"><span class="response-head"><span class="prompt-initials">LP</span>Human</span><strong class="calibre17"> </strong>Can you convert this program to use a graphical interface instead of a text interface?</p>
</div>
<div class="readable-text" id="p132">
<p class="calibre15">Copilot responded to us by laying out, step by step, the changes that we’d need to make to do so. It then rewrote the code so that the game now used a graphical interface with buttons and edit boxes, rather than a text interface. See figure 10.4 for the new interface. The code to generate this interface is on the website for the book in case you’re interested in running it yourself or learning about the code.<span/></p>
</div>
<div class="browsable-container" id="p133">
<img alt="figure" src="../Images/10-4.png" class="calibre88"/>
<h5 class="figure-container-h"><span>Figure 10.4</span> The graphical interface for the game as provided by Copilot. Note that it shows the secret code, presumably to help with testing (you’d want to remove that before playing the game).</h5>
</div>
<div class="readable-text" id="p134">
<h2 class="readable-text-h1" id="sigil_toc_id_155"><span class="calibre22">10.4</span> Example 2: Bogart</h2>
</div>
<div class="readable-text" id="p135">
<p class="calibre15"><em class="calibre18"/>Our second game will be a two-player dice game. In Bulls and Cows, one of our players was human and the other was the computer. This time, we’ll write a game for two human players. Randomness again will play a key role. Once we’re done, you can play against a friend or family member! </p>
</div>
<div class="readable-text" id="p136">
<h3 class="readable-text-h2" id="sigil_toc_id_156"><span class="calibre22">10.4.1</span> How the game works</h3>
</div>
<div class="readable-text" id="p137">
<p class="calibre15">The game that we’ll be writing here is called Bogart and was designed by Crab Fragment Labs. This is a dice game for two players. The game also uses a pot of chips or coins. We obviously won’t need actual dice or chips, though, as we’re implementing this as a computer game.</p>
</div>
<div class="callout-container">
<div class="readable-text" id="p138">
<h5 class="callout-container-h">Bogart</h5>
</div>
<div class="readable-text" id="p139">
<p class="calibre15">The Bogart game was designed by James Ernest (© 1999 James Ernest and Cheapass Games, used by permission; <a href="https://crabfragmentlabs.com/">https://crabfragmentlabs.com/</a>). You can download the instructions for the original game for free as part of a .pdf file of games: <a href="https://crabfragmentlabs.com/shop/p/chief-herman-1">https://crabfragmentlabs.com/shop/p/chief-herman-1</a>. If you enjoy the game and can’t stop playing our re-creation, we encourage you to support the work that Crab Fragment Labs is doing. We thank them for letting us use their game here!</p>
</div>
</div>
<div class="readable-text" id="p140">
<p class="calibre15">When the game starts, the pot of chips is empty (has no chips in it). One of the two players is randomly chosen to start the game. From there, each player takes turns until the game is over. We’ll first explain what it means for a player to take a turn and then give the rules for when the game ends. Figure 10.5 provides an overview of the flow of the game as well.</p>
</div>
<div class="readable-text" id="p141">
<p class="calibre15">At the beginning of a player’s turn, one chip gets added to the pot, and that player rolls one die. If that die is a 1, then the player’s turn is over, and they don’t collect any chips. If that die isn’t a 1, then the player gets to decide whether to continue their turn or not. If they decide not to continue their turn, they collect all the chips from the pot (making the pot empty).<span/></p>
</div>
<div class="browsable-container" id="p142">
<img alt="figure" src="../Images/10-5.png" class="calibre89"/>
<h5 class="figure-container-h"><span>Figure 10.5</span> Player turn in Bogart</h5>
</div>
<div class="readable-text" id="p143">
<p class="calibre15">If they do decide to continue their turn, then two chips get added to the pot, and they roll two dice. If one or both of those dice is a 1, then the player’s turn is over. Otherwise, the player again gets to decide whether to continue their turn or not. </p>
</div>
<div class="readable-text" id="p144">
<p class="calibre15">If they continue their turn, then they roll three dice, then four dice, and then five dice. (Players can’t choose to skip a number of dice; they must work through the number of dice sequentially starting from one die.) If they ever roll a 1, then their turn ends, and they don’t collect any chips. If they decide not to continue their turn, then they collect all the chips from the pot. </p>
</div>
<div class="readable-text" id="p145">
<p class="calibre15">Rolling a 1 in this game is bad news for the current player. When rolling one die, the probability of rolling a 1 is low, only 1 in 6 (about 17%). When rolling two dice, the probability of rolling at least one 1 is higher, this time about 31%. It’s higher still when rolling three dice (42%), four dice (52%), or five dice (60%). So, the longer you extend your turn, the higher the probability that you’ll eventually roll a 1 and get nothing for your turn. Worse, you’ll likely leave the pot quite full for the other player to collect if they play more conservatively than you. At the same time, the longer you extend your turn, the faster the chips in the pot accumulate and the more chips you can collect assuming that you do successfully end your turn eventually. The whole trick is to decide when to press your luck for more chips and when to take what you’ve got.</p>
</div>
<div class="readable-text" id="p146">
<p class="calibre15">This is how a player’s turn works. Players alternate turns, rolling dice and collecting chips, until the game ends. There are two ways that the game can end:</p>
</div>
<ol class="calibre28">
<li class="readable-text1" id="p147"> If a player collects a total of 30 or more chips, then that player wins. </li>
<li class="readable-text1" id="p148"> Say a player on their turn rolls one die, then two dice, then three, then four, and then five, never once rolling a 1. Then, that player instantly wins. It doesn’t matter how many chips they’ve collected: if they get to five dice of which none are a 1, they win. </li>
</ol>
<div class="readable-text" id="p149">
<h4 class="readable-text-h3">Example game of Bogart</h4>
</div>
<div class="readable-text" id="p150">
<p class="calibre15">Let’s play out a few turns of the game to make sure we’re clear on how it all works. The pot starts out empty. Let’s say that Player 1 is the player randomly chosen to go first. We add one chip to the pot, and Player 1 rolls one die. Let’s say that they roll a 5. Now Player 1 has to decide whether to end their turn and take the one chip from the pot or continue their turn.</p>
</div>
<div class="readable-text" id="p151">
<p class="calibre15">Let’s say that they continue their turn. We add two chips to the pot; now the pot has three chips. Player 1 rolls two dice. Let’s say they roll a 4 and a 2.</p>
</div>
<div class="readable-text" id="p152">
<p class="calibre15">Should they end their turn and take the three chips? Nah, nah. They want more. They continue their turn. We add three chips to the pot; now the pot has six chips. Player 1 rolls three dice. This time, they roll a 6, a 5, and—oh no!—a 1. Player 1’s turn is over. They got no chips, and they left a juicy six chips in the pot for Player 2.</p>
</div>
<div class="readable-text" id="p153">
<p class="calibre15">Now it’s Player 2’s turn. We add one chip to the pot—that’s seven chips now!—and Player 2 rolls one die. Let’s say that they roll a 2. If Player 2 ends their turn now, they’ll collect the seven chips from the pot. That feels like a lot, so let’s say that Player 2 does decide to end their turn.</p>
</div>
<div class="readable-text" id="p154">
<p class="calibre15">Now the pot is empty, and it’s back to being Player 1’s turn. Player 1 has some catching up to do: they have 0 chips and Player 2 has 7 chips. We’ll stop here, but the game will continue until one of the players racks up 30 or more chips or they get to roll five dice and manage not to roll a single 1.</p>
</div>
<div class="readable-text" id="p155">
<h3 class="readable-text-h2" id="sigil_toc_id_157"><span class="calibre22">10.4.2</span> Top-down design</h3>
</div>
<div class="readable-text" id="p156">
<p class="calibre15">As was the case when we implemented our Bulls and Cows game, implementing Bogart is a large problem for which we need top-down design. We’ll offer that design now, but here we encourage you to try it on your own before continuing. We recommend this because we found an effective top-down design to be subtle for this game due to the number of interacting elements. For example, a player’s turn can end in one of three ways: collect the chips, don’t collect the chips, and instantly win. We need to be able to determine which of these situations happened. As another example, after each player’s turn, we need to switch to the other player—except, unfortunately, not always: if a player wins the game, we want to stop the game right there and declare them the winner, not switch to the other player! We’ll primarily focus on our successful top-down design here, but we’ll occasionally justify why we made our decisions and what went wrong with other decisions. </p>
</div>
<div class="readable-text" id="p157">
<p class="calibre15">We’ll name our top-level function <code class="calibre25">play</code>. Here are the main subtasks that we’ll need to solve for our game:</p>
</div>
<ol class="calibre28">
<li class="readable-text1" id="p158"> Initialize the pot, and start Player 1 and Player 2 with zero chips. This is part of the game setup phase. </li>
<li class="readable-text1" id="p159"> Randomly choose Player 1 or Player 2 to start the game. This too is part of the game setup. </li>
<li class="readable-text1" id="p160"> Now we enter the gameplay phase. While the game isn’t over, do the following: 
    <ol class="calibre48">
<li class="calibre30"> Print the number of chips in the pot, number of chips Player 1 has, and number of chips Player 2 has. </li>
<li class="calibre30"> Take a full turn for the current player. </li>
<li class="calibre30"> If the current player won chips, give the chips to the current player, and reset the pot to have zero chips. </li>
<li class="calibre30"> Switch to the other player’s turn. </li>
</ol></li>
<li class="readable-text1" id="p161"> Print the name of the player (Player 1 or Player 2) who won the game. </li>
</ol>
<div class="readable-text" id="p162">
<p class="calibre15">At this point in the book, we suspect you’ve become familiar enough with the code from Copilot to have some nice intuition about which of these tasks will require separate functions. Task 1 is just a few variable assignments, so we don’t need a separate function for that. Other tasks for which we don’t need a separate function are task 2 (just a call to <code class="calibre25">random.randint</code>), 3a (just a few <code class="calibre25">print</code> calls), and 4 (a <code class="calibre25">print</code> call). We’ll capture each of the remaining subtasks in a function. The following subsections describe each of the remaining subtasks.</p>
</div>
<div class="readable-text" id="p163">
<h4 class="readable-text-h3">Task 3. While the game isn’t over</h4>
</div>
<div class="readable-text" id="p164">
<p class="calibre15">We’ll have a <code class="calibre25">while</code> loop that continues while the game isn’t over, so we’ll need a function to tell us whether the game is over! How can the function know whether the game is over? It’ll need to know the current number of chips that Player 1 has and the current number of chips that Player 2 has. That way, it can check whether one of these is at least 30. But remember that there’s another way for the game to end, and that’s when a player rolls five dice, none of which is a 1. Therefore, this function will also need to know the most recent dice rolls for the current player.</p>
</div>
<div class="readable-text" id="p165">
<p class="calibre15">We’ll name this function <code class="calibre25">game_over</code>. It will take three parameters: Player 1 chips, Player 2 chips, and list of rolls. It will return <code class="calibre25">True</code> if the game is over and <code class="calibre25">False</code> otherwise. The code for this function will need to check a few conditions, but we should be able to do that without splitting it out into further subtasks.</p>
</div>
<div class="readable-text" id="p166">
<h4 class="readable-text-h3">Task 3b. Take a full turn for the current player</h4>
</div>
<div class="readable-text" id="p167">
<p class="calibre15">We’ll name this function <code class="calibre25">take_full_turn</code>. The function <em class="calibre18">needs</em> to know how many chips are in the pot right now, so that it can update that as needed. It’ll also need to return the updated number of chips in the pot. Beyond that, there’s a lot that we need to manage to carry out a full turn, so we’re going to need to keep the complexity of this function under control. Here’s what comes to mind for what this function may need to do:</p>
</div>
<ol class="calibre28">
<li class="readable-text1" id="p168"> Allow the player to roll one die, then two dice, then three dice, and so on until the player’s turn is over. </li>
<li class="readable-text1" id="p169"> Update the current player’s number of chips based on what happened on this turn. We could add an additional return value to communicate this updated information to whoever called this function. </li>
<li class="readable-text1" id="p170"> Determine whether the game is over. We could add an additional return value where <code class="calibre25">True</code> means that the game is over and <code class="calibre25">False</code> means that it isn’t. </li>
</ol>
<div class="readable-text" id="p171">
<p class="calibre15">We initially tried to have the function do all three of these things but were unable to receive satisfactory code from Copilot. This isn’t too surprising because we’re asking the function to do too much. This led us to focus on the core of this function, which is point 1.</p>
</div>
<div class="readable-text" id="p172">
<p class="calibre15">But OK, if we focus only on point 1, then how are we going to update the current player’s number of chips (point 2), and how will we know whether the game is over (point 3)? For point 2, the solution we thought of is to not update the current player’s chip count at all in this function, instead returning the total number of chips in the pot after this turn.</p>
</div>
<div class="readable-text" id="p173">
<p class="calibre15">For example, if there were 10 chips in the pot and this player’s turn generated 6 chips, then we’d return 16. The player may or may not get to collect these 16 chips—it depends on how their turn ended—but we won’t deal with that here (this is for the calling function to manage now). </p>
</div>
<div class="readable-text" id="p174">
<p class="calibre15">For point 3 (knowing whether the game is over), our solution is to have the function return the most recent list of rolls as part of its return value. (This list of rolls will also be needed by the calling function for point 2.) The function that calls this one can then use those rolls to determine whether the game is over.</p>
</div>
<div class="readable-text" id="p175">
<p class="calibre15">In summary, our function will take the number of chips in the pot as a parameter and will return a list of two values: the new number of chips in the pot after the player’s turn and the most recent list of rolls. </p>
</div>
<div class="readable-text" id="p176">
<p class="calibre15">To take a full turn, we’ll need to be able to roll dice: first one die, then two dice, then three dice, and so on. We’ll split this out into a function named <code class="calibre25">roll_dice</code>. It will take the number of dice to roll as a parameter and will return a list of rolls. For example, if we ask the function to roll three dice, we might get back <code class="calibre25">[6,</code> <code class="calibre25">1,</code> <code class="calibre25">4]</code>. </p>
</div>
<div class="readable-text" id="p177">
<p class="calibre15">We’ll also need to be able to determine whether the turn is over based on the most recent list of rolls. If the player rolled any 1s or rolled five dice none of which is a 1, then the turn is over. We’ll split that out too into a function named <code class="calibre25">turn_over</code>. It will take the list of rolls as a parameter and will return <code class="calibre25">True</code> if the turn is over and <code class="calibre25">False</code> if not.</p>
</div>
<div class="readable-text" id="p178">
<p class="calibre15">If the turn isn’t over, then we’ll need to ask the player whether they want to continue their turn. We’ll ask for a yes (y) or no (n) response. We can do that using a call to the <code class="calibre25">input</code> function. If the player wants to keep going, we can again call <code class="calibre25">roll_dice</code>. We don’t need a separate function for asking for user input, so we won’t break this part down any further. If we wanted to validate the user’s input (rejecting any response that’s not y or n), that would increase the complexity enough so that we’d probably split it out.</p>
</div>
<div class="readable-text" id="p179">
<p class="calibre15">In summary, we’ve split out two subtasks for our <code class="calibre25">take_full_turn</code> function: <code class="calibre25">roll_ dice</code> and <code class="calibre25">turn_over</code>. These functions don’t need to be broken down any further. For <code class="calibre25">roll_dice</code>, we can use <code class="calibre25">random.randint</code> in a loop to generate the rolls that we need. And, <code class="calibre25">turn_over</code> will amount to a couple of checks on the dice rolls to determine whether they ended the turn for which we won’t need any further breaking down.</p>
</div>
<div class="readable-text" id="p180">
<h4 class="readable-text-h3">Task 3c. If the current player won chips</h4>
</div>
<div class="readable-text" id="p181">
<p class="calibre15">When a player’s turn ends, we’re furnished with the new number of chips in the pot and the final list of rolls that ended the turn. We need to determine whether the player gets those chips or not. (If the final list of rolls doesn’t contain a 1, then the player collects the chips; otherwise, they don’t, and the chips stay in the pot.) </p>
</div>
<div class="readable-text" id="p182">
<p class="calibre15">We’ll split out a function to tell us whether the player collects the chips or not. We’ll name it <code class="calibre25">wins_chips</code>. This function will take the most recent list of rolls as a parameter and will return <code class="calibre25">True</code> if the player wins the chips and <code class="calibre25">False</code> otherwise.</p>
</div>
<div class="readable-text" id="p183">
<h4 class="readable-text-h3">Task 3d. Switch to the other player’s turn</h4>
</div>
<div class="readable-text" id="p184">
<p class="calibre15">We’ll name this function <code class="calibre25">switch_player</code>. Suppose that the current player has just finished their turn. We need to switch to the other player’s turn, but only if the game isn’t over yet. Our function will encapsulate this logic. It will need to call <code class="calibre25">game_over</code> to determine whether the game is over, so we need at least three parameters for <code class="calibre25">switch_player</code>: player 1’s chips, player 2’s chips, and the most recent list of dice rolls. We’ll also need a parameter to indicate the current player (1 or 2), so that we can return the number of the new current player. So, the function will take those four parameters, and it will return a 1 or a 2 indicating the player that we’re switching to next.</p>
</div>
<div class="readable-text" id="p185">
<p class="calibre15">If the game is over, this function won’t do anything. And if the game isn’t over, then we’ll need to change a 1 to a 2 or a 2 to a 1. We already have the <code class="calibre25">game_over</code> function, and that’s sufficient for breaking down this function.</p>
</div>
<div class="readable-text" id="p186">
<p class="calibre15">We’ve finished our top-down design! Check out figure 10.6 for our tree of functions.<span/></p>
</div>
<div class="browsable-container" id="p187">
<img alt="figure" src="../Images/10-6.png" class="calibre90"/>
<h5 class="figure-container-h"><span>Figure 10.6</span> Top-down design for the Bogart game</h5>
</div>
<div class="readable-text" id="p188">
<h3 class="readable-text-h2" id="sigil_toc_id_158"><span class="calibre22">10.4.3</span> Implementing our functions</h3>
</div>
<div class="readable-text" id="p189">
<p class="calibre15">Now it’s time to work with Copilot to write the code for each of our functions. As always, we’ll start with leaf functions and move our way up (left in the diagram), implementing our top-level <code class="calibre25">play</code> function only when all other functions have been implemented. We can start with any leaf function. We’ll start with the <code class="calibre25">game_over</code> function because it’s needed both by <code class="calibre25">play</code> and by <code class="calibre25">switch_player</code>. Then, we’ll move on to other functions.</p>
</div>
<div class="readable-text" id="p190">
<h4 class="readable-text-h3">game_over</h4>
</div>
<div class="readable-text" id="p191">
<p class="calibre15">This function takes three parameters: the number of chips that Player 1 has, the number of chips that Player 2 has, and the most recent list of rolls. It returns <code class="calibre25">True</code> if the game is over, and <code class="calibre25">False</code> if not, as shown in the following listing.</p>
</div>
<div class="browsable-container" id="p192">
<h5 class="listing-container-h"><span>Listing 10.6</span> <code class="calibre25">game_over</code> function in Bogart</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def game_over(player1, player2, rolls):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    player1 is the number of chips that player 1 has.</strong>
<strong class="calibre17">    player2 is the number of chips that player 2 has.</strong>
<strong class="calibre17">    rolls is the last list of dice rolls.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Return True if the game is over, False otherwise.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    The game is over if player1 has at least 30 chips, </strong>
<strong class="calibre17">    or player 2 has at least 30 chips, </strong>
<strong class="calibre17">    or there are 5 rolls none of which is a 1.</strong>
<strong class="calibre17">    '''</strong>
    return player1 &gt;= 30 or player2 &gt;= 30 or \      <span/> #1
            (len(rolls) == 5 and not 1 in rolls)     #1</pre>
<div class="code-annotations-overlay-container">
     #1 The three ways that the game is over
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p193">
<p class="calibre15">Remember that there are three ways for the game to be over: Player 1 has at least 30 chips, Player 2 has at least 30 chips, or a player managed to roll five dice on their last turn without rolling a 1.</p>
</div>
<div class="callout-container">
<div class="readable-text" id="p194">
<h5 class="callout-container-h">Returning a Boolean directly</h5>
</div>
<div class="readable-text" id="p195">
<p class="calibre15">You may have expected to see the code this way, with the use of <code class="calibre25">if-else</code> and actual <code class="calibre25">return</code> <code class="calibre25">True</code> and <code class="calibre25">return</code> <code class="calibre25">False</code> lines:</p>
</div>
<div class="browsable-container" id="p196">
<div class="readable-text">
<pre class="code-area">if player1 &gt;= 30 or player2 &gt;= 30 or (len(rolls) == 5
        and not 1 in rolls):
    return True
else:
    return False</pre>
</div>
</div>
<div class="readable-text" id="p197">
<p class="calibre15">This would work, but it’s more common to see programmers use a <code class="calibre25">return</code> statement directly with the <code class="calibre25">True</code>/<code class="calibre25">False</code> expression. It works because the result of the expression is what is being returned. If the expression is true, <code class="calibre25">True</code> gets returned, and if the expression is false, <code class="calibre25">False</code> gets returned. That’s exactly the same thing that the <code class="calibre25">if-else</code> version does! </p>
</div>
</div>
<div class="readable-text" id="p198">
<h4 class="readable-text-h3">roll_dice</h4>
</div>
<div class="readable-text" id="p199">
<p class="calibre15">This is the function that rolls our dice and adds randomness to our game. It takes the number of dice to roll as a parameter, and it returns the list of dice rolls. We’ll expect Copilot to make use of <code class="calibre25">random.randint</code> here, as shown in listing 10.7.</p>
</div>
<div class="readable-text" id="p200">
<p class="calibre15">In addition to returning the list of rolls, it’s also helpful if this function prints each dice roll. That way, the player can see exactly what they rolled. In the docstring, we ask Copilot to print the rolls (in addition to returning the list of rolls).</p>
</div>
<div class="browsable-container" id="p201">
<h5 class="listing-container-h"><span>Listing 10.7</span> <code class="calibre25">roll_dice</code> function in Bogart</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">import random</strong>
<strong class="calibre17">def roll_dice(n):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    Create a list of n random integers between 1 and 6.</strong>
<strong class="calibre17">    Print each of these integers, and return the list.</strong>
<strong class="calibre17">    '''</strong>
    rolls = []                  <span/> #1
    for i in range(n):         <strong class="calibre17">      </strong><span/> #2
        roll = random.randint(1, 6)     <span/> #3
        print(roll)                  <span/> #4
        rolls.append(roll)     <span/> #5
    return rolls     <span/> #6</pre>
<div class="code-annotations-overlay-container">
     #1 List of dice rolls (integers between 1 and 6), starts empty
     <br class="calibre1"/>#2 Loops n times, once per roll
     <br class="calibre1"/>#3 Uses “randint” to generate a random integer between 1 and 6
     <br class="calibre1"/>#4 Prints roll for players to see
     <br class="calibre1"/>#5 Adds roll to list of rolls
     <br class="calibre1"/>#6 Returns list of rolls
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p202">
<h4 class="readable-text-h3">turn_over</h4>
</div>
<div class="readable-text" id="p203">
<p class="calibre15">This function takes the most recent list of rolls and uses that to determine whether the current player’s turn is over or not. It returns <code class="calibre25">True</code> if the turn is over, and <code class="calibre25">False</code> if not, as shown in the following listing.</p>
</div>
<div class="browsable-container" id="p204">
<h5 class="listing-container-h"><span>Listing 10.8</span> <code class="calibre25">turn_over</code> function in Bogart</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def turn_over(rolls):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    Return True if the turn is over, False otherwise.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    The turn is over if any of the rolls is a 1, </strong>
<strong class="calibre17">    or if there are exactly five rolls.</strong>
<strong class="calibre17">    '''</strong>
    return 1 in rolls or len(rolls) == 5     <span/> #1</pre>
<div class="code-annotations-overlay-container">
     #1 The two ways for the turn to be over
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p205">
<p class="calibre15">There are two ways for the player’s turn to be over. The first is when there’s a 1 in the list of rolls. The second is when the player has rolled five dice.</p>
</div>
<div class="readable-text" id="p206">
<p class="calibre15">Is <code class="calibre25">len(rolls)</code> <code class="calibre25">==</code> <code class="calibre25">5</code> really enough for the turn to be over? Don’t we have to check whether there were any 1s rolled? No, if the player rolls five dice, then their turn is over no matter what, regardless of what the dice rolls were. If they rolled any 1s, then the turn is over because they rolled a 1 (and they won’t collect any chips). If they didn’t roll any 1s, then the turn is still over (and they’ll win the game automatically in this case).</p>
</div>
<div class="readable-text" id="p207">
<h4 class="readable-text-h3">take_full_turn</h4>
</div>
<div class="readable-text" id="p208">
<p class="calibre15">We’re ready for <code class="calibre25">take_full_turn</code> now, as shown in listing 10.9. This function takes the number of chips currently in the pot as a parameter. It will process all the rolls from a full turn for the current player and then returns a list of two values: the new number of chips in the pot and the final list of rolls.</p>
</div>
<div class="browsable-container" id="p209">
<h5 class="listing-container-h"><span>Listing 10.9</span> <code class="calibre25">take_full_turn</code> function in Bogart</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def take_full_turn(pot_chips):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    The pot has pot_chips chips.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Take a full turn for the current player and, once done, </strong>
<strong class="calibre17">    return a list of two values:</strong>
<strong class="calibre17">    the number of chips in the pot, and the final list of dice rolls.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Begin by rolling 1 die, and put 1 chip into the pot.</strong>
<strong class="calibre17">    Then, if the turn isn't over, ask the player whether </strong>
<strong class="calibre17">    they'd like to continue their turn.</strong>
<strong class="calibre17">    If they respond 'n', then the turn is over.</strong>
<strong class="calibre17">         If they respond 'y', then roll one more die than last time, </strong>
<strong class="calibre17">         and add 1 chip to the pot for each die that is rolled.</strong>
<strong class="calibre17">         (for example, if 3 dice were rolled last time, then </strong>
<strong class="calibre17">         roll 4 dice and add 4 chips to the pot.)</strong>
<strong class="calibre17">    If the turn is not over, repeat by asking the player again </strong>
<strong class="calibre17">    whether they'd like to continue their turn.</strong>
<strong class="calibre17">    '''</strong>
    rolls = roll_dice(1)     <span/> #1
    pot_chips += 1                      <span/> #2
    while not turn_over(rolls):                  <span/> #3
        keep_going = input('Continue? (y/n) ')     <span/> #4
        if keep_going == 'y':                      <span/> #5
            rolls = roll_dice(len(rolls) + 1)        <span/> #6
            pot_chips += len(rolls)          <span/> #7
        else:
            break                 <span/> #8
    return pot_chips, rolls   <span/> #9</pre>
<div class="code-annotations-overlay-container">
     #1 Rolls one dice
     <br class="calibre1"/>#2 Adds one chip to the pot
     <br class="calibre1"/>#3 While the current player’s turn isn’t over . . . 
     <br class="calibre1"/>#4 . . . asks the player if they want to continue their turn.
     <br class="calibre1"/>#5 If they do want to continue their turn . . . 
     <br class="calibre1"/>#6 . . . rolls one more dice than last time.
     <br class="calibre1"/>#7 Adds new chips to the pot
     <br class="calibre1"/>#8 Gets out of the while loop
     <br class="calibre1"/>#9 Returns both number of chips in the pot and the final list of rolls
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p210">
<h4 class="readable-text-h3">wins_chips</h4>
</div>
<div class="readable-text" id="p211">
<p class="calibre15">This function takes a list of rolls as a parameter. If the rolls are good (i.e., contain no 1s), then the player will collect the chips. If the rolls contain any 1s, then the player won’t collect the chips. This function returns <code class="calibre25">True</code> if the player gets to collect the chips, and <code class="calibre25">False</code> otherwise, as shown in the following listing.</p>
</div>
<div class="browsable-container" id="p212">
<h5 class="listing-container-h"><span>Listing 10.10</span> <code class="calibre25">wins_chips</code> function in Bogart</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def wins_chips(rolls):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    Return True if the player wins chips, False otherwise.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    The player wins the chips if none of the rolls is a 1.</strong>
<strong class="calibre17">    '''</strong>
    return not 1 in rolls     <span/> #1</pre>
<div class="code-annotations-overlay-container">
     #1 Returns True when there are no 1s, and returns False otherwise
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p213">
<h4 class="readable-text-h3">switch_player </h4>
</div>
<div class="readable-text" id="p214">
<p class="calibre15">This function takes four parameters: the number of chips that Player 1 has, the number of chips that Player 2 has, the most recent list of rolls (rolled by the current player), and the number of the current player. If the game isn’t over, this function returns the number of the other player. If the game is over, then the function returns the current player (because there’s no turn for the other player!). See the following listing.</p>
</div>
<div class="browsable-container" id="p215">
<h5 class="listing-container-h"><span>Listing 10.11</span> <code class="calibre25">switch_player</code> function in Bogart</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def switch_player(player1, player2, rolls, current_player):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    player1 is the number of chips that player 1 has.</strong>
<strong class="calibre17">    player2 is the number of chips that player 2 has.</strong>
<strong class="calibre17">    rolls is the last list of dice rolls.</strong>
<strong class="calibre17">    current_player is the current player (1 or 2).</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    If the game is not over, switch current_player to the other player.</strong>
<strong class="calibre17">    Return the new current_player.</strong>
<strong class="calibre17">    '''</strong>
    if not game_over(player1, player2, rolls):    <span/> #1
        if current_player == 1:               <span/> #2
            current_player = 2
        else:
            current_player = 1
    return current_player       <span/> #3</pre>
<div class="code-annotations-overlay-container">
     #1 If game isn’t over . . . 
     <br class="calibre1"/>#2 . . . switches from 1 to 2 or from 2 to 1.
     <br class="calibre1"/>#3 Returns new current player
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p216">
<h4 class="readable-text-h3">play</h4>
</div>
<div class="readable-text" id="p217">
<p class="calibre15">We’ve made it all the way up to our <code class="calibre25">play</code> function! We’ve decided to write this function without any parameters. You might wonder if we could make the code more flexible by adding, say, a parameter for the number of chips required to win (currently 30). You could certainly do that; we haven’t done that here to keep the number of parameters smaller throughout the code. This function doesn’t return anything. Instead, it plays the game, as shown in the following listing.</p>
</div>
<div class="browsable-container" id="p218">
<h5 class="listing-container-h"><span>Listing 10.12</span> <code class="calibre25">play</code> function in Bogart</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def play():</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    Play the game until the game is over.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    The pot starts with 0 chips, and each player starts with 0 chips.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Randomly decide whether player 1 or player 2 goes first.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Before each turn, print three lines of information:</strong>
<strong class="calibre17">    1. The number of chips in the pot</strong>
<strong class="calibre17">    2. The number of chips that each player has</strong>
<strong class="calibre17">    3. Whether it is player 1's turn or player 2's turn</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Take a full turn for the current player. </strong>
<strong class="calibre17">    If they won the chips, add the chips in the pot to the </strong>
<strong class="calibre17">    total for that player and reset the pot to have 0 chips.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Then, switch to the other player's turn.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Once the game is over, print the current player </strong>
<strong class="calibre17">    (that's the player who won).</strong>
<strong class="calibre17">    '''</strong>
    pot_chips = 0     <strong class="calibre17"> </strong><span/> #1
    player1 = 0       <strong class="calibre17"> </strong> #1
    player2 = 0       <strong class="calibre17"> </strong> #1
    current_player = random.randint(1, 2)     <span/> #2
    rolls = []
    while not game_over(player1, player2, rolls):    <span/> #3
        print('Pot chips:', pot_chips)              <strong class="calibre17">  </strong><span/> #4
        print('Player 1 chips:', player1)              #4
        print('Player 2 chips:', player2)           <strong class="calibre17">  </strong> #4
        print('Player', current_player, 'turn')     <strong class="calibre17">  </strong> #4
        pot_chips, rolls = take_full_turn(pot_chips)    <span/> #5
        if wins_chips(rolls):                          <span/> #6
            if current_player == 1:                  <strong class="calibre17">      </strong><span/> #7
                player1 += pot_chips                      <span/> #8
            else:
                player2 += pot_chips         <strong class="calibre17">            </strong><span/> #9
            pot_chips = 0                             <span/> #10
        current_player = switch_player(player1, player2, <span/> #11
                                       rolls, current_player)
    print('Player', current_player, 'wins!')  <span/> #12</pre>
<div class="code-annotations-overlay-container">
     #1 Starts pot and players with 0 chips
     <br class="calibre1"/>#2 Randomly makes Player 1 or Player 2 start the game
     <br class="calibre1"/>#3 While the game isn’t over . . . 
     <br class="calibre1"/>#4 . . . prints the current state of the game.
     <br class="calibre1"/>#5 Lets the current player have their turn
     <br class="calibre1"/>#6 If current player wins chips . . . 
     <br class="calibre1"/>#7 . . . and it’s Player 1 . . . 
     <br class="calibre1"/>#8 . . . gives Player 1 the chips from the pot; . . . 
     <br class="calibre1"/>#9 . . . otherwise, gives Player 2 the chips from the pot.
     <br class="calibre1"/>#10 Resets pot to now have 0 chips
     <br class="calibre1"/>#11 Switches to the other player’s turn
     <br class="calibre1"/>#12 Prints out who wins
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p219">
<p class="calibre15">We now have all the code that we need for the game. Just add </p>
</div>
<div class="browsable-container" id="p220">
<div class="readable-text">
<pre class="code-area">play()</pre>
</div>
</div>
<div class="readable-text" id="p221">
<p class="calibre15">below all of your existing code to call our <code class="calibre25">play</code> function, and then you’ll be able to play!</p>
</div>
<div class="readable-text" id="p222">
<h4 class="readable-text-h3">Customizing the game</h4>
</div>
<div class="readable-text" id="p223">
<p class="calibre15">We’re happy with what Copilot has given us, and the game is certainly playable. But, admittedly, the interaction with the players could be a little more user-friendly. For example, here’s how the game might start when we run it and press y a few times:</p>
</div>
<div class="readable-text" id="p224">
<p class="calibre15">Pot chips: 0</p>
</div>
<div class="readable-text" id="p225">
<p class="calibre15">Player 1 chips: 0</p>
</div>
<div class="readable-text" id="p226">
<p class="calibre15">Player 2 chips: 0</p>
</div>
<div class="readable-text" id="p227">
<p class="calibre15">Player 2 turn</p>
</div>
<div class="readable-text" id="p228">
<p class="calibre15">4</p>
</div>
<div class="readable-text" id="p229">
<p class="calibre15">Continue? (y/n) y</p>
</div>
<div class="readable-text" id="p230">
<p class="calibre15">5</p>
</div>
<div class="readable-text" id="p231">
<p class="calibre15">2</p>
</div>
<div class="readable-text" id="p232">
<p class="calibre15">Continue? (y/n) y</p>
</div>
<div class="readable-text" id="p233">
<p class="calibre15">3</p>
</div>
<div class="readable-text" id="p234">
<p class="calibre15">1</p>
</div>
<div class="readable-text" id="p235">
<p class="calibre15">4</p>
</div>
<div class="readable-text" id="p236">
<p class="calibre15">Pot chips: 6</p>
</div>
<div class="readable-text" id="p237">
<p class="calibre15">Player 1 chips: 0</p>
</div>
<div class="readable-text" id="p238">
<p class="calibre15">Player 2 chips: 0</p>
</div>
<div class="readable-text" id="p239">
<p class="calibre15">Player 1 turn</p>
</div>
<div class="readable-text" id="p240">
<p class="calibre15">2</p>
</div>
<div class="readable-text" id="p241">
<p class="calibre15">Continue? (y/n)</p>
</div>
<div class="readable-text" id="p242">
<p class="calibre15">There’s no welcome message. Numbers like 4, 5, 2, and so on are just there, with no context of what they mean. The game asks us whether we want to “Continue? (y/n).” Continue what, though? It isn’t clear.</p>
</div>
<div class="readable-text" id="p243">
<p class="calibre15">We can make the interaction with the players more pleasant by spicing up the <code class="calibre25">print</code> calls in our functions. We can just put what we want in each <code class="calibre25">print</code> statement ourselves. Why not just use Copilot? It’s likely easier to just do it rather than trying to cajole Copilot to print exactly what we want. For example, the following listing shows a new version of <code class="calibre25">play</code> where we’ve added more <code class="calibre25">print</code> calls to explain what’s going on and to better format the game output.</p>
</div>
<div class="browsable-container" id="p244">
<h5 class="listing-container-h"><span>Listing 10.13</span> <code class="calibre25">play</code> function in Bogart with better formatting</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def play():</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    Play the game until the game is over.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    The pot starts with 0 chips, and each player starts with 0 chips.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Randomly decide whether player 1 or player 2 goes first.</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Before each turn, print three lines of information:</strong>
<strong class="calibre17">    1. The number of chips in the pot</strong>
<strong class="calibre17">    2. The number of chips that each player has</strong>
<strong class="calibre17">    3. Whether it is player 1's turn or player 2's turn</strong>
<strong class="calibre17">    </strong>
<strong class="calibre17">    Take a full turn for the current player. </strong>
<strong class="calibre17">    If they won the chips, add the chips in the pot to the</strong>
<strong class="calibre17">    total for that player</strong>
<strong class="calibre17">    and reset the pot to have 0 chips.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Then, switch to the other player's turn.</strong>
<strong class="calibre17"> </strong>
<strong class="calibre17">    Once the game is over, print the current player </strong>
<strong class="calibre17">    (that's the player who won).</strong>
<strong class="calibre17">    '''</strong>
    pot_chips = 0
    player1 = 0
    player2 = 0
    current_player = random.randint(1, 2)
    rolls = []

    print('Welcome to Bogart!')      <span/> #1
    print()                           <span/> #2

    while not game_over(player1, player2, rolls):
        print('Pot chips:', pot_chips)
        print('Player 1 chips:', player1)
        print('Player 2 chips:', player2)
        print('Player', current_player, 'turn')
        pot_chips, rolls = take_full_turn(pot_chips)
        if wins_chips(rolls):
            print('Player', current_player, 'gets', <strong class="calibre17">  </strong><span/> #3
                  pot_chips, 'chips!')                 #3
            if current_player == 1:
                player1 += pot_chips
            else:
                player2 += pot_chips
            pot_chips = 0
        current_player = switch_player(player1, player2, 
                                       rolls, current_player)

        print()
        print()
        print('-=' * 20)    <span/> #4
        print()

    print('Player', current_player, 'wins!')</pre>
<div class="code-annotations-overlay-container">
     #1 Prints welcome message
     <br class="calibre1"/>#2 Prints a blank line
     <br class="calibre1"/>#3 Prints message saying that the current player got chips
     <br class="calibre1"/>#4 Separates each turn from the next
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p245">
<p class="calibre15">We encourage you to add <code class="calibre25">print</code> calls elsewhere as well to make the game interaction even better! For example, in <code class="calibre25">roll_dice</code>, you could add a <code class="calibre25">print</code> call to tell the players that dice are about to be rolled (**ROLLS** in the following output). In <code class="calibre25">take_full_ turn</code>, you could add a <code class="calibre25">print</code> call to print the number of chips in the pot prior to asking the player whether they’d like to continue their turn. Here’s what an interaction with our game looks like after we made those changes:</p>
</div>
<div class="readable-text" id="p246">
<p class="calibre15">Welcome to Bogart!</p>
</div>
<div class="readable-text" id="p247">
<p class="calibre15">Pot chips: 0</p>
</div>
<div class="readable-text" id="p248">
<p class="calibre15">Player 1 chips: 0</p>
</div>
<div class="readable-text" id="p249">
<p class="calibre15">Player 2 chips: 0</p>
</div>
<div class="readable-text" id="p250">
<p class="calibre15">Player 2 turn</p>
</div>
<div class="readable-text" id="p251">
<p class="calibre15">**ROLLS**</p>
</div>
<div class="readable-text" id="p252">
<p class="calibre15">2</p>
</div>
<div class="readable-text" id="p253">
<p class="calibre15">The pot currently has 1 chips.</p>
</div>
<div class="readable-text" id="p254">
<p class="calibre15">Continue turn? (y/n) y</p>
</div>
<div class="readable-text" id="p255">
<p class="calibre15">**ROLLS**</p>
</div>
<div class="readable-text" id="p256">
<p class="calibre15">6</p>
</div>
<div class="readable-text" id="p257">
<p class="calibre15">3</p>
</div>
<div class="readable-text" id="p258">
<p class="calibre15">The pot currently has 3 chips.</p>
</div>
<div class="readable-text" id="p259">
<p class="calibre15">Continue turn? (y/n) y</p>
</div>
<div class="readable-text" id="p260">
<p class="calibre15">**ROLLS**</p>
</div>
<div class="readable-text" id="p261">
<p class="calibre15">1</p>
</div>
<div class="readable-text" id="p262">
<p class="calibre15">1</p>
</div>
<div class="readable-text" id="p263">
<p class="calibre15">6</p>
</div>
<div class="readable-text" id="p264">
<p class="calibre15">-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</p>
</div>
<div class="readable-text" id="p265">
<p class="calibre15">Pot chips: 6</p>
</div>
<div class="readable-text" id="p266">
<p class="calibre15">Player 1 chips: 0</p>
</div>
<div class="readable-text" id="p267">
<p class="calibre15">Player 2 chips: 0</p>
</div>
<div class="readable-text" id="p268">
<p class="calibre15">Player 1 turn</p>
</div>
<div class="readable-text" id="p269">
<p class="calibre15">**ROLLS**</p>
</div>
<div class="readable-text" id="p270">
<p class="calibre15">5</p>
</div>
<div class="readable-text" id="p271">
<p class="calibre15">The pot currently has 7 chips.</p>
</div>
<div class="readable-text" id="p272">
<p class="calibre15">Continue turn? (y/n)</p>
</div>
<div class="readable-text" id="p273">
<p class="calibre15">Try making such changes to your code as well. Make the game yours! </p>
</div>
<div class="readable-text" id="p274">
<p class="calibre15">In this chapter, we used Copilot to help us write two computer games: a logic game (similar to Wordle, but with numbers), and a two-player dice game. We were able to do this using the skills we’ve honed throughout the book, including problem decomposition, writing clear docstrings, and interacting with Copilot Chat. </p>
</div>
<div class="readable-text" id="p275">
<h2 class="readable-text-h1" id="sigil_toc_id_159"><span class="calibre22">10.5</span> Exercises</h2>
</div>
<ol class="calibre28">
<li class="readable-text1" id="p276"> There is an error in the following <code class="calibre25">guess_result</code> function that leads to incorrect counts of correct and misplaced digits. Identify and fix the error: </li>
</ol>
<div class="browsable-container" id="p277">
<div class="readable-text">
<pre class="code-area">def guess_result(guess, secret_code): 
   correct = 0 
   misplaced = 0 
   for i in range(len(guess)): 
      if guess[i] == secret_code[i]: 
  correct += 1 
     if guess[i] in secret_code: 
         misplaced += 1 
return [correct, misplaced]</pre>
</div>
</div>
<ol class="faux-ol-li">
<li class="readable-text3" id="p278"><span class="faux-ol-li-counter">2. </span> Modify the <code class="calibre25">get_guess</code> function from this chapter to include error messages that guide the player to enter a valid guess. Ensure that these messages are clear and helpful. Be creative! Here are some examples: 
    <ol class="calibre48">
<li class="calibre30"> “Error: Guess must contain only digits.” </li>
<li class="calibre30"> “Error: Guess must not contain repeated digits.” </li>
</ol></li>
<li class="readable-text3" id="p279"><span class="faux-ol-li-counter">3. </span> Why did we choose to pass the number of digits and the number of guesses as parameters to the <code class="calibre25">play</code> function for the Bulls and Cows game? How does this decision enhance the flexibility of the game? </li>
<li class="readable-text3" id="p280"><span class="faux-ol-li-counter">4. </span> Implement a simple dice game where the player rolls two dice. If the total is 7 or 11, the player wins. If the total is 2, 3, or 12, the player loses. For any other total, the player continues to roll until they either match their initial roll (win) or roll a 7 (lose). Think carefully about how you want to divide the main problem here into smaller subproblems! </li>
<li class="readable-text3" id="p281"><span class="faux-ol-li-counter">5. </span> Implement a version of the Bogart game where one player is human and the other is the computer. To do this, you’ll need to come up with some rules that the computer can use to end their turn. For example, the computer will certainly want to stop rolling dice when the number of chips that they’ve already accumulated on their turn is enough for them to win the game! The computer will also likely want to stop rolling once it can earn a large number of chips on its current turn. </li>
<li class="readable-text3" id="p282"><span class="faux-ol-li-counter">6. </span> <em class="calibre18">The Price Is Right</em> game show is a great source of little games that may be fun to implement. For example, you can try implementing the game called Any Number: </li>
</ol>
<div class="readable-text" id="p283">
<p class="calibre15"><a href="https://priceisright.fandom.com/wiki/Any_Number">https://priceisright.fandom.com/wiki/Any_Number</a></p>
</div>
<div class="readable-text" id="p284">
<p class="calibre15">In your game, the player should continue to choose numbers until all the digits of one of the prizes are revealed; that’s the prize that the player wins.</p>
</div>
<ol class="faux-ol-li">
<li class="readable-text3" id="p285"><span class="faux-ol-li-counter">7. </span> Create a simple game using the Pygame library. In this game, the player controls a character that moves left and right to collect falling objects. The objective is to collect as many objects as possible without missing them. You can be flexible here with how the objects in your game look, so have fun with it! As a potential extension: Can you think of how you would keep track of the player’s high score? </li>
</ol>
<div class="readable-text" id="p286">
<h2 class="readable-text-h1" id="sigil_toc_id_160">Summary</h2>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p287"> Games have a common program flow that includes game setup and gameplay. </li>
<li class="readable-text1" id="p288"> Randomness is an important ingredient of many games. </li>
<li class="readable-text1" id="p289"> We can add randomness to our Python games by using functions in the random module. </li>
<li class="readable-text1" id="p290"> We can implement games with Copilot using the same workflow that we’ve used throughout the book, with problem decomposition playing a key role. </li>
</ul>
</div></body></html>