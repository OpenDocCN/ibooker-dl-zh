<html><head></head><body>
  <h1 class="tochead" id="heading_id_2">7 <a id="idTextAnchor001"/>Genetic algorithms</h1>

  <p class="co-summary-head">This chapter covers<a id="idIndexMarker000"/><a id="marker-233"/></p>

  <ul class="calibre5">
    <li class="co-summary-bullet">Introducing population-based optimization algorithms</li>

    <li class="co-summary-bullet">Understanding evolutionary computation</li>

    <li class="co-summary-bullet">Understanding the different components of genetic algorithms</li>

    <li class="co-summary-bullet">Implementing genetic algorithms in Python</li>
  </ul>

  <p class="body">Suppose you’re on a treasure-hunting mission and you don’t want the risk of searching alone and returning empty-handed. You might decide to collaborate with a group of friends and share information. This approach follows a population-based search strategy, where multiple agents are involved in the search process.</p>

  <p class="body">During this collaborative effort, you may notice that some hunters perform better than others. In this case, you may choose to retain only the best-performing hunters and replace the less competent ones with new recruits. This process resembles the workings of evolutionary algorithms such as genetic algorithms, where the fittest individuals survive and pass on their traits to the next generation.</p>

  <p class="body">In this chapter, the binary-coded genetic algorithm is presented and discussed as an evolutionary computing algorithm. We’ll look at different elements of this algorithm and at the implementation details. Other variants of genetic algorithms, such as the gray-coded genetic algorithm, real-valued genetic algorithm, and permutation-based genetic algorithm will be discussed in the next chapter.</p>

  <h2 class="fm-head" id="heading_id_3">7.1 Population-based metaheuristic algorithms</h2>

  <p class="body">Population-based metaheuristic algorithms (P-metaheuristics), such as genetic algorithms, particle swarm optimization, and ant colony optimization, utilize multiple agents to search for an optimal or near-optimal global solution. As these algorithms begin with a diverse set of initial populations, they are naturally more exploration-based, allowing for the possibility of finding better solutions that might be missed by trajectory-based (S-metaheuristic) algorithms, which are more exploitation-based.<a id="idIndexMarker001"/><a id="idIndexMarker002"/><a id="idIndexMarker003"/><a id="idIndexMarker004"/><a id="marker-234"/></p>

  <p class="body">Population-based metaheuristic algorithms can be classified into two main categories based on their source of inspiration: <i class="fm-italics">evolutionary computation algorithms</i> and <i class="fm-italics">swarm intelligence algorithms</i>, as shown in figure 7.1.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F01_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.1 Metaheuristic algorithms</p>
  </div>

  <p class="body">Evolutionary computation (EC) algorithms, as the name suggests, are inspired by the process of biological evolution. These algorithms use a population of potential solutions, which undergo genetic operations, such as mutation and crossover, to create new offspring that may have better fitness values. The process of selection determines which individuals in the population are selected to reproduce and create the next generation. Genetic algorithm (GA), differential evolution (DE), genetic programming (GP), evolutionary programming (EP), evolutionary strategies (ES), cultural algorithms (CA), and co-evolution (CoE) are examples of evolutionary computation algorithms.<a id="idIndexMarker005"/><a id="idIndexMarker006"/><a id="idIndexMarker007"/><a id="idIndexMarker008"/><a id="idIndexMarker009"/><a id="idIndexMarker010"/><a id="idIndexMarker011"/><a id="idIndexMarker012"/></p>

  <p class="body">Swarm intelligence (SI) algorithms, on the other hand, are inspired by the collective behavior of social organisms such as ants, bees, and birds, and they’ll be discussed in part 4 of this book. These algorithms use a population of agents that interact with each other to find a solution. They use a variety of mechanisms, such as communication, cooperation, and self-organization, to optimize the search process. Examples of swarm intelligence algorithms include particle swarm optimization (PSO), ant colony optimization (ACO), artificial bee colony (ABC), the firefly algorithm (FA), the bat algorithm (BA), and the wolf search algorithm (WSA).<a id="idIndexMarker013"/><a id="idIndexMarker014"/><a id="idIndexMarker015"/><a id="idIndexMarker016"/><a id="idIndexMarker017"/><a id="idIndexMarker018"/><a id="idIndexMarker019"/></p>

  <p class="body">Both evolutionary computation and swarm intelligence algorithms are population-based algorithms that begin their search for the optimal or near-optimal solution from an initial population of candidate solutions. The quality and diversity of the initial population significantly influences the performance and efficiency of the algorithm. A well-constructed initial population provides a good starting point for the search process and can help the algorithm quickly converge toward a promising region of the search space. In contrast, a poorly constructed initial population may result in a premature convergence to a suboptimal solution, may get the algorithm stuck in a suboptimal region, or may take longer to converge toward a solution. To ensure a good balance between exploration and exploitation, the initial population should be diverse and cover a wide range of potential solutions.</p>

  <p class="body"><a id="marker-235"/>A comparison between different initialization strategies for population-based metaheuristics is provided in El-Ghazali Talbi’s <i class="fm-italics">Metaheuristics: From Design to Implementation</i> [1], based on three key aspects: diversity, computational cost, and the quality of initial solutions. Initial solutions can be generated using a pseudo-random process or a quasi-random search. Initial solutions can also be generated sequentially (sequential diversification) or concurrently (parallel diversification) to achieve very high diversity. Heuristics involve using local search or greedy methods to generate initial solutions.<a id="idIndexMarker020"/><a id="idIndexMarker021"/></p>

  <p class="body">As shown in table 7.1, a pseudo-random strategy provides moderate diversity, low computational cost, and low-quality initial solutions. A quasi-random strategy exhibits higher diversity with comparable computational cost and low-quality initial solutions. Sequential diversification and parallel diversification both stand out with very high diversity, but the former incurs moderate computational cost, while the latter has low computational cost; both methods result in low-quality initial solutions. In contrast, the use of heuristics, such as local search or a greedy heuristic, yields high-quality initial solutions but with low diversity and high computational cost.</p>

  <p class="fm-table-caption">Table 7.1 Initialization strategies for population-based metaheuristics<a id="idIndexMarker022"/></p>

  <table border="1" class="contenttable-1-table" id="table001" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Initialization strategy</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Diversity</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Computational cost</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Quality of initial solution</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">Pseudo-random</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Moderate</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Low</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Low</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">Quasi-random</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">High</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Low</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Low</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">Sequential diversification</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Very high</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Moderate</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Low</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">Parallel diversification</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Very high</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Low</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Low</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">Heuristics (e.g., local search or greedy heuristic)</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Low</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">High</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">High</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">It is often beneficial to use a randomized approach to generate the initial population, where the candidates are samples from different regions of the search space to maximize the chances of finding the optimal solution. The next listing shows how we can sample initial solutions using Python. Let’s start by generating 200 pseudo-random numbers.</p>

  <p class="fm-code-listing-caption">Listing 7.1 Generating initial populations in Python</p>
  <pre class="programlisting">import math
import numpy as np
import matplotlib.pyplot as plt
  
np.random.seed(6345245)                  <span class="fm-combinumeral">①</span>
  
N=200                                    <span class="fm-combinumeral">②</span>
P_random_pseudo=np.random.rand(N,N)      <span class="fm-combinumeral">③</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Set a seed for the random number generator.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Number of samples</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Pseudo-random sampling</p>

  <p class="fm-callout"><span class="fm-callout-head">Note</span> Random numbers are inherently unpredictable, pseudo-random numbers are deterministic but appear random, and quasi-random numbers are deterministic with evenly distributed patterns.<a id="marker-236"/></p>

  <p class="body">The generalized Halton number generator in the ghalton library can be used to generate quasi-random numbers. This method is based on the Halton sequence, which uses coprime numbers as its bases. You can use the generalized Halton number generator as follows:</p>
  <pre class="programlisting">!pip install ghalton
import ghalton
  
sequencer = ghalton.GeneralizedHalton(7,23)
P_random_quasi = np.array(sequencer.get(N))</pre>

  <p class="body">The Box-Muller transform is used to generate pairs of independent, standard, normally distributed random numbers from pairs of uniformly distributed random numbers. Box-Muller is a 2D Gaussian sampling method that can be used as follows:</p>
  <pre class="programlisting">u1 = np.random.uniform(size=(N))                        <span class="fm-combinumeral">①</span>
u2 = np.random.uniform(size=(N))                        <span class="fm-combinumeral">①</span>
  
P_BM_x = np.sqrt(-2*np.log(u1))*np.cos(2*math.pi*u2)    <span class="fm-combinumeral">②</span>
P_BM_y = np.sqrt(-2*np.log(u1))*np.sin(2*math.pi*u2)    <span class="fm-combinumeral">②</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Generate uniformly distributed values between 0 and 1.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Calculate x and y values using Box-Muller.</p>

  <p class="body">One of the drawbacks of the Box-Muller transform is its tendency to cluster values around the mean due to its dependency on uniform distribution. Additionally, calculating the square root can be costly.</p>

  <p class="body">Central limit theorem (CLT) sampling is another sampling method where the distribution of the sample means approximates a normal distribution as the sample size gets larger, regardless of the population’s distribution. The following code snippet shows how to implement this method:</p>
  <pre class="programlisting">import random
  
P_CLT_x=[2.0 * math.sqrt(N) * (sum(random.randint(0,1) for x in range(N)) / N - 0.5)
<span class="fm-code-continuation-arrow">➥</span> for x in range(N)]
P_CLT_y=[2.0 * math.sqrt(N) * (sum(random.randint(0,1) for x in range(N)) / N - 0.5)
<span class="fm-code-continuation-arrow">➥</span> for x in range(N)]</pre>

  <p class="body">The Sobol low-discrepancy sequence (LDS) is a quasi-random sampling method available in the sobol_seq package. This method generates a sequence of points that are evenly spaced and distributed throughout the sample space, such that the gaps between adjacent points are as small as possible. It can be used as follows:<a id="idIndexMarker023"/><a id="marker-237"/></p>
  <pre class="programlisting">!pip install sobol_seq
import sobol_seq
P_sobel=sobol_seq.i4_sobol_generate(2,N)</pre>

  <p class="body">Latin hypercube sampling is a parallel diversification method where the search space is decomposed into 25 blocks, and a solution is generated pseudo-randomly in each block. An example of using the Latin hybercube sampling method in the pyDOE (Design of Experiments) Python package is shown here:<a id="idIndexMarker024"/><a id="idIndexMarker025"/></p>
  <pre class="programlisting">!pip install pyDOE
from pyDOE import *
P_LHS=lhs(2, samples=N, criterion='center')</pre>

  <p class="body">Let’s visualize all of these sampling methods so we can get a good sense of the differences between them:</p>
  <pre class="programlisting">f, (ax1, ax2) = plt.subplots(ncols=2, figsize=(18,8))
f, (ax3,ax4) = plt.subplots(ncols=2, figsize=(18,8))
f, (ax5, ax6) = plt.subplots(ncols=2, figsize=(18,8))
ax1.scatter(P_random_pseudo[:,0], P_random_pseudo[:,1], color="gray")
ax2.scatter(P_random_quasi[:100], P_random_quasi[100:], color="red")
ax3.scatter(P_BM_x, P_BM_y, color="green")
ax4.scatter(P_CLT_x, P_CLT_y, color="cyan")
ax5.scatter(P_sobel[:,0], P_sobel[:,1], color="magenta")
ax6.plot(P_LHS[:,0], P_LHS[:,1], "o")
                          
ax1.set_title("Pseudo-random")
ax2.set_title("Quasi-random")
ax3.set_title("Box-Muller")
ax4.set_title("Central Limit Theorem")
ax5.set_title("Sobol")
ax6.set_title("Latin Hypercube")
plt.show()</pre>

  <p class="body">Running this code generates the plots shown in figure 7.2. In this figure, candidate solutions have been sampled from a feasible search space using various sampling methods, with each point representing a different solution. The level of diversity achieved by each sampling method can be evaluated by observing the gaps between the points and their dispersion.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F02_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.2 Sampling methods for generating an initial population<a id="marker-238"/></p>
  </div>

  <p class="body">As mentioned in appendix A (see liveBook), there are several Python packages for evolutionary computation. In this chapter, we will focus on using pymoo: multi-objective optimization in Python. Pymoo provides different sampling methods for creating an initial population or an initial search point. Examples include random sampling and Latin hypercube sampling. As a continuation of listing 7.1, the following code snippet shows random sampling in pymoo:<a id="idIndexMarker026"/></p>
  <pre class="programlisting">!pip install -U pymoo
from pymoo.core.problem import Problem                         <span class="fm-combinumeral">①</span>
from pymoo.operators.sampling.rnd import FloatRandomSampling   <span class="fm-combinumeral">②</span>
from pymoo.util import plotting                                <span class="fm-combinumeral">③</span>
  
problem = Problem(n_var=2, xl=0, xu=1)                         <span class="fm-combinumeral">④</span>
  
sampling = FloatRandomSampling()                               <span class="fm-combinumeral">⑤</span>
  
X = sampling(problem, 200).get("X")                            <span class="fm-combinumeral">⑥</span>
plotting.plot(X, no_fill=True)                                 <span class="fm-combinumeral">⑦</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Import an instance of the problem class.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Import the random sampling method.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Import the visualization method.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Create a problem with two variables, and specify the lower and upper bounds.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Create an instance of the random sampler.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Generate 200 random solutions/individuals.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑦</span> Visualize the generated individuals.</p>

  <p class="body">The following code generates and visualizes 200 initial solutions using Latin hypercube sampling:</p>
  <pre class="programlisting">from pymoo.operators.sampling.lhs import LHS      <span class="fm-combinumeral">①</span>
  
sampling = LHS()
  
X = sampling(problem, 200).get("X")
plotting.plot(X, no_fill=True)</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Import the Latin hypercube sampling module.</p>

  <p class="body"><a id="marker-239"/>If the solutions take the form of permutations, random permutations can be generated as follows:</p>
  <pre class="programlisting">per1=np.random.permutation(10)                               <span class="fm-combinumeral">①</span>
print(per1)
  
per2 = np.array([5, 4, 9, 0, 1, 2, 6, 8, 7, 3])              <span class="fm-combinumeral">②</span>
np.random.shuffle(per2)                                      <span class="fm-combinumeral">②</span>
print(per2)
  
pop_init = np.arange(50).reshape((10,5))                     <span class="fm-combinumeral">③</span>
np.random.permutation(pop_init)                              <span class="fm-combinumeral">③</span>
  
from itertools import combinations                           <span class="fm-combinumeral">④</span>
size=5                                                       <span class="fm-combinumeral">④</span>
ones=2                                                       <span class="fm-combinumeral">④</span>
  
for pos in map(set, combinations(range(size), ones)):        <span class="fm-combinumeral">④</span>
     print([int(i in pos) for i in range(size)], sep='\n')   <span class="fm-combinumeral">④</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Randomly permute a sequence, or return a permuted range.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Randomly shuffle a sequence.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Population of the initial solution as real-value permutations</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Population of the initial solution as binary permutations with the number of bits in the binary string and the number of ones in each binary string</p>

  <p class="body">You can also generate a random route between two points using the following code:</p>
  <pre class="programlisting">import osmnx as ox
import random
from collections import deque
from optalgotools.structures import Node
  
G = ox.graph_from_place("University of Toronto")
fig, ax = ox.plot_graph(G)
  
def randomized_search(G, source, destination):                  <span class="fm-combinumeral">①</span>
    origin = Node(graph = G, osmid = source)
    destination = Node(graph = G, osmid = destination)
    
    route = [] 
    frontier = deque([origin])
    explored = set()
    while frontier:
        node = random.choice(frontier)                          <span class="fm-combinumeral">②</span>
        frontier.remove(node)
        explored.add(node.osmid)
  
        for child in node.expand():
            if child not in explored and child not in frontier:
                if child == destination:
                    route = child.path()
                    return route
                frontier.append(child)
  
    raise Exception("destination and source are not on same component")
  
random_route = randomized_search(G, 24959528, 1480794706)       <span class="fm-combinumeral">③</span>
  
fig, ax = ox.plot_graph_route(G, random_route)                  <span class="fm-combinumeral">④</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> This is a typical graph search with a shuffled frontier.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> This is the randomization part.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Generate random routes between two nodes.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Visualize the random routes.</p>

  <p class="body">The preceding code modifies a typical graph search algorithm by scrambling the frontier nodes. This means that candidates for expansion are “random,” which means different routes are yielded when it’s called repeatedly. Some generated random routes are shown in figure 7.3.<a id="marker-240"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F03_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.3 Generating random initial routes</p>
  </div>

  <p class="body">In the next section, I’ll introduce evolutionary computation as population-based metaheuristics. <a id="idIndexMarker027"/><a id="idIndexMarker028"/></p>

  <h2 class="fm-head" id="heading_id_4">7.2 Introducing evolutionary computation</h2>

  <p class="body">Evolution can be considered an optimization process in the sense that it involves the gradual improvement of the characteristics of living organisms over time, resulting in adaptation to dynamically changing and competitive environments and an enhanced ability to survive in these environments. In this section, I’ll provide an overview of the fundamental concepts of biological evolution. Understanding these principles is important for gaining insight into evolutionary computation. <a id="idIndexMarker029"/><a id="idIndexMarker030"/></p>

  <h3 class="fm-head1" id="heading_id_5">7.2.1 A brief recap of biology fundamentals</h3>

  <p class="body"><a id="marker-241"/>The <i class="fm-italics">nucleus</i> is the central part of any living cell that contains the genetic information. This genetic information is stored in the <i class="fm-italics">chromosomes</i>, each of which is built of deoxyribonucleic acid (DNA), which carries the genetic information used in the growth, development, functioning, and reproduction of all living organisms. Humans have a total of 23 pairs of chromosomes, or 46 chromosomes in total, in each of their cells. Each chromosome is made up of many different sections called <i class="fm-italics">genes</i>, which are responsible for coding specific properties of an individual. The variant form of a gene that determines these properties, found at a specific location on a chromosome, is called an allele. Every gene has a unique position on the chromosome called a <i class="fm-italics">locus</i>. The entire combination of genes is called a <i class="fm-italics">genotype</i>, and it’s the genotype that provides the genetic blueprint for an organism, determining the potential for an individual’s traits and characteristics. The term <i class="fm-italics">phenotype</i> refers to the observable physical, behavioral, and physiological characteristics of an organism, which result from the interaction between its genotype and the environment. <a id="idIndexMarker031"/><a id="idIndexMarker032"/><a id="idIndexMarker033"/><a id="idIndexMarker034"/><a id="idIndexMarker035"/><a id="idIndexMarker036"/><a id="idIndexMarker037"/><a id="idIndexMarker038"/><a id="idIndexMarker039"/><a id="idIndexMarker040"/></p>

  <p class="body">To illustrate the concept of genes and their role in determining the characteristics of a living organism, let’s consider an example where a DNA molecule consists of four genes that are responsible for different traits: appetite, movement, feet, and skin type. The appetite gene may have different values that reflect the diet of the organism, such as herbivore (H), carnivore (C), or insectivore (I). The movement gene may determine the organism’s mode of movement, such as climbing (CL), flying (FL), running (R), or swimming (SW). The feet gene may determine the type of feet or limbs that the organism has, such as claws (CLW), flippers (FLP), hooves (HV), or wings (WNG). Finally, the skin gene may determine the skin covering of the organism, such as fur (F), scales (S), or feathers (FTH), as illustrated in figure 7.4.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F04_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.4 Genotype, phenotype, and taxonomic classification</p>
  </div>

  <p class="body">In this example, the <i class="fm-italics">genotype</i> refers to the specific genetic makeup of an organism, which is determined by the specific combination of alleles that an individual inherits from its parents. The specific values of these genes will determine the <i class="fm-italics">phenotype</i>, or observable characteristics, of the organism. For example, an organism with an insectivore appetite gene, a flying movement gene, a wings feet gene, and a feather skin gene would likely be a bird. On the other hand, an organism with an herbivorous appetite gene, a running movement gene, a hooves feet gene, and a fur skin gene would likely be a mammal, such as a white-tailed deer.</p>

  <p class="body">The class to which an organism belongs, such as the species, genus, or family, is determined by its taxonomic classification based on shared characteristics with other organisms.<a id="marker-242"/></p>

  <h3 class="fm-head1" id="heading_id_6">7.2.2 The theory of evolution</h3>

  <p class="body">The theory of evolution explains how species of living organisms have changed over time and diversified into the forms we see today. This theory, developed by Charles Darwin, offers an explanation of biological diversity and its underlying mechanisms. <a id="idIndexMarker041"/><a id="idIndexMarker042"/></p>

  <p class="body">According to the theory, <i class="fm-italics">natural selection</i> is a major mechanism that drives evolution. Over the course of numerous generations, adaptations arise from the cumulative effects of successive, minor, stochastic alterations in traits, and natural selection favors those variants that are best suited to their environment. This phenomenon is known as survival of the fittest: selected individuals reproduce, passing their properties to their offspring. Other individuals die without mating, and their properties are thus discarded. Over time, natural selection plays a significant role in shaping the characteristics and adaptations of populations, promoting the transmission of advantageous traits and eliminating less beneficial ones.<a id="idIndexMarker043"/><a id="idIndexMarker044"/></p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">The theory of evolution</p>

    <p class="fm-sidebar-text">The theory of evolution by natural selection can be summarized as follows:</p>

    <ul class="calibre5">
      <li class="fm-list-bullet2">
        <p class="list-s">In a world with limited resources and stable populations, each individual competes with others for survival.</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">Those individuals with the “best” characteristics (traits) are more likely to survive and to reproduce, and those characteristics will be passed on to their offspring.</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">These desirable characteristics are inherited by subsequent generations, and (over time) become dominant among the population.</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">During production of a child organism, random events cause random changes to the child organism’s characteristics.</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">If these new characteristics are a benefit to the organism, the chances of survival for that organism are increased.</p>
      </li>
    </ul>
  </div>

  <p class="body">Evolutionary computation techniques mimic biological evolution and process a sequence of operations, such as creating an initial population (a collection of chromosomes), evaluating the population, and then evolving the population through multiple generations.</p>

  <h3 class="fm-head1" id="heading_id_7">7.2.3 Evolutionary computation</h3>

  <p class="body"><a id="marker-243"/><i class="fm-italics">Computational intelligence</i> (CI) is a subfield of artificial intelligence (AI) that emphasizes the design, application, and development of algorithms that can learn and adapt to solve complex problems. It focuses on soft computing methods such as fuzzy logic, neural networks, evolutionary computation, and swarm intelligence. <i class="fm-italics">Evolutionary computation</i> (EC), as a branch of CI, employs various computational methods inspired by biological evolution. These methods have computational mechanisms of natural selection, survival of the fittest, and reproduction as the core elements of their computational systems.<a id="idIndexMarker045"/><a id="idIndexMarker046"/><a id="idIndexMarker047"/><a id="idIndexMarker048"/><a id="idIndexMarker049"/><a id="idIndexMarker050"/><a id="idIndexMarker051"/></p>

  <p class="body">Generally speaking, EC algorithms consist of the following main components:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Population of individuals</i>—This is a set of candidate solutions that are initially generated randomly or by some heuristic methods and are then improved over time. The population size is usually large in order to explore a wide range of possible solutions to the problem. However, the optimal population size depends on various factors, such as the complexity of the problem, the number of variables in the problem, the required accuracy of the solution, and the computational resources available. In practice, the optimal population size is often determined through experimentation, with the performance of the algorithm being evaluated for different population sizes and the best performing size being selected.<a id="idIndexMarker052"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Fitness function</i>—This function evaluates the quality of candidate solutions. It determines how well each solution solves the given problem by assigning a fitness value to each individual in the population. The higher the fitness value, the better the solution.<a id="idIndexMarker053"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Parent selection method</i>—This method is used to select the most promising individuals from the population in order to create new offspring for the next generation.<a id="idIndexMarker054"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Genetic operators</i>—These operators include <i class="fm-italics">crossover</i> and <i class="fm-italics">mutation</i>, and they are used to create new offspring from selected parents. The crossover operator exchanges genetic material between two selected individuals to create new offspring with a combination of traits from both parents. The mutation operator introduces random changes to the offspring’s genetic makeup to add diversity to the population and prevent stagnation.<a id="idIndexMarker055"/><a id="idIndexMarker056"/><a id="idIndexMarker057"/><a id="marker-244"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Survival methods</i>—These methods determine which individuals in a population will survive to the next generation. <a id="idIndexMarker058"/></p>
    </li>
  </ul>

  <p class="body">Together, these five components form the basis of EC algorithms, which can effectively solve various optimization problems. As illustrated in figure 7.5, there are several EC paradigms.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F05_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.5 EC paradigms</p>
  </div>

  <p class="body">These paradigms mainly vary in their approaches to representing individuals, parents, survival selection methods, and genetic operators:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Genetic algorithm (GA)</i>—This search algorithm mimics natural evolution, where each individual is a candidate solution encoded as a binary, real-valued, or permutation vector. We will discuss genetic algorithms in detail in this part of the book.<a id="idIndexMarker059"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Differential evolution (DE)</i>—This algorithm uses real-valued vectors as individuals and generates new solutions by adding weighted differences between pairs of existing solutions. It is similar to GA, differing in the reproduction mechanism used.<a id="idIndexMarker060"/><a id="marker-245"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Genetic programming (GP)</i>—This is a special case of GA, where each individual is a computer program encoded as a variable-length tree. This tree structure is used to represent functions and operators, such as <code class="fm-code-in-text">if</code>-<code class="fm-code-in-text">else</code> statements and mathematical operations. <a id="idIndexMarker061"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Evolutionary programming (EP)</i>—This is similar to GP, but it focuses on evolving behavioral traits rather than program structure. It is an open framework where any representation and mutation operation can be applied, but there is no recombination.<a id="idIndexMarker062"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Evolutionary strategies (ES)</i>—This algorithm uses real-valued vectors as individuals and adapts mutation and recombination parameters during evolution. Plus-selection, comma-selection, greedy selection, and distance-based selection are used as selection methods.<a id="idIndexMarker063"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Cultural algorithm (CA)</i>—This approach incorporates social learning from a shared belief space into the traditional population-based evolution process. CA models the evolution of a population’s culture and how it influences the genetic and phenotypic evolution of individuals.<a id="idIndexMarker064"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Co-evolution (CoE)</i>—This is based on the reciprocal evolutionary change that occurs between interacting populations, where each represents a given species, together optimizing coupled objectives.<a id="idIndexMarker065"/></p>
    </li>
  </ul>

  <p class="body">EC is a powerful approach to optimization that has several advantages, as well as a few drawbacks. The advantages include the following:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">EC algorithms do not make any presumptions about the problem space, making them applicable to a wide range of problems.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">They are widely applicable across different domains and can be used to solve continuous and discrete problems in various fields.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The solutions produced by EC algorithms are more interpretable than those of neural networks or other black-box optimization techniques. This is mainly because EC algorithms use a more transparent process of selection, mutation, and recombination that can be tracked and understood step by step, whereas neural networks are often considered “black boxes” due to their complex, layered structures and nonlinear operations.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">EC algorithms provide multiple alternative solutions, which can be useful in cases where there is no single best solution.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">EC algorithms exhibit inherent parallelism, making them well-suited for simple parallel implementations on modern hardware.</p>
    </li>
  </ul>

  <p class="body">The disadvantages of EC include the following:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">EC algorithms can be computationally expensive, meaning that they may be slow to converge or require a significant amount of computational resources to run.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">While EC algorithms, like many metaheuristic algorithms, cannot guarantee finding an optimal solution, they often converge to a near-optimal solution within a finite time frame.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">EC algorithms often require parameter tuning to achieve good performance, which can be time-consuming and challenging.</p>
    </li>
  </ul>

  <p class="body">This chapter primarily focuses on genetic algorithms. The following section will look at the various components of genetic algorithms.<a id="idIndexMarker066"/><a id="idIndexMarker067"/><a id="idIndexMarker068"/><a id="idIndexMarker069"/></p>

  <h2 class="fm-head" id="heading_id_8">7.3 Genetic algorithm building blocks</h2>

  <p class="body"><a id="marker-246"/>Genetic algorithms are the most widely used form of EC. They are adaptive heuristic search algorithms that are designed to simulate processes in natural systems necessary for evolution, as proposed by Charles Darwin in his theory of evolution. These algorithms represent an intelligent exploitation of a random search within a defined search space.<a id="idIndexMarker070"/></p>

  <p class="body">The first genetic algorithm, named simple genetic algorithm (SGA) and also known as the classical or canonical GA, was developed by John Holland in 1975. Through his research, Holland provided insights into the design of artificial systems that are robust, adaptive, and capable of evolving to meet new challenges. By studying the processes of natural systems, he sought to create algorithms and computational models that could solve complex problems much like natural systems can. Holland defined GA as a computer program that evolves in ways that resemble natural selection and that can solve complex problems that even their creators do not fully understand. GA is based on the principles of evolution via natural selection, employing a population of individuals that undergo selection in the presence of variation-inducing operators such as mutation and crossover (recombination). A fitness function is used to evaluate individuals, and their reproductive success varies with their fitness. Figure 7.6 shows an analogy between GA and natural evolution.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F06_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.6 GA versus natural evolution</p>
  </div>

  <p class="body">GA starts by initializing a population of individuals or candidate solutions. The fitness of all the individuals in the population is evaluated based on a defined fitness function, and then a new population is created by performing crossover and mutation, which generate children or new solutions. In constrained optimization problems, a feasibility check and repair should be applied after the offspring are produced.<a id="marker-247"/></p>

  <p class="body">The population keeps evolving until certain stopping criteria are met, as illustrated in figure 7.7. These termination criteria could be</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">A specified number of generations or fitness evaluations (100 or 150 generations)</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">An adequate solution that reaches a minimum threshold</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">When there is no improvement in the best individual for a specified number of generations</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">When memory or time constraints are reached</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Any combination of the preceding points</p>
    </li>
  </ul>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F07_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.7 GA steps</p>
  </div>

  <p class="body"><a id="marker-248"/>Algorithm 7.1 summarizes the main steps of genetic algorithms.</p>

  <p class="fm-code-listing-caption">Algorithm 7.1 Genetic algorithm</p>
  <pre class="programlisting">Initialization: Randomly generate an initial population M(0)
  
Evaluate all individuals: Compute and save the fitness f(m) for each individual in the current population M(t)
  
While termination criteria are not met
    Select parents: Define selection probabilities p(m)for each individual p in M(t)
    Apply crossover: Generate M(t+1) by probabilistically selecting individuals from M(t) to produce offspring via genetic operators
    Apply mutation: Introduce random changes to individuals
    Evaluate: evaluate the fitness of the new individuals
    Select survivors: select individuals to form the next generation</pre>

  <p class="body">The concept of GA is straightforward and easy to understand, as it emulates the process of natural evolution. It is a modular algorithm that can operate in parallel and can be easily distributed. GA is versatile and can handle multi-objective optimization problems effectively. It is particularly effective in noisy environments. GA is widely employed for tackling complex continuous and discrete optimization problems, and it excels in scenarios featuring numerous combinatorial parameters and nonlinear interdependencies among variables. Notably, as of the publication of this book in 2024, a search for “genetic algorithm” as a composite keyword returns approximately 100,000 results on Google Patent Search, while Google Scholar presents a staggering 1,940,000 results. This volume reflects the substantial interest in and diverse applications of genetic algorithms across academic and industrial domains.</p>

  <h3 class="fm-head1" id="heading_id_9">7.3.1 Fitness function</h3>

  <p class="body">As mentioned earlier, GA mimics nature’s survival-of-the-fittest principle in a search process. Therefore, genetic algorithms are naturally suitable for solving maximization problems. However, various mathematical transformations can be used to convert minimization problems into maximization problems, such as these:<a id="idIndexMarker071"/><a id="idIndexMarker072"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Negation transformation</i>—The simplest transformation is to negate the objective function. For example, maximizing a fitness function <span class="times"><i class="fm-italics">f</i>(<i class="fm-italics">x</i>) = –<i class="fm-italics">O</i>(<i class="fm-italics">x</i>)</span> is the same as minimizing the original objective function <span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">x</i>)</span>. <a id="idIndexMarker073"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Reciprocal transformation</i>—Another way to convert a minimization problem into a maximization problem is to take the reciprocal of the objective function. This works only if the objective function is always non-negative. Equation 7.1 shows an example:<a id="idIndexMarker074"/></p>
    </li>
  </ul>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH07_F07_Khamis-EQ01.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">7.1</p>
        </td>
      </tr>
    </tbody>
  </table>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Other mathematical transformations</i>—Equation 7.2 shows another transformation that converts an objective function in a minimization problem <span class="times"><i class="fm-italics">O</i>(<i class="fm-italics">x</i>)</span> into a fitness function in a maximization problem <span class="times"><i class="fm-italics">f</i>(<i class="fm-italics">x</i>)</span>. In this equation, <i class="fm-italics">O<sub class="fm-subscript">i</sub></i> is the objective function value of individual <i class="timesitalic">i</i>, <i class="timesitalic">N</i> is the population size, and <i class="timesitalic">V</i> is a large value to ensure non-negative fitness values. The value of <i class="timesitalic">V</i> can be the maximum value of the second term of the equation, so that the fitness value corresponding to the maximum value of the objective function is zero:</p>
    </li>
  </ul>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH07_F07_Khamis-EQ02.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">7.2</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body"><a id="marker-249"/>According to the duality principal introduced in section 1.3.2, these transformations do not alter the location of the minima but convert a minimization problem to an equivalent maximization problem.</p>

  <h3 class="fm-head1" id="heading_id_10">7.3.2 Representation schemes</h3>

  <p class="body">An <i class="fm-italics">encoding</i> is a data structure for representing candidate solutions, and a good encoding is probably the most important factor for the performance of GA. In GA, the parameters of a candidate solution (the genes) are concatenated to form a string (a chromosome). Binary encoding, real-value encoding, and permutation encoding can be used to encode the solution. Binary encoding is used in binary-coded GA (BGA) where the solution is represented as a binary string, as illustrated in figure 7.8.<a id="idIndexMarker075"/><a id="idIndexMarker076"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F08_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.8 Binary encoding</p>
  </div>

  <p class="body">Let’s look again at the ticket pricing example introduced in section 1.3.1, where an event organizer is planning a conference and wants to determine the optimal ticket price to maximize the profit. The expected profit is given by the following equation:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH07_F08_Khamis-EQ03.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">7.3</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">where <i class="timesitalic">x</i> is the ticket price. The binary genetic algorithm (BGA) can be used to find the optimal ticket price to maximize the profit, subject to the boundary constraint 75.0 <span class="cambria">≤</span> <i class="timesitalic">x</i> <span class="cambria">≤</span> 235.0, which will make sure that profit is positive. BGA features a simple binary encoding. The boundary constraint on the preceding function requires us to use an 8-bit binary encoding, as explained in the following sidebar. Hence, the chromosomes are represented by bit strings of length 8.<a id="idIndexMarker077"/><a id="marker-250"/></p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">Calculating the minimum number of bits for a solution</p>

    <p class="fm-sidebar-text">To calculate the number of bits required to represent a range between the lower bound (LB) and upper bound (UB) with a desired precision <i class="fm-italics">p</i>, follow these steps:<a id="idIndexMarker078"/><a id="idIndexMarker079"/></p>

    <ol class="calibre7">
      <li class="fm-list-bullet2">
        <p class="list-s">Calculate the range size: <span class="times"><i class="fm-italics">R</i> = (<i class="fm-italics">UB</i> – <i class="fm-italics">LB</i>)</span>.</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">Divide the range size by the desired precision: <span class="times"><i class="fm-italics">R</i> / <i class="fm-italics">P.</i></span></p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">Round up to the nearest whole number: <span class="times"><i class="fm-italics">number_of_steps</i> = ceil(<i class="fm-italics">R</i> / <i class="fm-italics">P</i>)</span>, where ceil is the ceiling function that rounds up to the nearest integer.</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">Calculate the number of bits: <span class="times"><i class="fm-italics">number_of_bits</i> = ceil(log<sub class="fm-subscript">2</sub>(<i class="fm-italics">number_of_steps</i>))</span>, where <span class="times">log<sub class="fm-subscript">2</sub></span> is the logarithm to the base 2.</p>
      </li>
    </ol>

    <p class="fm-sidebar-text">Let’s calculate the number of bits we’ll need for the ticket pricing problem: <span class="times">75.0 <span class="cambria">≤</span> <i class="timesitalic">x</i> <span class="cambria">≤</span> 235.0</span>, assuming a precision of 0.1:</p>

    <ol class="calibre7">
      <li class="fm-list-bullet2">
        <p class="list-s">Calculate the range size: <span class="times">(235.0 – 75.0) = 160</span></p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">Divide the range size by the desired precision: <span class="times">160 / 0.1 = 1600</span></p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">Round up to the nearest whole number: <span class="times">1600</span>. Now you have <span class="times">1600 steps (values) to represent the numbers from 75.0 to 235.0 with a precision of 0.1</span>.</p>
      </li>

      <li class="fm-list-bullet2">
        <p class="list-s">To find the minimum number of bits required, you can use the formula <span class="times"><i class="fm-italics">number_of_bits</i> = ceil(log<sub class="fm-subscript">2</sub>(<i class="fm-italics">number_of_steps</i>))</span>:<br class="calibre10"/>
            <span class="times"><i class="fm-italics">number_of_bits</i> = ceil(log<sub class="fm-subscript">2</sub>(1600)) ≈ ceil(10.64) = 11</span></p>
      </li>
    </ol>

    <p class="fm-sidebar-text">So you’ll need 11 bits to represent the numbers from 75.0 to 235.0 with a precision of 0.1. If you want to consider integer values only (i.e., a precision of 1), you would need <span class="times">ceil(logs(160)) = ceil(7.32) = 8 bits</span>.</p>
  </div>

  <p class="body">As mentioned previously, GA starts with an initial population of candidate solutions. Population size has to be carefully selected, as very big population size usually does not improve performance of GA. Some research also shows that the best population size depends on the size of encoded string (chromosomes). It means that if you have chromosomes with 32 bits, the population should be higher than for chromosomes with 16 bits.</p>

  <p class="body">In the ticket pricing problem, assume that we start with a population of size 5. Table 7.2 shows examples of random solutions that can be generated to form the initial population.</p>

  <p class="fm-table-caption">Table 7.2 Initial population</p>

  <table border="1" class="contenttable-1-table" id="table002" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
      <col class="contenttable-0-col" span="1" width="25%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Candidate solutions <i class="timesitalic">x</i></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Values of <i class="timesitalic">x</i> in the solution space</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Candidate solutions in the binary coding space</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Objective function <span class="times"><i class="fm-italics">f</i>(<i class="fm-italics">x</i>)</span></p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">1</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">77</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">01001101</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">8,820</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">2</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">203</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">11001011</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">84,420</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">3</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">01101110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">90,000</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">4</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">145</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">10010001</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">128,500</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">5</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">230</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">11100110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">18,000</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">Once we have an initial population, we can proceed to select the parents that will be subjected to genetic operators (crossover and mutation). We’ll look at the selection operators next.<a id="idIndexMarker080"/><a id="idIndexMarker081"/><a id="marker-251"/></p>

  <h3 class="fm-head1" id="heading_id_11">7.3.3 Selection operators</h3>

  <p class="body">There are different methods (operators) for parent selection, and they have different levels of selective pressure. <i class="fm-italics">Selective pressure</i> refers to the probability of the best individual being selected compared to the average probability of selection for all individuals. When using an operator with a high selective pressure in a genetic algorithm, the diversity within the population decreases at a faster rate than it would using operators with a lower selective pressure. This may sound good, but it can result in the population converging prematurely towards suboptimal solutions, thus limiting the exploration abilities of the population and eliminating individuals that do not fit the specific criteria determined by the selective pressure. This can lead to a lack of diversity in the population, which reduces the chances of finding better solutions. <a id="idIndexMarker082"/><a id="idIndexMarker083"/></p>

  <p class="body">It is important to balance selective pressure with the exploration capabilities of the population to avoid premature convergence and to encourage the discovery of a diverse range of optimal solutions. Figure 7.9 illustrates some selection methods.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F09_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.9 Selection methods with their selective pressure</p>
  </div>

  <p class="fm-head2">Elitism</p>

  <p class="body"><a id="marker-252"/><i class="fm-italics">Elitism</i> in genetic algorithms involves selecting the fittest individuals for crossover and mutation and preserving the top-performing individuals of the current population to propagate into the next generation. The greater the number of individuals that are preserved, the lower the diversity of the succeeding population. This selection method has the highest selective pressure, as illustrated in figure 7.9. <a id="idIndexMarker084"/><a id="idIndexMarker085"/><a id="idIndexMarker086"/></p>

  <p class="body">In the ticket pricing example, the best solutions (<i class="timesitalic">x<sub class="fm-subscript">4</sub></i> and <i class="timesitalic">x<sub class="fm-subscript">3</sub></i>) will be selected parents to generate offspring, as shown in table 7.3.</p>

  <p class="fm-table-caption">Table 7.3 Solution ranking</p>

  <table border="1" class="contenttable-1-table" id="table003" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="20%"/>
      <col class="contenttable-0-col" span="1" width="20%"/>
      <col class="contenttable-0-col" span="1" width="20%"/>
      <col class="contenttable-0-col" span="1" width="20%"/>
      <col class="contenttable-0-col" span="1" width="20%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Candidate solutions <i class="timesitalic">x</i></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Values of <i class="timesitalic">x</i> in the solution space</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Candidate solutions in the binary coding space</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Objective function <span class="times"><i class="fm-italics">f</i>(<i class="fm-italics">x</i>)</span></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Ranking</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">1</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">77</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">01001101</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">8,820</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">5</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">2</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">203</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">11001011</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">84,420</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">3</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">3</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body1">110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body1">01101110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body1">90,000</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><b class="fm-bold">2</b> <b class="fm-bold">(second-best individual)</b></p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">4</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body1">145</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body1">10010001</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><b class="fm-bold">128</b>,<b class="fm-bold">500</b></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body"><b class="fm-bold">1</b> <b class="fm-bold">(best individual)</b></p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">5</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">230</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">11100110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">18,000</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">4</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="fm-head2">Fitness-proportionate selection</p>

  <p class="body"><i class="fm-italics">Fitness-proportionate selection</i> (FPS) is a selection method that favors the selection of the fittest individuals in a population. This method creates a probability distribution where the probability of an individual being selected is directly proportional to its fitness value. Individuals are chosen from this distribution by sampling it randomly. The individual fitness assignment relative to the whole population can be calculated as follows<a id="idIndexMarker087"/><a id="idIndexMarker088"/><a id="idIndexMarker089"/><a id="idIndexMarker090"/>:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH07_F09_Khamis-EQ04.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">7.4</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">where <i class="timesitalic">f</i> is the solution represented by an individual chromosome and N is the population size. Roulette wheel selection is an example of an FPS operator.</p>

  <p class="body">In our ticket pricing example, the roulette wheel can be constructed by implementing the following steps:</p>

  <p class="body-dialog">  1.  Calculate the total fitness for the population: <span class="times"><i class="fm-italics">F</i> = 8,820 + 84,420 + 90,000 + 128,500 + 18,000 = 329,740</span>.</p>

  <p class="body-dialog">  2.  Calculate the selection probability <i class="timesitalic">p<sub class="fm-subscript">k</sub></i> for each chromosome <i class="timesitalic">x<sub class="fm-subscript">k</sub></i> where <span class="times"><i class="fm-italics">p<sub class="fm-subscript">k</sub></i> = <i class="fm-italics">f</i>(<i class="fm-italics">x<sub class="fm-subscript">k</sub></i>) / <i class="fm-italics">F</i></span>. Table 7.4 shows the calculated selection probabilities. <a id="idIndexMarker091"/><a id="marker-253"/></p>

  <p class="fm-table-caption">Table 7.4 Selection probabilities</p>

  <table border="1" class="contenttable-1-table" id="table004" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="20%"/>
      <col class="contenttable-0-col" span="1" width="20%"/>
      <col class="contenttable-0-col" span="1" width="20%"/>
      <col class="contenttable-0-col" span="1" width="20%"/>
      <col class="contenttable-0-col" span="1" width="20%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Candidate solutions <i class="timesitalic">x</i></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Values of <i class="timesitalic">x</i> in the solution space</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Candidate solutions in the binary coding space</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Objective function <span class="times"><i class="fm-italics">f</i>(<i class="fm-italics">x</i>)</span></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Selection probability <i class="timesitalic">p<sub class="fm-subscript">k</sub></i></p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">1</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">77</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">01001101</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">8,820</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.03</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">2</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">203</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">11001011</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">84,420</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.26</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">3</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">01101110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">90,000</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.27</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">4</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">145</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">10010001</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">128,500</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.39</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">5</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">230</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">11100110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">18,000</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.05</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body-dialog">  3.  Calculate the cumulative probability <i class="timesitalic">q<sub class="fm-subscript">k</sub></i> for each chromosome <i class="timesitalic">x<sub class="fm-subscript">k</sub></i> where <span class="times"><i class="fm-italics">q<sub class="fm-subscript">k</sub></i> = sum(<i class="fm-italics">p<sub class="fm-subscript">j</sub></i>), <i class="timesitalic">j</i></span> <i class="timesitalic">= {1,k}</i>. Table 7.5 shows the calculated cumulative probabilities.<a id="idIndexMarker092"/></p>

  <p class="fm-table-caption">Table 7.5 Cumulative probabilities</p>

  <table border="1" class="contenttable-1-table" id="table005" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Candidate solutions <i class="timesitalic">x</i></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Values of <i class="timesitalic">x</i> in the solution space</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Candidate solutions in the binary coding space</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Objective function <span class="times"><i class="fm-italics">f</i>(<i class="fm-italics">x</i>)</span></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Selection probability <i class="timesitalic">p<sub class="fm-subscript">k</sub></i></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Cumulative probability <i class="timesitalic">q<sub class="fm-subscript">k</sub></i></p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">1</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">77</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">01001101</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">8,820</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.03</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.03</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">2</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">203</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">11001011</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">84,420</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.26</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.28</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">3</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">01101110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">90,000</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.27</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.56</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">4</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">145</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">10010001</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">128,500</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.39</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.95</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">5</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">230</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">11100110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">18,000</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.05</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1.00</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body-dialog">  4.  Generate a random number <i class="timesitalic">r</i> from the range [0,1].</p>

  <p class="body-dialog">  5.  If <span class="times"><i class="fm-italics">q</i><sub class="fm-subscript">1</sub> &gt;= <i class="fm-italics">r</i></span>, then select the first chromosome <span class="times"><i class="timesitalic">x</i><sub class="fm-subscript">1</sub></span>; otherwise, select the <i class="timesitalic">k<sup class="fm-superscript">th</sup></i> chromosome <span class="times"><i class="fm-italics">x<sub class="fm-subscript">k</sub></i> (2 ≤ k ≤ <i class="fm-italics">N</i>)</span> such that <span class="times"><i class="fm-italics">q<sub class="fm-subscript">k</sub></i><sub class="fm-subscript">-1</sub> &lt; <i class="fm-italics">r</i> ≤ <i class="fm-italics">q<sub class="fm-subscript">k</sub></i></span>. If we assume that the randomly generated number <span class="times"><i class="fm-italics">r</i> = 0.25</span>, then <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">2</sub></span> with <span class="times"><i class="fm-italics">q</i><sub class="fm-subscript">2</sub> = 0.28</span> is selected because <span class="times"><i class="fm-italics">q</i><sub class="fm-subscript">2</sub> &gt; 0.25</span>, and if <span class="times"><i class="fm-italics">r</i> = 0.58</span>, <span class="times"><i class="fm-italics">x</i><sub class="fm-subscript">4</sub></span> will be selected because <span class="times"><i class="fm-italics">q<sub class="fm-subscript">4</sub></i> &gt; 0.58</span>. Figure 7.10 illustrates the roulette wheel for the ticket pricing example.<a id="marker-254"/></p>

  <div class="figure">
    <p class="figured"><img alt="" class="calibre4" src="../Images/CH07_F10_Khamis.png"/></p>

    <p class="figurecaptiond">Figure 7.10 Roulette wheel for the ticket pricing example</p>
  </div>

  <p class="body">As you can see, the fittest individual occupies the largest segment of the roulette wheel, and the weakest individual occupies the smallest segment of the wheel. Due to the direct correlation between fitness and selection in proportional selection, there is a potential for dominant individuals to disproportionately contribute to the next generation’s offspring, leading to a reduction in the diversity of the population. This implies that proportional selection results in a high selective pressure.</p>

  <p class="fm-head2">Rank-based selection</p>

  <p class="body">One way to address the limitations of FPS in genetic algorithms is to use relative fitness instead of absolute fitness to determine selection probabilities—individuals are selected based on their fitness relative to the fitness of other individuals in the population. This approach ensures that the selection process is not dominated by the best individual in the population. <a id="idIndexMarker093"/><a id="idIndexMarker094"/><a id="idIndexMarker095"/></p>

  <p class="body">Linear ranking and nonlinear ranking can be used. In <i class="fm-italics">linear ranking</i>, the rank-based probability of an individual <i class="timesitalic">i</i> being selected is calculated using the following equation:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH07_F10_Khamis-EQ05.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">7.5</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">where <i class="timesitalic">N</i> is the size of the population, <i class="timesitalic">SP</i> is the selection pressure <span class="times">(1.0 &lt; <i class="fm-italics">SP</i> ≤ 2.0)</span>, and <span class="times"><i class="fm-italics">r</i>(<i class="fm-italics">i</i>)</span> is the rank associated with individual <i class="timesitalic">i</i> (a higher rank is better). In the ticket pricing example, where <span class="times"><i class="fm-italics">N</i> = 5</span>, and assuming that <span class="times"><i class="fm-italics">SP</i> = 1.5</span>, the rank-based selection probability of each individual in the population is shown in table 7.6.</p>

  <p class="fm-table-caption">Table 7.6 Rank-based selection probabilities</p>

  <table border="1" class="contenttable-1-table" id="table006" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="14.29%"/>
      <col class="contenttable-0-col" span="1" width="14.29%"/>
      <col class="contenttable-0-col" span="1" width="14.29%"/>
      <col class="contenttable-0-col" span="1" width="14.29%"/>
      <col class="contenttable-0-col" span="1" width="14.29%"/>
      <col class="contenttable-0-col" span="1" width="14.29%"/>
      <col class="contenttable-0-col" span="1" width="14.29%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Candidate solutions <i class="timesitalic">x</i></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Values of <i class="timesitalic">x</i> in the solution space</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Candidate solutions in the binary coding space</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Objective function <span class="times"><i class="fm-italics">f</i>(<i class="fm-italics">x</i>)</span></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Rank <i class="timesitalic">r<sub class="fm-subscript">i</sub></i></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">FPS cumulative probability <i class="timesitalic">q<sub class="fm-subscript">k</sub></i></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Rank-based selection probability</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">1</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">77</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">01001101</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">8,820</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.03</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.50</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">2</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">203</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">11001011</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">84,420</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">3</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.28</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.75</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">3</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">01101110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">90,000</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">4</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.56</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.88</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">4</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">145</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">10010001</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">128,500</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">5</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.95</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1.00</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body"><span class="times">x<sub class="fm-subscript">5</sub></span></p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">230</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">11100110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">18,000</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">2</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1.00</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">0.63</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body"><a id="marker-255"/>As you can see, rank-based selection reduces the bias of FPS by assigning greater probabilities of selection to less-fit individuals.</p>

  <p class="body"><i class="fm-italics">Nonlinear ranking</i> permits higher selective pressures than linear ranking does. The selection probability is calculated using the following equation:</p>

  <table border="0" class="contenttable-0-table" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="90%"/>
      <col class="contenttable-0-col" span="1" width="10%"/>
    </colgroup>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-0-td">
          <div class="figure2">
            <p class="figured"><img alt="" class="calibre4" src="../Images/CH07_F10_Khamis-EQ06.png"/></p>
          </div>
        </td>

        <td class="contenttable-0-td">
          <p class="fm-equation-caption">7.6</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">where <i class="timesitalic">X</i> is computed as the root of the polynomial <span class="times">(SP–N).X<i class="fm-italics"><sup class="fm-superscript">N–</sup></i><sup class="fm-superscript">1</sup>)+SP.X<i class="fm-italics"><sup class="fm-superscript">N–</sup></i><sup class="fm-superscript">2</sup>+…+SP.X+SP=0</span>. This nonlinear ranking allows values of selective pressure in the interval <span class="times">[1, N – 2]</span>.</p>

  <p class="fm-head2">Stochastic universal sampling</p>

  <p class="body"><i class="fm-italics">Stochastic universal sampling</i> (SUS) is another approach to mitigating the potential bias in the roulette-wheel selection approach. This method involves placing an outer roulette wheel around the pie with <i class="timesitalic">m</i> evenly spaced pointers. With SUS, a single spin of the roulette wheel is used to simultaneously select all <i class="timesitalic">m</i> individuals for reproduction. Figure 7.11 shows SUS for the ticket pricing problem using four selection points.<a id="idIndexMarker096"/><a id="idIndexMarker097"/><a id="idIndexMarker098"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F11_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.11 Stochastic universal sampling (SUS) strategy</p>
  </div>

  <p class="fm-head2">Tournament selection</p>

  <p class="body"><i class="fm-italics">Tournament selection</i> involves randomly selecting a group of <i class="timesitalic">k</i> individuals from the current population, where <i class="timesitalic">k</i> is the size of the tournament group. Once the group is formed, a tournament is held among its members to identify the best-performing individual based on their fitness values. The individual with the highest fitness score is the winner and advances to the next stage of the genetic algorithm. Figure 7.12 shows the tournament selection process.<a id="idIndexMarker099"/><a id="idIndexMarker100"/><a id="idIndexMarker101"/><a id="marker-256"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F12_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.12 Tournament selection</p>
  </div>

  <p class="body">To select <i class="timesitalic">m</i> individuals for reproduction, the tournament procedure is carried out <i class="timesitalic">m</i> times. In each iteration, a new tournament group is randomly chosen from the population, and the individuals in the group compete against each other until the best-performing individual is identified. The winners from each tournament are then selected for reproduction, which involves applying genetic operators such as crossover and mutation to create new offspring.</p>

  <p class="fm-head2">Random selection</p>

  <p class="body"><i class="fm-italics">Random selection</i> is the simplest selection operator, where each individual has the same selection probability of <span class="times">1/<i class="fm-italics">N</i></span> (where <i class="timesitalic">N</i> is the population size). No fitness information is used, which means that the best and the worst individuals have exactly the same probability of being selected. Random selection has the lowest selective pressure among the selection operators, as all individuals within the population have the same chance of being selected.<a id="idIndexMarker102"/><a id="idIndexMarker103"/><a id="idIndexMarker104"/></p>

  <p class="fm-head2">Other selection methods</p>

  <p class="body">Other selection methods include, but are not limited to, Boltzmann Selection, <span class="times">(<i class="fm-italics">μ, λ</i>)-</span> and <span class="times">(<i class="timesitalic">μ</i> + <i class="fm-italics">λ</i>)-</span>selection, and hall of fame. The random selection and tournament selection methods are implemented as part of the <code class="fm-code-in-text">pymoo.operators.selection</code> class in pymoo. <a id="idIndexMarker105"/><a id="idIndexMarker106"/><a id="idIndexMarker107"/></p>

  <p class="body">After we select the parents, we need to produce offspring by applying reproduction operators.</p>

  <h3 class="fm-head1" id="heading_id_12">7.3.4 Reproduction operators</h3>

  <p class="body"><a id="marker-257"/>Genetic algorithms employ two primary genetic operators, namely crossover and mutation, to generate offspring. Let’s look at these two reproduction operators in detail. <a id="idIndexMarker108"/><a id="idIndexMarker109"/></p>

  <p class="fm-head2">Crossover</p>

  <p class="body"><i class="fm-italics">Crossover</i> is inspired by the biological process of recombination, where a portion of the genetic information is exchanged between two chromosomes. This exchange of genetic material results in the production of offspring, so two parents can thus give rise to two offspring. In order to ensure that the best individuals are able to contribute their genetic material, superior individuals are typically given more opportunities to reproduce through crossover. This mechanism promotes the effective combination of schemata, which are subsolutions located on different chromosomes. 1-point crossover, <i class="fm-italics">n</i>-point crossover, and uniform crossover are commonly used crossover methods. <a id="idIndexMarker110"/><a id="idIndexMarker111"/></p>

  <p class="body">In <i class="fm-italics">1-point crossover</i>, we start by choosing a random point on the two parents and splitting parents at this crossover point. Two children are then created by exchanging tails, as illustrated in figure 7.13. This crossover operation produces two new children (candidate solutions), which in the figure are 01010001 and 01001101 (or 81 and 77 in decimal, respectively) as potential ticket prices. These solutions result in total profits of $20,980 and $8,820 respectively, based on equation 7.3.<a id="idIndexMarker112"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F13_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.13 1-point crossover</p>
  </div>

  <p class="body">In <i class="fm-italics">n-point crossover</i>, which is a generalization of 1-point crossover, we choose <i class="timesitalic">n</i> random crossover points and split along those points. The children are generated by gluing parts together and alternating between parents, as illustrated in figure 7.14. Following the 2-point crossover illustrated in figure 7.14, two candidate solutions are generated, which are 141 and 81 with fitness values of $126,580 and $20,980 respectively.<a id="idIndexMarker113"/><a id="marker-258"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F14_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.14 <i class="fm-italics">n</i>-point crossover</p>
  </div>

  <p class="body">In <i class="fm-italics">uniform crossover</i>, random bit positions from two parents are swapped to create two offspring. One parent is assigned the label “heads” and the other “tails.” For the first child, a coin is flipped for each gene to determine whether it should come from the “heads” or “tails” parent. The second child is created by taking the inverse of each gene in the first child, as shown in figure 7.15. In this example, applying uniform crossover results in 217 and 5 with fitness values of $53,620 and $–319,500. As you can see, 5 is not a feasible solution because it is not within the boundary constraints of {75.0,235.0}. This solution is rejected.<a id="idIndexMarker114"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F15_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.15 Uniform crossover</p>
  </div>

  <p class="body">In pymoo, the repair operator can be used make sure the algorithm only searches in the feasible space. It is applied after the offspring have been produced.</p>

  <p class="fm-head2">Mutation</p>

  <p class="body"><i class="fm-italics">Mutation</i> is a process that introduces new genetic material into an individual, which helps to increase the diversity of the population. This diversity is important because it allows the population to explore a wider range of possible solutions to the problem at hand. Mutation is often used in combination with crossover to ensure that the full range of alleles is accessible for each gene. In the case of mutation, selection mechanisms could focus on “weak” individuals in the hope that mutation will introduce better traits to those individuals, increasing their chances of survival. <a id="idIndexMarker115"/><a id="idIndexMarker116"/><a id="idIndexMarker117"/><a id="marker-259"/></p>

  <p class="body">In binary genetic algorithms, mutation is performed by altering each gene independently with a probability <i class="timesitalic">p<sub class="fm-subscript">m</sub></i>. For each gene, we generate a random number <i class="timesitalic">r</i> between 0 and 1. If <span class="times"><i class="fm-italics">p<sub class="fm-subscript">m</sub></i> &gt; <i class="fm-italics">r</i></span>, we alter the gene. Figure 7.16 illustrates mutating one of the individuals of the ticket pricing problem.</p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F16_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.16 Mutation</p>
  </div>

  <p class="fm-head2">New population</p>

  <p class="body">After applying crossover and mutation, we will have new offspring that represent new candidate solutions. To start a new generation, we need to create a new population by selecting individuals from the old population and from the newly generated offspring. The size of the new population will remain the same as the old population. <a id="idIndexMarker118"/><a id="idIndexMarker119"/></p>

  <p class="body">Generational GA and steady-state GA are two models used in genetic algorithms. As shown in figure 7.17, in <i class="fm-italics">generational GA</i> models, the whole population is replaced by its offspring to start a “next generation.” In <i class="fm-italics">steady-state GA</i>, the number of generated offspring is less than the population size. Old individuals may be replaced by new ones. The process of selecting individuals for the new population is known as <i class="fm-italics">survivor selection</i>. We’ll look at survivor selection methods next.<a id="idIndexMarker120"/><a id="idIndexMarker121"/><a id="idIndexMarker122"/><a id="idIndexMarker123"/><a id="idIndexMarker124"/></p>

  <div class="figure">
    <p class="figure1"><img alt="" class="calibre4" src="../Images/CH07_F17_Khamis.png"/></p>

    <p class="figurecaption">Figure 7.17 GA generational and steady-state models</p>
  </div>

  <h3 class="fm-head1" id="heading_id_13">7.3.5 Survivor selection</h3>

  <p class="body"><a id="marker-260"/>Random selection, age-based selection, fitness-proportionate selection, and tournament selection are examples of survivor selection methods that can preserve the best individuals while also introducing diversity to a population by making use of the newly generated offspring: <a id="idIndexMarker125"/><a id="idIndexMarker126"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">In <i class="fm-italics">random selection</i>, the new population is formed by random selection of <i class="timesitalic">N</i> individuals.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">With <i class="fm-italics">age-based selection</i> (or first in, first out), the oldest individuals will be deleted. <a id="idIndexMarker127"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Fitness-proportionate selection</i> (FPS) takes into consideration the fitness of each individual—we can delete or replace individuals based on the inverse of fitness, always keeping the best individuals or deleting the worst individuals. For example, <i class="fm-italics">elitist selection</i> involves simply selecting the best individuals from both the old population and the new offspring to create the new population. This method ensures that the best solutions are preserved from generation to generation. <a id="idIndexMarker128"/><a id="idIndexMarker129"/><a id="marker-261"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Tournament selection involves selecting individuals from both the old population and the new offspring at random and then selecting the best individuals from each group to create the new population. This method can be more effective at preserving diversity in the population.</p>
    </li>
  </ul>

  <p class="body">In the ticket pricing example, if we apply elitist selection, the new population will be formed by the selected solutions shown in table 7.7.</p>

  <p class="fm-table-caption">Table 7.7 Elitist selection</p>

  <table border="1" class="contenttable-1-table" id="table007" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Source</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Candidate solutions <span class="times">x</span> in the solution space</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Candidate solutions in the binary coding space</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Objective function <span class="times">f(x)</span></p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Ranking</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Selected</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1" rowspan="5">
          <p class="fm-table-head">Old individuals</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">77</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">01001101</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">8,820</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">7</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">203</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">11001011</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">84,420</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">3</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">01101110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">90,000</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">2</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">145</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">10010001</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">128,500</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">1</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">230</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">11100110</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">18,000</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">6</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1" rowspan="2">
          <p class="fm-table-head">New individuals generated by 1-point crossover</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">81</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">01010001</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">20,980</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">5</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">77</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">01001101</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">8,820</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">7</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-th1">
          <p class="fm-table-head">New individuals generated by mutating individual 77</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">103</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">01100111</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">76,420</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">4</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">You may have noticed that 1-point crossover generated a solution that already exists in the initial population. This phenomenon is not necessarily a problem, as it is an expected outcome when applying genetic operators in a search process. Crossover and mutation can result in both explorative and exploitative behaviors. For example, in 1-point or <i class="fm-italics">n</i>-point crossover and based on the random split point position, a new solution can be the same as or close to the parents or can generate more diverse offspring.</p>

  <h2 class="fm-head" id="heading_id_14">7.4 Implementing genetic algorithms in Python</h2>

  <p class="body">A genetic algorithm is an easy algorithm to implement. Let’s see how we can solve the ticket pricing problem using GA in Python. <a id="idIndexMarker130"/><a id="idIndexMarker131"/><a id="marker-262"/></p>

  <p class="body">We’ll start by importing the necessary packages and defining the problem.</p>

  <p class="fm-code-listing-caption">Listing 7.2 Solving the ticket pricing problem using binary GA</p>
  <pre class="programlisting">import numpy as np
import random
from tqdm.notebook import tqdm
from copy import copy
import matplotlib.pyplot as plt
  
def profit(x):
    return -20*x*x+6200*x-350000</pre>

  <p class="body">Because we’re solving this problem using a binary GA, we need to generate an initial random population. As a continuation of listing 7.2, the following <code class="fm-code-in-text">init_pop</code> function takes two arguments as input—<code class="fm-code-in-text">pop_size</code>, which represents the population size, and <code class="fm-code-in-text">chromosome_length</code>, which represents the length of each chromosome: <a id="idIndexMarker132"/><a id="idIndexMarker133"/><a id="idIndexMarker134"/></p>
  <pre class="programlisting">def init_pop(pop_size, chromosome_length):
    ints = [random.randint(75,235) for i in range(pop_size)]      <span class="fm-combinumeral">①</span>
    strs = [bin(n)[2:].zfill(chromosome_length) for n in ints]    <span class="fm-combinumeral">②</span>
    bins = [[int(x) for x in n] for n in strs]                    <span class="fm-combinumeral">③</span>
    return bins                                                   <span class="fm-combinumeral">④</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Generate a list of random integers.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Convert the integers to binary strings.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Convert the binary strings to lists of binary digits.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Return the final list of binary chromosomes.</p>

  <p class="body">The <code class="fm-code-in-text">init_pop</code> function starts by generating a list of random integers from 75 to 235 (inclusive) with a length equal to <code class="fm-code-in-text">pop_size</code>. This list will later be converted to binary representations. The integers in the <code class="fm-code-in-text">ints</code> list are then converted to binary strings using the <code class="fm-code-in-text">bin()</code> function, which returns a binary string representation of a given number with the prefix <code class="fm-code-in-text">0b</code>. To remove this prefix, we use slicing with <code class="fm-code-in-text">[2:]</code>. Then we use the <code class="fm-code-in-text">zfill()</code> method to pad the binary string with leading zeros to ensure it has the same length as <code class="fm-code-in-text">chromosome_length</code>. The binary strings in the <code class="fm-code-in-text">strs</code> list are converted to lists of binary digits (0 or 1). This is done using a nested list comprehension that iterates through each character in the binary strings and converts it to an integer. The function finally returns a list of binary chromosomes, where each chromosome is a list of binary digits.<a id="idIndexMarker135"/><a id="idIndexMarker136"/><a id="idIndexMarker137"/><a id="idIndexMarker138"/><a id="idIndexMarker139"/><a id="idIndexMarker140"/><a id="idIndexMarker141"/></p>

  <p class="body">For a given population, we can calculate the fitness of each element in the population using the following <code class="fm-code-in-text">fitness_score</code> function. This fitness function essentially determines how “good” a particular offspring is. It converts each unit in the population to a binary number (the genotype), evaluates the function to optimize profit, and then returns the “best” offspring. The function mainly takes a population as input and returns a tuple containing two lists, one of the sorted fitness values and another of the sorted population:<a id="idIndexMarker142"/></p>
  <pre class="programlisting">def fitness_score(population):
    fitness_values = []
    num = []
    for i in range(len(population)):
        num.append(int("".join(str(x) for x in population[i]), base=2))  <span class="fm-combinumeral">①</span>
        fitness_values.append(profit(num[i]))                            <span class="fm-combinumeral">②</span>
    tuples = zip(*sorted(zip(fitness_values, population),reverse=True))  <span class="fm-combinumeral">③</span>
    fitness_values, population = [list(t) for t in tuples]               <span class="fm-combinumeral">④</span>
    return fitness_values, population                                    <span class="fm-combinumeral">⑤</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Convert binary to decimal.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Evaluate the fitness of each chromosome and append the fitness value to the fitness_values list.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Create tuples of fitness values and their corresponding chromosomes, and then sort them in descending order based on fitness values.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Unzip the sorted tuples back into separate lists for fitness values and the population.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Return the sorted fitness values and population.</p>

  <p class="body">Let’s now select two parents using the random selection method implemented in the following <code class="fm-code-in-text">select_parent</code> function. This function takes two arguments as input: <code class="fm-code-in-text">population</code>, which is a list of individuals in the population, and <code class="fm-code-in-text">num_parents</code>, which represents the number of parents to select. It returns a list of selected parents:<a id="idIndexMarker143"/><a id="idIndexMarker144"/><a id="idIndexMarker145"/></p>
  <pre class="programlisting">def select_parent(population, num_parents):
    parents=random.sample(population, num_parents)     <span class="fm-combinumeral">①</span>
    return parents                                     <span class="fm-combinumeral">②</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Randomly select a specified number of unique parents from the given population.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Return the list of selected parents.</p>

  <p class="body">The <code class="fm-code-in-text">select_parent</code> function implements a simple random sampling selection method, which gives each individual in the population an equal chance of being selected as a parent. Other selection methods, such as FPS or roulette wheel selection, can also be used to give higher chances to individuals with better fitness values. <a id="idIndexMarker146"/></p>

  <p class="body"><a id="marker-263"/>The following <code class="fm-code-in-text">roulette_wheel_selection</code> function shows the steps of roulette wheel selection. The function takes two arguments as input—<code class="fm-code-in-text">population</code>, which is a list of individuals in the population, and <code class="fm-code-in-text">num_parents</code>, which represents the number of parents to select:<a id="idIndexMarker147"/></p>
  <pre class="programlisting">def roulette_wheel_selection(population, num_parents):
    fitness_values, population = fitness_score(population)                 <span class="fm-combinumeral">①</span>
    total_fitness = sum(fitness_values)
    probabilities = [fitness / total_fitness for fitness in fitness_values]<span class="fm-combinumeral">②</span>
 
    selected_parents = [] 
    for i in range(num_parents):                                           <span class="fm-combinumeral">③</span>
        r = random.random()                                                <span class="fm-combinumeral">④</span>
  
        cumulative_probability = 0                                         <span class="fm-combinumeral">⑤</span>
        for j in range(len(population)):
            cumulative_probability += probabilities[j]
            if cumulative_probability &gt; r:
                selected_parents.append(population[j])
                break
  
    return selected_parents</pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Calculate total fitness.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Calculate selection probabilities for each individual.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Select only two parents.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Generate a random number r between 0 and 1.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Find the individual whose cumulative probability includes r.</p>

  <p class="body">After selecting the parents, it’s time to apply genetic operators to produce the offspring. The following <code class="fm-code-in-text">crossover</code> function implements 1-point crossover. The function takes two arguments as input: <code class="fm-code-in-text">parents</code>, which is a list of two parent chromosomes, and <code class="fm-code-in-text">crossover_prob</code>, which represents the probability of crossover occurring between the parents. It returns a list of parents and offspring. The first offspring is generated by taking the first part (up to and including the crossover point) of the first parent and the second part (from the crossover point + 1 to the end of the chromosome) of the second parent. Similarly, the second offspring is generated by taking the first part (up to and including the crossover point) of the second parent and the second part (from the crossover point + 1 to the end of the chromosome) of the first parent:<a id="idIndexMarker148"/><a id="idIndexMarker149"/><a id="idIndexMarker150"/></p>
  <pre class="programlisting">def crossover(parents, crossover_prob): 
    chromosome_length = len(parents[0]) 
    if crossover_prob &gt; random.random():                                  <span class="fm-combinumeral">①</span>
        cross_point = random.randint(0,chromosome_length)                 <span class="fm-combinumeral">②</span>
        parents+=tuple([(parents[0][0:cross_point+1] +parents[1][cross_   <span class="fm-combinumeral">③</span>
point+1])]) 
        parents+=tuple([(parents[1][0:cross_point+1] +parents[0][cross_   <span class="fm-combinumeral">④</span>
point+1])]) 
    return parents                                                        <span class="fm-combinumeral">⑤</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Apply crossover if, and only if, crossover probability is greater than a randomly generated number.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Choose a random crossover point within the range of chromosome indices.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Create the first offspring.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Create the second offspring.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Return the original parents and the new offspring generated by the crossover operation.</p>

  <p class="body"><a id="marker-264"/>Let’s now apply the mutation process. The following <code class="fm-code-in-text">mutation</code> function performs mutation operations on a given population of chromosomes. It takes two arguments as input: <code class="fm-code-in-text">population</code>, which is a list of binary chromosomes, and <code class="fm-code-in-text">mutation_prob</code>, which represents the probability of mutation occurring at each gene in the chromosomes. It returns the mutated population:<a id="idIndexMarker151"/><a id="idIndexMarker152"/><a id="idIndexMarker153"/></p>
  <pre class="programlisting">def mutation(population, mutation_prob) :
    chromosome_length = len(population[0])
    for i in range(len(population)):               <span class="fm-combinumeral">①</span>
        for j in range(chromosome_length-1):       <span class="fm-combinumeral">②</span>
            if mutation_prob &gt; random.random():    <span class="fm-combinumeral">③</span>
                if population[i][j]==1:            <span class="fm-combinumeral">④</span>
                    population[i][j]=0             <span class="fm-combinumeral">④</span>
                else:                              <span class="fm-combinumeral">④</span>
                    population[i][j]=1             <span class="fm-combinumeral">④</span>
    return population                              <span class="fm-combinumeral">⑤</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Iterate through each chromosome in the population.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Iterate through each gene in the chromosome, except the last one.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Apply mutation if, and only if, the mutation probability is greater than a randomly generated number</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Flip the value of the gene.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Return the mutated population.</p>

  <p class="body">Let’s now put everything together and define the binary genetic algorithm (<code class="fm-code-in-text">BGA</code>) function. This function takes the following arguments as input:<a id="idIndexMarker154"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">population</code>—The initial population of binary chromosomes</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">num_gen</code>—The number of generations the algorithm will run for</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">num_parents</code>—The number of parents to select for crossover</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">crossover_prob</code>—The probability of crossover occurring between parents</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">mutation_prob</code>—The probability of mutation occurring at each gene</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">use_tqdm</code> (optional, default=<code class="fm-code-in-text">False</code>)—A Boolean flag to enable or disable a progress bar using the tqdm library</p>
    </li>
  </ul>

  <p class="body">This is the BGA function:</p>
  <pre class="programlisting">def BGA(population, num_gen, num_parents, crossover_prob, mutation_prob, use_tqdm =
<span class="fm-code-continuation-arrow">➥</span> False):
    states = []                                             <span class="fm-combinumeral">①</span>
    best_solution = []                                      <span class="fm-combinumeral">①</span>
    best_score = 0                                          <span class="fm-combinumeral">①</span>
    if use_tqdm: pbar = tqdm(total=num_gen)
    for _ in range(num_gen):                                <span class="fm-combinumeral">②</span>
        if use_tqdm: pbar.update()
        scores, population = fitness_score(population)      <span class="fm-combinumeral">③</span>
        current_best_score = scores[0]                      <span class="fm-combinumeral">④</span>
        current_best_solution = population[0]               <span class="fm-combinumeral">④</span>
        states.append(current_best_score)
        if current_best_score &gt; best_score: 
            best_score = current_best_score
            best_solution = int("".join(str(x) for x in
            <span class="fm-code-continuation-arrow">➥</span> copy(current_best_solution)), base=2)
        parents = select_parent(population, num_parents)    <span class="fm-combinumeral">⑤</span>
        parents = crossover(parents, crossover_prob)        <span class="fm-combinumeral">⑥</span>
        population = mutation(population,mutation_prob)     <span class="fm-combinumeral">⑦</span>
    return best_solution, best_score, states                <span class="fm-combinumeral">⑧</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Initialization</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Run the genetic algorithm for num_gen generations using a for loop.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Calculate the fitness scores and sort the population based on the fitness values by calling the fitness_score function.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Update the best solution and best score.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Parent selection using the select_parent random method. You can replace this method with roulette_wheel_selection(population, num_parents).<a id="idIndexMarker155"/></p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑥</span> Perform crossover on the selected parents.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑦</span> Perform mutation.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑧</span> Return the best solution.</p>

  <p class="body">This function returns the best solution, the best score, and the list of best scores at each generation.</p>

  <p class="body"><a id="marker-265"/>Now we can solve the ticket pricing problem, starting with generating an initial population with the following parameters:</p>
  <pre class="programlisting">num_gen = 1000
pop_size = 5
crossover_prob = 0.7
mutation_prob = 0.3
num_parents = 2
  
chromosome_length = 8
best_score = -100000 
  
population = init_pop(pop_size, chromosome_length)
print("Initial population: \n", population)</pre>

  <p class="body">Running this code produced the following initial population:</p>
  <pre class="programlisting">Initial population: [[1, 1, 1, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 1, 0], [1, 1, 0, 1, 1, 1, 0, 1], [1, 1, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 0, 0, 0, 0]]</pre>

  <p class="body">We can now run the binary GA solver to get the solutions, as follows:</p>
  <pre class="programlisting">best_solution, best_score, states = BGA(population, num_gen, num_parents,
<span class="fm-code-continuation-arrow">➥</span> crossover_prob, mutation_prob, use_tqdm=True)</pre>

  <p class="body">Running this code produces the same solution obtained by the SciPy optimizer (see listing 2.4):</p>
  <pre class="programlisting">Optimal ticket price ($): 155
Profit ($): 130500</pre>

  <p class="body">Rather than writing your own genetic algorithm code from scratch, you can take advantage of existing Python packages that offer GA implementations. Numerous open source Python libraries can help streamline the development process and save time. These libraries often include genetic operators, selection methods, and other features that make it easier to adapt a genetic algorithm to different optimization problems. Examples of these libraries include, but are not limited to, the following:<a id="idIndexMarker156"/><a id="idIndexMarker157"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Pymoo</i> (Multi-objective Optimization in Python; <a class="url" href="https://pymoo.org/algorithms/moo/nsga2.html">https://pymoo.org/algorithms/moo/nsga2.html</a>)—A Python library for multi-objective optimization using evolutionary algorithms and other metaheuristic techniques. Pymoo offers a variety of algorithms such as GA, differential evolution, evolutionary strategy, non-dominated sorting genetic algorithm (NSGA-II), NSGA-III, and particle swarm optimization (PSO).<a id="idIndexMarker158"/><a id="idIndexMarker159"/><a id="idIndexMarker160"/><a id="idIndexMarker161"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">DEAP</i> (Distributed Evolutionary Algorithms in Python; <a class="url" href="https://deap.readthedocs.io/en/master/">https://deap.readthedocs.io/en/master/</a>—A Python library for implementing genetic algorithms in Python. It provides tools for defining, training, and evaluating genetic algorithm models, as well as for visualizing the optimization process. DEAP provides a variety of built-in genetic operators, including mutation, crossover, and selection, as well as support for custom operators tailored to specific optimization problems.<a id="idIndexMarker162"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">PyGAD</i> (Python Genetic Algorithm; <a class="url" href="https://pygad.readthedocs.io/en/latest/">https://pygad.readthedocs.io/en/latest/</a>)—A Python library for implementing genetic algorithms and differential evolution (DE) algorithms. PyGAD is suitable for both single-objective and multi-objective optimization tasks and can be used in a wide range of applications, including machine learning, and other problem domains.<a id="idIndexMarker163"/><a id="idIndexMarker164"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">jMetalPy</i> (<a class="url" href="https://github.com/jMetal/jMetalPy">https://github.com/jMetal/jMetalPy</a>)—A Python library designed for developing and experimenting with metaheuristic algorithms for solving multi-objective optimization problems. It provides support for a variety of metaheuristic algorithms, including popular evolutionary algorithms like non-dominated sorting genetic algorithm (NSGA-II), NSGA-III, strength Pareto evolutionary algorithm (SPEA2), and multi-objective evolutionary algorithm based on decomposition (MOEA/D), as well as other optimization techniques such as simulated annealing and particle swarm optimization.<a id="idIndexMarker165"/><a id="idIndexMarker166"/><a id="idIndexMarker167"/><a id="idIndexMarker168"/><a id="marker-266"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">PyGMO</i> (Python Parallel Global Multi-objective Optimizer; <a class="url" href="https://esa.github.io/pygmo/">https://esa.github.io/pygmo/</a>)—A scientific library providing a large number of optimization problems and algorithms such as NSGA-II, SPEA2, non-dominated sorting particle swarm optimization (NS-PSO), and parameter adaptive differential evolution (PaDE). It uses the generalized island-model paradigm for the coarse grained parallelization of optimization algorithms and, therefore, allows users to develop asynchronous and distributed algorithms.<a id="idIndexMarker169"/><a id="idIndexMarker170"/><a id="idIndexMarker171"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Inspyred</i> (Bio-inspired Algorithms in Python; <a class="url" href="https://pythonhosted.org/inspyred/">https://pythonhosted.org/inspyred/</a>)—A library for creating and working with bio-inspired computational intelligence algorithms. It supports a variety of bio-inspired optimization algorithms, such as GA, evolution strategy, simulated annealing, differential evolution algorithm, estimation of distribution algorithm, Pareto archived evolution strategy (PAES), nondominated sorting genetic algorithm (NSGA-II), particle swarm optimization (PSO), and ant colony optimization (ACO).<a id="idIndexMarker172"/><a id="idIndexMarker173"/><a id="idIndexMarker174"/><a id="idIndexMarker175"/><a id="idIndexMarker176"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Platypus</i> (<a class="url" href="https://platypus.readthedocs.io/en/latest/">https://platypus.readthedocs.io/en/latest/</a>)—A framework for evolutionary computing in Python with a focus on multi-objective evolutionary algorithms (MOEAs). It provides tools for analyzing and visualizing algorithm performance and solution sets.<a id="idIndexMarker177"/><a id="idIndexMarker178"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">MEALPY</i> (<a class="url" href="https://mealpy.readthedocs.io/en/latest/index.html">https://mealpy.readthedocs.io/en/latest/index.html</a>)—A Python library that provides implementations for population-based meta-heuristic algorithms such as evolutionary computing algorithms, swarm inspired computing, physics inspired computing, human inspired computing, and biology inspired computing. <a id="idIndexMarker179"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Mlrose</i> (Machine Learning, Randomized Optimization and Search; <a class="url" href="https://mlrose.readthedocs.io/en/stable/index.html">https://mlrose.readthedocs.io/en/stable/index.html</a>)—An open source Python library that provides an implementation of standard GA to find the optimum for a given optimization problem.<a id="idIndexMarker180"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">Pyevolve</i> (<a class="url" href="https://pyevolve.sourceforge.net/">https://pyevolve.sourceforge.net/</a>)—An open source Python library designed for working with genetic algorithms and other EC techniques<a id="idIndexMarker181"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><i class="fm-italics">EasyGA</i> (<a class="url" href="https://github.com/danielwilczak101/EasyGA">https://github.com/danielwilczak101/EasyGA</a>)—A Python package designed to provide an easy-to-use GA. It’s worth noting that EasyGA and Pyevolve are simple libraries with less functionality and predefined problems than other libraries such as DEAP and Pymoo.<a id="idIndexMarker182"/></p>
    </li>
  </ul>

  <p class="body">Listing A.3, available in the book’s G<a id="idTextAnchor002"/>itHub repo, shows how to use some of these libraries.</p>

  <p class="body">In this book, we will focus on utilizing the pymoo library, as it is a comprehensive framework that offers several optimization algorithms, visualization tools, and decision-making capabilities. This library is particularly well-suited for multi-objective optimization, which we’ll explore in more detail in the next chapter. Pymoo’s extensive features make it an excellent choice for implementing and analyzing genetic algorithms in various problem domains. Table 7.8 summarizes a comparative study of selected evolutionary computing frameworks, including pymoo [2]. <a id="idIndexMarker183"/><a id="marker-267"/></p>

  <p class="fm-table-caption">Table 7.8 Comparing selected evolutionary computing frameworks in Python</p>

  <table border="1" class="contenttable-1-table" id="table008" width="100%">
    <colgroup class="contenttable-0-colgroup">
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
      <col class="contenttable-0-col" span="1" width="16.66%"/>
    </colgroup>

    <thead class="calibre6">
      <tr class="contenttable-0-tr">
        <th class="contenttable-1-th">
          <p class="fm-table-head">Library</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">License</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Pure Python</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Visualization</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Focus on multi-objective</p>
        </th>

        <th class="contenttable-1-th">
          <p class="fm-table-head">Decision making</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre6">
      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">jMetalPy</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">MIT</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">PyGMO</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">GPL-3.0</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No (C++ with Python wrappers)</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">Platypus</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">GPL-3.0</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">DEAP</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">LGPL-3.0</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">inspyred</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">MIT</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">No</p>
        </td>
      </tr>

      <tr class="contenttable-0-tr">
        <td class="contenttable-1-td">
          <p class="fm-table-body">pymoo</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Apache 2.0</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>

        <td class="contenttable-1-td">
          <p class="fm-table-body">Yes</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="body">The following listing shows the steps for solving the ticket pricing problem using GA implemented in pymoo. We’ll start by importing various classes and functions from the pymoo library.<a id="idIndexMarker184"/></p>

  <p class="fm-code-listing-caption">Listing 7.3 Solving the ticket pricing problem using GA in pymoo</p>
  <pre class="programlisting">from pymoo.algorithms.soo.nonconvex.ga import GA
from pymoo.operators.crossover.pntx import PointCrossover, 
<span class="fm-code-continuation-arrow">➥</span> SinglePointCrossover,
<span class="fm-code-continuation-arrow">➥</span> TwoPointCrossover
from pymoo.operators.mutation.pm import PolynomialMutation
from pymoo.operators.repair.rounding import RoundingRepair
from pymoo.operators.sampling.rnd import FloatRandomSampling
from pymoo.core.problem import Problem
from pymoo.optimize import minimize</pre>

  <p class="body">The <code class="fm-code-in-text">GA</code> class represents a single-objective genetic algorithm in the pymoo library. The <code class="fm-code-in-text">PointCrossover</code>, <code class="fm-code-in-text">SinglePointCrossover</code>, and <code class="fm-code-in-text">TwoPointCrossover</code> classes represent different crossover operators for combining the genetic material of parent chromosomes to create offspring. The <code class="fm-code-in-text">PolynomialMutation</code> class represents a mutation operator that introduces small, random changes in the chromosomes’ genes. The <code class="fm-code-in-text">RoundingRepair</code> class represents a repair operator that rounds the variable values of the chromosomes, ensuring that they stay within a specific range or meet certain constraints. The <code class="fm-code-in-text">FloatRandomSampling</code> class represents a random sampling operator that generates an initial population of chromosomes with random float values. The <code class="fm-code-in-text">Problem</code> class is used to define optimization problems by specifying objectives, constraints, and variable bounds. Finally, the <code class="fm-code-in-text">minimize</code> function is used to perform the optimization process. It is worth noting that pymoo can only handle minimization problems, so if you need to use it with a maximization problem, you’ll have to convert the problem into a minimization problem, as discussed in section 7.3.1.<a id="idIndexMarker185"/><a id="idIndexMarker186"/><a id="idIndexMarker187"/><a id="idIndexMarker188"/><a id="idIndexMarker189"/><a id="idIndexMarker190"/><a id="idIndexMarker191"/><a id="idIndexMarker192"/><a id="idIndexMarker193"/><a id="marker-268"/></p>

  <p class="body">After importing the necessary classes and functions from the pymoo library, we can define the <code class="fm-code-in-text">TicketPrice</code> problem by subclassing the <code class="fm-code-in-text">Problem</code> class from the pymoo library as follows:<a id="idIndexMarker194"/><a id="idIndexMarker195"/></p>
  <pre class="programlisting">class TicketPrice(Problem):
  
    def __init__(self):                             <span class="fm-combinumeral">①</span>
        super().__init__(n_var=1,
                         n_obj=1,
                         n_constr=0,
                         xl=75.0,
                         xu=235.0, vtype=float)     <span class="fm-combinumeral">②</span>
  
    def _evaluate(self, x, out, *args, **kwargs):   <span class="fm-combinumeral">③</span>
        out["F"]= 20*x*x-6200*x+350000              <span class="fm-combinumeral">④</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Define the constructor for the TicketPrice class.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Call the constructor of the parent Problem class.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Define the evaluation function for the TicketPrice class.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Evaluate the value of the objective function using the given formula.</p>

  <p class="body">As can be seen, the constructor of the parent <code class="fm-code-in-text">Problem</code> class contains the following components with customized values applied to the ticket pricing problem:<a id="idIndexMarker196"/></p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">n_var=1</code>—The number of decision variables in the problem, which is set to 1, indicating a single decision variable for the ticket price.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">n_obj=1</code>—The number of objectives in the problem, which is set to 1, indicating a single-objective optimization problem.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">n_constr=0</code>—The number of constraints in the problem, which is set to 0, indicating that there are no constraints in this optimization problem.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">xl=75.0</code>—The lower bound for the decision variable, which is set to 75.0.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">xu=235.0</code>—The upper bound for the decision variable, which is set to 235.0.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">vtype=float</code>—The variable type for the decision variables, which is set to float. Other types include <code class="fm-code-in-text">int</code> and <code class="fm-code-in-text">bool</code>.</p>
    </li>
  </ul>

  <p class="body">Now we can apply GA to solve the problem as follows:</p>
  <pre class="programlisting">problem = TicketPrice()                                                  <span class="fm-combinumeral">①</span>
algorithm = GA(
    pop_size=100,
    sampling=FloatRandomSampling(),
    crossover=PointCrossover(prob=0.8, n_points=2),
    mutation = PolynomialMutation(prob=0.3, repair=RoundingRepair()),
    eliminate_duplicates=True
)                                                                        <span class="fm-combinumeral">②</span>
  
res = minimize(problem, algorithm, ('n_gen', 100), seed=1, verbose=True) <span class="fm-combinumeral">③</span>
  
print(f"Optimal ticket price ($): {res.X}")                              <span class="fm-combinumeral">④</span>
print(f"Profit ($): {-res.F}")                                           <span class="fm-combinumeral">⑤</span></pre>

  <p class="fm-code-annotation"><span class="fm-combinumeral">①</span> Create an instance of the TicketPrice problem.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">②</span> Instantiate a GA object.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">③</span> Run the solver.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">④</span> Print the optimal ticket price.</p>

  <p class="fm-code-annotation"><span class="fm-combinumeral">⑤</span> Print the profit. Negate the objective value when printing the result.</p>

  <p class="body">GA parameters include the following:</p>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">pop_size=100</code>—Set the population size to 100 individuals.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">sampling=FloatRandomSampling()</code>—Use the <code class="fm-code-in-text">FloatRandomSampling</code> class to generate an initial population of chromosomes with random float values.<a id="idIndexMarker197"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">crossover=PointCrossover(prob=0.8, n_points=2)</code>—Use the <code class="fm-code-in-text">PointCrossover</code> class as the crossover operator with a probability of 0.8 and two crossover points.<a id="idIndexMarker198"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">mutation=PolynomialMutation(prob=0.3, repair=RoundingRepair())</code>—Use the <code class="fm-code-in-text">PolynomialMutation</code> class as the mutation operator with a probability of 0.3, and apply the <code class="fm-code-in-text">RoundingRepair</code> class to repair mutated solutions if needed. The repair makes sure every solution that is evaluated is, in fact, feasible.<a id="idIndexMarker199"/><a id="idIndexMarker200"/><a id="marker-269"/></p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">eliminate_duplicates=True</code>—Set the flag to eliminate duplicate individuals in the population.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list"><code class="fm-code-in-text">res = minimize(...)</code>—Call the minimize function from pymoo to run the optimization process.</p>
    </li>
  </ul>

  <p class="body">Running listing 7.3 produces the following output:</p>
  <pre class="programlisting">Optimal ticket price ($): [155]
Profit ($): [130500.]</pre>

  <p class="body">So far, we’ve only scratched the surface of genetic algorithms. We’ll dive into the details, study different variants of genetic algorithms, and address more practical use cases in t<a id="idTextAnchor003"/>he next chapter.<a id="idIndexMarker201"/><a id="idIndexMarker202"/></p>

  <h2 class="fm-head" id="heading_id_15">Summary</h2>

  <ul class="calibre5">
    <li class="fm-list-bullet">
      <p class="list">Metaheuristic algorithms that are population-based, often referred to as P-metaheuristics, employ multiple agents to find an optimal or near-optimal global solution. These algorithms can be divided into two main categories, depending on their source of inspiration: evolutionary computation (EC) algorithms and swarm intelligence (SI) algorithms.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">EC algorithms draw inspiration from the process of biological evolution. Examples of EC algorithms include the genetic algorithm (GA), differential evolution (DE), genetic programming (GP), evolutionary programming (EP), evolutionary strategies (ES), cultural algorithms (CA), and co-evolution (CoE).</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">The genetic algorithm is the most widely used form of EC. It is an adaptive heuristic search method designed to mimic the natural system’s processes required for evolution, as outlined in Charles Darwin’s theory of evolution.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">Pseudo-random strategies, quasi-random strategies, sequential diversification, parallel diversification, and heuristics represent various initialization strategies for P-metaheuristics like genetic algorithms. Each strategy offers distinct levels of diversity, computational cost, and initial solution quality.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">In genetic algorithms, the crossover and mutation operators play essential roles in searching the solution space and maintaining diversity within the population. The primary purpose of these operators is to handle the search dilemma by balancing exploration (searching new areas of the solution space) and exploitation (refining the existing solutions).</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">A high crossover rate and a low mutation rate are recommended to balance exploration and exploitation. The high crossover rate facilitates the sharing of good traits between individuals, while the low mutation rate introduces small, random changes to maintain diversity and prevent premature convergence. This combination allows the algorithm to efficiently search the solution space and find high-quality solutions.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">In the generational model of genetic algorithms, the entire population is replaced, whereas in the steady-state model of genetic algorithms, a small fraction of the population is replaced. The steady-state model has lower computation costs than the generational model in genetic algorithms, but the generational model improves diversity preservation compared to the steady-state models.</p>
    </li>

    <li class="fm-list-bullet">
      <p class="list">A wide range of open source Python libraries exist for working with genetic algorithms. One such library, pymoo (Multi-objective Optimization in Python), includes popular algorithms such as genetic algorithms, differential evolution, evolutionary strategies, the non-dominated sorting genetic algorithm (NSGA-II), NSGA-III, and particle swarm optimization (PSO).<a id="idIndexMarker203"/><a id="marker-270"/></p>
    </li>
  </ul>
</body></html>