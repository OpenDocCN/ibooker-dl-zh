- en: 6 Tabu search
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 禁忌搜索
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding local search
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解局部搜索
- en: Understanding how tabu search extends local search
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解禁忌搜索如何扩展局部搜索
- en: Solving constraint-satisfaction problems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决约束满足问题
- en: Solving continuous problems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决连续问题
- en: Solving routing problems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决路径问题
- en: Solving assembly line balancing problems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决装配线平衡问题
- en: In the previous chapter, you were introduced to trajectory-based metaheuristics,
    and you learned about simulated annealing (SA) as an example of these metaheuristic
    algorithms. The actual first use of a metaheuristic is probably Fred Glover’s
    *tabu search* (TS) in 1986, although his seminal article on tabu search was published
    later, in 1997 [1]. The word “tabu” (also spelled “taboo”) originated from the
    Polynesian languages of the South Pacific. It is a term used to describe something
    that is prohibited, forbidden, or considered socially unacceptable within a particular
    culture or society. Tabu search is called “tabu” because it uses a memory structure
    to keep track of solutions that have been recently explored so it can avoid returning
    to them, especially in the early stage of the search, in order to avoid getting
    stuck in local optima.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你被介绍到基于轨迹的元启发式算法，并学习了模拟退火（SA）作为这些元启发式算法的例子。元启发式算法的实际首次使用可能是弗雷德·格洛弗的*禁忌搜索*（TS）在1986年，尽管他关于禁忌搜索的开创性文章是在1997年[1]发表的。单词“tabu”（也拼作“taboo”）起源于南太平洋的波利尼西亚语。它是一个用来描述在特定文化或社会中被认为是禁止的、禁止的或被认为是不被社会接受的术语。禁忌搜索被称为“tabu”，因为它使用一个记忆结构来跟踪最近探索过的解决方案，以便避免返回它们，特别是在搜索的早期阶段，以避免陷入局部最优。
- en: TS is a powerful trajectory-based optimization technique that has been successfully
    applied to solve different optimization problems in different areas, such as scheduling,
    design, allocation, routing, production, inventory and investment, telecommunications,
    logic and artificial intelligence, technology, graph optimization, and general
    combinatorial optimization. TS can be considered a combination of local search
    and memory structures.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: TS是一种强大的基于轨迹的优化技术，它已成功应用于解决不同领域中的不同优化问题，如调度、设计、分配、路径、生产、库存和投资、电信、逻辑和人工智能、技术、图优化和一般组合优化。TS可以被认为是局部搜索和记忆结构的组合。
- en: This chapter presents tabu search as a trajectory-based metaheuristic optimization
    technique, discusses its pros and cons, and looks at its applications in different
    domains. To illustrate how this algorithm can be used to solve optimization problems,
    a variety of case studies and exercises will be presented. Let’s start by closely
    exploring local search.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了禁忌搜索作为一种基于轨迹的元启发式优化技术，讨论了其优缺点，并探讨了其在不同领域的应用。为了说明该算法如何用于解决优化问题，将展示各种案例研究和练习。让我们首先近距离探索局部搜索。
- en: 6.1 Local search
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 局部搜索
- en: Imagine yourself enjoying a vacation at a resort that features multiple restaurants,
    each offering a diverse selection of dishes to satisfy your every craving. During
    the initial day of your stay, you might choose a restaurant randomly or select
    the nearest one to your room if you are exhausted from your journey. You may continue
    dining at that particular restaurant or explore other options within the resort.
    In this case, you are applying local search by limiting your options to those
    found within the resort, without considering the possibility of ordering food
    online or leaving the resort to dine elsewhere.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下自己在一家提供多种餐厅的度假村度假，每家餐厅都提供多样化的菜品以满足你的每一个需求。在你入住的第一天，你可能会随机选择一家餐厅，或者如果你在旅途中感到疲惫，就选择离你房间最近的一家。你可能继续在那家特定的餐厅用餐，或者探索度假村内的其他选项。在这种情况下，你通过限制你的选择仅限于度假村内的选项来应用局部搜索，而不考虑在线订购食物或离开度假村在其他地方用餐的可能性。
- en: '*Local search* (LS) is a search technique that iteratively explores a subset
    of a search space in the neighborhood of the current solution or state in order
    to improve this solution with local changes. The type of local changes that may
    be applied to a solution is defined by a *neighborhood structure*. For a finite
    set of candidate solutions *S*, a neighborhood structure represents a set of neighboring
    solutions *N*(*s*) ⊆ *S* that can be generated by making a small change to the
    current solution *s* ∈ *S*. The horizon of *N*(*s*) as a neighborhood of *s* varies
    from exploring all the possible neighbors of the current solutions (random search)
    to only considering one neighbor (local search). The former can be computationally
    demanding, while the latter has a very limited horizon or search space and is
    highly vulnerable to getting trapped in a local minimum.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*局部搜索*（LS）是一种搜索技术，它通过迭代地探索当前解或状态附近的搜索空间的一个子集，以通过局部变化来改进这个解。可以应用于解的局部变化类型由一个*邻域结构*定义。对于一个有限候选解集
    *S*，邻域结构表示一个由对当前解 *s* ∈ *S* 进行微小改变所能生成的邻近解集 *N*(*s*) ⊆ *S*。*N*(*s*) 作为 *s* 的邻域，其范围从探索当前解的所有可能邻近者（随机搜索）到仅考虑一个邻近者（局部搜索）。前者可能计算量很大，而后者具有非常有限的视野或搜索空间，并且很容易陷入局部最小值。'
- en: As shown in algorithm 6.1, a local search algorithm starts from an initial feasible
    solution and iteratively moves to a neighboring solution as long as the new neighboring
    solution is better than the old one.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如算法6.1所示，局部搜索算法从一个初始可行解开始，只要新的邻近解比旧的好，就迭代地移动到一个邻近解。
- en: Algorithm 6.1 Local search
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 算法6.1 局部搜索
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Typically, every feasible solution has more than one neighboring solution. The
    name “local search” implies that the algorithm searches for a new solution in
    the neighborhood of the current one. For example, hill climbing can be considered
    a local search technique where a new neighboring solution that is locally maximizing
    the criterion or objective function is considered in each iteration. The hill
    climbing algorithm is a greedy algorithm, as it accepts only improving solutions.
    This sometimes makes it converge to local optima, which are usually average solutions
    unless the search is extremely lucky. The solution quality and the computation
    time are usually dependent on the chosen local moves.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个可行解都有多个邻近解。名称“局部搜索”意味着算法在当前解的邻域中搜索新的解。例如，爬山法可以被认为是一种局部搜索技术，其中在每个迭代中考虑一个局部最大化标准或目标函数的新邻近解。爬山算法是一种贪婪算法，因为它只接受改进的解。这有时会导致它收敛到局部最优，除非搜索非常幸运，否则这些局部最优通常是平均解。解决方案的质量和计算时间通常取决于所选的局部移动。
- en: Local search algorithms have been successfully applied to solve many hard combinatorial
    optimization problems in reasonable time. Application domains include areas such
    as operations research, management science, engineering, and bioinformatics. The
    performance of LS-based approaches can be further enhanced by introducing mechanisms
    for escaping from local minima in the search space. These mechanisms include,
    but are not limited to, simulated annealing, random noise, mixed random walk,
    and tabu search. Tabu search was originally proposed to allow LS to overcome the
    difficulty of local optima and prevent cycling by allowing non-improving moves
    and memorizing the recent history of the search.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 局部搜索算法已被成功应用于在合理时间内解决许多困难的组合优化问题。应用领域包括运筹学、管理科学、工程和生物信息学等领域。通过引入从搜索空间中的局部最小值中逃逸的机制，可以进一步提高基于LS方法的性能。这些机制包括但不限于模拟退火、随机噪声、混合随机游走和禁忌搜索。禁忌搜索最初被提出是为了允许局部搜索克服局部最优的困难，并通过允许非改进移动和记住搜索的最近历史来防止循环。
- en: Let’s now discuss the various components of TS.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论TS的各个组成部分。
- en: 6.2 Tabu search algorithm
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 禁忌搜索算法
- en: Going back to our resort example, even if you enjoyed your first meal at a particular
    restaurant within the resort, you may opt to dine at a different one on the following
    day to explore other options and to avoid becoming trapped in a local optimum.
    Suppose you promise yourself not to dine at the same restaurant for several days
    so you can explore the other dining options at the resort. Once you have sampled
    various restaurants, you might opt to return to one of the restaurants you previously
    visited and dine there for the remainder of your stay. You apply tabu search by
    memorizing your impressions of each meal at each restaurant you try, and you can
    search for alternatives, taking into consideration your previously memorized favorites.
    This allows you to enhance your local search by using memory to explore the search
    space more flexibly and responsively beyond local optimality.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的度假村例子，即使你在度假村内的某个餐厅的第一顿饭很享受，你也可能会选择在第二天去不同的餐厅用餐，以探索其他选项并避免陷入局部最优。假设你承诺自己不会连续几天在同一个餐厅用餐，这样你就可以探索度假村的其他餐饮选择。一旦你尝试过各种餐厅，你可能会选择回到你之前访问过的其中一家餐厅，并在那里度过你剩余的时光。你通过记住你在尝试的每家餐厅的每顿饭的印象来应用禁忌搜索，并且你可以寻找替代方案，同时考虑你之前记住的喜好。这使你能够通过使用记忆来更灵活、更响应式地探索搜索空间，从而增强你的局部搜索，超越局部最优性。
- en: This example demonstrates that tabu search incorporates adaptive memory and
    responsive exploration. *Adaptive memory* involves remembering information that
    is relevant or useful during the search process, such as recent moves made by
    the algorithm and the promising solutions found. *Responsive exploration* is a
    problem-solving approach that adapts and adjusts the behavior of the solver based
    on new information and the search history to find superior solutions faster.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了禁忌搜索结合了自适应记忆和响应式探索。*自适应记忆*涉及在搜索过程中记住相关信息或有用信息，例如算法最近做出的移动和找到的有希望的解决方案。*响应式探索*是一种问题解决方法，它根据新信息和搜索历史调整求解器的行为，以更快地找到更优的解决方案。
- en: Tabu search
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 禁忌搜索
- en: “Tabu search is based on the premise that problem solving, in order to qualify
    as intelligent, must incorporate adaptive memory and responsive exploration. The
    adaptive memory feature of TS allows the implementation of procedures that are
    capable of searching the solution space economically and effectively. Since local
    choices are guided by information collected during the search, TS contrasts with
    memoryless designs that heavily rely on semi-random processes that implement a
    form of sampling. The emphasis on responsive exploration in tabu search, whether
    in a deterministic or probabilistic implementation, derives from the supposition
    that a bad strategic choice can often yield more information than a good random
    choice.” (From Glover, Laguna, and Marti, “Principles of tabu search” [2].)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “禁忌搜索基于这样一个前提，即为了成为智能的，问题解决必须结合自适应记忆和响应式探索。TS的自适应记忆功能允许实施能够经济有效地搜索解空间的程序。由于局部选择是由搜索过程中收集到的信息引导的，TS与依赖于半随机过程的记忆无设计形成对比，这些过程实现了一种采样形式。禁忌搜索中强调响应式探索，无论是在确定性还是概率实现中，都源于这样一个假设：一个糟糕的战略选择往往能提供比一个好的随机选择更多的信息。”（摘自Glover,
    Laguna和Marti的《禁忌搜索原理》[2]。）
- en: 'Tabu search is an iterative neighborhood search algorithm where the neighborhood
    changes dynamically. This algorithm was originally proposed to allow local search
    to overcome local optima. TS enhances local search by actively avoiding points
    in the search space already visited. By avoiding already visited points, loops
    in search trajectories are avoided and local optima can be escaped. Tabu search
    employs memory through a tabu list, which prohibits revisiting recently explored
    neighborhoods. This is done to avoid getting stuck in local optima. This combination
    can substantially increase the efficiency of solving some problems. The main feature
    of TS is the use of an explicit memory, which has two purposes: to avoid revisiting
    previously explored solutions and to explore unvisited regions of the solution
    space. The TS process starts with an initial randomized solution and then finds
    neighboring solutions. The best solution is then chosen and added to a tabu list.
    In subsequent iterations, tabu-active items are excluded as potential candidates
    unless enough time has elapsed and they can be reconsidered. This method helps
    prevent TS from getting stuck in local optima. Furthermore, to mitigate the effect
    of a tabu list excluding some good solutions, an aspiration criterion *A*(*s*)
    can be employed, which allows previously tabu moves to be reconsidered if they
    result in a better solution than the current best-known solution.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 禁忌搜索是一种迭代邻域搜索算法，其中邻域动态变化。该算法最初提出是为了允许局部搜索克服局部最优。TS 通过积极避免搜索空间中已访问的点来增强局部搜索。通过避免已访问的点，可以避免搜索轨迹中的循环并逃离局部最优。禁忌搜索通过禁忌列表使用记忆，禁止重新访问最近探索过的邻域。这样做是为了避免陷入局部最优。这种组合可以显著提高解决某些问题的效率。TS
    的主要特点是使用显式记忆，它有两个目的：避免重新访问先前探索过的解，并探索解空间中未访问的区域。TS 过程从初始随机解开始，然后找到邻近解。然后选择最佳解并将其添加到禁忌列表中。在后续迭代中，除非足够的时间已经过去并且它们可以重新考虑，否则排除禁忌活跃项作为潜在候选解。这种方法有助于防止
    TS 陷入局部最优。此外，为了减轻禁忌列表排除某些好解的影响，可以采用渴望标准 *A*(*s*)，它允许重新考虑先前禁忌的移动，如果它们导致比当前最佳已知解更好的解。
- en: Algorithm 6.2 shows how tabu search combines local search and memory structures.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 算法 6.2 展示了禁忌搜索如何结合局部搜索和记忆结构。
- en: Algorithm 6.2 Tabu search
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 算法 6.2 搜索禁忌算法
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As the algorithm shows, tabu search starts by using an initial feasible solution
    *s* and explores the search space iteratively to generate an optimal or near-optimal
    solution. At each iteration, and while the termination criteria are not met, the
    algorithm creates a candidate list of moves that lead to new solutions from the
    current solution within the neighborhood *N*(*s*). If the new solution *s’* is
    an improving solution that is not listed as tabu-active *T*(*s*) or is an admissible
    solution considering the aspiration criteria *A*(*s*), the obtained solution is
    designated as the new current solution. Admissibility is then revised by updating
    the tabu restrictions and aspiration criteria.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如算法所示，禁忌搜索首先使用一个初始可行解 *s*，然后迭代地探索搜索空间以生成最优或近似最优解。在每次迭代中，并且当终止条件未满足时，算法创建一个候选移动列表，该列表从当前解在邻域
    *N*(*s*) 内生成新的解。如果新解 *s’* 是一个改进的解，且未列为禁忌活跃 *T*(*s*) 或在考虑渴望标准 *A*(*s*) 的情况下是可接受的解，则获得的解被指定为新的当前解。然后通过更新禁忌限制和渴望标准来修订可接受性。
- en: Figure 6.1 summarizes the steps of TS in a flowchart. We start by obtaining
    a solution from initialization or from an intermediate or long-term memory component.
    We then create a candidate list of moves by applying an operator on the current
    solution, such as swapping, deleting and inserting, etc., depending on the nature
    of the problem at hand. These candidate neighboring solutions are evaluated, and
    the best admissible candidate is chosen. We keep updating the admissibility conditions,
    tabu restrictions, and aspiration criteria if the stopping criteria are not satisfied.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 以流程图的形式总结了禁忌搜索（TS）的步骤。我们首先从初始化或中间或长期记忆组件中获取一个解。然后，通过在当前解上应用操作员（如交换、删除和插入等），根据手头问题的性质创建候选移动列表。评估这些候选邻近解，并选择最佳可接受候选解。如果不满足停止条件，我们继续更新可接受条件、禁忌限制和渴望标准。
- en: '![](../Images/CH06_F01_Khamis.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F01_Khamis.png)'
- en: Figure 6.1 Tabu search steps (based on F. Glover’s “Tabu search and adaptive
    memory programming—advances, applications and challenges” [1])
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1禁忌搜索步骤（基于F. Glover的“禁忌搜索和自适应记忆编程——进展、应用和挑战” [1]）
- en: 'The following criteria may be used to terminate TS:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标准可以用来终止TS：
- en: The neighborhood is empty, meaning that all possible neighboring solutions have
    already been explored.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邻域为空，意味着已经探索了所有可能的邻近解。
- en: The number of iterations performed since the last improvement exceeds a specified
    limit.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自上次改进以来执行的迭代次数超过了一个指定的限制。
- en: There is external evidence that an optimal or a near-optimal solution has been
    reached.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有外部证据表明已经达到了一个最优或近似最优解。
- en: To gain a better understanding of the TS algorithm, let’s consider a simplified
    version of a symmetric traveling salesman problem (TSP) with only four cities,
    as illustrated in figure 6.2.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解TS算法，让我们考虑一个简化的对称旅行商问题（TSP）的版本，该版本只有四个城市，如图6.2所示。
- en: '![](../Images/CH06_F02_Khamis.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F02_Khamis.png)'
- en: Figure 6.2 A 4-city TSP. The weights on the edges of the graph represent the
    travel distances between the cities.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 一个4城市TSP。图中边的权重代表城市之间的旅行距离。
- en: A feasible solution can be represented as a sequence of cities or nodes where
    each city is visited exactly once. Assuming that the home city is city 1, an initial
    feasible solution can be selected randomly or using a greedy approach. A possible
    greedy approach is to choose the unvisited node closest to the current node and
    to continue this process until all nodes have been visited, resulting in a complete
    feasible tour that covers all nodes. This initial solution can be represented
    using permutation, such as {1,2,4,3}.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可行解可以表示为一系列城市或节点，其中每个城市恰好访问一次。假设家乡城市是城市1，一个初始可行解可以随机选择或使用贪婪方法选择。一种可能的贪婪方法是选择离当前节点最近的未访问节点，并继续此过程，直到所有节点都被访问，从而形成一个覆盖所有节点的完整可行旅行。这个初始解可以用排列表示，如{1,2,4,3}。
- en: 'To generate a neighboring solution, we can apply a swapping operator. The neighborhood
    represents a set of neighboring solutions that can be generated by a pairwise
    exchange of any two cities in the solution. For this 4-city TSP, and fixing node
    1 as the starting node or home city, the number of neighbors is the number of
    combinations without repetition *C*(*n*,*k*) or *n*-choose-*k*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成一个邻近解，我们可以应用一个交换算子。邻域代表一组可以通过交换解决方案中任意两个城市的成对交换生成的邻近解。对于这个4城市TSP，并且将节点1作为起始节点或家乡城市，邻域的数量是不重复组合数
    *C*(*n*,*k*) 或 *n*-choose-*k*：
- en: '![](../Images/CH06_F02_Khamis-EQ01.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F02_Khamis-EQ01.png)'
- en: 'Given the initial solution is {1,2,4,3}, the following three feasible neighboring
    solutions can be generated by applying the swapping operator:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 给定初始解为{1,2,4,3}，通过应用交换算子可以生成以下三个可行的邻近解：
- en: '{1,2,3,4} by swapping 3 and 4'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过交换3和4得到{1,2,3,4}
- en: '{1,3,4,2} by swapping 2 and 3'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过交换2和3得到{1,3,4,2}
- en: '{1,4,2,3} by swapping 2 and 4'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过交换2和4得到{1,4,2,3}
- en: At each iteration, the neighboring solution with the best objective value (minimum
    total distance) is selected.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，选择具有最佳目标值（最小总距离）的邻近解。
- en: 6.2.1 Memory structure
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 记忆结构
- en: 'Local search strategies are often memoryless ones that keep no record of their
    past moves or solutions. The main feature of TS is the use of an explicit memory.
    *Explicit memory* refers to a mechanism that remembers the moves that have been
    previously visited during the search process. A simple TS usually implements the
    following two forms of adaptive memory mechanisms:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 局部搜索策略通常是记忆无的，它们不保留过去移动或解决方案的记录。TS的主要特点是使用显式记忆。*显式记忆*指的是在搜索过程中记住之前访问过的移动的一种机制。简单的TS通常实现以下两种自适应记忆机制：
- en: '*A recency-based or short-term memory*—This is a mechanism that keeps track
    of recently visited moves during the search process. It plays a role in preventing
    the algorithm from revisiting moves that have been explored recently.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于最近或短期记忆*——这是一种在搜索过程中跟踪最近访问过的移动的机制。它在防止算法重新访问最近已探索的移动中发挥作用。'
- en: '*A frequency-based or long-term memory*—This is a mechanism that tracks the
    historical frequency of specific moves throughout the entire search process and
    penalizes moves that have been visited frequently without success or that have
    proven to be less promising.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于频率或长期记忆*——这是一种在整个搜索过程中跟踪特定移动的历史频率的机制，并惩罚那些频繁访问但没有成功或已被证明不太有希望的移动。'
- en: Memory types
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆类型
- en: 'According to the Atkinson–Shiffrin model (also known as the multi-store model
    or modal model), human memory has three components: sensory memory, working memory
    (sometimes called short-term memory), and long-term memory, as shown in the following
    figure.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据阿特金森-希夫林模型（也称为多存储模型或模式模型），人类记忆有三个组成部分：感觉记忆、工作记忆（有时称为短期记忆）和长期记忆，如图所示。
- en: Sensory memory is a very brief memory that automatically results from our perceptions
    and generally disappears after the original stimulus has ceased. Each of our five
    senses has a different memory store. For example, visual info is stored in iconic
    memory, while auditory info is stored in echoic memory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 感觉记忆是一种非常短暂的记忆，它自动由我们的感知产生，并在原始刺激停止后通常消失。我们的五种感官各有不同的记忆存储。例如，视觉信息存储在图像记忆中，而听觉信息存储在回声记忆中。
- en: The amount of information stored in short-term memory depends on the attention
    paid to the elements of sensory memory. Working memory is a more recent extension
    of the concept of short-term memory. This memory allows you to store and use the
    temporary information required to execute specific tasks. Rehearsal and repetition
    can help in increasing the duration of short-term memory. For example, imagine
    yourself as a customer-service associate in a fast food or beverage drive-thru,
    taking orders from customers and ensuring those orders are fulfilled. The order
    information provided by the customers is stored in your short-term or working
    memory, and once the order is fulfilled, this information is not kept in your
    memory.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 短期记忆中存储的信息量取决于对感觉记忆元素的关注程度。工作记忆是短期记忆概念的最新扩展。这种记忆允许你存储和使用执行特定任务所需的临时信息。复述和重复可以帮助增加短期记忆的持续时间。例如，想象你自己是一名快餐或饮料外卖窗口的客户服务代表，从客户那里接收订单并确保这些订单得到满足。客户提供的订单信息存储在你的短期或工作记忆中，一旦订单得到满足，这些信息就不会保留在你的记忆中。
- en: '![](../Images/CH06_F02_UN01_Khamis.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F02_UN01_Khamis.png)'
- en: Memory types
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆类型
- en: Long-term memory holds your lifelong memories and a vast amount of information,
    such as your birthday, your address, work skills you’ve learned, etc. Some important
    information captured by working memory can be encoded and stored in long-term
    memory. The purpose of encoding is to assign a meaning to the information being
    memorized. For example, you might encode the word “omelet” as “egg, beaten, fried.”
    If you could not recall the word “omelet” spontaneously, you can still retrieve
    it by invoking one of the indexes that you used to encode it, such as “egg.” This
    is similar to encoding information using a lookup table for quick information
    retrieval.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 长期记忆存储了你的终身记忆和大量信息，例如你的生日、你的地址、你学到的职业技能等。一些通过工作记忆捕获的重要信息可以被编码并存储在长期记忆中。编码的目的是为正在记忆的信息赋予意义。例如，你可能会将单词“omelet”编码为“鸡蛋，打散，煎”。如果你不能自发地回忆起“omelet”这个词，你仍然可以通过调用你用来编码它的一个索引来检索它，比如“鸡蛋”。这类似于使用查找表进行快速信息检索的编码方式。
- en: Figure 6.3 shows a knapsack problem as an example. In this problem, each item
    has a *utility* and a *weight*, and we want to maximize the utility of the contents
    of the knapsack without exceeding the maximum weight. The problem is constrained
    by the capacity of the knapsack. Neighboring solutions can be generated by swapping
    items in and out of the knapsack.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3展示了背包问题作为一个例子。在这个问题中，每个物品都有一个*效用*和一个*重量*，我们希望在不超出最大重量的情况下最大化背包内容的效用。这个问题受背包容量的限制。可以通过在背包中交换物品来生成相邻的解决方案。
- en: '![](../Images/CH06_F03_Khamis.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F03_Khamis.png)'
- en: Figure 6.3 A knapsack problem
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 背包问题
- en: As illustrated in figure 6.3, a new candidate solution can be generated by swapping
    items 1 and 4\. In this case, this swap will be tabu-active for the next three
    iterations, as shown in the tabu structure in the figure. *Tabu-active* moves
    are currently on the tabu list and cannot be selected for exploration in the current
    iteration. We could also generate neighboring solutions by adding or removing
    different items. If a neighborhood structure considers “add” and “remove” as separate
    moves, it might be a good idea to keep separate tabu lists for each type of move.
    Frequency-based memory keeps track of the frequency of the different swaps performed
    during a specified time interval. The idea is to penalize swaps that have been
    visited frequently.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如图6.3所示，可以通过交换1和4号项来生成一个新的候选解。在这种情况下，这种交换将在接下来的三次迭代中保持tabu状态，如图中的tabu结构所示。*tabu状态*的移动目前位于tabu列表中，不能在当前迭代中被选中进行探索。我们还可以通过添加或删除不同的项来生成邻近解。如果邻近结构将“添加”和“删除”视为独立的移动，那么为每种类型的移动保留单独的tabu列表可能是个好主意。基于频率的记忆跟踪在指定时间间隔内执行的不同交换的频率。其想法是对频繁访问的交换进行惩罚。
- en: The use of recency and frequency memory in TS serves primarily to prevent the
    searching process from cycling, which involves endlessly repeating the same sequence
    of moves or revisiting identical sets of solutions. Moreover, these two memory
    mechanisms play a role in achieving a trade-off between exploration and exploitation,
    as illustrated in figure 6.4.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在TS中使用最近和频率记忆主要为了防止搜索过程循环，这涉及到无限重复相同的移动序列或重新访问相同的解集。此外，这两种记忆机制在如图6.4所示的探索和利用之间起到权衡的作用。
- en: '![](../Images/CH06_F04_Khamis.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F04_Khamis.png)'
- en: Figure 6.4 TS short-term memory and long-term memory and the search dilemma
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 TS短期记忆和长期记忆以及搜索困境
- en: The recency-based memory restricts the search to within a set of potentially
    prosperous or elite solutions to intensify the search while avoiding repetition
    or reversal of previously visited solutions. Frequency-based memory emphasizes
    the frequency of different moves to guide the algorithm toward new regions in
    the search space that might have not been explored. By discouraging the repetition
    of recent moves, recency-based memory contributes to exploration to a certain
    extent, but the primary reinforcement for exploration comes from frequency-based
    memory. The interplay between these memory mechanisms maintains a balance, allowing
    the algorithm to efficiently navigate the feasible search space.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 基于最近记忆的记忆限制搜索在潜在繁荣或精英解集内，以增强搜索同时避免重复或逆转之前访问过的解。基于频率的记忆强调不同移动的频率，引导算法向搜索空间中可能尚未探索的新区域移动。通过阻止最近移动的重复，基于最近记忆的记忆在一定程度上促进了探索，但探索的主要强化来自基于频率的记忆。这些记忆机制之间的相互作用保持平衡，允许算法有效地导航可行搜索空间。
- en: For the 4-city TSP, a tabu structure can be used to represent both forms of
    memory, as shown in figure 6.5\. In recency-based memory, the tabu structure stores
    the number of iterations for which a given swap is prohibited.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于4城市TSP问题，可以使用tabu结构来表示这两种记忆形式，如图6.5所示。在基于最近记忆中，tabu结构存储了禁止给定交换的迭代次数。
- en: '![](../Images/CH06_F05_Khamis.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F05_Khamis.png)'
- en: Figure 6.5 Tabu structure for the 4-city TSP. The numbers in recency-based memory
    represent the number of iterations remaining for tabu-active moves; the numbers
    in long-term memory represent the frequency count of using the move.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 4城市TSP的tabu结构。基于最近记忆中的数字表示tabu状态的移动剩余的迭代次数；长期记忆中的数字表示使用该移动的频率计数。
- en: 'This recency-based memory mechanism is implemented using a tabu list as a data
    structure to keep track of the forbidden or tabu-active moves, preventing the
    algorithm from revisiting them for a specified number of iterations, called the
    *tabu tenure*. At each iteration, the tenure of each move already in the tabu
    list is decreased by 1, and those moves with zero tenure are dropped from the
    tabu list. The tabu tenure *T* can be chosen using different methods:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于最近记忆的机制通过使用tabu列表作为数据结构来跟踪禁止或tabu状态的移动，防止算法在指定数量的迭代中重新访问它们，这被称为*tabu任期*。在每次迭代中，tabu列表中每个移动的任期减少1，任期为零的移动将从tabu列表中删除。tabu任期*T*可以通过不同的方法选择：
- en: '*Static*—Choose *T* to be a constant, which may depend on the problem size,
    such as using guidelines like √N or N/10 iterations where *N* is the problem size.
    It has been shown that a static tabu tenure cannot always prevent cycling [3].'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*静态*—选择 *T* 为一个常数，这可能会依赖于问题大小，例如使用类似于 √N 或 N/10 迭代的指南，其中 *N* 是问题大小。已经证明，静态禁忌任期并不能总是防止循环[3]。'
- en: '*Dynamic*—Choose *T* to vary randomly between a specific range *T*[min] and
    *T*[max] following the search progress. The threshold *T*[min] and *T*[max] can
    vary based on how the solution is improving during a certain number of iterations.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态*—选择 *T* 在一个特定范围 *T*[min] 和 *T*[max] 内随机变化，这个范围随着搜索进程而变化。阈值 *T*[min] 和 *T*[max]
    可以根据在特定次数的迭代中解决方案的改进情况而变化。'
- en: In the previous 4-city TSP example (figure 6.2), let’s assume the tabu tenure
    is set as 3 iterations. If a solution is generated based on swap (1,4), this swap
    will be tabu-active for three iterations, meaning that it cannot be performed
    for the next three iterations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的4城市TSP示例（图6.2）中，假设禁忌任期设置为3次迭代。如果基于交换（1,4）生成解决方案，这个交换将在接下来的三次迭代中处于禁忌活跃状态，这意味着在接下来的三次迭代中不能执行这个交换。
- en: Frequency-based memory, shown in the lower-left corner of figure 6.5, contains
    values that correspond to the frequency count of the swap. Whenever a swap occurs
    between two cities, the frequency counters of the respective swap values in the
    frequency table will increase by 1\. When searching for the optimal solution,
    the values in the frequency counter are taken into account as a penalty for solutions
    which have been visited frequently. A penalized value directly proportional to
    the frequency count can be added to the cost or the fitness function of the solution.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 基于频率的记忆，如图6.5左下角所示，包含与交换频率计数相对应的值。每当两个城市之间发生交换时，频率表中相应交换值的频率计数器将增加1。在搜索最优解时，频率计数器中的值被视为对频繁访问的解决方案的惩罚。可以将与频率计数成正比的惩罚值直接添加到解决方案的成本或适应度函数中。
- en: 6.2.2 Aspiration criteria
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 渴望标准
- en: Avoiding tabu-active moves is necessary, but some of these moves may possess
    significant potential. In such instances, the tabu restrictions may hinder promising
    solutions, even in the absence of cycling risks. This problem is known as *stagnation*.
    In tabu search, stagnation can occur when the algorithm keeps rejecting candidate
    moves because they are tabu-active, and all tabu-inactive moves have already been
    explored or are non-improving moves. This can result in the algorithm revisiting
    the same solutions repeatedly without making any significant progress toward better
    solutions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 避免禁忌活跃移动是必要的，但其中一些移动可能具有显著潜力。在这种情况下，禁忌限制可能会阻碍有希望的解决方案，即使没有循环风险。这个问题被称为*停滞*。在禁忌搜索中，当算法因为候选移动是禁忌活跃的而持续拒绝它们，并且所有禁忌非活跃移动都已经探索过或都是非改进移动时，就会发生停滞。这可能导致算法反复访问相同的解决方案，而没有在向更好的解决方案取得任何重大进展。
- en: '*Aspiration criteria* can mitigate this stagnation by allowing the algorithm
    to consider moves that are tabu-active but that lead to better solutions than
    the current best solution. By temporarily lifting tabu conditions for certain
    attributes of the solution, the algorithm can explore new regions of the search
    space and potentially discover better solutions. A commonly used aspiration criterion
    in almost all tabu search implementations is to allow the tabu activation rule
    to be overridden if the move yields a solution better than the best obtained so
    far (the incumbent solution) and when few iterations are left before this tabu-active
    move will get out of the tabu list.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*渴望标准*可以通过允许算法考虑那些虽然禁忌但能带来比当前最佳解决方案更好的解决方案的移动来减轻这种停滞。通过暂时解除解决方案某些属性的禁忌条件，算法可以探索搜索空间的新区域，并可能发现更好的解决方案。在几乎所有禁忌搜索实现中，常用的渴望标准是允许如果移动产生比迄今为止获得的最佳解决方案（即现任解决方案）更好的解决方案，并且在距离这个禁忌活跃移动从禁忌列表中移除之前迭代次数很少时，可以覆盖禁忌激活规则。'
- en: 6.2.3 Adaptation in TS
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 TS中的适应性
- en: TS is applicable in both discrete and continuous solution spaces. For some complex
    problems, such as scheduling, quadratic assignment, and vehicle routing, tabu
    search obtains solutions that often surpass the best solutions previously found
    by other approaches. However, to achieve the best results, many parameters need
    to be carefully tuned, and the number of iterations required may also be large.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: TS适用于离散和连续解空间。对于一些复杂问题，如调度、二次分配和车辆路径问题，禁忌搜索获得的解通常优于其他方法之前找到的最佳解。然而，为了获得最佳结果，需要仔细调整许多参数，并且所需的迭代次数也可能很大。
- en: 'As is the case for all metaheuristics algorithms, a global optimum may not
    be found, depending on the parameter settings. TS parameters include the initial
    solution generation method (random, greedy, heuristic, etc.), tabu tenure, neighborhood
    structure, aspiration criteria, stopping criteria, and penalized value of the
    frequency count. These parameters can be pretuned or autotuned to improve the
    performance of TS. Parameter tuning refers to finding suitable values for the
    different algorithm parameters before the algorithm is run, but adaptation can
    also be done on the fly while the algorithm is running, following deterministic,
    adaptive, or self-adaptive approaches to balance exploration and exploitation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有元启发式算法，根据参数设置，可能无法找到全局最优解。TS参数包括初始解生成方法（随机、贪婪、启发式等）、禁忌任期、邻域结构、渴望标准、停止标准以及频率计数的惩罚值。这些参数可以通过预调优或自动调优来提高TS的性能。参数调优是指在算法运行之前找到不同算法参数的合适值，但也可以在算法运行时动态调整，采用确定性、自适应或自适应性方法来平衡探索和利用：
- en: '*Deterministic tuning* is when the control parameter is changed according to
    some deterministic update rule without taking into account any information from
    the search algorithm.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确定性调优*是指根据某些确定性更新规则改变控制参数，而不考虑搜索算法的任何信息。'
- en: '*Adaptive tuning* is when the update rule takes information from the search
    algorithm and changes the control parameter accordingly.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自适应调优*是指更新规则从搜索算法中获取信息并相应地改变控制参数。'
- en: '*Self-adaptive tuning* is when the update rule itself is adapted.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自适应性调优*是指更新规则本身进行适应性调整。'
- en: One of the most important parameters of TS is the tabu tenure. Figure 6.6 illustrates
    the effect of tabu tenure on the performance of TS. A tabu tenure that is too
    short may result in frequent cycling, where the algorithm performs the same moves
    or revisits the same solutions in a repetitive manner. This hinders the exploration
    of diverse areas in the solution space and may prevent the discovery of optimal
    or near-optimal solutions. Moreover, tabu tenures that are too short may lift
    restrictions on moves quickly, potentially causing the algorithm to overlook promising
    solutions that were temporarily deemed unfavorable. In contrast, a tabu tenure
    that is excessively long may lead to stagnation, where certain moves remain prohibited
    for an extended period. This can prevent the algorithm from exploring new regions
    of the solution space, potentially hindering the discovery of better solutions.
    Moreover, long tabu tenures increase the memory footprint of the algorithm, potentially
    leading to inefficiency and increased computational demands. This can be particularly
    problematic for large-scale problems.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: TS最重要的参数之一是禁忌任期。图6.6说明了禁忌任期对TS性能的影响。过短的禁忌任期可能导致频繁的循环，算法以重复的方式执行相同的移动或重新访问相同的解。这阻碍了在解空间中探索不同的区域，并可能阻止发现最优或近似最优解。此外，过短的禁忌任期可能会迅速解除对移动的限制，可能导致算法忽略那些暂时被认为不利的有希望的解。相反，过长的禁忌任期可能导致停滞，某些移动在较长时间内被禁止。这可能会阻止算法探索解空间的新区域，从而阻碍发现更好的解。此外，长的禁忌任期会增加算法的内存占用，可能导致效率低下和计算需求增加。这在大规模问题中尤其成问题。
- en: '![](../Images/CH06_F06_Khamis.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F06_Khamis.png)'
- en: Figure 6.6 Effect of tabu tenure
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 禁忌任期的效果
- en: One of the adaptive approaches incorporated into TS is to allow the length of
    the short-term memory (the tabu tenure) to vary dynamically and intensify the
    search when indicators identify promising regions or to promote diversification
    if the improvements seem to be minimal or a local optimum is detected. For example,
    you can set a lower bound *L*[min] and an upper bound *L*[max] for the tabu tenure.
    You can then decrement the tabu tenure by 1 if the solution has improved over
    the last iteration so the search will focus in a region of potential improvement.
    If the solution has deteriorated over the last iteration, you can increment the
    tabu tenure by 1 to guide the search away from an apparently bad region, as illustrated
    in figure 6.7\. The values of *L*[min] and *L*[max] can be randomly changed every
    specific number of iterations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: TS中纳入的一种自适应方法是允许短期记忆（禁忌期）的长度动态变化，并在指示器识别出有希望的领域时加强搜索，或者在改进似乎最小或检测到局部最优时促进多样化。例如，你可以为禁忌期设置一个下限**L**[min]和一个上限**L**[max]。然后，如果在上一个迭代中解决方案有所改进，你可以通过减去1来递减禁忌期，以便搜索将集中在潜在改进的区域。如果在上一个迭代中解决方案恶化，你可以通过增加1来递增禁忌期，以引导搜索远离显然不良的区域，如图6.7所示。**L**[min]和**L**[max]的值可以在每特定次数的迭代后随机更改。
- en: '![](../Images/CH06_F07_Khamis.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F07_Khamis.png)'
- en: Figure 6.7 Dynamically controlling the tabu tenure
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 动态控制禁忌期
- en: Reactive TS prevents the cycle occurrence by automatically learning the optimal
    tabu tenure [4]. In this approach, two possible reaction mechanisms are considered.
    An *immediate reaction mechanism* increases the tabu tenure to discourage additional
    repetitions. After a number of *R* immediate reactions, the geometric increase
    is sufficient to break any limit cycle. A second mechanism, called an *escape
    mechanism*, counts the number of moves that are repeated many times (more than
    *REP* times). When this number is greater than a predefined threshold *REP*, a
    diversifying escape movement is enforced. Other algorithm parameters, such as
    applying frequency-based memory or aspiration criterion, can be also considered
    when creating an adaptive version of tabu search.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 反应性TS通过自动学习最优禁忌期来防止循环发生[4]。在此方法中，考虑了两种可能的反应机制。一种称为**立即反应机制**，通过增加禁忌期来阻止额外的重复。经过若干次**R**立即反应后，几何增长足以打破任何极限循环。第二种机制，称为**逃逸机制**，计算重复多次（超过**REP**次）的移动次数。当这个数字超过预定义的阈值**REP**时，强制执行多样化的逃逸运动。在创建禁忌搜索的适应性版本时，也可以考虑其他算法参数，例如应用基于频率的记忆或渴望标准。
- en: Now that you have a good understanding of the various components of tabu search,
    let’s explore how this algorithm can be used to solve a variety of optimization
    problems.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经很好地理解了禁忌搜索的各个组成部分，让我们来探讨这个算法如何被用来解决各种优化问题。
- en: 6.3 Solving constraint satisfaction problems
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 解决约束满足问题
- en: 'The *n*-queens problem is a classic puzzle that involves placing *n* chess
    queens on an *n* × *n* chessboard in such a way that no two queens threaten each
    other. In other words, no two queens should share the same row, column, or diagonal.
    This is a constraint-satisfaction problem (CSP) that does not define an explicit
    objective function. Let’s suppose we are attempting to solve a 7-queens problem
    using tabu search. In this problem, the number of collisions in the initial random
    configuration shown in figure 6.8a is 4: {Q1–Q2}, {Q2–Q6}, {Q4–Q5}, and {Q6–Q7}.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**后问题是一个经典的谜题，它涉及将**n**个棋后放置在**n**×**n**的棋盘上，使得没有两个棋后相互威胁。换句话说，没有两个棋后应该共享同一行、列或对角线。这是一个不定义显式目标函数的约束满足问题（CSP）。假设我们正在尝试使用禁忌搜索解决7后问题。在此问题中，图6.8a中显示的初始随机配置中的冲突数为4：{Q1–Q2}，{Q2–Q6}，{Q4–Q5}和{Q6–Q7}。'
- en: '![](../Images/CH06_F08_Khamis.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F08_Khamis.png)'
- en: Figure 6.8 TS initialization for a 7-queens problem. At the left, the dotted
    lines show the 4 collisions between the queens. In the middle, C represents the
    column where a queen Q is placed. At the right, * denotes the swap that gives
    the best neighboring solution.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 7后问题的TS初始化。在左侧，虚线显示了皇后之间的4次冲突。在中间，C代表放置皇后Q的列。在右侧，*表示给出最佳邻近解的交换。
- en: The initial solution in figure 6.8a can be represented as the ordering shown
    in figure 6.8b. A number of candidate neighboring solutions can be generated by
    swapping as shown in figure 6.8c. Swaps (Q1,Q7), (Q2,Q3), (Q2,Q6), and (Q5,Q6)
    give the same value, so let’s assume that (Q1,Q7) is arbitrarily selected as a
    move that gives a new solution, which is shown in figure 6.9\. In the initial
    iteration, Q1 was placed in column 4, and Q7 was placed in column 2\. Swapping
    Q1 and Q7 means placing Q1 in column 2 and Q7 in column 4.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH06_F09_Khamis.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 A 7-queens problem—TS iteration 1
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The number of collisions is now reduced to 2, which are {Q2-Q6} and {Q4-Q5}.
    The tabu structure is updated as shown in figure 6.9c, forbidding the recently
    performed swap (Q1,Q7) for three iterations, assuming that the tabu tenure is
    3.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: In the next iteration, other neighboring solutions can be generated by swapping
    Q2 and Q4, as illustrated in figure 6.10\. Swap (Q2,Q4) gives a new candidate
    solution, as it reduces the collisions by 1\. The associated number of collisions
    for this solution is 1\. The tabu structure is updated, and the search continues.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH06_F10_Khamis.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 A 7-queens problem—TS iteration 2
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: In the next iteration (figure 6.11), swap (Q1,Q3) is selected as a move that
    gives a new solution.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH06_F11_Khamis.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 A 7-queens problem—TS iteration 3
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: In the new iteration (figure 6.12), swap (Q5,Q7) is selected. The *T* in figure
    6.12a denotes the tabu-active moves.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH06_F12_Khamis.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 A 7-queens problem—TS iteration 4
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: In the next iteration, the (Q4,Q7) swap is selected (figure 6.13).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH06_F13_Khamis.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 A 7-queens problem—TS iteration 5
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: In the next iteration, as the improving swaps are tabu-active, we can apply
    aspiration criteria to select swap (Q1,Q3) because there is only one iteration
    left before this swap is out of the tabu list (figure 6.14).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH06_F14_Khamis.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 A 7-queens problem—TS iteration 6
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Based on this solution, the board configuration will be as shown in figure 6.15\.
    This is one of various possible solutions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH06_F15_Khamis.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 A 7-queens solution generated by hand-iteration
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how we can use Python to solve this problem using tabu search.
    To begin, we’ll import the following Python libraries for random number generation
    and multi-dimensional arrays and plotting. Then we’ll define a function to generate
    a random configuration for a *n*-queens board, based on a predefined board size.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.1 Solving the 7-queens problem
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Assuming that the board size is 7, calling this function returns a random board
    configuration such as [0, 4, 1, 5, 6, 2, 3]. This means that Q1, Q2, Q3, Q4, Q5,
    Q6, and Q7 are placed in columns 1, 5, 2, 6, 7, 3, and 4 respectively.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then define a function to compute the number of queens that are attacking
    each other on the board. This function is defined as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义一个函数来计算棋盘上相互攻击的皇后的数量。此函数定义如下：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we can create a function to determine the best possible move that decreases
    the number of attacks on the board, while ensuring that the move is not currently
    on the tabu list (i.e., not tabu-active). This function is defined as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个函数来确定最佳可能的移动，该移动可以减少棋盘上的攻击次数，同时确保该移动当前不在禁忌列表上（即，不是禁忌活跃的）。此函数定义如下：
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you may have noticed, the best number of attacks is initialized as the maximum
    number of attacks, which is *n* * (*n* – 1) / 2. In a 7-queens problem, this number
    is 7 * 6 / 2 = 21.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，最佳攻击次数初始化为最大攻击次数，即 *n* * (*n* – 1) / 2。在7皇后问题中，这个数字是7 * 6 / 2 = 21。
- en: 'We also need to implement a function that updates the tabu list based on a
    predefined tabu tenure. Here is the definition of this function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要实现一个函数，根据预定义的禁忌任期更新禁忌列表。以下是此函数的定义：
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following function executes the steps of the tabu search, taking input
    parameters such as the maximum number of iterations, the tabu tenure, and the
    maximum number of moves without improvement before concluding that the solution
    is stuck, and the initial solution:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数执行禁忌搜索的步骤，接受如最大迭代次数、禁忌任期、在得出解决方案陷入停滞的结论之前，最大无改进移动次数以及初始解决方案等输入参数：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For a board size of 7, the maximum number of iterations is 2,000, the tabu tenure
    is 10, and the maximum number of moves without improvement before considering
    the solution to be stuck is 50\. Calling the tabu search gives the solution [5,
    1, 4, 0, 3, 6, 2], which is shown in figure 6.16.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于7大小的棋盘，最大迭代次数为2,000，禁忌任期是10，在考虑解决方案陷入停滞之前，最大无改进移动次数是50。调用禁忌搜索给出解决方案[5, 1,
    4, 0, 3, 6, 2]，如图6.16所示。
- en: '![](../Images/CH06_F16_Khamis.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F16_Khamis.png)'
- en: Figure 6.16 A 7-queens solution generated by Python code
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 由Python代码生成的7皇后解决方案
- en: The full code for this implementation can be found in listing 6.1 in the book’s
    GitHub repository. The number of iterations is used in the code as a stopping
    criterion. As an exercise, you can modify the code to add a stopping criterion
    that terminates the search once a solution with zero attacks has been found.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现的完整代码可以在本书GitHub仓库的列表6.1中找到。代码中使用的迭代次数作为停止标准。作为练习，你可以修改代码以添加一个停止标准，一旦找到零攻击的解决方案，就终止搜索。
- en: The *n*-queens problem is a discrete problem, as it involves finding a feasible
    configuration of chess queens on a discrete chessboard. In the following section,
    we’ll explore how tabu search can be applied to continuous problems in the form
    of function optimization.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: n皇后问题是一个离散问题，因为它涉及到在离散棋盘上找到棋后可行配置。在下一节中，我们将探讨禁忌搜索如何应用于连续问题，以函数优化形式。
- en: 6.4 Solving continuous problems
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 解决连续问题
- en: As an illustration of continuous problems, let’s begin with function optimization.
    The Himmelblau function (*f*(*x*,*y*) = (*x*² + *y* – 11)² + (*x* + *y*² – 7)²),
    named after David Mautner Himmelblau (1924–2011), is a multimodal function that
    is often used as a test problem for optimization algorithms. It is a nonconvex
    function with four identical local minima at (3.0, 2.0), (–2.805118, 3.131312),
    (–3.779310, –3.283186), and (3.584428, –1.848126), as shown in figure 6.17.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 作为连续问题的示例，让我们从函数优化开始。Himmelblau函数 (*f*(*x*,*y*) = (*x*² + *y* – 11)² + (*x*
    + *y*² – 7)²)，以David Mautner Himmelblau（1924–2011）的名字命名，是一个多模态函数，常被用作优化算法的测试问题。它是一个非凸函数，在(3.0,
    2.0)，(–2.805118, 3.131312)，(–3.779310, –3.283186)，和(3.584428, –1.848126)有四个相同的局部最小值，如图6.17所示。
- en: '![](../Images/CH06_F17_Khamis.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F17_Khamis.png)'
- en: Figure 6.17 Himmelblau’s function has four identical local minima at (3.0, 2.0),
    (–2.805118, 3.131312), (–3.779310, –3.283186), and (3.584428, –1.848126).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 Himmelblau函数在(3.0, 2.0)，(–2.805118, 3.131312)，(–3.779310, –3.283186)，和(3.584428,
    –1.848126)有四个相同的局部最小值。
- en: A generic Python implementation of tabu search is available as part of our optalgotools
    package. In this implementation, a hash table or dictionary as an indexed data
    structure is used to implement the tabu structure. A hashmap is a set of key–value
    pairs with no duplicate keys. It can be used to quickly retrieve data no matter
    how much data there is, as it has a big *O*(1) for add, get, and delete functions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 optalgotools 包中提供了一个通用的 Tabu 搜索的 Python 实现。在这个实现中，使用哈希表或字典作为索引数据结构来实现 Tabu
    结构。哈希表是一组键值对，没有重复的键。它可以用来快速检索数据，无论数据量有多大，因为它具有大 *O*(1) 的添加、获取和删除函数。
- en: 'The generic TS solver takes the following arguments:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通用 TS 求解器接受以下参数：
- en: Maximum number of iterations (default `max_iter=1000`)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大迭代次数（默认 `max_iter=1000`)
- en: Tabu tenure (default `tabu_tenure=1000`)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tabu tenure (默认 `tabu_tenure=1000`)
- en: Neighborhood size (default `neighbor_size=10`)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Neighborhood size (默认 `neighbor_size=10`)
- en: Aspiration criteria (default `use_aspiration=True`)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aspiration criteria (默认 `use_aspiration=True`)
- en: Remaining number of iterations to get out of tabu (default `aspiration_limit=None`)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余迭代次数以退出 Tabu（默认 `aspiration_limit=None`)
- en: Incorporating frequency-based memory (default `use_longterm=False`)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Incorporating frequency-based memory (默认 `use_longterm=False`)
- en: The next listing shows how we can solve the minimization problem of Himmelblau’s
    function using the generic tabu search solver implemented in optalgotools.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何使用在 optalgotools 中实现的通用 Tabu 搜索求解器来解决 Himmelblau 函数的最小化问题。
- en: Listing 6.2 Solving Himmelblau’s function using tabu search
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 使用 Tabu 搜索解决 Himmelblau 函数
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① Import the generic tabu search solver from optalgotools.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从 optalgotools 导入通用的 Tabu 搜索求解器。
- en: ② Import the continuous problem base
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ② 导入连续问题库
- en: ③ Define the objective function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义目标函数。
- en: ④ Define the bounds.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 定义边界。
- en: ⑤ Create a continuous function object.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建一个连续函数对象。
- en: ⑥ Define the TS solver. Add debug = 1 to print the initial and final solution.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 定义 TS 求解器。添加 debug = 1 以打印初始和最终解。
- en: ⑦ Run the solver.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 运行求解器。
- en: 'Running this code gives a potential solution for Himmelblau’s function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将为 Himmelblau 函数提供一个潜在解：
- en: '[PRE8]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Proper tuning of the various algorithm parameters allows you to find an optimal
    or near-optimal solution. Several other optimization test functions are available
    in appendix B. You may consider trying different functions by modifying listing
    6.2.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的调整各种算法参数可以使你找到最优或近似最优解。附录 B 中提供了其他几个优化测试函数。你可以通过修改列表 6.2 来尝试不同的函数。
- en: Next, let’s examine how tabu search can address the traveling salesman problem.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 Tabu 搜索如何解决旅行商问题。
- en: 6.5 Solving TSP and routing problems
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 解决 TSP 和路由问题
- en: Let’s look at using tabu search, implemented in Google OR-Tools, to solve the
    Berlin52 instance of TSP. This dataset contains 52 locations in the city of Berlin
    ([http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/STSP.html](http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/STSP.html)).
    The objective of the problem is to find the shortest possible tour that visits
    each location exactly once and then return to the starting location. The shortest
    route obtained for the Berlin52 dataset is 7,542, as explained in the previous
    chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用在 Google OR-Tools 中实现的 Tabu 搜索来解决 TSP 的 Berlin52 实例。这个数据集包含柏林市的 52
    个地点 ([http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/STSP.html](http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/STSP.html))。问题的目标是找到最短的旅行路线，该路线访问每个地点一次，然后返回起点。Berlin52
    数据集的最短路线是 7,542，如前一章所述。
- en: We’ll start by importing the TSP problem class, the OR-Tools constraint programming
    solver, and the protocol buffer module that defines various enumerations (`enums`)
    used in the routing library of OR-Tools. We’ll then create a `tsp` object from
    our generic `tsp` class implemented in `optalgotools`. We’ll extract points of
    interest, nodes, or cities and calculate pairwise distances. The pairwise distances
    will be converted into integers as required by OR-Tools. Then we’ll store the
    problem data in the form of a dictionary. In this dictionary, `distance_matrix`
    will represent the pairwise distances between the points of interest in the dataset.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入 TSP 问题类、OR-Tools 约束编程求解器和定义 OR-Tools 路由库中使用的各种枚举（`enums`）的协议缓冲模块。然后，我们将从
    `optalgotools` 中实现的通用 `tsp` 类创建一个 `tsp` 对象。我们将提取感兴趣的点、节点或城市并计算成对距离。成对距离将被转换为整数，以满足
    OR-Tools 的要求。然后，我们将问题数据以字典的形式存储。在这个字典中，`distance_matrix` 将表示数据集中感兴趣点之间的成对距离。
- en: Listing 6.3 Solving Belin52 TSP using OR-Tools tabu search
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 使用 OR-Tools 禁忌搜索解决 Belin52 TSP
- en: '[PRE9]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① Import the TSP problem class from optalgotools.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从 optalgotools 导入 TSP 问题类。
- en: ② Import the Python wrapper for the C++ constraint programming solver in OR-Tools.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ② 导入 OR-Tools 中 C++ 约束编程求解器的 Python 包装器。
- en: ③ Import the protocol buffer module.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 导入协议缓冲区模块。
- en: ④ Get berlin52 from a permalink.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 从永久链接获取 berlin52。
- en: ⑤ Create a different tsp object from the problem class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 从问题类创建不同的 tsp 对象。
- en: ⑥ Define the problem parameters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 定义问题参数。
- en: We need to create a routing model by defining `data`, an index manager (`manager`),
    and a routing model (`routing`). The pairwise distances between any two nodes
    will be returned by the `distance_callback` function, which also converts from
    the routing variable `Index` to the distance matrix `NodeIndex`. The cost of the
    edge joining any two points of interest in the dataset is computed using an arc
    cost evaluator that tells the solver how to calculate the cost of travel between
    any two locations.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过定义 `data`、索引管理器（`manager`）和路由模型（`routing`）来创建一个路由模型。任何两个节点之间的成对距离将由 `distance_callback`
    函数返回，该函数还将从路由变量 `Index` 转换到距离矩阵 `NodeIndex`。数据集中任何两个感兴趣点之间的边成本是通过弧成本评估器计算的，该评估器告诉求解器如何计算任何两个位置之间的旅行成本。
- en: 'The data model is where the distance matrix, number of vehicles, and home city
    or initial depot are defined:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型是定义距离矩阵、车辆数量和起始城市或初始仓库的地方：
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following function returns the pair-wise distance between any two nodes:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数返回任何两个节点之间的成对距离：
- en: '[PRE11]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The obtained route and its cost, or length, can be printed using the following
    function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下函数打印获得的路线及其成本或长度：
- en: '[PRE12]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let’s now look at how we can actually solve the TSP using the tabu search implemented
    in OR-Tools. We’ll start by using the preceding functions to create a data model,
    which generates the data necessary for the TSP, such as the distance matrix between
    the cities, the number of vehicles, and the home city or the initial depot.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用 OR-Tools 中实现的禁忌搜索算法来解决 TSP 问题。我们将首先使用前面的函数来创建一个数据模型，该模型生成 TSP 所需的数据，例如城市之间的距离矩阵、车辆数量以及起始城市或初始仓库。
- en: Next, we’ll define a manager to manage the indices of the routing problem. For
    this, we’ll use the `RoutingIndexManager` class from the `pywrapcp` module in
    the OR-Tools. This module provides a Python wrapper for the CP-SAT solver, a constraint
    programming solver developed by Google.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个管理器来管理路由问题的索引。为此，我们将使用 OR-Tools 中的 `pywrapcp` 模块中的 `RoutingIndexManager`
    类。此模块为 CP-SAT 求解器提供了一个 Python 包装器，CP-SAT 求解器是由 Google 开发的约束编程求解器。
- en: Then we’ll create the `RoutingModel` object by using the `RoutingIndexManager`
    object. This `RoutingModel` object is used to define the constraints and objectives
    of the capacitated vehicle routing problem (CVRP), which is considered a generalization
    of TSP. The `RegisterTransitCallback()` method will register a callback function
    that calculates the distance between two cities. This callback function is defined
    in the `distance_callback` function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用 `RoutingIndexManager` 对象创建 `RoutingModel` 对象。此 `RoutingModel` 对象用于定义容量车辆路径问题（CVRP）的约束和目标，CVRP
    被视为 TSP 的一般化。`RegisterTransitCallback()` 方法将注册一个回调函数，该函数计算两个城市之间的距离。此回调函数在 `distance_callback`
    函数中定义。
- en: The `SetArcCostEvaluatorOfAllVehicles()` method will set the arc cost evaluator
    of all the vehicles to the transit callback index, which calculates the distance
    between two nodes. In our case, we have a single traveling salesman or a single
    vehicle (so `num_vehicles=1`), but this code can also handle multiple TSP (mTSP)
    or multiple vehicles as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetArcCostEvaluatorOfAllVehicles()` 方法将所有车辆的弧成本评估器设置为传输回调索引，该索引计算两个节点之间的距离。在我们的情况下，我们有一个单独的旅行商或单一车辆（因此
    `num_vehicles=1`），但此代码也可以处理多个 TSP（mTSP）或多个车辆。'
- en: The `DefaultRoutingSearchParameters()` method will create an object of the `RoutingSearchParameters`
    class, which specifies the search parameters for solving the routing problem.
    In this case, the local search metaheuristic is set to tabu search, and the time
    limit is set to 30 seconds. Other available methods include `GREEDY_DESCENT`,
    `SIMULATED_ANNEALING`, and `GENERIC_TABU_SEARCH`. The main difference between
    `TABU_SEARCH` and `GENERIC_TABU_SEARCH` is in the way they handle the tabu list.
    `TABU_SEARCH` maintains a tabu list for each variable and applies tabu constraints
    to the current assignment. `GENERIC_TABU_SEARCH`, on the other hand, maintains
    a single tabu list for the entire search and applies tabu constraints to the moves
    made by the search.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultRoutingSearchParameters()` 方法将创建一个 `RoutingSearchParameters` 类的对象，该对象指定了解决路由问题的搜索参数。在这种情况下，局部搜索元启发式设置为禁忌搜索，时间限制设置为
    30 秒。其他可用方法包括 `GREEDY_DESCENT`、`SIMULATED_ANNEALING` 和 `GENERIC_TABU_SEARCH`。`TABU_SEARCH`
    和 `GENERIC_TABU_SEARCH` 之间的主要区别在于它们处理禁忌列表的方式。`TABU_SEARCH` 为每个变量维护一个禁忌列表，并将禁忌约束应用于当前分配。另一方面，`GENERIC_TABU_SEARCH`
    维护一个用于整个搜索的单个禁忌列表，并将禁忌约束应用于搜索所做的移动。'
- en: 'The `SolveWithParameters()` method solves the routing problem with the specified
    search parameters. If a solution is found, it calls the `print_solution()` function
    to print the solution:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`SolveWithParameters()` 方法使用指定的搜索参数解决路由问题。如果找到解决方案，它将调用 `print_solution()`
    函数来打印解决方案：'
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① Create the model.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建模型。
- en: ② Set TABU_SEARCH as the solver.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将 TABU_SEARCH 设置为求解器。
- en: ③ Find the solution.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 寻找解决方案。
- en: 'The following `get_routes()` function can then be called to extract the routes
    for each vehicle from the solution. This function iterates through each vehicle,
    starting with the start node, and adds the nodes visited by the vehicle until
    it reaches the end node. It then returns a list of routes for each vehicle:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `get_routes()` 函数可以调用以从解决方案中提取每辆车的路线。此函数遍历每辆车，从起始节点开始，并添加车辆访问的节点，直到达到终点节点。然后，它返回每辆车的路线列表：
- en: '[PRE14]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① Print the route.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ① 打印路线。
- en: ② Visualize the route.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ② 可视化路线。
- en: 'Running this code produces the following results and the route shown in figure
    6.18:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码产生以下结果，并在图 6.18 中显示了路线。
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](../Images/CH06_F18_Khamis.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F18_Khamis.png)'
- en: Figure 6.18 A TSP solution using the tabu search in OR-Tools. The graph shows
    the x and y locations of the points of interest included in the dataset in km.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18 使用 OR-Tools 中的禁忌搜索解决 TSP 问题。图中显示了包含在数据集中的感兴趣点的 x 和 y 位置（单位：公里）。
- en: The preceding implementation applies a simple aspiration criterion, where a
    solution is accepted if it is better than any other solution encountered so far.
    OR-Tools is very efficient in solving this problem (the obtained route length
    is 7,884, while the optimal solution is 7,542). However, the implemented tabu
    search is mainly used to solve routing problems.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实现应用了一个简单的渴望标准，即如果解决方案比迄今为止遇到的任何其他解决方案都好，则接受该解决方案。OR-Tools 在解决这个问题上非常高效（获得的路线长度为
    7,884，而最优解为 7,542）。然而，实现的禁忌搜索主要用于解决路由问题。
- en: 'As a continuation of listing 6.3, the following code snippet shows a generic
    tabu search solver in optalgotools that can be used to solve the same problem:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为列表 6.3 的延续，以下代码片段展示了 optalgotools 中的一个通用禁忌搜索求解器，可用于解决相同的问题：
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Create a TSP object for the problem.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为问题创建一个 TSP 对象。
- en: ② Create a TS object to help in solving the TSP problem.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个 TS 对象以帮助解决 TSP 问题。
- en: ③ Get an initial random solution, and check its length.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 获取一个初始随机解，并检查其长度。
- en: ④ Run TS, and evaluate the best solution distance.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 运行 TS，并评估最佳解决方案的距离。
- en: ⑤ Print the best route.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 打印最佳路线。
- en: ⑥ Print the route length.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 打印路线长度。
- en: ⑦ Visualize the best route.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 可视化最佳路线。
- en: 'Running this code produces the following results:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码产生以下结果：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, the obtained route length using our tabu search solver is 7,982.79,
    while the tabu search implemented in OR-Tools provides 7,884, and the optimal
    solution is 7,542\. The tabu search algorithm implemented in optalgotools is also
    slower than the optimized tabu search implemented in Google’s OR-Tools.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用我们的禁忌搜索求解器获得的路线长度为 7,982.79，而 OR-Tools 中实现的禁忌搜索提供的是 7,884，最优解为 7,542。optalgotools
    中实现的禁忌搜索算法也比 Google 的 OR-Tools 中实现的优化禁忌搜索慢。
- en: Let’s revisit the delivery semi-truck routing problem discussed in section 5.6\.
    In this problem, we need to find the optimal route for a delivery semi-truck to
    visit 18 Walmart Supercenters in a selected part of the Greater Toronto Area (GTA)
    starting from Walmart Supercenter number 3001, located at 270 Kingston Rd. E in
    Ajax, Ontario. The next listing shows how we can use the generic tabu search solver
    to handle this problem. A complete listing is available in the book’s GitHub repo.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在5.6节中讨论的配送半挂车路线规划问题。在这个问题中，我们需要找到一辆配送半挂车从位于安大略省Ajax的270 Kingston Rd.
    E的沃尔玛超级中心3001号开始，访问大多伦多地区（GTA）选定区域内的18个沃尔玛超级中心的最佳路线。下面的列表显示了我们可以如何使用通用的禁忌搜索求解器来处理这个问题。完整的列表可在本书的GitHub仓库中找到。
- en: Listing 6.4 Solving the delivery semi-truck problem using tabu search
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.4 使用禁忌搜索解决配送半挂车问题
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Create a TSP object for the problem.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为问题创建一个TSP对象。
- en: ② Create a TS object to help solve the TSP problem.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个TS对象以帮助解决TSP问题。
- en: ③ Get an initial random solution, and check its length.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 获取一个初始随机解，并检查其长度。
- en: ④ Draw the path of the random initial solution.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 绘制随机初始解的路径。
- en: ⑤ Run tabu search five times, and return the best solution.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 运行禁忌搜索五次，并返回最佳解决方案。
- en: ⑥ Print the best solution.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 打印最佳解决方案。
- en: ⑦ Print the best route length.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 打印最佳路线长度。
- en: ⑧ Visualize the obtained route.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 可视化获得的路线。
- en: The generated route for the delivery semi-truck problem is shown in figure 6.19.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 配送半挂车问题的生成路线如图6.19所示。
- en: '![](../Images/CH06_F19_Khamis.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F19_Khamis.png)'
- en: Figure 6.19 The TS solution for the Walmart delivery semi-truck route with a
    total distance of 223.53 km
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 沃尔玛配送半挂车路线的TS解决方案，总距离为223.53公里
- en: Tabu search generates a slightly shorter route (223.53 km) than simulated annealing
    (227.17 km). Compared to the tabu search algorithm implemented in OR-Tools, the
    tabu search algorithm in optalgotools gives you more freedom to tune more parameters
    and to handle different types of discrete and continuous problems.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 求解禁忌搜索算法生成的路线（223.53公里）比模拟退火算法（227.17公里）略短。与OR-Tools中实现的禁忌搜索算法相比，optalgotools中的禁忌搜索算法为你提供了更多的自由度来调整更多参数，并处理不同类型的离散和连续问题。
- en: In the next section, we will delve into another notable challenge that the manufacturing
    sector faces.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨制造业面临的另一个显著挑战。
- en: 6.6 Assembly line balancing problem
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 装配线平衡问题
- en: Henry Ford designed and installed an assembly line for car mass production in
    1913\. This development of assembly line manufacturing enabled mass production
    during the second industrial revolution and beyond. An *assembly line* is a flow-oriented
    production system where the productive units performing the operations, referred
    to as *workstations* or simply *stations*, are aligned sequentially. The work
    pieces visit the stations successively as they are moved along the line, usually
    by some kind of transportation system, such as a conveyor belt. At each workstation,
    new parts are added or new assemblies take place, resulting in a finished product
    at the end.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 亨利·福特于1913年设计和安装了用于汽车大批量生产的装配线。这种装配线制造的发展使得第二次工业革命及其之后的批量生产成为可能。*装配线*是一种面向流程的生产系统，其中执行操作的生产品单位，被称为*工作站*或简单地称为*站*，是按顺序排列的。工件沿着生产线依次经过各个工作站，通常是通过某种运输系统，如传送带。在每个工作站，添加新部件或进行新的组装，最终在生产线末端形成成品。
- en: 'For example, figure 6.20 shows an example of a bike assembly line with five
    workstations. Beginning at the initial workstation WS-1, workers focus on assembling
    the frame, laying the foundation for subsequent tasks. Moving along the line,
    WS-2 takes charge of installing the forks and handlebars, while WS-3 attaches
    the wheels. Following this, at WS-4, workers undertake the intricate assembly
    of crankset, chain, derailleurs, gears, and pedals. Finally, at WS-5, the seat
    is securely affixed and other accessories are added, completing the assembly process.
    Three lamps are used to indicate the status of operation of each workstation:
    emergency, finish, and work in progress (WIP).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，图6.20展示了具有五个工作站的自行车装配线示例。从初始工作站WS-1开始，工人专注于组装车架，为后续任务奠定基础。沿着生产线移动，WS-2负责安装前叉和把手，而WS-3则安装车轮。随后，在WS-4，工人进行曲柄、链条、变速器、齿轮和踏板的复杂组装。最后，在WS-5，座椅被牢固地固定，并添加其他附件，完成组装过程。使用三个灯来指示每个工作站的操作状态：紧急、完成和进行中（WIP）。
- en: '![](../Images/CH06_F20_Khamis.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F20_Khamis.png)'
- en: Figure 6.20 Assembly line balancing problem
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: It is crucial to optimize the design of an assembly line before implementing
    it, as assembly lines are designed to ensure high production efficiency, and reconfiguring
    them can result in significant investment costs. The assembly line balancing problem
    (ALBP) addresses the assignment of tasks (work elements) to workstations in order
    to minimize the amount of idle time of the line, while satisfying specific constraints.
    ALBP generally comprises all tasks and decisions related to equipping and aligning
    the productive units for a given production process before the actual assembly
    process can start. This encompasses setting the system capacity, which includes
    cycle time, number of stations, and station equipment, as well as assigning work
    content to productive units, which includes task assignment and determining the
    sequence of operations. This *balancing* of assembly lines is a difficult combinatorial
    optimization problem arising frequently in manufacturing.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Assembly line balancing problems can be categorized into two main groups: simple
    assembly line balancing problems (SALBPs) and generalized assembly line balancing
    problems (GALBPs). An SALBP involves the production of a single product in a serial
    line on one-sided workstations, while a GALBP considers different assembly line
    objectives, such as mixed model assembly lines, parallel lines, U-shaped lines,
    and two-sided lines.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: In SALBP, we have a number of tasks that need to be completed by a number of
    workstations. Each task *i* has a time requirement *t[i]*, and we are given a
    maximum number of workstations. Each workstation has a cycle time *C*, which refers
    to the time allocated for each station in the assembly line to complete its assigned
    tasks and pass the product to the next station. The goal is to minimize the number
    of workstations needed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: To capture more realistic conditions for ALBPs in industry, the time and space
    assembly line balancing problem (TSALBP) incorporates additional space constraints.
    A TSALBP involves assigning a set of *n* tasks with temporal and spatial attributes
    and a precedence graph. Each task must be assigned to only one station, provided
    that
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: All precedence constraints are met
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The workload time for each station does not exceed the cycle time
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The required space for each station does not exceed the global available space
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different variations on TSALBP with different levels of complexity are shown
    in table 6.1.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6.1 TSALBP variations: F (feasibility problem), OP (mono-objective optimization
    problem), MOP (multi-objective optimization problem)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '| Problem | # of stations | Cycle time | Space or layout of the stations |
    Type |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| TSALBP-F | Given | Given | Given | F |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| TSALBP-1 | Minimize | Given | Given | OP |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| TSALBP-2 | Given | Minimize | Given | OP |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| TSALBP-3 | Given | Given | Minimize | OP |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| TSALBP-1/2 | Minimize | Minimize | Given | MOP |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| TSALBP-1/3 | Minimize | Given | Minimize | MOP |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| TSALBP-2/3 | Given | Minimize | Minimize | MOP |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| TSALBP-1/2/3 | Minimize | Minimize | Minimize | MOP |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: In the bike assembly line illustrated in figure 6.20, installing the forks and
    handlebar depends on the availability of an assembled frame. Similarly, attaching
    the wheels depends on the frame and forks assembly being completed. This dependency
    is defined by a precedence diagram, which shows the relationships between tasks,
    indicating which tasks must be completed before others can begin. For example,
    task 2 should be performed before starting tasks 3 and 4, as per the precedence
    diagram depicted in figure 6.21\. In ALBPs, the sequence of the tasks should not
    violate the specified precedence due to the dependency relations between them.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH06_F21_Khamis.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 A precedence diagram
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple assembly line balancing problems can be classified into two types: type
    1 (SALBP-1) and type 2 (SALBP-2). Under type 1 (SALBP-1), the objective is to
    minimize the number of stations for a given cycle time. Conversely, under type
    2 (SALBP-2), the goal is to minimize the cycle time for a given number of stations.
    Let’s consider a type 1 (SALBP-1) problem that consists of minimizing the number
    of stations *NS* given fixed values of the cycle time *CT* and of the available
    area per station *A*. TSALBP-1 is equivalent to SALBP-1 if *A* → ∞. We’ll use
    smoothing index (SI) as a quantitative measure to evaluate the uniformity of workload
    distribution among the workstations. Each neighboring solution will be quantitatively
    evaluated using this SI. The SI aims to get the optimal task assignment for each
    station to minimize the idle time between stations, taking into account that the
    constraints imposed on the station’s workload cannot exceed the cycle time.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'SI is calculated as in equation 6.1:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH06_F21_Khamis-EQ02.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: '| 6.1 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: where
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: WL[i] is the workload of workstation *i*
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*WL*[max] is the maximum workload'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NS* is the number of stations'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks are assigned to the stations such that the workload doesn’t exceed the
    cycle time and without violating their precedence. Assume that the cycle time
    *CT* is 4 minutes and the number of tasks *n* is 6, with the precedence diagram
    given in figure 6.22.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH06_F22_Khamis.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: Figure 6.22 Precedence diagram example for six tasks
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Let’s perform hand iterations to understand how TS can be used to solve this
    problem, considering a tabu tenure of 3\. A random initial solution is generated,
    as shown in figure 6.23, and its SI is evaluated using equation 6.1\. The tabu
    structure or neighborhood can be defined as any other solution that is obtained
    by a pair-wise exchange of any two tasks in the solution. In our case, we have
    six tasks (i.e., *n* = 6) and a pairwise exchange (i.e., *k* = 2). So the maximum
    number of neighbors is the number of combinations without repetition *C*(*n*,*k*),
    or *n*-choose-*k*, or *n*! / *k*!(*n* – *k*)! = 6! / 2!4! = 15 neighbors. The
    solution is presented as a permutation of tasks. For example, the initial solution
    [1 2 3 4 5 6] reflects the order of execution of the six tasks, taking into consideration
    the precedence constraint.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH06_F23_Khamis.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: Figure 6.23 TS initialization for SALBP
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.24 shows the first iteration of TS for solving the SALBP. To generate
    a neighboring solution, we have to check the precedence diagram (figure 6.22).
    For example, for task 5 to start, both predecessor tasks 3 and 4 must have finished.
    Following this precedence diagram, when task 4 finishes, then both tasks 5 and
    6 can start.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the swap method to find a neighboring solution. For this iteration,
    the neighboring feasible solutions are (1-2), (2-3), (3-4), and (5-6). As the
    three swaps lead to the same SI, we can arbitrarily pick one, such as (1-2), that
    results in a new order of task execution (i.e., a new candidate solution). This
    solution is [2 1 3 4 5 6]. The (1-2) swap should be added to the tabu structure
    for three iterations, assuming that the tabu tenure is 3.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH06_F24_Khamis.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: Figure 6.24 TS iteration 1 for SALBP
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, figure 6.25 shows the second iteration of tabu search. For this
    iteration, the neighboring feasible solutions are (2-1), (2-3), (3-4), and (5-6).
    Note that the move (2-1) is tabu-active. The (3-4) swap is selected because it
    has the smallest SI. The new solution is [2 1 4 3 5 6] with SI = 0, calculated
    with equation 6.1.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH06_F25_Khamis.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: Figure 6.25 TS iteration 2 for SALBP
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The tabu list is updated before we start the next iteration, as shown in the
    figure. The next listing shows a snippet of the tabu search implementation for
    solving SALBP. A complete listing is available in the book’s GitHub repo.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.5 Solving SALBP using tabu search
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① Read data from appendix B directly.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the cycle time.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: ③ Get an initial solution.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: ④ Ensure the feasibility of the solution, considering the task precedence constraint.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Run the tabu search.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Calculate the SI of the best solution.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Visualize the solution.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code produces the following output:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Figure 6.26 shows the initial and the final solution found by tabu search with
    a fair load balance between the workstations.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH06_F26_Khamis.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: Figure 6.26 SALBP initial and final solutions
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now use the generic tabu search solver that’s implemented as part of our
    optalgotools package. There are several benchmark datasets for ALBPs. These datasets
    are available in appendix B of the book’s GitHub repo, and you can access them
    directly by using the URL to the raw content of the file, which can be obtained
    by using the “Raw” view in GitHub. Precedence graphs are provided in files with
    an .IN2 extension.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The next listing shows how to use the generic solver to solve the MANSOOR benchmark
    SALBP (best *NS* for a given *CT* = 48 is 4). The solution shows both the minimum
    number of workstations and the SI.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.6 Assembly line balancing problem benchmarking
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① Import the tabu search solver from optalgotools.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: ② Import the ALBP class from the generic problem class.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: ③ Define the URL of the datasets.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: ④ Create an ALBP instance.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Create an instance of the tabu search solver.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Solve the problem using tabu search.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Calculate the SI of the solution.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Print the results.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code gives the following results:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The complete listing in the book’s GitHub repo shows several different datasets,
    including the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: MITCHELL (best NS for a given CT = 26 is 5)
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SAWYER30 (best NS for a given CT = 26 is 10)
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HAHN (best NS for a given CT = 2338 is 7)
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GUNTHER (best NS for a given CT = 44 is 12)
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BUXEY (best NS for a given CT = 47 is 7)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LUTZ2 (best NS for a given CT = 11 is 49)
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BARTHOL2 (best NS for a given CT = 104 is 41)
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JACKSON (best NS for a given CT = 9 is 6)
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TONGE70 (best NS for a given CT = 293 is 13)
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That concludes the second part of this book. We’ll now shift our focus to evolutionary
    computation algorithms like genetic algorithms. These algorithms feature inherent
    parallelism and the capability to adapt their search for optimal solutions dynamically.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Local search iteratively explores a subset of the search space in the neighborhood
    of the current solution or state in order to improve the solution by making local
    changes.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tabu search extends local search by combining it with adaptive memory structures.
    It guides a local search procedure to explore the solution space beyond any local
    optimality.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adaptive memory structures are used to remember recent algorithm moves and capture
    promising solutions.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tabu list is a data structure that keeps track of tabu-active moves.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tabu tenure refers to the specified number of iterations for which certain moves
    or solutions are marked as tabu-active.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A too-short tabu tenure can result in cycling and the neglect of promising solutions,
    while a too-long tabu tenure may lead to stagnation and memory overload.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a way to avoid search stagnation, aspiration criteria allow tabu-active moves
    to be accepted by relaxing or temporarily lifting the tabu condition.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A crucial aspect of adaptive tabu search involves striking a balance between
    exploiting search and exploration.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
