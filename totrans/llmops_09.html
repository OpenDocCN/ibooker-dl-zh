<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 9. Scaling: Hardware, Infrastructure, and Resource Management"><div class="chapter" id="ch09_scaling_hardware_infrastructure_and_resource_ma_1748896826216961">
<h1><span class="label">Chapter 9. </span>Scaling: Hardware, Infrastructure, <span class="keep-together">and Resource Management</span></h1>

<p>Deploying<a contenteditable="false" data-primary="scaling" data-type="indexterm" id="icd901"/> and managing LLMs presents unique challenges and opportunities in the realm of infrastructure and resource management. LLMs, as you’ve seen throughout this book, are computationally intensive, requiring substantial hardware, storage, and network resources to operate efficiently. Whether you’re leveraging LLMs as a cloud-based service, deploying pretrained models in on-premises data centers, or training your own models from scratch, your infrastructure decisions will influence their performance, scalability, and cost-effectiveness.</p>

<p>Effective resource management for LLMs involves optimizing compute power, memory, and storage. In this chapter, we will explore the key components of infrastructure for LLMs, including hardware requirements and deployment strategies. We’ll also discuss best practices for optimizing resource use, managing costs, and maintaining reliability in production environments. This chapter will help you understand the trade-offs involved in managing resources for large-scale AI applications.</p>

<section data-type="sect1" data-pdf-bookmark="Choosing the Right Approach"><div class="sect1" id="ch09_choosing_the_right_approach_1748896826217183">
<h1>Choosing the Right Approach</h1>

<p>Selecting<a contenteditable="false" data-primary="scaling" data-secondary="choosing approach for" data-type="indexterm" id="id1282"/> the appropriate method for using LLMs depends on the requirements of the application that you want to use it for. For startups or small-scale applications, using models directly from the cloud may be the quickest and most cost-effective solution. For enterprises with specialized requirements or high workloads, deploying LLMs on cloud infrastructure can help you find an appropriate balance between flexibility and scalability. Finally, for organizations with strict data privacy or latency requirements, local deployment offers unmatched control and security, though at the cost of higher operational complexity.</p>

<p>By carefully evaluating the trade-offs of each approach, your organization can align its LLM deployment strategy with its technical and business objectives, ensuring efficient and effective use of these transformative AI technologies.</p>

<p>Regardless of the solution you choose, my suggestion is to always begin with a third-party API-based approach; that is, start by using models directly from the cloud. One of the major issues I’ve observed in real-world deployments is figuring out whether the LLM is a good solution to a given problem. Using a third-party, API-based approach will allow you to answer that question in a prototype before committing a large number of resources to infrastructure.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Scaling and Resource Allocation"><div class="sect1" id="ch09_scaling_and_resource_allocation_1748896826217247">
<h1>Scaling and Resource Allocation</h1>

<p>To <a contenteditable="false" data-primary="scaling" data-secondary="resource allocation and" data-type="indexterm" id="id1283"/>maintain performance, cost-effectiveness, and<a contenteditable="false" data-primary="resource allocation" data-type="indexterm" id="id1284"/> reliability in your LLM-based application, you’ll have to manage your resources well. Overallocating resources, especially those in high demand, such as the required GPUs and memory bandwidth to run AI systems, will lead to unnecessary expenses. Underallocating resources will expose you to risks of system crashes and poor user experiences.</p>

<p>Most training failures come from running out of memory and not compute. I call this the “iceberg problem” where the visible tip is the failure, but the real hidden issue is memory inefficiency beneath. Most people don’t realize that the real miss-out is when the suboptimal memory use goes unnoticed and under-utilized. Thus, people leave a lot of performance on the table. If you’re hitting memory walls, don’t reach for more hardware just yet. When used correctly, methods like sharding, activation checkpointing, dynamic batching, model offloading, etc., can easily make your 24 GB consumer GPU behave like a 48 GB A100.</p>

<p>The two main components of resource allocation are <em>monitoring</em> and <em>automating deployments</em>. You need to monitor in order to know when you are over- or underallocating resources. Then, once you have this information, you need to be able to react quickly. While it’s possible to live with manual deployments, the costs will likely become prohibitive over time. This is especially true if the demand for your service varies a lot, which could happen if your service achieves sudden success or expands to different geographical regions whose usage patterns reflect different time zones.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Monitoring"><div class="sect1" id="ch09_monitoring_1748896826217301">
<h1>Monitoring</h1>

<p>Monitoring <a contenteditable="false" data-primary="scaling" data-secondary="monitoring" data-type="indexterm" id="icd902"/><a contenteditable="false" data-primary="monitoring" data-type="indexterm" id="icd904x"/>enables you to understand your application’s behavior, optimize resource usage, and maintain high availability and performance under varying workloads. A successful monitoring approach revolves around tracking key performance indicators (KPIs) using the appropriate monitoring tools, then developing appropriate procedures to implement changes when needed.</p>

<p>Key metrics for<a contenteditable="false" data-primary="monitoring" data-secondary="metrics for" data-type="indexterm" id="id1285"/> monitoring include:</p>

<dl>
	<dt>Latency</dt>
	<dd>
	<p><em>Latency <a contenteditable="false" data-primary="latency" data-secondary="metrics for" data-type="indexterm" id="id1286"/></em>measures the response time for user queries and is shown to directly impact user satisfaction. Your goal is to minimize latency.</p>
	</dd>
	<dt>Throughput</dt>
	<dd>
	<p><em>Throughput</em>, <a contenteditable="false" data-primary="throughput" data-type="indexterm" id="id1287"/>or the number of requests processed in a period of time (usually per second), indicates the system’s capacity to handle demand and is critical to understand how your system is performing during peak loads.</p>
	</dd>
	<dt>Resource utilization metrics</dt>
	<dd>
	<p><em>Resource utilization metrics</em> such<a contenteditable="false" data-primary="resource utilization metrics" data-type="indexterm" id="id1288"/> as CPU, GPU, memory, disk I/O, and network bandwidth provide insights into which resources are and are not well allocated.</p>
	</dd>
	<dt>Error rates</dt>
	<dd>
	<p>Monitoring error rates<a contenteditable="false" data-primary="error rates" data-type="indexterm" id="id1289"/>, including server errors and application-specific issues like exceeding token limits or LLM safety responses, can help you identify issues before they become big problems.</p>
	</dd>
	<dt>Cost</dt>
	<dd>
	<p>Monitor <a contenteditable="false" data-primary="costs" data-secondary="monitoring" data-type="indexterm" id="id1290"/>cost to make sure your application is economically viable, especially for resource-intensive LLMs.</p>
	</dd>
</dl>

<p>Cloud environments offer numerous native <a contenteditable="false" data-primary="monitoring" data-secondary="tools for" data-type="indexterm" id="id1291"/>monitoring tools for these metrics that are tailored to their respective platforms, like AWS CloudWatch, Azure Monitor, and Google Cloud Operations Suite. These comprehensive tools enable you to track both standard and custom metrics, such as model-specific data like token usage or inference times.</p>

<p>Application performance-monitoring platforms like Datadog, New Relic, and AppDynamics go a step further by visualizing application dependencies, providing detailed insights into bottlenecks and potential failures. Model-specific platforms like Weights &amp; Biases and MLflow allow you to monitor LLM behavior, track fine-tuning iterations, and compare deployments.</p>

<p>For logging, centralized systems like the ELK Stack or Fluentd are valuable for capturing detailed application logs, query specifics, and system warnings; distributed tracing tools like OpenTelemetry or Jaeger let you trace requests across services to pinpoint latency hotspots.</p>

<p>A good monitoring architecture<a contenteditable="false" data-primary="monitoring" data-secondary="layers of" data-type="indexterm" id="id1292"/> will have at least three layers:</p>

<dl>
	<dt>Client layer</dt>
	<dd>
	<p>The client layer allows you to capture user-side performance and satisfaction metrics, often by asking users to rate an answer using a thumbs-up or a <span class="keep-together">thumbs-down.</span></p>
	</dd>
	<dt>Application layer</dt>
	<dd>
	<p>The application layer can focus on API performance, tracking throughput, processing times, and error rates.</p>
	</dd>
	<dt>Infrastructure layer</dt>
	<dd>
	<p>The infrastructure layer can monitor the underlying resources that host the LLM and your application, measuring CPU, GPU, memory, storage, and I/O <span class="keep-together">performance.</span></p>
	</dd>
</dl>

<p>Finally, you can treat the model as a separate fourth layer, depending on the kind of granularity you want. This is especially desirable for LLM-based applications. This <em>model layer</em> can track inference times, token usage, token caching, and other model-specific metrics, such as perplexity.</p>

<p>Real-time alerting can help automate issue detection. By setting thresholds for metrics like latency, resource utilization, and error rates, you can receive alerts by email or SMS when a specific metric falls below expected levels. It’s also a good idea to implement<a contenteditable="false" data-primary="synthetic monitoring" data-type="indexterm" id="id1293"/> <em>synthetic monitoring</em> by automatically sending your application some requests for which you know the expected answer and measuring the output.</p>

<p>When a threshold fails, you can set scripts to trigger automatically; for example, starting a new virtual machine if a current one hits some CPU- or memory-level threshold. You can also automatically run scripts to reduce downtime during common issues, such as restarting services periodically or scaling resources up or down based on anticipated demand.</p>

<p>The insights you derive from monitoring will be invaluable in optimizing your system. For<a contenteditable="false" data-primary="autoscaling" data-type="indexterm" id="id1294"/> instance, <em>autoscaling</em> mechanisms can adjust compute resources dynamically, based on workload demands. <em>Horizontal scaling</em> can accommodate more requests by adding instances, while <em>vertical scaling</em> increases the capacity of existing nodes. <em>Caching</em> <a contenteditable="false" data-primary="caching" data-secondary="monitoring and" data-type="indexterm" id="id1295"/>frequently accessed responses reduces latency and lessens the workload on the model, while <em>batching</em> low-priority queries enhances efficiency. Furthermore, techniques like model <a contenteditable="false" data-primary="distillation" data-type="indexterm" id="id1296"/>distillation and quantization<a contenteditable="false" data-primary="quantization" data-type="indexterm" id="id1297"/> (discussed in <a data-type="xref" href="ch05.html#ch05_model_domain_adaptation_for_llm_based_applications_1748896666813361">Chapter 5</a>) can optimize the model itself, balancing performance with resource consumption.</p>

<p>Monitoring is not a one-time setup but a continuous process of observability and refinement. Observability tools allow you to identify workload patterns, predict resource needs, and analyze trends in user interactions to refine both your infrastructure and your model’s performance. Advanced testing techniques, such as A/B and shadow testing, let you validate new deployments in a controlled manner, minimizing risks while introducing improvements. These are discussed in <a contenteditable="false" data-primary="monitoring" data-startref="icd904x" data-type="indexterm" id="id1298"/>the <a contenteditable="false" data-primary="scaling" data-secondary="monitoring" data-startref="icd902" data-type="indexterm" id="id1299"/>​next section.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="A/B Testing and Shadow Testing for LLMs"><div class="sect1" id="ch09_a_b_testing_and_shadow_testing_for_llms_1748896826217358">
<h1>A/B Testing and Shadow Testing for LLMs</h1>

<p>As <a contenteditable="false" data-primary="scaling" data-secondary="A/B testing" data-type="indexterm" id="id1300"/><a contenteditable="false" data-primary="A/B testing" data-type="indexterm" id="id1301"/><a contenteditable="false" data-primary="scaling" data-secondary="shadow testing" data-type="indexterm" id="id1302"/><a contenteditable="false" data-primary="shadow testing" data-type="indexterm" id="id1303"/>described in <a data-type="xref" href="ch07.html#ch07_evaluation_for_llms_1748896751667823">Chapter 7</a>, A/B testing is a widely used method for evaluating the performance of different versions of a system. In the LLM context, A/B testing involves deploying two versions of the LLM—often referred to as the “champion” (the existing model) and the “challenger” (the new model)—to determine which performs better under real-world conditions using the metrics described previously.</p>

<p>In contrast, <em>shadow testing</em> provides a safer, less intrusive way to evaluate a new model without directly affecting users. In this approach, the challenger model runs in the background, “shadowing” the champion model by processing the same inputs (or a fraction of them, for cost savings) but without influencing the live application’s <span class="keep-together">outputs.</span> This allows teams to collect performance data, identify potential issues, and fine-tune the challenger model before making it available to users. Shadow testing is particularly useful for testing LLMs in high-stakes or sensitive applications, such as customer service or healthcare, where introducing a flawed model could lead to significant negative consequences. Again, the better defined your metrics are, the more accurately you can see whether the new model performs better or worse than the existing one.</p>

<p>One caveat: in shadow testing, the users don’t see the output of the new model, so you can only collect their interactions with or feedback about the existing (champion) model. This makes A/B testing ideal for situations where user feedback is essential to evaluating performance, whereas shadow testing is better suited for testing infrastructure and ensuring a model’s reliability and safety <em>before</em> deployment.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Automatic Infrastructure Provisioning and Management"><div class="sect1" id="ch09_automatic_infrastructure_provisioning_and_manageme_1748896826217419">
<h1>Automatic Infrastructure Provisioning and Management</h1>

<p>Deploying<a contenteditable="false" data-primary="scaling" data-secondary="automatic infrastructure provisioning and management" data-type="indexterm" id="icd903"/><a contenteditable="false" data-primary="provisioning and management" data-type="indexterm" id="icd903a"/> and managing infrastructure for LLMs requires significant resources, whether in cloud architectures or on premises. Automatic infrastructure provisioning can help you optimize resource utilization, ensure scalability, and reduce operational overhead by dynamically adjusting your infrastructure to meet your model’s computational demands during training, fine-tuning, and inference based on monitoring signals.</p>

<section data-type="sect2" data-pdf-bookmark="Provisioning and Management in Cloud Architectures"><div class="sect2" id="ch09_provisioning_and_management_in_cloud_architectures_1748896826217492">
<h2>Provisioning and Management in Cloud Architectures</h2>

<p>The <a contenteditable="false" data-primary="scaling" data-secondary="automatic infrastructure provisioning and management" data-tertiary="in cloud architectures" data-tertiary-sortas="cloud architectures" data-type="indexterm" id="id1304"/><a contenteditable="false" data-primary="provisioning and management" data-secondary="in cloud architectures" data-secondary-sortas="cloud architectures" data-type="indexterm" id="id1305"/>major<a contenteditable="false" data-primary="cloud architectures" data-type="indexterm" id="id1306"/>​ cloud platforms offer tools for automatic infrastructure provisioning and management, including scalable compute instances,<a contenteditable="false" data-primary="GPUs (graphics processing units)" data-secondary="provisioning and management" data-type="indexterm" id="icd902x"/> GPU and TPU support, managed storage, and networking solutions tailored for AI workloads. Tools like AWS CloudFormation, Azure Resource Manager (ARM), and Google Cloud Deployment Manager allow you to<a contenteditable="false" data-primary="IaC (infrastructure as code)" data-type="indexterm" id="id1307"/><a contenteditable="false" data-primary="infrastructure as code (IaC)" data-type="indexterm" id="id1308"/> deploy <em>infrastructure as code</em> (IaC) and define infrastructure requirements like products, versions, and features in declarative YAML or JSON <span class="keep-together">templates.</span> These templates automate resource provisioning to keep environments consistent across multiple deployments.</p>

<p>One of the most significant advantages of cloud architectures is their ability to scale resources automatically based on demand. Services like AWS Auto Scaling, Azure Virtual Machine Scale Sets (VMSS), and Google Cloud Platform (GCP) Autoscaler can dynamically increase or decrease the number of compute instances based on predefined metrics, such as CPU usage, memory consumption, and GPU utilization. Linking one of these tools to your monitoring setup can really help you manage costs and latency. This elasticity is particularly useful for LLM inference, which consumes expensive resources quickly. You can also use your monitoring metrics to automatically scale down resources that are not being used and quickly scale up when needed.</p>

<p>Cloud providers also offer cost-saving options like AWS Spot Instances, Azure Spot VMs, and GCP preemptible VMs, which let you take advantage of unused capacity at a lower price. These are ideal for noncritical workloads, such as batch processing or distributed LLM training. However, because these instances can be interrupted, it’s critical to integrate their provisioning with your monitoring infrastructure to manage fault tolerance and job retries.</p>

<p>Finally, as we noted earlier, cloud-based monitoring tools like AWS CloudWatch, Azure Monitor, and GCP Operations Suite can track resource utilization, detect anomalies, and trigger automated actions. You can combine them with automation tools like AWS Lambda, Azure Functions, or GCP Cloud Functions to enable <em>self-healing </em>architectures. For example, if a GPU instance fails during an LLM training job, a function can automatically provision a replacement instance, then restart the job. These tools are very configurable. While you’re likely to use many preconfigured metrics as they are (such as those for CPU and memory usage), you should still configure custom metrics for your specific use case.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Provisioning and Management on Owned Hardware"><div class="sect2" id="ch09_provisioning_and_management_on_owned_hardware_1748896826217553">
<h2>Provisioning and Management on Owned Hardware</h2>

<p>For <a contenteditable="false" data-primary="scaling" data-secondary="automatic infrastructure provisioning and management" data-tertiary="in owned hardware" data-tertiary-sortas="owned hardware" data-type="indexterm" id="id1309"/><a contenteditable="false" data-primary="provisioning and management" data-secondary="in owned hardware" data-secondary-sortas="owned hardware" data-type="indexterm" id="id1310"/>organizations that choose to deploy LLMs on hardware they own themselves, whether on premises or in private clouds, automatic provisioning and management present unique challenges and opportunities. These setups often rely on virtualization technologies (like VMware, Proxmox, or Hyper-V) and containerization platforms (like Kubernetes or Docker Swarm) to orchestrate resources effectively.</p>

<p>Deploying LLMs on owned hardware often involves deciding between “bare metal” servers and virtualized environments. Bare metal offers better performance and is well suited for resource-intensive tasks like LLM training or fine-tuning, especially when paired with high-end GPUs like <a contenteditable="false" data-primary="NVIDIA GPUs" data-type="indexterm" id="id1311"/>NVIDIA A100s or H100s. However, virtualization provides greater flexibility, allowing multiple workloads to share resources. Tools like <a contenteditable="false" data-primary="Kubernetes" data-secondary="provisioning and management on owned hardware" data-type="indexterm" id="id1312"/>Kubernetes node pools can allocate GPU resources to pods dynamically, optimizing resource utilization across LLM workloads.</p>

<p>Just as in cloud environments, on-premises deployments can leverage IaC tools like Terraform, Ansible, and Chef to automate infrastructure provisioning. These tools enable the consistent configuration of servers, networking, and storage, ensuring reproducibility across environments. For example, you could use Terraform to define GPU-enabled nodes and Ansible to configure ML frameworks like PyTorch or TensorFlow on those nodes.</p>

<p>On-premises deployments require robust monitoring to track resource usage and performance. You can use open source tools like <a contenteditable="false" data-primary="Prometheus" data-type="indexterm" id="id1313"/>Prometheus and <a contenteditable="false" data-primary="Grafana" data-type="indexterm" id="id1314"/>Grafana to visualize metrics, while workload schedulers like <a contenteditable="false" data-primary="SLURM (Simple Linux Utility for Resource Management)" data-type="indexterm" id="id1315"/>SLURM (Simple Linux Utility for Resource Management) and <a contenteditable="false" data-primary="Kubernetes" data-type="indexterm" id="id1316"/>Kubernetes help allocate compute resources efficiently. For inference tasks, edge deployments may also benefit from low-latency scheduling algorithms to prioritize real-time requests.</p>

<p>Scaling on-premises infrastructure is more challenging than in the cloud, since it requires purchasing and provisioning additional hardware. Hybrid approaches—combining owned hardware with cloud resources—can address this limitation. For example, you might train your LLM using local GPUs but offload inference or testing workloads to the cloud during peak demand. <a contenteditable="false" data-primary="GPUs (graphics processing units)" data-secondary="provisioning and management" data-startref="icd902x" data-type="indexterm" id="id1317"/>However, hybrid architectures also present challenges; for example, your LLMOps engineer will need to configure the endpoints and parameters for when to send requests to different endpoints, as well as implement monitoring and automatic failure recovery. <a data-type="xref" href="#ch09_table_1_1748896826210123">Table 9-1</a> compares several aspects of managing<em> </em>LLMs in the cloud versus<a contenteditable="false" data-primary="cloud architectures" data-type="indexterm" id="id1318"/> on premises.</p>

<table id="ch09_table_1_1748896826210123">
	<caption><span class="label">Table 9-1. </span>Comparison of cloud and on-premises management</caption>
	<thead>
		<tr>
			<th>Aspect</th>
			<th>Cloud architectures</th>
			<th>Owned hardware</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="subheading">Scalability</td>
			<td>
			<p>Highly scalable with autoscaling tools</p>
			</td>
			<td>
			<p>Limited by hardware availability</p>
			</td>
		</tr>
		<tr>
			<td class="subheading">Up-front costs</td>
			<td>
			<p>Low up-front costs; pay-as-you-go model</p>
			</td>
			<td>
			<p>High up-front costs for hardware acquisition</p>
			</td>
		</tr>
		<tr>
			<td class="subheading">Operational costs</td>
			<td>
			<p>Variable costs based on usage</p>
			</td>
			<td>
			<p>Fixed costs for power, cooling, and maintenance</p>
			</td>
		</tr>
		<tr>
			<td class="subheading">Performance</td>
			<td>
			<p>High for training/inference with cloud GPUs</p>
			</td>
			<td>
			<p>High for specific workloads with bare metal</p>
			</td>
		</tr>
		<tr>
			<td class="subheading">Flexibility</td>
			<td>
			<p>Easy to provision and reconfigure resources</p>
			</td>
			<td>
			<p>Requires manual or automated reconfiguration</p>
			</td>
		</tr>
		<tr>
			<td class="subheading">Control</td>
			<td>
			<p>Limited to cloud provider’s offerings</p>
			</td>
			<td>
			<p>Full control over hardware and software stack</p>
			</td>
		</tr>
	</tbody>
</table>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Best Practices for Automatic Infrastructure Management"><div class="sect2" id="ch09_best_practices_for_automatic_infrastructure_manage_1748896826217608">
<h2>Best Practices for Automatic Infrastructure Management</h2>

<p>Combining<a contenteditable="false" data-primary="scaling" data-secondary="automatic infrastructure provisioning and management" data-tertiary="best practices for" data-type="indexterm" id="id1319"/><a contenteditable="false" data-primary="provisioning and management" data-secondary="best practices for" data-type="indexterm" id="id1320"/> the flexibility of cloud platforms with the control of owned hardware allows organizations to leverage the best of both worlds. A few best practices to implement are:</p>

<dl>
	<dt>Cloud bursting</dt>
	<dd>
	<p>With this common strategy, additional workloads are handled by the cloud during peak demand.</p>
	</dd>
	<dt>Using automation pipelines</dt>
	<dd>
	<p>Use IaC and CI/CD pipelines to automate deployment and updates. For instance, Jenkins or GitHub Actions can automate resource provisioning, LLM deployment, and inference tasks.</p>
	</dd>
	<dt>Optimizing for cost and performance</dt>
	<dd>
	<p>Whether in the cloud or on premises, monitoring tools and scheduling algorithms can help you balance cost and performance. Use the cost simulators provided by your cloud platform or benchmark tests for owned hardware to plan your deployments.</p>
	</dd>
	<dt>Designing for high availability and redundancy</dt>
	<dd>
	<p>Ensure that critical LLM applications are fault tolerant by deploying resources across multiple zones (in the cloud) or using redundant hardware (on premises). Implement automated failover mechanisms to minimize downtime.</p>
	</dd>
</dl>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Scaling Law and the Compute-Optimal Argument"><div class="sect2" id="ch09_scaling_law_and_the_compute_optimal_argument_1748896826217660">
<h2>Scaling Law and the Compute-Optimal Argument</h2>

<p>The <a href="https://oreil.ly/dLHHa">compute-optimal argument</a> is <a contenteditable="false" data-primary="scaling" data-secondary="automatic infrastructure provisioning and management" data-tertiary="scaling law and compute-optimal argument" data-type="indexterm" id="icd909"/><a contenteditable="false" data-primary="provisioning and management" data-secondary="scaling law and compute-optimal argument" data-type="indexterm" id="icd910"/><a contenteditable="false" data-primary="scaling" data-secondary="scaling laws" data-type="indexterm" id="icd911"/><a contenteditable="false" data-primary="compute-optimal argument" data-type="indexterm" id="icd912"/>a principle in ML model training that addresses the trade-off between model size (number of parameters) and the amount of data used for training, emphasizing finding a balance between these factors to optimize use of available computational power.</p>

<p>This principle was formalized by <a contenteditable="false" data-primary="DeepMind" data-type="indexterm" id="id1321"/>DeepMind’s<a contenteditable="false" data-primary="Chinchilla scaling law" data-type="indexterm" id="icd901x"/> Chinchilla scaling law, discussed in <a data-type="xref" href="ch05.html#ch05_model_domain_adaptation_for_llm_based_applications_1748896666813361">Chapter 5</a>, which revealed that many earlier LLMs, such as GPT-3, were <a contenteditable="false" data-primary="undertrained LLMs" data-type="indexterm" id="id1322"/>undertrained relative to their size. These models used a disproportionate amount of compute to scale their number of parameters but didn’t implement a corresponding increase in the volume of training data. This imbalance resulted in suboptimal performance because the models had a vast number of parameters but weren’t exposed to enough training data to find the optimal weights for those parameters.</p>

<p>The practical implication here is that, when allocating computational resources to train an LLM, you have to balance the model’s size with the amount of training data. That’s where the compute-optimal argument comes in. For instance, rather than building a massive model but training it with inadequate data, it may be a more effective use of resources to create a smaller model and train it more thoroughly on the same dataset.</p>

<p>A major benefit of training models with a compute-optimal balance is that they tend to require less retraining or fine-tuning for downstream tasks than overly large, undertrained models require. More modern default models like GPT-4 and newer versions of Claude and Gemini do apply the compute-optimal principle, making them better at general tasks and decreasing the need for custom fine-tuning.</p>

<p>Let’s work through a concrete example.</p>

<p>The Chinchilla scaling law suggests that for a compute budget <em>C</em>, the relationship between a model’s number of parameters <em>N</em> and the training data it uses <em>D</em> (measured in tokens) is:</p>

<div data-type="equation">
<math alttext="upper C proportional-to upper N times upper D">
  <mrow>
    <mi>C</mi>
    <mo>∝</mo>
    <mi>N</mi>
    <mo>×</mo>
    <mi>D</mi>
  </mrow>
</math>
</div>

<p>Here, the <math alttext="proportional-to">
  <mo>∝</mo>
</math> symbol means to “proportional to.”</p>

<p>Additionally:</p>

<div data-type="equation">
<math alttext="upper D proportional-to upper N">
  <mrow>
    <mi>D</mi>
    <mo>∝</mo>
    <mi>N</mi>
  </mrow>
</math>
</div>

<p>This means that <em>D</em> should scale approximately linearly with <em>N</em>. The optimal proportion between tokens and parameters is between 15 and 25; that is, the number of tokens should be between 15 and 25 times the number of <a contenteditable="false" data-primary="Chinchilla scaling law" data-startref="icd901x" data-type="indexterm" id="id1323"/>​parameters.</p>

<p>Suppose you have a compute budget of <math alttext="upper C equals 10 Superscript 23">
  <mrow>
    <mi>C</mi>
    <mo>=</mo>
    <msup><mrow><mn>10</mn></mrow> <mn>23</mn> </msup>
  </mrow>
</math> floating-point operations (FLOPs) and you want to train an LLM. Let’s explore two scenarios for that compute budget.</p>

<section data-type="sect3" data-pdf-bookmark="Scenario 1: Overprioritize model size"><div class="sect3" id="ch09_scenario_1_overprioritize_model_size_1748896826217715">
<h3>Scenario 1: Overprioritize model size</h3>

<p>Overprioritize model size by training a 200-billion-parameter model on 300 billion tokens of data:</p>

<div data-type="equation">
<math alttext="StartLayout 1st Row  upper N equals 200 times 10 Superscript 9 Baseline 2nd Row  upper D equals 300 times 10 Superscript 9 EndLayout">
  <mtable displaystyle="true">
    <mtr>
      <mtd columnalign="right">
        <mrow>
          <mi>N</mi>
          <mo>=</mo>
          <mn>200</mn>
          <mo>×</mo>
          <msup><mrow><mn>10</mn></mrow> <mn>9</mn> </msup>
        </mrow>
      </mtd>
    </mtr>
    <mtr>
      <mtd columnalign="right">
        <mrow>
          <mi>D</mi>
          <mo>=</mo>
          <mn>300</mn>
          <mo>×</mo>
          <msup><mrow><mn>10</mn></mrow> <mn>9</mn> </msup>
        </mrow>
      </mtd>
    </mtr>
  </mtable>
</math>
</div>

<p>Here, your <em>D</em>/<em>N</em> is 1.5 tokens per parameter, falling below the compute-optimal zone specified by the Chinchilla scaling law.</p>

<p>The compute required for training is proportional to <em>N × D</em>, and the exact proportionality <em>k</em> is unknown:</p>

<div data-type="equation">
<math alttext="upper C equals k times upper N times upper D">
  <mrow>
    <mi>C</mi>
    <mo>=</mo>
    <mi>k</mi>
    <mo>×</mo>
    <mi>N</mi>
    <mo>×</mo>
    <mi>D</mi>
  </mrow>
</math>
</div>

<p>Substituting <em>N</em> and <em>D</em>, we obtain:</p>

<div data-type="equation">
<math alttext="upper C equals k times left-parenthesis 200 times 10 Superscript 9 Baseline right-parenthesis times left-parenthesis 300 times 10 Superscript 9 Baseline right-parenthesis equals k times 6 times 10 Superscript 4 Baseline times 10 Superscript 18 Baseline equals 6 times 10 Superscript 22">
  <mrow>
    <mi>C</mi>
    <mo>=</mo>
    <mi>k</mi>
    <mo>×</mo>
    <mrow>
      <mo>(</mo>
      <mn>200</mn>
      <mo>×</mo>
      <msup><mrow><mn>10</mn></mrow> <mn>9</mn> </msup>
      <mo>)</mo>
    </mrow>
    <mo>×</mo>
    <mrow>
      <mo>(</mo>
      <mn>300</mn>
      <mo>×</mo>
      <msup><mrow><mn>10</mn></mrow> <mn>9</mn> </msup>
      <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mi>k</mi>
    <mo>×</mo>
    <mn>6</mn>
    <mo>×</mo>
    <msup><mrow><mn>10</mn></mrow> <mn>4</mn> </msup>
    <mo>×</mo>
    <msup><mrow><mn>10</mn></mrow> <mn>18</mn> </msup>
    <mo>=</mo>
    <mn>6</mn>
    <mo>×</mo>
    <msup><mrow><mn>10</mn></mrow> <mn>22</mn> </msup>
  </mrow>
</math>
</div>

<p>This fits within the compute budget of 10<sup>23</sup> FLOPS.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Scenario 2: Compute-optimal strategy"><div class="sect3" id="ch09_scenario_2_compute_optimal_strategy_1748896826217762">
<h3>Scenario 2: Compute-optimal strategy</h3>

<p>Use the compute-optimal strategy and train a smaller model of 50 billion parameters on 1 trillion (a thousand billion) tokens:</p>

<div data-type="equation">
<math alttext="StartLayout 1st Row  upper N equals 50 times 10 Superscript 9 Baseline 2nd Row  upper D equals 1 comma 000 times 10 Superscript 9 EndLayout">
  <mtable displaystyle="true">
    <mtr>
      <mtd columnalign="right">
        <mrow>
          <mi>N</mi>
          <mo>=</mo>
          <mn>50</mn>
          <mo>×</mo>
          <msup><mrow><mn>10</mn></mrow> <mn>9</mn> </msup>
        </mrow>
      </mtd>
    </mtr>
    <mtr>
      <mtd columnalign="right">
        <mrow>
          <mi>D</mi>
          <mo>=</mo>
          <mn>1</mn>
          <mo lspace="0%" rspace="0%">,</mo>
          <mn>000</mn>
          <mo>×</mo>
          <msup><mrow><mn>10</mn></mrow> <mn>9</mn> </msup>
        </mrow>
      </mtd>
    </mtr>
  </mtable>
</math>
</div>

<p>Here, your <em>D</em>/<em>N</em> is 20.</p>

<p>The compute required for training is:</p>

<div data-type="equation">
<math alttext="upper C equals k times left-parenthesis 50 times 10 Superscript 9 Baseline right-parenthesis times left-parenthesis 1 comma 000 times 10 Superscript 9 Baseline right-parenthesis equals k times 5 times 10 Superscript 4 Baseline times 10 Superscript 18 Baseline equals 5 times 10 Superscript 22">
  <mrow>
    <mi>C</mi>
    <mo>=</mo>
    <mi>k</mi>
    <mo>×</mo>
    <mrow>
      <mo>(</mo>
      <mn>50</mn>
      <mo>×</mo>
      <msup><mrow><mn>10</mn></mrow> <mn>9</mn> </msup>
      <mo>)</mo>
    </mrow>
    <mo>×</mo>
    <mrow>
      <mo>(</mo>
      <mn>1</mn>
      <mo lspace="0%" rspace="0%">,</mo>
      <mn>000</mn>
      <mo>×</mo>
      <msup><mrow><mn>10</mn></mrow> <mn>9</mn> </msup>
      <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mi>k</mi>
    <mo>×</mo>
    <mn>5</mn>
    <mo>×</mo>
    <msup><mrow><mn>10</mn></mrow> <mn>4</mn> </msup>
    <mo>×</mo>
    <msup><mrow><mn>10</mn></mrow> <mn>18</mn> </msup>
    <mo>=</mo>
    <mn>5</mn>
    <mo>×</mo>
    <msup><mrow><mn>10</mn></mrow> <mn>22</mn> </msup>
  </mrow>
</math>
</div>

<p>Not only does that fit within the compute budget of 10<sup>23</sup> FLOPS, but the <em>D</em>/<em>N</em> of 20 tokens per parameter also falls within the compute-optimal zone. This finding indicates that training a smaller model with more data will lead to better performance per unit of compute.</p>

<p>Scenario 2 is a better solution, because it ensures that every parameter has sufficient exposure to training data, reducing overfitting and <a contenteditable="false" data-primary="scaling" data-secondary="automatic infrastructure provisioning and management" data-startref="icd909" data-tertiary="scaling law and compute-optimal argument" data-type="indexterm" id="id1324"/><a contenteditable="false" data-primary="provisioning and management" data-secondary="scaling law and compute-optimal argument" data-startref="icd910" data-type="indexterm" id="id1325"/><a contenteditable="false" data-primary="scaling" data-secondary="scaling laws" data-startref="icd911" data-type="indexterm" id="id1326"/><a contenteditable="false" data-primary="compute-optimal argument" data-startref="icd912" data-type="indexterm" id="id1327"/>utilizing <a contenteditable="false" data-primary="provisioning and management" data-startref="icd903a" data-type="indexterm" id="id1328"/>resources <a contenteditable="false" data-primary="scaling" data-secondary="automatic infrastructure provisioning and management" data-startref="icd903" data-type="indexterm" id="id1329"/>​appropriately.</p>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Optimizing LLM Infrastructure"><div class="sect1" id="ch09_optimizing_llm_infrastructure_1748896826217813">
<h1>Optimizing LLM Infrastructure</h1>

<p>Deploying<a contenteditable="false" data-primary="scaling" data-secondary="optimizing infrastructure" data-type="indexterm" id="icd904"/> and managing LLMs efficiently requires infrastructure, of course, but optimizing it also requires software that takes advantage of that infrastructure. To meet the demands of LLM training and inference, techniques such as compilers; parallel and distributed computing; and frameworks <a contenteditable="false" data-primary="CUDA (Compute Unified Device Architecture)" data-type="indexterm" id="id1330"/><a contenteditable="false" data-primary="Compute Unified Device Architecture (CUDA)" data-type="indexterm" id="id1331"/><a contenteditable="false" data-primary="NVIDIA CUDA" data-type="indexterm" id="id1332"/>like CUDA (Nvidia’s Compute Unified Device Architecture), NCCL (NVIDIA Collective Communications Library)<a contenteditable="false" data-primary="NCCL (NVIDIA Collective Communications Library)" data-type="indexterm" id="id1333"/><a contenteditable="false" data-primary="NVIDIA Collective Communications Library (NCCL)" data-type="indexterm" id="id1334"/>, ZeRO (Zero Redundancy Optimizer)<a contenteditable="false" data-primary="ZeRO (Zero Redundancy Optimizer)" data-type="indexterm" id="id1335"/>, DeepSpeed<a contenteditable="false" data-primary="DeepSpeed" data-type="indexterm" id="id1336"/>, TF-Replicator<a contenteditable="false" data-primary="TF-Replicator" data-type="indexterm" id="id1337"/>, and Horovod <a contenteditable="false" data-primary="Horovod" data-type="indexterm" id="id1338"/>play critical roles. Another key aspect of optimization is fault tolerance and backup systems. In an ideal situation, all your resources would go toward enhancing performance, but in practice, some need to be used to ensure that your system can continue to operate (overhead costs).</p>

<p><em>Compilers</em> translate<a contenteditable="false" data-primary="compilers" data-type="indexterm" id="icd9029x"/> high-level code into machine instructions optimized for specific hardware architectures. For LLM workloads, which demand high computational efficiency, you need specialized compilers such as NVIDIA’s NVCC (for CUDA), TensorFlow’s XLA, or PyTorch’s TorchScript. These compilers focus on achieving three types of optimizations: kernel fusion, precision scaling, and hardware utilization. Let’s look at each type in turn.</p>

<section data-type="sect2" data-pdf-bookmark="Kernel Fusion"><div class="sect2" id="ch09_kernel_fusion_1748896826217863">
<h2>Kernel Fusion</h2>

<p><em>Kernel fusion </em>is<a contenteditable="false" data-primary="scaling" data-secondary="optimizing infrastructure" data-tertiary="kernel fusion" data-type="indexterm" id="id1339"/><a contenteditable="false" data-primary="kernel fusion" data-type="indexterm" id="id1340"/> a technique where multiple computational operations are combined into a single GPU kernel to reduce memory traffic and execution overhead. In deep-learning workflows, operations like matrix multiplications, element-wise additions, and activations often occur sequentially. Without kernel fusion, these operations would each involve separate memory read/write operations, “going out of the core” to save intermediate results and then “going out of the core” again to read these intermediate results. The repeated need to access global memory leads to latency and inefficiency. Compilers thus identify opportunities to combine (or <em>fuse</em>) these operations. The benefits of fusing include:</p>

<dl>
	<dt>Reduced memory access</dt>
	<dd>
	<p>Intermediate results are stored in faster, low-latency GPU registers or shared memory, rather than being written back to global memory.</p>
	</dd>
	<dt>Minimized kernel launch overhead</dt>
	<dd>
	<p>Each kernel launch has a computational overhead. Fused kernels require fewer launches, speeding up execution.</p>
	</dd>
	<dt>Improved cache efficiency</dt>
	<dd>
	<p>Fusion allows related operations to share data in memory more effectively, reducing cache misses.</p>
	</dd>
</dl>

<p>For example, a typical deep-learning evaluation sequence like <code>ReLU(Wx + b)</code>, where <code>W</code> and <code>b</code> are the weights and biases, can be fused into a single kernel that computes the matrix multiplication (<code>Wx</code>), adds the bias (<code>+b</code>), and applies the activation function (<code>ReLU</code>) without having to write each intermediate step in the global memory outside of the GPU.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Precision Scaling"><div class="sect2" id="ch09_precision_scaling_1748896826217909">
<h2>Precision Scaling</h2>

<p>Deep-learning<a contenteditable="false" data-primary="scaling" data-secondary="optimizing infrastructure" data-tertiary="precision scaling" data-type="indexterm" id="id1341"/><a contenteditable="false" data-primary="precision scaling" data-type="indexterm" id="id1342"/> workloads often involve numerical computations that don’t require high precision. <em>Precision scaling</em> enables models to use lower-precision formats like 16-bit floating point (FP16) or brain floating point (BF16) instead of the traditional 32-bit floating point (FP32) format. Compilers help by:</p>

<dl>
	<dt>Automating mixed-precision training</dt>
	<dd>
	<p>Compilers like NVIDIA’s APEX (for PyTorch) and TensorFlow’s Mixed Precision API automatically downscale certain operations to FP16 while maintaining critical operations (such as gradient accumulation) in FP32. This ensures numerical stability while reducing memory usage and speeding computation.</p>
	</dd>
	<dt>Leveraging specialized hardware</dt>
	<dd>
	<p>Modern GPUs<a contenteditable="false" data-primary="NVIDIA GPUs" data-type="indexterm" id="id1343"/> (like NVIDIA’s A100 or H100) include tensor cores optimized for lower precision. Compilers can translate high-level operations into instructions that specifically use these lower-precision cores, significantly speeding up matrix multiplications and other tensor operations while freeing up the higher-precision cores for operations that require them.</p>
	</dd>
	<dt>Enhancing memory efficiency</dt>
	<dd>
	<p>By reducing precision, models can consume less memory, which lets you use larger batch sizes or train on hardware with lower memory capacity.</p>
	</dd>
</dl>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Hardware Utilization"><div class="sect2" id="ch09_hardware_utilization_1748896826217955">
<h2>Hardware Utilization</h2>

<p>Efficient<a contenteditable="false" data-primary="scaling" data-secondary="optimizing infrastructure" data-tertiary="hardware utilization" data-type="indexterm" id="id1344"/><a contenteditable="false" data-primary="hardware utilization efficiency" data-type="indexterm" id="id1345"/> hardware utilization ensures that GPUs or other accelerators operate at their full potential, maximizing computational throughput. Modern hardware can include specialized units such as tensor cores, matrix multiplication units, and vector processors. Compilers map operations like general matrix multiplication to these specialized units, leveraging their high throughput and freeing more general resources for other tasks.</p>

<p><em>Instruction-level parallelism</em> is<a contenteditable="false" data-primary="instruction-level parallelism" data-type="indexterm" id="id1346"/> another way AI-specialized compilers can optimize hardware utilization. They can generate code that exploits parallelism at multiple levels, including at the thread level (using thousands of GPU threads) and the vector level.</p>

<p><em>AI-specialized compilers</em> know<a contenteditable="false" data-primary="AI (artificial intelligence)" data-secondary="AI-specialized compilers" data-type="indexterm" id="id1347"/><a contenteditable="false" data-primary="compilers" data-startref="icd9029x" data-type="indexterm" id="id1348"/> how memory is organized in modern GPUs and AI servers, so their memory hierarchies are especially efficient. They optimize the code to use shared memory, registers, and caches effectively and reduce reliance on the slower global memory.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Parallel and Distributed Computing for LLMs"><div class="sect1" id="ch09_parallel_and_distributed_computing_for_llms_1748896826218007">
<h1>Parallel and Distributed Computing for LLMs</h1>

<p>Large-scale<a contenteditable="false" data-primary="scaling" data-secondary="optimizing infrastructure" data-tertiary="parallel and distributed computing" data-type="indexterm" id="icd905"/><a contenteditable="false" data-primary="parallelization" data-type="indexterm" id="icd907"/><a contenteditable="false" data-primary="distributed computing" data-type="indexterm" id="icd908"/> LLMs require parallel and distributed computing to manage their immense computational and memory demands. Techniques like <em>data parallelism</em>, <em>model parallelism</em>, and <em>pipeline parallelism</em> distribute the workload across multiple processors or nodes to use hardware resources efficiently. The building blocks of these techniques are<a contenteditable="false" data-primary="NCCL (NVIDIA Collective Communications Library)" data-type="indexterm" id="id1349"/><a contenteditable="false" data-primary="NVIDIA Collective Communications Library (NCCL)" data-type="indexterm" id="id1350"/><a contenteditable="false" data-primary="CUDA (Compute Unified Device Architecture)" data-type="indexterm" id="id1351"/><a contenteditable="false" data-primary="Compute Unified Device Architecture (CUDA)" data-type="indexterm" id="id1352"/><a contenteditable="false" data-primary="NVIDIA CUDA" data-type="indexterm" id="id1353"/> the CUDA and NCCL frameworks.</p>

<p>NVIDIA’s CUDA is the cornerstone of GPU-based acceleration, providing APIs for high-performance parallel computing. It lets developers write code that directly utilizes GPUs’ processing power, which is critical for LLM tasks like matrix multiplication, attention mechanisms, and gradient computations. Even very small language models depend on CUDA to run with acceptable performance.</p>

<p class="pagebreak-before">The NCCL complements CUDA by optimizing communication among multiple GPUs. It provides primitives for data movement, such as <code>all-reduce</code>, <code>all-gather</code>, and <code>broadcast</code>, ensuring minimal latency and high bandwidth. This is particularly important in distributed training, where model gradients frequently need to be synchronized between GPUs. As models grow, they tend to require multiple GPUs, and NCCL provides APIs that let different GPUs communicate.</p>

<section data-type="sect2" data-pdf-bookmark="Data Parallelism"><div class="sect2" id="ch09_data_parallelism_1748896826218056">
<h2>Data Parallelism</h2>

<p><em>Data parallelism</em> involves<a contenteditable="false" data-primary="data parallelism" data-type="indexterm" id="id1354"/> splitting training dataset into chunks, each corresponding to a device (such as a GPU or TPU). Each device processes its own chunk in parallel during a training iteration. You then place an identical copy of the model on each device, which computes the gradients for its chunk of data. Next, the gradients are averaged and synchronized across devices, using communication primitives like <code>all-reduce</code>, and the averaged gradients are applied to update the model’s parameters on each device.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Model Parallelism"><div class="sect2" id="ch09_model_parallelism_1748896826218103">
<h2>Model Parallelism</h2>

<p><em>Model parallelism</em> divides<a contenteditable="false" data-primary="model parallelism" data-type="indexterm" id="id1355"/> the model itself across multiple devices, making each device responsible for a portion of the model, such as a few layers (or operations). This is useful when the model is too large to fit on a single device. You then pass the input through the model sequentially, moving intermediate outputs between devices as needed; this is called a <em>forward pass</em>. Next, in a <em>backward pass</em>, you compute the gradients for each layer in reverse order. This helps to synchronize across devices for gradient flow. Finally, parameters are updated, either independently on each device or via a central parameter server.</p>

<p>Model parallelism optimizes memory but at the cost of throughput; while one device works on an input, the other devices wait.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Pipeline Parallelism"><div class="sect2" id="ch09_pipeline_parallelism_1748896826218150">
<h2>Pipeline Parallelism</h2>

<p><em>Pipeline parallelism</em> also<a contenteditable="false" data-primary="pipeline parallelism" data-type="indexterm" id="id1356"/> divides the model, assigning different layers to different devices, much like in model parallelism. However, in pipeline parallelism, the data batches are broken up into smaller pieces so that as many devices as possible are occupied at any given time. This requires additional communication but reduces idle compute time.</p>

<p class="pagebreak-before"><a data-type="xref" href="#ch09_figure_1_1748896826206032">Figure 9-1</a> shows an example of implementing pipeline parallelism with four devices and breaking the batch data into four micro-batches.</p>

<figure><div id="ch09_figure_1_1748896826206032" class="figure"><img alt="" src="assets/llmo_0901.png" width="1336" height="377"/>
<h6><span class="label">Figure 9-1. </span>Implementing pipeline parallelism</h6>
</div></figure>

<p>Pipeline parallelism is very effective in speeding up the training of models with a smaller hardware footprint, but it used to be hard to implement. In 2022, Meta released Pipeline Parallelism for PyTorch, or <a href="https://oreil.ly/g5EZ3">PiPPy</a>. PiPPy was merged into the main PyTorch distribution as the <code>torch.distributed.pipelining</code> subpackage and no longer requires a separate <a contenteditable="false" data-primary="scaling" data-secondary="optimizing infrastructure" data-startref="icd905" data-tertiary="parallel and distributed computing" data-type="indexterm" id="id1357"/><a contenteditable="false" data-primary="parallelization" data-startref="icd907" data-type="indexterm" id="id1358"/><a contenteditable="false" data-primary="distributed computing" data-startref="icd908" data-type="indexterm" id="id1359"/>installation.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Advanced Frameworks: ZeRO and DeepSpeed"><div class="sect1" id="ch09_advanced_frameworks_zero_and_deepspeed_1748896826218202">
<h1>Advanced Frameworks: ZeRO and DeepSpeed</h1>

<p>Developed<a contenteditable="false" data-primary="scaling" data-secondary="optimizing infrastructure" data-tertiary="ZeRO and DeepSpeed" data-type="indexterm" id="id1360"/><a contenteditable="false" data-primary="ZeRO (Zero Redundancy Optimizer)" data-type="indexterm" id="id1361"/><a contenteditable="false" data-primary="DeepSpeed" data-type="indexterm" id="id1362"/> by Microsoft, ZeRO minimizes memory overhead during training by partitioning model states (like parameters, gradients, and optimizer states) across devices. This lets you train models with tens or even hundreds of billions of parameters without requiring GPUs with excessive memory capacities.</p>

<p>Built on top of ZeRO, DeepSpeed is a deep-learning optimization library that makes training large models more efficient. It provides features like mixed-precision training, gradient accumulation, and memory optimization, significantly reducing training time and cost.</p>

<p><a data-type="xref" href="#table0902">Table 9-2</a> summarizes when to use each technique mentioned.</p>

<table id="table0902">
		<caption><span class="label">Table 9-2. </span>A comparison of different memory optimization techniques</caption>
<thead>
    <tr>
      <th>Technique</th>
      <th>The problem it solves</th>
      <th>How it works</th>
      <th>Trade-off</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Sharding</td>
      <td>Model too big for one GPU</td>
      <td>Split model weights/layers across multiple GPUs</td>
      <td>Increased complexity in syncing and communication</td>
    </tr>
    <tr>
      <td>Activation checkpointing</td>
      <td>High memory use during backprop</td>
      <td>Save only key activations and recompute the rest later</td>
      <td>Extra compute time</td>
    </tr>
    <tr>
      <td>Dynamic<br/>batching</td>
      <td>Wasted compute on small requests</td>
      <td>Group inputs on the fly to maximize GPU use</td>
      <td>Slight response delay</td>
    </tr>
    <tr>
      <td>Model<br/>offloading</td>
      <td>GPU can’t hold entire model</td>
      <td>Move unused parts to CPU or disk; fetch when needed</td>
      <td>Slower due to transfer time</td>
    </tr>
    <tr>
      <td>Mixed precision training</td>
      <td>Activations and weights take too much space</td>
      <td>Use lower-precision (e.g., FP16) instead of FP32</td>
      <td>Slight loss in numerical accuracy (often negligible)</td>
    </tr>
    <tr>
      <td>Quantization</td>
      <td>Models are too large for deployment</td>
      <td>Compress weights to 8-bit or lower</td>
      <td>Potential accuracy loss if not careful</td>
    </tr>
    <tr>
      <td>Gradient accumulation</td>
      <td>Batch size too big for GPU</td>
      <td>Split one big batch into smaller chunks and accumulate gradients</td>
      <td>Slower iteration time</td>
    </tr>
    <tr>
      <td>Zero Redundancy Optimizer (ZeRO)</td>
      <td>Redundant optimizer state across GPUs</td>
      <td>Partition optimizer state and gradients across devices</td>
      <td>Complexity and comm overhead</td>
    </tr>
    <tr>
      <td>Operator fusion</td>
      <td>Too many small intermediate tensors</td>
      <td>Combine multiple ops into one to reduce memory ops</td>
      <td>Needs compiler/tooling support</td>
    </tr>
    <tr>
      <td>Paged attention (for inference)</td>
      <td>Memory spikes from long contexts</td>
      <td>Stream key–value cache in and out like virtual memory</td>
      <td>Requires smart scheduling</td>
    </tr>
  </tbody>
</table>


<section data-type="sect2" data-pdf-bookmark="Backup and Failsafe Processes for LLM Applications"><div class="sect2" id="ch09_backup_and_failsafe_processes_for_llm_applications_1748896826218259">
<h2>Backup and Failsafe Processes for LLM Applications</h2>

<p>In <a contenteditable="false" data-primary="scaling" data-secondary="optimizing infrastructure" data-tertiary="backups and restores" data-type="indexterm" id="icd906"/><a contenteditable="false" data-primary="backups and restores" data-type="indexterm" id="icd906a"/>LLM applications, the LLMOps engineer is usually responsible for managing backups. Failures do happen, due to hardware malfunctions, software issues, or even malicious activity. LLM engineers can mitigate risk with robust backup and failsafe strategies to ensure continuity and minimize downtime.</p>

<p>The name of these activities can be misleading. Having a well-documented, regularly tested restore strategy is just as important as having good backups. It’s far too common for longtime practitioners to have “war stories” of occasions when backups were done for years but never tested and that, when actually required, did not work.</p>

<p>Which artifacts the LLMOps engineer backs up will vary, depending on the stage of the model and application lifecycle. During development, the most common artifacts to back up are the training data and intermediate model weights (model checkpoints), as well as the files describing the training as infrastructure as code. Datasets for training and model checkpoints tend to be very large, while the <a contenteditable="false" data-primary="IaC (infrastructure as code)" data-type="indexterm" id="id1363"/><a contenteditable="false" data-primary="infrastructure as code (IaC)" data-type="indexterm" id="id1364"/>IaC files tend to be small.</p>

<p>As the application moves to production, the IaC files representing the production architecture should be backed up, as well as user data (such as query logs and personalizations) and performance metrics. LLMs depend on large datasets, and losing preprocessed or fine-tuning data can be extremely costly. Backups safeguard the data from corruption or accidental deletion. Training LLMs is also computationally expensive, so backups of model checkpoints can make a big difference in the event of a failure or data corruption, preserving progress. Furthermore, many industries and jurisdictions have compliance standards that require data to be backed up for auditability and accountability.</p>
</div></section>

<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Types of Backup Strategies"><div class="sect2" id="ch09_types_of_backup_strategies_1748896826218310">
<h2 class="less_space">Types of Backup Strategies</h2>

<p>Backup<a contenteditable="false" data-primary="backups and restores" data-secondary="strategies for" data-type="indexterm" id="id1365"/> strategies for LLM applications fall into three basic categories: full, incremental, and differential. Let’s examine these more closely:</p>

<dl>
	<dt>Full backups</dt>
	<dd>
	<p>Full<a contenteditable="false" data-primary="full backups" data-type="indexterm" id="id1366"/> backups capture an <em>entire</em> dataset or model at a specific point in time. While they require significant storage, they are comprehensive and straightforward to restore.</p>
	</dd>
	<dt>Incremental backups</dt>
	<dd>
	<p><em>Incremental backups</em> store<a contenteditable="false" data-primary="incremental backups" data-type="indexterm" id="id1367"/> only the changes made since the last (full or incremental) backup, to reduce storage requirements. To restore, you need the entire historical sequence of data; even a single missing data block will cause the restore to fail.</p>
	</dd>
	<dt>Differential backups</dt>
	<dd>
	<p><em>Differential backups </em>save<a contenteditable="false" data-primary="differential backups" data-type="indexterm" id="id1368"/> the changes made since the last <em>full</em> backup, balancing storage efficiency and recovery speed. To restore, you need the latest full backup and the latest differential backup.</p>
	</dd>
</dl>

<p>Your choice of backup strategy depends on a few factors. High-stakes applications require more frequent backups and redundancy and often less downtime as well. Restores for critical applications need to be fast and trouble-free, so frequent full backups are usually recommended.</p>

<p>Data volume is also an important factor. Incremental or differential backups can help minimize storage overhead for large datasets like those used in LLM applications, since making full copies daily consumes expensive time and storage.</p>

<p>In volatile systems where the data changes rapidly, such as active fine-tuning environments, frequent backups are a particularly good idea. If the data volume is small, these can even be full backups. For relatively static systems like deployed inference models, however, you can have a lower frequency of backups (for example, weekly).</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="The Most Important Practice: Test Restores Regularly"><div class="sect2" id="ch09_the_most_important_practice_test_restores_regular_1748896826218362">
<h2>The Most Important Practice: Test Restores Regularly</h2>

<p>Regardless of<a contenteditable="false" data-primary="backups and restores" data-secondary="testing restores regularly" data-type="indexterm" id="id1369"/> your backup strategy, it is <em>imperative</em> that you regularly test the restore process. For example, large backups are often placed in cold storage, which is a lot cheaper than hot storage.<a contenteditable="false" data-primary="hot storage" data-type="indexterm" id="id1370"/> <em>Hot storage</em> is somewhat similar to having a folder on the cloud, in that you can access files immediately.<a contenteditable="false" data-primary="cold storage" data-type="indexterm" id="id1371"/> <em>Cold storage </em>is more like keeping a disk in a warehouse—it takes a while to access the data, sometimes as long as a few days. An LLMOps engineer can go from hero to zero quickly by saying, “Don’t worry, I have all the data backed up; however, production will be down for two weeks while I <a contenteditable="false" data-primary="scaling" data-secondary="optimizing infrastructure" data-startref="icd906" data-tertiary="backups and restores" data-type="indexterm" id="id1372"/><a contenteditable="false" data-primary="backups and restores" data-startref="icd906a" data-type="indexterm" id="id1373"/>retrieve <a contenteditable="false" data-primary="scaling" data-secondary="optimizing infrastructure" data-startref="icd904" data-type="indexterm" id="id1374"/>it.”</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="ch09_conclusion_1748896826218411">
<h1>Conclusion</h1>

<p>Managing LLM infrastructure and resources requires different approaches depending on whether you’re running them on custom cloud infrastructure or owned hardware. Your choice of deployment strategy should consider cost, scalability, data privacy, and operational complexity. Regardless of the choice of infrastructure, LLMOps engineers have to monitor and evaluate performance to ensure that their deployments remain efficient and reliable.</p>

<p>Scaling LLM infrastructure effectively requires advanced tools, like special compilers that optimize hardware usage, and techniques, such as balancing model size and training data to improve performance at a given cost. Understanding and implementing parallelism strategies lets you train and deploy even the largest models.</p>

<p>It’s crucial to have good backup strategies and to test restores regularly, identifying potential failure points. Integrating these best practices will help you deploy resilient, high-performance AI-driven applications that meet your <a contenteditable="false" data-primary="scaling" data-startref="icd901" data-type="indexterm" id="id1375"/>customers’ demands.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="References"><div class="sect1" id="ch09_references_1748896826218455">
<h1>References</h1>

<p>Hoffman, Jordan, et al. <a href="https://oreil.ly/dLHHa">“Training Compute-Optimal Large Language Models”</a>, arXiv, March 29, 2022.</p>

<p>Mueller, Z. R. <a href="https://oreil.ly/g5EZ3">PiPPy</a>, PyTorch, September 2024.</p>
</div></section>
</div></section></div></div></body></html>