<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Developing the FastAPI Code"><div class="chapter" id="chapter_4">
<h1><span class="label">Chapter 4. </span>Developing the FastAPI Code</h1>


<p>In <a data-type="xref" href="ch03.html#chapter_3">Chapter 3</a>, you created your database and the Python code to access the database. In this chapter, you will build on this foundation code to create a working API. <a data-type="xref" href="#swc_endpoints_ch4">Table 4-1</a> lists the endpoints that you will create to fulfill these user stories.<a data-type="indexterm" data-primary="endpoints of APIs" data-secondary="SWC Fantasy Football API" id="id944"/><a data-type="indexterm" data-primary="SportsWorldCentral (SWC)" data-secondary="website API" data-tertiary="endpoints of API" data-seealso="endpoints of APIs" id="id945"/><a data-type="indexterm" data-primary="API endpoints" data-secondary="SWC Fantasy Football API" id="id946"/><a data-type="indexterm" data-primary="building APIs" data-secondary="health check" data-tertiary="endpoint for SWC" id="id947"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="health check" data-tertiary="endpoint for SWC" id="id948"/><a data-type="indexterm" data-primary="health check" data-secondary="endpoint for SWC" id="id949"/><a data-type="indexterm" data-primary="SportsWorldCentral (SWC)" data-secondary="health check as endpoint" data-seealso="health check" id="id950"/><a data-type="indexterm" data-primary="GET HTTP verb" data-secondary="calling SWC API" id="id951"/></p>
<table id="swc_endpoints_ch4">
<caption><span class="label">Table 4-1. </span>Endpoints for the SWC Fantasy Football API</caption>
<thead>
<tr>
<th>Endpoint description</th>
<th>HTTP verb</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>API health check</p></td>
<td><p>GET</p></td>
<td><p><em>/</em></p></td>
</tr>
<tr>
<td><p>Read player list</p></td>
<td><p>GET</p></td>
<td><p><em>/v0/players/</em></p></td>
</tr>
<tr>
<td><p>Read individual player</p></td>
<td><p>GET</p></td>
<td><p><em>/v0/players/{player_id}/</em></p></td>
</tr>
<tr>
<td><p>Read performance list</p></td>
<td><p>GET</p></td>
<td><p><em>/v0/performances/</em></p></td>
</tr>
<tr>
<td><p>Read league list</p></td>
<td><p>GET</p></td>
<td><p><em>/v0/leagues/</em></p></td>
</tr>
<tr>
<td><p>Read individual league</p></td>
<td><p>GET</p></td>
<td><p><em>/v0/leagues/{league_id}/</em></p></td>
</tr>
<tr>
<td><p>Read team list</p></td>
<td><p>GET</p></td>
<td><p><em>/v0/teams/</em></p></td>
</tr>
<tr>
<td><p>Read counts</p></td>
<td><p>GET</p></td>
<td><p><em>/v0/counts/</em></p></td>
</tr>
</tbody>
</table>

<p>You are using version 0 for your API.<a data-type="indexterm" data-primary="semantic versioning" data-secondary="version 0 for your API" id="id952"/><a data-type="indexterm" data-primary="building APIs" data-secondary="version 0 for your API" id="id953"/> This will notify API consumers that the product is changing rapidly and they should be aware of potential <em>breaking changes</em>—changes that cause functionality to stop working and may require consumers to make changes in their program code.</p>






<section data-type="sect1" data-pdf-bookmark="Continuing Your Portfolio Project"><div class="sect1" id="id170">
<h1>Continuing Your Portfolio Project</h1>

<p><a data-type="xref" href="#application_components_ch4">Figure 4-1</a> shows<a data-type="indexterm" data-primary="APIs" data-secondary="architecture of" data-tertiary="components of API" id="id954"/><a data-type="indexterm" data-primary="portfolio projects" data-secondary="building an API" data-tertiary="components of API" id="id955"/><a data-type="indexterm" data-primary="Uvicorn web server" data-secondary="about" id="id956"/> the same API components you saw previously, with one addition: the Uvicorn web server. Uvicorn will execute your API code and interact with API requests.</p>

<figure><div id="application_components_ch4" class="figure">
<img src="assets/haad_0401.png" alt="API components with Uvicorn" width="1408" height="391"/>
<h6><span class="label">Figure 4-1. </span>API components with Uvicorn</h6>
</div></figure>

<p>In <a data-type="xref" href="ch03.html#chapter_3">Chapter 3</a>, you completed two very important parts of the API: the SQLite database and the SQLAlchemy classes that enable Python to interact with the data. In this chapter, you will finish the rest of the components. <a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="Pydantic schemas" id="id957"/><a data-type="indexterm" data-primary="Pydantic" data-secondary="schemas" id="id958"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="Pydantic schemas" id="id959"/>You will create Pydantic <em>schemas</em> that define the structure of request and response messages. Then, you will create the controlling FastAPI application that stitches all the other components together to finish the API.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Software Used in This Chapter"><div class="sect1" id="id36">
<h1>Software Used in This Chapter</h1>

<p>The software introduced in this chapter will focus on handling API requests from your consumers. <a data-type="xref" href="#tools_table_chapter_4">Table 4-2</a> lists the new tools you will use.<a data-type="indexterm" data-primary="FastAPI" id="id960"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" id="id961"/><a data-type="indexterm" data-primary="Pydantic" data-secondary="about" id="id962"/><a data-type="indexterm" data-primary="httpx Python library" data-secondary="about" id="id963"/></p>
<table id="tools_table_chapter_4">
<caption><span class="label">Table 4-2. </span>New tools used in this chapter</caption>
<thead>
<tr>
<th>Software name</th>
<th>Version</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>FastAPI</p></td>
<td><p>0</p></td>
<td><p>Web framework to build the API</p></td>
</tr>
<tr>
<td><p>FastAPI CLI</p></td>
<td><p>0</p></td>
<td><p>Command-line interface for FastAPI</p></td>
</tr>
<tr>
<td><p>HTTPX</p></td>
<td><p>0</p></td>
<td><p>HTTP client for Python</p></td>
</tr>
<tr>
<td><p>Pydantic</p></td>
<td><p>2</p></td>
<td><p>Validation library</p></td>
</tr>
<tr>
<td><p>Uvicorn</p></td>
<td><p>0</p></td>
<td><p>Web server to run the API</p></td>
</tr>
</tbody>
</table>








<section data-type="sect2" data-pdf-bookmark="FastAPI"><div class="sect2" id="id37">
<h2>FastAPI</h2>

<p>FastAPI is a Python web framework that is designed for building APIs. A <em>web framework</em> is a set of libraries that simplify common tasks for web applications. Other common web frameworks include Express, Flask, Django, and Ruby on Rails.</p>

<p>FastAPI is built to be fast in both application performance and developer productivity. Because FastAPI focuses on API development, it simplifies several tasks related to API building and publishing:</p>

<ul>
<li>
<p>It handles HTTP traffic, requests/responses, and other “plumbing” jobs with a few lines of code.</p>
</li>
<li>
<p>It automatically generates an OpenAPI specification file for your API, which is useful for integrating with other products.</p>
</li>
<li>
<p>It includes interactive documentation for your API.<a data-type="indexterm" data-primary="documentation" data-secondary="interactive documentation" data-tertiary="FastAPI interactive documentation" id="id964"/><a data-type="indexterm" data-primary="interactive documentation" data-secondary="FastAPI interactive documentation" id="id965"/></p>
</li>
<li>
<p>It supports API versioning, security, and many other capabilities.</p>
</li>
</ul>

<p>As you will see as you work through the portfolio project, all of these capabilities provide benefits to the users of your APIs.</p>

<p>Compared to the other frameworks I mentioned, FastAPI is a relative newcomer. <a data-type="indexterm" data-primary="Ramírez Montaño, Sebastián" id="id966"/>It is an open source project created by Sebastián Ramírez Montaño in 2018.</p>

<p>FastAPI also includes the FastAPI CLI.<a data-type="indexterm" data-primary="FastAPI" data-secondary="CLI" id="id967"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="CLI" id="id968"/> This is a separate Python library that is used to run FastAPI from the command line.</p>

<p>As of this writing, the latest version<a data-type="indexterm" data-primary="semantic versioning" data-secondary="version 0 for FastAPI" id="id969"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="version 0 for FastAPI" id="id970"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="version 0 for FastAPI" id="id971"/> of FastAPI is a 0.x version (e.g., 0.115). That version number is important because, according to semantic versioning, 0.x indicates that breaking changes may occur with the software.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="HTTPX"><div class="sect2" id="id38">
<h2>HTTPX</h2>

<p>HTTPX is a Python HTTP client.<a data-type="indexterm" data-primary="httpx Python library" data-secondary="about" id="id972"/><a data-type="indexterm" data-primary="requests library with only synchronous calls" id="id973"/><a data-type="indexterm" data-primary="httpx Python library" data-secondary="asynchronous calls" id="id974"/><a data-type="indexterm" data-primary="asynchronous calls via HTTPX" id="id975"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="HTTPX for asynchronous calls" id="id976"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="HTTPX for asynchronous calls" id="id977"/> It is similar to the very popular requests library, but it supports <em>asynchronous calls</em>, which allows some tasks to finish while others process. The requests library only supports <em>synchronous calls</em>, which wait until they receive a response before continuing. HTTPX is used by pytest to test FastAPI programs. You will also use this library in <a data-type="xref" href="ch07.html#chapter_7">Chapter 7</a> to create your Python SDK.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Pydantic"><div class="sect2" id="id39">
<h2>Pydantic</h2>

<p>Pydantic is a data validation library,<a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="Pydantic for data validation" id="id978"/><a data-type="indexterm" data-primary="Pydantic" id="id979"/><a data-type="indexterm" data-primary="data validation" data-secondary="Pydantic for" id="id980"/><a data-type="indexterm" data-primary="endpoints of APIs" data-secondary="data validation via Pydantic" id="id981"/><a data-type="indexterm" data-primary="API endpoints" data-secondary="data validation via Pydantic" id="id982"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="Pydantic for data validation" id="id983"/><a data-type="indexterm" data-primary="Pydantic" data-secondary="data validation" id="id984"/><a data-type="indexterm" data-primary="validation of data" data-see="data validation" id="id985"/> which will play a key part in the APIs that you build. Because APIs are used to communicate between systems, a critical piece of their functionality is the validation of inputs and outputs. API developers and data scientists typically spend a significant amount of time writing the code to check the data types and validate values that go into and out of the API endpoints.</p>

<p>Pydantic is purpose-built to address this important task. Pydantic is fast in two ways: it saves the developer time that would be spent to write custom Python validation code, and Pydantic validation code runs much faster because it is implemented in the Rust programming language.</p>

<p>In addition to these benefits, <a data-type="indexterm" data-primary="tooltips and hints via Pydantic" id="id986"/>objects defined in Pydantic automatically support tooltips and hints in IDEs such as VS Code. <a data-type="indexterm" data-primary="JSON" data-secondary="JSON Schema" id="id987"/>FastAPI uses Pydantic to generate JSON Schema representations from Python code. <em>JSON Schema</em> is a standard that ensures consistency in JSON data structures. <a data-type="indexterm" data-primary="OpenAPI Specification (OAS) file" data-secondary="FastAPI generating via Pydantic" id="id988"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="OAS file generated via Pydantic" id="id989"/><a data-type="indexterm" data-primary="Pydantic" data-secondary="OAS file generated in FastAPI" id="id990"/>This Pydantic feature enables FastAPI to automatically generate the <em>OpenAPI specification</em>, which is an industry-standard file describing APIs.</p>

<p>For your project, you will use Pydantic version 2.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Uvicorn"><div class="sect2" id="id40">
<h2>Uvicorn</h2>

<p>All web applications, including APIs,<a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="Uvicorn web server" id="id991"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="Uvicorn web server" id="id992"/><a data-type="indexterm" data-primary="Uvicorn web server" id="id993"/> rely on a web server to handle the various administrative tasks related to handling requests and responses. You will be using the open source Uvicorn web server. <a data-type="indexterm" data-primary="ASGI specification" id="id994"/><a data-type="indexterm" data-primary="asynchronous processes via Uvicorn" id="id995"/>Uvicorn is based on the <em>ASGI specification</em>, which provides support for both <em>synchronous processes</em> (which block the process while waiting for a task to be performed) and <em>asychronous processes</em> (which can allow another process to continue while they are waiting).</p>

<p>For your project, you will be using Uvicorn 0.x.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id996">
<h1>You Can Start from Here</h1>
<p>The instructions in this chapter assume that you completed Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.html#chapter_2">2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#chapter_3">3</a> already. If you’re starting your coding in this chapter, you will need to perform a couple of steps to catch up. First, you need to create a GitHub Codespace from the book’s GitHub repository. Full instructions are available in <a data-type="xref" href="ch02.html#getting_started_GHcodespace">“Getting Started with Your GitHub Codespace”</a>.</p>

<p>To catch up on the coding from <a data-type="xref" href="ch03.html#chapter_3">Chapter 3</a>, <a data-type="indexterm" data-primary="resources online" data-secondary="chapter code" data-tertiary="chapter 3 complete" id="id997"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="code online" id="id998"/>you can use the completed set of files that is in <em>chapter3/complete</em> of your Codespace. If you are using these, use the directory <em>chapter3/complete</em> instead of <em>chapter3</em> in the setup commands that follow.</p>

<p>If you run into trouble with any of the steps in this chapter, there are a few troubleshooting tips at the end.</p>
</div></aside>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Copying Files from Chapter 3"><div class="sect1" id="id226">
<h1>Copying Files from Chapter 3</h1>

<p>To continue your portfolio project where you left it in the previous chapter, change the directory to <em>chapter4</em> and then copy the previous chapter’s files over to it. The following shows the commands and expected output:<a data-type="indexterm" data-primary="portfolio projects" data-secondary="copying files from previous chapters" data-tertiary="from chapter 3" id="id999"/></p>

<pre data-type="programlisting" data-code-language="shell">.../portfolio-project (main) $ cd chapter4
.../chapter4 (main) $ cp ../chapter3/*.py .
.../chapter4 (main) $ cp ../chapter3/fantasy_data.db .
.../chapter4 (main) $ cp ../chapter3/requirements.txt .
.../chapter4 (main) $ ls *.*
crud.py  database.py  fantasy_data.db  models.py  readme.md  requirements.txt
test_crud.py</pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Installing the New Libraries in Your Codespace"><div class="sect1" id="id171">
<h1>Installing the New Libraries in Your Codespace</h1>

<p>In the previous chapter, <a data-type="indexterm" data-primary="requirements.txt file for pip" data-secondary="installing Pydantic, FastAPI, Uvicorn, HTTPX" id="id1000"/><a data-type="indexterm" data-primary="Pydantic" data-secondary="installation" id="id1001"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="installing" id="id1002"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="installation of FastAPI" id="id1003"/><a data-type="indexterm" data-primary="Uvicorn web server" data-secondary="installation" id="id1004"/><a data-type="indexterm" data-primary="httpx Python library" data-secondary="installation" id="id1005"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="requirements.txt file for library installations" id="id1006"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="requirements.txt file for library installations" id="id1007"/>you created the <em>requirements.txt</em> file and specified libraries to install using the <code>pip3</code> package manager in Python. You will now use this process to install Pydantic,  FastAPI, and Uvicorn.</p>

<p>Update <em>requirements.txt</em> to match the following:</p>

<pre data-type="programlisting">#Chapter 4 pip requirements
SQLAlchemy&gt;=2.0.0
pydantic&gt;=2.4.0
fastapi[standard]&gt;=0.115.0
uvicorn&gt;=0.23.0
Pytest&gt;=8.1.0
httpx&gt;=0.27.0</pre>

<p>Execute the following command to install the new libraries in your Codespace and verify that the libraries installed in the previous chapter still exist:</p>

<pre data-type="programlisting"><strong>pip3 install -r requirements.txt</strong></pre>

<p>You should see a message that states that these libraries were successfully installed, such as the following:</p>

<pre data-type="programlisting" data-code-language="shell">Installing collected packages: uvicorn, pydantic, httpx, fastapi
Successfully installed fastapi-0.115.4 httpx-0.26.0 pydantic-2.4.2 uvicorn-0.23.2</pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Creating Python Files for Your API"><div class="sect1" id="id41">
<h1>Creating Python Files for Your API</h1>

<p>You will be creating two new Python files, which are detailed in  <a data-type="xref" href="#file_table_chapter_4">Table 4-3</a>.<a data-type="indexterm" data-primary="Python" data-secondary="API files" id="ch4-apifi"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="Python files" id="ch4-apifi2"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="Python files" id="ch4-apifi3"/><a data-type="indexterm" data-primary="Python" data-secondary="API files" data-tertiary="main.py" id="id1008"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="main.py" id="id1009"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="Python files" data-tertiary="main.py" id="id1010"/><a data-type="indexterm" data-primary="Python" data-secondary="API files" data-tertiary="schemas.py" data-seealso="schemas.py" id="ch4schemas"/><a data-type="indexterm" data-primary="schemas.py" id="ch4schemas2"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="schemas.py" id="ch4schemas3"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="Python files" data-tertiary="schemas.py" id="ch4schemas4"/><a data-type="indexterm" data-primary="Python" data-secondary="API files" data-tertiary="test_main.py" id="id1011"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="test_main.py" id="id1012"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="Python files" data-tertiary="test_main.py" id="id1013"/><a data-type="indexterm" data-primary="main.py" data-secondary="about" id="id1014"/><a data-type="indexterm" data-primary="schemas.py" data-secondary="about" id="id1015"/><a data-type="indexterm" data-primary="test_main.py" data-secondary="about" id="id1016"/></p>
<table id="file_table_chapter_4">
<caption><span class="label">Table 4-3. </span>Purpose of the Chapter 4 files</caption>
<thead>
<tr>
<th>Filename</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><em>main.py</em></p></td>
<td><p>FastAPI file that defines routes and controls API</p></td>
</tr>
<tr>
<td><p><em>schemas.py</em></p></td>
<td><p>Defines the Pydantic classes that validate data sent to the API</p></td>
</tr>
<tr>
<td><p><em>test_main.py</em></p></td>
<td><p>The pytest file for the FastAPI program</p></td>
</tr>
</tbody>
</table>








<section data-type="sect2" data-pdf-bookmark="Creating Pydantic Schemas"><div class="sect2" id="id42">
<h2>Creating Pydantic Schemas</h2>

<p>The Pydantic classes define<a data-type="indexterm" data-primary="Pydantic" data-secondary="schemas" data-tertiary="creating" id="ch4schcr"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="Pydantic schemas" id="ch4schcr2"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="Pydantic schemas" data-tertiary="creating" id="id1017"/> the structure of the data that the consumer will receive in their API responses. <a data-type="indexterm" data-primary="Pydantic" data-secondary="data transfer objects" id="id1018"/><a data-type="indexterm" data-primary="data transfer objects (DTOs)" id="id1019"/>This uses a software design pattern called <em>data transfer objects</em> (DTO), in which you define a format for transferring data between a producer and consumer, without the consumer needing to know the backend format. In your portfolio project, the backend and frontend classes won’t look significantly different, but using DTOs allows complete flexibility on this point.</p>

<p class="less_space pagebreak-before">Although you define the classes using Python code and your code interacts with them as fully formed Python objects, the consumer will receive them in an HTTP request as a JSON object. <a data-type="indexterm" data-primary="FastAPI" data-secondary="serialization via Pydantic" id="id1020"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="serialization via Pydantic" id="id1021"/><a data-type="indexterm" data-primary="JSON" data-secondary="FastAPI serialization via Pydantic" id="id1022"/><a data-type="indexterm" data-primary="serialization of Python objects by Pydantic" id="id1023"/>FastAPI uses Pydantic to perform the <em>serialization</em> process, which is converting the Python objects into JSON for the API response. This means you do not need to manage serialization in your Python code, which simplifies your program. Pydantic 2 is written in Rust and performs this task much faster than Python could. In addition to performing this de-serialization task, <a data-type="indexterm" data-primary="OpenAPI Specification (OAS) file" data-secondary="openapi.json file" id="id1024"/><a data-type="indexterm" data-primary="openapi.json file" id="id1025"/><a data-type="indexterm" data-primary="JSON" data-secondary="openapi.json file" id="id1026"/>Python also defines the response format in the <em>openapi.json</em> file. This is a standard contract that uses OpenAPI and JSON Schema. This will provide multiple benefits for the consumer, as you will see in subsequent chapters. Pydantic will take data from SQLAlchemy classes and provide it to the API users.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Both SQLAlchemy and Pydantic <a data-type="indexterm" data-primary="model as term" data-secondary="classes as models in SQLAlchemy and Pydantic" id="id1027"/>documentation refer to their classes as models, which may be confusing at times. This is extra confusing for data science work, where models have additional meanings. For clarity, this book will refer to Pydantic schemas and SQLAlchemy models.</p>
</div>

<p>Create a file with the following contents, and name it <em>schemas.py</em>:<a data-type="indexterm" data-primary="gsis_id" data-secondary="schemas.py" id="id1028"/></p>

<pre data-type="programlisting" data-code-language="python">"""Pydantic schemas"""
from pydantic import BaseModel, ConfigDict
from typing import List
from datetime import date


class Performance(BaseModel):
    model_config = ConfigDict(from_attributes = True)
    performance_id : int
    player_id : int
    week_number : str
    fantasy_points : float
    last_changed_date : date
        
class PlayerBase(BaseModel):
    model_config = ConfigDict(from_attributes = True)    
    player_id : int
    gsis_id: str
    first_name : str
    last_name : str
    position : str
    last_changed_date : date

class Player(PlayerBase):
    model_config = ConfigDict(from_attributes = True)
    performances: List[Performance] = []

class TeamBase(BaseModel):
    model_config = ConfigDict(from_attributes = True)
    league_id : int
    team_id : int
    team_name : str
    last_changed_date : date

class Team(TeamBase):
    model_config = ConfigDict(from_attributes = True)
    players: List[PlayerBase] = []

class League(BaseModel):
    model_config = ConfigDict(from_attributes = True)
    league_id : int
    league_name : str
    scoring_type : str
    last_changed_date : date
    teams: List[TeamBase] = []

class Counts(BaseModel):
    league_count : int
    team_count : int
    player_count : int</pre>

<p>The schemas in this file will be used to form the responses to the API endpoints that you will define next. The primary schemas are directly returned to the endpoints and the secondary schemas are returned as an attribute of the primary schema. For example, the <em>/v0/players/</em> endpoint URL returns a list of <code>Player</code> objects (primary), which has the attribute <code>Player.performances</code> (secondary). <a data-type="xref" href="#schema_endpoint_mapping">Table 4-4</a> shows the mapping between API endpoints and schemas.<a data-type="indexterm" data-primary="schemas.py" data-secondary="mapping schemas to endpoints" id="id1029"/><a data-type="indexterm" data-primary="endpoints of APIs" data-secondary="mapping schemas to endpoints" id="id1030"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="Pydantic schemas mapped to endpoints" id="id1031"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="Pydantic schemas" data-tertiary="mapped to endpoints" id="id1032"/><a data-type="indexterm" data-primary="API endpoints" data-secondary="mapping schemas to endpoints" id="id1033"/></p>
<table id="schema_endpoint_mapping">
<caption><span class="label">Table 4-4. </span>Mapping of schemas to endpoints</caption>
<thead>
<tr>
<th>Endpoint URL</th>
<th>Primary schema</th>
<th>Secondary schema</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><em>/</em></p></td>
<td><p>None</p></td>
<td><p>None</p></td>
</tr>
<tr>
<td><p><em>/v0/players/</em></p></td>
<td><p>Player</p></td>
<td><p>Performance</p></td>
</tr>
<tr>
<td><p><em>/v0/players/{player_id}/</em></p></td>
<td><p>Player</p></td>
<td><p>Performance</p></td>
</tr>
<tr>
<td><p><em>/v0/performances/</em></p></td>
<td><p>Performance</p></td>
<td><p>None</p></td>
</tr>
<tr>
<td><p><em>/v0/leagues/</em></p></td>
<td><p>League</p></td>
<td><p>TeamBase</p></td>
</tr>
<tr>
<td><p><em>/v0/leagues/</em>{league_id}</p></td>
<td><p>League</p></td>
<td><p>TeamBase</p></td>
</tr>
<tr>
<td><p><em>/v0/teams/</em></p></td>
<td><p>Team</p></td>
<td><p>PlayerBase</p></td>
</tr>
<tr>
<td><p><em>/v0/counts/</em></p></td>
<td><p>Counts</p></td>
<td><p>None</p></td>
</tr>
</tbody>
</table>

<p>The <code>Performance</code> class is the first and simplest schema:</p>

<pre data-type="programlisting" data-code-language="python">class Performance(BaseModel):
    model_config = ConfigDict(from_attributes = True)
    performance_id : int
    player_id : int
    week_number : str
    fantasy_points : float
    last_changed_date : date</pre>

<p>This class represents the scoring data that the consumer will receive. From their perspective, a <em>performance</em> is what happens when a player plays in a single week. If you compare the elements of this class to the SQLAlchemy models, you will see that it contains all of the elements that the <code>Performance</code> model contains.</p>

<p><code>Performance</code> is a subclass of the Pydantic <code>BaseModel</code> class, which provides a lot of built-in capabilities, including validating the data types, converting the Python object to JSON (serializing), raising intelligent errors, and connecting automatically to the SQLAlchemy models.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Notice that the Pydantic data types<a data-type="indexterm" data-primary="Pydantic" data-secondary="data types of class elements assigned with colon" id="id1034"/><a data-type="indexterm" data-primary="SQLAlchemy" data-secondary="data types of class elements assigned with equals sign" id="id1035"/><a data-type="indexterm" data-primary="data type assignment in Pydantic versus SQLAlchemy" id="id1036"/> of individual class elements are assigned with a colon, and not an equals sign which is what SQLAlchemy uses. (This will trip you up if you’re not careful.)</p>
</div>

<p>The player data is represented in two schemas: <code>PlayerBase</code> and <code>Player</code>. Breaking the data into two classes allows you to share a limited version of the data in some situations and a full version in others. Here are those two schemas:<a data-type="indexterm" data-primary="gsis_id" data-secondary="schemas.py" id="id1037"/></p>

<pre data-type="programlisting" data-code-language="python">class PlayerBase(BaseModel):
    model_config = ConfigDict(from_attributes = True)
    player_id : int
    gsis_id: str
    first_name : str
    last_name : str
    position : str
    last_changed_date : date


class Player(PlayerBase):
    model_config = ConfigDict(from_attributes = True)
    performances: List[Performance] = []</pre>

<p>The performance data had a single <code>Performance</code> schema, but the player data has two schemas. <code>PlayerBase</code> is a subclass of <code>BaseModel</code>, and it has all the player fields except one: the <code>Performance</code> list. <a data-type="xref" href="#schema_endpoint_mapping">Table 4-4</a> shows that <code>PlayerBase</code> will be used as a secondary schema for the <em>/v0/teams/</em> endpoint. The reason is simple: to reduce the amount of data transmitted in the API call. When the API user retries a list of <code>Team</code> schemas, they want to see all the players on that team without also getting a list of all the scoring performances for all the players.</p>

<p class="less_space pagebreak-before">The full <code>Player</code> schema is a subclass of <code>PlayerBase</code> and adds the list of <code>Performance</code> objects. This schema is used directly in the <em>/v0/players/</em> and <em>/v0/players/{player_id}/</em> endpoints. In those situations, the API user wants a list of scoring performances with the players.</p>

<p>To see the secondary use of <code>PlayerBase</code>, examine the next two schemas:</p>

<pre data-type="programlisting" data-code-language="python">class TeamBase(BaseModel):
    model_config = ConfigDict(from_attributes = True)
    league_id : int
    team_id : int
    team_name : str
    last_changed_date : date

class Team(TeamBase):
    model_config = ConfigDict(from_attributes = True)
    players: List[PlayerBase] = []</pre>

<p>The <code>Team</code> object contains the statement <code>players: List[PlayerBase] = []</code>. As mentioned previously, this means the items in <code>Team.players</code> are of the more limited <code>PlayerBase</code> schema. This is the secondary usage of <code>PlayerBase</code> shown in <a data-type="xref" href="#schema_endpoint_mapping">Table 4-4</a> in the <em>/v0/teams/</em> endpoint.</p>

<p>The next class is the <code>League</code> schema:</p>

<pre data-type="programlisting" data-code-language="python">class League(BaseModel):
    model_config = ConfigDict(from_attributes = True)
    league_id : int
    league_name : str
    scoring_type : str
    last_changed_date : date
    teams: List[TeamBase] = []</pre>

<p>By now you probably noticed that <code>League.teams</code> contains <code>TeamBase</code> objects. This is the secondary use of <code>TeamBase</code> used in the <em>/v0/leagues/</em> endpoint.</p>

<p>Finally, you will create a special-purpose schema to support the analytics provided by the <em>v0/counts/</em> endpoint. This schema does not directly map to a database table, so it does not include the <code>model_config</code> element. The name of the schema is <code>Counts</code>, and it includes the number of league, team, and player records in the API:</p>

<pre data-type="programlisting" data-code-language="python">class Counts(BaseModel):
    league_count : int
    team_count : int
    player_count : int</pre>

<p>At this point, you have designed the DTOs that will be used to send data to the API consumer. You are ready for the final piece: the FastAPI controller class.<a data-type="indexterm" data-startref="ch4schemas" id="id1038"/><a data-type="indexterm" data-startref="ch4schemas2" id="id1039"/><a data-type="indexterm" data-startref="ch4schemas3" id="id1040"/><a data-type="indexterm" data-startref="ch4schemas4" id="id1041"/><a data-type="indexterm" data-startref="ch4schcr" id="id1042"/><a data-type="indexterm" data-startref="ch4schcr2" id="id1043"/></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Creating Your FastAPI Controller"><div class="sect2" id="id43">
<h2>Creating Your FastAPI Controller</h2>

<p>Now that all of the pieces are in place<a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="creating FastAPI controller" id="ch4-cr8con"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="FastAPI controller created" id="ch4-cr8con2"/><a data-type="indexterm" data-primary="main.py" id="ch4-cr8con3"/><a data-type="indexterm" data-primary="Python" data-secondary="API files" data-tertiary="main.py" data-seealso="main.py" id="ch4-cr8con4"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="main.py" id="ch4-cr8con5"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="Python files" data-tertiary="main.py" id="ch4-cr8con6"/> in the other Python files, you can tie them together with the FastAPI functionality in <em>main.py</em>. You can accomplish a lot with only a few lines of FastAPI code.</p>

<p>Create the file with the following contents, and name it <em>main.py</em>:<a data-type="indexterm" data-primary="GET HTTP verb" data-secondary="calling SWC API" id="id1044"/></p>

<pre data-type="programlisting" data-code-language="python">"""FastAPI program - Chapter 4"""
from fastapi import Depends, FastAPI, HTTPException
from sqlalchemy.orm import Session
from datetime import date

import crud, schemas
from database import SessionLocal

app = FastAPI()

# Dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/")
async def root():
    return {"message": "API health check successful"}


@app.get("/v0/players/", response_model=list[schemas.Player])
def read_players(skip: int = 0, 
                 limit: int = 100, 
                 minimum_last_changed_date: date = None, 
                 first_name: str = None, 
                 last_name: str = None,
                 db: Session = Depends(get_db)
                 ):
    players = crud.get_players(db, 
                skip=skip, 
                limit=limit, 
                min_last_changed_date=minimum_last_changed_date, 
                first_name=first_name, 
                last_name=last_name)
    return players


@app.get("/v0/players/{player_id}", response_model=schemas.Player)
def read_player(player_id: int, 
                db: Session = Depends(get_db)):
    player = crud.get_player(db, 
                             player_id=player_id)
    if player is None:
        raise HTTPException(status_code=404, 
                            detail="Player not found")
    return player

@app.get("/v0/performances/", 
         response_model=list[schemas.Performance])
def read_performances(skip: int = 0, 
                limit: int = 100, 
                minimum_last_changed_date: date = None, 
                db: Session = Depends(get_db)):
    performances = crud.get_performances(db, 
                skip=skip, 
                limit=limit, 
                min_last_changed_date=minimum_last_changed_date)
    return performances

@app.get("/v0/leagues/{league_id}", response_model=schemas.League)
def read_league(league_id: int,db: Session = Depends(get_db)):
    league = crud.get_league(db, league_id = league_id)
    if league is None:
        raise HTTPException(status_code=404, detail="League not found")
    return league


@app.get("/v0/leagues/", response_model=list[schemas.League])
def read_leagues(skip: int = 0, 
                limit: int = 100, 
                minimum_last_changed_date: date = None, 
                league_name: str = None,
                db: Session = Depends(get_db)):
    leagues = crud.get_leagues(db, 
                skip=skip, 
                limit=limit, 
                min_last_changed_date=minimum_last_changed_date, 
                league_name=league_name)
    return leagues

@app.get("/v0/teams/", response_model=list[schemas.Team])
def read_teams(skip: int = 0, 
               limit: int = 100, 
               minimum_last_changed_date: date = None, 
               team_name: str = None, 
               league_id: int = None, 
               db: Session = Depends(get_db)):
    teams = crud.get_teams(db, 
                skip=skip, 
                limit=limit, 
                min_last_changed_date=minimum_last_changed_date, 
                team_name=team_name,
                league_id=league_id)
    return teams


@app.get("/v0/counts/", response_model=schemas.Counts)
def get_count(db: Session = Depends(get_db)):
    counts = schemas.Counts(
        league_count = crud.get_league_count(db),
        team_count = crud.get_team_count(db),
        player_count = crud.get_player_count(db))
    return counts</pre>

<p>Let’s walk through the code in your FastAPI file. We’ll begin with the imports:</p>

<pre data-type="programlisting" data-code-language="python">from fastapi import Depends, FastAPI, HTTPException <a class="co" id="co_developing_the_fastapi_code_CO1-1" href="#callout_developing_the_fastapi_code_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a>
from sqlalchemy.orm import Session <a class="co" id="co_developing_the_fastapi_code_CO1-2" href="#callout_developing_the_fastapi_code_CO1-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a>
from datetime import date <a class="co" id="co_developing_the_fastapi_code_CO1-3" href="#callout_developing_the_fastapi_code_CO1-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a>

import crud, schemas <a class="co" id="co_developing_the_fastapi_code_CO1-4" href="#callout_developing_the_fastapi_code_CO1-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a>
from database import SessionLocal <a class="co" id="co_developing_the_fastapi_code_CO1-5" href="#callout_developing_the_fastapi_code_CO1-5"><img src="assets/5.png" alt="5" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_developing_the_fastapi_code_CO1-1" href="#co_developing_the_fastapi_code_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>These are methods from the FastAPI library. You will use these to identify this program as a FastAPI application.</p></dd>
<dt><a class="co" id="callout_developing_the_fastapi_code_CO1-2" href="#co_developing_the_fastapi_code_CO1-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The SQLAlchemy <code>Session</code> will be used when this program calls <em>crud.py</em>.<a data-type="indexterm" data-primary="SQLAlchemy" data-secondary="session object" id="id1045"/><a data-type="indexterm" data-primary="session object of SQLAlchemy" id="id1046"/><a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLAlchemy" data-tertiary="session object" id="id1047"/></p></dd>
<dt><a class="co" id="callout_developing_the_fastapi_code_CO1-3" href="#co_developing_the_fastapi_code_CO1-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>You will use the <code>date</code> type to query by last changed date.<a data-type="indexterm" data-primary="data pipelines" data-secondary="last changed date query parameter" data-tertiary="date object for" id="id1048"/><a data-type="indexterm" data-primary="last changed date query parameter" data-secondary="date object for" id="id1049"/><a data-type="indexterm" data-primary="query parameters" data-secondary="last changed date" data-tertiary="date object for" id="id1050"/></p></dd>
<dt><a class="co" id="callout_developing_the_fastapi_code_CO1-4" href="#co_developing_the_fastapi_code_CO1-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>These imports allow the FastAPI application to reference the SQLAlchemy and Pydantic classes.</p></dd>
<dt><a class="co" id="callout_developing_the_fastapi_code_CO1-5" href="#co_developing_the_fastapi_code_CO1-5"><img src="assets/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>This retrieves the shared <code>SessionLocal</code> class that is used to connect to your SQLite database.</p></dd>
</dl>

<p>Continue reviewing the code:</p>

<pre data-type="programlisting" data-code-language="python">app = FastAPI()

# Dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()</pre>

<p>In FastAPI, the primary class<a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="FastAPI class" id="id1051"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="FastAPI class" id="id1052"/><a data-type="indexterm" data-primary="main.py" data-secondary="FastAPI class" id="id1053"/> you will work with is a <code>FastAPI</code> class. This class by default includes the functionality to handle much of the work that an API needs to perform, without requiring you to specify every detail. You create a <code>FastAPI</code> instance and name it <code>app</code>. This will be used in the rest of <em>main.py</em>. When you execute your API from the command line using Uvicorn, you will reference <code>main:app</code>, referring to the <code>app</code> object in <em>main.py</em>.</p>

<p>You define the <code>get_db()</code> function to create a database session and close the session when you are done with it. This function is used as a dependency in the API routes within <em>main.py</em>:</p>

<pre data-type="programlisting" data-code-language="python">@app.get("/")
async def root():
    return {"message": "API health check successful"}</pre>

<p>The next command is <code>@app.get("/")</code>, <a data-type="indexterm" data-primary="decorators" id="id1054"/><a data-type="indexterm" data-primary="Python" data-secondary="decorators" id="id1055"/>which is a <em>decorator</em>. A decorator is a statement that is added above a function definition, to give special attributes to it. In this case, the decorator defines that the <code>async def root()</code> function definition will be a FastAPI request handler.</p>

<p>This function will be called<a data-type="indexterm" data-primary="building APIs" data-secondary="health check" data-tertiary="main.py" id="id1056"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="health check" data-tertiary="main.py" id="id1057"/><a data-type="indexterm" data-primary="health check" data-secondary="main.py" id="id1058"/><a data-type="indexterm" data-primary="main.py" data-secondary="health check" id="id1059"/> when a consumer accesses the root URL of the API, which is equivalent to <code>/</code>. It will serve as a health check for the entire API by returning a simple message to the consumer. <a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="Pydantic schemas mapped to endpoints" id="ch4mapend"/><a data-type="indexterm" data-primary="endpoints of APIs" data-secondary="mapping schemas to endpoints" id="ch4mapend2"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="Pydantic schemas" data-tertiary="mapped to endpoints" id="ch4mapend3"/><a data-type="indexterm" data-primary="schemas.py" data-secondary="mapping schemas to endpoints" data-tertiary="main.py defining endpoints" id="ch4mapend4"/><a data-type="indexterm" data-primary="API endpoints" data-secondary="mapping schemas to endpoints" id="ch4mapend5"/>The next statement defines the first endpoint that we have created for your user stories:</p>

<pre data-type="programlisting" data-code-language="python">@app.get("/v0/players/", response_model=list[schemas.Player])
def read_players(skip: int = 0,
                limit: int = 100,
                minimum_last_changed_date: date = None,
                first_name: str = None,
                last_name: str = None,
                db: Session = Depends(get_db)
                ):
   players = crud.get_players(db,
               skip=skip,
               limit=limit,
               min_last_changed_date=minimum_last_changed_date,
               first_name=first_name,
               last_name=last_name)
   return players</pre>

<p>Remember that <a data-type="xref" href="#swc_endpoints_ch4">Table 4-1</a> defined the endpoints that we planned to create as a combination of HTTP verb and URL. With FastAPI these endpoints (also called <em>routes</em>) are defined with the decorators above each function.</p>

<p>The following explains how the HTTP verb and URL are specified in the decorator:<a data-type="indexterm" data-primary="HTTP" data-secondary="verbs" data-tertiary="decorator specifying" id="id1060"/></p>

<ul>
<li>
<p><em>HTTP verb</em>: All of these endpoints use the <code>GET</code> verb, which is defined by the <code>@app.get()</code> decorator function.</p>
</li>
<li>
<p><em>URL</em>: The first parameter of the <code>get()</code> function is the relative URL.  For this first endpoint, the URL is <em>/v0/players/</em>.</p>
</li>
</ul>

<p>The second parameter of the decorator is <code>response_model=list[schemas.Player])</code>. This informs FastAPI that the data returned from this endpoint will be a list of Pydantic <code>Player</code> objects, as defined in the <em>schemas.py</em> file. This information will be included in the OpenAPI specification that FastAPI automatically creates for this API. Consumers can count on the returned data being valid according to this <span class="keep-together">definition.</span></p>

<p>Let’s look at the function signature that you decorated:</p>

<pre data-type="programlisting" data-code-language="python">def read_players(skip: int = 0,
                 limit: int = 100,
                 minimum_last_changed_date: date = None,
                 first_name: str = None,
                 last_name: str = None,
                 db: Session = Depends(get_db)
                 ):</pre>

<p>Several things are going on in this function. <a data-type="indexterm" data-primary="database creation and access" data-secondary="SQLAlchemy" data-tertiary="session object" id="id1061"/><a data-type="indexterm" data-primary="session object of SQLAlchemy" id="id1062"/><a data-type="indexterm" data-primary="SQLAlchemy" data-secondary="session object" id="id1063"/>Starting at the end, the <code>db</code> object is a session that is created by the <code>get_db()</code> function defined at the top of this file. By wrapping the function in <code>Depends()</code>, FastAPI handles the call for and gives the <code>Session</code> to your function.</p>

<p>The next two parameters are optional integers with a default value: <code>skip: int = 0, limit: int = 100, last_name</code>. These are followed by two optional string parameters that default to <code>None</code>. These are all named parameters that have a defined data type and a default value. <a data-type="indexterm" data-primary="query parameters" data-secondary="FastAPI including in URL via main.py" id="id1064"/><a data-type="indexterm" data-primary="URL of API" data-secondary="query parameters included in" id="id1065"/>FastAPI will automatically include these parameters as query parameters in the API definition. Query parameters are included in the URL path with a question mark in front and an ampersand between.</p>

<p>For instance, to call this query method, the API consumer could use this request:</p>

<ul>
<li>
<p><em>HTTP verb</em>: GET</p>
</li>
<li>
<p><em>URL</em>: <em>{base URL}/v0/players/?first_name=Bryce&amp;last_name=Young</em></p>
</li>
</ul>

<p>Within the body of the <code>read_players()</code> function, FastAPI is calling the <code>get_players()</code> function that you defined in <em>crud.py</em>. It is performing a database query. The <code>players</code> object receives the result of that function call. FastAPI validates that this object matches the definition <code>list[schemas.Player]</code>. If it does, <a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="serialization via Pydantic" id="id1066"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="serialization via Pydantic" id="id1067"/><a data-type="indexterm" data-primary="JSON" data-secondary="FastAPI serialization via Pydantic" id="id1068"/><a data-type="indexterm" data-primary="serialization of Python objects by Pydantic" id="id1069"/>FastAPI uses Pydantic to serialize the Python objects into a text JSON string and sends the response to the consumer.</p>

<p>The next endpoint adds two additional FastAPI features:</p>

<pre data-type="programlisting" data-code-language="python">@app.get("/v0/players/{player_id}", response_model=schemas.Player)
def read_player(player_id: int,
                db: Session = Depends(get_db)):
    player = crud.get_player(db,
                             player_id=player_id)
    if player is None:
        raise HTTPException(status_code=404,
                            detail="Player not found")
    return player</pre>

<p>First, the URL path<a data-type="indexterm" data-primary="query parameters" data-secondary="FastAPI including in URL via main.py" data-tertiary="path parameters" id="id1070"/><a data-type="indexterm" data-primary="path parameters" id="id1071"/><a data-type="indexterm" data-primary="URL of API" data-secondary="query parameters included in" data-tertiary="path parameters" id="id1072"/> includes <code>{player_id}</code>. This is a <em>path parameter</em>, which is an API request parameter that is included in the URL path instead of being separated by question marks and ampersands, like the query parameters. Here is an example of how the API consumer might call this endpoint:</p>

<ul>
<li>
<p><em>HTTP verb</em>: GET</p>
</li>
<li>
<p><em>URL</em>: <em>{base URL}/v0/players/12345?skip=10&amp;limit=50</em></p>
</li>
</ul>

<p>The function checks to see if any records were returned from the helper function, and if not, it raises an <em>HTTPException</em>. This is a standard method that web applications use to communicate status. <a data-type="indexterm" data-primary="RESTful" data-secondary="HTTP status codes" id="id1073"/><a data-type="indexterm" data-primary="HTTP" data-secondary="status codes" data-tertiary="404 as not found" id="id1074"/><a data-type="indexterm" data-primary="HTTP" data-secondary="status codes" data-tertiary="RESTful APIs using standard codes" id="id1075"/>It is good RESTful API design to use the standard <a href="https://oreil.ly/cTnfI">HTTP status codes</a> to communicate with consumers. This makes the operation more predictable and reliable. This endpoint returns an HTTP status code of 404, which is the <em>not found</em> code. It adds the additional message that the item not found was the player being searched for.</p>

<p>The next four endpoints do not use any new features. But together they complete all of the user stories that we have included for your first API:</p>

<pre data-type="programlisting" data-code-language="python">@app.get("/v0/performances/",
         response_model=list[schemas.Performance])
def read_performances(skip: int = 0,
                limit: int = 100,
                minimum_last_changed_date: date = None,
                db: Session = Depends(get_db)):
    performances = crud.get_performances(db,
                skip=skip,
                limit=limit,
                min_last_changed_date=minimum_last_changed_date)
    return performances

@app.get("/v0/leagues/{league_id}", response_model=schemas.League)
def read_league(league_id: int,db: Session = Depends(get_db)):
    league = crud.get_league(db, league_id = league_id)
    if league is None:
        raise HTTPException(status_code=404, detail="League not found")
    return league


@app.get("/v0/leagues/", response_model=list[schemas.League])
def read_leagues(skip: int = 0,
                limit: int = 100,
                minimum_last_changed_date: date = None,
                league_name: str = None,
                db: Session = Depends(get_db)):
    leagues = crud.get_leagues(db,
                skip=skip,
                limit=limit,
                min_last_changed_date=minimum_last_changed_date,
                league_name=league_name)
    return leagues

@app.get("/v0/teams/", response_model=list[schemas.Team])
def read_teams(skip: int = 0,
               limit: int = 100,
               minimum_last_changed_date: date = None,
               team_name: str = None,
               league_id: int = None,
               db: Session = Depends(get_db)):
    teams = crud.get_teams(db,
                skip=skip,
                limit=limit,
                min_last_changed_date=minimum_last_changed_date,
                team_name=team_name,
                league_id=league_id)
    return teams</pre>

<p>The final endpoint provides counts of leagues, teams, and players:</p>

<pre data-type="programlisting" data-code-language="python">@app.get("/v0/counts/", response_model=schemas.Counts)
def get_count(db: Session = Depends(get_db)):
   counts = schemas.Counts(
       league_count = crud.get_league_count(db),
       team_count = crud.get_team_count(db),
       player_count = crud.get_player_count(db))
   return counts</pre>

<p>It is worth noting that, in addition to the basic options of FastAPI and Pydantic that you are using, many other validations and features are available. As you can see, these libraries accomplish a lot with only a few lines of code from you.<a data-type="indexterm" data-startref="ch4-apifi" id="id1076"/><a data-type="indexterm" data-startref="ch4-apifi2" id="id1077"/><a data-type="indexterm" data-startref="ch4-apifi3" id="id1078"/><a data-type="indexterm" data-startref="ch4-cr8con" id="id1079"/><a data-type="indexterm" data-startref="ch4-cr8con2" id="id1080"/><a data-type="indexterm" data-startref="ch4-cr8con3" id="id1081"/><a data-type="indexterm" data-startref="ch4-cr8con4" id="id1082"/><a data-type="indexterm" data-startref="ch4-cr8con5" id="id1083"/><a data-type="indexterm" data-startref="ch4-cr8con6" id="id1084"/><a data-type="indexterm" data-startref="ch4mapend" id="id1085"/><a data-type="indexterm" data-startref="ch4mapend2" id="id1086"/><a data-type="indexterm" data-startref="ch4mapend3" id="id1087"/><a data-type="indexterm" data-startref="ch4mapend4" id="id1088"/><a data-type="indexterm" data-startref="ch4mapend5" id="id1089"/></p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Testing Your API"><div class="sect1" id="id44">
<h1>Testing Your API</h1>

<p>You will use pytest to test<a data-type="indexterm" data-primary="building APIs" data-secondary="testing your API" id="ch4test"/><a data-type="indexterm" data-primary="test_main.py" id="ch4test2"/><a data-type="indexterm" data-primary="Python" data-secondary="API files" data-tertiary="test_main.py" id="ch4test3"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="test_main.py" id="ch4test4"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="Python files" data-tertiary="test_main.py" id="ch4test5"/><a data-type="indexterm" data-primary="pytest" data-secondary="testing main.py code" id="ch4test6"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="testing your API" id="ch4test7"/> your <em>main.py</em> file. As with the <em>crud.py</em> file in the previous chapter, you will be testing that the correct number of records are returned by each API endpoint. The counts of records can be verified by the SQL queries in <a data-type="xref" href="ch03.html#load_your_data">“Loading Your Data”</a>.</p>

<p>To implement the tests for your API, create a file with the following contents, and name it <em>test_main.py</em>:</p>

<pre data-type="programlisting" data-code-language="python">from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

# test the health check endpoint
def test_read_main():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "API health check successful"}

# test /v0/players/
def test_read_players():
    response = client.get("/v0/players/?skip=0&amp;limit=10000")
    assert response.status_code == 200
    assert len(response.json()) == 1018

def test_read_players_by_name():
    response = client.get("/v0/players/?first_name=Bryce&amp;last_name=Young")
    assert response.status_code == 200
    assert len(response.json()) == 1
    assert response.json()[0].get("player_id") == 2009

# test /v0/players/{player_id}/
def test_read_players_with_id():
    response = client.get("/v0/players/1001/")
    assert response.status_code == 200
    assert response.json().get("player_id") == 1001

# test /v0/performances/
def test_read_performances():
    response = client.get("/v0/performances/?skip=0&amp;limit=20000")
    assert response.status_code == 200
    assert len(response.json()) == 17306

# test /v0/performances/ with changed date
def test_read_performances_by_date():
    response = client.get(
        "/v0/performances/?skip=0&amp;limit=20000&amp;minimum_last_changed_date=
        2024-04-01"
    )
    assert response.status_code == 200
    assert len(response.json()) == 2711

# test /v0/leagues/{league_id}/
def test_read_leagues_with_id():
    response = client.get("/v0/leagues/5002/")
    assert response.status_code == 200
    assert len(response.json()["teams"]) == 8

# test /v0/leagues/
def test_read_leagues():
    response = client.get("/v0/leagues/?skip=0&amp;limit=500")
    assert response.status_code == 200
    assert len(response.json()) == 5

# test /v0/teams/
def test_read_teams():
    response = client.get("/v0/teams/?skip=0&amp;limit=500")
    assert response.status_code == 200
    assert len(response.json()) == 20

# test /v0/teams/
def test_read_teams_for_one_league():
    response = client.get("/v0/teams/?skip=0&amp;limit=500&amp;league_id=5001")
    assert response.status_code == 200
    assert len(response.json()) == 12

# test the count functions
def test_counts():
    response = client.get("/v0/counts/")
    response_data = response.json()
    assert response.status_code == 200
    assert response_data["league_count"] == 5
    assert response_data["team_count"] == 20
    assert response_data["player_count"] == 1018</pre>

<p>The file begins with import statements and creation of the <code>TestClient</code> class:</p>

<pre data-type="programlisting" data-code-language="python">from fastapi.testclient import TestClient <a class="co" id="co_developing_the_fastapi_code_CO2-1" href="#callout_developing_the_fastapi_code_CO2-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a>
from main import app <a class="co" id="co_developing_the_fastapi_code_CO2-2" href="#callout_developing_the_fastapi_code_CO2-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a>

client = TestClient(app) <a class="co" id="co_developing_the_fastapi_code_CO2-3" href="#callout_developing_the_fastapi_code_CO2-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_developing_the_fastapi_code_CO2-1" href="#co_developing_the_fastapi_code_CO2-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p><code>TestClient</code> is a special class<a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="TestClient class" id="id1090"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="testing your API" data-tertiary="TestClient class" id="id1091"/> that allows the FastAPI program to be tested without running it on a web server.</p></dd>
<dt><a class="co" id="callout_developing_the_fastapi_code_CO2-2" href="#co_developing_the_fastapi_code_CO2-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>This references the FastAPI object you created in <em>main.py</em>.</p></dd>
<dt><a class="co" id="callout_developing_the_fastapi_code_CO2-3" href="#co_developing_the_fastapi_code_CO2-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>This statement creates a <code>TestClient</code> that will test your application.</p></dd>
</dl>

<p>Take a look at a few of the test functions:</p>

<pre data-type="programlisting" data-code-language="python">#test the health check endpoint
def test_read_main():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "API health check successful"}</pre>

<p>This function uses<a data-type="indexterm" data-primary="building APIs" data-secondary="health check" data-tertiary="test_main.py" id="id1092"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="health check" data-tertiary="test_main.py" id="id1093"/><a data-type="indexterm" data-primary="health check" data-secondary="test_main.py" id="id1094"/><a data-type="indexterm" data-primary="test_main.py" data-secondary="health check" id="id1095"/><a data-type="indexterm" data-primary="HTTP" data-secondary="status codes" data-tertiary="200 as successful response" id="id1096"/> the <code>TestClient</code> to simulate an API call to the root path. Then, it checks the HTTP status code for a value of <code>200</code>, which means a successful request. Next, it looks at the JSON value returned by the API and checks that it matches the JSON value provided.</p>

<p class="less_space pagebreak-before">The next test function adds more functionality:</p>

<pre data-type="programlisting" data-code-language="python">#test /v0/players/
def test_read_players():
    response = client.get("/v0/players/?skip=0&amp;limit=10000")
    assert response.status_code == 200
    assert len(response.json()) == 1018</pre>

<p>Notice that the URL passed in the <code>get()</code> statement uses the <code>skip</code> and <code>limit</code> parameters. The second <code>assert</code> statement checks the length of the list of players returned by the API to make sure it is exactly 1018.</p>

<p>Another test function tests the search of players by name. Although the database does not enforce uniqueness on player names, duplicate player names are rare, and names are commonly used to identify players.</p>

<p>This search without a key supports the design recommended in <a data-type="xref" href="ch01.html#chapter_1">Chapter 1</a> for AI:<a data-type="indexterm" data-primary="AI (artificial intelligence)" data-secondary="searching without a key" id="id1097"/></p>

<pre data-type="programlisting" data-code-language="python">def test_read_players_by_name():
    response = client.get("/v0/players/?first_name=Bryce&amp;last_name=Young")
    assert response.status_code == 200
    assert len(response.json()) == 1
    assert response.json()[0].get("player_id") == 2009</pre>

<p>This adds two <code>assert</code> statements: one to make sure only one record was returned from this query (after all, there is only one Bryce Young) and another to make sure the <code>player_id</code> is correct.</p>

<p>The complete file contains 11 tests in all. To execute the tests, enter the following command:</p>

<pre data-type="programlisting" data-code-language="shell">.../chapter4 (main) $ pytest test_main.py
================== test session starts ===========================
platform linux -- Python 3.10.14, pytest-8.1.2, pluggy-1.4.0
rootdir: /workspaces/portfolio-project/chapter4
plugins: anyio-3.4.4.0

collected 11 items

test_main.py                                              [100%]

=================== 11 passed in 1.01s ============================</pre>

<p>You have verified that your FastAPI program works with pytest. Now it’s time to try it with a web server.<a data-type="indexterm" data-startref="ch4test" id="id1098"/><a data-type="indexterm" data-startref="ch4test2" id="id1099"/><a data-type="indexterm" data-startref="ch4test3" id="id1100"/><a data-type="indexterm" data-startref="ch4test4" id="id1101"/><a data-type="indexterm" data-startref="ch4test5" id="id1102"/><a data-type="indexterm" data-startref="ch4test6" id="id1103"/><a data-type="indexterm" data-startref="ch4test7" id="id1104"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Launching Your API"><div class="sect1" id="id45">
<h1>Launching Your API</h1>

<p>This is the moment you<a data-type="indexterm" data-primary="building APIs" data-secondary="launching your API" id="id1105"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="launching your API" id="id1106"/><a data-type="indexterm" data-primary="launching your API" id="id1107"/><a data-type="indexterm" data-primary="main.py" data-secondary="launching your API" id="id1108"/><a data-type="indexterm" data-primary="Python" data-secondary="API files" data-tertiary="launching your API" id="id1109"/> have been waiting for: it’s time to run your API. Enter the following command from the command line:<a data-type="indexterm" data-primary="FastAPI" data-secondary="CLI" data-tertiary="fastapi run" id="id1110"/></p>

<pre data-type="programlisting" data-code-language="shell">.../chapter4 (main) $ fastapi run main.py</pre>

<p>You will see the application startup occur as shown in <a data-type="xref" href="#fast_api_run_ch4">Figure 4-2</a>.</p>

<figure><div id="fast_api_run_ch4" class="figure">
<img src="assets/haad_0402.png" alt="FastAPI running from command line" width="744" height="306"/>
<h6><span class="label">Figure 4-2. </span>FastAPI running from the command line</h6>
</div></figure>

<p>In Codespaces, you will <a data-type="indexterm" data-primary="Codespaces (GitHub)" data-secondary="launching your API" id="id1111"/><a data-type="indexterm" data-primary="GitHub" data-secondary="Codespaces" data-tertiary="launching your API" id="id1112"/><a data-type="indexterm" data-primary="port 8000 for application" id="id1113"/><a data-type="indexterm" data-primary="launching your API" data-secondary="port 8000 for application" id="id1114"/><a data-type="indexterm" data-primary="Codespaces (GitHub)" data-secondary="launching your API" data-tertiary="port 8000 for application" id="id1115"/><a data-type="indexterm" data-primary="building APIs" data-secondary="launching your API" data-tertiary="port 8000 for application" id="id1116"/><a data-type="indexterm" data-primary="GitHub" data-secondary="Codespaces" data-tertiary="launching your API to port 8000" id="id1117"/>also see a dialog stating “Your application running on port 8000 is available,” as shown in <a data-type="xref" href="#codespaces_api_open_browser4">Figure 4-3</a>.</p>

<figure><div id="codespaces_api_open_browser4" class="figure">
<img src="assets/haad_0403.png" alt="Codespaces browser window popup" width="772" height="163"/>
<h6><span class="label">Figure 4-3. </span>Codespaces browser window pop-up</h6>
</div></figure>

<p>Click “Open in Browser” to open a browser tab outside your Codespaces. This browser will show a base URL ending in <em>app.github.dev</em> that contains the response from your API running on Codespaces. <a data-type="indexterm" data-primary="building APIs" data-secondary="health check" data-tertiary="launching API" id="id1118"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="health check" data-tertiary="launching API" id="id1119"/><a data-type="indexterm" data-primary="health check" data-secondary="launching API" id="id1120"/>You should see the following health check message in your web browser:</p>

<pre data-type="programlisting">{"message":"API health check successful"}</pre>

<p>This confirms your API is running, which is a great start.</p>

<p>The next test is to call an endpoint that retrieves data. Give that a try by copying and pasting the following onto the end of the base URL in your browser: <strong><em>/v0/performances/?skip=0&amp;limit=1</em></strong>. For example, the full URL might be <em><a href="https://happy-pine-tree-1234-8000.app.github.dev/v0/performances/?skip=0&amp;limit=1" class="bare"><em class="hyperlink">https://happy-pine-tree-1234-8000.app.github.dev/v0/performances/?skip=0&amp;limit=1</em></a></em>.</p>

<p>If everything is working correctly, you should see the following data in your browser:</p>

<pre data-type="programlisting" data-code-language="json">[{"performance_id":2501,"player_id":1001,"week_number":"202301",
"fantasy_points":20.0,"last_changed_date":"2024-03-01"}]</pre>
<div data-type="tip"><h6>Tip</h6>
<p>This chapter covered a lot, so it’s possible that an error occurred or you are not getting a successful result. Don’t worry, this happens to all of us. <a data-type="indexterm" data-primary="building APIs" data-secondary="troubleshooting" id="id1121"/><a data-type="indexterm" data-primary="FastAPI" data-secondary="troubleshooting" id="id1122"/><a data-type="indexterm" data-primary="troubleshooting API build" id="id1123"/>Here are a few suggestions for how to troubleshoot any problems you are running into:</p>

<ul>
<li>
<p>Run the <strong><code>pip3 install -r requirements.txt</code></strong> command again to make sure you have all the updated software.</p>
</li>
<li>
<p>Take a minute to verify the path in the URL bar of your browser. Minor things matter, such as slashes and question marks.</p>
</li>
<li>
<p>Look at the command line to see any errors that are being thrown by FastAPI.</p>
</li>
<li>
<p>To verify your environment <a data-type="indexterm" data-primary="FastAPI" data-secondary="tutorial creating simple API" id="id1124"/><a data-type="indexterm" data-primary="building APIs" data-secondary="FastAPI" data-tertiary="tutorial creating simple API" id="id1125"/><a data-type="indexterm" data-primary="tutorial creating simple API with FastAPI" id="id1126"/><a data-type="indexterm" data-primary="resources online" data-secondary="FastAPI" data-tertiary="tutorial creating simple API" id="id1127"/>with FastAPI and Uvicorn, try creating a simple API, such as one from the <a href="https://oreil.ly/L7QWz">official FastAPI tutorial</a>.</p>
</li>
<li>
<p>If a formatting error occurs due to text wrapping, check against the files in the GitHub repository.</p>
</li>
</ul>
</div>

<p>If this first API endpoint is working for you, try out some more of the URLs from <a data-type="xref" href="#swc_endpoints_ch4">Table 4-1</a> in your browser to verify that you have completed all of your user stories. Congratulations, you are an API developer!</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Additional Resources"><div class="sect1" id="id46">
<h1>Additional Resources</h1>

<p>To explore FastAPI <a data-type="indexterm" data-primary="FastAPI" data-secondary="documentation online" id="id1128"/><a data-type="indexterm" data-primary="resources online" data-secondary="FastAPI" data-tertiary="documentation" id="id1129"/>beyond this book, the official <a href="https://oreil.ly/SFN3w">FastAPI tutorial</a> and <a href="https://oreil.ly/MVgVk">FastAPI reference documentation</a> are both very useful.</p>

<p>To learn the ins and outs of building a project with FastAPI, I recommend <em>FastAPI: Modern Python Web Development</em> by Bill Lubanovic (O’Reilly, 2023).<a data-type="indexterm" data-primary="FastAPI: Modern Python Web Development (Lubanovic)" id="id1130"/><a data-type="indexterm" data-primary="Lubanovic, Bill" id="id1131"/></p>

<p>For a growing list of practical tips from an official FastAPI Expert, check out <a href="https://oreil.ly/kludex">Marcelo Trylesinski’s FastAPI Tips</a>.<a data-type="indexterm" data-primary="FastAPI Tips (Trylesinski) online" id="id1132"/><a data-type="indexterm" data-primary="resources online" data-secondary="FastAPI" data-tertiary="FastAPI Tips (Trylesinski)" id="id1133"/><a data-type="indexterm" data-primary="Trylesinski, Marcelo" id="id1134"/></p>

<p>The official <a href="https://oreil.ly/2OE-8">Pydantic 2.4 documentation</a> provides information for the specific version of Pydantic used in this chapter.<a data-type="indexterm" data-primary="Pydantic" data-secondary="documentation online" id="id1135"/><a data-type="indexterm" data-primary="resources online" data-secondary="Pydantic documentation" id="id1136"/></p>

<p>The official <a href="https://oreil.ly/uvicorn">Uvicorn documentation</a> has much more information about the capabilities of this software.<a data-type="indexterm" data-primary="Uvicorn web server" data-secondary="documentation online" id="id1137"/><a data-type="indexterm" data-primary="resources online" data-secondary="Uvicorn documentation" id="id1138"/></p>
<aside data-type="sidebar" epub:type="sidebar" class="less_space pagebreak-before"><div class="sidebar" id="id1139">
<h1>Extending Your Portfolio Project</h1>
<p>There are several ways you could build on what you have learned in this chapter:<a data-type="indexterm" data-primary="portfolio projects" data-secondary="building an API" data-tertiary="extending portfolio project" id="id1140"/><a data-type="indexterm" data-primary="building APIs" data-secondary="portfolio project extended" id="id1141"/></p>

<ul>
<li>
<p>Learn more about pytest by creating new tests. Adding tests to verify that secondary classes retrieve data correctly would be a good place to start.</p>
</li>
<li>
<p>Identify additional parameters that users may want to use. Implement them in the FastAPI program, schemas, and helper functions.</p>
</li>
<li>
<p>If you have been developing your own API project in previous chapters, implement the Pydantic and FastAPI code for it.</p>
</li>
</ul>
</div></aside>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="id380">
<h1>Summary</h1>

<p>In this chapter, you completed the API functionality for the SWC Fantasy Football API. You accomplished the following:</p>

<ul>
<li>
<p>You installed FastAPI, SQLAlchemy, Pydantic, and Uvicorn, along with several supporting libraries.</p>
</li>
<li>
<p>You defined Pydantic schemas to represent the data that your API consumers wanted to receive.</p>
</li>
<li>
<p>You created a FastAPI program to process consumer requests and return data responses, tying everything together.</p>
</li>
<li>
<p>You tested the API with pytest and then ran it successfully on the web server.</p>
</li>
</ul>

<p>In <a data-type="xref" href="ch05.html#chapter_5">Chapter 5</a>, you will document your API using FastAPI’s built-in capabilities.</p>
</div></section>
</div></section></div>
</div>
</body></html>