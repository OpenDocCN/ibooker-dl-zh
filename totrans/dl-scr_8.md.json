["```py\ndef _get_image_patches(imgs_batch: ndarray,\n                       fil_size: int):\n    '''\n imgs_batch: [batch_size, channels, img_width, img_height]\n fil_size: int\n '''\n    # pad the images\n    imgs_batch_pad = np.stack([_pad_2d_channel(obs, fil_size // 2)\n                              for obs in imgs_batch])\n    patches = []\n    img_height = imgs_batch_pad.shape[2]\n\n    # For each location in the image...\n    for h in range(img_height-fil_size+1):\n        for w in range(img_height-fil_size+1):\n\n            # ...get an image patch of size [fil_size, fil_size]\n            patch = imgs_batch_pad[:, :, h:h+fil_size, w:w+fil_size]\n            patches.append(patch)\n\n    # Stack, getting an output of size\n    # [img_height * img_width, batch_size, n_channels, fil_size, fil_size]\n    return np.stack(patches)\n```", "```py\ndef _output_matmul(input_: ndarray,\n                   param: ndarray) -> ndarray:\n    '''\n conv_in: [batch_size, in_channels, img_width, img_height]\n param: [in_channels, out_channels, fil_width, fil_height]\n '''\n\n    param_size = param.shape[2]\n    batch_size = input_.shape[0]\n    img_height = input_.shape[2]\n    patch_size = param.shape[0] * param.shape[2] * param.shape[3]\n\n    patches = _get_image_patches(input_, param_size)\n\n    patches_reshaped = (\n      patches\n      .transpose(1, 0, 2, 3, 4)\n      .reshape(batch_size, img_height * img_height, -1)\n      )\n\n    param_reshaped = param.transpose(0, 2, 3, 1).reshape(patch_size, -1)\n\n    output = np.matmul(patches_reshaped, param_reshaped)\n\n    output_reshaped = (\n      output\n      .reshape(batch_size, img_height, img_height, -1)\n      .transpose(0, 3, 1, 2)\n    )\n\n    return output_reshaped\n```", "```py\nnp.matmul(self.inputs.transpose(1, 0), output_grad)\n```", "```py\ndef _param_grad_matmul(input_: ndarray,\n                       param: ndarray,\n                       output_grad: ndarray):\n    '''\n input_: [batch_size, in_channels, img_width, img_height]\n param: [in_channels, out_channels, fil_width, fil_height]\n output_grad: [batch_size, out_channels, img_width, img_height]\n '''\n\n    param_size = param.shape[2]\n    batch_size = input_.shape[0]\n    img_size = input_.shape[2] ** 2\n    in_channels = input_.shape[1]\n    out_channels = output_grad.shape[1]\n    patch_size = param.shape[0] * param.shape[2] * param.shape[3]\n\n    patches = _get_image_patches(input_, param_sizes)\n\n    patches_reshaped = (\n        patches\n        .reshape(batch_size * img_size, -1)\n        )\n\n    output_grad_reshaped = (\n        output_grad\n        .transpose(0, 2, 3, 1)\n        .reshape(batch_size * img_size, -1)\n    )\n\n    param_reshaped = param.transpose(0, 2, 3, 1).reshape(patch_size, -1)\n\n    param_grad = np.matmul(patches_reshaped.transpose(1, 0),\n                           output_grad_reshaped)\n\n    param_grad_reshaped = (\n        param_grad\n        .reshape(in_channels, param_size, param_size, out_channels)\n        .transpose(0, 3, 1, 2)\n    )\n\n    return param_grad_reshaped\n```", "```py\nnp.matmul(output_grad, self.param.transpose(1, 0))\n```", "```py\ndef _input_grad_matmul(input_: ndarray,\n                       param: ndarray,\n                       output_grad: ndarray):\n\n    param_size = param.shape[2]\n    batch_size = input_.shape[0]\n    img_height = input_.shape[2]\n    in_channels = input_.shape[1]\n\n    output_grad_patches = _get_image_patches(output_grad, param_size)\n\n    output_grad_patches_reshaped = (\n        output_grad_patches\n        .transpose(1, 0, 2, 3, 4)\n        .reshape(batch_size * img_height * img_height, -1)\n    )\n\n    param_reshaped = (\n        param\n        .reshape(in_channels, -1)\n    )\n\n    input_grad = np.matmul(output_grad_patches_reshaped,\n                           param_reshaped.transpose(1, 0))\n\n    input_grad_reshaped = (\n        input_grad\n        .reshape(batch_size, img_height, img_height, 3)\n        .transpose(0, 3, 1, 2)\n    )\n\n    return input_grad_reshaped\n```"]