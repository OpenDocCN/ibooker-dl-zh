["```py\ntext2cypher_description = {\n    \"type\": \"function\",\n    \"function\": {\n        \"name\": \"text2cypher\",\n        \"description\": \"Query the database with a user question. When other tools don't fit, fallback to use this one.\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"question\": {\n                    \"type\": \"string\",\n                    \"description\": \"The user question to find the answer for\",\n                }\n            },\n            \"required\": [\"question\"],\n        },\n    },\n}\n\ndef text2cypher(question: str):\n    \"\"\"Query the database with a user question.\"\"\"\n    t2c = Text2Cypher(neo4j_driver)\n    t2c.set_prompt_section(\"question\", question)\n    cypher = t2c.generate_cypher()\n    records, _, _ = neo4j_driver.execute_query(cypher)\n    return [record.data() for record in records]\n\nmovie_info_by_title_description = {\n    \"type\": \"function\",\n    \"function\": {\n        \"name\": \"movie_info_by_title\",\n        \"description\": \"Get information about a movie by providing the title\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"title\": {\n                    \"type\": \"string\",\n                    \"description\": \"The movie title\",\n                }\n            },\n            \"required\": [\"title\"],\n        },\n    },\n}\n\ndef movie_info_by_title(title: str):\n    \"\"\"Return movie information by title.\"\"\"\n    query = \"\"\"\n    MATCH (m:Movie)\n    WHERE toLower(m.title) CONTAINS $title\n    OPTIONAL MATCH (m)<-[:ACTED_IN]-(a:Person)\n    OPTIONAL MATCH (m)<-[:DIRECTED]-(d:Person)\n    RETURN m AS movie, collect(a.name) AS cast, collect(d.name) AS directors\n    \"\"\"\n    records, _, _ = neo4j_driver.execute_query(query, title=title.lower())\n    return [record.data() for record in records]\n\nmovies_info_by_actor_description = {\n    \"type\": \"function\",\n    \"function\": {\n        \"name\": \"movies_info_by_actor\",\n        \"description\": \"Get information about a movie by providing an actor\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"actor\": {\n                    \"type\": \"string\",\n                    \"description\": \"The actor name\",\n                }\n            },\n            \"required\": [\"actor\"],\n        },\n    },\n}\n\ndef movies_info_by_actor(actor: str):\n    \"\"\"Return movie information by actor.\"\"\"\n    query = \"\"\"\n    MATCH (a:Person)-[:ACTED_IN]->(m:Movie)\n    OPTIONAL MATCH (m)<-[:ACTED_IN]-(a:Person)\n    OPTIONAL MATCH (m)<-[:DIRECTED]-(d:Person)\n    WHERE toLower(a.name) CONTAINS $actor\n    RETURN m AS movie, collect(a.name) AS cast, collect(d.name) AS directors\n    \"\"\"\n    records, _, _ = neo4j_driver.execute_query(query, actor=actor.lower())\n    return [record.data() for record in records]\n```", "```py\nanswer_given_description = {\n    \"type\": \"function\",\n    \"function\": {\n        \"name\": \"answer_given\",\n        \"description\": \"If a complete answer to the question is already provided in the conversation, use this tool to extract it.\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"answer\": {\n                    \"type\": \"string\",\n                    \"description\": \"The answer to the question\",\n                }\n            },\n            \"required\": [\"answer\"],\n        },\n    },\n}\n\ndef answer_given(answer: str):\n    \"\"\"Extract the answer from a given text.\"\"\"\n    return answer\n```", "```py\ndef handle_tool_calls(tools: dict[str, any], llm_tool_calls: list[dict[str, any]]):\n    output = []\n    if llm_tool_calls:\n        for tool_call in llm_tool_calls:\n            function_to_call = tools[tool_call.function.name][\"function\"]\n            function_args = json.loads(tool_call.function.arguments)\n            res = function_to_call(**function_args)\n            output.append(res)\n    return output\n```", "```py\n[\n    {\n        \"function\": {\n            \"name\": \"answer_given\",\n            \"arguments\": \"{\\\"answer\\\": \\\"Dave Smith\\\"}\"\n        }\n    }\n]\n```", "```py\nquery_update_prompt = \"\"\"\n    You are an expert at updating questions to make them more atomic, specific, and easier to find the answer to.\n    You do this by filling in missing information in the question, with the extra information provided to you in previous answers.\n\n    You respond with the updated question that has all information in it.\n    Only edit the question if needed. If the original question already is atomic, specific, and easy to answer, you keep the original.\n    Do not ask for more information than the original question. Only rephrase the question to make it more complete.\n\n    JSON template to use:\n    {\n        \"question\": \"question1\"\n    }\n\"\"\"\n```", "```py\ndef query_update(input: str, answers: list[any]) -> str:\n    messages = [\n        {\"role\": \"system\", \"content\": query_update_prompt},\n        *answers,\n        {\"role\": \"user\", \"content\": f\"The user question to rewrite: '{input}'\"},\n    ]\n    config = {\"response_format\": {\"type\": \"json_object\"}}\n    output = chat(messages, model = \"gpt-4o\", config=config, )\n    try:\n        return json.loads(output)[\"question\"]\n    except json.JSONDecodeError:\n        print(\"Error decoding JSON\")\n    return []\n```", "```py\ntools = {\n    \"movie_info_by_title\": {\n        \"description\": movie_info_by_title_description,\n        \"function\": movie_info_by_title\n    },\n    \"movies_info_by_actor\": {\n        \"description\": movies_info_by_actor_description,\n        \"function\": movies_info_by_actor\n    },\n    \"text2cypher\": {\n        \"description\": text2cypher_description,\n        \"function\": text2cypher\n    },\n    \"answer_given\": {\n        \"description\": answer_given_description,\n        \"function\": answer_given\n    }\n}\n```", "```py\ntool_picker_prompt = \"\"\"\n    Your job is to choose the right tool needed to respond to the user question.\n    The available tools are provided to you in the request.\n    Make sure to pass the right and complete arguments to the chosen tool.\n\"\"\"\n```", "```py\ndef route_question(question: str, tools: dict[str, any], answers: list[dict[str, str]]):\n    llm_tool_calls = tool_choice(\n        [\n            {\n                \"role\": \"system\",\n                \"content\": tool_picker_prompt,\n            },\n            *answers,\n            {\n                \"role\": \"user\",\n                \"content\": f\"The user question to find a tool to answer: '{question}'\",\n            },\n        ],\n        model = \"gpt-4o\",\n        tools=[tool[\"description\"] for tool in tools.values()],\n    )\n    return handle_tool_calls(tools, llm_tool_calls)\n```", "```py\ndef handle_user_input(input: str, answers: list[dict[str, str]] = []):\n    updated_question = query_update(input, answers)\n    response  = route_question(updated_question, tools, answers)\n    answers.append({\"role\": \"assistant\", \"content\": f\"For the question: '{updated_question}', we have the answer: '{json.dumps(response)}'\"})\n    return answers\n```", "```py\nanswer_critique_prompt = \"\"\"\n    You are an expert at identifying if questions have been fully answered or if there is an opportunity to enrich the answer.\n    The user will provide a question, and you will scan through the provided information to see if the question is answered.\n    If anything is missing from the answer, you will provide a set of new questions that can be asked to gather the missing information.\n    All new questions must be complete, atomic, and specific.\n    However, if the provided information is enough to answer the original question, you will respond with an empty list.\n\n    JSON template to use for finding missing information:\n    {\n        \"questions\": [\"question1\", \"question2\"]\n    }\n\"\"\"\n```", "```py\ndef critique_answers(question: str, answers: list[dict[str, str]]) -> list[str]:\n    messages = [\n        {\n            \"role\": \"system\",\n            \"content\": answer_critique_prompt,\n        },\n        *answers,\n        {\n            \"role\": \"user\",\n            \"content\": f\"The original user question to answer: {question}\",\n        },\n    ]\n    config = {\"response_format\": {\"type\": \"json_object\"}}\n    output = chat(messages, model=\"gpt-4o\", config=config)\n    try:\n        return json.loads(output)[\"questions\"]\n    except json.JSONDecodeError:\n        print(\"Error decoding JSON\")\n    return []\n```", "```py\nmain_prompt = \"\"\"\n    Your job is to help the user with their questions.\n    You will receive user questions and information needed to answer the questions\n    If the information is missing to answer part of or the whole question, you will say that the information\n    is missing. You will only use the information provided to you in the prompt to answer the questions.\n    You are not allowed to make anything up or use external information.\n\"\"\"\n```", "```py\ndef main(input: str):\n    answers = handle_user_input(input)\n    critique = critique_answers(input, answers)\n\n    if critique:\n        answers = handle_user_input(\" \".join(critique), answers)\n\n    llm_response = chat(\n        [\n            {\"role\": \"system\", \"content\": main_prompt},\n            *answers,\n            {\"role\": \"user\", \"content\": f\"The user question to answer: {input}\"},\n        ],\n        model=\"gpt-4o\",\n    )\n\n    return llm_response\n```"]