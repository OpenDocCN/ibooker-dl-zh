- en: 5 Empowering agents with actions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 赋能动作代理
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: How an agent acts outside of itself using actions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理如何使用动作在自身之外进行行动
- en: Defining and using OpenAI functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和使用 OpenAI 函数
- en: The Semantic Kernel and how to use semantic functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义内核及其使用语义函数的方法
- en: Synergizing semantic and native functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协同语义和本地函数
- en: Instantiating a GPT interface with Semantic Kernel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用语义内核实例化 GPT 接口
- en: In this chapter, we explore actions through the use of functions and how agents
    can use them as well. We’ll start by looking at OpenAI function calling and then
    quickly move on to another project from Microsoft called Semantic Kernel (SK),
    which we’ll use to build and manage skills and functions for agents or as agents.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过函数的使用来探讨动作，以及代理如何使用它们。我们将首先查看 OpenAI 函数调用，然后迅速转向微软的另一个项目，称为语义内核（SK），我们将使用它来构建和管理代理或作为代理的技能和函数。
- en: We’ll finish the chapter using SK to host our first agent system. This will
    be a complete chapter with plenty of annotated code examples.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 SK 来完成本章，以托管我们的第一个代理系统。这将是一个包含大量注释代码示例的完整章节。
- en: 5.1 Defining agent actions
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 定义代理动作
- en: ChatGPT plugins were first introduced to provide a session with abilities, skills,
    or tools. With a plugin, you can search the web or create spreadsheets or graphs.
    Plugins provide ChatGPT with the means to extend the platform.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 插件首次推出是为了提供具有能力、技能或工具的会话。有了插件，你可以搜索网络或创建电子表格或图表。插件为 ChatGPT 提供了扩展平台的方式。
- en: Figure 5.1 shows how a ChatGPT plugin works. In this example, a new movie recommender
    plugin has been installed in ChatGPT. When a user asks ChatGPT to recommend a
    new movie, the large language model (LLM) recognizes that it has a plugin to manage
    that action. It then breaks down the user request into actionable parameters,
    which it passes to the new movie recommender.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 展示了 ChatGPT 插件的工作方式。在这个例子中，ChatGPT 中安装了一个新的电影推荐插件。当用户要求 ChatGPT 推荐一部新电影时，大型语言模型（LLM）识别出它有一个用于管理该动作的插件。然后，它将用户请求分解为可操作的参数，并将这些参数传递给新的电影推荐器。
- en: '![figure](../Images/5-1.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/5-1.png)'
- en: Figure 5.1 How a ChatGPT plugin operates and how plugins and other external
    tools (e.g., APIs) align with the Use External Tools prompt engineering strategy
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.1 ChatGPT 插件的工作方式以及插件和其他外部工具（例如，API）如何与“使用外部工具”提示工程策略相一致
- en: The recommender then scrapes a website showcasing new movies and appends that
    information to a new prompt request to an LLM. With this information, the LLM
    responds to the recommender, which passes this back to ChatGPT. ChatGPT then responds
    to the user with the recommended request.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐器随后抓取展示新电影的网站，并将该信息附加到对 LLM 的新提示请求中。有了这些信息，LLM 会回应推荐器，推荐器将此信息传递回 ChatGPT。然后
    ChatGPT 对用户做出推荐请求的回应。
- en: We can think of plugins as proxies for actions. A plugin generally encapsulates
    one or more abilities, such as calling an API or scraping a website. Actions,
    therefore, are extensions of plugins—they give a plugin its abilities.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将插件视为动作的代理。插件通常封装了一个或多个能力，例如调用 API 或抓取网站。因此，动作是插件的扩展——它们赋予了插件能力。
- en: AI agents can be considered plugins and consumers of plugins, tools, skills,
    and other agents. Adding skills, functions, and tools to an agent/plugin allows
    it to execute well-defined actions—figure 5.2 highlights where agent actions occur
    and their interaction with LLMs and other systems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: AI 代理可以被视为插件和插件的消费者、工具、技能和其他代理。向代理/插件添加技能、函数和工具允许它执行定义良好的动作——图 5.2 强调了代理动作发生的位置及其与
    LLM 和其他系统的交互。
- en: '![figure](../Images/5-2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/5-2.png)'
- en: Figure 5.2 How an agent uses actions to perform external tasks
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2 代理如何使用动作执行外部任务
- en: An agent action is an ability that allows it to use a function, skill, or tool.
    What gets confusing is that different frameworks use different terminology. We’ll
    define an action as anything an agent can do to establish some basic definitions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 代理动作是允许它使用函数、技能或工具的能力。令人困惑的是，不同的框架使用不同的术语。我们将定义动作为代理可以执行以建立一些基本定义的任何操作。
- en: ChatGPT plugins and functions represent an actionable ability that ChatGPT or
    an agent system can use to perform additional actions. Now let’s examine the basis
    for OpenAI plugins and the function definition.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 插件和函数代表了 ChatGPT 或代理系统可以用来执行额外动作的可执行能力。现在让我们来检查 OpenAI 插件和函数定义的基础。
- en: 5.2 Executing OpenAI functions
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 执行 OpenAI 函数
- en: OpenAI, with the enablement of plugins, introduced a structure specification
    for defining the interface between functions/plugins an LLM could action. This
    specification is becoming a standard that LLM systems can follow to provide actionable
    systems.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI 通过启用插件，引入了一种结构规范，用于定义函数/插件与 LLM 之间的接口。这个规范正在成为 LLM 系统可以遵循的标准，以提供可执行的系统。
- en: These same function definitions are now also being used to define plugins for
    ChatGPT and other systems. Next, we’ll explore how to use functions directly with
    an LLM call.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些相同的函数定义现在也被用来定义 ChatGPT 和其他系统的插件。接下来，我们将探讨如何直接使用 LLM 调用来使用函数。
- en: 5.2.1 Adding functions to LLM API calls
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 将函数添加到 LLM API 调用中
- en: Figure 5.3 demonstrates how an LLM recognizes and uses the function definition
    to cast its response as the function call.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 展示了 LLM 如何识别和使用函数定义来将其响应作为函数调用。
- en: '![figure](../Images/5-3.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/5-3.png)'
- en: Figure 5.3 How a single LLM request, including tools, gets interpreted by an
    LLM
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.3 如何解释单个 LLM 请求，包括工具
- en: Listing 5.1 shows the details of an LLM API call using tools and a function
    definition. Adding a function definition allows the LLM to reply regarding the
    function’s input parameters. This means the LLM will identify the correct function
    and parse the relevant parameters for the user’s request.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 显示了使用工具和函数定义进行 LLM API 调用的详细信息。添加函数定义允许 LLM 回复有关函数的输入参数。这意味着 LLM 将识别正确的函数并解析用户请求的相关参数。
- en: Listing 5.1 `first_function.py` (API call)
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1 `first_function.py` (API 调用)
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#1 New parameter called tools'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 新参数称为 tools'
- en: '#2 Sets the type of tool to function'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 设置工具的类型以执行功能'
- en: '#3 Provides an excellent description of what the function does'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 提供了关于函数功能的出色描述'
- en: '#4 Defines the type of parameters for input; an object represents a JSON document.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 定义输入参数的类型；一个对象代表一个 JSON 文档。'
- en: '#5 Excellent descriptions for each input parameter'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 为每个输入参数提供出色的描述'
- en: '#6 You can even describe in terms of enumerations.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 您甚至可以用枚举的方式来描述。'
- en: 'To see how this works, open Visual Studio Code (VS Code) to the book’s source
    code folder: `chapter_4/first_function.py`. It’s a good practice to open the relevant
    chapter folder in VS Code to create a new Python environment and install the `requirements.txt`
    file. If you need assistance with this, consult appendix B.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这是如何工作的，请打开 Visual Studio Code (VS Code) 到书籍的源代码文件夹：`chapter_4/first_function.py`。在
    VS Code 中打开相关章节文件夹以创建一个新的 Python 环境并安装 `requirements.txt` 文件是一个好习惯。如果您需要这方面的帮助，请参阅附录
    B。
- en: Before starting, correctly set up an `.env` file in the `chapter_4` folder with
    your API credentials. Function calling is an extra capability provided by the
    LLM commercial service. At the time of writing, this feature wasn’t an option
    for open source LLM deployments.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请正确设置 `chapter_4` 文件夹中的 `.env` 文件，并包含您的 API 凭据。函数调用是 LLM 商业服务提供的额外功能。在撰写本文时，此功能不是开源
    LLM 部署的选项。
- en: Next, we’ll look at the bottom of the code in `first_function.py,` as shown
    in listing 5.2\. Here are just two examples of calls made to an LLM using the
    request previously specified in listing 5.1\. Here, each request shows the generated
    output from running the example.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看 `first_function.py` 代码的底部，如列表 5.2 所示。这里只是使用列表 5.1 中指定的先前请求对 LLM 进行调用的两个示例。在这里，每个请求都显示了运行示例生成的输出。
- en: Listing 5.2 `first_function.py` (exercising the API)
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2 `first_function.py` (练习 API)
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#1 Previously defined function'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 之前定义的函数'
- en: '#2 Returned in the name of the function to call and the extracted input parameters'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 返回要调用的函数名称和提取的输入参数'
- en: '#3 Previously defined function'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 之前定义的函数'
- en: '#4 Returned in the name of the function to call and the extracted input parameters'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 返回要调用的函数名称和提取的输入参数'
- en: Run the `first_function.py` Python script in VS Code using the debugger (F5)
    or the terminal to see the same results. Here, the LLM parses the input request
    to match any registered tools. In this case, the tool is the single function definition,
    that is, the recommended function. The LLM extracts the input parameters from
    this function and parses those from the request. Then, it replies with the named
    function and designated input parameters.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器（F5）或终端在 VS Code 中运行 `first_function.py` Python 脚本，以查看相同的结果。在这里，LLM 解析输入请求以匹配任何已注册的工具。在这种情况下，工具是单个函数定义，即推荐的函数。LLM
    从该函数中提取输入参数，并从请求中解析这些参数。然后，它以命名函数和指定的输入参数的形式回复。
- en: NOTE  The actual function isn’t being called. The LLM only returns the suggested
    function and the relevant input parameters. The name and parameters must be extracted
    and passed into a function matching the signature to act on the function. We’ll
    look at an example of this in the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：实际函数并未被调用。LLM只返回建议的函数和相关的输入参数。必须提取名称和参数，并将它们传递给一个与签名匹配的函数以执行该函数。我们将在下一节中查看一个示例。
- en: 5.2.2 Actioning function calls
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 执行函数调用
- en: Now that we understand that an LLM doesn’t execute the function or plugin directly,
    we can look at an example that executes the tools. Keeping with the recommender
    theme, we’ll look at another example that adds a Python function for simple recommendations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经明白LLM不会直接执行函数或插件，我们可以看看一个执行工具的示例。继续遵循推荐主题，我们将看看另一个添加Python函数以进行简单推荐的示例。
- en: Figure 5.4 shows how this simple example will work. We’ll submit a single request
    that includes a tool function definition, asking for three recommendations. The
    LLM, in turn, will reply with the three function calls with input parameters (time
    travel, recipe, and gift). The results from executing the functions are then passed
    back to the LLM, which converts them back to natural language and returns a reply.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4展示了这个简单示例的工作原理。我们将提交一个包含工具函数定义的单个请求，请求三个推荐。LLM随后将回复三个带有输入参数的函数调用（时间旅行、食谱和礼物）。执行函数的结果随后被传递回LLM，它将它们转换回自然语言并返回一个回复。
- en: '![figure](../Images/5-4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/5-4.png)'
- en: Figure 5.4 A sample request returns three tool function calls and then submits
    the results back to the LLM to return a natural language response.
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.4一个示例请求返回三个工具函数调用，然后将结果提交回LLM以返回一个自然语言回复。
- en: Now that we understand the example, open `parallel_functions.py` in VS Code.
    Listing 5.3 shows the Python function that you want to call to give recommendations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了这个示例，请在VS Code中打开`parallel_functions.py`。列表5.3显示了您想要调用的Python函数，以提供推荐。
- en: Listing 5.3 `parallel_functions.py` (recommend function)
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.3 `parallel_functions.py` (推荐函数)
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#1 Checks to see if the string is contained within the topic input'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 检查字符串是否包含在主题输入中'
- en: '#2 If no topic is detected, returns the default'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 如果未检测到主题，则返回默认值'
- en: '#3 Returns a JSON object'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 返回一个JSON对象'
- en: Next, we’ll look at the function called `run_conversation`, where all the work
    starts with the request construction.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看名为`run_conversation`的函数，所有的工作都是从请求构建开始的。
- en: Listing 5.4 `parallel_functions.py` (`run_conversation`, `request`)
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.4 `parallel_functions.py` (`run_conversation`, `request`)
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 The user message asks for three recommendations.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 用户消息请求三个推荐。'
- en: '#2 Note that there is no system message.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 注意没有系统消息。'
- en: '#3 Adds the function definition to the tools part of the request'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 将函数定义添加到请求的工具部分'
- en: Listing 5.5 shows the request being made, which we’ve covered before, but there
    are a few things to note. This call uses a lower model such as GPT-3.5 because
    delegating functions is a more straightforward task and can be done using older,
    cheaper, less sophisticated language models.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5显示了请求的执行，我们之前已经讨论过，但有一些需要注意的事项。这个调用使用了一个较低模型，如GPT-3.5，因为委托函数是一个更直接的任务，可以使用较旧、较便宜、不太复杂的语言模型来完成。
- en: Listing 5.5 `parallel_functions.py` (`run_conversation`, API call)
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.5 `parallel_functions.py` (`run_conversation`, API调用)
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 LLMs that delegate to functions can be simpler models.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 委托给函数的LLM可以是更简单的模型。'
- en: '#2 Adds the messages and tools definitions'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 添加消息和工具定义'
- en: '#3 auto is the default.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 auto是默认值。'
- en: '#4 The returned message from the LLM'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 LLM返回的消息'
- en: At this point, after the API call, the response should hold the information
    for the required function calls. Remember, we asked the LLM to provide us with
    three recommendations, which means it should also provide us with three function
    call outputs, as shown in the following listing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，API调用之后，响应应该包含所需函数调用的信息。记住，我们要求LLM提供三个推荐，这意味着它也应该提供三个函数调用输出，如下所示。
- en: Listing 5.6 `parallel_functions.py` (`run_conversation`, `tool_calls`)
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.6 `parallel_functions.py` (`run_conversation`, `tool_calls`)
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '#1 If the response contains tool calls, execute them.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 如果响应包含工具调用，则执行它们。'
- en: '#2 Only one function but could contain several'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 只有一个函数，但可能包含多个'
- en: '#3 Loops through the calls and replays the content back to the LLM'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 遍历调用并将内容回放给LLM'
- en: '#4 Executes the recommend function from extracted parameters'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 从提取的参数中执行推荐函数'
- en: '#5 Appends the results of each function call to the set of messages'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 将每个函数调用的结果附加到消息集合中'
- en: '#6 Sends another request to the LLM with updated information and returns the
    message reply'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 使用更新后的信息向LLM发送另一个请求，并返回消息回复'
- en: The tool call outputs and the calls to the recommender function results are
    appended to the messages. Notice how messages now also contain the history of
    the first call. This is then passed back to the LLM to construct a reply in natural
    language.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 工具调用输出和推荐函数调用的结果被附加到消息中。注意现在消息还包含了第一次调用的历史。然后这些信息被传递回LLM以构建自然语言回复。
- en: Debug this example in VS Code by pressing the F5 key with the file open. The
    following listing shows the output of running `parallel_functions.py`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS Code中通过按F5键并打开文件来调试此示例。以下列表显示了运行`parallel_functions.py`的输出。
- en: Listing 5.7 `parallel_functions.py` (output)
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.7 `parallel_functions.py`（输出）
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This completes this simple demonstration. For more advanced applications, the
    functions could do any number of things, from scraping websites to calling search
    engines to completing far more complex tasks.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了这个简单的演示。对于更高级的应用，函数可以执行各种任务，从抓取网站到调用搜索引擎，甚至完成更复杂的任务。
- en: Functions are an excellent way to cast outputs for a particular task. However,
    the work of handling functions or tools and making secondary calls can be done
    in a cleaner and more efficient way. The following section will uncover a more
    robust system of adding actions to agents.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是针对特定任务输出的一种优秀方式。然而，处理函数或工具以及进行二次调用的任务可以通过更干净、更高效的方式进行。下一节将揭示为代理添加动作的更稳健的系统。
- en: 5.3 Introducing Semantic Kernel
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 介绍语义内核
- en: Semantic Kernel (SK) is another open source project from Microsoft intended
    to help build AI applications, which we call agents. At its core, the project
    is best used to define actions, or what the platform calls *semantic plugins*,
    which are wrappers for skills and functions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 语义内核（SK）是微软的另一个开源项目，旨在帮助构建AI应用，我们称之为代理。在其核心，该项目最好用于定义动作，或者平台所说的*语义插件*，它们是技能和函数的包装器。
- en: Figure 5.5 shows how the SK can be used as a plugin and a consumer of OpenAI
    plugins. The SK relies on the OpenAI plugin definition to define a plugin. That
    way, it can consume and publish itself or other plugins to other systems.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5展示了如何将SK用作插件以及OpenAI插件的消费者。SK依赖于OpenAI插件定义来定义插件。这样，它可以消费并发布自身或其他插件到其他系统。
- en: '![figure](../Images/5-5.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/5-5.png)'
- en: Figure 5.5 How the Semantic Kernel integrates as a plugin and can also consume
    plugins
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.5 语义内核如何作为一个插件集成，并且也可以消费插件
- en: An OpenAI plugin definition maps precisely to the function definitions in listing
    5.4\. This means that SK is the orchestrator of API tool calls, aka plugins. That
    also means that SK can help organize multiple plugins with a chat interface or
    an agent.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI插件定义精确映射到列表5.4中的函数定义。这意味着SK是API工具调用（即插件）的协调者。这也意味着SK可以帮助通过聊天界面或代理组织多个插件。
- en: Note  The team at SK originally labeled the functional modules as *skills.*
    However, to be more consistent with OpenAI, they have since renamed *skills* to
    *plugins.* What is more confusing is that the code still uses the term *skills.*
    Therefore, throughout this chapter, we’ll use *skills* and *plugins* to mean the
    same thing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：SK团队最初将功能模块标记为*技能*。然而，为了与OpenAI保持一致，他们已经将*技能*重命名为*插件*。更令人困惑的是，代码仍然使用术语*技能*。因此，在本章中，我们将使用*技能*和*插件*来表示同一概念。
- en: SK is a useful tool for managing multiple plugins (actions for agents) and,
    as we’ll see later, can also assist with memory and planning tools. For this chapter,
    we’ll focus on the actions/plugins. In the next section, we look at how to get
    started using SK.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: SK是管理多个插件（代理的动作）的有用工具，正如我们稍后将会看到的，它还可以帮助记忆和规划工具。对于本章，我们将专注于动作/插件。在下一节中，我们将探讨如何开始使用SK。
- en: 5.3.1 Getting started with SK semantic functions
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 开始使用SK语义函数
- en: SK is easy to install and works within Python, Java, and C#. This is excellent
    news as it also allows plugins developed in one language to be consumed in a different
    language. However, you can’t yet develop a native function in one language and
    use it in another.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: SK易于安装，并在Python、Java和C#中工作。这是一个好消息，因为它还允许在一个语言中开发的插件在另一种语言中被消费。然而，你目前还不能在一个语言中开发原生函数并在另一个语言中使用它。
- en: We’ll continue from where we left off for the Python environment using the `chapter_4`
    workspace in VS Code. Be sure you have a workspace configured if you want to explore
    and run any examples.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用VS Code中的`chapter_4`工作空间来处理Python环境。如果你想要探索和运行任何示例，请确保你已经配置了一个工作空间。
- en: Listing 5.8 shows how to install SK from a terminal within VS Code. You can
    also install the SK extension for VS Code. The extension can be a helpful tool
    to create plugins/skills, but it isn’t required.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 展示了如何在VS Code的终端中安装SK。你也可以安装SK的VS Code扩展。这个扩展可以是一个创建插件/技能的有用工具，但不是必需的。
- en: Listing 5.8 Installing Semantic Kernel
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.8 安装语义内核
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 Uninstalls any previous installations of SK'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 卸载SK的任何先前安装'
- en: '#2 Clones the repository to a local folder'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将仓库克隆到本地文件夹'
- en: '#3 Changes to the source folder'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 对源文件夹的更改'
- en: '#4 Installs the editable package from the source folder'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 从源文件夹安装可编辑的包'
- en: Once you finish the installation, open `SK_connecting.py` in VS Code. Listing
    5.9 shows a demo of running an example quickly through SK. The example creates
    a chat completion service using either OpenAI or Azure OpenAI.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，打开`SK_connecting.py`。列表 5.9 展示了通过SK快速运行示例的演示。该示例使用OpenAI或Azure OpenAI创建聊天完成服务。
- en: Listing 5.9 `SK_connecting.py`
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.9 `SK_connecting.py`
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 Sets the service you’re using (OpenAI or Azure OpenAI)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 设置你使用的服务（OpenAI或Azure OpenAI）'
- en: '#2 Creates the kernel'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 创建内核'
- en: '#3 Loads secrets from the .env file and sets them on the chat service'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 从 .env 文件加载机密信息并将其设置在聊天服务上'
- en: '#4 Loads secrets from the .env file and sets them on the chat service'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 从 .env 文件加载机密信息并将其设置在聊天服务上'
- en: '#5 Invokes the prompt'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 调用提示'
- en: '#6 Calls the function asynchronously'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 异步调用函数'
- en: Run the example by pressing F5 (debugging), and you should see an output similar
    to listing 5.9\. This example demonstrates how a semantic function can be created
    with SK and executed. A semantic function is the equivalent of a prompt template
    in prompt flow, another Microsoft tool. In this example, we define a simple prompt
    as a function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按F5（调试）运行示例，你应该会看到一个类似于列表 5.9 的输出。这个示例演示了如何使用SK创建并执行语义函数。语义函数相当于提示流中的提示模板，这是另一个微软工具。在这个例子中，我们定义一个简单的提示作为一个函数。
- en: It’s important to note that this semantic function isn’t defined as a plugin.
    However, the kernel can create the function as a self-contained semantic element
    that can be executed against an LLM. Semantic functions can be used alone or registered
    as plugins, as you’ll see later. Let’s jump to the next section, where we introduce
    contextual variables.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这个语义函数并不是定义为插件。然而，内核可以创建一个自包含的语义元素，该元素可以针对一个LLM执行。语义函数可以单独使用或注册为插件，正如你稍后将会看到的。让我们跳到下一节，我们将介绍上下文变量。
- en: 5.3.2 Semantic functions and context variables
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 语义函数和上下文变量
- en: Expanding on the previous example, we can look at adding contextual variables
    to the semantic function. This pattern of adding placeholders to prompt templates
    is one we’ll review over and over. In this example, we look at a prompt template
    that has placeholders for subject, genre, format, and custom.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例的基础上，我们可以看看如何向语义函数添加上下文变量。这种在提示模板中添加占位符的模式是我们将反复回顾的。在这个例子中，我们查看一个具有主题、类型、格式和自定义占位符的提示模板。
- en: Open `SK_context_variables.py` in VS Code, as shown in the next listing. The
    prompt is equivalent to setting aside a `system` and `user` section of the prompt.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS Code中打开`SK_context_variables.py`，如下一个列表所示。提示相当于设置提示的`system`和`user`部分。
- en: Listing 5.10 `SK_context_variables.py`
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.10 `SK_context_variables.py`
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '#1 Defines a prompt with placeholders'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义一个带有占位符的提示'
- en: '#2 Configures a prompt template and input variable definitions'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 配置提示模板和输入变量定义'
- en: '#3 Creates a kernel function from the prompt'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 从提示创建内核函数'
- en: '#4 Creates an asynchronous function to wrap the function call'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 创建一个异步函数来包装函数调用'
- en: '#5 Sets the kernel function arguments'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 设置内核函数参数'
- en: Go ahead and debug this example (F5), and wait for the output to be generated.
    That is the basis for setting up SK and creating and exercising semantic functions.
    In the next section, we move on to see how a semantic function can be registered
    as a skill/plugin.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调试这个示例（F5），等待输出生成。这是设置SK和创建及练习语义函数的基础。在下一节中，我们将继续了解如何将语义函数注册为技能/插件。
- en: 5.4 Synergizing semantic and native functions
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 语义函数和本地函数的协同作用
- en: Semantic functions encapsulate a prompt/profile and execute through interaction
    with an LLM. Native functions are the encapsulation of code that may perform anything
    from scraping websites to searching the web. Both semantic and native functions
    can register as plugins/skills in the SK kernel.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 语义函数封装了一个提示/配置文件并通过与 LLM 的交互来执行。原生函数是封装了可能从抓取网站到搜索网络的任何操作的代码。语义和原生函数都可以在 SK
    内核中注册为插件/技能。
- en: A function, semantic or native, can be registered as a plugin and used the same
    way we registered the earlier function directly with our API calls. When a function
    is registered as a plugin, it becomes accessible to chat or agent interfaces,
    depending on the use case. The next section looks at how a semantic function is
    created and registered with the kernel.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数，无论是语义还是原生，都可以注册为插件，并像我们直接通过 API 调用注册早期函数一样使用。当一个函数注册为插件时，它将根据用例对聊天或代理接口变得可访问。下一节将探讨如何创建和注册语义函数与内核。
- en: 5.4.1 Creating and registering a semantic skill/plugin
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 创建和注册语义技能/插件
- en: The VS Code extension for SK provides helpful tools for creating plugins/skills.
    In this section, we’ll use the SK extension to create a plugin/skill and then
    edit the components of that extension. After that, we’ll register and execute
    the plugin in the SK.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: SK 的 VS Code 扩展提供了创建插件/技能的有用工具。在本节中，我们将使用 SK 扩展创建一个插件/技能，然后编辑该扩展的组件。之后，我们将在
    SK 中注册并执行该插件。
- en: Figure 5.6 shows the process for creating a new skill within VS Code using the
    SK extension. (Refer to appendix B for directions if you need to install this
    extension.) You’ll then be given the option for the skill/plugin folder to place
    the function. Always group functions that are similar together. After creating
    a skill, enter the name and description of the function you want to develop. Be
    sure to describe the function as if the LLM were going to use it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 展示了在 VS Code 中使用 SK 扩展创建新技能的过程。（如果您需要安装此扩展，请参阅附录 B 的说明。）然后，您将获得将函数放置在技能/插件文件夹中的选项。始终将相似的功能分组在一起。创建技能后，输入您想要开发的函数的名称和描述。务必像
    LLM 将要使用它一样描述该函数。
- en: '![figure](../Images/5-6.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/5-6.png)'
- en: Figure 5.6 The process of creating a new skill/plugin
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.6 创建新技能/插件的过程
- en: You can see the completed skills and functions by opening the `skills/plugin`
    folder and reviewing the files. We’ll follow the previously constructed example,
    so open the `skills/Recommender/Recommend_Movies` folder, as shown in figure 5.7\.
    Inside this folder is a `config.json` file, the function description, and the
    semantic function/prompt in a file called `skprompt.txt`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打开 `skills/plugin` 文件夹并查看文件来查看已完成的技能和函数。我们将遵循之前构建的示例，因此打开 `skills/Recommender/Recommend_Movies`
    文件夹，如图 5.7 所示。在这个文件夹中有一个 `config.json` 文件，函数描述，以及一个名为 `skprompt.txt` 的语义函数/提示文件。
- en: '![figure](../Images/5-7.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/5-7.png)'
- en: Figure 5.7 The file and folder structure of a semantic function skill/plugin
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.7 语义函数技能/插件的文件和文件夹结构
- en: Listing 5.11 shows the contents of the semantic function definition, also known
    as the plugin definition. Note that the type is marked as `completion` and not
    of type `function` because this is a semantic function. We would define a native
    function as a type function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.11 展示了语义函数定义的内容，也称为插件定义。请注意，类型被标记为 `completion` 而不是 `function` 类型，因为这是一个语义函数。我们将定义原生函数为类型函数。
- en: Listing 5.11 `Recommend_Movies/config.json`
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.11 `Recommend_Movies/config.json`
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#1 Semantic functions are functions of type completion.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 语义函数是完成类型的函数。'
- en: '#2 We can also set the completion parameters for how the function is called.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们还可以设置函数调用的完成参数。'
- en: '#3 Defines the parameters input into the semantic function'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 定义了输入到语义函数的参数'
- en: Next, we can look at the definition of the semantic function prompt, as shown
    in listing 5.12\. The format is a little different, but what we see here matches
    the earlier examples using templating. This prompt recommends movies based on
    a list of movies the user has previously seen.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以查看语义函数提示的定义，如图表 5.12 所示。格式略有不同，但我们在这里看到的内容与之前使用模板的示例相匹配。此提示基于用户之前看过的电影列表推荐电影。
- en: Listing 5.12 `Recommend_Movies/skprompt.txt`
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.12 `Recommend_Movies/skprompt.txt`
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we’ll dive into the code that loads the skill/plugin and executes it in
    a simple example. Open the `SK_first_skill.py` file in VS Code. The following
    listing shows an abridged version highlighting the new sections.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将深入探讨加载技能/插件并在简单示例中执行它的代码。在 VS Code 中打开 `SK_first_skill.py` 文件。以下列表显示了一个突出显示新部分的缩略版本。
- en: Listing 5.13 SK_first_skill.py (abridged listing)
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.13 SK_first_skill.py（缩略列表）
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#1 Loads the prompt from the plugins folder'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从插件文件夹加载提示'
- en: '#2 List of user’s previously seen movies'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 用户之前看过的电影列表'
- en: '#3 Input is set to joined list of seen movies.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 将已看电影的列表设置为连接列表。'
- en: '#4 Function is executed asynchronously.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 函数异步执行。'
- en: The code loads the skill/plugin from the `skills` directory and the `plugin`
    folder. When a skill is loaded into the kernel and not just created, it becomes
    a registered plugin. That means it can be executed directly as is done here or
    through an LLM chat conversation via the plugin interface.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从 `skills` 目录和 `plugin` 文件夹加载技能/插件。当一个技能被加载到内核中而不是仅仅创建时，它就成为一个已注册的插件。这意味着它可以直接执行，就像这里所做的那样，或者通过插件接口通过
    LLM 聊天对话执行。
- en: Run the code (F5), and you should see an output like listing 5.13\. We now have
    a simple semantic function that can be hosted as a plugin. However, this function
    requires users to input a complete list of movies they have watched. We’ll look
    at a means to fix this by introducing native functions in the next section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码（F5），你应该会看到一个类似于列表 5.13 的输出。我们现在有一个简单的语义函数，它可以作为插件托管。然而，这个函数需要用户输入他们看过的电影完整列表。我们将在下一节介绍原生函数，以探讨如何解决这个问题。
- en: 5.4.2 Applying native functions
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 应用原生函数
- en: As stated, native functions are code that can do anything. In the following
    example, we’ll introduce a native function to assist the semantic function we
    built earlier.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，原生函数是可以做任何事情的代码。在以下示例中，我们将介绍一个原生函数来帮助我们在之前构建的语义函数。
- en: This native function will load a list of movies the user has previously seen,
    from a file. While this function introduces the concept of memory, we’ll defer
    that discussion until chapter 8\. Consider this new native function as any code
    that could virtually do anything.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此原生函数将从文件中加载用户之前看过的电影列表。虽然这个函数引入了记忆的概念，但我们将在第 8 章讨论这个问题。将这个新的原生函数视为任何可以虚拟做任何事情的代码。
- en: Native functions can be created and registered using the SK extension. For this
    example, we’ll create a native function directly in code to make the example easier
    to follow.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 SK 扩展创建和注册原生函数。对于这个例子，我们将直接在代码中创建原生函数，以便使示例更容易理解。
- en: Open `SK_native_functions.py` in VS Code. We’ll start by looking at how the
    native function is defined. A native function is typically defined within a class,
    which simplifies managing and instantiating native functions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开 `SK_native_functions.py`。我们将首先查看原生函数是如何定义的。原生函数通常在类内部定义，这简化了原生函数的管理和实例化。
- en: Listing 5.14 `SK_native_functions.py` (`MySeenMovieDatabase`)
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.14 `SK_native_functions.py` (`MySeenMovieDatabase`)
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#1 Provides a description for the container class'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 为容器类提供描述'
- en: '#2 Uses a decorator to provide function description and name'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用装饰器提供函数描述和名称'
- en: '#3 The actual function returns a list of movies in a comma-separated string.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 实际的函数返回一个以逗号分隔的字符串形式的电影列表。'
- en: '#4 Loads seen movies from the text file'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 从文本文件中加载已看电影'
- en: With the native function defined, we can see how it’s used by scrolling down
    in the file, as shown in the following listing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 原生函数定义后，我们可以通过在文件中向下滚动查看其使用方法，如下所示列表。
- en: Listing 5.15 `SK_native_functions` (remaining code)
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.15 `SK_native_functions`（剩余代码）
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#1 Loads the semantic function as shown previously'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 按照之前所示加载语义函数'
- en: '#2 Imports the skill into the kernel and registers the function as a plugin'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将技能导入内核并注册该函数为插件'
- en: '#3 Loads the native function'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 加载原生函数'
- en: '#4 Executes the function and returns the list as a string'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 执行函数并将列表作为字符串返回'
- en: '#5 Wraps the plugin call in an asynchronous function and executes'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 将插件调用封装在一个异步函数中并执行'
- en: One important aspect to note is how the native function was imported into the
    kernel. The act of importing to the kernel registers that function as a plugin/skill.
    This means the function can be used as a skill from the kernel through other conversations
    or interactions. We’ll see how to embed a native function within a semantic function
    in the next section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的重要方面是本地函数如何导入到内核中。将函数导入内核的行为将此函数注册为插件/技能。这意味着该函数可以通过其他对话或交互从内核中作为技能使用。我们将在下一节中看到如何在语义函数中嵌入本地函数。
- en: 5.4.3 Embedding native functions within semantic functions
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.3 在语义函数中嵌入本地函数
- en: There are plenty of powerful features within SK, but one beneficial feature
    is the ability to embed native or semantic functions within other semantic functions.
    The following listing shows how a native function can be embedded within a semantic
    function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: SK中有很多强大的功能，但一个有益的功能是能够在其他语义函数中嵌入本地或语义函数。以下列表显示了如何在一个语义函数中嵌入本地函数。
- en: Listing 5.16 `SK_semantic_native_functions.py` (`skprompt`)
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.16 `SK_semantic_native_functions.py` (`skprompt`)
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#1 The exact instruction text as previous'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 与之前相同的精确指令文本'
- en: '#2 The native function is referenced and identified by class name and function
    name.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 通过类名和函数名引用和识别本地函数。'
- en: The next example, `SK_semantic_native_functions.py`, uses inline native and
    semantic functions. Open the file in VS Code, and the following listing shows
    the code to create, register, and execute the functions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下一示例，`SK_semantic_native_functions.py`，使用了内联本地和语义函数。在VS Code中打开文件，以下列表显示了创建、注册和执行函数的代码。
- en: Listing 5.17 `SK_semantic_native_functions.py` (abridged)
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.17 `SK_semantic_native_functions.py`（缩略）
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '#1 Creates the prompt template config for the prompt'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 为提示创建提示模板配置'
- en: '#2 Creates an inline semantic function from the prompt'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 从提示中创建内联语义函数'
- en: '#3 Executes the semantic function asynchronously'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 异步执行语义功能'
- en: Run the code, and you should see an output like listing 5.17\. One important
    aspect to note is that the native function is registered with the kernel, but
    the semantic function is not. This is important because function creation doesn’t
    register a function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，你应该会看到一个类似于列表5.17的输出。一个需要注意的重要方面是，本地函数已注册到内核中，但语义函数没有。这很重要，因为函数创建不会注册函数。
- en: For this example to work correctly, the native function must be registered with
    the kernel, which uses the `import_plugin` function call—the first line in listing
    5.17\. However, the semantic function itself isn’t registered. An easy way to
    register the function is to make it a plugin and import it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此示例正确工作，本地函数必须使用`import_plugin`函数调用（列表5.17中的第一行）注册到内核中。然而，语义函数本身并没有注册。注册函数的一个简单方法是将它做成插件并导入。
- en: These simple exercises showcase ways to integrate plugins and skills into chat
    or agent interfaces. In the next section, we’ll look at a complete example demonstrating
    adding a plugin representing a service or GPT interface to a chat function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的练习展示了将插件和技能集成到聊天或代理界面中的方法。在下一节中，我们将查看一个完整的示例，展示如何将代表服务或GPT接口的插件添加到聊天功能中。
- en: 5.5 Semantic Kernel as an interactive service agent
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 语义内核作为交互式服务代理
- en: In chapter 1, we introduced the concept of the GPT interface—a new paradigm
    in connecting services and other components to LLMs via plugins and semantic layers.
    SK provides an excellent abstraction for converting any service to a GPT interface.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们介绍了GPT接口的概念——通过插件和语义层将服务和其他组件连接到LLMs的新范式。SK为将任何服务转换为GPT接口提供了一个出色的抽象。
- en: Figure 5.8 shows a GPT interface constructed around an API service called The
    Movie Database (TMDB; [www.themoviedb.org](http://www.themoviedb.org)). The TMDB
    site provides a free API that exposes information about movies and TV shows.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8展示了一个围绕名为The Movie Database (TMDB; [www.themoviedb.org](http://www.themoviedb.org))的API服务构建的GPT界面。TMDB网站提供了一个免费的API，可以公开电影和电视节目的信息。
- en: '![figure](../Images/5-8.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/5-8.png)'
- en: Figure 5.8 This layer architecture diagram shows the role of a GPT interface
    and the Semantic Kernel being exposed to chat or agent interfaces.
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.8 这层架构图显示了GPT接口和语义内核在聊天或代理界面中被暴露的作用。
- en: To follow along with the exercises in this section, you must register for a
    free account from TMDB and create an API key. Instructions for getting an API
    key can be found at the TMDB website ([www.themoviedb.org](http://www.themoviedb.org))
    or by asking a GPT-4 turbo or a more recent LLM.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本节的练习，您必须从TMDB注册一个免费账户并创建一个API密钥。获取API密钥的说明可以在TMDB网站上找到（[www.themoviedb.org](http://www.themoviedb.org)）或通过询问GPT-4
    turbo或更近期的LLM。
- en: Over the next set of subsections, we’ll create a GPT interface using an SK set
    of native functions. Then, we’ll use the SK kernel to test the interface and,
    later in this chapter, implement it as plugins into a chat function. In the next
    section, we look at building a GPT interface against the TMDB API.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将使用SK原生函数集创建一个GPT接口。然后，我们将使用SK内核测试该接口，并在本章的后面部分将其作为插件实现到聊天功能中。在下一节中，我们将探讨如何针对TMDB
    API构建GPT接口。
- en: 5.5.1 Building a semantic GPT interface
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 构建语义GPT接口
- en: TMDB is an excellent service, but it provides no semantic services or services
    that can be plugged into ChatGPT or an agent. To do that, we must wrap the API
    calls that TMDB exposes in a semantic service layer.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: TMDB是一个出色的服务，但它不提供语义服务或可以插入到ChatGPT或代理中的服务。为了做到这一点，我们必须在TMDB公开的API调用周围包装一个语义服务层。
- en: A semantic service layer is a GPT interface that exposes functions through natural
    language. As discussed, to expose functions to ChatGPT or other interfaces such
    as agents, they must be defined as plugins. Fortunately, SK can create the plugins
    for us automatically, given that we write our semantic service layer correctly.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 语义服务层是一个GPT接口，通过自然语言公开函数。正如讨论的那样，要将函数公开给ChatGPT或其他如代理等接口，它们必须被定义为插件。幸运的是，SK可以自动为我们创建插件，前提是我们正确编写我们的语义服务层。
- en: A native plugin or set of skills can act as a semantic layer. To create a native
    plugin, create a new plugin folder, and put a Python file holding a class containing
    the set of native functions inside that folder. The SK extension currently doesn’t
    do this well, so manually creating the module works best.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 原生插件或一组技能可以作为语义层。要创建原生插件，创建一个新的插件文件夹，并在该文件夹中放置一个包含一组原生函数的Python文件。目前SK扩展没有很好地做到这一点，所以手动创建模块效果最好。
- en: Figure 5.9 shows the structure of the new plugin called `Movies` and the semantic
    service layer called `tmdb.py`. For native functions, the parent folder’s name
    (`Movies`) is used in the import.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9展示了名为`Movies`的新插件和名为`tmdb.py`的语义服务层的结构。对于原生函数，使用父文件夹的名称（`Movies`）进行导入。
- en: '![figure](../Images/5-9.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/5-9.png)'
- en: Figure 5.9 The folder and file structure of the TMDB plugin
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.9 TMDB插件的文件夹和文件结构
- en: Open the `tmdb.py` file in VS Code, and look at the top of the file, as shown
    in listing 5.18\. This file contains a class called `TMDbService`, which exposes
    several functions that map to API endpoint calls. The idea is to map the various
    relevant API function calls in this semantic service layer. This will expose the
    functions as plugins for a chat or agent interface.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS Code中打开`tmdb.py`文件，查看文件顶部，如图5.18所示。此文件包含一个名为`TMDbService`的类，它公开了几个映射到API端点调用的函数。想法是将这个语义服务层中的各种相关API函数调用映射出来。这将使函数作为聊天或代理接口的插件公开。
- en: Listing 5.18 `tmdb.py` (top of file)
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.18 `tmdb.py`（文件顶部）
- en: '[PRE17]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#1 Prints the calls to the functions for debugging'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 打印函数调用以进行调试'
- en: '#2 Top-level service and decorator used to describe the function (good descriptions
    are important)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 顶级服务和装饰器用于描述函数（好的描述很重要）'
- en: '#3 Function wrapped in semantic wrapper; should return str'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 被语义包装器包装的函数；应返回str'
- en: '#4 Calls the API endpoint, and, if good (code 200), checks for matching genre'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 调用API端点，如果成功（代码200），则检查匹配的类型'
- en: '#5 Found the genre, returns the id'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 找到类型，返回id'
- en: The bulk of the code for the `TMDbService` and the functions to call the TMDB
    endpoints was written with the help of GPT-4 Turbo. Then, each function was wrapped
    with the `sk_function` decorator to expose it semantically.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`TMDbService`的代码以及调用TMDB端点的函数大部分是在GPT-4 Turbo的帮助下编写的。然后，每个函数都被`sk_function`装饰器包装以公开其语义。'
- en: A few of the TMDB API calls have been mapped semantically. Listing 5.19 shows
    another example of a function exposed to the semantic service layer. This function
    pulls a current top 10 list of movies playing for a particular genre.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: TMDB API的一些调用已经被语义化了。列表5.19展示了向语义服务层公开的函数的另一个示例。这个函数可以拉取特定类型的当前最热门的10部电影列表。
- en: Listing 5.19 `tmdb.py` (`get_top_movies_by_genre`)
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.19 `tmdb.py` (`get_top_movies_by_genre`)
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '#1 Decorates the function with descriptions'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用描述装饰函数'
- en: '#2 Finds the genre id for the given genre name'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 根据给定的类型名称查找genre id'
- en: '#3 Gets a list of currently playing movies'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 获取当前正在上映的电影列表'
- en: '#4 Converts genre_ids to strings'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 将genre_ids转换为字符串'
- en: '#5 Checks to see if the genre id matches movie genres'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 检查是否genre id与电影类型匹配'
- en: Look through the various other API calls mapped semantically. As you can see,
    there is a well-defined pattern for converting API calls to a semantic service.
    Before we run the full service, we’ll test each of the functions in the next section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 查看其他映射为语义的API调用。如您所见，将API调用转换为语义服务的模式已经定义得很好。在我们运行完整服务之前，我们将在下一节测试每个函数。
- en: 5.5.2 Testing semantic services
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2 测试语义服务
- en: In a real-world application, you’ll likely want to write a complete set of unit
    or integration tests for each semantic service function. We won’t do that here;
    instead, we’ll write a quick helper script to test the various functions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，您可能希望为每个语义服务函数编写一套完整的单元或集成测试。我们在这里不会这样做；相反，我们将编写一个快速的帮助脚本以测试各种函数。
- en: Open `test_tmdb_service.py` in VS Code, and review the code, as shown in listing
    5.20\. You can comment and uncomment any functions to test them in isolation.
    Be sure to have only one function uncommented at a time.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS Code中打开`test_tmdb_service.py`，并查看代码，如图表 5.20 所示。您可以注释和取消注释任何函数以单独测试它们。确保一次只取消注释一个函数。
- en: Listing 5.20 `test_tmdb_service.py`
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.20 `test_tmdb_service.py`
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#1 Instantiates the kernel'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 实例化内核'
- en: '#2 Imports the plugin service'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 导入插件服务'
- en: '#3 Inputs parameter to functions, when needed'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 在需要时将输入参数传递给函数'
- en: '#4 Executes and tests the various functions'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 执行并测试各种函数'
- en: '#5 Inputs parameter to functions, when needed'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 在需要时将输入参数传递给函数'
- en: '#6 Executes and tests the various functions'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 执行并测试各种函数'
- en: '#7 Inputs parameter to functions, when needed'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 在需要时将输入参数传递给函数'
- en: '#8 Executes and tests the various functions'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 执行并测试各种函数'
- en: '#9 Executes and tests the various functions'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '#9 执行并测试各种函数'
- en: '#10 Executes main asynchronously'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '#10 异步执行主函数'
- en: '#11 Calls print function details to notify when the function is being called'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '#11 调用打印函数详细信息以通知函数正在被调用'
- en: The real power of SK is shown in this test. Notice how the `TMDbService` class
    is imported as a plugin, but we don’t have to define any plugin configurations
    other than what we already did? By just writing one class that wrapped a few API
    functions, we’ve exposed part of the TMDB API semantically. Now, with the functions
    exposed, we can look at how they can be used as plugins for a chat interface in
    the next section.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中展示了SK的真正力量。注意`TMDbService`类是如何作为一个插件导入的，但我们不需要定义除了我们之前已经做的任何插件配置？通过只写一个封装了一些API函数的类，我们已经以语义方式公开了TMDB
    API的一部分。现在，函数公开后，我们可以在下一节中查看它们如何作为聊天界面的插件使用。
- en: 5.5.3 Interactive chat with the semantic service layer
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.3 与语义服务层的交互式聊天
- en: With the TMDB functions exposed semantically, we can move on to integrating
    them into a chat interface. This will allow us to converse naturally in this interface
    to get various information, such as current top movies.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当TMDB函数以语义方式公开时，我们可以继续将它们集成到聊天界面中。这将使我们能够在这个界面中自然地进行对话以获取各种信息，例如当前的热门电影。
- en: Open `SK_service_chat.py` in VS Code. Scroll down to the start of the new section
    of code that creates the functions, as shown in listing 5.21\. The functions created
    here are now exposed as plugins, except we filter out the chat function, which
    we don’t want to expose as a plugin. The chat function here allows the user to
    converse directly with the LLM and shouldn’t be a plugin.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS Code中打开`SK_service_chat.py`。向下滚动到创建函数的新代码部分的开始，如图表 5.21 所示。这里创建的函数现在作为插件公开，除了我们过滤掉的聊天函数，我们不希望将其作为插件公开。这里的聊天函数允许用户直接与LLM进行对话，不应作为插件。
- en: Listing 5.21 `SK_service_chat.py` (function setup)
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.21 `SK_service_chat.py`（函数设置）
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#1 Imports the TMDbService as a plugin'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将TMDbService作为插件导入'
- en: '#2 Configures the execution settings and adds filtered tools'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 配置执行设置并添加过滤工具'
- en: '#3 Configures the prompt configuration'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 配置提示配置'
- en: '#4 Defines the input template and takes full strings as user input'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 定义输入模板并接受完整的字符串作为用户输入'
- en: '#5 Adds the chat history object and populates some history'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 添加聊天历史对象并填充一些历史记录'
- en: '#6 Creates the chat function'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 创建聊天函数'
- en: Next, we can continue by scrolling in the same file to review the chat function,
    as shown in the following listing.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以继续在同一文件中滚动以审查聊天函数，如下列所示。
- en: Listing 5.22 `SK_service_chat.py` (chat function)
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.22 `SK_service_chat.py`（聊天函数）
- en: '[PRE21]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '#1 Input is taken directly from the terminal/console.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 输入直接来自终端/控制台。'
- en: '#2 If the user types exit, then exit the chat.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 如果用户输入 exit，则退出聊天。'
- en: '#3 Creates arguments to pass to the function'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 创建传递给函数的参数'
- en: '#4 Uses the utility function to call the function and execute the tool'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 使用实用函数调用函数并执行工具'
- en: Lastly, scroll down to the bottom of the file, and review the primary function.
    This is the code that calls the chat function in a loop.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，滚动到文件底部，并审查主函数。这是调用循环中聊天函数的代码。
- en: Listing 5.23 `SK_service_chat.py` (main function)
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.23 `SK_service_chat.py`（主函数）
- en: '[PRE22]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 Introduction to the user'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 对用户的介绍'
- en: '#2 Continues until chatting is False'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 继续直到聊天为 False'
- en: '#3 Calls the chat function asynchronously'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 异步调用聊天函数'
- en: Run the chat interface, run the file (F5), and then ask about movies or television
    shows of a particular genre. An example conversation session is shown in listing
    5.24\. This output shows how a request to list movies from two genres made the
    chat interface make multiple calls to the `get_top_movie_by_genre` function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 运行聊天界面，运行文件（F5），然后询问特定类型的电影或电视节目。示例对话会话如列表 5.24 所示。此输出显示了请求列出两个类型的电影时，聊天界面如何多次调用
    `get_top_movie_by_genre` 函数。
- en: Listing 5.24 `SK_service_chat.py` (example conversation)
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.24 `SK_service_chat.py`（示例对话）
- en: '[PRE23]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 LLM makes two calls to get_top_movies_by_genre.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 LLM 调用两次 get_top_movies_by_genre。'
- en: '#2 Internal call to get the genre id'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 内部调用以获取类型 ID'
- en: '#3 List of the top current action movies'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 当前最受欢迎的动作电影列表'
- en: '#4 List of the top current comedy movies'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 当前最受欢迎的喜剧电影列表'
- en: Be sure to explore the chat interface’s boundaries and what you can ask for
    from the TMDB service. For example, try asking for a list of genres for movies
    or television shows. This service is a good first try, but we can perhaps do better,
    as we’ll see in the next section.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要探索聊天界面的边界以及你可以从 TMDB 服务中请求的内容。例如，尝试请求电影或电视节目的类型列表。这个服务是一个很好的尝试，但我们可能做得更好，正如我们将在下一节中看到的那样。
- en: 5.6 Thinking semantically when writing semantic services
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 在编写语义服务时进行语义思考
- en: Now we’ve seen an excellent demonstration of converting an API into a semantic
    service interface. As it is, the functions return the titles of the top movies
    and television shows currently playing. However, by just returning the titles,
    we’re limiting the ability of the LLM to parse the results on its own.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了将 API 转换为语义服务接口的出色演示。就目前而言，这些函数返回当前正在上映的电影和电视节目的标题。然而，仅仅返回标题，我们限制了
    LLM 自行解析结果的能力。
- en: Therefore, we’ll create a v2 version of `TMDbService` to correct this and return
    the results as JSON strings. Open the file `tmdb_v2.py` in VS Code, and scroll
    down to the `get_top_movies_by_genre` function.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建 `TMDbService` 的 v2 版本来纠正这个问题，并将结果作为 JSON 字符串返回。在 VS Code 中打开文件 `tmdb_v2.py`，并滚动到
    `get_top_movies_by_genre` 函数。
- en: Listing 5.25 `tmdb_v2.py` (`get_top_movies_by_genre`)
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.25 `tmdb_v2.py` (`get_top_movies_by_genre`)
- en: '[PRE24]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 Now returns a filtered list as a JSON string'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 现在返回一个过滤后的 JSON 字符串列表'
- en: Now open `SK_service_chat.py` in VS Code, and comment and uncomment the line
    shown in listing 5.26\. This will then use version 2 of the `TMDbService` that
    outputs results as full JSON documents in a single string.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 VS Code 中打开 `SK_service_chat.py` 文件，注释和取消注释列表 5.26 中显示的行。这将使用 `TMDbService`
    的第 2 个版本，该版本以单个字符串的形式输出完整的 JSON 文档结果。
- en: Listing 5.26 `SK_service_chat.py` (modifying imports)
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.26 `SK_service_chat.py`（修改导入）
- en: '[PRE25]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '#1 Comment out this line.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 注释掉这一行。'
- en: '#2 Uncomment this line to use version 2 of the service.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 取消注释此行以使用服务的第 2 个版本。'
- en: Rerun the `SK_service_chat.py` file in VS Code, and alter your query slightly,
    as shown by the output in the following listing.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VS Code 中重新运行 `SK_service_chat.py` 文件，并稍微修改你的查询，如下列所示。
- en: Listing 5.27 `SK_service_chat.py` (`TMDb_v2` service output)
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.27 `SK_service_chat.py`（`TMDb_v2` 服务输出）
- en: '[PRE26]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#1 New query asks to include an additional filter for space'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 新查询要求包含额外的空间过滤器'
- en: '#2 The LLM calls the service and then reviews the returned results that match
    the filter.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 LLM 调用服务并审查匹配过滤器的返回结果。'
- en: Because the semantic service functions now return the complete movie listing
    in JSON, the LLM can apply additional filtering. This is the real power of semantic
    services, allowing you to process the data through the LLM. We won’t see this
    power by just returning a list of titles.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于语义服务函数现在以 JSON 格式返回完整的电影列表，LLM 可以应用额外的过滤。这是语义服务的真正力量，允许你通过 LLM 处理数据。我们不会仅仅通过返回标题列表来看到这种力量。
- en: This last exercise demonstrated the change in mentality you need to make when
    writing semantic service layers. Generally, you’ll typically want to return as
    much information as possible. Returning more information takes advantage of the
    LLM abilities to filter, sort, and transform data independently. In the next chapter,
    we’ll explore building autonomous agents using behavior trees.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后一个练习展示了在编写语义服务层时你需要做出的心态转变。通常，你通常会希望返回尽可能多的信息。返回更多信息可以利用 LLM 独立过滤、排序和转换数据的能力。在下一章中，我们将探讨使用行为树构建自主代理。
- en: 5.7 Exercises
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7 练习
- en: 'Complete the following exercises to improve your knowledge of the material:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下练习以提高你对材料的了解：
- en: '*Exercise 1*—Creating a Basic Plugin for Temperature Conversion'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*练习 1*—创建温度转换的基本插件'
- en: '*Objective *—Familiarize yourself with creating a simple plugin for the OpenAI
    chat completions API.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标*—熟悉创建简单的 OpenAI 聊天完成 API 插件。'
- en: '*Tasks:*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务:*'
- en: Develop a plugin that converts temperatures between Celsius and Fahrenheit.
  id: totrans-295
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个在摄氏度和华氏度之间转换温度的插件。
- en: Test the plugin by integrating it into a simple OpenAI chat session where users
    can ask for temperature conversions.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将其集成到简单的 OpenAI 聊天会话中测试插件，用户可以请求温度转换。
- en: '*Exercise 2*—Developing a Weather Information Plugin'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*练习 2*—开发天气信息插件'
- en: '*Objective *—Learn to create a plugin that performs a unique task.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标*—学习创建执行独特任务的插件。'
- en: '*Tasks:*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务:*'
- en: Create a plugin for the OpenAI chat completions API that fetches weather information
    from a public API.
  id: totrans-300
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 OpenAI 聊天完成 API 创建一个插件，从公共 API 获取天气信息。
- en: Ensure the plugin can handle user requests for current weather conditions in
    different cities.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保插件可以处理用户对不同城市当前天气状况的请求。
- en: '*Exercise 3*—Crafting a Creative Semantic Function'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*练习 3*—制作一个创意语义功能'
- en: '*Objective *—Explore the creation of semantic functions.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标*—探索创建语义功能。'
- en: '*Tasks:*'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务:*'
- en: Develop a semantic function that writes a poem or tells a children’s story based
    on user input.
  id: totrans-305
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个基于用户输入写诗或讲述儿童故事的语义功能。
- en: Test the function in a chat session to ensure it generates creative and coherent
    outputs.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在聊天会话中测试该函数，以确保它生成创意和连贯的输出。
- en: '*Exercise 4*—Enhancing Semantic Functions with Native Functions'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*练习 4*—使用原生函数增强语义功能'
- en: '*Objective *—Understand how to combine semantic and native functions.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标*—了解如何结合语义和原生函数。'
- en: '*Tasks:*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务:*'
- en: Create a semantic function that uses a native function to enhance its capabilities.
  id: totrans-310
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个使用原生函数增强其功能的语义功能。
- en: For example, develop a semantic function that generates a meal plan and uses
    a native function to fetch nutritional information for the ingredients.
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，开发一个生成餐单的语义功能，并使用原生函数获取食材的营养信息。
- en: '*Exercise 5*—Wrapping an Existing Web API with Semantic Kernel'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*练习 5*—使用语义内核封装现有的 Web API'
- en: '*Objective *—Learn to wrap existing web APIs as semantic service plugins.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标*—学习将现有的网络 API 封装为语义服务插件。'
- en: '*Tasks:*'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务:*'
- en: Use SK to wrap a news API and expose it as a semantic service plugin in a chat
    agent.
  id: totrans-315
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SK 将新闻 API 封装并作为聊天代理中的语义服务插件公开。
- en: Ensure the plugin can handle user requests for the latest news articles on various
    topics.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保插件可以处理用户对各种主题的最新新闻文章的请求。
- en: Summary
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Agent actions extend the capabilities of an agent system, such as ChatGPT. This
    includes the ability to add plugins to ChatGPT and LLMs to function as proxies
    for actions.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理动作扩展了代理系统的功能，如 ChatGPT。这包括向 ChatGPT 和 LLM 添加插件以作为动作代理的能力。
- en: OpenAI supports function definitions and plugins within an OpenAI API session.
    This includes adding function definitions to LLM API calls and understanding how
    these functions allow the LLM to perform additional actions.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAI 支持在 OpenAI API 会话中定义函数和插件。这包括向 LLM API 调用中添加函数定义，并理解这些函数如何允许 LLM 执行额外的操作。
- en: The Semantic Kernel (SK) is an open source project from Microsoft that can be
    used to build AI applications and agent systems. This includes the role of semantic
    plugins in defining native and semantic functions.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义内核（SK）是微软的一个开源项目，可用于构建AI应用程序和代理系统。这包括语义插件在定义原生和语义函数中的作用。
- en: Semantic functions encapsulate the prompt/profile template used to engage an
    LLM.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义函数封装了用于与LLM互动的提示/配置文件模板。
- en: Native functions encapsulate code that performs or executes an action using
    an API or other interface.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生函数封装了使用API或其他接口执行或执行动作的代码。
- en: Semantic functions can be combined with other semantic or native functions and
    layered within one another as execution stages.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义函数可以与其他语义或原生函数结合，并在执行阶段相互层叠。
- en: SK can be used to create a GPT interface over the top of API calls in a semantic
    service layer and expose them as chat or agent interface plugins.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SK可以在语义服务层上创建一个GPT接口，并在聊天或代理接口插件中暴露它们。
- en: Semantic services represent the interaction between LLMs and plugins, as well
    as the practical implementation of these concepts in creating efficient AI agents.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义服务代表了LLMs（大型语言模型）和插件之间的交互，以及这些概念在实际创建高效AI代理中的应用实现。
