["```py\nimport math\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(6345245)                  ①\n\nN=200                                    ②\nP_random_pseudo=np.random.rand(N,N)      ③\n```", "```py\n!pip install ghalton\nimport ghalton\n\nsequencer = ghalton.GeneralizedHalton(7,23)\nP_random_quasi = np.array(sequencer.get(N))\n```", "```py\nu1 = np.random.uniform(size=(N))                        ①\nu2 = np.random.uniform(size=(N))                        ①\n\nP_BM_x = np.sqrt(-2*np.log(u1))*np.cos(2*math.pi*u2)    ②\nP_BM_y = np.sqrt(-2*np.log(u1))*np.sin(2*math.pi*u2)    ②\n```", "```py\nimport random\n\nP_CLT_x=[2.0 * math.sqrt(N) * (sum(random.randint(0,1) for x in range(N)) / N - 0.5)\n➥ for x in range(N)]\nP_CLT_y=[2.0 * math.sqrt(N) * (sum(random.randint(0,1) for x in range(N)) / N - 0.5)\n➥ for x in range(N)]\n```", "```py\n!pip install sobol_seq\nimport sobol_seq\nP_sobel=sobol_seq.i4_sobol_generate(2,N)\n```", "```py\n!pip install pyDOE\nfrom pyDOE import *\nP_LHS=lhs(2, samples=N, criterion='center')\n```", "```py\nf, (ax1, ax2) = plt.subplots(ncols=2, figsize=(18,8))\nf, (ax3,ax4) = plt.subplots(ncols=2, figsize=(18,8))\nf, (ax5, ax6) = plt.subplots(ncols=2, figsize=(18,8))\nax1.scatter(P_random_pseudo[:,0], P_random_pseudo[:,1], color=\"gray\")\nax2.scatter(P_random_quasi[:100], P_random_quasi[100:], color=\"red\")\nax3.scatter(P_BM_x, P_BM_y, color=\"green\")\nax4.scatter(P_CLT_x, P_CLT_y, color=\"cyan\")\nax5.scatter(P_sobel[:,0], P_sobel[:,1], color=\"magenta\")\nax6.plot(P_LHS[:,0], P_LHS[:,1], \"o\")\n\nax1.set_title(\"Pseudo-random\")\nax2.set_title(\"Quasi-random\")\nax3.set_title(\"Box-Muller\")\nax4.set_title(\"Central Limit Theorem\")\nax5.set_title(\"Sobol\")\nax6.set_title(\"Latin Hypercube\")\nplt.show()\n```", "```py\n!pip install -U pymoo\nfrom pymoo.core.problem import Problem                         ①\nfrom pymoo.operators.sampling.rnd import FloatRandomSampling   ②\nfrom pymoo.util import plotting                                ③\n\nproblem = Problem(n_var=2, xl=0, xu=1)                         ④\n\nsampling = FloatRandomSampling()                               ⑤\n\nX = sampling(problem, 200).get(\"X\")                            ⑥\nplotting.plot(X, no_fill=True)                                 ⑦\n```", "```py\nfrom pymoo.operators.sampling.lhs import LHS      ①\n\nsampling = LHS()\n\nX = sampling(problem, 200).get(\"X\")\nplotting.plot(X, no_fill=True)\n```", "```py\nper1=np.random.permutation(10)                               ①\nprint(per1)\n\nper2 = np.array([5, 4, 9, 0, 1, 2, 6, 8, 7, 3])              ②\nnp.random.shuffle(per2)                                      ②\nprint(per2)\n\npop_init = np.arange(50).reshape((10,5))                     ③\nnp.random.permutation(pop_init)                              ③\n\nfrom itertools import combinations                           ④\nsize=5                                                       ④\nones=2                                                       ④\n\nfor pos in map(set, combinations(range(size), ones)):        ④\n     print([int(i in pos) for i in range(size)], sep='\\n')   ④\n```", "```py\nimport osmnx as ox\nimport random\nfrom collections import deque\nfrom optalgotools.structures import Node\n\nG = ox.graph_from_place(\"University of Toronto\")\nfig, ax = ox.plot_graph(G)\n\ndef randomized_search(G, source, destination):                  ①\n    origin = Node(graph = G, osmid = source)\n    destination = Node(graph = G, osmid = destination)\n\n    route = [] \n    frontier = deque([origin])\n    explored = set()\n    while frontier:\n        node = random.choice(frontier)                          ②\n        frontier.remove(node)\n        explored.add(node.osmid)\n\n        for child in node.expand():\n            if child not in explored and child not in frontier:\n                if child == destination:\n                    route = child.path()\n                    return route\n                frontier.append(child)\n\n    raise Exception(\"destination and source are not on same component\")\n\nrandom_route = randomized_search(G, 24959528, 1480794706)       ③\n\nfig, ax = ox.plot_graph_route(G, random_route)                  ④\n```", "```py\nInitialization: Randomly generate an initial population M(0)\n\nEvaluate all individuals: Compute and save the fitness f(m) for each individual in the current population M(t)\n\nWhile termination criteria are not met\n    Select parents: Define selection probabilities p(m)for each individual p in M(t)\n    Apply crossover: Generate M(t+1) by probabilistically selecting individuals from M(t) to produce offspring via genetic operators\n    Apply mutation: Introduce random changes to individuals\n    Evaluate: evaluate the fitness of the new individuals\n    Select survivors: select individuals to form the next generation\n```", "```py\nimport numpy as np\nimport random\nfrom tqdm.notebook import tqdm\nfrom copy import copy\nimport matplotlib.pyplot as plt\n\ndef profit(x):\n    return -20*x*x+6200*x-350000\n```", "```py\ndef init_pop(pop_size, chromosome_length):\n    ints = [random.randint(75,235) for i in range(pop_size)]      ①\n    strs = [bin(n)[2:].zfill(chromosome_length) for n in ints]    ②\n    bins = [[int(x) for x in n] for n in strs]                    ③\n    return bins                                                   ④\n```", "```py\ndef fitness_score(population):\n    fitness_values = []\n    num = []\n    for i in range(len(population)):\n        num.append(int(\"\".join(str(x) for x in population[i]), base=2))  ①\n        fitness_values.append(profit(num[i]))                            ②\n    tuples = zip(*sorted(zip(fitness_values, population),reverse=True))  ③\n    fitness_values, population = [list(t) for t in tuples]               ④\n    return fitness_values, population                                    ⑤\n```", "```py\ndef select_parent(population, num_parents):\n    parents=random.sample(population, num_parents)     ①\n    return parents                                     ②\n```", "```py\ndef roulette_wheel_selection(population, num_parents):\n    fitness_values, population = fitness_score(population)                 ①\n    total_fitness = sum(fitness_values)\n    probabilities = [fitness / total_fitness for fitness in fitness_values]②\n\n    selected_parents = [] \n    for i in range(num_parents):                                           ③\n        r = random.random()                                                ④\n\n        cumulative_probability = 0                                         ⑤\n        for j in range(len(population)):\n            cumulative_probability += probabilities[j]\n            if cumulative_probability > r:\n                selected_parents.append(population[j])\n                break\n\n    return selected_parents\n```", "```py\ndef crossover(parents, crossover_prob): \n    chromosome_length = len(parents[0]) \n    if crossover_prob > random.random():                                  ①\n        cross_point = random.randint(0,chromosome_length)                 ②\n        parents+=tuple([(parents[0][0:cross_point+1] +parents[1][cross_   ③\npoint+1])]) \n        parents+=tuple([(parents[1][0:cross_point+1] +parents[0][cross_   ④\npoint+1])]) \n    return parents                                                        ⑤\n```", "```py\ndef mutation(population, mutation_prob) :\n    chromosome_length = len(population[0])\n    for i in range(len(population)):               ①\n        for j in range(chromosome_length-1):       ②\n            if mutation_prob > random.random():    ③\n                if population[i][j]==1:            ④\n                    population[i][j]=0             ④\n                else:                              ④\n                    population[i][j]=1             ④\n    return population                              ⑤\n```", "```py\ndef BGA(population, num_gen, num_parents, crossover_prob, mutation_prob, use_tqdm =\n➥ False):\n    states = []                                             ①\n    best_solution = []                                      ①\n    best_score = 0                                          ①\n    if use_tqdm: pbar = tqdm(total=num_gen)\n    for _ in range(num_gen):                                ②\n        if use_tqdm: pbar.update()\n        scores, population = fitness_score(population)      ③\n        current_best_score = scores[0]                      ④\n        current_best_solution = population[0]               ④\n        states.append(current_best_score)\n        if current_best_score > best_score: \n            best_score = current_best_score\n            best_solution = int(\"\".join(str(x) for x in\n            ➥ copy(current_best_solution)), base=2)\n        parents = select_parent(population, num_parents)    ⑤\n        parents = crossover(parents, crossover_prob)        ⑥\n        population = mutation(population,mutation_prob)     ⑦\n    return best_solution, best_score, states                ⑧\n```", "```py\nnum_gen = 1000\npop_size = 5\ncrossover_prob = 0.7\nmutation_prob = 0.3\nnum_parents = 2\n\nchromosome_length = 8\nbest_score = -100000 \n\npopulation = init_pop(pop_size, chromosome_length)\nprint(\"Initial population: \\n\", population)\n```", "```py\nInitial population: [[1, 1, 1, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 1, 0], [1, 1, 0, 1, 1, 1, 0, 1], [1, 1, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 0, 0, 0, 0]]\n```", "```py\nbest_solution, best_score, states = BGA(population, num_gen, num_parents,\n➥ crossover_prob, mutation_prob, use_tqdm=True)\n```", "```py\nOptimal ticket price ($): 155\nProfit ($): 130500\n```", "```py\nfrom pymoo.algorithms.soo.nonconvex.ga import GA\nfrom pymoo.operators.crossover.pntx import PointCrossover, \n➥ SinglePointCrossover,\n➥ TwoPointCrossover\nfrom pymoo.operators.mutation.pm import PolynomialMutation\nfrom pymoo.operators.repair.rounding import RoundingRepair\nfrom pymoo.operators.sampling.rnd import FloatRandomSampling\nfrom pymoo.core.problem import Problem\nfrom pymoo.optimize import minimize\n```", "```py\nclass TicketPrice(Problem):\n\n    def __init__(self):                             ①\n        super().__init__(n_var=1,\n                         n_obj=1,\n                         n_constr=0,\n                         xl=75.0,\n                         xu=235.0, vtype=float)     ②\n\n    def _evaluate(self, x, out, *args, **kwargs):   ③\n        out[\"F\"]= 20*x*x-6200*x+350000              ④\n```", "```py\nproblem = TicketPrice()                                                  ①\nalgorithm = GA(\n    pop_size=100,\n    sampling=FloatRandomSampling(),\n    crossover=PointCrossover(prob=0.8, n_points=2),\n    mutation = PolynomialMutation(prob=0.3, repair=RoundingRepair()),\n    eliminate_duplicates=True\n)                                                                        ②\n\nres = minimize(problem, algorithm, ('n_gen', 100), seed=1, verbose=True) ③\n\nprint(f\"Optimal ticket price ($): {res.X}\")                              ④\nprint(f\"Profit ($): {-res.F}\")                                           ⑤\n```", "```py\nOptimal ticket price ($): [155]\nProfit ($): [130500.]\n```"]