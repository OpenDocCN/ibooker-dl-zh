- en: 12 Where to go from here
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Expanding the dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing our ACH processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving further into FinTech
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we worked through an entire program increment—starting from research
    spikes, we derived a minimum viable product (MVP) and enhanced the product based
    on feedback from our stakeholders. Along the way, we explored programming with
    Python using FastAPI to document and power our APIs. Furthermore, we used Next.js
    and Material UI to present the data stored in our Postgres database. Working on
    this project expanded our knowledge of FinTech and Automated Clearing House processing.
  prefs: []
  type: TYPE_NORMAL
- en: However, we only scratched the surface of what is possible. By processing ACH
    transactions, we were able to drive a lot of interesting features you are likely
    to encounter on a regular basis. In other words, the project is now at a point
    where you can expand it to different areas of software development and finance.
    This chapter shares some ideas you can use to improve the project, and figure
    12.1 shows an overview of various possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a company  Description automatically generated](../Images/CH12_F01_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1  Expanding our project
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 12.1 Backend processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We built the backend processing using Python, FastAPI Framework, and a database
    running Postgres. While we had a chance to touch on all those areas, we did not
    really examine them in depth, but now it’s a perfect time for you to investigate
    some of the possibilities we skipped or were not able to cover. This section touches
    on some areas of the backend that you may find both interesting and valuable.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.1 Asynchronous processing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should have a better understanding of ACH processing at this point, so let’s
    investigate some possibilities for enhancing the parsing of uploaded files. When
    uploading a file, we currently must wait for the file to load and process before
    a response is returned. For large files, this is simply not going to be a nice
    experience as the process may time out and users may not realize the file is still
    loading in the background. This downside may result in users trying to process
    the file a second, third, or fourth time. Depending on the safeguards we have
    in place, it could very well lead to duplicate transactions being posted to accounts
    if there is no way to identify the file is the same (such as computing a hash).
  prefs: []
  type: TYPE_NORMAL
- en: We need to worry not only about large files, but also about the ancillary processing
    that goes along with file loading. We saw a piece of this with OFAC scanning and
    how we would likely need to integrate scans into the processing of an ACH file
    itself. You would also need to post the transactions to the account, debiting
    or crediting the account as appropriate. When OFAC scanning and the accounts are
    separate services or require additional API calls, you will see a degradation
    of the user experience when larger files or remote services are involved.
  prefs: []
  type: TYPE_NORMAL
- en: One way to deal with this problem is to introduce asynchronous processing to
    the file load and then process the file in steps. By introducing this type of
    processing, you’ll also have additional opportunities to improve the user experience.
    Imagine that a user loads a file. As soon as you can confirm the file is uploaded
    successfully, you can respond to the user at that point. The file can then be
    processed and the user alerted through a message on the dashboard, an email, or
    text. To implement this feature, you will need to introduce a file status and
    track the file through the various stages.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.2 ORM frameworks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An object-relational mapper (ORM) allows mapping objects to a database and can
    simplify the interactions between our classes and the database. ORMs such as SQL­Alchemy
    and Peewee are popular options for Python and work with a variety of databases,
    including our Postgres database. So, why didn’t we use an ORM?
  prefs: []
  type: TYPE_NORMAL
- en: We believe that ORMs are very handy, but the level of abstraction that comes
    with them gives them a learning curve. Of course, learning pure SQL has its own
    learning curve! Now that you have learned some SQL concepts and created a fair
    number of queries, it’s a great time to see whether you could drop in an ORM and
    replace some of the handwritten SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.3 Application programming interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RESTful APIs are ubiquitous in the industry at this point, and FastAPI gave
    us a great way to build APIs in our application. It also allowed us to easily
    generate OpenAPI documentation, so there were plenty of opportunities to learn
    about API development. We also took a brief look at API managers such as WSO2\.
  prefs: []
  type: TYPE_NORMAL
- en: We built enough APIs to demonstrate the ACH processing and some dashboard functionality,
    but to have a fully functioning dashboard, we would need to generate additional
    APIs and functionality. For instance, the dashboard should provide the ability
    to add/update/delete companies, delete uploaded files, and undo anything related
    to the deleted file (e.g., OFAC-related scans). You could expand or enhance the
    current APIs in plenty of places in the project.
  prefs: []
  type: TYPE_NORMAL
- en: Another option would be to start incorporating GraphQL. While RESTful APIs are
    still the predominant API standard, there is still a place for GraphQL. Regardless
    of whether we want to migrate away from REST or use it in conjunction with our
    RESTful APIs, GraphQL is an interesting option worth exploring. If nothing else,
    you can gain some hands-on experience, so that you have an informed opinion when
    another team wants to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2 Infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most companies and projects have a robust infrastructure—it supports the long-term
    sustainability of the project. For example, projects need to be built, packaged,
    and deployed in some form. This process may require code merges, reviews, and
    scanning for vulnerabilities or just ensuring the code meets existing standards.
    In this section, we look at how to improve the infrastructure of the ACH dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.1 Docker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the ACH dashboard, we relied heavily on Docker, not just because container
    technology is important to understand and get comfortable with, but also because
    it is useful when exploring other technologies and products.
  prefs: []
  type: TYPE_NORMAL
- en: Companies such as Atlassian have Docker images that allow us to run their products,
    which facilitates evaluating them in a sandbox environment. We saw how easy it
    was to get Postgres up and running with a Docker image. In addition, the WSO2
    API Manager was also available to download from Docker. You should keep in mind
    that whenever you want to explore something new, there may be a container that
    lets you start working quickly. Whether it is an official image from Docker on
    Golang, MongoDB, or a Debian Linux distribution, you can explore a wealth of things
    even without installing a bunch of products on your machine—just use a container
    and get rid of it once you are done.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.2 Multitenant environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although there are a few flavors of multitenant environments, we consider that
    a multi­tenant environment involves two distinct entities (financial institutions)
    sharing the same database table. We only considered this application being used
    by Futuristic FinTech. But what if you wanted or needed to support additional
    financial institutions? This can be tackled in several ways. First, since the
    application runs as separate services, you could simply look at spinning up additional
    containers to handle the new financial institution. You should be able to do that
    without any additional setup. Each financial institution would be running on their
    own instance, and you would have different DNS names pointing to those locations,
    such as http://bankA.dashboard.com or http://bankB.dashboard.com.
  prefs: []
  type: TYPE_NORMAL
- en: Another option would be to update the database so that the tables also utilize
    a tenant ID. which could be the ABA number for the bank or some other identifier.
    This option allows the bank to exist in the same database. The identifier does
    not necessarily need to be added to all the tables (e.g., the individual ACH record
    tables do not need an identifier because they are dependent on the ACH file table),
    meaning the ACH file itself can be tied to a particular bank and then all the
    records within that file will automatically be associated with that bank. However,
    you would need to review the queries to ensure that it is not possible to pull
    bank data using a UUID of another bank.
  prefs: []
  type: TYPE_NORMAL
- en: There are pros and cons to using a single database versus multiple databases.
    Depending on the industry, company, and governing regulations, customer may be
    required to be isolated in databases and even restricted to using their own hardware.
    However, adding other banks that can use the dashboard with their own routing
    numbers, companies, and similar, would let you explore different types of architectures
    and a chance to address these types of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.3 Continuous integration and delivery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our project used several containers running under Docker. This approach worked
    well enough for our needs, especially with running our database in a container.
    We were able to bring the container down and start with a fresh database as needed.
    A challenge that we encountered was taking our project from our IDE or a source
    control system such as GitHub and deploying it to those containers because that
    is currently a manual process.
  prefs: []
  type: TYPE_NORMAL
- en: A great direction to explore (especially if you have not had much opportunity
    to do so) is to look at various ways to automate those tasks. This gets you moving
    in a continuous integration (CI) and continuous deployment (CD) direction. For
    instance, you could automate moving and/or building the code into the appropriate
    containers from your IDE. You could also create an instance of a CI/CD server
    such as Jenkins and learn to build and deploy the code from there. Furthermore,
    you could also use GitHub Actions to deploy the code, although with the current
    infrastructure setup to be running in a local Docker container, using a local
    Jenkins server may be easier.
  prefs: []
  type: TYPE_NORMAL
- en: A build server such as Jenkins allows you to automate other tasks as part of
    your build, such as running unit tests, scanning for security vulnerabilities,
    and performing a slew of other tasks. You are likely to find these types of build
    servers at companies of any size and in any industry.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.4 Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We tried to introduce several methods of testing the application, drawing mostly
    on TDD and BDD. We did not have a chance to revisit load testing of our APIs using
    Locust after it was introduced. We also did not do too much UI testing, besides
    a few tests in Jest and Playwright.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the tests and reviewing the test coverage would be a great way to
    familiarize yourself with the testing process. You could also ensure the tests
    are robust enough to work when being run through a CI/CD server. A lot can be
    learned from writing tests and ensuring that they run through a release pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.5 Database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used Postgres as our database of choice, but you are certainly not limited
    to using Postgres. Changing the database can be tied to exploring ORM frameworks
    as they provide a level of abstraction that can be helpful when the underlying
    database needs to be swapped. If the business has another vendor or database product
    they prefer, you often must go with that database. If you are interested in selling
    a product and allowing customers to install it in their environment, having flexibility
    in the database choice can be a big selling point. If a company uses Oracle database
    and your product requires a Postgres database, customers may not be interested
    in the overhead associated with managing another database product.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is not just to swap out the RDMS from Postgres to some other
    vendor but also to consider exploring a NoSQL database such as MongoDB. While
    Postgres was a great choice for storing the data for the ACH dashboard, it may
    be interesting to start moving some of the tables over to MongoDB. You could begin
    with something small, such as the `bank_routing_numbers` table and then look for
    other tables that can be moved. Do you need MongoDB for the ACH dashboard? No,
    but you already understand the table structure and data that may make exploring
    and transitioning to a new database interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3 User interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot can be done from the UI perspective if you want to explore the other end
    of development. Throughout the project, we used React and the Next.js framework
    to build the interface. You can use other React frameworks or switch gears and
    use Angular or even plain old HTML, CSS, and JavaScript! It all depends on where
    your interests and needs lie.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.1 Charts and forms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used Recharts to create some scatterplots, bar graphs, and pie charts. However,
    we did not go in depth, and you could certainly work on adding new charts and
    visualizing other aspects of the ACH files. Figures 12.2 and 12.3 show two sample
    charts, visualizing ACH files over a period of time. As the current charts focus
    on the existing contents of the files, they would be a great addition for our
    users.
  prefs: []
  type: TYPE_NORMAL
- en: You could also let users choose the type of chart they want to see the data
    displayed in. It would also be nice to have some interactivity added to the charts,
    such as dynamically adjusting the data or navigating to other pages in response
    to user actions. By adding additional charts and interactivity, you may improve
    the user experience and make the dashboard even more practical.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of the dashboard that could use some updating is the basic manage­ment
    of information through using forms. For instance, the company information was
    displayed, but it was not possible to update it. You could enable updating, perform
    validation, or try different methods of presenting the data to the user. We also
    used a lot of DataGrid elements to display our data. You may continue to use those
    or design other components to display data. This may lead you to explore concepts
    such as those in *Data-Oriented Programming* (2022, Manning) by Yehonathan Sharvit.
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph of a number of columns  Description automatically generated](../Images/CH12_F02_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2  Payroll by month over the year
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![A graph of a graph of a number of companies  Description automatically generated
    with medium confidence](../Images/CH12_F03_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3  ACH returns by company
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 12.3.2 Configurable dashboards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You saw that there are at least three levels of progression (and possibly more)
    when it comes to configurable dashboards. You could create some more prepackaged
    components that users could drag onto the dashboard screen to configure what they
    want to see when they view the main dashboard and company level. While that would
    give users more flexibility and could greatly benefit them, we can provide them
    with even more customization.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of choosing from prepackaged components, what if you allowed them to
    customize and configure their own components? By allowing the user to pick the
    fields that are being displayed and generating charts based on that information,
    you give them finer control over the UI.
  prefs: []
  type: TYPE_NORMAL
- en: The next progression would be to allow users to write their own components using
    an API provided by the dashboard or backend. Products such as Jenkins or the Atlassian
    suite let third parties to write tools that extend the product functionality.
    Imagine the ACH dashboard UI had a marketplace where custom user components are
    integrated into the dashboard using the type of customization we previously described.
    Perhaps users want to publish messages to Microsoft Teams or a Slack/Discord channel
    to alert when an ACH file is loaded, an exception occurred processing a file,
    or there is a transaction for a VIP customer.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.3 Mobile version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used APIs to ensure the backend and the UI were separated. Not only is using
    an API a great way to separate components, but it also lets you create other ways
    (or channels) for users to communicate with the application. For instance, you
    could use React Native, Dart, Swift, Kotlin, or anything you desired to design
    a mobile version of the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach for a mobile application would be to allow customers (companies)
    to create batches and enter transactions for the ACH system right from their Mobile
    App! So, even when dealing with the ACH and FinTech, we can still work in this
    area as well.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4 Finance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we already have a lot of knowledge in the technical side of things and want
    to continue to expand the capabilities of the application, there are numerous
    possibilities for that as well.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.1 Accounts and customers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the first tasks we would suggest undertaking is the addition of accounts
    to the application. Whether they exist in the same database or as a separate service
    is a decision that can be made as part of the overall design. The addition of
    accounts brings up a few possibilities, not the least of which is that if you
    have account numbers, those accounts must belong to customers. The relationship
    between customers and accounts is no trivial matter, and you can look at handling
    relationships on accounts such as the primary/secondary owners or authorized signers,
    to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: With accounts in the database (or posted via an API to a core banking product),
    the ACH transactions can be posted to the account. This has a cascading effect
    of causing you to handle insufficient fund conditions (also known as NSF), errors
    with the wrong or incorrect account number, interest accruals, and statements.
  prefs: []
  type: TYPE_NORMAL
- en: When an account has insufficient funds to cover a transaction, this can create
    a whole new world of transfers for accounts. You may have overdraft protection
    on the account or may transfer funds from another account to cover the charges.
    Furthermore, you may want to look at scheduled transfer or bill payments.
  prefs: []
  type: TYPE_NORMAL
- en: When a transaction does not post because of insufficient funds or an invalid
    account number or any number of other conditions, it may be returned or unposted.
    The way you need to deal with returned or unposted items may vary from one customer
    to another, as well as with the circumstances of the situation.
  prefs: []
  type: TYPE_NORMAL
- en: All of this account activity—such as transactions posting, overdraft transfers
    taking place and associated fees—must be reflected on the customer’s monthly statement.
    These statements and notices may be mailed via snail mail, email, or available
    online for viewing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, most of what is previously done also needs to be reversed. For instance,
    if a transaction posts multiple times to an account because of some error, you
    need to be able to safely reverse that debit or credit. This could also cause
    a cascading effect of having to undo the transfer for an overdraft, as well as
    any associated fees the account may have incurred due to the erroneous transaction
    postings.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.2 ACH origination and returns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ACH origination is the process of creating ACH transactions such as credits
    and debits that will be processed by the ACH network. In our project, we focused
    on receiving and processing ACH files within the dashboard. Financial institutions
    may originate ACH files to help facilitate movement of funds between the bank
    and their customers. We kind of touched on the process of originating files with
    the creation of our ACH files for testing. However, with the addition of companies
    to our dashboard, some additional opportunities for development arise when it
    comes to originating files. The companies that have defined the database may want
    to originate files for paying their employees (payroll) or other businesses/companies.
    You would need to provide the ability to create batches with transaction entries/addenda
    as necessary. The financial institution would then send these batches on behalf
    of the company.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of ACH processing is the need to process returns. An ACH return
    happens when the financial institution rejects the transaction. Examples of why
    this might happen are incorrect account information, insufficient funds, or a
    stop payment on the transaction. With an ACH return, you would be returning the
    funds to an account they came from and possibly charging a fee.
  prefs: []
  type: TYPE_NORMAL
- en: By adding the functionality for ACH origination and handling of returns, you
    are beginning to build a more complete ACH-processing system.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.3 Positive Pay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another feature you could consider is building a Positive Pay system. Positive
    Pay is a system of fraud prevention originally created for check processing, but
    it has been expanded to other transaction processing areas as well. Basically,
    with Positive Pay customers would enter transactions on the dashboard or upload
    a list of expected transactions through the dashboard. The system would then check
    fields such as date, dollar amount, account number, names, and similar against
    the company-provided data to ensure transactions were added.
  prefs: []
  type: TYPE_NORMAL
- en: When transactions coming into the system do not match an item, they are flagged
    and rejected for processing. Basically, this is meant to prevent unauthorized
    transactions from being processed by the bank, reducing risk and fraud for both
    the company and the bank. Positive Pay is often offered to commercial customers,
    but in theory, it could be used by any customer.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.4 Service charges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a broad area where customers may be assessed service charges or fees
    for types of transactions or problems with their account. For instance, most people
    are painfully familiar with an overdraft or insufficient funds fee, which can
    happen when a transaction comes in for more than our available balance, and the
    bank assesses a fee. Obviously, if you are processing ACH transactions, you could
    certainly encounter this situation. Other fees may be associated with different
    actions, perhaps originating ACH transactions, processing IAT transactions, creating
    a stop payment, or a monthly maintenance fee, to name just a few.
  prefs: []
  type: TYPE_NORMAL
- en: Given that you have companies, customers, and accounts (depending on how many
    additional features you have implemented), there are ample opportunities to apply
    different types of service charges to customers. Sticking with the ACH theme,
    you may choose to also charge companies for the number of transactions they have
    processed or originated, or you may charge them for returned or reversed items.
    While service charges start to tackle the broader FinTech area, there are plenty
    of opportunities to apply charges to ACH specific areas.
  prefs: []
  type: TYPE_NORMAL
- en: 12.5 Final thoughts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have made it to the end of our journey and would like to thank you for sticking
    with us! The main goal for this book was to pique your interest in software development
    and finance, hoping that you continue exploring other areas or dive deeper into
    a topic that we have already touched upon. In our experience, what separates good
    software developers from great software developers is curiosity and the willingness
    to expand one’s knowledge to continue to grow. Taking on this book and making
    it to the end should show you that you have what it takes to be a great programmer.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, you had an opportunity to work through a FinTech project following
    an agile methodology. We wanted to provide you with a project based on the real
    world and follow the same process that you are likely to see in any company you
    will work for.
  prefs: []
  type: TYPE_NORMAL
- en: From processing an ACH file, to creating APIs, and presenting everything in
    a UI, you worked on a lot of areas and covered a lot of additional topics. We
    hope you enjoyed the journey!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether it is expanding the existing code, swapping out the FastAPI framework,
    or moving away from Python entirely, a plethora of things can be done to continue
    expanding the backend processing of our project. Rewriting functionality from
    one language to another often provides a great learning experience, and the ability
    to use language or framework features not available in the original language can
    be illuminating.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, pieces of code or entire applications need to be rewritten because
    of resource constraints. We have seen applications rewritten into a new language
    because they were legacy software written in a nonstandard language, and the team
    simply did not have the bandwidth or resources to devote to learning it just to
    maintain that piece of software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well-established products often have plenty of infrastructure around them. Such
    infrastructure is often homegrown, especially if we are dealing with legacy software
    that may have existed before commercial tools were available to fill some of the
    niches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing tools that are out there can be helpful, as homegrown tools eventually
    need to be replaced. Often, as team members mature, there is a need to replace
    the existing home-grown tools with a standard product so that new team members
    have a reduced learning curve.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ACH is widely used in the United States, and as we saw, it has international
    capabilities as well. Processing ACH transactions provides some real-world exposure
    to what happens billions of times a year without much fanfare. Creating a simple
    system to begin processing ACH transactions and see just what goes on during the
    process gives us a great base to expand from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
