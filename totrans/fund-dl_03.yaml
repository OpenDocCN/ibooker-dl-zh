- en: Chapter 3\. The Neural Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Intelligent Machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The brain is the most incredible organ in the human body. It dictates the way
    we perceive every sight, sound, smell, taste, and touch. It enables us to store
    memories, experience emotions, and even dream. Without it, we would be primitive
    organisms, incapable of anything other than the simplest of reflexes. The brain
    is, inherently, what makes us intelligent.
  prefs: []
  type: TYPE_NORMAL
- en: The infant brain weighs only a single pound, but somehow it solves problems
    that even our biggest, most powerful supercomputers find impossible. Within a
    matter of months after birth, infants can recognize the faces of their parents,
    discern discrete objects from their backgrounds, and even tell voices apart. Within
    a year, they‚Äôve already developed an intuition for natural physics, can track
    objects even when they become partially or completely blocked, and can associate
    sounds with specific meanings. And by early childhood, they have a sophisticated
    understanding of grammar and thousands of words in their vocabularies.^([1](ch03.xhtml#idm45934167495712))
  prefs: []
  type: TYPE_NORMAL
- en: For decades, we‚Äôve dreamed of building intelligent machines with brains like
    ours‚Äîrobotic assistants to clean our homes, cars that drive themselves, microscopes
    that automatically detect diseases. But building these artificially intelligent
    machines requires us to solve some of the most complex computational problems
    we have ever grappled with; problems that our brains can already solve in a manner
    of microseconds. To tackle these problems, we‚Äôll have to develop a radically different
    way of programming a computer using techniques largely developed over the past
    decade. This is an extremely active field of artificial computer intelligence
    often referred to as *deep learning*.
  prefs: []
  type: TYPE_NORMAL
- en: The Limits of Traditional Computer Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why exactly are certain problems so difficult for computers to solve? Well,
    it turns out that traditional computer programs are designed to be very good at
    two things: (1) performing arithmetic really fast and (2) explicitly following
    a list of instructions. So if you want to do some heavy financial number crunching,
    you‚Äôre in luck. Traditional computer programs can do the trick. But let‚Äôs say
    we want to do something slightly more interesting, like write a program to automatically
    read someone‚Äôs handwriting. [Figure¬†3-1](#handwritten_digit_dataset) will serve
    as a starting point.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Image from MNIST handwritten digit dataset^([2](ch03.xhtml#idm45934169246960))
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although every digit in [Figure¬†3-1](#handwritten_digit_dataset) is written
    in a slightly different way, we can easily recognize every digit in the first
    row as a zero, every digit in the second row as a one, etc. Let‚Äôs try to write
    a computer program to crack this task. What rules could we use to tell one digit
    from another?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we can start simple! For example, we might state that we have a zero if
    our image has only a single, closed loop. All the examples in¬†[Figure¬†3-1](#handwritten_digit_dataset)
    seem to fit this bill, but this isn‚Äôt really a sufficient condition. What if someone
    doesn‚Äôt perfectly close the loop on their zero? And, as in¬†[Figure¬†3-2](#difficult_to_distinguish),
    how do you distinguish a messy zero from a six?
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. A zero that‚Äôs algorithmically difficult to distinguish from a six
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You could potentially establish some sort of cutoff for the distance between
    the starting point of the loop and the ending point, but it‚Äôs not exactly clear
    where we should be drawing the line. But this dilemma is only the beginning of
    our worries. How do we distinguish between threes and fives? Or between fours
    and nines? We can add more and more rules, or *features*,¬†through careful observation
    and months of trial and error, but it‚Äôs quite clear that this isn‚Äôt going to be
    an easy process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many other classes of problems fall into this same category: object recognition,
    speech comprehension, automated translation, etc. We don‚Äôt know what program to
    write because we don‚Äôt know how it‚Äôs done by our brains. ¬†And even if we did know
    how to do it, the program might be horrendously complicated.'
  prefs: []
  type: TYPE_NORMAL
- en: The Mechanics of Machine Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To tackle these classes of problems, we‚Äôll have to use a different kind of approach.
    A lot of the things we learn in school growing up have much in common with traditional
    computer programs. We learn how to multiply numbers, solve equations, and take
    derivatives by internalizing a set of instructions. But the things we learn at
    an extremely early age, the things we find most natural, are learned by example,
    not by formula.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, when we were two years old, our parents didn‚Äôt teach us how to
    recognize a dog by measuring the shape of its nose or the contours of its body.
    We learned to recognize a dog by being shown multiple examples and being corrected
    when we made the wrong guess. When we were born, our brains provided us with a
    model that described how we would be able to see the world. As we grew up, that
    model would take in our sensory inputs and make a guess about what we were experiencing.
    If that guess was confirmed by our parents, our model would be reinforced. If
    our parents said we were wrong, we‚Äôd modify our model to incorporate this new
    information. Over our lifetime, our model becomes more and more accurate as we
    assimilate more and more examples. Obviously all of this happens subconsciously,
    but we can use this to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Deep learning is a subset of a more general field of AI called *machine learning*,
    which is predicated on this idea of learning from example. In machine learning,
    instead of teaching a computer a massive list of rules to solve the problem, we
    give it a *model* with which it can evaluate examples, and a small set of instructions
    to modify the model when it makes a mistake. We expect that, over time, a well-suited
    model would be able to solve the problem extremely accurately.
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs be a little bit more rigorous about what this means so we can formulate
    this idea mathematically. Let‚Äôs define our model to be a function¬† <math alttext="h
    left-parenthesis bold x comma theta right-parenthesis"><mrow><mi>h</mi> <mo>(</mo>
    <mi>ùê±</mi> <mo>,</mo> <mi>Œ∏</mi> <mo>)</mo></mrow></math> . The input **x** is
    an example expressed in vector form. For example, if **x** were a grayscale image,
    the vector‚Äôs components would be pixel intensities at each position, as shown
    in [Figure¬†3-3](#process_of_vectorizing).
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. The process of vectorizing an image for a machine learning algorithm
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The input <math alttext="theta"><mi>Œ∏</mi></math> is a vector of the parameters
    that our model uses. Our machine learning program tries to perfect the values
    of these parameters as it is exposed to more and more examples. We‚Äôll see this
    in action and in more detail in [Chapter¬†4](ch04.xhtml#training_feed_forward).
  prefs: []
  type: TYPE_NORMAL
- en: 'To develop a more intuitive understanding for machine learning models, let‚Äôs
    walk through a quick example. Let‚Äôs say we wanted to determine how to predict
    exam performance based on the number of hours of sleep we get and the number of
    hours we study the previous day. We collect a lot of data, and for each data point
    <math alttext="bold x equals Start 1 By 2 Matrix 1st Row 1st Column x 1 2nd Column
    x 2 EndMatrix Superscript upper T"><mrow><mi>ùê±</mi> <mo>=</mo> <msup><mfenced
    open="[" close="]"><mtable><mtr><mtd><msub><mi>x</mi> <mn>1</mn></msub></mtd>
    <mtd><msub><mi>x</mi> <mn>2</mn></msub></mtd></mtr></mtable></mfenced> <mi>T</mi></msup></mrow></math>
    , we record the number of hours of sleep we got ( <math alttext="x 1"><msub><mi>x</mi>
    <mn>1</mn></msub></math> ), the number of hours we spent studying ( <math alttext="x
    2"><msub><mi>x</mi> <mn>2</mn></msub></math> ), and whether we performed above
    or below the class average. Our goal, then, might be to learn a model¬† <math alttext="h
    left-parenthesis bold x comma theta right-parenthesis"><mrow><mi>h</mi> <mo>(</mo>
    <mi>ùê±</mi> <mo>,</mo> <mi>Œ∏</mi> <mo>)</mo></mrow></math> ¬†with parameter vector
    <math alttext="theta equals Start 1 By 3 Matrix 1st Row 1st Column theta 0 2nd
    Column theta 1 3rd Column theta 2 EndMatrix Superscript upper T"><mrow><mi>Œ∏</mi>
    <mo>=</mo> <msup><mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>Œ∏</mi>
    <mn>0</mn></msub></mtd> <mtd><msub><mi>Œ∏</mi> <mn>1</mn></msub></mtd> <mtd><msub><mi>Œ∏</mi>
    <mn>2</mn></msub></mtd></mtr></mtable></mfenced> <mi>T</mi></msup></mrow></math>
    ¬†such that:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="h left-parenthesis bold x comma theta right-parenthesis equals
    StartLayout Enlarged left-brace 1st Row 1st Column negative 1 2nd Column if bold
    x Superscript upper T Baseline dot StartBinomialOrMatrix theta 1 Choose theta
    2 EndBinomialOrMatrix plus theta 0 less-than 0 2nd Row 1st Column 1 2nd Column
    if bold x Superscript upper T Baseline dot StartBinomialOrMatrix theta 1 Choose
    theta 2 EndBinomialOrMatrix plus theta 0 greater-than-or-equal-to 0 EndLayout"><mrow><mi>h</mi>
    <mrow><mo>(</mo> <mi>ùê±</mi> <mo>,</mo> <mi>Œ∏</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mfenced separators="" open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mo>-</mo>
    <mn>1</mn></mrow></mtd> <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><msup><mi>ùê±</mi>
    <mi>T</mi></msup> <mo>¬∑</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>Œ∏</mi>
    <mn>1</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>Œ∏</mi> <mn>2</mn></msub></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <msub><mi>Œ∏</mi> <mn>0</mn></msub> <mo><</mo> <mn>0</mn></mrow></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mn>1</mn></mtd> <mtd columnalign="left"><mrow><mtext>if</mtext>
    <mrow><msup><mi>ùê±</mi> <mi>T</mi></msup> <mo>¬∑</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>Œ∏</mi>
    <mn>1</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>Œ∏</mi> <mn>2</mn></msub></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <msub><mi>Œ∏</mi> <mn>0</mn></msub> <mo>‚â•</mo> <mn>0</mn></mrow></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: So we guess that the blueprint for our model¬† <math alttext="h left-parenthesis
    bold x comma theta right-parenthesis"><mrow><mi>h</mi> <mo>(</mo> <mi>ùê±</mi> <mo>,</mo>
    <mi>Œ∏</mi> <mo>)</mo></mrow></math> ¬†is as described (geometrically, this particular
    blueprint describes a linear classifier that divides the coordinate plane into
    two halves). Then, we want to learn a parameter vector¬† <math alttext="theta"><mi>Œ∏</mi></math>
    ¬†such that our model makes the right predictions (‚àí1 if we perform below average,
    and 1 otherwise) given an input example **x**. This model is called a linear *perceptron*,
    and it‚Äôs a model that‚Äôs been used since the 1950s.^([3](ch03.xhtml#idm45934169203808))¬†Let‚Äôs
    assume our data is as shown in¬†[Figure¬†3-4](#sample_data_for_our_exam).
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Sample data for our exam predictor algorithm and a potential classifier
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then it turns out that by selecting¬† <math alttext="theta equals Start 1 By
    3 Matrix 1st Row 1st Column negative 24 2nd Column 3 3rd Column 4 EndMatrix Superscript
    upper T"><mrow><mi>Œ∏</mi> <mo>=</mo> <msup><mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>-</mo><mn>24</mn></mrow></mtd><mtd><mn>3</mn></mtd><mtd><mn>4</mn></mtd></mtr></mtable></mfenced>
    <mi>T</mi></msup></mrow></math> , our machine learning model makes the correct
    prediction on every data point:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="h left-parenthesis bold x comma theta right-parenthesis equals
    StartLayout Enlarged left-brace 1st Row 1st Column negative 1 2nd Column if 3
    x 1 plus 4 x 2 minus 24 less-than 0 2nd Row 1st Column 1 2nd Column if 3 x 1 plus
    4 x 2 minus 24 greater-than-or-equal-to 0 EndLayout"><mrow><mi>h</mi> <mrow><mo>(</mo>
    <mi>ùê±</mi> <mo>,</mo> <mi>Œ∏</mi> <mo>)</mo></mrow> <mo>=</mo> <mfenced separators=""
    open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><mn>3</mn> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mn>4</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo>
    <mn>24</mn> <mo><</mo> <mn>0</mn></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mn>1</mn></mtd>
    <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><mn>3</mn> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mn>4</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo>
    <mn>24</mn> <mo>‚â•</mo> <mn>0</mn></mrow></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: An optimal parameter vector¬† <math alttext="theta"><mi>Œ∏</mi></math> ¬†positions
    the classifier so that we make as many correct predictions as possible. In most
    cases, there are many (or even infinitely many)¬†possible choices for¬† <math alttext="theta"><mi>Œ∏</mi></math>
    ¬†that are optimal. Fortunately for us, most of the time these alternatives are
    so close to one another that the difference is negligible. If this is not the
    case, we may want to collect more data to narrow our choice of¬† <math alttext="theta"><mi>Œ∏</mi></math>
    .
  prefs: []
  type: TYPE_NORMAL
- en: While the setup seems reasonable, there are still some pretty significant questions
    that remain. First off, how do we even come up with an optimal value for the parameter
    vector¬† <math alttext="theta"><mi>Œ∏</mi></math> ¬†in the first place? Solving this
    problem requires a technique commonly known as *optimization*. An optimizer aims
    to maximize the performance of a machine learning model by iteratively tweaking
    its parameters until the error is minimized.¬†We‚Äôll begin to tackle this question
    of learning parameter vectors in more detail in [Chapter¬†4](ch04.xhtml#training_feed_forward),
    when we describe the process of *gradient descent*.^([4](ch03.xhtml#idm45934168242992))
    In later chapters, we‚Äôll try to find ways to make this process even more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Second, it‚Äôs quite clear that this particular model (the linear perceptron model)
    is quite limited in the relationships it can learn. For example, the distributions
    of data shown in¬†[Figure¬†3-5](#data_takes_on_more_complex_forms) cannot be described
    well by a linear perceptron.
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0305.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5\. As our data takes on more complex forms, we need more complex models
    to describe them
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: But these situations are only the tip of the iceberg. As we move on to much
    more complex problems, such as object recognition and text analysis, our data
    becomes extremely high dimensional, and the relationships we want to capture become
    highly nonlinear. To accommodate this complexity, recent research in machine learning
    has attempted to build models that resemble the structures utilized by our brains.
    It‚Äôs essentially this body of research, commonly referred to as¬†*deep learning*,
    that has had spectacular success in tackling problems in computer vision and natural
    language processing. These algorithms not only far surpass other kinds of machine
    learning algorithms, but also rival (or even exceed) the accuracies achieved by
    humans.
  prefs: []
  type: TYPE_NORMAL
- en: The Neuron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The foundational unit of the human brain is the neuron. A tiny piece of the
    brain, about the size of grain of rice, contains over 10,000 neurons, each of
    which forms an average of 6,000 connections with other neurons.^([5](ch03.xhtml#idm45934168225968))
    It‚Äôs this massive biological network that enables us to experience the ¬†world
    around us. Our goal in this section is to use this natural structure to build
    machine learning models that solve problems in an analogous way.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, the neuron is optimized to receive information from other neurons,
    process this information in a unique way, and send its result to other cells.
    This process is summarized in¬†[Figure¬†3-6](#function_description_of_biological_neuron_structure).
    The neuron receives its inputs along antennae-like structures called¬†*dendrites*.
    Each of these incoming connections is dynamically strengthened or weakened based
    on how often it is used (this is how we learn new concepts), and it‚Äôs the strength
    of each connection that determines the contribution of the input to the neuron‚Äôs
    output. After being weighted by the strength of their respective connections,
    the inputs are summed together in the¬†*cell body*. This sum is then transformed
    into a new signal that‚Äôs propagated along the cell‚Äôs¬†*axon*¬†and sent off to other
    neurons.
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0306.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-6\. A functional description of a biological neuron‚Äôs structure
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can translate this functional understanding of the neurons in our brain into
    an artificial model that we can represent on our computer. Such a model is described
    in¬†[Figure¬†3-7](#schematic_for_a_neuron), leveraging the approach first pioneered
    in 1943 by Warren S. McCulloch and Walter H. Pitts.^([6](ch03.xhtml#idm45934168212000))
    Just as in biological neurons, our artificial neuron takes in some number of inputs,¬†
    <math alttext="x 1 comma x 2 comma ellipsis comma x Subscript n Baseline"><mrow><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>,</mo> <msub><mi>x</mi> <mn>2</mn></msub> <mo>,</mo> <mo>...</mo>
    <mo>,</mo> <msub><mi>x</mi> <mi>n</mi></msub></mrow></math> , each of which is
    multiplied by a specific weight, <math alttext="w 1 comma w 2 comma ellipsis comma
    w Subscript n Baseline"><mrow><msub><mi>w</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>w</mi>
    <mn>2</mn></msub> <mo>,</mo> <mo>...</mo> <mo>,</mo> <msub><mi>w</mi> <mi>n</mi></msub></mrow></math>
    .¬†These weighted inputs are, as before, summed to produce the¬†*logit*¬†of the neuron,¬†
    <math alttext="z equals sigma-summation Underscript i equals 0 Overscript n Endscripts
    w Subscript i Baseline x Subscript i"><mrow><mi>z</mi> <mo>=</mo> <msubsup><mo>‚àë</mo>
    <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></msubsup> <msub><mi>w</mi>
    <mi>i</mi></msub> <msub><mi>x</mi> <mi>i</mi></msub></mrow></math> . In many cases,
    the logit also includes a¬†*bias*, which is a constant (not shown in the figure).¬†The
    logit is then passed through a function¬† <math alttext="f"><mi>f</mi></math> ¬†to
    produce the output¬† <math alttext="y equals f left-parenthesis z right-parenthesis"><mrow><mi>y</mi>
    <mo>=</mo> <mi>f</mi> <mo>(</mo> <mi>z</mi> <mo>)</mo></mrow></math> . This output
    can be transmitted to other neurons.
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0307.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-7\. Schematic for a neuron in an artificial neural net
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We‚Äôll conclude our mathematical discussion of the artificial neuron by re-expressing
    its functionality in vector form. Let‚Äôs reformulate the inputs as a vector **x**
    = [x[1] x[2] ‚Ä¶ x[n]] and the weights of the neuron as **w** = [w[1] w[2] ‚Ä¶ w[n]].
    Then we can re-express the output of the neuron as <math alttext="y equals f left-parenthesis
    bold x dot bold w plus b right-parenthesis"><mrow><mi>y</mi> <mo>=</mo> <mi>f</mi>
    <mfenced separators="" open="(" close=")"><mi>ùê±</mi> <mo>¬∑</mo> <mi>ùê∞</mi> <mo>+</mo>
    <mi>b</mi></mfenced></mrow></math> , where <math alttext="b"><mi>b</mi></math>
    is the bias term. We can compute the output by performing the dot product of the
    input and weight vectors, adding in the bias term to produce the logit, and then
    applying the transformation function. While this seems like a trivial reformulation,
    thinking about neurons as a series of vector manipulations will be crucial to
    how we implement them in software later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing Linear Perceptrons as Neurons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [‚ÄúThe Mechanics of Machine Learning‚Äù](#mech_machine_learn), we talked about
    using machine learning models to capture the relationship between success on exams
    and time spent studying and sleeping. To tackle this problem, we constructed a
    linear perceptron classifier that divided the Cartesian coordinate plane into
    two halves:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="h left-parenthesis bold x comma theta right-parenthesis equals
    StartLayout Enlarged left-brace 1st Row 1st Column negative 1 2nd Column if 3
    x 1 plus 4 x 2 minus 24 less-than 0 2nd Row 1st Column 1 2nd Column if 3 x 1 plus
    4 x 2 minus 24 greater-than-or-equal-to 0 EndLayout"><mrow><mi>h</mi> <mrow><mo>(</mo>
    <mi>ùê±</mi> <mo>,</mo> <mi>Œ∏</mi> <mo>)</mo></mrow> <mo>=</mo> <mfenced separators=""
    open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><mn>3</mn> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mn>4</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo>
    <mn>24</mn> <mo><</mo> <mn>0</mn></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mn>1</mn></mtd>
    <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><mn>3</mn> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mn>4</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo>
    <mn>24</mn> <mo>‚â•</mo> <mn>0</mn></mrow></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in¬†[Figure¬†3-4](#sample_data_for_our_exam), this is an optimal choice
    for¬† <math alttext="theta"><mi>Œ∏</mi></math> ¬†because it correctly classifies
    every sample in our dataset. Here, we show that our model¬†*h*¬†is easily using
    a neuron. Consider the neuron depicted in¬†[Figure¬†3-8](#expressing_our_exam_performance).
    The neuron has two inputs, a bias, and uses the function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis z right-parenthesis equals StartLayout Enlarged
    left-brace 1st Row 1st Column negative 1 2nd Column if z less-than 0 2nd Row 1st
    Column 1 2nd Column if z greater-than-or-equal-to 0 EndLayout"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>=</mo> <mfenced separators=""
    open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><mi>z</mi> <mo><</mo> <mn>0</mn></mrow></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mn>1</mn></mtd> <mtd columnalign="left"><mrow><mtext>if</mtext>
    <mrow><mi>z</mi> <mo>‚â•</mo> <mn>0</mn></mrow></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: It‚Äôs easy to show that our linear perceptron and the neuronal model are perfectly
    equivalent. And in general, it‚Äôs quite simple to show that singular neurons are
    strictly more expressive than linear perceptrons. Every linear perceptron can
    be expressed as a single neuron, but single neurons can also express models that
    cannot be expressed by any linear perceptron.
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0308.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-8\. Expressing our exam performance perceptron as a neuron
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Feed-Forward Neural Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although single neurons are more powerful than linear perceptrons, they‚Äôre not
    nearly expressive enough to solve complicated learning problems. There‚Äôs a reason
    our brain is made of more than one neuron. For example, it is impossible for a
    single neuron to differentiate handwritten digits. So to tackle much more complicated
    tasks, we‚Äôll have to take our machine learning model even further.
  prefs: []
  type: TYPE_NORMAL
- en: The neurons in the human brain are organized in layers. In fact, the human cerebral
    cortex (the structure responsible for most of human intelligence) is made up of
    six layers.^([7](ch03.xhtml#idm45934167717376)) Information flows from one layer
    to another until sensory input is converted into conceptual understanding. For
    example, the bottommost layer of the visual cortex receives raw visual data from
    the eyes. This information is processed by each layer and passed on to the next
    until, in the sixth layer, we conclude whether we are looking at a cat, or a soda
    can, or an airplane.
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing from these concepts, we can construct an *artificial neural network*.
    A neural network comes about when we start hooking up neurons to each other, the
    input data, and to the output nodes, which correspond to the network‚Äôs answer
    to a learning problem.¬†[Figure¬†3-9](#simple_example_of_a_feed_forward_neural_network)
    demonstrates a simple example of an artificial neural network, similar to the
    architecture described in McCulloch and Pitt‚Äôs work in 1943.
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0309.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-9\. A feed-forward neural network with three layers (input, one hidden,
    and output) and three neurons per layer
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The bottom layer of the network pulls in the input data. The top layer of neurons
    (output nodes) computes our final answer. The middle layer(s) of neurons are called
    the *hidden layers*, and we let¬† <math alttext="w Subscript i comma j Superscript
    left-parenthesis k right-parenthesis"><msubsup><mi>w</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow>
    <mrow><mo>(</mo><mi>k</mi><mo>)</mo></mrow></msubsup></math> ¬†be the weight of
    the connection between the¬† <math alttext="i Superscript t h"><msup><mi>i</mi>
    <mrow><mi>t</mi><mi>h</mi></mrow></msup></math> ¬†neuron in the¬† <math alttext="k
    Superscript t h"><msup><mi>k</mi> <mrow><mi>t</mi><mi>h</mi></mrow></msup></math>
    ¬†layer with the¬† **<math alttext="j Superscript t h"><msup><mi>j</mi> <mrow><mi>t</mi><mi>h</mi></mrow></msup></math>**neuron
    in the**¬† <math alttext="k plus 1 Superscript s t"><mrow><mi>k</mi> <mo>+</mo>
    <msup><mn>1</mn> <mrow><mi>s</mi><mi>t</mi></mrow></msup></mrow></math> ¬†**layer.
    These weights constitute our parameter vector,¬† <math alttext="theta"><mi>Œ∏</mi></math>
    , and just as before, our ability to solve problems with neural networks depends
    on finding the optimal values to plug into¬† <math alttext="theta"><mi>Œ∏</mi></math>
    .
  prefs: []
  type: TYPE_NORMAL
- en: We note that in this example, connections traverse only from a lower layer to
    a higher layer. There are no connections between neurons in the same layer, and
    there are no connections that transmit data from a higher layer to a lower layer.
    These neural networks are called *feed-forward* networks, and we start by discussing
    these networks because they are the simplest to analyze. We present this analysis
    (specifically, the process of selecting the optimal values for the weights) in
    [Chapter¬†4](ch04.xhtml#training_feed_forward). More complicated connectivities
    will be addressed in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We‚Äôll discuss the major types of layers that are utilized in feed-forward neural
    networks, but before we proceed, here‚Äôs a couple of important notes to keep in
    mind:'
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned, the layers of neurons that lie sandwiched between the first
    layer of neurons (input layer) and the last layer of neurons (output layer) are
    called the hidden layers. This is where most of the magic is happening when the
    neural net tries to solve problems. Whereas (as in the handwritten digit example)
    we would previously have to spend a lot of time identifying useful features, the
    hidden layers automate this process for us. Oftentimes, taking a look at the activities
    of hidden layers can tell you a lot about the features the network has automatically
    learned to extract from the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although in [Figure¬†3-9](#simple_example_of_a_feed_forward_neural_network) every
    layer has the same number of neurons, this is neither necessary nor recommended.
    More often than not, hidden layers have fewer neurons than the input layer to
    force the network to learn compressed representations of the original input. For
    example, while our eyes obtain raw pixel values from our surroundings, our brain
    thinks in terms of edges and contours. This is because the hidden layers of biological
    neurons in our brain, force us to come up with better representations for everything
    we perceive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is not required that every neuron has its output connected to the inputs
    of all neurons in the next layer. In fact, selecting which neurons to connect
    to which other neurons in the next layer is an art that comes from experience.
    We‚Äôll discuss this issue in more depth as we work through various examples of
    neural networks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The inputs and outputs are *vectorized* representations. For example, you might
    imagine a neural network where the inputs are the individual pixel RGB values
    in an image represented as a vector (refer to [Figure¬†3-3](#process_of_vectorizing)).
    The last layer might have two neurons that correspond to the answer to our problem:¬†
    <math alttext="left-bracket 1 comma 0 right-bracket"><mrow><mo>[</mo> <mn>1</mn>
    <mo>,</mo> <mn>0</mn> <mo>]</mo></mrow></math> ¬†if the image contains a dog,¬†
    <math alttext="left-bracket 0 comma 1 right-bracket"><mrow><mo>[</mo> <mn>0</mn>
    <mo>,</mo> <mn>1</mn> <mo>]</mo></mrow></math> ¬†if the image contains a cat,¬†
    <math alttext="left-bracket 1 comma 1 right-bracket"><mrow><mo>[</mo> <mn>1</mn>
    <mo>,</mo> <mn>1</mn> <mo>]</mo></mrow></math> ¬†if it contains both, and¬† <math
    alttext="left-bracket 0 comma 0 right-bracket"><mrow><mo>[</mo> <mn>0</mn> <mo>,</mo>
    <mn>0</mn> <mo>]</mo></mrow></math> ¬†if it contains neither.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We‚Äôll also observe that, similarly to our reformulation for the neuron, we can
    also mathematically express a neural network as a series of vector and matrix
    operations. Let‚Äôs consider the input to the <math alttext="i Superscript t h"><msup><mi>i</mi>
    <mrow><mi>t</mi><mi>h</mi></mrow></msup></math> layer of the network to be a vector
    **x** = [x[1] x[2] ‚Ä¶ x[n]]. We‚Äôd like to find the vector **y** = [y[1] y[2] ‚Ä¶
    y[m]] produced by propagating the input through the neurons. We can express this
    as a simple matrix multiply if we construct a weight matrix <math alttext="bold
    upper W"><mi>ùêñ</mi></math> of size <math alttext="n times m"><mrow><mi>n</mi>
    <mo>√ó</mo> <mi>m</mi></mrow></math> and a bias vector of size <math alttext="m"><mi>m</mi></math>
    . In this matrix, each column corresponds to a neuron, where the <math alttext="j
    Superscript t h"><msup><mi>j</mi> <mrow><mi>t</mi><mi>h</mi></mrow></msup></math>
    element of the column corresponds to the weight of the connection pulling in the
    <math alttext="j Superscript t h"><msup><mi>j</mi> <mrow><mi>t</mi><mi>h</mi></mrow></msup></math>
    element of the input. In other words, **y** = ∆í(**W**^(**T**)**x** + **b**), where
    the transformation function is applied to the vector element-wise. This reformulation
    will become all the more critical as we begin to implement these networks in software.
  prefs: []
  type: TYPE_NORMAL
- en: Linear Neurons and Their Limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most neuron types are defined by the function¬† <math alttext="f"><mi>f</mi></math>
    ¬†they apply to their logit <math alttext="z"><mi>z</mi></math> . Let‚Äôs first consider
    layers of neurons that use a linear function in the form of <math alttext="f left-parenthesis
    z right-parenthesis equals a z plus b"><mrow><mi>f</mi> <mo>(</mo> <mi>z</mi>
    <mo>)</mo> <mo>=</mo> <mi>a</mi> <mi>z</mi> <mo>+</mo> <mi>b</mi></mrow></math>
    . For example, a neuron that attempts to estimate a cost of a meal in a fast-food
    restaurant would use a linear neuron where <math alttext="a equals 1"><mrow><mi>a</mi>
    <mo>=</mo> <mn>1</mn></mrow></math> and <math alttext="b equals 0"><mrow><mi>b</mi>
    <mo>=</mo> <mn>0</mn></mrow></math> . Using <math alttext="f left-parenthesis
    z right-parenthesis equals z"><mrow><mi>f</mi> <mo>(</mo> <mi>z</mi> <mo>)</mo>
    <mo>=</mo> <mi>z</mi></mrow></math> and weights equal to the price of each item,
    the linear neuron in [Figure¬†3-10](#example_of_a_linear_neuron) would take in
    some ordered triple of servings of burgers, fries, and sodas, and output the price
    of the combination.
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0310.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-10\. An example of a linear neuron
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Linear neurons are easy to compute with, but they run into serious limitations.
    In fact, it can be shown that any feed-forward neural network consisting of only
    linear neurons can be expressed as a network with no hidden layers. This is problematic
    because, as we discussed, hidden layers are what enable us to learn important
    features from the input data. In other words, to learn complex relationships,
    we need to use neurons that employ some sort of nonlinearity.
  prefs: []
  type: TYPE_NORMAL
- en: Sigmoid, Tanh, and ReLU Neurons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Three major types of neurons are used in practice that introduce nonlinearities
    in their computations. The first of these is the *sigmoid neuron*, which uses
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis z right-parenthesis equals StartFraction 1
    Over 1 plus e Superscript negative z Baseline EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi>
    <mrow><mo>-</mo><mi>z</mi></mrow></msup></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Intuitively, this means that when the logit is very small, the output of a logistic
    neuron is close to 0\. When the logit is very large, the output of the logistic
    neuron is close to 1\. In-between these two extremes, the neuron assumes an S-shape,
    as shown in¬†[Figure¬†3-11](#otuput_of_a_sigmoid_neuron).
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0311.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-11\. The output of a sigmoid neuron as z varies
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*Tanh neurons*¬†use a similar kind of S-shaped nonlinearity, but instead of
    ranging from 0 to 1, the output of tanh neurons ranges from ‚àí1 to 1\. As you would
    expect, they use¬† <math alttext="f left-parenthesis z right-parenthesis equals
    hyperbolic tangent left-parenthesis z right-parenthesis"><mrow><mi>f</mi> <mo>(</mo>
    <mi>z</mi> <mo>)</mo> <mo>=</mo> <mo form="prefix">tanh</mo> <mo>(</mo> <mi>z</mi>
    <mo>)</mo></mrow></math> . The resulting relationship between the output¬† <math
    alttext="y"><mi>y</mi></math> ¬†and the logit¬† <math alttext="z"><mi>z</mi></math>
    ¬†is depicted in¬†[Figure¬†3-12](#output_of_a_tanh_neuron). When S-shaped nonlinearities
    are used, the tanh neuron is often preferred over the sigmoid neuron because it
    is zero-centered.'
  prefs: []
  type: TYPE_NORMAL
- en: A different kind of nonlinearity is used by the *Rectified Linear Unit (ReLU)
    neuron*. It uses the function¬† <math alttext="f left-parenthesis z right-parenthesis
    equals max left-parenthesis 0 comma z right-parenthesis"><mrow><mi>f</mi> <mo>(</mo>
    <mi>z</mi> <mo>)</mo> <mo>=</mo> <mo movablelimits="true" form="prefix">max</mo>
    <mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow></math> , resulting
    in a characteristic hockey-stick-shaped response, as shown in¬†[Figure¬†3-13](#output_of_a_relu_neuron).
  prefs: []
  type: TYPE_NORMAL
- en: The ReLU has recently become the neuron of choice for many tasks (especially
    in computer vision) for a number of reasons, despite some drawbacks.^([8](ch03.xhtml#idm45934165761792))
    We‚Äôll discuss these reasons in [Chapter¬†7](ch07.xhtml#convolutional_neural_networks),
    as well as strategies to combat the potential pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0312.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-12\. The output of a tanh neuron as z varies
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0313.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-13\. The output of a ReLU neuron as z varies
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Softmax Output Layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Oftentimes, we want our output vector to be a probability distribution over
    a set of mutually exclusive labels. For example, let‚Äôs say we want to build a
    neural network to recognize handwritten digits from the MNIST dataset. Each label
    (0 through 9) is mutually exclusive, but it‚Äôs unlikely that we will be able to
    recognize digits with 100% confidence. Using a probability distribution gives
    us a better idea of how confident we are in our predictions. As a result, the
    desired output vector is of the following form, where <math alttext="sigma-summation
    Underscript i equals 0 Overscript 9 Endscripts p Subscript i Baseline equals 1"><mrow><msubsup><mo>‚àë</mo>
    <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mn>9</mn></msubsup> <msub><mi>p</mi>
    <mi>i</mi></msub> <mo>=</mo> <mn>1</mn></mrow></math> :'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 1 By 6 Matrix 1st Row 1st Column p 0 2nd Column p 1 3rd
    Column p 2 4th Column p 3 5th Column  ellipsis 6th Column p 9 EndMatrix"><mrow><mo>[</mo>
    <mtable><mtr><mtd><msub><mi>p</mi> <mn>0</mn></msub></mtd> <mtd><msub><mi>p</mi>
    <mn>1</mn></msub></mtd> <mtd><msub><mi>p</mi> <mn>2</mn></msub></mtd> <mtd><msub><mi>p</mi>
    <mn>3</mn></msub></mtd> <mtd><mo>...</mo></mtd> <mtd><msub><mi>p</mi> <mn>9</mn></msub></mtd></mtr></mtable>
    <mo>]</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This is achieved by using a special output layer called a *softmax layer*.
    Unlike in other kinds of layers, the output of a neuron in a softmax layer depends
    on the outputs of all the other neurons in its layer. This is because we require
    the sum of all the outputs to be equal to 1\. Letting <math alttext="z Subscript
    i"><msub><mi>z</mi> <mi>i</mi></msub></math> be the logit of the¬† <math alttext="i
    Superscript t h"><msup><mi>i</mi> <mrow><mi>t</mi><mi>h</mi></mrow></msup></math>
    softmax neuron, we can achieve this normalization by setting its output to:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="y Subscript i Baseline equals StartFraction e Superscript z Super
    Subscript i Superscript Baseline Over sigma-summation Underscript j Endscripts
    e Superscript z Super Subscript j Superscript Baseline EndFraction"><mrow><msub><mi>y</mi>
    <mi>i</mi></msub> <mo>=</mo> <mfrac><msup><mi>e</mi> <msub><mi>z</mi> <mi>i</mi></msub></msup>
    <mrow><msub><mo>‚àë</mo> <mi>j</mi></msub> <msup><mi>e</mi> <msub><mi>z</mi> <mi>j</mi></msub></msup></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: A strong prediction would have a single entry in the vector close to 1, while
    the remaining entries would be close to 0\. A weak prediction would have multiple
    possible labels that are more or less equally likely.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we‚Äôve built a basic intuition for machine learning and neural
    networks. We‚Äôve talked about the basic structure of a neuron, how feed-forward
    neural networks work, and the importance of nonlinearity in tackling complex learning
    problems. In the next chapter, we will begin to build the mathematical background
    necessary to train a neural network to solve problems. Specifically, we will talk
    about finding optimal parameter vectors, best practices while training neural
    networks, and major challenges. In later chapters, we will take these foundational
    ideas to build more specialized neural architectures.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.xhtml#idm45934167495712-marker)) Kuhn, Deanna, et al. *Handbook of
    Child Psychology. Vol. 2, Cognition, Perception, and Language*. Wiley, 1998.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch03.xhtml#idm45934169246960-marker)) Y. LeCun, L. Bottou, Y. Bengio,
    and P. Haffner. ‚ÄúGradient-Based Learning Applied to Document Recognition.‚Äù *Proceedings
    of the IEEE*, 86(11):2278-2324, November 1998.
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch03.xhtml#idm45934169203808-marker)) Rosenblatt, Frank. ‚ÄúThe perceptron:
    A Probabilistic Model for Information Storage and Organization in the Brain.‚Äù
    *Psychological Review* 65.6 (1958): 386.'
  prefs: []
  type: TYPE_NORMAL
- en: '^([4](ch03.xhtml#idm45934168242992-marker)) Bubeck, S√©bastien. ‚ÄúConvex Optimization:
    Algorithms and Complexity.‚Äù *Foundations and Trends¬Æ in Machine Learning*. 8.3-4
    (2015): 231-357.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch03.xhtml#idm45934168225968-marker)) Restak, Richard M. and David Grubin.
    *The Secret Life of the Brain*. Joseph Henry Press, 2001.
  prefs: []
  type: TYPE_NORMAL
- en: '^([6](ch03.xhtml#idm45934168212000-marker)) McCulloch, Warren S., and Walter
    Pitts. ‚ÄúA Logical Calculus of the Ideas Immanent in Nervous Activity.‚Äù *The Bulletin
    of Mathematical Biophysics*. 5.4 (1943): 115-133.'
  prefs: []
  type: TYPE_NORMAL
- en: '^([7](ch03.xhtml#idm45934167717376-marker)) Mountcastle, Vernon B. ‚ÄúModality
    and Topographic Properties of Single Neurons of Cat‚Äôs Somatic Sensory Cortex.‚Äù
    *Journal of Neurophysiology* 20.4 (1957): 408-434.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch03.xhtml#idm45934165761792-marker)) Nair, Vinod, and Geoffrey E. Hinton.
    ‚ÄúRectified Linear Units Improve Restricted Boltzmann Machines.‚Äù *Proceedings of
    the 27th International Conference on Machine Learning* (ICML-10), 2010.
  prefs: []
  type: TYPE_NORMAL
