- en: Chapter 3\. The Neural Network
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Intelligent Machines
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The brain is the most incredible organ in the human body. It dictates the way
    we perceive every sight, sound, smell, taste, and touch. It enables us to store
    memories, experience emotions, and even dream. Without it, we would be primitive
    organisms, incapable of anything other than the simplest of reflexes. The brain
    is, inherently, what makes us intelligent.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The infant brain weighs only a single pound, but somehow it solves problems
    that even our biggest, most powerful supercomputers find impossible. Within a
    matter of months after birth, infants can recognize the faces of their parents,
    discern discrete objects from their backgrounds, and even tell voices apart. Within
    a year, they’ve already developed an intuition for natural physics, can track
    objects even when they become partially or completely blocked, and can associate
    sounds with specific meanings. And by early childhood, they have a sophisticated
    understanding of grammar and thousands of words in their vocabularies.^([1](ch03.xhtml#idm45934167495712))
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: For decades, we’ve dreamed of building intelligent machines with brains like
    ours—robotic assistants to clean our homes, cars that drive themselves, microscopes
    that automatically detect diseases. But building these artificially intelligent
    machines requires us to solve some of the most complex computational problems
    we have ever grappled with; problems that our brains can already solve in a manner
    of microseconds. To tackle these problems, we’ll have to develop a radically different
    way of programming a computer using techniques largely developed over the past
    decade. This is an extremely active field of artificial computer intelligence
    often referred to as *deep learning*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The Limits of Traditional Computer Programs
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why exactly are certain problems so difficult for computers to solve? Well,
    it turns out that traditional computer programs are designed to be very good at
    two things: (1) performing arithmetic really fast and (2) explicitly following
    a list of instructions. So if you want to do some heavy financial number crunching,
    you’re in luck. Traditional computer programs can do the trick. But let’s say
    we want to do something slightly more interesting, like write a program to automatically
    read someone’s handwriting. [Figure 3-1](#handwritten_digit_dataset) will serve
    as a starting point.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0301.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Image from MNIST handwritten digit dataset^([2](ch03.xhtml#idm45934169246960))
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although every digit in [Figure 3-1](#handwritten_digit_dataset) is written
    in a slightly different way, we can easily recognize every digit in the first
    row as a zero, every digit in the second row as a one, etc. Let’s try to write
    a computer program to crack this task. What rules could we use to tell one digit
    from another?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Well, we can start simple! For example, we might state that we have a zero if
    our image has only a single, closed loop. All the examples in [Figure 3-1](#handwritten_digit_dataset)
    seem to fit this bill, but this isn’t really a sufficient condition. What if someone
    doesn’t perfectly close the loop on their zero? And, as in [Figure 3-2](#difficult_to_distinguish),
    how do you distinguish a messy zero from a six?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0302.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. A zero that’s algorithmically difficult to distinguish from a six
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You could potentially establish some sort of cutoff for the distance between
    the starting point of the loop and the ending point, but it’s not exactly clear
    where we should be drawing the line. But this dilemma is only the beginning of
    our worries. How do we distinguish between threes and fives? Or between fours
    and nines? We can add more and more rules, or *features*, through careful observation
    and months of trial and error, but it’s quite clear that this isn’t going to be
    an easy process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Many other classes of problems fall into this same category: object recognition,
    speech comprehension, automated translation, etc. We don’t know what program to
    write because we don’t know how it’s done by our brains.  And even if we did know
    how to do it, the program might be horrendously complicated.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他类别的问题也属于这一类：物体识别，语音理解，自动翻译等。我们不知道要写什么程序，因为我们不知道我们的大脑是如何做的。即使我们知道如何做，程序可能会非常复杂。
- en: The Mechanics of Machine Learning
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习的机制
- en: To tackle these classes of problems, we’ll have to use a different kind of approach.
    A lot of the things we learn in school growing up have much in common with traditional
    computer programs. We learn how to multiply numbers, solve equations, and take
    derivatives by internalizing a set of instructions. But the things we learn at
    an extremely early age, the things we find most natural, are learned by example,
    not by formula.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题类别，我们将不得不采用一种不同的方法。我们在学校学到的很多东西与传统的计算机程序有很多共同之处。我们学会如何相乘，解方程，通过内化一组指令来求导数。但我们在极早期学到的东西，我们认为最自然的东西，是通过示例学习的，而不是通过公式。
- en: For instance, when we were two years old, our parents didn’t teach us how to
    recognize a dog by measuring the shape of its nose or the contours of its body.
    We learned to recognize a dog by being shown multiple examples and being corrected
    when we made the wrong guess. When we were born, our brains provided us with a
    model that described how we would be able to see the world. As we grew up, that
    model would take in our sensory inputs and make a guess about what we were experiencing.
    If that guess was confirmed by our parents, our model would be reinforced. If
    our parents said we were wrong, we’d modify our model to incorporate this new
    information. Over our lifetime, our model becomes more and more accurate as we
    assimilate more and more examples. Obviously all of this happens subconsciously,
    but we can use this to our advantage.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们两岁时，我们的父母没有教我们通过测量狗的鼻子形状或身体轮廓来认识狗。我们通过展示多个示例并在猜错时得到纠正来学会认识狗。当我们出生时，我们的大脑为我们提供了一个描述我们如何看世界的模型。随着我们长大，该模型会接收我们的感官输入并猜测我们正在经历什么。如果父母确认了这个猜测，我们的模型就会得到强化。如果父母说我们错了，我们会修改我们的模型以纳入这个新信息。随着时间的推移，随着我们吸收更多的示例，我们的模型变得越来越准确。显然，所有这些都是在潜意识中发生的，但我们可以利用这一点。
- en: Deep learning is a subset of a more general field of AI called *machine learning*,
    which is predicated on this idea of learning from example. In machine learning,
    instead of teaching a computer a massive list of rules to solve the problem, we
    give it a *model* with which it can evaluate examples, and a small set of instructions
    to modify the model when it makes a mistake. We expect that, over time, a well-suited
    model would be able to solve the problem extremely accurately.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习是人工智能更一般领域机器学习的一个子集，其基于从示例中学习的这一想法。在机器学习中，我们不是教计算机解决问题的大量规则，而是给它一个模型，通过这个模型它可以评估示例，并给出一小组指令来在犯错误时修改模型。我们期望随着时间的推移，一个合适的模型将能够极其准确地解决问题。
- en: Let’s be a little bit more rigorous about what this means so we can formulate
    this idea mathematically. Let’s define our model to be a function  <math alttext="h
    left-parenthesis bold x comma theta right-parenthesis"><mrow><mi>h</mi> <mo>(</mo>
    <mi>𝐱</mi> <mo>,</mo> <mi>θ</mi> <mo>)</mo></mrow></math> . The input **x** is
    an example expressed in vector form. For example, if **x** were a grayscale image,
    the vector’s components would be pixel intensities at each position, as shown
    in [Figure 3-3](#process_of_vectorizing).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对这意思更加严谨，这样我们就可以用数学的方式来表达这个想法。让我们定义我们的模型为一个函数h(𝐱,θ)。输入x是以向量形式表示的示例。例如，如果x是一个灰度图像，向量的分量将是每个位置的像素强度，如[图3-3](#process_of_vectorizing)所示。
- en: '![ ](Images/fdl2_0303.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![ ](Images/fdl2_0303.png)'
- en: Figure 3-3\. The process of vectorizing an image for a machine learning algorithm
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-3。将图像向量化为机器学习算法的过程
- en: The input <math alttext="theta"><mi>θ</mi></math> is a vector of the parameters
    that our model uses. Our machine learning program tries to perfect the values
    of these parameters as it is exposed to more and more examples. We’ll see this
    in action and in more detail in [Chapter 4](ch04.xhtml#training_feed_forward).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 输入θ是我们模型使用的参数的向量。随着暴露于越来越多的示例，我们的机器学习程序试图完善这些参数的值。我们将在[第4章](ch04.xhtml#training_feed_forward)中看到这一点，并更详细地了解。
- en: 'To develop a more intuitive understanding for machine learning models, let’s
    walk through a quick example. Let’s say we wanted to determine how to predict
    exam performance based on the number of hours of sleep we get and the number of
    hours we study the previous day. We collect a lot of data, and for each data point
    <math alttext="bold x equals Start 1 By 2 Matrix 1st Row 1st Column x 1 2nd Column
    x 2 EndMatrix Superscript upper T"><mrow><mi>𝐱</mi> <mo>=</mo> <msup><mfenced
    open="[" close="]"><mtable><mtr><mtd><msub><mi>x</mi> <mn>1</mn></msub></mtd>
    <mtd><msub><mi>x</mi> <mn>2</mn></msub></mtd></mtr></mtable></mfenced> <mi>T</mi></msup></mrow></math>
    , we record the number of hours of sleep we got ( <math alttext="x 1"><msub><mi>x</mi>
    <mn>1</mn></msub></math> ), the number of hours we spent studying ( <math alttext="x
    2"><msub><mi>x</mi> <mn>2</mn></msub></math> ), and whether we performed above
    or below the class average. Our goal, then, might be to learn a model  <math alttext="h
    left-parenthesis bold x comma theta right-parenthesis"><mrow><mi>h</mi> <mo>(</mo>
    <mi>𝐱</mi> <mo>,</mo> <mi>θ</mi> <mo>)</mo></mrow></math>  with parameter vector
    <math alttext="theta equals Start 1 By 3 Matrix 1st Row 1st Column theta 0 2nd
    Column theta 1 3rd Column theta 2 EndMatrix Superscript upper T"><mrow><mi>θ</mi>
    <mo>=</mo> <msup><mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>θ</mi>
    <mn>0</mn></msub></mtd> <mtd><msub><mi>θ</mi> <mn>1</mn></msub></mtd> <mtd><msub><mi>θ</mi>
    <mn>2</mn></msub></mtd></mtr></mtable></mfenced> <mi>T</mi></msup></mrow></math>
     such that:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更直观地理解机器学习模型，让我们通过一个快速示例来走一遍。假设我们想确定如何根据我们睡眠时间和前一天学习时间来预测考试表现。我们收集了大量数据，对于每个数据点
    <math alttext="bold x equals Start 1 By 2 Matrix 1st Row 1st Column x 1 2nd Column
    x 2 EndMatrix Superscript upper T"><mrow><mi>𝐱</mi> <mo>=</mo> <msup><mfenced
    open="[" close="]"><mtable><mtr><mtd><msub><mi>x</mi> <mn>1</mn></msub></mtd>
    <mtd><msub><mi>x</mi> <mn>2</mn></msub></mtd></mtr></mtable></mfenced> <mi>T</mi></msup></mrow></math>，我们记录了我们的睡眠时间（
    <math alttext="x 1"><msub><mi>x</mi> <mn>1</mn></msub></math> ），我们学习的时间（ <math
    alttext="x 2"><msub><mi>x</mi> <mn>2</mn></msub></math> ），以及我们是否表现高于或低于班级平均水平。因此，我们的目标可能是学习一个带有参数向量
    <math alttext="theta equals Start 1 By 3 Matrix 1st Row 1st Column theta 0 2nd
    Column theta 1 3rd Column theta 2 EndMatrix Superscript upper T"><mrow><mi>θ</mi>
    <mo>=</mo> <msup><mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>θ</mi>
    <mn>0</mn></msub></mtd> <mtd><msub><mi>θ</mi> <mn>1</mn></msub></mtd> <mtd><msub><mi>θ</mi>
    <mn>2</mn></msub></mtd></mtr></mtable></mfenced> <mi>T</mi></msup></mrow></math>
    的模型 <math alttext="h left-parenthesis bold x comma theta right-parenthesis"><mrow><mi>h</mi>
    <mo>(</mo> <mi>𝐱</mi> <mo>,</mo> <mi>θ</mi> <mo>)</mo></mrow></math>，使得：
- en: <math alttext="h left-parenthesis bold x comma theta right-parenthesis equals
    StartLayout Enlarged left-brace 1st Row 1st Column negative 1 2nd Column if bold
    x Superscript upper T Baseline dot StartBinomialOrMatrix theta 1 Choose theta
    2 EndBinomialOrMatrix plus theta 0 less-than 0 2nd Row 1st Column 1 2nd Column
    if bold x Superscript upper T Baseline dot StartBinomialOrMatrix theta 1 Choose
    theta 2 EndBinomialOrMatrix plus theta 0 greater-than-or-equal-to 0 EndLayout"><mrow><mi>h</mi>
    <mrow><mo>(</mo> <mi>𝐱</mi> <mo>,</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mfenced separators="" open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mo>-</mo>
    <mn>1</mn></mrow></mtd> <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><msup><mi>𝐱</mi>
    <mi>T</mi></msup> <mo>·</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>θ</mi>
    <mn>1</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>θ</mi> <mn>2</mn></msub></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo><</mo> <mn>0</mn></mrow></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mn>1</mn></mtd> <mtd columnalign="left"><mrow><mtext>if</mtext>
    <mrow><msup><mi>𝐱</mi> <mi>T</mi></msup> <mo>·</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>θ</mi>
    <mn>1</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>θ</mi> <mn>2</mn></msub></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo>≥</mo> <mn>0</mn></mrow></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="h left-parenthesis bold x comma theta right-parenthesis equals
    StartLayout Enlarged left-brace 1st Row 1st Column negative 1 2nd Column if bold
    x Superscript upper T Baseline dot StartBinomialOrMatrix theta 1 Choose theta
    2 EndBinomialOrMatrix plus theta 0 less-than 0 2nd Row 1st Column 1 2nd Column
    if bold x Superscript upper T Baseline dot StartBinomialOrMatrix theta 1 Choose
    theta 2 EndBinomialOrMatrix plus theta 0 greater-than-or-equal-to 0 EndLayout"><mrow><mi>h</mi>
    <mrow><mo>(</mo> <mi>𝐱</mi> <mo>,</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mfenced separators="" open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mo>-</mo>
    <mn>1</mn></mrow></mtd> <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><msup><mi>𝐱</mi>
    <mi>T</mi></msup> <mo>·</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>θ</mi>
    <mn>1</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>θ</mi> <mn>2</mn></msub></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo><</mo> <mn>0</mn></mrow></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mn>1</mn></mtd> <mtd columnalign="left"><mrow><mtext>if</mtext>
    <mrow><msup><mi>𝐱</mi> <mi>T</mi></msup> <mo>·</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>θ</mi>
    <mn>1</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>θ</mi> <mn>2</mn></msub></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo>≥</mo> <mn>0</mn></mrow></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: So we guess that the blueprint for our model  <math alttext="h left-parenthesis
    bold x comma theta right-parenthesis"><mrow><mi>h</mi> <mo>(</mo> <mi>𝐱</mi> <mo>,</mo>
    <mi>θ</mi> <mo>)</mo></mrow></math>  is as described (geometrically, this particular
    blueprint describes a linear classifier that divides the coordinate plane into
    two halves). Then, we want to learn a parameter vector  <math alttext="theta"><mi>θ</mi></math>
     such that our model makes the right predictions (−1 if we perform below average,
    and 1 otherwise) given an input example **x**. This model is called a linear *perceptron*,
    and it’s a model that’s been used since the 1950s.^([3](ch03.xhtml#idm45934169203808)) Let’s
    assume our data is as shown in [Figure 3-4](#sample_data_for_our_exam).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们猜想我们模型的蓝图 <math alttext="h left-parenthesis bold x comma theta right-parenthesis"><mrow><mi>h</mi>
    <mo>(</mo> <mi>𝐱</mi> <mo>,</mo> <mi>θ</mi> <mo>)</mo></mrow></math> 如上所述（从几何上讲，这个特定的蓝图描述了一个将坐标平面分成两半的线性分类器）。然后，我们想学习一个参数向量
    <math alttext="theta"><mi>θ</mi></math>，使得我们的模型在给定输入示例 **x** 时做出正确的预测（如果我们表现低于平均水平，则为-1，否则为1）。这个模型被称为线性*感知器*，自上世纪50年代以来一直被使用。让我们假设我们的数据如图3-4所示。
- en: '![ ](Images/fdl2_0304.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![ ](Images/fdl2_0304.png)'
- en: Figure 3-4\. Sample data for our exam predictor algorithm and a potential classifier
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-4。我们考试预测算法和潜在分类器的样本数据
- en: 'Then it turns out that by selecting  <math alttext="theta equals Start 1 By
    3 Matrix 1st Row 1st Column negative 24 2nd Column 3 3rd Column 4 EndMatrix Superscript
    upper T"><mrow><mi>θ</mi> <mo>=</mo> <msup><mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>-</mo><mn>24</mn></mrow></mtd><mtd><mn>3</mn></mtd><mtd><mn>4</mn></mtd></mtr></mtable></mfenced>
    <mi>T</mi></msup></mrow></math> , our machine learning model makes the correct
    prediction on every data point:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后发现，通过选择 <math alttext="theta equals Start 1 By 3 Matrix 1st Row 1st Column
    negative 24 2nd Column 3 3rd Column 4 EndMatrix Superscript upper T"><mrow><mi>θ</mi>
    <mo>=</mo> <msup><mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>-</mo><mn>24</mn></mrow></mtd><mtd><mn>3</mn></mtd><mtd><mn>4</mn></mtd></mtr></mtable></mfenced>
    <mi>T</mi></msup></mrow></math>，我们的机器学习模型对每个数据点都做出了正确的预测：
- en: <math alttext="h left-parenthesis bold x comma theta right-parenthesis equals
    StartLayout Enlarged left-brace 1st Row 1st Column negative 1 2nd Column if 3
    x 1 plus 4 x 2 minus 24 less-than 0 2nd Row 1st Column 1 2nd Column if 3 x 1 plus
    4 x 2 minus 24 greater-than-or-equal-to 0 EndLayout"><mrow><mi>h</mi> <mrow><mo>(</mo>
    <mi>𝐱</mi> <mo>,</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mfenced separators=""
    open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><mn>3</mn> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mn>4</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo>
    <mn>24</mn> <mo><</mo> <mn>0</mn></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mn>1</mn></mtd>
    <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><mn>3</mn> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mn>4</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo>
    <mn>24</mn> <mo>≥</mo> <mn>0</mn></mrow></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="h left-parenthesis bold x comma theta right-parenthesis equals
    StartLayout Enlarged left-brace 1st Row 1st Column negative 1 2nd Column if 3
    x 1 plus 4 x 2 minus 24 less-than 0 2nd Row 1st Column 1 2nd Column if 3 x 1 plus
    4 x 2 minus 24 greater-than-or-equal-to 0 EndLayout"><mrow><mi>h</mi> <mrow><mo>(</mo>
    <mi>𝐱</mi> <mo>,</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mfenced separators=""
    open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><mn>3</mn> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mn>4</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo>
    <mn>24</mn> <mo><</mo> <mn>0</mn></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mn>1</mn></mtd>
    <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><mn>3</mn> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mn>4</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo>
    <mn>24</mn> <mo>≥</mo> <mn>0</mn></mrow></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: An optimal parameter vector  <math alttext="theta"><mi>θ</mi></math>  positions
    the classifier so that we make as many correct predictions as possible. In most
    cases, there are many (or even infinitely many) possible choices for  <math alttext="theta"><mi>θ</mi></math>
     that are optimal. Fortunately for us, most of the time these alternatives are
    so close to one another that the difference is negligible. If this is not the
    case, we may want to collect more data to narrow our choice of  <math alttext="theta"><mi>θ</mi></math>
    .
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最佳参数向量 <math alttext="theta"><mi>θ</mi></math> 使分类器定位，以便我们尽可能多地做出正确预测。在大多数情况下，有许多（甚至无限多）可能的最佳选择
    <math alttext="theta"><mi>θ</mi></math>。幸运的是，大多数情况下，这些替代方案之间的差异是微不足道的。如果不是这种情况，我们可能需要收集更多数据来缩小我们对
    <math alttext="theta"><mi>θ</mi></math> 的选择。
- en: While the setup seems reasonable, there are still some pretty significant questions
    that remain. First off, how do we even come up with an optimal value for the parameter
    vector  <math alttext="theta"><mi>θ</mi></math>  in the first place? Solving this
    problem requires a technique commonly known as *optimization*. An optimizer aims
    to maximize the performance of a machine learning model by iteratively tweaking
    its parameters until the error is minimized. We’ll begin to tackle this question
    of learning parameter vectors in more detail in [Chapter 4](ch04.xhtml#training_feed_forward),
    when we describe the process of *gradient descent*.^([4](ch03.xhtml#idm45934168242992))
    In later chapters, we’ll try to find ways to make this process even more efficient.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设置看起来合理，但仍然存在一些相当重要的问题。首先，我们如何找到参数向量<math alttext="theta"><mi>θ</mi></math>的最优值？解决这个问题需要一种常用的技术，称为*优化*。优化器旨在通过迭代调整其参数，直到误差最小化，从而最大化机器学习模型的性能。我们将在[第4章](ch04.xhtml#training_feed_forward)中更详细地讨论学习参数向量的问题，当我们描述*梯度下降*过程时。在后面的章节中，我们将尝试找到使这个过程更加高效的方法。
- en: Second, it’s quite clear that this particular model (the linear perceptron model)
    is quite limited in the relationships it can learn. For example, the distributions
    of data shown in [Figure 3-5](#data_takes_on_more_complex_forms) cannot be described
    well by a linear perceptron.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，很明显，这个特定模型（线性感知器模型）在学习关系方面是相当有限的。例如，[图3-5](#data_takes_on_more_complex_forms)中显示的数据分布无法很好地被线性感知器描述。
- en: '![ ](Images/fdl2_0305.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![ ](Images/fdl2_0305.png)'
- en: Figure 3-5\. As our data takes on more complex forms, we need more complex models
    to describe them
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-5。随着我们的数据呈现更复杂的形式，我们需要更复杂的模型来描述它们
- en: But these situations are only the tip of the iceberg. As we move on to much
    more complex problems, such as object recognition and text analysis, our data
    becomes extremely high dimensional, and the relationships we want to capture become
    highly nonlinear. To accommodate this complexity, recent research in machine learning
    has attempted to build models that resemble the structures utilized by our brains.
    It’s essentially this body of research, commonly referred to as *deep learning*,
    that has had spectacular success in tackling problems in computer vision and natural
    language processing. These algorithms not only far surpass other kinds of machine
    learning algorithms, but also rival (or even exceed) the accuracies achieved by
    humans.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些情况只是冰山一角。随着我们转向更复杂的问题，如物体识别和文本分析，我们的数据变得极高维，我们想要捕捉的关系变得高度非线性。为了适应这种复杂性，最近机器学习领域的研究尝试构建类似于我们大脑所利用的结构的模型。这基本上是一系列研究，通常被称为*深度学习*，在解决计算机视觉和自然语言处理问题方面取得了惊人的成功。这些算法不仅远远超过其他类型的机器学习算法，而且与人类达到的准确度相媲美（甚至超过）。
- en: The Neuron
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经元
- en: The foundational unit of the human brain is the neuron. A tiny piece of the
    brain, about the size of grain of rice, contains over 10,000 neurons, each of
    which forms an average of 6,000 connections with other neurons.^([5](ch03.xhtml#idm45934168225968))
    It’s this massive biological network that enables us to experience the  world
    around us. Our goal in this section is to use this natural structure to build
    machine learning models that solve problems in an analogous way.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 人类大脑的基本单位是神经元。大脑中一个微小的部分，大约是一粒米的大小，包含超过10,000个神经元，每个神经元平均与其他神经元形成6,000个连接。正是这个庞大的生物网络使我们能够体验周围的世界。我们在本节的目标是利用这种自然结构来构建解决类似问题的机器学习模型。
- en: At its core, the neuron is optimized to receive information from other neurons,
    process this information in a unique way, and send its result to other cells.
    This process is summarized in [Figure 3-6](#function_description_of_biological_neuron_structure).
    The neuron receives its inputs along antennae-like structures called *dendrites*.
    Each of these incoming connections is dynamically strengthened or weakened based
    on how often it is used (this is how we learn new concepts), and it’s the strength
    of each connection that determines the contribution of the input to the neuron’s
    output. After being weighted by the strength of their respective connections,
    the inputs are summed together in the *cell body*. This sum is then transformed
    into a new signal that’s propagated along the cell’s *axon* and sent off to other
    neurons.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，神经元被优化为接收来自其他神经元的信息，以独特的方式处理这些信息，并将其结果发送给其他细胞。这个过程在[图3-6](#function_description_of_biological_neuron_structure)中进行了总结。神经元沿着类似触角的结构称为*树突*接收其输入。每个传入连接根据使用频率动态加强或减弱（这就是我们学习新概念的方式），而每个连接的强度决定了输入对神经元输出的贡献。在根据各自连接的强度加权后，输入在*细胞体*中相加。然后，这个总和被转化为一个新信号，沿着细胞的*轴突*传播，并发送给其他神经元。
- en: '![ ](Images/fdl2_0306.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![ ](Images/fdl2_0306.png)'
- en: Figure 3-6\. A functional description of a biological neuron’s structure
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-6。生物神经元结构的功能描述
- en: We can translate this functional understanding of the neurons in our brain into
    an artificial model that we can represent on our computer. Such a model is described
    in [Figure 3-7](#schematic_for_a_neuron), leveraging the approach first pioneered
    in 1943 by Warren S. McCulloch and Walter H. Pitts.^([6](ch03.xhtml#idm45934168212000))
    Just as in biological neurons, our artificial neuron takes in some number of inputs, 
    <math alttext="x 1 comma x 2 comma ellipsis comma x Subscript n Baseline"><mrow><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>,</mo> <msub><mi>x</mi> <mn>2</mn></msub> <mo>,</mo> <mo>...</mo>
    <mo>,</mo> <msub><mi>x</mi> <mi>n</mi></msub></mrow></math> , each of which is
    multiplied by a specific weight, <math alttext="w 1 comma w 2 comma ellipsis comma
    w Subscript n Baseline"><mrow><msub><mi>w</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>w</mi>
    <mn>2</mn></msub> <mo>,</mo> <mo>...</mo> <mo>,</mo> <msub><mi>w</mi> <mi>n</mi></msub></mrow></math>
    . These weighted inputs are, as before, summed to produce the *logit* of the neuron, 
    <math alttext="z equals sigma-summation Underscript i equals 0 Overscript n Endscripts
    w Subscript i Baseline x Subscript i"><mrow><mi>z</mi> <mo>=</mo> <msubsup><mo>∑</mo>
    <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></msubsup> <msub><mi>w</mi>
    <mi>i</mi></msub> <msub><mi>x</mi> <mi>i</mi></msub></mrow></math> . In many cases,
    the logit also includes a *bias*, which is a constant (not shown in the figure). The
    logit is then passed through a function  <math alttext="f"><mi>f</mi></math>  to
    produce the output  <math alttext="y equals f left-parenthesis z right-parenthesis"><mrow><mi>y</mi>
    <mo>=</mo> <mi>f</mi> <mo>(</mo> <mi>z</mi> <mo>)</mo></mrow></math> . This output
    can be transmitted to other neurons.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0307.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: Figure 3-7\. Schematic for a neuron in an artificial neural net
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’ll conclude our mathematical discussion of the artificial neuron by re-expressing
    its functionality in vector form. Let’s reformulate the inputs as a vector **x**
    = [x[1] x[2] … x[n]] and the weights of the neuron as **w** = [w[1] w[2] … w[n]].
    Then we can re-express the output of the neuron as <math alttext="y equals f left-parenthesis
    bold x dot bold w plus b right-parenthesis"><mrow><mi>y</mi> <mo>=</mo> <mi>f</mi>
    <mfenced separators="" open="(" close=")"><mi>𝐱</mi> <mo>·</mo> <mi>𝐰</mi> <mo>+</mo>
    <mi>b</mi></mfenced></mrow></math> , where <math alttext="b"><mi>b</mi></math>
    is the bias term. We can compute the output by performing the dot product of the
    input and weight vectors, adding in the bias term to produce the logit, and then
    applying the transformation function. While this seems like a trivial reformulation,
    thinking about neurons as a series of vector manipulations will be crucial to
    how we implement them in software later in this book.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Expressing Linear Perceptrons as Neurons
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [“The Mechanics of Machine Learning”](#mech_machine_learn), we talked about
    using machine learning models to capture the relationship between success on exams
    and time spent studying and sleeping. To tackle this problem, we constructed a
    linear perceptron classifier that divided the Cartesian coordinate plane into
    two halves:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="h left-parenthesis bold x comma theta right-parenthesis equals
    StartLayout Enlarged left-brace 1st Row 1st Column negative 1 2nd Column if 3
    x 1 plus 4 x 2 minus 24 less-than 0 2nd Row 1st Column 1 2nd Column if 3 x 1 plus
    4 x 2 minus 24 greater-than-or-equal-to 0 EndLayout"><mrow><mi>h</mi> <mrow><mo>(</mo>
    <mi>𝐱</mi> <mo>,</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mfenced separators=""
    open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><mn>3</mn> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mn>4</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo>
    <mn>24</mn> <mo><</mo> <mn>0</mn></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mn>1</mn></mtd>
    <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><mn>3</mn> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mn>4</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo>
    <mn>24</mn> <mo>≥</mo> <mn>0</mn></mrow></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="h left-parenthesis bold x comma theta right-parenthesis equals
    StartLayout Enlarged left-brace 1st Row 1st Column negative 1 2nd Column if 3
    x 1 plus 4 x 2 minus 24 less-than 0 2nd Row 1st Column 1 2nd Column if 3 x 1 plus
    4 x 2 minus 24 greater-than-or-equal-to 0 EndLayout"><mrow><mi>h</mi> <mrow><mo>(</mo>
    <mi>𝐱</mi> <mo>,</mo> <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mfenced separators=""
    open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><mn>3</mn> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mn>4</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo>
    <mn>24</mn> <mo><</mo> <mn>0</mn></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mn>1</mn></mtd>
    <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><mn>3</mn> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mn>4</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo>
    <mn>24</mn> <mo>≥</mo> <mn>0</mn></mrow></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'As shown in [Figure 3-4](#sample_data_for_our_exam), this is an optimal choice
    for  <math alttext="theta"><mi>θ</mi></math>  because it correctly classifies
    every sample in our dataset. Here, we show that our model *h* is easily using
    a neuron. Consider the neuron depicted in [Figure 3-8](#expressing_our_exam_performance).
    The neuron has two inputs, a bias, and uses the function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis z right-parenthesis equals StartLayout Enlarged
    left-brace 1st Row 1st Column negative 1 2nd Column if z less-than 0 2nd Row 1st
    Column 1 2nd Column if z greater-than-or-equal-to 0 EndLayout"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>=</mo> <mfenced separators=""
    open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><mi>z</mi> <mo><</mo> <mn>0</mn></mrow></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mn>1</mn></mtd> <mtd columnalign="left"><mrow><mtext>if</mtext>
    <mrow><mi>z</mi> <mo>≥</mo> <mn>0</mn></mrow></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis z right-parenthesis equals StartLayout Enlarged
    left-brace 1st Row 1st Column negative 1 2nd Column if z less-than 0 2nd Row 1st
    Column 1 2nd Column if z greater-than-or-equal-to 0 EndLayout"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>z</mi> <mo>)</mo></mrow> <mo>=</mo> <mfenced separators=""
    open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd columnalign="left"><mrow><mtext>if</mtext> <mrow><mi>z</mi> <mo><</mo> <mn>0</mn></mrow></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mn>1</mn></mtd> <mtd columnalign="left"><mrow><mtext>if</mtext>
    <mrow><mi>z</mi> <mo>≥</mo> <mn>0</mn></mrow></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: It’s easy to show that our linear perceptron and the neuronal model are perfectly
    equivalent. And in general, it’s quite simple to show that singular neurons are
    strictly more expressive than linear perceptrons. Every linear perceptron can
    be expressed as a single neuron, but single neurons can also express models that
    cannot be expressed by any linear perceptron.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0308.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: Figure 3-8\. Expressing our exam performance perceptron as a neuron
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Feed-Forward Neural Networks
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although single neurons are more powerful than linear perceptrons, they’re not
    nearly expressive enough to solve complicated learning problems. There’s a reason
    our brain is made of more than one neuron. For example, it is impossible for a
    single neuron to differentiate handwritten digits. So to tackle much more complicated
    tasks, we’ll have to take our machine learning model even further.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The neurons in the human brain are organized in layers. In fact, the human cerebral
    cortex (the structure responsible for most of human intelligence) is made up of
    six layers.^([7](ch03.xhtml#idm45934167717376)) Information flows from one layer
    to another until sensory input is converted into conceptual understanding. For
    example, the bottommost layer of the visual cortex receives raw visual data from
    the eyes. This information is processed by each layer and passed on to the next
    until, in the sixth layer, we conclude whether we are looking at a cat, or a soda
    can, or an airplane.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing from these concepts, we can construct an *artificial neural network*.
    A neural network comes about when we start hooking up neurons to each other, the
    input data, and to the output nodes, which correspond to the network’s answer
    to a learning problem. [Figure 3-9](#simple_example_of_a_feed_forward_neural_network)
    demonstrates a simple example of an artificial neural network, similar to the
    architecture described in McCulloch and Pitt’s work in 1943.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](Images/fdl2_0309.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: Figure 3-9\. A feed-forward neural network with three layers (input, one hidden,
    and output) and three neurons per layer
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The bottom layer of the network pulls in the input data. The top layer of neurons
    (output nodes) computes our final answer. The middle layer(s) of neurons are called
    the *hidden layers*, and we let  <math alttext="w Subscript i comma j Superscript
    left-parenthesis k right-parenthesis"><msubsup><mi>w</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow>
    <mrow><mo>(</mo><mi>k</mi><mo>)</mo></mrow></msubsup></math>  be the weight of
    the connection between the  <math alttext="i Superscript t h"><msup><mi>i</mi>
    <mrow><mi>t</mi><mi>h</mi></mrow></msup></math>  neuron in the  <math alttext="k
    Superscript t h"><msup><mi>k</mi> <mrow><mi>t</mi><mi>h</mi></mrow></msup></math>
     layer with the  **<math alttext="j Superscript t h"><msup><mi>j</mi> <mrow><mi>t</mi><mi>h</mi></mrow></msup></math>**neuron
    in the**  <math alttext="k plus 1 Superscript s t"><mrow><mi>k</mi> <mo>+</mo>
    <msup><mn>1</mn> <mrow><mi>s</mi><mi>t</mi></mrow></msup></mrow></math>  **layer.
    These weights constitute our parameter vector,  <math alttext="theta"><mi>θ</mi></math>
    , and just as before, our ability to solve problems with neural networks depends
    on finding the optimal values to plug into  <math alttext="theta"><mi>θ</mi></math>
    .
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: We note that in this example, connections traverse only from a lower layer to
    a higher layer. There are no connections between neurons in the same layer, and
    there are no connections that transmit data from a higher layer to a lower layer.
    These neural networks are called *feed-forward* networks, and we start by discussing
    these networks because they are the simplest to analyze. We present this analysis
    (specifically, the process of selecting the optimal values for the weights) in
    [Chapter 4](ch04.xhtml#training_feed_forward). More complicated connectivities
    will be addressed in later chapters.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll discuss the major types of layers that are utilized in feed-forward neural
    networks, but before we proceed, here’s a couple of important notes to keep in
    mind:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned, the layers of neurons that lie sandwiched between the first
    layer of neurons (input layer) and the last layer of neurons (output layer) are
    called the hidden layers. This is where most of the magic is happening when the
    neural net tries to solve problems. Whereas (as in the handwritten digit example)
    we would previously have to spend a lot of time identifying useful features, the
    hidden layers automate this process for us. Oftentimes, taking a look at the activities
    of hidden layers can tell you a lot about the features the network has automatically
    learned to extract from the data.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们提到的，位于第一层神经元（输入层）和最后一层神经元（输出层）之间的神经元层被称为隐藏层。这是神经网络尝试解决问题时发生大部分魔法的地方。与以前需要花费大量时间识别有用特征（如手写数字示例）不同，隐藏层为我们自动化了这个过程。通常情况下，查看隐藏层的活动可以告诉您很多关于网络自动学习从数据中提取的特征。
- en: Although in [Figure 3-9](#simple_example_of_a_feed_forward_neural_network) every
    layer has the same number of neurons, this is neither necessary nor recommended.
    More often than not, hidden layers have fewer neurons than the input layer to
    force the network to learn compressed representations of the original input. For
    example, while our eyes obtain raw pixel values from our surroundings, our brain
    thinks in terms of edges and contours. This is because the hidden layers of biological
    neurons in our brain, force us to come up with better representations for everything
    we perceive.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管在[图3-9](#simple_example_of_a_feed_forward_neural_network)中每一层都有相同数量的神经元，但这既不是必要的也不推荐。通常情况下，隐藏层的神经元数量比输入层少，以强制网络学习原始输入的压缩表示。例如，虽然我们的眼睛从周围获取原始像素值，但我们的大脑却以边缘和轮廓的形式思考。这是因为我们大脑中的隐藏层生物神经元迫使我们为我们所感知的一切提出更好的表示。
- en: It is not required that every neuron has its output connected to the inputs
    of all neurons in the next layer. In fact, selecting which neurons to connect
    to which other neurons in the next layer is an art that comes from experience.
    We’ll discuss this issue in more depth as we work through various examples of
    neural networks.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并不要求每个神经元的输出都连接到下一层所有神经元的输入。事实上，选择连接到下一层哪些神经元的哪些其他神经元是一门来自经验的艺术。随着我们逐步讨论各种神经网络示例，我们将更深入地讨论这个问题。
- en: The inputs and outputs are *vectorized* representations. For example, you might
    imagine a neural network where the inputs are the individual pixel RGB values
    in an image represented as a vector (refer to [Figure 3-3](#process_of_vectorizing)).
    The last layer might have two neurons that correspond to the answer to our problem: 
    <math alttext="left-bracket 1 comma 0 right-bracket"><mrow><mo>[</mo> <mn>1</mn>
    <mo>,</mo> <mn>0</mn> <mo>]</mo></mrow></math>  if the image contains a dog, 
    <math alttext="left-bracket 0 comma 1 right-bracket"><mrow><mo>[</mo> <mn>0</mn>
    <mo>,</mo> <mn>1</mn> <mo>]</mo></mrow></math>  if the image contains a cat, 
    <math alttext="left-bracket 1 comma 1 right-bracket"><mrow><mo>[</mo> <mn>1</mn>
    <mo>,</mo> <mn>1</mn> <mo>]</mo></mrow></math>  if it contains both, and  <math
    alttext="left-bracket 0 comma 0 right-bracket"><mrow><mo>[</mo> <mn>0</mn> <mo>,</mo>
    <mn>0</mn> <mo>]</mo></mrow></math>  if it contains neither.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入和输出是*向量化*表示。例如，您可以想象一个神经网络，其中输入是图像中表示为向量的单个像素RGB值（参见[图3-3](#process_of_vectorizing)）。最后一层可能有两个神经元，对应于我们问题的答案：<math
    alttext="left-bracket 1 comma 0 right-bracket"><mrow><mo>[</mo> <mn>1</mn> <mo>,</mo>
    <mn>0</mn> <mo>]</mo></mrow></math> 如果图像包含狗，<math alttext="left-bracket 0 comma
    1 right-bracket"><mrow><mo>[</mo> <mn>0</mn> <mo>,</mo> <mn>1</mn> <mo>]</mo></mrow></math>
    如果图像包含猫，<math alttext="left-bracket 1 comma 1 right-bracket"><mrow><mo>[</mo>
    <mn>1</mn> <mo>,</mo> <mn>1</mn> <mo>]</mo></mrow></math> 如果两者都包含，<math alttext="left-bracket
    0 comma 0 right-bracket"><mrow><mo>[</mo> <mn>0</mn> <mo>,</mo> <mn>0</mn> <mo>]</mo></mrow></math>
    如果两者都不包含。
- en: We’ll also observe that, similarly to our reformulation for the neuron, we can
    also mathematically express a neural network as a series of vector and matrix
    operations. Let’s consider the input to the <math alttext="i Superscript t h"><msup><mi>i</mi>
    <mrow><mi>t</mi><mi>h</mi></mrow></msup></math> layer of the network to be a vector
    **x** = [x[1] x[2] … x[n]]. We’d like to find the vector **y** = [y[1] y[2] …
    y[m]] produced by propagating the input through the neurons. We can express this
    as a simple matrix multiply if we construct a weight matrix <math alttext="bold
    upper W"><mi>𝐖</mi></math> of size <math alttext="n times m"><mrow><mi>n</mi>
    <mo>×</mo> <mi>m</mi></mrow></math> and a bias vector of size <math alttext="m"><mi>m</mi></math>
    . In this matrix, each column corresponds to a neuron, where the <math alttext="j
    Superscript t h"><msup><mi>j</mi> <mrow><mi>t</mi><mi>h</mi></mrow></msup></math>
    element of the column corresponds to the weight of the connection pulling in the
    <math alttext="j Superscript t h"><msup><mi>j</mi> <mrow><mi>t</mi><mi>h</mi></mrow></msup></math>
    element of the input. In other words, **y** = ƒ(**W**^(**T**)**x** + **b**), where
    the transformation function is applied to the vector element-wise. This reformulation
    will become all the more critical as we begin to implement these networks in software.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将观察到，类似于我们对神经元的重新表述，我们也可以将神经网络数学表达为一系列向量和矩阵运算。让我们将网络的第<math alttext="i Superscript
    t h"><msup><mi>i</mi> <mrow><mi>t</mi><mi>h</mi></mrow></msup></math>层的输入视为向量**x**
    = [x[1] x[2] … x[n]]。我们希望通过神经元传播输入来找到向量**y** = [y[1] y[2] … y[m]]。如果我们构建一个大小为<math
    alttext="n times m"><mrow><mi>n</mi> <mo>×</mo> <mi>m</mi></mrow></math>的权重矩阵<math
    alttext="bold upper W"><mi>𝐖</mi></math>和大小为<math alttext="m"><mi>m</mi></math>的偏置向量，我们可以将这个过程表达为简单的矩阵乘法。在这个矩阵中，每一列对应一个神经元，其中列的第<math
    alttext="j Superscript t h"><msup><mi>j</mi> <mrow><mi>t</mi><mi>h</mi></mrow></msup></math>元素对应于连接拉入输入的第<math
    alttext="j Superscript t h"><msup><mi>j</mi> <mrow><mi>t</mi><mi>h</mi></mrow></msup></math>元素的权重。换句话说，**y**
    = ƒ(**W**^(**T**)**x** + **b**)，其中变换函数逐元素应用于向量。随着我们开始在软件中实现这些网络，这种重新表述将变得更加关键。
- en: Linear Neurons and Their Limitations
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性神经元及其局限性
- en: Most neuron types are defined by the function  <math alttext="f"><mi>f</mi></math>
     they apply to their logit <math alttext="z"><mi>z</mi></math> . Let’s first consider
    layers of neurons that use a linear function in the form of <math alttext="f left-parenthesis
    z right-parenthesis equals a z plus b"><mrow><mi>f</mi> <mo>(</mo> <mi>z</mi>
    <mo>)</mo> <mo>=</mo> <mi>a</mi> <mi>z</mi> <mo>+</mo> <mi>b</mi></mrow></math>
    . For example, a neuron that attempts to estimate a cost of a meal in a fast-food
    restaurant would use a linear neuron where <math alttext="a equals 1"><mrow><mi>a</mi>
    <mo>=</mo> <mn>1</mn></mrow></math> and <math alttext="b equals 0"><mrow><mi>b</mi>
    <mo>=</mo> <mn>0</mn></mrow></math> . Using <math alttext="f left-parenthesis
    z right-parenthesis equals z"><mrow><mi>f</mi> <mo>(</mo> <mi>z</mi> <mo>)</mo>
    <mo>=</mo> <mi>z</mi></mrow></math> and weights equal to the price of each item,
    the linear neuron in [Figure 3-10](#example_of_a_linear_neuron) would take in
    some ordered triple of servings of burgers, fries, and sodas, and output the price
    of the combination.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数神经元类型由它们应用于logit <math alttext="z"><mi>z</mi></math> 的函数 <math alttext="f"><mi>f</mi></math>
    定义。让我们首先考虑使用线性函数的神经元层，形式为 <math alttext="f left-parenthesis z right-parenthesis
    equals a z plus b"><mrow><mi>f</mi> <mo>(</mo> <mi>z</mi> <mo>)</mo> <mo>=</mo>
    <mi>a</mi> <mi>z</mi> <mo>+</mo> <mi>b</mi></mrow></math>。例如，试图估算快餐店餐点成本的神经元将使用线性神经元，其中
    <math alttext="a equals 1"><mrow><mi>a</mi> <mo>=</mo> <mn>1</mn></mrow></math>
    和 <math alttext="b equals 0"><mrow><mi>b</mi> <mo>=</mo> <mn>0</mn></mrow></math>。使用
    <math alttext="f left-parenthesis z right-parenthesis equals z"><mrow><mi>f</mi>
    <mo>(</mo> <mi>z</mi> <mo>)</mo> <mo>=</mo> <mi>z</mi></mrow></math> 和权重等于每个项目的价格，[图3-10](#example_of_a_linear_neuron)中的线性神经元将接收一些有序的三元组，包括汉堡包、薯条和苏打水的份数，并输出组合的价格。
- en: '![ ](Images/fdl2_0310.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![ ](Images/fdl2_0310.png)'
- en: Figure 3-10\. An example of a linear neuron
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-10. 线性神经元的示例
- en: Linear neurons are easy to compute with, but they run into serious limitations.
    In fact, it can be shown that any feed-forward neural network consisting of only
    linear neurons can be expressed as a network with no hidden layers. This is problematic
    because, as we discussed, hidden layers are what enable us to learn important
    features from the input data. In other words, to learn complex relationships,
    we need to use neurons that employ some sort of nonlinearity.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 线性神经元易于计算，但存在严重限制。事实上，可以证明仅由线性神经元组成的前馈神经网络可以表示为没有隐藏层的网络。这是有问题的，因为正如我们讨论的那样，隐藏层使我们能够从输入数据中学习重要特征。换句话说，为了学习复杂关系，我们需要使用采用某种非线性的神经元。
- en: Sigmoid, Tanh, and ReLU Neurons
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sigmoid，Tanh和ReLU神经元
- en: 'Three major types of neurons are used in practice that introduce nonlinearities
    in their computations. The first of these is the *sigmoid neuron*, which uses
    the function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实践中使用三种主要类型的神经元，在计算中引入非线性。其中之一是*sigmoid神经元*，它使用函数：
- en: <math alttext="f left-parenthesis z right-parenthesis equals StartFraction 1
    Over 1 plus e Superscript negative z Baseline EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi>
    <mrow><mo>-</mo><mi>z</mi></mrow></msup></mrow></mfrac></mrow></math>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis z right-parenthesis equals StartFraction 1
    Over 1 plus e Superscript negative z Baseline EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi>
    <mrow><mo>-</mo><mi>z</mi></mrow></msup></mrow></mfrac></mrow></math>
- en: Intuitively, this means that when the logit is very small, the output of a logistic
    neuron is close to 0\. When the logit is very large, the output of the logistic
    neuron is close to 1\. In-between these two extremes, the neuron assumes an S-shape,
    as shown in [Figure 3-11](#otuput_of_a_sigmoid_neuron).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地说，当logit非常小时，逻辑神经元的输出接近0。当logit非常大时，逻辑神经元的输出接近1。在这两个极端之间，神经元呈S形状，如[图3-11](#otuput_of_a_sigmoid_neuron)所示。
- en: '![ ](Images/fdl2_0311.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![ ](Images/fdl2_0311.png)'
- en: Figure 3-11\. The output of a sigmoid neuron as z varies
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-11. 随着z变化的sigmoid神经元的输出
- en: '*Tanh neurons* use a similar kind of S-shaped nonlinearity, but instead of
    ranging from 0 to 1, the output of tanh neurons ranges from −1 to 1\. As you would
    expect, they use  <math alttext="f left-parenthesis z right-parenthesis equals
    hyperbolic tangent left-parenthesis z right-parenthesis"><mrow><mi>f</mi> <mo>(</mo>
    <mi>z</mi> <mo>)</mo> <mo>=</mo> <mo form="prefix">tanh</mo> <mo>(</mo> <mi>z</mi>
    <mo>)</mo></mrow></math> . The resulting relationship between the output  <math
    alttext="y"><mi>y</mi></math>  and the logit  <math alttext="z"><mi>z</mi></math>
     is depicted in [Figure 3-12](#output_of_a_tanh_neuron). When S-shaped nonlinearities
    are used, the tanh neuron is often preferred over the sigmoid neuron because it
    is zero-centered.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*Tanh神经元*使用类似的S形非线性，但输出范围从-1到1，而不是从0到1。正如您所期望的那样，它们使用 <math alttext="f left-parenthesis
    z right-parenthesis equals hyperbolic tangent left-parenthesis z right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>z</mi> <mo>)</mo> <mo>=</mo> <mo form="prefix">tanh</mo> <mo>(</mo>
    <mi>z</mi> <mo>)</mo></mrow></math>。输出 <math alttext="y"><mi>y</mi></math> 与logit
    <math alttext="z"><mi>z</mi></math> 之间的关系如[图3-12](#output_of_a_tanh_neuron)所示。当使用S形非线性时，通常优先选择tanh神经元而不是sigmoid神经元，因为它是以零为中心的。'
- en: A different kind of nonlinearity is used by the *Rectified Linear Unit (ReLU)
    neuron*. It uses the function  <math alttext="f left-parenthesis z right-parenthesis
    equals max left-parenthesis 0 comma z right-parenthesis"><mrow><mi>f</mi> <mo>(</mo>
    <mi>z</mi> <mo>)</mo> <mo>=</mo> <mo movablelimits="true" form="prefix">max</mo>
    <mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow></math> , resulting
    in a characteristic hockey-stick-shaped response, as shown in [Figure 3-13](#output_of_a_relu_neuron).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rectified Linear Unit (ReLU)神经元*使用不同类型的非线性。它使用函数 <math alttext="f left-parenthesis
    z right-parenthesis equals max left-parenthesis 0 comma z right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>z</mi> <mo>)</mo> <mo>=</mo> <mo movablelimits="true" form="prefix">max</mo>
    <mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow></math>，导致具有特征曲棍球形状响应，如[图3-13](#output_of_a_relu_neuron)所示。'
- en: The ReLU has recently become the neuron of choice for many tasks (especially
    in computer vision) for a number of reasons, despite some drawbacks.^([8](ch03.xhtml#idm45934165761792))
    We’ll discuss these reasons in [Chapter 7](ch07.xhtml#convolutional_neural_networks),
    as well as strategies to combat the potential pitfalls.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，ReLU已成为许多任务（尤其是在计算机视觉中）的首选神经元，尽管存在一些缺点。我们将在[第7章](ch07.xhtml#convolutional_neural_networks)中讨论这些原因，以及应对潜在问题的策略。
- en: '![ ](Images/fdl2_0312.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![ ](Images/fdl2_0312.png)'
- en: Figure 3-12\. The output of a tanh neuron as z varies
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-12. 随着z变化的tanh神经元的输出
- en: '![ ](Images/fdl2_0313.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![ ](Images/fdl2_0313.png)'
- en: Figure 3-13\. The output of a ReLU neuron as z varies
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-13. 随着z变化的ReLU神经元的输出
- en: Softmax Output Layers
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Softmax输出层
- en: 'Oftentimes, we want our output vector to be a probability distribution over
    a set of mutually exclusive labels. For example, let’s say we want to build a
    neural network to recognize handwritten digits from the MNIST dataset. Each label
    (0 through 9) is mutually exclusive, but it’s unlikely that we will be able to
    recognize digits with 100% confidence. Using a probability distribution gives
    us a better idea of how confident we are in our predictions. As a result, the
    desired output vector is of the following form, where <math alttext="sigma-summation
    Underscript i equals 0 Overscript 9 Endscripts p Subscript i Baseline equals 1"><mrow><msubsup><mo>∑</mo>
    <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mn>9</mn></msubsup> <msub><mi>p</mi>
    <mi>i</mi></msub> <mo>=</mo> <mn>1</mn></mrow></math> :'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望输出向量是一组相互排斥标签的概率分布。例如，假设我们想要构建一个神经网络来识别MNIST数据集中的手写数字。每个标签（0到9）是相互排斥的，但我们不太可能能够以100%的信心识别数字。使用概率分布可以让我们更好地了解我们对预测的信心。因此，期望的输出向量具有以下形式，其中<math
    alttext="sigma-summation Underscript i equals 0 Overscript 9 Endscripts p Subscript
    i Baseline equals 1"><mrow><msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>0</mn></row>
    <mn>9</mn></msubsup> <msub><mi>p</mi> <mi>i</mi></msub> <mo>=</mo> <mn>1</mn></mrow></math>：
- en: <math alttext="Start 1 By 6 Matrix 1st Row 1st Column p 0 2nd Column p 1 3rd
    Column p 2 4th Column p 3 5th Column  ellipsis 6th Column p 9 EndMatrix"><mrow><mo>[</mo>
    <mtable><mtr><mtd><msub><mi>p</mi> <mn>0</mn></msub></mtd> <mtd><msub><mi>p</mi>
    <mn>1</mn></msub></mtd> <mtd><msub><mi>p</mi> <mn>2</mn></msub></mtd> <mtd><msub><mi>p</mi>
    <mn>3</mn></msub></mtd> <mtd><mo>...</mo></mtd> <mtd><msub><mi>p</mi> <mn>9</mn></msub></mtd></mtr></mtable>
    <mo>]</mo></mrow></math>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 1 By 6 Matrix 1st Row 1st Column p 0 2nd Column p 1 3rd
    Column p 2 4th Column p 3 5th Column  ellipsis 6th Column p 9 EndMatrix"><mrow><mo>[</mo>
    <mtable><mtr><mtd><msub><mi>p</mi> <mn>0</mn></msub></mtd> <mtd><msub><mi>p</mi>
    <mn>1</mn></msub></mtd> <mtd><msub><mi>p</mi> <mn>2</mn></msub></mtd> <mtd><msub><mi>p</mi>
    <mn>3</mn></msub></mtd> <mtd><mo>...</mo></mtd> <mtd><msub><mi>p</mi> <mn>9</mn></msub></mtd></mtr></mtable>
    <mo>]</mo></mrow></math>
- en: 'This is achieved by using a special output layer called a *softmax layer*.
    Unlike in other kinds of layers, the output of a neuron in a softmax layer depends
    on the outputs of all the other neurons in its layer. This is because we require
    the sum of all the outputs to be equal to 1\. Letting <math alttext="z Subscript
    i"><msub><mi>z</mi> <mi>i</mi></msub></math> be the logit of the  <math alttext="i
    Superscript t h"><msup><mi>i</mi> <mrow><mi>t</mi><mi>h</mi></mrow></msup></math>
    softmax neuron, we can achieve this normalization by setting its output to:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用称为*softmax层*的特殊输出层来实现的。与其他类型的层不同，softmax层中神经元的输出取决于其层中所有其他神经元的输出。这是因为我们要求所有输出的总和等于1。让<math
    alttext="z Subscript i"><msub><mi>z</mi> <mi>i</mi></msub></math>是第i个softmax神经元的逻辑，我们可以通过将其输出设置为来实现这种归一化：
- en: <math alttext="y Subscript i Baseline equals StartFraction e Superscript z Super
    Subscript i Superscript Baseline Over sigma-summation Underscript j Endscripts
    e Superscript z Super Subscript j Superscript Baseline EndFraction"><mrow><msub><mi>y</mi>
    <mi>i</mi></msub> <mo>=</mo> <mfrac><msup><mi>e</mi> <msub><mi>z</mi> <mi>i</mi></msub></msup>
    <mrow><msub><mo>∑</mo> <mi>j</mi></msub> <msup><mi>e</mi> <msub><mi>z</mi> <mi>j</mi></msub></msup></mrow></mfrac></mrow></math>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y Subscript i Baseline equals StartFraction e Superscript z Super
    Subscript i Superscript Baseline Over sigma-summation Underscript j Endscripts
    e Superscript z Super Subscript j Superscript Baseline EndFraction"><mrow><msub><mi>y</mi>
    <mi>i</mi></msub> <mo>=</mo> <mfrac><msup><mi>e</mi> <msub><mi>z</mi> <mi>i</mi></msub></msup>
    <mrow><msub><mo>∑</mo> <mi>j</mi></msub> <msup><mi>e</mi> <msub><mi>z</mi> <mi>j</mi></msub></msup></mrow></mfrac></mrow></math>
- en: A strong prediction would have a single entry in the vector close to 1, while
    the remaining entries would be close to 0\. A weak prediction would have multiple
    possible labels that are more or less equally likely.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 强预测将在向量中有一个接近1的单个条目，而其余条目将接近0。弱预测将有多个可能的标签，这些标签更或多或少是等可能的。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve built a basic intuition for machine learning and neural
    networks. We’ve talked about the basic structure of a neuron, how feed-forward
    neural networks work, and the importance of nonlinearity in tackling complex learning
    problems. In the next chapter, we will begin to build the mathematical background
    necessary to train a neural network to solve problems. Specifically, we will talk
    about finding optimal parameter vectors, best practices while training neural
    networks, and major challenges. In later chapters, we will take these foundational
    ideas to build more specialized neural architectures.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们建立了对机器学习和神经网络的基本直觉。我们讨论了神经元的基本结构，前馈神经网络的工作原理，以及在解决复杂学习问题时非线性的重要性。在下一章中，我们将开始建立训练神经网络解决问题所需的数学背景。具体来说，我们将讨论如何找到最佳参数向量，在训练神经网络时的最佳实践以及主要挑战。在后续章节中，我们将利用这些基础性思想构建更专业化的神经架构。
- en: ^([1](ch03.xhtml#idm45934167495712-marker)) Kuhn, Deanna, et al. *Handbook of
    Child Psychology. Vol. 2, Cognition, Perception, and Language*. Wiley, 1998.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 1. Kuhn, Deanna等人。《儿童心理学手册》。第2卷，认知、感知和语言。Wiley，1998年。
- en: ^([2](ch03.xhtml#idm45934169246960-marker)) Y. LeCun, L. Bottou, Y. Bengio,
    and P. Haffner. “Gradient-Based Learning Applied to Document Recognition.” *Proceedings
    of the IEEE*, 86(11):2278-2324, November 1998.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 2. Y. LeCun, L. Bottou, Y. Bengio和P. Haffner。"基于梯度的学习应用于文档识别。"《IEEE会议录》，86(11)：2278-2324，1998年11月。
- en: '^([3](ch03.xhtml#idm45934169203808-marker)) Rosenblatt, Frank. “The perceptron:
    A Probabilistic Model for Information Storage and Organization in the Brain.”
    *Psychological Review* 65.6 (1958): 386.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 3. Rosenblatt, Frank。"感知器：大脑中信息存储和组织的概率模型。"《心理评论》65.6（1958）：386。
- en: '^([4](ch03.xhtml#idm45934168242992-marker)) Bubeck, Sébastien. “Convex Optimization:
    Algorithms and Complexity.” *Foundations and Trends® in Machine Learning*. 8.3-4
    (2015): 231-357.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 4. Bubeck, Sébastien。"凸优化：算法和复杂性。"《机器学习基础与趋势》。8.3-4（2015）：231-357。
- en: ^([5](ch03.xhtml#idm45934168225968-marker)) Restak, Richard M. and David Grubin.
    *The Secret Life of the Brain*. Joseph Henry Press, 2001.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 5. Restak, Richard M.和David Grubin。《大脑的秘密生活》。Joseph Henry Press，2001年。
- en: '^([6](ch03.xhtml#idm45934168212000-marker)) McCulloch, Warren S., and Walter
    Pitts. “A Logical Calculus of the Ideas Immanent in Nervous Activity.” *The Bulletin
    of Mathematical Biophysics*. 5.4 (1943): 115-133.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 6. McCulloch, Warren S.和Walter Pitts。"神经活动中内在思想的逻辑演算。"《数学生物物理学公报》5.4（1943）：115-133。
- en: '^([7](ch03.xhtml#idm45934167717376-marker)) Mountcastle, Vernon B. “Modality
    and Topographic Properties of Single Neurons of Cat’s Somatic Sensory Cortex.”
    *Journal of Neurophysiology* 20.4 (1957): 408-434.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 7. Mountcastle, Vernon B.。“猫体感觉皮层单个神经元的模态性和拓扑特性。”《神经生理学杂志》20.4（1957）：408-434。
- en: ^([8](ch03.xhtml#idm45934165761792-marker)) Nair, Vinod, and Geoffrey E. Hinton.
    “Rectified Linear Units Improve Restricted Boltzmann Machines.” *Proceedings of
    the 27th International Conference on Machine Learning* (ICML-10), 2010.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 8. Nair, Vinod和Geoffrey E. Hinton。"修正线性单元改进了受限玻尔兹曼机。"《第27届国际机器学习会议论文集》（ICML-10），2010年。
