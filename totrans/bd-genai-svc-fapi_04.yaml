- en: Chapter 2\. Getting Started with FastAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the end of this chapter, you should feel comfortable using the FastAPI web
    framework, setting up FastAPI projects, and articulating your tech stack decisions
    for building GenAI services.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to FastAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[FastAPI](https://oreil.ly/2xcoR) is an asynchronous gateway interface (ASGI)
    web framework that enables you to build lean APIs and backend web servers. Being
    an ASGI framework means that it can leverage concurrency to process web requests.
    It is [fast comparable to modern frameworks](https://oreil.ly/tgwEJ) but also
    ships with strong [Swagger/OpenAPI integrations for auto-documentation](https://oreil.ly/WlwOC),
    alongside built-in data validation and serialization features via [Pydantic](https://oreil.ly/5-EmU).^([1](ch02.html#id507))
    Effectively, FastAPI is a wrapper over the [Starlette framework](https://oreil.ly/tyKtQ),
    built by Encode, the same people who built the Django REST framework. It is light-weight
    and has a similar development experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we discuss FastAPI in more detail, let’s set up your development environment
    with a running FastAPI application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Your Development Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the rest of this chapter, I will guide you through the installation
    process of FastAPI and its essential dependencies, enabling you to set up a basic
    web server. We will also install a selection of formatters, loggers, and linters
    that you can set up to enhance your development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Code examples in this book have been tested against Python 3.11\. Running code
    examples with other Python versions may result in issues. Furthermore, some deployment
    environments and package dependencies may not support the latest versions of Python.
  prefs: []
  type: TYPE_NORMAL
- en: You can now get started with setting up your FastAPI project.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python, FastAPI, and Required Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re on Windows, you can use `conda` to create a virtual Python environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re on a macOS or a Linux system, you can create a virtual Python environment
    using `venv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`venv` creates your virtual environment in the `.venv` folder that you can
    activate by using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the environment is activated, you can install the core packages needed
    to run the FastAPI server and serve requests from the OpenAI API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `uvicorn` package is the bare-bones web server that FastAPI runs on. `fastapi`
    will also install its dependency packages such as `starlette` and `pydantic`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Simple FastAPI Web Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once FastAPI and its dependencies are installed, you are ready to start your
    own web server. To create a simple web server that has one endpoint in FastAPI,
    all you have to write is 15 lines of code. Create a *main.py* file in the root
    of your directory, as shown in [Example 2-1](#simple_fastapi_web_server).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For simplicity, [Example 2-1](#simple_fastapi_web_server) uses the OpenAI API.
    To run the code, you can get an API key from [OpenAI](https://oreil.ly/SZsuD),
    which requires a credit card. However, rest assured that other code examples in
    this book will use open source models as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. Starter code for a simple FastAPI web server serving GPT-4o requests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_getting_started_with_fastapi_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a FastAPI application object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_getting_started_with_fastapi_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: You will need an [API key](https://oreil.ly/PP0nN) to use the OpenAI API.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_getting_started_with_fastapi_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `@app.get` decorator to create a `GET` endpoint on the `/chat` path.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_getting_started_with_fastapi_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Make an API call to the OpenAI Completions API to generate a response from the
    `gpt-4o` model.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_getting_started_with_fastapi_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Any data returned by the decorated function will be returned when you hit the
    root endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: You can now start the server using the `fastapi dev` command, as shown here:^([2](ch02.html#id511))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Your web server is now accessible from `http://127.0.0.1:8000` with two exposed
    endpoints at the root `/` and `/chat` routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you visit `http://127.0.0.1:8000` in your browser, you should see the `{"status":
    "healthy"}` message. Also, when you visit `http://127.0.0.1:8000/chat`, you should
    see an inspirational message from OpenAI’s `gpt-4o` model.'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations. You now have a fully working bare-bones generative AI service.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you started the server in a dev model using the `fastapi dev` command, a
    file watcher process is listening for changes in your project and auto-updates
    the service as you update the code.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to change the default prompt and refresh the browser to see your changes
    reflected in real time.
  prefs: []
  type: TYPE_NORMAL
- en: The `app` object—which is created from the `FastAPI` class—converts your Python
    function with a decorator into a Hypertext Transfer Protocol (HTTP) endpoint.
    You can trigger both endpoints by sending an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, the `uvicorn` package takes the `app` object and starts a web
    server running your FastAPI service.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to getting a simple web server out of the box, you also get API
    documentation automatically generated for you. The documentation follows the OpenAPI
    standard and includes an `openapi.json` specification of your web service and
    a Swagger documentation page built from the same specification file.
  prefs: []
  type: TYPE_NORMAL
- en: You can access the auto-generated docs page by going to the `/docs` route of
    your server via `http://localhost:8000/docs`; you’ll see a page similar to [Figure 2-1](#swagger_docs).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0201](assets/bgai_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Auto-generated Swagger documentation of the API
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From the Swagger docs page, you can send requests to your API to quickly test
    an endpoint. The docs page will also take care of sending the correct request
    headers, methods, and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: What I love about the Swagger docs page is that you can quickly iterate over
    various implementations using the user interface, which can be quicker than writing
    tests when iterating over the design of your APIs. However, this does not replace
    the traditional testing that can check every endpoint when you make changes. As
    your application grows, it is still worth writing tests. Once your endpoint signatures
    are further established, you can write `pytest` tests to systematically test your
    web service from end to end.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to auto-documentation, FastAPI ships with auto-serialization and
    validation of data. In [Example 2-1](#simple_fastapi_web_server), we returned
    a dictionary in the root controller as you visited `http://localhost:8000`. There
    is a bit of magic that must happen for data to show up in your browser. The data
    must first be serialized from a Python object such as a dictionary or a list into
    a JavaScript Object Notation (JSON) string first. Afterward, it’s transferred
    over the web and deserialized back into a JavaScript object by your browser client
    once transmission is completed. This is effectively how applications around the
    web “talk” to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Serialization is required when using HTTP for data transmissions, as only text
    or binary data can be transferred via HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a working FastAPI server, let’s look at FastAPI’s features
    and benefits that you can use in your project.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI Features and Advantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You want a suitable web framework that allows you to effortlessly create your
    generative AI services, without any unnecessary struggles. This framework should
    include all the essential elements for security, authentication, and performance,
    while still granting you the flexibility to incorporate any additional features
    and integrations required as your application grows in complexity.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI can meet most of these criteria, as it hosts several features and advantages
    out of the box. However, as you’ll learn more about [FastAPI limitations](#fastapi_limitations)
    later in this chapter, advanced use cases like resource-intensive AI workloads
    may require specialized web frameworks or solutions, as will be discussed in [Chapter 3](ch03.html#ch03).
  prefs: []
  type: TYPE_NORMAL
- en: For now, let’s review FastAPI’s features and benefits before discussing its
    limitations in the context of building generative AI services.
  prefs: []
  type: TYPE_NORMAL
- en: Inspired by Flask Routing Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In both Flask and FastAPI, you can create any route by decorating a function
    with a specialized decorator. You can then configure the routes to accept and
    validate headers, cookies, body, path, and query parameters to support your implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Asynchronous and Synchronous Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building services, your service must be able to handle multiple requests
    by several users to increase usage efficiency as demand scales. FastAPI can seamlessly
    [handle both synchronous and asynchronous functions in your application](https://oreil.ly/gNYMg)
    to enable concurrency from the get-go.
  prefs: []
  type: TYPE_NORMAL
- en: As we will discuss in detail in [Chapter 5](ch05.html#ch05), if you define an
    asynchronous route using `async def`, FastAPI will run it on the main thread on
    the main event loop. On the other hand, if you define a synchronous route (not
    declared with the `async` keyword), FastAPI will run it on a *thread worker* for
    handling concurrent workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is additional overhead to running threaded operations compared to running
    them asynchronously. Therefore, having many synchronous routes can still limit
    the scalability of your application.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, concurrent requests won’t block the main server thread. This is
    particularly useful when dealing with input/output operations, such as querying
    databases, exchanging data with a graphical processing units (GPU),^([3](ch02.html#id527))
    or making HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Built-In Support for Background Tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can build routes capable of handling long-running tasks (e.g., sending emails)
    without the need of external libraries (e.g., `celery`). FastAPI includes a [background
    tasks feature](https://oreil.ly/aO6ml)^([4](ch02.html#id530)) for working with
    systems that need time to process data but you don’t want them to delay returning
    the responses to requests.
  prefs: []
  type: TYPE_NORMAL
- en: Not all tasks can be responded to within the patience tolerance of your users.
    You do not want to keep them waiting while the process is continuing to finish.
    You can hand off the long-running operation to a background task running on a
    separate thread, after you respond to the client. As a response, you can then
    let clients know that your service has accepted and queued their request to process
    it in the background.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, in GenAI services you can use background tasks to process large
    uploaded documents into a vector database without blocking the server. This allows
    the server to handle other requests while the document processing happens in the
    background.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn how to build such a system in [Chapter 5](ch05.html#ch05).
  prefs: []
  type: TYPE_NORMAL
- en: Custom Middleware and CORS Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FastAPI enables you to add [middleware components](https://oreil.ly/uvlLC) to
    your app router to intercept the communication between your API endpoints and
    the clients. Each middleware, sitting in front of your endpoints, allows you to
    access the request and response objects to modify them as needed. You can add
    logic around how requests should be processed before they’re handed off to the
    route handlers. Once the response is generated, you can then perform operations
    on the response—such as modifying headers, logging operations, and setting cookies—before
    sending it off to the client.
  prefs: []
  type: TYPE_NORMAL
- en: A common pattern in backend development is to use middleware to [add extra headers
    to a response](https://oreil.ly/Yfsqg), perform basic checks on incoming requests,
    support [CORS requests](https://oreil.ly/6u1dI), [log and monitor communications](ch03.html#middleware_monitoring),
    and much more. You can even take advantage of third-party and [custom middleware](https://oreil.ly/AJKJt).
  prefs: []
  type: TYPE_NORMAL
- en: Freedom to Customize Any Service Layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when you may want to break away from the limitations of your
    current web framework. FastAPI provides a solution to this by allowing you to
    define custom classes that inherit base classes of Starlette—the underlying web
    framework. For instance, you can [override default exception handlers](https://oreil.ly/qgvgO),
    add [custom ASGI middleware](https://oreil.ly/1A8OD), or even [create custom responses](https://oreil.ly/jLXUf).
  prefs: []
  type: TYPE_NORMAL
- en: With the power of Pydantic or [FastAPI’s encoders](https://oreil.ly/MJmqJ),
    you can also effortlessly create your own [custom serializers](https://oreil.ly/UnzRk)
    to adjust how datetime objects are handled.
  prefs: []
  type: TYPE_NORMAL
- en: This enables you to implement features according to your preferences without
    having to struggle against FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: Data Validation and Serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For applications that handle large amounts of data, it is important that the
    data you are about to process is clean and in a known format.
  prefs: []
  type: TYPE_NORMAL
- en: As the complexity of your service grows, you will want to perform data validation
    and serialization. In FastAPI, you can use Pydantic to automatically serialize
    common data types (e.g., lists, dictionaries, primitives) when returning them
    in API routes. You can also define your own Pydantic schemas for request and response
    data to perform stricter data validation.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, you can validate a user’s password on account creation to match
    your security policies, as shown in [Example 2-2](#data_validation).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. Validating user passwords in FastAPI using a Pydantic schema
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_getting_started_with_fastapi_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a Pydantic model with custom data validation on the `password` field.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_getting_started_with_fastapi_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Raise a `ValueError` if any of the password policies are not met.
  prefs: []
  type: TYPE_NORMAL
- en: This enables you to catch, handle, and protect your services from data issues
    that are not captured by static type checkers like `mypy`.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic validators also allow you to validate more complex data types at runtime
    like emails, URLs, UUIDs, and more. [Chapter 4](ch04.html#ch04) will go into more
    detail on how to perform data validation using Pydantic.
  prefs: []
  type: TYPE_NORMAL
- en: Rich Ecosystem of Plug-Ins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Plug-ins are Python packages that hook into FastAPI internals and existing features.
    They are similar to any other Python package you install and import into your
    scripts, and they require minimal configurations after installation. Integrating
    them means extending the functionalities of your service without having to deal
    with order of integrations or compatibility issues. You can also remove them without
    breaking your app.
  prefs: []
  type: TYPE_NORMAL
- en: Some well-known plug-ins include FastAPI Filters, Auth Users, Rate Limiting
    and several others, which you can view at the [Awesome FastAPI GitHub repository](https://oreil.ly/nKbvP).
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With FastAPI, Swagger UI documentation is auto-generated for you to view and
    test any routes you create, as you saw in [Figure 2-1](#swagger_docs). During
    development, having an interactive docs page allows for easier and faster debugging
    and prototyping of your routes until you build and maintain your own test suites.
  prefs: []
  type: TYPE_NORMAL
- en: As you build new endpoints, you may often want to revisit the `/docs` page to
    test them.
  prefs: []
  type: TYPE_NORMAL
- en: You can configure a redirect from the base URL `/` to the `/docs` endpoint to
    facilitate quicker access to the documentation page, as shown in [Example 2-3](#setting_up_redirect).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. Setting up redirect to the auto-generated docs page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_getting_started_with_fastapi_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a handler for the base root handler, but don’t include it in OpenAPI
    specifications and the documentation page.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_getting_started_with_fastapi_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Return a redirect response to the `/docs` page with a redirection status code
    for the browsers to perform the redirect.
  prefs: []
  type: TYPE_NORMAL
- en: With [Example 2-3](#setting_up_redirect) implemented, you can access the `/docs`
    page during local development whenever you visit the base URL `/` of the service.
  prefs: []
  type: TYPE_NORMAL
- en: In production, unless your API is public, disable this redirection and hide
    the `/docs` routes by default for enhanced security.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If your API is publicly accessible in production, you may expose unsecured endpoints
    and sensitive information about your API. Therefore, it is [best practice to turn
    off the documentation page](https://oreil.ly/Dk45G).
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you can show the `/docs` page explicitly on selected environments only.
  prefs: []
  type: TYPE_NORMAL
- en: For public APIs, you can set the root handler `/` to return your API version
    instead of redirecting to the `/docs` page.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another powerful component of FastAPI is its [dependency injection system](https://oreil.ly/eAIwR)
    based on a development pattern called *inversion of control*. Using this pattern,
    you break down a function into a series of functions that you inject into other
    functions as *dependencies*.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to helping structure your application logic, dependencies can help
    you reduce duplication. They let you share and reuse logic across your API, reuse
    open database connections, enforce security such as authentication or authorization
    requirements, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can specify common query parameters across API routes (e.g.,
    for pagination and filtering), as shown in [Example 2-4](#dependency_pagination).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. Reducing duplication using a pagination dependency
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In FastAPI, dependencies are also cached within *the context of a single request*
    to prevent duplicate computations. This means a dependency function is executed
    only once per request, and its result is reused for the duration of that request
    if needed again. However, in a new request, the dependency function is executed
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Having to manage database connections or checking user credentials in every
    route handler is tedious and violates the *Don’t Repeat Yourself* (DRY) principles
    of programming. Another great use case of the dependency injection system is when
    you create a database connection and want to reuse that connection to perform
    multiple fetch requests while processing a single request.
  prefs: []
  type: TYPE_NORMAL
- en: You can create dependencies for your route controller functions, as shown in
    [Example 2-5](#fastapi_dependency).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5\. Dependency injection in FastAPI
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_getting_started_with_fastapi_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a function to create and manage a database session, which can be used
    as a dependency in route handlers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_getting_started_with_fastapi_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Yield the open database session, making it available for any function that depends
    on `get_db`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_getting_started_with_fastapi_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Close the database session after the request is processed, preventing resource
    leaks.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_getting_started_with_fastapi_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Inject the `get_db` dependency into the route handler to create and reuse the
    same database session during the request lifecycle. FastAPI will also automatically
    expose parameters within dependencies on your endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_getting_started_with_fastapi_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Reuse the injected database session to perform multiple database operations
    within a single request to return a user’s messages.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Example 2-5](#fastapi_dependency), you can inject these dependencies
    into other functions by passing them as parameters to `Depends()` for FastAPI
    to evaluate and cache your function outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Here you define a utility function for creating a database session and then
    use it as a dependency of the `get_current_user_messages` function to inject the
    created database session.
  prefs: []
  type: TYPE_NORMAL
- en: This dependency system is just one of many other features that ship with FastAPI
    that speed up and ease the process of building backend services.
  prefs: []
  type: TYPE_NORMAL
- en: Lifespan Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[FastAPI’s lifespan events](https://oreil.ly/Cn2DB) are excellent for handling
    initialization and cleanup of your service when you need to set up resources that
    can be shared between requests.^([5](ch02.html#id554)) During server startup,
    you can create database connection pools or load GenAI models into memory for
    reuse across requests. Afterward, before server shutdown, you can clean up by
    unloading AI models, closing connection pools, deleting temporary artifacts, and
    logging events.'
  prefs: []
  type: TYPE_NORMAL
- en: By using lifespan events, your FastAPI service performs long-running operations
    like model loading at the start, before serving requests, and keeps it loaded
    for reuse among requests. During server shutdown, you can then gracefully finish
    all remaining and queued requests before running any cleanup operations.
  prefs: []
  type: TYPE_NORMAL
- en: Security and Authentication Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with any other framework, you will need security and authentication components
    to secure your service. FastAPI doesn’t lock you in a specific implementation
    of the security and authentication layer. It gives you a set of [security components](https://oreil.ly/zlAgl)
    so you can protect your services based on your own needs.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn how to implement an authentication layer from scratch for your
    GenAI services in [Chapter 8](ch08.html#ch08).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you don’t want to implement an authentication layer from scratch, then you
    can also reach out for third-party plug-ins like [FastAPI Users](https://oreil.ly/eEtMe)
    that automatically take care of that for you.
  prefs: []
  type: TYPE_NORMAL
- en: You can also integrate with third-party authentication providers for [single
    sign-on flows in FastAPI](https://oreil.ly/vIqCd) in enterprise environments.
  prefs: []
  type: TYPE_NORMAL
- en: Bidirectional Web Socket, GraphQL, and Custom Response Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building services, you will often need to move beyond the standard *REST*
    *endpoints*.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re building a chat application, you may also need real-time client-server
    communication or longer-duration connections where data is streamed in a direction.
    WebSocket (WS) and server-sent events (SSE) endpoints can help you stream generative
    model outputs to the clients, as you will see in [Chapter 6](ch06.html#ch06) on
    real-time communication with AI services.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, you may want to use [GraphQL in FastAPI](https://oreil.ly/SL62a)
    to expose endpoints that can return dynamic schemas based on the request. FastAPI
    can use the [`strawberry` package](https://oreil.ly/wIzvi)^([6](ch02.html#id561))
    to leverage GraphQL in using dynamic schemas for your API service so that clients
    can select fields they want from a resource to avoid over-fetching data from your
    service. However, we won’t be covering GraphQL usage in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Modern Python and IDE Integration with Sensible Defaults
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the FastAPI tech stack is built on modern Python (e.g., with type annotations
    and doc-strings), all IDE linters and formatters can natively check and format
    your codebase. The defaults are also sufficient to get you started by importing
    and instantiating the FastAPI class. Because everything ties neatly with modern
    IDE and Python features, anyone can easily get started building, testing, debugging,
    and deploying their own FastAPI services.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI Project Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often when you are working on a real-world project, you will end up building
    services that will span multiple modules, packages, and nested directories. The
    decision on how to structure your project is going to be totally up to you.
  prefs: []
  type: TYPE_NORMAL
- en: This is where most people will struggle and end up with a codebase too overwhelming
    to navigate. You will end up frustrated, having to understand the codebase and
    project structure before you can contribute to it. At some point, the complexity
    will grow so much that you will dread touching the project again.
  prefs: []
  type: TYPE_NORMAL
- en: Some files will end up too large to read with bloated functions, or there will
    be too many files scattered all over the place. You may also end up having millions
    of import errors or circular dependencies breaking your application.
  prefs: []
  type: TYPE_NORMAL
- en: Learning to structure larger applications will be even more important when working
    with generative AI models. These models often need dependencies and additional
    utility functions to support them. Therefore, you will have to add a layer of
    complexity for your models on top of existing applications layers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Compared to opinionated frameworks such as Django, you need to follow good practices
    for having success with larger projects in nonopinionated frameworks such as FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: Over the past few years working with FastAPI and data science applications,
    I have seen many developers come up with their own cookie-cutter templates for
    starting FastAPI projects. Some even recommend following a structure popularized
    by the Netflix Dispatch FastAPI project for larger API applications that has inspired
    other templates.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to building real-world applications, you must do everything you
    can to keep the codebase as structured as possible. This is for your own benefit—to
    help you and others in your team in understanding the code in the future.
  prefs: []
  type: TYPE_NORMAL
- en: You know you have a good project structure if you can find any function or component
    within your codebase. If you start questioning the purpose of a directory or spending
    hours searching for a piece of code, then your project structure might be unclear
    and too complex to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'In these instances, you can refer to a few common project structures that have
    recently become popular in the FastAPI community. There are a few project structures
    you can adopt: flat, nested, and modular.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us take a detailed look at each one.
  prefs: []
  type: TYPE_NORMAL
- en: Flat Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A flat structure is one in which the application files remain at the root of
    your project with no nested directories. You may group all your files under a
    single directory for better organization.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea here is to keep all similar code in modules and placed together
    near the root of your project. For instance, put all your database models in *models.py*
    or your endpoints in *routes.py*.
  prefs: []
  type: TYPE_NORMAL
- en: By far, the most common project structure is flat due to its simplicity and
    ease of use. This structure is often great for building the first version of a
    service or a tiny microservices. [Example 2-6](#flat_structure) is what the structure
    could look like.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6\. A flat FastAPI project structure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the structure shown in [Example 2-6](#flat_structure) that you
    have a few files that contain the core of your application logic. If you are building
    a microservice with FastAPI, by definition, you will want to maintain a flat structure
    for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: The simplicity of the flat structure allows you to focus on the development
    rather than the structure. There are few files to worry about. You also don’t
    need to care about coupling, decomposition, or reuse as there are few lines of
    codes to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the flat structure will be hard to maintain as your project
    grows in complexity. At this point, it makes sense to break down the global Python
    modules into packages of their own using the nested structure.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The nested structure groups similar modules into packages—effectively creating
    a nested structure and hierarchy of modules. You group all modules under a package
    that are similar in nature irrespective of the feature they support. These are
    loosely coupled modules that contain similar logic for different entities in your
    project. For instance, the `models` package may contain `users` and `profiles`
    database models.
  prefs: []
  type: TYPE_NORMAL
- en: The nested structure is recommended for larger projects by the official FastAPI
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: You can see a project with nested structure in [Example 2-7](#nested_structure).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7\. Nested FastAPI project
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you add AI models and several external services and databases to your project,
    you can adopt a nested structure to manage the growing complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The main pitfall with this project structure is the ambiguous coupling of modules.
    Changes in one module can cascade into other modules, and it can become difficult
    to understand the cascading effect of new changes. Over time, it can be challenging
    to maintain and change the code without performing many updates everywhere else.
    This is referred to as *shotgun updates*. Shotgun updates in the context of software
    development are when it is challenging to maintain and change the code without
    performing many updates everywhere else.
  prefs: []
  type: TYPE_NORMAL
- en: If you expect difficulty managing module coupling or expecting to deal with
    a large application, I would recommend using a modular structure.
  prefs: []
  type: TYPE_NORMAL
- en: Modular Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The modular structure—popularized by the Netflix Dispatch FastAPI project—is
    similar to the nested structure because you can place multiple modules within
    a package and subpackages. However, the core difference is in how you organize
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: In the modular structure, modules that are closely related and refer to a specific
    domain are grouped together. This approach differs from the previously mentioned
    nested structure. An example could be the `users` package that contains user schemas,
    database services, dependencies and routers.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this difference better, look at [Example 2-8](#modular_structure).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8\. Modular FastAPI project structure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In modular project structure like the one shown in [Example 2-8](#modular_structure),
    you bring together closely interconnected components based on a feature or a global
    system they implement (e.g., authentication, payment processing, notifications,
    etc.) or the resource they interact with (e.g., users, profiles, messages, etc).
    This kind of encapsulation eliminates any uncertainty regarding the couplings
    in your code, resulting in improved scalability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to include more features, you can create a new package that contains
    all the necessary code. Similarly, if you need to modify or delete code, you can
    easily determine where the changes should be made and expect how they will impact
    other parts of the code. This is possible because the structure of the codebase
    is transparent and well-encapsulated, making it clear where different components
    are connected.
  prefs: []
  type: TYPE_NORMAL
- en: Progressive Reorganization of Your FastAPI Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A modular codebase allows you to add and remove components with ease. You can
    also reuse components across different parts of your system to avoid repetition.
  prefs: []
  type: TYPE_NORMAL
- en: When you first start your project, modularity is not as important. You can get
    started with just a single or a few Python files to build your services easily.
    However, as soon as you introduce AI models, external services, and complex business
    logic, you will want to consider modularizing your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: You can achieve modularity by designing components of your system with re-usability
    and disposability in mind. Make sure the design of your modules and functions
    allow for usage in different environments and that you place them at the right
    place in your project directory. Selecting the best project structure is a matter
    of preference. However, you may be asking yourself, “Which project structure should
    I adopt for building generative AI services with FastAPI?”
  prefs: []
  type: TYPE_NORMAL
- en: 'I found that the best way to structure projects is to *progressively reorganize*
    your project from a flat to a modular structure as your service complexity grows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Flat
  prefs: []
  type: TYPE_NORMAL
- en: If you are starting with a new project and the complexity of your system is
    not yet clear, you can focus on writing all your FastAPI code in a single file
    before worrying about the project structure. You then extract your code into several
    files under the root directory. This is the initial structure you will adopt when
    experimenting on the first version of your service from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Nested
  prefs: []
  type: TYPE_NORMAL
- en: As the number of files in your codebase and service complexity grows, you can
    adopt the nested structure. You can search for files based on logical grouping
    (models, routers, schemas, etc.) and do not have to worry too much about logical
    couplings in your code. As you make changes, only a handful of files are affected.
    At this point, you have an AI microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Modular
  prefs: []
  type: TYPE_NORMAL
- en: As you move from a microservice to a full backend service, you will want to
    adopt a modular structure. There is now an increasing number of modules, features,
    and complexity. You start grouping your code into packages based on *areas of
    concern*. Your code is now handling requests, authentication, external systems,
    etc., while serving an AI model.
  prefs: []
  type: TYPE_NORMAL
- en: I suggest restructuring your project as outlined. However, you have the flexibility
    to adopt any organizational scheme that makes sense to you and allows you to recall
    the location and purpose of your files.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember, if you cannot justify the file organization in your codebase to another
    developer, it is time to reconsider your existing structure.
  prefs: []
  type: TYPE_NORMAL
- en: As you build your GenAI service, you will inevitably end up with a large codebase
    and a complex application.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about the structure of your large FastAPI application is only the first
    step in building production-grade services. In the next step, you will learn more
    about a software design pattern that helps you manage the complexity of your AI
    services. This is called the *onion*, or *layered*, application design pattern,
    which we will talk about next.
  prefs: []
  type: TYPE_NORMAL
- en: Onion/Layered Application Design Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you plan on building a fully featured backend service for generative AI,
    you will benefit to know more about the onion, or layered, application design
    pattern, which can be implemented within the nested and modular project structures.
    The purpose of this pattern is to create a separation of concerns between the
    different parts of your application to simplify the process of adding, removing,
    and modifying features.
  prefs: []
  type: TYPE_NORMAL
- en: The onion design pattern has also influenced web frameworks in other languages
    such as [Nest.js](https://nestjs.com).
  prefs: []
  type: TYPE_NORMAL
- en: The onion design consists of layers, each with a specific responsibility and
    dependency direction, shown in [Figure 2-3](#onion_design_pattern). The innermost
    layer contains the domain models and business logic, while the outer layers contain
    route handling (in an API service) or user-interfacing code (when serving HTML
    templates).
  prefs: []
  type: TYPE_NORMAL
- en: The pattern is called “onion” because the layers build upon each other, with
    the domain model at the center, surrounded by layers of increasing abstraction
    promoting testability, maintainability, and flexibility in maintaining your AI
    services. The core of the application (domain model and business logic) is at
    the inner layers, and all other layers depend inwardly on it. This approach helps
    to manage dependencies, promote separation of concerns, and facilitate a more
    testable and maintainable codebase.
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0203](assets/bgai_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. Onion design pattern
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The main idea behind this pattern is the *dependency inversion principle*, which
    states that high-level modules should not directly depend on the implementation
    of low-level modules but declare what they need from low-level modules by leveraging
    the FastAPI dependency system. The dependency system can then inject the output
    of the low-level modules to avoid coupling between layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this software design, you break down your service as an onion
    consisting of layers that go deeper and deeper. Each layer (as you move from outer
    to inner layers) introduces components that are responsible for a set of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: API routers
  prefs: []
  type: TYPE_NORMAL
- en: Routers are responsible for grouping multiple controllers/route handlers to
    apply common logic across several controllers.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI provides the `APIRouter` class to help you with this.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers/route handlers
  prefs: []
  type: TYPE_NORMAL
- en: Controllers are responsible for handling incoming *requests* and returning *responses*
    to the client via a logical execution of services or providers.
  prefs: []
  type: TYPE_NORMAL
- en: Good controller design always uses dependencies to inject required data or logic
    required for its execution. See [Figure 2-4](#api_routers_controllers).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0204](assets/bgai_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. API routers and controllers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Services/providers
  prefs: []
  type: TYPE_NORMAL
- en: Services are responsible for combining or orchestrating multiple internal operations
    to implement a business logic (services), while providers implement the interface
    with external systems.
  prefs: []
  type: TYPE_NORMAL
- en: Services typically use repositories for data access to implement complex business
    logic rather than simple data retrieval and mutation operations. Each module of
    your application can have its own service.
  prefs: []
  type: TYPE_NORMAL
- en: Providers are similar to services but are specialized in interacting with external
    systems such as internal/third-party APIs. Examples of providers include clients
    for email servers, payment gateways, or other microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, both providers and services support implementation of controller
    business logic by facilitating internal and external interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how they work together within a route controller: the
    `users` database service fetches a user’s record by email and then uses that information
    with a payment gateway and email server clients (providers) for processing payments
    and sending confirmation emails.'
  prefs: []
  type: TYPE_NORMAL
- en: Repositories (data adapters)
  prefs: []
  type: TYPE_NORMAL
- en: A repository is a design pattern used when implementing the logic for data access
    and mutation operations with data sources (not to be confused with a Git repository).
  prefs: []
  type: TYPE_NORMAL
- en: Repositories use object-relational mapping (ORM) or raw SQL commands to execute
    queries on your infrastructure like a database, or a memory store for retrieving
    or mutating data.
  prefs: []
  type: TYPE_NORMAL
- en: You may implement an abstract interface in this layer to enforce consistent
    design across all your repositories—using the create, read, update, delete (CRUD)
    operations. See [Figure 2-5](#services_providers_repositories).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0205](assets/bgai_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. Services, providers, and repositories
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Schemas/models
  prefs: []
  type: TYPE_NORMAL
- en: These are responsible for enforcing type-safety, structure, and validation logic
    on your data as it flows throughout your service.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also have components that span layers to support the whole application:'
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  prefs: []
  type: TYPE_NORMAL
- en: This handles requests and responses before and after they are passed to the
    application controllers/route handlers (see [Figure 2-6](#middlewares)).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0206](assets/bgai_0206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. Middleware
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Dependencies
  prefs: []
  type: TYPE_NORMAL
- en: These include reusable functions you define that can be injected into controllers
    to support a business logic. Dependencies can be cached and depend on other dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes
  prefs: []
  type: TYPE_NORMAL
- en: These are data transformer functions that you can use across application layers.
    Examples include data aggregators, cleaners, parsers, translators, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Mappers
  prefs: []
  type: TYPE_NORMAL
- en: These are data mappers from one schema into another, often passing data across
    layers such as from the `UserRequest` schema at a router layer to the `UserInDB`
    schema at the data access layer. See [Figure 2-7](#models_pipes_mappers).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0207](assets/bgai_0207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7\. Models, pipes, and mappers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Exception filters
  prefs: []
  type: TYPE_NORMAL
- en: These consistently handle exceptions across the layers.
  prefs: []
  type: TYPE_NORMAL
- en: Guards
  prefs: []
  type: TYPE_NORMAL
- en: These secure and protect controllers from abuse. Authentication and authorization
    logic can be implemented as dependencies or middleware to act as guards (see [Figure 2-8](#guards)).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0208](assets/bgai_0208.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. Guards
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you refer to the modular project structure shown in [Example 2-8](#modular_structure),
    you will now notice various elements of the onion design pattern in the modular
    project structure. Following this pattern can help you create a maintainable,
    testable, and scalable FastAPI generative AI service.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapters, you’ll use these patterns to build the GenAI service
    shown in [Figure 2-9](#genai_service).
  prefs: []
  type: TYPE_NORMAL
- en: '![bgai 0209](assets/bgai_0209.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-9\. Generative AI service you’ll build with FastAPI
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Next, we will compare FastAPI with other frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing FastAPI to Other Python Web Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most Python web frameworks can provide you with tools for building REST, GraphQL,
    WebSocket, and other types of endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: These frameworks are either opinionated, such as Django (Python) and Nestjs
    (JavaScript), while others are not. Flask or FastAPI (Python) and Express (JavaScript)
    give you the option to architect your service however you like.
  prefs: []
  type: TYPE_NORMAL
- en: Opinionated frameworks, such as Django (Python) and Nestjs (JavaScript), make
    decisions for you with certain assumptions about how you will be providing data
    to your components. Effectively, they provide structure while restricting what
    you are allowed to do. Opinionated frameworks are typically easier to use. On
    the other hand, nonopinionated frameworks such as Flask or FastAPI (Python) and
    Express (JavaScript) are more flexible but can give you too much freedom—many
    possibilities to achieve the same results.
  prefs: []
  type: TYPE_NORMAL
- en: Because nonopinionated frameworks such as FastAPI give you so much freedom in
    building services, you may feel some decision fatigue when choosing and integrating
    every single support package yourself. For instance, to work with a database,
    you will need to install and integrate several packages that work well together—one
    to access the database, one to migrate it, and another to act as an object relational
    mapper (ORM).
  prefs: []
  type: TYPE_NORMAL
- en: While doing that, you may run into compatibility issues with older packages
    during integration. This makes working with nonopinionated frameworks difficult,
    and often you may decide to use an opinionated framework such as Django, which
    ships with a tightly integrated and excellent ORM system for interacting with
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: Django is a battery-included framework that markets itself as the “Python web
    framework for developers with deadlines.” It ships with a fully integrated and
    feature-rich ORM system that takes care of your database migrations and data access
    needs when you provide the data models.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it provides you with an administration panel, a credentials-based
    user authentication and authorization system, and several web security features
    out of the box, so you do not have to build these yourself. It has also been around
    for a long time, fostering an active community that has produced excellent documentation,
    tutorials, and other resources for the framework. In Django version 4.2, support
    for async requests has also been introduced—allowing you to build concurrency
    into your services. Django expects you to adopt the MVC architecture, requiring
    you to define data models and views. These views become routes serving templated
    HTML files, JSON responses, or any HTTP response out of the box, even without
    relying on `django-rest-framework`. Controller layers then will contain the core
    data processing and business logic.
  prefs: []
  type: TYPE_NORMAL
- en: This makes Django an excellent choice for monolith *progressive web applications*
    (PWA) that deploy as a single backend with a frontend. However, as businesses
    move toward building specialized teams for developing backends and frontends,
    microservice architectural patterns are becoming more popular. With microservices,
    you want to separate your backend and frontend services, build APIs instead of
    PWAs, and focus on keeping your services as lean as possible. Using Django you
    can also build APIs, but you can end up with a heavy application that slows you
    down during development, deployment, and scaling services. That is why nonopinionated
    frameworks such as Flask are rising in popularity.^([7](ch02.html#id589))
  prefs: []
  type: TYPE_NORMAL
- en: Flask ships with as little code as practically possible for building web servers.
    In comparison to FastAPI, Flask does not come packaged with data validation, auto-documentation,
    and a dependency injection system. The mentioned features are often required for
    building any backend service that is becoming complex or requires integration
    with databases and external services.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A new web framework called Quart has tried to tackle this problem, which is
    a good contender to FastAPI. However, at the time of this writing, Quart is new,
    and compared to other frameworks it does not have a large community of users and
    documented resources to help if you get stuck on a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Flask was released in 2010 and implements a communication protocol
    called *Web Server Gateway Interface* (WSGI) for web serving, meaning that requests
    are processed synchronously in comparison to ASGI, which is asynchronous in nature.
    Additionally, Flask is not designed for handling a large number of simultaneous
    connections (like an asynchronous framework would). However, this does not limit
    the number of parallel requests the server can handle on its own. In production,
    you can employ various strategies (like worker processes or threads) to handle
    multiple requests concurrently. Also, because Flask implements WSGI, it does not
    support WebSocket endpoints, which are used for maintaining a persistent, bidirectional
    communication channel between a client and a server. This is because WSGI does
    not natively support WebSocket. However, you can install Flask extensions to integrate
    WebSocket support.
  prefs: []
  type: TYPE_NORMAL
- en: Flask, relying on a WSGI server, will process each request synchronously, whereas
    FastAPI uses an event loop for concurrent workloads. Therefore, FastAPI is going
    to be much faster with input/output (I/O) heavy tasks—for instance, when communicating
    with an external API or data store, which would block an entire worker process
    in Flask.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, I recommend Django and other frameworks if you want to build PWA
    monoliths, and Flask or Quart for simple APIs and frameworks in other languages
    if you have more experience with them.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you’re building a backend service that requires AI model support,
    connection to external systems, and some level of business logic complexity, I
    recommend considering FastAPI as the web framework of choice.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI Limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the aforementioned features and benefits, there are also several drawbacks
    and trade-offs you must consider if you are going to adopt FastAPI for your project.
    With AI use cases in mind, FastAPI falls short in several areas.
  prefs: []
  type: TYPE_NORMAL
- en: Inefficient Model Memory Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FastAPI does provide built-in mechanisms for sharing model memory between multiple
    instances or processes of the same container. This means when scaling web workers
    horizontally, you need to load a whole new model instance into the container’s
    memory. This creates a memory bottleneck and increases operational costs of high-traffic
    GenAI services.
  prefs: []
  type: TYPE_NORMAL
- en: Limited Number of Threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a limit to the number of threads that FastAPI creates on application
    startup in the internal thread pool.^([8](ch02.html#id601))
  prefs: []
  type: TYPE_NORMAL
- en: This means there is also a limit to how much you can scale a single instance
    of FastAPI, especially with AI workloads that have heavy I/O as well as CPU/GPU-intensive
    operations.^([9](ch02.html#id602))
  prefs: []
  type: TYPE_NORMAL
- en: Restricted to Global Interpreter Lock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, multithreading can produce unintuitive and often counterproductive
    results because of the *Global Interpreter Lock* (GIL).
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI leverages multithreading via an internal thread pool to handle concurrent
    web requests hitting a synchronous route. However, even with asynchronous endpoints,
    the AI inference requests can still block the main event loop, preventing all
    other requests from being processed in the main web serving thread.
  prefs: []
  type: TYPE_NORMAL
- en: This is because AI inference workloads are CPU/GPU intensive. Non-I/O operations,
    such as serving an expensive model or aggregating large amounts of data on a worker,
    will cause other threads to wait as Python currently is not using multiple cores
    for threading.^([10](ch02.html#id607)) Instead, as you’ll learn more in [Chapter 5](ch05.html#ch05),
    for these kinds of expensive compute operations, you’ll need to use multiprocessing
    or a process pool instead.
  prefs: []
  type: TYPE_NORMAL
- en: Lack of Support for Micro-Batch Processing Inference Requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deep learning frameworks provide support for vectorization so that inferences
    can be batched together, efficiently computed, and parallelized. Unfortunately,
    prediction requests can’t be batched together in FastAPI, and as a result, each
    compute-intensive model inference operation can block other requests.
  prefs: []
  type: TYPE_NORMAL
- en: When scaling services, a solution is to serve heavy models separately and use
    FastAPI to authenticate and manage the incoming and outgoing data.
  prefs: []
  type: TYPE_NORMAL
- en: Cannot Efficiently Split AI Workloads Between CPU and GPU
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the CPU mostly handles request transformation and validation operations,
    the GPU can run and parallelize compute-intensive model inference. In some specialized
    ML web frameworks (like BentoML), you can also efficiently split AI workloads
    between the CPU and GPU.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you split AI workloads across the CPU and GPU, data preparation and post-processing
    operations run on the CPU, while faster deep learning inference is performed on
    the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, FastAPI can’t efficiently perform this split of the AI inference
    workload between these devices. This means your CPU can be blocked from processing
    requests even when inference processes are running on the GPU. As this is a big
    bottleneck when working with heavier models, it will require serving heavier models
    outside FastAPI for concurrent workloads.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss solutions to this limitation in more detail in [Chapter 5](ch05.html#ch05).
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Conflicts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are deploying ML models, you will face unique challenges compared to
    deploying typical web applications. This is due to your model runtime’s deep coupling
    with native libraries and hardware. Each deployment environment can operate on
    distinct hardware and may require you to use specific versions of native libraries
    and containerization commands.
  prefs: []
  type: TYPE_NORMAL
- en: Lack of Support for Resource-Intensive AI Workloads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite its incredible capabilities, FastAPI was developed before the rise of
    generative AI. As a result, it remains a general-purpose web framework with recent
    support for AI serving and ML workflows. However, for certain use cases, such
    as serving resource-intensive and complex billion-parameter models, it may be
    worth exploring other frameworks like *BentoML*.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, you’ll learn how to build your own GenAI service
    with FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: But before moving forward, let’s configure necessary Python tools like linters,
    formatters, and type checkers in your development environment for easier maintainability
    of your FastAPI project as we work on it together.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a Managed Python Environment and Tooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To maintain a stable and reproducible development environment, you may want
    to manage your Python environment and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a *requirements.txt* file with `pip` for simpler projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using [uv](https://oreil.ly/Qxl7h) or [Conda](https://oreil.ly/Kfsc4) for `pip`-driven
    workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using [Poetry](https://oreil.ly/Rt04z) for more complex projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aside from managing dependencies, Python also has several third-party packages
    that allow you to lint and format your codebase before shipping it into production.^([11](ch02.html#id618))
  prefs: []
  type: TYPE_NORMAL
- en: It is best practice for professional Python developers to use these tools to
    catch bugs during development and before adding changes to the code repository.
    In fact, I recommend that you run code checks with these tools against your codebase
    frequently to prevent bugs from appearing in your services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a nonexhaustive list of Python packages that I recommend integrating
    into any project you start:'
  prefs: []
  type: TYPE_NORMAL
- en: Linters
  prefs: []
  type: TYPE_NORMAL
- en: 'These tools analyze source code to flag programming errors, stylistic errors,
    and unused code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Autoflake*: Removes unused imports and variables from code to improve readability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Flake8*: Checks against Python enhancement proposals (PEPs) and code styles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatters
  prefs: []
  type: TYPE_NORMAL
- en: 'These enable you to better see what you have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '*isort*: Sorts imports in Python modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Black*: Formats Python code for readability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ruff*: Rust-based linter and formatter that is extremely fast and can be used
    as a replacement for other tools such as `isort`, `black`, `flake8`, and possibly
    `bandit`^([12](ch02.html#id621))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loggers
  prefs: []
  type: TYPE_NORMAL
- en: 'Used in parts of the code that gets complex to debug and monitor your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Loguru*: Replacing Python’s built-in logger module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanners
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want confidence that you did not commit insecure code or passwords by
    chance:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bandit*: Vulnerability scanning of your Python codebase with checking against
    common security issues such as hard-coded secrets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Safety*: Python dependency vulnerability scanner to detect packages with known
    vulnerabilities or malicious packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type checkers
  prefs: []
  type: TYPE_NORMAL
- en: 'To catch those bugs that normal linters do not catch. Also, great if you want
    confidence that changes in your schemas did not break your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mypy*: A powerful static type checker that can help catch a lot of bugs in
    your code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pylance*: A type checker that ships with Microsoft’s Python extension for
    VS Code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of your development environment, it’s also worthwhile to use version
    control systems like Git to track codebase changes, manage different versions
    of your project, and manage code contributions from other developers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When using Git, you can also add *.gitignore* files to help you manage files
    and directories that you want excluded from version control tracking.
  prefs: []
  type: TYPE_NORMAL
- en: Integrated development environments (IDEs) such as VS Code or JetBrains Pycharm
    provide plug-ins for running these tools as you type or save your work. They often
    require some configuration, but once done, you will get auto-formatting and linting
    set up and ready before you begin. In any case, I recommend having a script or
    pre-commit hooks that lints, checks, and formats your code before you commit to
    your codebase or deploy it to production.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I’ve prepared a [FastAPI blank template](https://oreil.ly/j8lF7) that includes
    integrations with common tools that you can use as a foundation for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: These are fundamentals of Python programming and software engineering. They
    will become crucial when you start working with AI models that can produce probabilistic
    outputs as well as external services and databases that can change schemas at
    any time. Maintaining an AI application that changes schemas and prompts constantly
    without the aforementioned tools can definitively become a headache quite fast.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the FastAPI framework, including its capabilities
    and drawbacks compared to other frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to set up your own FastAPI project from scratch, alongside
    a set of tools you can use to improve your development experience.
  prefs: []
  type: TYPE_NORMAL
- en: Then you were introduced to several project structures you can adopt when building
    your own FastAPI service. As part of this, you learned more about the onion/layered
    software design pattern to help manage project complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered tools you can use to manage your Python environments and
    help maintain your FastAPI codebase as it grows in complexity.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be comfortable starting your own FastAPI projects and managing
    the project complexity as it evolves over time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to implement your own GenAI features
    in FastAPI for generating text, image, audio, and video. You will understand the
    inner workings of each model and the role of FastAPI lifecycle system in model
    serving, while leveraging NVIDIA GPUs for inference tasks. Finally, you will be
    introduced to the FastAPI background tasks system to offload long-running inference
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.html#id507-marker)) Large parts of Pydantic v2’s data validation
    logic have been rewritten in Rust for significant performance improvements.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.html#id511-marker)) The `fastapi dev` command searches your project
    directories for a FastAPI `app` object. If you’re having issues starting your
    FastAPI server, consult its documentation using `fastapi dev --help`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.html#id527-marker)) To perform model inference
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.html#id530-marker)) Coming from the Starlette framework
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch02.html#id554-marker)) FastAPI’s new lifespan events replace the deprecated
    startup/shutdown events in older versions.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch02.html#id561-marker)) An external dependency
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch02.html#id589-marker)) As is clear by their number of monthly downloads
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch02.html#id601-marker)) FastAPI relies on `AnyIO` (an asynchronous networking
    and concurrency library) to handle concurrency. `AnyIO` creates up to 40 threads
    by default on a dynamic internal thread pool and removes those that aren’t used
    for a while.
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch02.html#id602-marker)) Unless you run the GPU operations in another
    process (via multiprocessing) and await the operations
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch02.html#id607-marker)) However, according to [PEP 703](https://oreil.ly/_bRzj),
    GIL will be made optional in CPython soon.
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch02.html#id618-marker)) Refer to [Hypermodern’s GitHub repository](https://oreil.ly/6YWRN)
    for tooling examples.
  prefs: []
  type: TYPE_NORMAL
- en: ^([12](ch02.html#id621-marker)) You can use `ruff` for faster checks in CI/CD
    pipelines, unless your development environment or CI/CD pipeline is tightly integrated
    with the other tools.
  prefs: []
  type: TYPE_NORMAL
