- en: '4 APIs: The piping between our components'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An introduction to the FastAPI framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting APIs using the OpenAPI standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing our APIs using Postman and Locust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API management with WSO2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this sprint, we work on another research spike where we explore designing
    and testing application program interfaces (APIs). An API is simply a way to interact
    with a software component. Regardless of whether we are dealing with microservices
    and distributed systems or using packages from `npm`/`pip`, we utilize APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 API-driven design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, when we mention APIs in this book, we are talking about the REST
    (Representational State Transfer) API standard. However, there are other standards
    as well, such as GraphQL and the older SOAP (Simple Object Access Protocol). We
    may also come across message queuing, such as IBM Websphere MQ and RabbitMQ. Table
    4.1 shows some pros and cons of the more common approaches to implementing APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.1 Pros and cons of different APIs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '|  | REST | SOAP | GraphQL |'
  prefs: []
  type: TYPE_TB
- en: '| Pros | Simple; builds on standard HTTP methodsMultiple data formats can be
    supported, although JSON is the most common. | Relies on XML-based messagingEnterprise-level
    security | EfficientSingle endpointStrongly typed |'
  prefs: []
  type: TYPE_TB
- en: '| Cons | Versioning and breaking changes can be complex to manage.The number
    of endpoints may become inconvenient. | Complex to implementWordy XML-based messages
    | Steeper learning curve |'
  prefs: []
  type: TYPE_TB
- en: APIs act as a contract parties agree to abide by. The consumer of the API agrees
    to abide by any terms of use and licensing agreements and follow any documentation
    and standards established by the provider. In turn, the API provider provides
    a stable and scalable endpoint to access. Subscriptions to APIs also provide tools
    to make costs, usage, and a Service Level Agreement (SLA) transparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the adoption of distributed computing, many developers and architects
    have become interested in API-driven design. Often, we can expect our software
    to be deployed in the cloud or in a containerized environment. In these cases,
    we want to make sure we consider APIs. As with most design objectives, we want
    to keep some of the following things in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Clear use case**s*—An API should not serve as a Swiss Army knife that can
    deal with customers, accounts, and transactions. Instead, the design should be
    kept simple, straightforward, and consistent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Versionin**g*—Anticipate versioning and having to deprecate older API versions.
    Having to maintain multiple versions of an API can lead to increased technical
    debt with each change. Tools such as WSO2 API Manager and the Anypoint Platform
    by Mulesoft can help with versioning, governance, and many other tasks regarding
    APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Documentatio**n*—Comprehensive up-to-date documentation ensures easy consumption
    of our API. Standards such as OpenAPI allow our APIs to produce documentation
    that can be made available online with tools such as Swagger and Redoc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performance and scalin**g*—Our APIs should be able to scale to larger datasets,
    which means that we may need to introduce paging for very large datasets. We also
    need to determine acceptable wait times for API requests and how to handle longer-running
    requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Security and validatio**n*—Remember that a UI that validates user input is
    only half the battle. We need to ensure that the server is validating input, as
    well to prevent hackers and bad actors from exploiting our APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Monitoring and analytic**s*—Ensuring our APIs are functioning when accessed
    by end-users and have sufficient capacity can only be done with appropriate monitoring
    and logging. We may want to consider OpenTelemetry and tools such as Prometheus
    and Grafana to support the observability and monitoring of our APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other considerations as well, and APIs is a topic whole books have
    been written about. At this point, we just want to provide you with enough knowledge
    to make you more proficient in your software development role. If you are interested
    in additional information on RESTful APIs, visit [https://restfulapi.net/](https://restfulapi.net/).
    If you are looking for a deeper understanding of APIs and additional hands-on
    exercise, *The Design of Web APIs* (2019, Manning) by Arnaud Lauret is an excellent
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Our APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before developing the endpoints for our APIs, we think about the tasks we need
    to perform. At this point, we won’t be dealing with many complicated tasks, but
    only upload files, view files, and view records. Table 4.2 shows what our APIs
    may look like. Note that `:fileId` and `:recordId` are placeholders for identifiers
    that will be returned by other queries.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.2 API overview
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| HTTP method | Uniform resource identifier | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/files` | Uploads a file to the system |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/files` | Returns a list of uploaded files |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/files/:fileId` | Returns details on a specific file |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/files/:fileId/records` | Returns records for a specific file |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/files/:fileId/records/:recordId` | Returns details for a specific
    record |'
  prefs: []
  type: TYPE_TB
- en: While the table provides a good overview of our APIs, it may be helpful to think
    in terms of the flow of these APIs and how to obtain these identifiers. Figure
    4.1 shows the interaction between a user and the API.
  prefs: []
  type: TYPE_NORMAL
- en: PlantUML
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: PlantUML ([https://plantuml.com/](https://plantuml.com/)) is a fantastic tool
    for creating many kinds of UML diagrams such as sequence, use case, state diagrams,
    and more, as well as other diagrams for UI mockups, Gantt diagrams, and WBS diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: PlantUML is a great tool to use for many of these diagrams because it is a text-based
    interface. We can produce diagrams just by entering text into an editor! That
    means they are easy to update, easy to store in version control, and can be compared
    against previous versions. There are plugins available for our IDE as well, and
    we often use this tool from within VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, we use diagrams produced with PlantUML.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer program  Description automatically generated](../Images/CH04_F01_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1  Sequence diagram produced by PlantUML
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Hopefully, you can better understand now how a user may employ these initial
    APIs. These APIs should provide us with a good starting point for the project
    as they meet the requirements regarding uploading and viewing data. We can expand
    on these APIs by including query parameters to help retrieve specific data. For
    example, we may want to select files by date/time or select all batch header records
    from a specific file.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Building our APIs with FastAPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, we built a simple health check API using FastAPI, but now we will
    examine FastAPI in more depth and start building our APIs to deal with ACH processing.
    Let’s take a look at building of our `GET` APIs first as they should be relatively
    simple to provide stubs for. In other words, we do not need to have a database
    yet. We can simply return a hardcoded value for now to make sure everything is
    working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: While this approach will give you some basic understanding of how FastAPI works,
    it does not mean that we won’t worry about topics such as pagination and asynchronous
    processing, which are required in a full-fledged production system to have a functional
    API. For now, keep in mind that returning large results such as thousands of ACH
    records not only takes time (resulting in the user waiting for the data), but
    presenting data on a UI becomes difficult. That is where the concept of allowing
    paging becomes useful. While UI components can do this with a large dataset, it
    will also become necessary to allow the API to handle requesting portions of the
    data. Likewise, uploading large ACH files may take time to process, and the user
    will be unsure whether the process was successful; furthermore, chances are the
    request will timeout from the user side. Using asynchronous processing, where
    a response is sent to let the user know the file was successfully uploaded and
    where further processing is done to load the file, becomes paramount. We will
    touch on this again in chapter 12.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we start with a simple project that has the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We make sure to install the following requirements for our IDE, which should
    be maintained in a requirements.txt like when using Docker. However, if we have
    simply dived in and started installing Python packages, then IDEs such as JetBrains
    Pycharm allow us to create a requirements.txt file based on the requirements for
    our project. In this sprint, we focus on gaining experience with APIs and FastAPI,
    so installing packages into the IDE works well for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pip` `install` `fastapi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pip` `install` `pytest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pip` `install` `httpx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We keep the routers in a separate folder, which makes it easier to manage our
    application as it grows. We could also refer to the YAGNI principle and keep things
    simple by not using a router yet, but for time and space constraints, we are going
    to jump ahead slightly. The routers/files.py holds the API endpoints we will build
    in the upcoming sections. For now, we only focus on the basics, as shown in the
    following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.1  Basic FastAPI router
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Imports APIRouter from fastapi, needed to define URIs for the application'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Creates a router that will be used to define specific URIs'
  prefs: []
  type: TYPE_NORMAL
- en: We then have the main.py that will pull in the router. The next listing shows
    how the router is incorporated into the application.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.2  FastAPI entry point
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Imports the fastapi class needed to create the application and our previously
    defined routes'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines the application and assigns it to the app'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Includes our routes in the application'
  prefs: []
  type: TYPE_NORMAL
- en: With this basic structure, we can now look at adding some routes!
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.1 Retrieving files with GET /files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our first route should return a list of files (and eventually some information
    from the file header record). For now, we are going to hardcode a response. Because
    we have already defined the router, we just need to add the following code.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.3  Our first API route
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '#1 A decorator that defines the route /files/'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 An asynchronous function that returns a hardcoded response for testing'
  prefs: []
  type: TYPE_NORMAL
- en: Here we defined the route with `@router.get("/files")` and an asynchronous function
    called `read_files` that returns a hardcoded JSON array of files.
  prefs: []
  type: TYPE_NORMAL
- en: To check whether this code works, let’s write a `pytest`, as shown in the following
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.4  Testing our first endpoint
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Necessary imports for our test'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines the TestClient'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Defines a test to validate the /files endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Makes a request to the /files endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Asserts the response code is 200 and that the response is as expected'
  prefs: []
  type: TYPE_NORMAL
- en: Here we import `TestClient` and our app. Next, we define a client we can use
    to make requests. By calling the `get("/files"),` we make a `GET` request to the
    URL `/files`, and that should be a valid endpoint. We assert that we received
    the HTTP status of `200`. Then we have our hardcoded JSON string. This should
    match whatever we were returning from the endpoint in main.py. Even if running
    this test worked flawlessly, we still might have doubts whether it is running
    or validating our data properly. This can sometimes be a common concern when we
    first start using unit tests. We can play around with changing the status code
    we are checking (make it a value other than `200`), the JSON string, the endpoint
    from `"files"`, or the request type from `get`. Changing those values should cause
    the test to fail and verify that the test is validating our logic.
  prefs: []
  type: TYPE_NORMAL
- en: Types of tests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Being able to run unit tests can be of great benefit to our development cycle.
    Unit tests give us a starting point to execute the code and go through the entire
    process—from start to finish. But what type of test is this: Is it a unit test,
    integration test, or something else?'
  prefs: []
  type: TYPE_NORMAL
- en: We hope that you agree with the statement that developers should be testing
    their code. Different systems, conditions, and code bases can make testing difficult,
    but they should be released without some sort of testing on our end only in extremely
    rare circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, developers will be primarily concerned with *unit tests*. The
    following figure shows that unit testing makes up the base of the testing pyramid,
    and this is where we will spend a lot of time creating tests, especially if we
    are following a test-driven development approach.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH04_UN01_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: A typical testing pyramid
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Component testing* may be where the previous test fits. It typically isolates
    a component such as an API so that we can evaluate it in isolation, which may
    help us catch more of the edge cases with malformed requests or other exception
    conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Integration tests* typically test multiple components and involve more dependencies
    than unit or component testing. As such, they are primarily concerned with ensuring
    the components can work together.'
  prefs: []
  type: TYPE_NORMAL
- en: '*UI testing* is the next layer. It shouldn’t be surprising that validating
    the UI using automated tools to crawl our UI validating functionality is similar
    to a user working through various tasks within the application.'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the pyramid, we have *manual and exploratory testing*. This is
    where we (or the QA team) are trying to find ways to break the software or look
    for inconsistencies in the interface and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We have just briefly touched on a few of the major testing categories here.
    There are additional types of testing and other ways to break it down, which we
    will cover later.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing to note is that the tests become less isolated, slower, and
    more fragile as we move up the pyramid. We use the term “fragile” to indicate
    that the test gets harder to automate and is more likely to break because of its
    continually changing nature.
  prefs: []
  type: TYPE_NORMAL
- en: The test category is important only when it comes to the amount of setup and
    time it may take to get the test to work. Tests near the bottom of the pyramid
    are usually isolated and run quickly. So, at the moment, it is easy to run this
    test as a unit test because the API is returning a hardcoded value. Once we are
    further along and need to retrieve data from the database or other APIs, and components
    start coming into play, this test may not be appropriate to run as part of our
    development test suite but rather as part of a continuous integration and delivery
    (CI/CD) pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: While we believe it is useful to have these tests function as unit tests, the
    reality is we may want to work this as a BDD-style test since they could be considered
    higher-level tests.
  prefs: []
  type: TYPE_NORMAL
- en: After ensuring that `pytest-bdd` is installed (`pip` `install` `pytest-bdd`),
    we create a `features` folder and a `step_defs` folder underneath our tests directory.
    Our folder structure for the tests folder should now look something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `files.feature` will store our scenarios so we can work with the `/files`
    endpoint. Remember that we are defining the feature and various scenarios in this
    file using a `Given/When/Then` format. The following listing is a simple example
    of ensuring the status code.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.5  Feature file for our BDD test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next, to power the feature file, we create corresponding step definitions in
    our test_files_feature.py.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.6  Step definitions for our BDD test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Imports what is needed for testing'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Loads the feature we defined in listing 4.5'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Creates a fixture to store responses from the API; the hash will be empty.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Decorates the function with “when” to handle the condition from our feature
    file. Note that the endpoint is pulled from the feature file and will be /files.'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 At the moment, we are only handling GET requests and will raise an exception
    for anything else. We will revist this line to add more functionality as needed.
    Notice how the response from the API is stored in our api_response fixture.'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Decorates the function with “then” to handle the “then” phrase from our
    feature file. Note that the status_code which we specified in the feature file
    is substituted for status_code.'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Checks whether the status code was what we expected, which the feature file
    specified should be 200'
  prefs: []
  type: TYPE_NORMAL
- en: Here we loaded the `files.feature` and defined functions to handle the `when`
    and `then` of our feature file. In addition, we have a fixture to store the API
    response for use between the calls. Notice, that although we coded the `when`
    to accept multiple types of HTTP requests, we only support a `GET` request at
    this point. As we create a more robust API that incorporates `POST`, `PUT`, and
    `DELETE` requests, we will need to expand it, or we will receive a `NotImplementedError`.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we may want to experiment with the scenario of changing the `GET` to
    another request just to see the `NotImplementedError`, and then change the status
    code or endpoint to get a feeling for different scenarios we may run into when
    coding.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.2 Adding a file with POST /files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now expand our example with a `POST` request to the same `/files` endpoint.
    This approach could potentially be used to upload our ACH file. Since we have
    an existing endpoint and tests established, let’s look at how we might work on
    this task from a more behavior-driven development approach. When working with
    a `POST` request we usually see a `201` `status` code, which means “created.”
    Since we are uploading a file and expecting it to be stored on the server, a `201`
    `CREATED` response should work for us. Thus, we can update our feature file with
    the scenario shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.7  BDD test for our `POST` request
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We are reusing the same feature file here, so we do not need to adjust any
    of the “when” or “then” decorators.'
  prefs: []
  type: TYPE_NORMAL
- en: When we run this test, we should first receive the `NotImplementedError` since
    we have not handled our client making a `POST` request, which we address now with
    the following code.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.8  Updating our steps to support the `POST` request
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Handling of the previous request remains the same.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 We now add a way to handle POST requests.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Continues to alert developers when they try to do something we have not
    yet coded for'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are making a `POST` request, we should see an error returned from
    our server because we have not actually handled a `POST` request. Note that in
    the previous code, we have a hardcoded post value being used for the request.
    Eventually, we will update the test to make this dynamic, but for now, we just
    want to get the basic setup. Running our test again results in the test failing
    because we receive a `405` `METHOD` `NOT ALLOWED` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This makes perfect sense because we have not actually coded the server to handle
    our `POST` request. Let’s jump over to the `app/routers/files.py` and implement
    it (feel free to give it a shot before moving on).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.9  Defining our `POST` endpoint
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Updates the import to include the Request object'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Previous endpoint implementation'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Creates a function decorated with the POST verb and the URI, which is going
    to return a hardcoded value for now'
  prefs: []
  type: TYPE_NORMAL
- en: Rerunning the test still fails, but this time because we are returning a `200`
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is technically fine since we have not created anything. However, let’s
    look at how we can update the status code because we will be creating data in
    the future. We update our files.py to include an import of status and update the
    `@router.post` as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.10  Supporting the `201` `status`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We import that status object from fastapi.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Previous code'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 We update the decorator to specify status_code along with a 20 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `status_code` will return the `201` for all cases, and we can now
    rerun our test and see that it passes. Note that setting the status code this
    way will cause this endpoint to always return a `201`. Later, as we expand our
    APIs, we will explore other ways of setting that status code so that it allows
    us to have finer control over them. This finer control will allow us to specify
    additional status codes when errors are encountered in our APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.3 Finishing the rest of the APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we created two APIs to support getting a hardcoded
    list of files and posting a file. You should have enough knowledge of the basics
    to create the remaining endpoints and unit tests on your own. Take a few minutes
    to create some unit tests for the remaining endpoints and then code up the remaining
    APIs to get those tests to pass.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 Adding our API to Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fantastic! Now that we have built our endpoints, we can run these APIs in a
    Docker container. We gained a lot of experience with Docker in chapter 2, so we
    can use that here. Essentially, we just need the API container from the previous
    chapter updated with the code we did here. Let’s see how we can get this code
    up and running in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.1 Preparing the project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have tested our code and should feel comfortable deploying it. Having faith
    in our suite of tests is needed for continuous integration and delivery. If you
    are not comfortable with deploying code after it passes all your tests, ask yourself
    why. Then figure out what additional steps and safeguards you need. We may need
    additional tests to cover edge cases, load testing, better coverage, static code
    analysis, and similar. The idea of automated tests is to help improve software
    delivery time and quality.
  prefs: []
  type: TYPE_NORMAL
- en: So, we should be ready to deploy the code. However, we were previously using
    Uvicorn to run the FastAPI application. Remember that Uvicorn is ASGI (Asynchronous
    Server Gateway Interface) compliant and goes hand in hand with FastAPI. We need
    to include it in our current project for completeness’ sake. By installing it
    in our project, we will be able to generate a list of requirements for the project.
    So, ensure it is installed by using `pip` `install` `uvicorn`.
  prefs: []
  type: TYPE_NORMAL
- en: After adding that additional dependency, we want to create a list of requirements
    that will be installed on the container. Remember that we had previously tried
    to keep the size of our Docker images to a minimum; furthermore, we should never
    only assume that a required package for our project exists on the server. Some
    IDEs will provide options to generate and manage the requirements.txt (the standard
    naming convention for Python requirements). However, if our IDE does not, we can
    always generate it from the command line with `pip` `freeze` `>` `requirements.txt`.
    Once we do that, we can review the requirements to ensure we have our desired
    packages. For instance, we may want to ensure that `uvicorn` and `fastapi` are
    present. Note that we may see additional requirements because of other dependencies
    we have installed.
  prefs: []
  type: TYPE_NORMAL
- en: With the requirements.txt and application folder in hand, we should have everything
    we need to run this in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.2 Docker setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using our previous Docker experience (we could just copy a previous setup we
    have or start from scratch), we end up with a folder structure similar to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'where the app folder will contain our application code. At the moment, we only
    need a few source files: main.py, files.py, and the associated __init__.py. Although
    it is quite possible there may be additional files present specific to the IDE,
    there is no need to copy those over.'
  prefs: []
  type: TYPE_NORMAL
- en: The Dockerfile is where all the heavy lifting comes into play, but since our
    structure is the same, we do not need to change anything.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.11  Our Dockerfile
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Uses the alpine version of our Python image, so the size of the image is
    reduced'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Ensures that we set the working directory for the container'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Copies the requirements to the image'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Updates the image and adds our additional dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Updates pip and installs the requirements'
  prefs: []
  type: TYPE_NORMAL
- en: '#6'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Copies the application code over to the image'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Starts uvicorn using our application and binding it to port 8000'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want the docker-compose.yml file to manage the building of the service
    for us. We will only have a single service at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once these are in place, we should be able to run the usual `docker-compose`
    `build` and `docker-compose up` commands to start our container. After navigating
    our browser over to http://localhost:8000/files/, we should see the hardcoded
    value returned. In our case, it is `[{"file":"File_1"},{"file":"File_2"}]`.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 Documenting our API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Great! We are moving right along. While most of our API is hardcoded, we will
    continue to refine it as we move forward. However, the hardcoded values are only
    a part of what makes our API unusable. Our main problem is that nobody knows about
    it, and if they knew about it, how would they use it? We need documentation, and
    OpenAPI ([https://www.openapis.org/](https://www.openapis.org/)) comes to our
    rescue. This is a standard that allows us to create interactive documentation,
    and others to discover how the API works and how it generates client code and
    server code, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: Remember API-driven design from the beginning of the chapter? Well, it is possible
    to give an OpenAPI specification to generate not only client code that would consume
    that API, but also the beginnings of the server-side code that will process those
    requests. With our Docker container up and running, we should have support out
    of the box for two flavors of documentation based on the OpenAPI specification.
    We will cover both documentation frameworks in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.1 Swagger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swagger is a set of tools for implementing the OpenAPI definition, but for historical
    reasons, many people may still refer to the OpenAPI definition as a Swagger specification,
    Swagger definition, or just Swagger. One of the most useful tools that you will
    likely find yourself using is Swagger Editor ([https://editor.swagger.io/](https://editor.swagger.io/)),
    which provides a side-by-side view of the OpenAPI definition and the resulting
    output. We can browse the Swagger documentation generated by FastAPI by navigating
    over to http://localhost:8000/docs. From there, we can view the documentation
    and experiment with the API. In this case, though, we want to click the link that
    should take us to http://localhost:8000/openapi.json and display the OpenAPI JSON.
    We can save or just copy and paste it into the online Swagger Editor. Figure 4.2
    is a sample screenshot of what we see.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH04_F02_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2  Online Swagger Editor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can play around with editing the API to gain a better understanding. Note
    that the online editor will prompt us to convert the JSON to YAML. We do not have
    to do this, but it does make it a little easier to edit in place.
  prefs: []
  type: TYPE_NORMAL
- en: The FastAPI framework supports several ways to help customize this documentation
    further, and we will be looking at that later on.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.2 Redoc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FastAPI also supports Redoc, a free and open source tool for creating documentation.
    It provides a responsive three-panel view that has become popular, especially
    when working with larger APIs. Again, FastAPI provides this documentation out
    of the box, and we can see it by going to http://localhost:8000/redoc. Figure
    4.3 shows our sample API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH04_F03_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3  FastAPI documentation with Redoc
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Stripe, a popular payment service uses a similar three-panel view for their
    APIs. However, they created a tool called Markdoc ([https://markdoc.dev/](https://markdoc.dev/))
    that helps generate their documentation. There are more tools for handling API
    documentation and documentation in general. Futuristic FinTech likely already
    provides multiple tools for this purpose, so we want to follow our company’s current
    standards and suggest new tools as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.3 What is so great about API documentation?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Documentation is one of those things that can be a struggle to get right, which
    is why the ability of FastAPI to provide us with OpenAPI documentation is so fantastic.
    Why? Because we can address one of the main documentation pain points, which is
    that it becomes stale quickly. With FastAPI, we can decorate our functions so
    that they generate the documentation, meaning we are less likely to be out of
    sync between what the documentation shows and what the code is doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is not all though. We really only touched on the basics of what is available.
    In addition to being able to interactively see the APIs and try them out, here
    are some of the other cool features available:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing contact information in the form of URL or email addresses that end
    users can use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Licensing information about your APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointing to different servers (e.g., a test server, sandbox, or production)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing examples of requests/responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating server-side code to handle requests to the APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating client-side code to interact with the APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those are just some interesting features of designing APIs that conform to the
    OpenAPI specification. To learn more, check out *Designing APIs with Swagger and
    OpenAPI* (2022, Manning) by Joshua S. Ponelat and Lukas L. Rosenstock.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Managing our APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, our API is small, consisting of a single `POST` and four `GET`
    statements. As our API grows, we need to have a strategy in place to manage it.
    This is best determined early as once APIs are in production and used by clients,
    it becomes more difficult to get a handle on the situation. Earlier, we mentioned
    the challenges of managing APIs such as versioning, documentation, monitoring,
    and so forth. We introduce the use of API management software so that you have
    some knowledge of its capabilities. We use API management as an umbrella term
    to cover the components that are found in the tool.
  prefs: []
  type: TYPE_NORMAL
- en: We will incorporate an API Manager by WSO2 ([https://wso2.com/](https://wso2.com/))
    into our solution just to highlight some of the benefits of using an API manager.
    There are many API management solutions, but we have worked directly with WSO2
    and Mulesoft Anypoint ([https://mng.bz/4a2V](https://mng.bz/4a2V)) in the FinTech
    industry.
  prefs: []
  type: TYPE_NORMAL
- en: The WSO2 solution was easy to integrate into our solution. In addition, the
    documentation and tutorials for WSO2 are highly informative. As mentioned before,
    the use of Docker makes switching out components easy. Feel free to work on integrating
    other API managers into your solution that may better match your environment.
    The underlying mechanics and benefits from working with an API manager should
    be the same across the board.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.1 Benefits of API management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: API managers can provide a more centralized approach to managing your APIs.
    If your business has multiple applications, they are likely to run on different
    servers, require different authentication, and expose multiple points to the outside
    world from a networking perspective. API managers provide a way to centralize
    your API management. They offer features that help monetize APIs, protect against
    potential attacks with rate limiting (which can also be used for monetization
    by supplying different tiers), and provide authentication/authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of managing APIs in larger corporations is providing a central
    place for our users to access. If we have distinct services and business units
    in our company, they more than likely have different servers handling their APIs,
    yet want to provide a single experience to their users. We can have all the APIs
    sent to a single endpoint, and then the API manager can direct the request to
    the appropriate server in your network.
  prefs: []
  type: TYPE_NORMAL
- en: Once our requests are flowing through a centralized location, we can provide
    additional benefits to our users. One of them is a common interface to view and
    manage APIs as an end-user. If you have experience with APIs such as Google APIs,
    you should be aware that they offer a console to subscribe to various APIs. Sometimes,
    as companies grow and acquire other companies or merge, multiple products can
    be listed under the same company but provide a disjointed experience. By using
    an API manager, customers can view all your API offerings in one location.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to a better user experience, API managers offer increased analytics
    for our APIs. We can find out the number of calls, which API versions are in use,
    and a plethora of other insights. These analytics can lead to additional benefits
    such as rate limiting, load balancing, and monetization. Many APIs offer a pay-as-we-play
    model, where we are charged by API usage. API managers help facilitate that monetization
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, lifecycle management is another benefit of using a third-party tool
    such as WSO2\. Having a tool that helps enforce good lifecycle management practices
    provides a better experience for your customers and developers. We can see the
    distinct phases of an API and move APIs between different states. As shown in
    figure 4.4, we have an API that is currently in a published state, with options
    to bring it back to a created or deprecated state.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.2 Adding WSO2 API manager to our project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we add WSO2 to our Docker setup, create a new folder named wso2, and
    place the following Dockerfile there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There is not much to our Dockerfile, but for consistency, we are sticking with
    the same layout as for previous setups. The real work happens in our docker-compose.yml
    file where we added the WSO2 service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`port` `9443` is the management console where we will be doing most of our
    work, and the other ports (8243/8280) are the default ports that we ensure are
    exposed for their respective request types. Once we complete the usual `docker-compose`
    `build` and `docker-compose` `up` commands, we should be able to log in with the
    default username and password of `admin/admin`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH04_F04_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4  Lifecycle management by WSO2
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 4.6.3 OpenAPI Version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One problem that we encountered while defining our API to WSO2 was `OpenAPI`
    `content` `validation` `failed!` We loaded our OpenAPI specification into the
    online Swagger Editor and received the error `Structural` `error` `at` `openapi`
    `should` `match pattern "^3\.0\.\d(-.+)?$"` `pattern:` `^3\.0\.\d(-.+)?$`.
  prefs: []
  type: TYPE_NORMAL
- en: The online Swagger Editor provided more information, and while it may be a little
    cryptic for those having no experience with regular expressions, it pointed to
    the version number being incorrect. It seems that both our Docker image for WSO2
    and the Swagger Editor do not currently support the latest version, but our FastAPI
    container does. To be sure we are using the correct version, we can double-check
    the OpenAPI site.
  prefs: []
  type: TYPE_NORMAL
- en: 'ChatGPT was aware of the latest version, and when we posted the specification
    and asked it “Is this a valid OpenAPI specification?” we received the following
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![image](../Images/Response-Chatgpt.png)** The OpenAPI specification you
    have posted is quite extensive, and at a glance, it seems to be structured correctly
    according to the OpenAPI 3.1.0 specifications. However, there are several nuances
    and small details in such a spec that need to be right for it to be valid. Here
    are some key points and common issues to check in a detailed spec like this.'
  prefs: []
  type: TYPE_NORMAL
- en: Out of curiosity, we also tried to type in an invalid OpenAPI version (a much
    higher number), and ChatGPT said that it was not valid.
  prefs: []
  type: TYPE_NORMAL
- en: We could go about tackling this problem in a few ways. It might be that there
    is an updated version of WSO2 that supports version 3.1.0\. However, this may
    not always be practical or quick in a production environment. We could look to
    downgrade FastAPI back to a previous version, but let’s assume there is functionality
    or bug fixes we need in the current version. In this case, we can update our API
    to report back the version of 3.0.0\. We could also just manually update the generated
    document before uploading it to WSO2\. However, there is also an option from within
    WSO2 to go directly to a URL, and we want to be able to employ that.
  prefs: []
  type: TYPE_NORMAL
- en: We update our main.py, adding the following.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.12  Adjusting the OpenAPI version
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Imports the get_openapi to allow us to customize the OpenAPI documentation;
    our previous code remains the same.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines a custom method'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 These fields are required when calling get_openapi.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 This is how we updated the OpenAPI version, and we had to fix a problem
    with WSO2 API manager.'
  prefs: []
  type: TYPE_NORMAL
- en: With that in place, if we rebuild and restart Docker, we should see `"openapi":"3.0.0"`
    instead of `"openapi":"3.1.0"` when viewing the JSON. We should also see the error
    resolved when viewed in the online Swagger Editor. Now, we can move on to creating
    the API in WSO2.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.4 Create an API in WSO2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create an API by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the Create API button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under REST API, click Import Open API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the OpenAPI URL, enter http://api:8000/openapi.json. We should see that
    the URL is validated by the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter a name (this is what the API will be known as in WSO2):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The context is a way to distinguish the API URL in WSO2.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The version of the API.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The endpoint should be http://api:8000.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left pane, under Deploy, click Deployments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Deploy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the left pane, under Test, click Try Out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will be directed to a similar Swagger Doc screen we saw earlier.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Generate Key.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Try out your APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this API in place, the thing to notice is that we no longer make a request
    directly to our backend of http://api:8000\. Instead, we are going to make requests
    to https://localhost:8243/sample/0.0.1/files, which is the API manager, the context
    we chose, version, and our API. If we were to keep the API manager in place, we
    would stop exposing `port` `8000` in Docker so that we would force anyone interested
    in using the APIs through the single-entry point.
  prefs: []
  type: TYPE_NORMAL
- en: Note that as we currently have things set up, we won’t be saving the APIs permanently
    in the manager. So, remember that if we spend a lot of time setting up and configuring
    the APIs, anything we do is not permanent. We just wanted to set up this sandbox
    because we believe it is beneficial for you to have some experience with API management
    tools as you are likely to encounter them, especially in larger companies.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.5 Troubleshooting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with an API manager and trying an API out, the most common error
    is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `Missing` `Credentials` error is caused by not selecting Generate Key before
    testing the API. When working with APIs in a production environment, we have to
    generate keys to use with the API either through a dashboard or through another
    API. In trying out our APIs, we are simply generating a temporary token to use
    for a brief time.
  prefs: []
  type: TYPE_NORMAL
- en: Working with an API manager or through the OpenAPI documentation pages is a
    helpful way of doing some initial evaluation and exploratory testing. However,
    once we settle on the APIs that we are going to use, we will need to start using
    additional tools that are more specialized and offer more robust functionality.
    The following sections illustrate some of the additional tools that we will be
    using.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7 Testing with Postman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Postman API platform is a popular tool to assist with the API lifecycle,
    collaboration between developers and other teams, as well as with API governance.
    We have primarily used it in testing capacity, although the platform offers many
    more capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: One of our favorite features is the ability to `import`/`export` `curl` versions
    of the command. `curl` is a ubiquitous command line utility that lets us get or
    send data using a variety of protocols. Many systems administrators will ask you
    for a `curl` equivalent of your `RESTful API` call when troubleshooting network/routing
    problems, so having the ability to produce one quickly and easily can be helpful
    for your entire team.
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration between team members is also easy with Postman, and we have worked
    closely with our QA department to help develop test scripts that can be used for
    component and integration tests. Let’s look at how we can use Postman to validate
    data that is returned from our API. This is similar to what we might be doing
    with our unit tests while developing. However, the perspective is different because
    these may be run as part of a larger CI/CD pipeline or as part of QA testing process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will continue to use the http://localhost:8000/files as our example. Of
    course, we could also take on the challenge of building a Postman test using an
    API manager layer. In Postman, we can create a collection that is used to group
    various requests. Then we can create a new `GET` request that points to the http://localhost:8000/files
    and click Send. We should see a nicely formatted JSON response that we have condensed
    here: `[{"file":"File_1"},{"file":"File_2"}]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have confirmed we are successfully connecting and receiving responses
    from the endpoint, we can add a few tests as well: click the Tests tab, and you
    can add some straightforward tests to get an idea of how the syntax works. First,
    let’s test that we have a valid `200` response code using the following listing.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.13  Sample Postman test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Check if response format is json'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Check if response status is 200'
  prefs: []
  type: TYPE_NORMAL
- en: When sending our request, we should see that the Test Results tab is populated,
    and we have a passing test. We add a few more tests, as shown in the following
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.14  More Postman tests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Some of these tests are fragile—meaning they may be easily broken by the data
    or ordering—so we would expect this code to run against known data. Let’s use
    the test that looks for `File_1` to make it a little more robust. Because our
    data is in an array, we should be guaranteed when parsing that we will always
    parse them in that order, as opposed to an object where the `key`/`value` pairs
    may not always be returned in the way we see it. Still, the ordering of the JSON
    depends on factors outside of our control. We may be guaranteed that there is
    a `File_1`, but maybe it is not always returned first. How can we write a more
    robust test? What if we iterated through the array using a `for-each` loop?
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.15  Using a `for-each` loop in Postman
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now we define a variable to indicate whether we found our desired item, so no
    matter where it appears in the array, we will find it. That is a more flexible
    test, and depending on your familiarity with the language, it might be your first
    attempt, and since it works, that may be enough. However, we can clarify the test
    a bit using the `some` method.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.16  Cleaning up our test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `some` method is part of ECMAScript 5+ and is available outside
    of Postman. We have found that using Postman and these test scripts is a fantastic
    way to introduce newer QA resources to some type of automation. We just scratched
    the surface of what Postman has to offer; it is a great tool that we have seen
    used at various FinTech companies, as well as in other industries.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8 Load testing with Locust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we introduced the testing pyramid that primarily included testing types
    we would consider functional. Here, we introduce load testing, which falls into
    the nonfunctional testing category. Figure 4.5 outlines some types of testing.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH04_F05_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 Software testing categories
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We want to ensure our APIs will be responsive, see where performance bottlenecks
    might be, and determine the capacity of the system for future planning. To prepare
    for all of that, we can look to a framework called Locust. Locust lets us use
    our budding Python skills to script tests used for load testing.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily get started by telling ChatGPT to “create a sample locust test
    for the http://localhost:8000/files endpoint,” and that provides some easy-to-follow
    steps. First, we want to install Locust with `pip` `install` `locust`. Also, we
    create a locustfile.py as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.17  Simple Locust file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: From the directory with locustfile.py, run the command `locust`. This will prompt
    you to open your browser to the default location http://localhost:8089\. Here,
    we will enter the number of users, spawn rate, the host, and how long it should
    run for (we clicked the Advanced options) to get that (see figure 4.6).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH04_F06_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6  Starting a new test with Locust
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: From there, we can see the test run and get metrics around how our API is performing.
    Obviously, in this case, we are dealing with hardcoded values, so we will have
    a better opportunity later to come back and explore load testing our APIs. However,
    we can go ahead and get some experience with Locust and load testing now. Can
    we add tests for the other endpoints? If we need a reminder of what they were
    or what they should be returning, do not forget our living documentation at http://localhost:8000/docs.
    With additional tests, our code should look like the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.18  Locust test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Creates a FileUser class that inherits from HttpUser'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Sets a random wait time ranging from 1 to 2.5 seconds between requests to
    simulate a user pausing between actions'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Defines the host where the API requests will be sent'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 The task decorator defines a user-simulated action.'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Issues a GET against'
  prefs: []
  type: TYPE_NORMAL
- en: the /files URI
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can rerun Locust to see it hitting the various endpoints. Although our
    endpoints are currently hardcoded, they will return the path parameters used.
    So, to make things more interesting, let’s add some code to each of these tests
    so that the parameters are unique, and that will show us hitting more endpoints
    in the Locust dashboard. Take a few minutes to see whether you can replace the
    hardcoded `file_ids` and `record_ids` with a random number, and then rerun the
    tests. The next listing shows the sample we came up with.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.19  Locust
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Generates a random file_id in the range from 1 to 9'
  prefs: []
  type: TYPE_NORMAL
- en: 'After rerunning our tests, we can see a lot more variety in the endpoints being
    accessed. At this point, we may have noticed a problem when executing the tests
    in Locust on the dashboard. If not, take a look at the Failures tab in Locust.
    You should see a number of failures for the `POST` method on `/files` with the
    error `HTTPError(''405` `Client` `Error: Method` `Not` `Allowed` `for` `url:`
    `/files'')`. It looks like we missed something in our API code. But before checking
    it, let’s take a look at another big problem with our Locust tests—no `assert`
    statements.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to all our other tests, we want to make sure we are doing some sort
    of the `assert` statement. Let’s start by ensuring a valid response each time.
    Feel free to give that a try before reading further.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.20  Locust test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Previous code setup from listing 4. 1 9'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses the Locust task decorator to define what Locust should be executing'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Defines a get_files method that executes a GET against the /files URI and
    checks the HTTP status was 200'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Makes requests using a random file_id in the range from 1 to 9'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Makes requests using a random file_id in the range from 1 to 9 and a random
    record_id in the range from 1 to 1 9'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have some assert statements, we can see an `Unexpected` `status`
    `code:` `405` in the Exceptions tab in addition to the Failures tab. Let’s check
    out the logs for the API container and see what’s there. The logs show two interesting
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw, the `POST` is getting a `405` `Method` `Not` `Allowed`, and we also
    see a `307` `Temporary` `Redirect`. When we review our code that defines the endpoints,
    we see that there was a trailing slash for some endpoints but not for others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: All the Locust requests left the trailing slash off the requests, so let’s make
    sure we are consistent in both the server and the client. In our example, we are
    going to remove the trailing slashes from the server portion. Rebuilding our containers
    and rerunning our tests give us a more consistent experience without errors in
    the logs or failures in Locust. We do see that we still have exceptions in Locust.
    This is because we coded all our assert statements to be expecting a `200` return
    code. However, when we refer to the documentation (or by looking at the code),
    we are reminded that our `POST` request responds with a `201` not `200`. With
    that taken care of, we see our tests running normally, with review failures, exceptions,
    and the associated analytics as shown in figure 4.7.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a graph  Description automatically generated](../Images/CH04_F07_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7  View of successive Locust runs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 4.9 Improving our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have both unit and load tests, you should feel comfortable working
    within your code to make improvements. Even though the code is straightforward,
    we can still take advantage of some benefits of FastAPI. This section shows the
    benefits of versioning, using prefixes, documentation, and validation.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.1 Using a prefix and versioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that each of our endpoints in the router includes`/files`.
    While this works fine, we would also like to include a version number, as well
    as put the endpoint under an `api` endpoint in the URL. We want to end up with
    something like `/api/v1/files` as our initial standard. Using `/api` helps with
    organizing our APIs in one area. This can help with web server configuration,
    firewall rules, monitoring, and similar. The `v1` indicates the API version, and
    we can use it to support multiple API versions. Remember that once end-users start
    consuming the API, it is unwise to make breaking changes to your API that would
    force them to upgrade their applications. In these cases, you should provide the
    new API under `/v2` and eventually phase out prior versions when possible. Remember,
    the `/api/v1` is just a suggestion. You could name the endpoint anything you choose
    and use any versioning scheme based on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We refactor our code to add the additional `/api/v1` to our endpoints by using
    the `prefix` parameter available in `APIRouter`. We update our files.py:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Then, we remove the `/files` from each of our defined endpoints. Table 4.3 shows
    the differences.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.3 Effects of using a `prefix` parameter on the router
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Before | After |'
  prefs: []
  type: TYPE_TB
- en: '| `@router.get("/files")` | `@router.get("")` |'
  prefs: []
  type: TYPE_TB
- en: '| `@router.get("/files /{file_id}")` | `@router.get("/{file_id}")` |'
  prefs: []
  type: TYPE_TB
- en: '| `@router.post("/files ", status_code=status.HTTP_201_CREATED)` | `@router.post("",
    status_code= status.HTTP_201_CREATED)` |'
  prefs: []
  type: TYPE_TB
- en: '| `@router.get("/files /{file_id}/records")` | `@router.get("/{file_id}/records")`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@router.get("/files /{file_id}/records/{record_id}")` | `@router.get("/{file_id}/records/{record_id}")`
    |'
  prefs: []
  type: TYPE_TB
- en: We can see that by using the prefix, we now have a little less typing to do
    in each endpoint. We also need to rerun our unit tests to see whether things still
    work, and as we may have suspected, our tests are all failing with `404` `errors`
    because they are no longer going to the correct URL. We need to go ahead and update
    our unit tests to include the `/api/v1` and rerun them.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.2 Adding Pydantic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pydantic is a widely used data validation library that comes bundled with FastAPI.
    We will incorporate it here to move away from our hardcoded strings (although
    we will still be returning hardcoded values). By adding Pydantic, we position
    our code to be more easily expanded in the future and are able to take advantage
    of some of its features for validation and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we will look to build objects that model actual ACH files and records.
    For now, let’s take a look at how Pydantic will enhance our current APIs. Our
    first endpoint performs a `GET` on `/api/v1/files/{file_id}` where we previously
    returned a JSON string. It looks something like this (with the new prefix defined).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.21  Our previous hardcoded function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, we create an `AchFile` class that will model the hardcoded value we were
    returning in the previous listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.22  Our first `Pydantic` class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With that simple class in place, we can update the router to return an instance
    of that class.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.23  Updating our route to use our newly created `Pydantic` class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Our unit tests should still pass, so we have not broken anything. If we were
    to start this up in Docker, we would run into an error of `ModuleNotFoundError:`
    `No` `module named` `'ach'`. This is because Python does not know where to find
    our class, and there is a possibility that we even forgot to copy it over! Before
    starting, add another `COPY` statement to your Dockerfile and set the `PYTHONPATH`.
    This should get our code up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.24  Updating our Dockerfile
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now we should be able to bring down Docker, build, and bring our containers
    up again. If we take a look at the documentation, we will see an `AchFile` in
    the schema section. Let’s continue to expand on the documentation by adding a
    `Field` method to provide additional documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.25  Expanding the documentation of our `AchFile` class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Imports the Field function'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Adds parameters that will help with the OpenAPI documentation'
  prefs: []
  type: TYPE_NORMAL
- en: By adding some examples, title, and description, the schema becomes more meaningful.
    Figure 4.8 shows how the OpenAPI documentation was updated.
  prefs: []
  type: TYPE_NORMAL
- en: '![A computer screen shot of a computer code  Description automatically generated](../Images/CH04_F08_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8  Our updated `AchFile` schema
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is just the beginning of making our API user-friendly. We will expand on
    the concept as we build more APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.3 Validation with Pydantic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another benefit of Pydantic is its built-in validation capabilities. Validation
    of data entering the environment is a must in any production system (unless we
    are looking to test the resilience of our system). We should not rely on the UI
    or another system to validate data. If end-users are given free rein to enter
    any type of data in a field, they will do so, and it does not matter whether it
    makes sense. By combining Pydantic with FastAPI we can get a lot of validation
    for free where we may have once needed a lot of boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could enforce our `file_id` to be at least one character and
    contain only lowercase letters, underscores, and numbers. There are multiple approaches
    to enforcing such validations. In Pydantic, for instance, we can use a regular
    expression. By simply adding a pattern parameter to the field, we can enforce
    this constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are enforcing validation, let us jump back to `main.py` and add
    an exception handler when a validation error occurs. In this case, we will return
    a `400` `status` along with some detailed error information. We need to be careful
    that our exception messages do not leak sensitive information. In this case, it
    is a validation error triggered by missing or malformed fields. Still, this may
    be more appropriate for a development environment; in production, we may want
    to have a more robust method of translating the error into a known message to
    reduce the risk of exposing any sensitive data. Our exception handler should look
    like the following.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.26  Validation in Pydantic
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Decorator that registers a custom exception handler for ValidationError
    exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Ensures the HTTP status of 400 is returned along with error details'
  prefs: []
  type: TYPE_NORMAL
- en: From here, we can add additional unit tests that confirm our validation behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.27  Validating our exception behavior
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '#1 A test that passes validation'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Testing when we receive an exception condition. Notice the status code of
    400 and also a detailed message explaining what the pattern is.'
  prefs: []
  type: TYPE_NORMAL
- en: We add the positive case to show that we accept a lowercase `file_id`, and when
    uppercase values are used, we see the error telling us what the pattern should
    be.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we get a lot of useful information returned by default. Whether it
    is appropriate to show all this to your end-user may be another matter. API usage
    is in most cases fine to return detailed information, but we want to caution against
    revealing too much. For instance, you may notice that most sites do not tell you
    whether you have typed your username or password incorrectly. They simply say
    that one or the other is incorrect. This is a conscious design decision made to
    prevent malicious users from attempting to determine a list of valid users. Therefore,
    we sometimes return more generic information to the user and log the details in
    a system log. In this case, we are fine since it is acting as an interactive guide
    to the API.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.28  Detailed error that we receive from Pydantic
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We just touched on the basics of validation in Pydantic and FastAPI. A broad
    range of validation options in addition to regular expressions, as well as the
    ability to create custom validators, are available. We will explore this in later
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.4 Troubleshooting Pydantic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We may see a `500` `Internal` `Server` `Error` if we failed to copy over our
    updated API code. In our custom handler, we are intercepting the validation error
    thrown and returning a `400` `error` code. If we see something similar to error
    shown in the following listing, we have likely made that oversight or our handler
    is not working.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.29  Docker error in FastAPI
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: API-driven design promotes an API-first approach to development and ensures
    your software meets today’s distributed nature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the design and testing of APIs is crucial for interaction with software
    components in microservices, distributed systems, and packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST is the primary API standard discussed, but GraphQL and SOAP are other important
    standards with unique pros and cons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs act as contracts requiring adherence to usage terms and providing stable,
    scalable endpoints with SLAs for consumers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API-driven design emphasizes clear use cases, versioning, comprehensive documentation,
    and robust security and validation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective API monitoring and analytics are essential for capacity assessment,
    using tools such as OpenTelemetry, Prometheus, and Grafana.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial API tasks are simple, focusing on uploading and viewing files and records
    with a clear interaction flow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FastAPI is used for building APIs, starting with basic `GET` endpoints, and
    supporting pagination and asynchronous processing for performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests validate API endpoints during development, while additional tests
    such as BDD can assess API behavior and performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API documentation via OpenAPI standards ensures alignment between implementation
    and user understanding, offering tools such as Swagger and Redoc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API management tools such as WSO2 centralize management, provide lifecycle control,
    and facilitate API monitoring, monetization, and user experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
