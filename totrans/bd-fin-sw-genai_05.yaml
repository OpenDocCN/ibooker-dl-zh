- en: '4 APIs: The piping between our components'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 个 API：我们组件之间的管道
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: An introduction to the FastAPI framework
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastAPI 框架简介
- en: Documenting APIs using the OpenAPI standard
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OpenAPI 标准记录 API
- en: Testing our APIs using Postman and Locust
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Postman 和 Locust 测试我们的 API
- en: API management with WSO2
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 WSO2 进行 API 管理
- en: In this sprint, we work on another research spike where we explore designing
    and testing application program interfaces (APIs). An API is simply a way to interact
    with a software component. Regardless of whether we are dealing with microservices
    and distributed systems or using packages from `npm`/`pip`, we utilize APIs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个冲刺中，我们致力于另一个研究激增，其中我们探索设计和测试应用程序程序接口（API）。API 简单来说就是与软件组件交互的一种方式。无论我们是在处理微服务和分布式系统，还是使用
    `npm`/`pip` 的包，我们都利用 API。
- en: 4.1 API-driven design
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 API 驱动设计
- en: Generally, when we mention APIs in this book, we are talking about the REST
    (Representational State Transfer) API standard. However, there are other standards
    as well, such as GraphQL and the older SOAP (Simple Object Access Protocol). We
    may also come across message queuing, such as IBM Websphere MQ and RabbitMQ. Table
    4.1 shows some pros and cons of the more common approaches to implementing APIs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们在这本书中提到 API 时，我们是在谈论 REST（表示状态传输）API 标准。然而，还有其他标准，例如 GraphQL 和较老的 SOAP（简单对象访问协议）。我们可能还会遇到消息队列，如
    IBM Websphere MQ 和 RabbitMQ。表 4.1 展示了一些常见实现 API 方法的好处和坏处。
- en: Table 4.1 Pros and cons of different APIs
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.1 不同 API 的优缺点
- en: '|  | REST | SOAP | GraphQL |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|  | REST | SOAP | GraphQL |'
- en: '| Pros | Simple; builds on standard HTTP methodsMultiple data formats can be
    supported, although JSON is the most common. | Relies on XML-based messagingEnterprise-level
    security | EfficientSingle endpointStrongly typed |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 简单；基于标准 HTTP 方法支持多种数据格式，尽管 JSON 是最常用的。 | 依赖于基于 XML 的消息企业级安全 | 高效单一端点强类型
    |'
- en: '| Cons | Versioning and breaking changes can be complex to manage.The number
    of endpoints may become inconvenient. | Complex to implementWordy XML-based messages
    | Steeper learning curve |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 缺点 | 版本控制和破坏性变更可能难以管理。端点数量可能变得不便。 | 实施复杂基于 XML 的消息 | 学习曲线陡峭 |'
- en: APIs act as a contract parties agree to abide by. The consumer of the API agrees
    to abide by any terms of use and licensing agreements and follow any documentation
    and standards established by the provider. In turn, the API provider provides
    a stable and scalable endpoint to access. Subscriptions to APIs also provide tools
    to make costs, usage, and a Service Level Agreement (SLA) transparent.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: API 作为各方同意遵守的合同。API 的消费者同意遵守任何使用条款和许可协议，并遵循提供者建立的任何文档和标准。反过来，API 提供者提供了一个稳定且可扩展的端点以访问。API
    订阅还提供了工具，使成本、使用情况和服务水平协议（SLA）透明。
- en: 'With the adoption of distributed computing, many developers and architects
    have become interested in API-driven design. Often, we can expect our software
    to be deployed in the cloud or in a containerized environment. In these cases,
    we want to make sure we consider APIs. As with most design objectives, we want
    to keep some of the following things in mind:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着分布式计算的应用，许多开发者和架构师对 API 驱动的架构产生了兴趣。通常，我们可以预期我们的软件将被部署在云端或容器化环境中。在这些情况下，我们想要确保我们考虑了
    API。与大多数设计目标一样，我们想要记住以下几点：
- en: '*Clear use case**s*—An API should not serve as a Swiss Army knife that can
    deal with customers, accounts, and transactions. Instead, the design should be
    kept simple, straightforward, and consistent.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*清晰的用例**—API 不应作为瑞士军刀，能够处理客户、账户和交易。相反，设计应保持简单、直接和一致。'
- en: '*Versionin**g*—Anticipate versioning and having to deprecate older API versions.
    Having to maintain multiple versions of an API can lead to increased technical
    debt with each change. Tools such as WSO2 API Manager and the Anypoint Platform
    by Mulesoft can help with versioning, governance, and many other tasks regarding
    APIs.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*版本控制**—预测版本控制并弃用旧版 API。需要维护多个版本的 API 可能会导致每次更改都增加技术债务。WSO2 API 管理器和 Mulesoft
    的 Anypoint 平台等工具可以帮助进行版本控制、治理以及许多其他与 API 相关的任务。'
- en: '*Documentatio**n*—Comprehensive up-to-date documentation ensures easy consumption
    of our API. Standards such as OpenAPI allow our APIs to produce documentation
    that can be made available online with tools such as Swagger and Redoc.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文档**—全面的最新文档确保我们的 API 容易被消费。例如，OpenAPI 等标准允许我们的 API 生成可以通过 Swagger 和 Redoc
    等工具在线提供的文档。'
- en: '*Performance and scalin**g*—Our APIs should be able to scale to larger datasets,
    which means that we may need to introduce paging for very large datasets. We also
    need to determine acceptable wait times for API requests and how to handle longer-running
    requests.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*性能和扩展性*—我们的API应该能够扩展到更大的数据集，这意味着我们可能需要为非常大的数据集引入分页。我们还需要确定API请求的可接受等待时间以及如何处理长时间运行的请求。'
- en: '*Security and validatio**n*—Remember that a UI that validates user input is
    only half the battle. We need to ensure that the server is validating input, as
    well to prevent hackers and bad actors from exploiting our APIs.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全和验证*—记住，一个验证用户输入的UI只是战斗的一半。我们需要确保服务器也在验证输入，以防止黑客和不良行为者利用我们的API。'
- en: '*Monitoring and analytic**s*—Ensuring our APIs are functioning when accessed
    by end-users and have sufficient capacity can only be done with appropriate monitoring
    and logging. We may want to consider OpenTelemetry and tools such as Prometheus
    and Grafana to support the observability and monitoring of our APIs.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*监控和分析*—确保我们的API在用户访问时正常工作并且有足够的容量，这只能通过适当的监控和日志记录来实现。我们可能需要考虑OpenTelemetry以及Prometheus和Grafana等工具来支持我们API的可观察性和监控。'
- en: There are other considerations as well, and APIs is a topic whole books have
    been written about. At this point, we just want to provide you with enough knowledge
    to make you more proficient in your software development role. If you are interested
    in additional information on RESTful APIs, visit [https://restfulapi.net/](https://restfulapi.net/).
    If you are looking for a deeper understanding of APIs and additional hands-on
    exercise, *The Design of Web APIs* (2019, Manning) by Arnaud Lauret is an excellent
    resource.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些考虑因素，API是一个有很多书籍讨论的主题。在这个阶段，我们只想提供足够的知识，使你在软件开发角色中更加熟练。如果你对RESTful API有更多兴趣，请访问[https://restfulapi.net/](https://restfulapi.net/)。如果你想要对API有更深入的理解和更多的实践练习，Arnaud
    Lauret的《Web API设计》（2019年，Manning出版社）是一本极好的资源。
- en: 4.2 Our APIs
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 我们的API
- en: Before developing the endpoints for our APIs, we think about the tasks we need
    to perform. At this point, we won’t be dealing with many complicated tasks, but
    only upload files, view files, and view records. Table 4.2 shows what our APIs
    may look like. Note that `:fileId` and `:recordId` are placeholders for identifiers
    that will be returned by other queries.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发我们的API端点之前，我们会考虑需要执行的任务。在这个阶段，我们不会处理很多复杂任务，而只是上传文件、查看文件和查看记录。表4.2显示了我们的API可能的样子。请注意，`:fileId`和`:recordId`是其他查询将返回的标识符的占位符。
- en: Table 4.2 API overview
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.2 API概述
- en: '| HTTP method | Uniform resource identifier | Description |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| HTTP方法 | 统一资源标识符 | 描述 |'
- en: '| `POST` | `/files` | Uploads a file to the system |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/files` | 将文件上传到系统中 |'
- en: '| `GET` | `/files` | Returns a list of uploaded files |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/files` | 返回已上传文件的列表 |'
- en: '| `GET` | `/files/:fileId` | Returns details on a specific file |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/files/:fileId` | 返回特定文件的详细信息 |'
- en: '| `GET` | `/files/:fileId/records` | Returns records for a specific file |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/files/:fileId/records` | 返回特定文件的记录 |'
- en: '| `GET` | `/files/:fileId/records/:recordId` | Returns details for a specific
    record |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/files/:fileId/records/:recordId` | 返回特定记录的详细信息 |'
- en: While the table provides a good overview of our APIs, it may be helpful to think
    in terms of the flow of these APIs and how to obtain these identifiers. Figure
    4.1 shows the interaction between a user and the API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然表格提供了我们API的良好概述，但考虑这些API的流程以及如何获取这些标识符可能会有所帮助。图4.1显示了用户与API之间的交互。
- en: PlantUML
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: PlantUML
- en: PlantUML ([https://plantuml.com/](https://plantuml.com/)) is a fantastic tool
    for creating many kinds of UML diagrams such as sequence, use case, state diagrams,
    and more, as well as other diagrams for UI mockups, Gantt diagrams, and WBS diagrams.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: PlantUML ([https://plantuml.com/](https://plantuml.com/)) 是一个创建各种UML图（如序列图、用例图、状态图等）以及UI原型、甘特图和WBS图的出色工具。
- en: PlantUML is a great tool to use for many of these diagrams because it is a text-based
    interface. We can produce diagrams just by entering text into an editor! That
    means they are easy to update, easy to store in version control, and can be compared
    against previous versions. There are plugins available for our IDE as well, and
    we often use this tool from within VS Code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: PlantUML 是使用这些图的一个很好的工具，因为它是一个基于文本的界面。我们只需在编辑器中输入文本就能生成图表！这意味着它们易于更新，易于存储在版本控制中，并且可以与之前的版本进行比较。我们的IDE也有可用的插件，我们经常在VS
    Code中使用这个工具。
- en: Throughout the book, we use diagrams produced with PlantUML.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们使用PlantUML生成的图表。
- en: '![A screenshot of a computer program  Description automatically generated](../Images/CH04_F01_Kardell.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图  自动生成的描述](../Images/CH04_F01_Kardell.png)'
- en: Figure 4.1  Sequence diagram produced by PlantUML
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1  由PlantUML生成的序列图
- en: Hopefully, you can better understand now how a user may employ these initial
    APIs. These APIs should provide us with a good starting point for the project
    as they meet the requirements regarding uploading and viewing data. We can expand
    on these APIs by including query parameters to help retrieve specific data. For
    example, we may want to select files by date/time or select all batch header records
    from a specific file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在能更好地理解用户如何使用这些初始API。这些API应该为我们提供项目的良好起点，因为它们满足上传和查看数据的要求。我们可以通过包括查询参数来扩展这些API，以帮助检索特定数据。例如，我们可能想按日期/时间选择文件，或从特定文件中选择所有批次标题记录。
- en: 4.3 Building our APIs with FastAPI
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 使用FastAPI构建我们的API
- en: Previously, we built a simple health check API using FastAPI, but now we will
    examine FastAPI in more depth and start building our APIs to deal with ACH processing.
    Let’s take a look at building of our `GET` APIs first as they should be relatively
    simple to provide stubs for. In other words, we do not need to have a database
    yet. We can simply return a hardcoded value for now to make sure everything is
    working as expected.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用FastAPI构建了一个简单的健康检查API，但现在我们将更深入地研究FastAPI，并开始构建我们的API来处理ACH处理。让我们首先看看构建我们的`GET`
    API，因为它们应该相对简单，可以提供占位符。换句话说，我们目前不需要数据库。我们可以简单地返回一个硬编码的值，以确保一切按预期工作。
- en: While this approach will give you some basic understanding of how FastAPI works,
    it does not mean that we won’t worry about topics such as pagination and asynchronous
    processing, which are required in a full-fledged production system to have a functional
    API. For now, keep in mind that returning large results such as thousands of ACH
    records not only takes time (resulting in the user waiting for the data), but
    presenting data on a UI becomes difficult. That is where the concept of allowing
    paging becomes useful. While UI components can do this with a large dataset, it
    will also become necessary to allow the API to handle requesting portions of the
    data. Likewise, uploading large ACH files may take time to process, and the user
    will be unsure whether the process was successful; furthermore, chances are the
    request will timeout from the user side. Using asynchronous processing, where
    a response is sent to let the user know the file was successfully uploaded and
    where further processing is done to load the file, becomes paramount. We will
    touch on this again in chapter 12.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法会给你一些关于FastAPI如何工作的基本理解，但这并不意味着我们不会担心诸如分页和异步处理等主题，这些主题在一个完整的生产系统中是必要的，以便拥有一个功能性的API。目前，请记住，返回大量结果，如数千条ACH记录，不仅耗时（导致用户等待数据），而且在UI上呈现数据也变得困难。这就是允许分页的概念变得有用的地方。虽然UI组件可以处理大量数据集，但也将有必要允许API处理数据的一部分请求。同样，上传大量的ACH文件可能需要时间来处理，用户将不确定过程是否成功；此外，请求可能从用户端超时。使用异步处理，其中发送响应以让用户知道文件已成功上传，并且进行进一步处理以加载文件，变得至关重要。我们将在第12章再次涉及这一点。
- en: 'For now, we start with a simple project that has the following folder structure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们从以下文件夹结构的一个简单项目开始：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We make sure to install the following requirements for our IDE, which should
    be maintained in a requirements.txt like when using Docker. However, if we have
    simply dived in and started installing Python packages, then IDEs such as JetBrains
    Pycharm allow us to create a requirements.txt file based on the requirements for
    our project. In this sprint, we focus on gaining experience with APIs and FastAPI,
    so installing packages into the IDE works well for now:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保为我们的IDE安装以下要求，这些要求应像使用Docker时一样维护在requirements.txt中。然而，如果我们只是直接跳入并开始安装Python包，那么像JetBrains
    Pycharm这样的IDE允许我们根据项目需求创建一个requirements.txt文件。在这个冲刺中，我们专注于获得API和FastAPI的经验，所以现在将包安装到IDE中是可行的：
- en: '`pip` `install` `fastapi`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip` `install` `fastapi`'
- en: '`pip` `install` `pytest`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip` `install` `pytest`'
- en: '`pip` `install` `httpx`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip` `install` `httpx`'
- en: We keep the routers in a separate folder, which makes it easier to manage our
    application as it grows. We could also refer to the YAGNI principle and keep things
    simple by not using a router yet, but for time and space constraints, we are going
    to jump ahead slightly. The routers/files.py holds the API endpoints we will build
    in the upcoming sections. For now, we only focus on the basics, as shown in the
    following listing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将路由器保存在一个单独的文件夹中，这使得随着应用程序的增长更容易管理。我们也可以参考 YAGNI 原则，通过不使用路由器来保持简单，但鉴于时间和空间限制，我们将稍微提前一点。routers/files.py
    包含我们在接下来的章节中将要构建的 API 端点。现在，我们只关注以下列表所示的基本内容。
- en: Listing 4.1  Basic FastAPI router
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1  基本FastAPI路由器
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#1 Imports APIRouter from fastapi, needed to define URIs for the application'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从 fastapi 导入 APIRouter，用于定义应用程序的 URI'
- en: '#2 Creates a router that will be used to define specific URIs'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 创建一个用于定义特定 URI 的路由器'
- en: We then have the main.py that will pull in the router. The next listing shows
    how the router is incorporated into the application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有 main.py，它将引入路由器。接下来的列表显示了如何将路由器集成到应用程序中。
- en: Listing 4.2  FastAPI entry point
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2  FastAPI 入口点
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#1 Imports the fastapi class needed to create the application and our previously
    defined routes'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 导入创建应用程序和之前定义的路由所需的 fastapi 类'
- en: '#2 Defines the application and assigns it to the app'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义应用程序并将其分配给 app'
- en: '#3 Includes our routes in the application'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 在应用程序中包含我们的路由'
- en: With this basic structure, we can now look at adding some routes!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个基本结构，我们现在可以看看添加一些路由！
- en: 4.3.1 Retrieving files with GET /files
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 使用 GET /files 获取文件
- en: Our first route should return a list of files (and eventually some information
    from the file header record). For now, we are going to hardcode a response. Because
    we have already defined the router, we just need to add the following code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个路由应该返回文件列表（以及最终从文件头记录中获取的一些信息）。现在，我们将硬编码一个响应。因为我们已经定义了路由器，所以我们只需要添加以下代码。
- en: Listing 4.3  Our first API route
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3  我们的第一个 API 路由
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 A decorator that defines the route /files/'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 一个定义 /files/ 路由的装饰器'
- en: '#2 An asynchronous function that returns a hardcoded response for testing'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 一个异步函数，用于测试返回硬编码的响应'
- en: Here we defined the route with `@router.get("/files")` and an asynchronous function
    called `read_files` that returns a hardcoded JSON array of files.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `@router.get("/files")` 定义了路由，并调用了一个名为 `read_files` 的异步函数，该函数返回一个硬编码的文件
    JSON 数组。
- en: To check whether this code works, let’s write a `pytest`, as shown in the following
    listing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查这段代码是否工作，让我们编写一个 `pytest`，如下所示。
- en: Listing 4.4  Testing our first endpoint
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4  测试我们的第一个端点
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 Necessary imports for our test'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 测试所需的必要导入'
- en: '#2 Defines the TestClient'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义 TestClient'
- en: '#3 Defines a test to validate the /files endpoint'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 定义一个测试来验证 /files 端点'
- en: '#4 Makes a request to the /files endpoint'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 向 /files 端点发送请求'
- en: '#5 Asserts the response code is 200 and that the response is as expected'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 断言响应代码是 200，并且响应符合预期'
- en: Here we import `TestClient` and our app. Next, we define a client we can use
    to make requests. By calling the `get("/files"),` we make a `GET` request to the
    URL `/files`, and that should be a valid endpoint. We assert that we received
    the HTTP status of `200`. Then we have our hardcoded JSON string. This should
    match whatever we were returning from the endpoint in main.py. Even if running
    this test worked flawlessly, we still might have doubts whether it is running
    or validating our data properly. This can sometimes be a common concern when we
    first start using unit tests. We can play around with changing the status code
    we are checking (make it a value other than `200`), the JSON string, the endpoint
    from `"files"`, or the request type from `get`. Changing those values should cause
    the test to fail and verify that the test is validating our logic.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 `TestClient` 和我们的应用程序。接下来，我们定义一个客户端，我们可以用它来发送请求。通过调用 `get("/files")`，我们向
    URL `/files` 发送了一个 `GET` 请求，这应该是一个有效的端点。我们断言我们收到了 HTTP 状态码 `200`。然后我们有我们的硬编码 JSON
    字符串。这应该与我们在 main.py 的端点返回的内容相匹配。即使运行这个测试完美无缺，我们仍然可能怀疑它是否正确地运行或验证我们的数据。当我们刚开始使用单元测试时，这有时可能是一个常见的担忧。我们可以通过更改我们正在检查的状态码（使其不是
    `200` 的值）、JSON 字符串、从 `"files"` 的端点或请求类型从 `get` 来玩弄这些值。更改这些值应该导致测试失败，并验证测试是否正在验证我们的逻辑。
- en: Types of tests
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'Being able to run unit tests can be of great benefit to our development cycle.
    Unit tests give us a starting point to execute the code and go through the entire
    process—from start to finish. But what type of test is this: Is it a unit test,
    integration test, or something else?'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 能够运行单元测试对我们的开发周期有很大的好处。单元测试为我们提供了一个起点，执行代码并完成整个过程——从开始到结束。但这是什么类型的测试：这是一个单元测试、集成测试，还是其他类型的测试？
- en: We hope that you agree with the statement that developers should be testing
    their code. Different systems, conditions, and code bases can make testing difficult,
    but they should be released without some sort of testing on our end only in extremely
    rare circumstances.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您同意这样一个观点：开发者应该测试他们的代码。不同的系统、条件和代码库可能会使测试变得困难，但在极其罕见的情况下，他们才应该在没有某种测试的情况下发布。
- en: In most cases, developers will be primarily concerned with *unit tests*. The
    following figure shows that unit testing makes up the base of the testing pyramid,
    and this is where we will spend a lot of time creating tests, especially if we
    are following a test-driven development approach.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，开发者将主要关注*单元测试*。以下图显示单元测试构成了测试金字塔的基础，这是我们将在其中花费大量时间创建测试的地方，尤其是如果我们遵循测试驱动开发方法。
- en: '![](../Images/CH04_UN01_Kardell.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_UN01_Kardell.png)'
- en: A typical testing pyramid
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 典型的测试金字塔
- en: '*Component testing* may be where the previous test fits. It typically isolates
    a component such as an API so that we can evaluate it in isolation, which may
    help us catch more of the edge cases with malformed requests or other exception
    conditions.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*组件测试*可能是之前测试适合的地方。它通常将组件（如API）隔离，以便我们可以单独评估它，这有助于我们捕捉到更多异常情况，如格式不正确的请求或其他异常条件。'
- en: '*Integration tests* typically test multiple components and involve more dependencies
    than unit or component testing. As such, they are primarily concerned with ensuring
    the components can work together.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*集成测试*通常测试多个组件，比单元测试或组件测试涉及更多的依赖项。因此，它们主要关注确保组件可以协同工作。'
- en: '*UI testing* is the next layer. It shouldn’t be surprising that validating
    the UI using automated tools to crawl our UI validating functionality is similar
    to a user working through various tasks within the application.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*UI测试*是下一层。使用自动化工具爬取我们的UI验证功能来验证UI，这类似于用户在应用程序中完成各种任务，这并不令人惊讶。'
- en: At the top of the pyramid, we have *manual and exploratory testing*. This is
    where we (or the QA team) are trying to find ways to break the software or look
    for inconsistencies in the interface and behavior.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔的顶部，我们有*手动和探索性测试*。这是我们在尝试找到破坏软件或查找界面和行为不一致的方法的地方。
- en: We have just briefly touched on a few of the major testing categories here.
    There are additional types of testing and other ways to break it down, which we
    will cover later.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只是简要地提到了一些主要的测试类别。还有其他类型的测试和分解方法，我们将在稍后介绍。
- en: One final thing to note is that the tests become less isolated, slower, and
    more fragile as we move up the pyramid. We use the term “fragile” to indicate
    that the test gets harder to automate and is more likely to break because of its
    continually changing nature.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是，随着我们向上移动金字塔，测试变得越来越不独立、越来越慢、越来越脆弱。我们使用“脆弱”一词来表示测试变得越来越难以自动化，并且更有可能因为其不断变化的本性而崩溃。
- en: The test category is important only when it comes to the amount of setup and
    time it may take to get the test to work. Tests near the bottom of the pyramid
    are usually isolated and run quickly. So, at the moment, it is easy to run this
    test as a unit test because the API is returning a hardcoded value. Once we are
    further along and need to retrieve data from the database or other APIs, and components
    start coming into play, this test may not be appropriate to run as part of our
    development test suite but rather as part of a continuous integration and delivery
    (CI/CD) pipeline.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类别的重要性仅在于设置量和测试运行所需的时间。金字塔底部的测试通常比较独立且运行速度快。因此，目前，由于API返回的是硬编码的值，运行这个测试作为单元测试是很容易的。一旦我们进一步发展，需要从数据库或其他API检索数据，组件开始发挥作用，这个测试可能不适合作为我们的开发测试套件的一部分运行，而应该作为持续集成和持续交付（CI/CD）管道的一部分运行。
- en: While we believe it is useful to have these tests function as unit tests, the
    reality is we may want to work this as a BDD-style test since they could be considered
    higher-level tests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们认为这些测试作为单元测试是有用的，但现实情况是，我们可能希望以BDD风格的测试来处理这个问题，因为它们可以被认为是更高级别的测试。
- en: After ensuring that `pytest-bdd` is installed (`pip` `install` `pytest-bdd`),
    we create a `features` folder and a `step_defs` folder underneath our tests directory.
    Our folder structure for the tests folder should now look something like
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保`pytest-bdd`已安装（`pip install pytest-bdd`）后，我们在测试目录下创建一个`features`文件夹和一个`step_defs`文件夹。我们的测试文件夹的目录结构现在应该看起来像这样。
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `files.feature` will store our scenarios so we can work with the `/files`
    endpoint. Remember that we are defining the feature and various scenarios in this
    file using a `Given/When/Then` format. The following listing is a simple example
    of ensuring the status code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`files.feature`将存储我们的场景，以便我们可以处理/files端点。记住，我们在这个文件中使用`Given/When/Then`格式定义了特性和各种场景。以下列表是一个确保状态码的简单示例。'
- en: Listing 4.5  Feature file for our BDD test
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.5  BDD测试的特性文件
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, to power the feature file, we create corresponding step definitions in
    our test_files_feature.py.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了激活特性文件，我们在test_files_feature.py中创建相应的步骤定义。
- en: Listing 4.6  Step definitions for our BDD test
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6  BDD测试的步骤定义
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 Imports what is needed for testing'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 导入测试所需的模块'
- en: '#2 Loads the feature we defined in listing 4.5'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 加载我们在列表4.5中定义的特性'
- en: '#3 Creates a fixture to store responses from the API; the hash will be empty.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 创建一个固定值来存储API的响应；哈希将为空。'
- en: '#4 Decorates the function with “when” to handle the condition from our feature
    file. Note that the endpoint is pulled from the feature file and will be /files.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 使用“when”装饰器来处理特性文件中的条件。注意，端点是从特性文件中提取的，将是/files。'
- en: '#5 At the moment, we are only handling GET requests and will raise an exception
    for anything else. We will revist this line to add more functionality as needed.
    Notice how the response from the API is stored in our api_response fixture.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 目前，我们只处理GET请求，对于其他任何请求都将抛出异常。我们将重新访问此行以添加所需的功能。注意，API的响应存储在我们的api_response固定值中。'
- en: '#6 Decorates the function with “then” to handle the “then” phrase from our
    feature file. Note that the status_code which we specified in the feature file
    is substituted for status_code.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 使用“then”装饰器来处理特性文件中的“then”短语。注意，我们在特性文件中指定的状态码被替换为status_code。'
- en: '#7 Checks whether the status code was what we expected, which the feature file
    specified should be 200'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 检查状态码是否是我们预期的，即特性文件指定的应该是200'
- en: Here we loaded the `files.feature` and defined functions to handle the `when`
    and `then` of our feature file. In addition, we have a fixture to store the API
    response for use between the calls. Notice, that although we coded the `when`
    to accept multiple types of HTTP requests, we only support a `GET` request at
    this point. As we create a more robust API that incorporates `POST`, `PUT`, and
    `DELETE` requests, we will need to expand it, or we will receive a `NotImplementedError`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们加载了`files.feature`并定义了处理特性文件中的`when`和`then`的函数。此外，我们有一个固定值来存储API响应，以便在调用之间使用。注意，尽管我们编写了`when`以接受多种类型的HTTP请求，但我们目前只支持GET请求。随着我们创建一个更健壮的API，它包含`POST`、`PUT`和`DELETE`请求，我们需要扩展它，否则我们将收到`NotImplementedError`。
- en: Again, we may want to experiment with the scenario of changing the `GET` to
    another request just to see the `NotImplementedError`, and then change the status
    code or endpoint to get a feeling for different scenarios we may run into when
    coding.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可能想要尝试将`GET`请求改为其他请求的场景，只是为了看到`NotImplementedError`，然后更改状态码或端点，以了解我们可能在编码时遇到的不同场景。
- en: 4.3.2 Adding a file with POST /files
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 使用POST /files添加文件
- en: We now expand our example with a `POST` request to the same `/files` endpoint.
    This approach could potentially be used to upload our ACH file. Since we have
    an existing endpoint and tests established, let’s look at how we might work on
    this task from a more behavior-driven development approach. When working with
    a `POST` request we usually see a `201` `status` code, which means “created.”
    Since we are uploading a file and expecting it to be stored on the server, a `201`
    `CREATED` response should work for us. Thus, we can update our feature file with
    the scenario shown in the following listing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在通过向同一/files端点发送`POST`请求来扩展我们的示例。这种方法可能被用来上传我们的ACH文件。由于我们已经有了一个现有的端点和测试，让我们看看我们可能如何从更行为驱动的开发方法来处理这个任务。当处理`POST`请求时，我们通常看到`201`状态码，这意味着“已创建”。由于我们正在上传文件并期望它在服务器上存储，因此`201`
    `CREATED`响应对我们来说是合适的。因此，我们可以更新特性文件，如下列所示的场景。
- en: Listing 4.7  BDD test for our `POST` request
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.7  `POST`请求的BDD测试
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 We are reusing the same feature file here, so we do not need to adjust any
    of the “when” or “then” decorators.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们在这里重用了相同的特性文件，因此我们不需要调整任何“when”或“then”装饰器。'
- en: When we run this test, we should first receive the `NotImplementedError` since
    we have not handled our client making a `POST` request, which we address now with
    the following code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个测试时，我们首先应该收到 `NotImplementedError`，因为我们没有处理客户端发出的 `POST` 请求，我们现在用以下代码解决这个问题。
- en: Listing 4.8  Updating our steps to support the `POST` request
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.8  更新我们的步骤以支持 `POST` 请求
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '#1 Handling of the previous request remains the same.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 对之前请求的处理保持不变。'
- en: '#2 We now add a way to handle POST requests.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 现在我们添加一种处理 POST 请求的方法。'
- en: '#3 Continues to alert developers when they try to do something we have not
    yet coded for'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 当开发者尝试执行我们尚未编写的功能时，会继续提醒开发者'
- en: 'Now that we are making a `POST` request, we should see an error returned from
    our server because we have not actually handled a `POST` request. Note that in
    the previous code, we have a hardcoded post value being used for the request.
    Eventually, we will update the test to make this dynamic, but for now, we just
    want to get the basic setup. Running our test again results in the test failing
    because we receive a `405` `METHOD` `NOT ALLOWED` status:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在发送 `POST` 请求，我们应该从我们的服务器收到一个错误，因为我们实际上没有处理 `POST` 请求。请注意，在之前的代码中，我们使用了一个硬编码的
    post 值用于请求。最终，我们将更新测试以使其动态化，但就目前而言，我们只想得到基本设置。再次运行我们的测试会导致测试失败，因为我们收到了 `405` `METHOD`
    `NOT ALLOWED` 状态码：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This makes perfect sense because we have not actually coded the server to handle
    our `POST` request. Let’s jump over to the `app/routers/files.py` and implement
    it (feel free to give it a shot before moving on).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全合理，因为我们实际上并没有编写服务器代码来处理我们的 `POST` 请求。让我们跳转到 `app/routers/files.py` 并实现它（在继续之前，你可以尝试一下）。
- en: Listing 4.9  Defining our `POST` endpoint
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.9  定义我们的 `POST` 端点
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 Updates the import to include the Request object'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 更新导入以包括请求对象'
- en: '#2 Previous endpoint implementation'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 之前的端点实现'
- en: '#3 Creates a function decorated with the POST verb and the URI, which is going
    to return a hardcoded value for now'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 创建一个用 POST 动词和 URI 装饰的函数，现在将返回一个硬编码的值'
- en: Rerunning the test still fails, but this time because we are returning a `200`
    code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行测试仍然失败，但这次是因为我们返回了一个 `200` 状态码。
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is technically fine since we have not created anything. However, let’s
    look at how we can update the status code because we will be creating data in
    the future. We update our files.py to include an import of status and update the
    `@router.post` as shown in the following listing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这是可以的，因为我们没有创建任何东西。然而，让我们看看我们如何更新状态码，因为我们将在未来创建数据。我们将更新 `files.py` 以包含对
    `status` 的导入，并更新 `@router.post`，如下所示。
- en: Listing 4.10  Supporting the `201` `status`
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10  支持状态 `201`
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#1 We import that status object from fastapi.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们从 fastapi 导入那个状态对象。'
- en: '#2 Previous code'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 之前的代码'
- en: '#3 We update the decorator to specify status_code along with a 20 1 .'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 我们更新装饰器以指定状态码和 20 1 。'
- en: Setting the `status_code` will return the `201` for all cases, and we can now
    rerun our test and see that it passes. Note that setting the status code this
    way will cause this endpoint to always return a `201`. Later, as we expand our
    APIs, we will explore other ways of setting that status code so that it allows
    us to have finer control over them. This finer control will allow us to specify
    additional status codes when errors are encountered in our APIs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `status_code` 将在所有情况下返回 `201`，现在我们可以重新运行我们的测试，并看到它通过了。请注意，以这种方式设置状态码将导致此端点始终返回
    `201`。稍后，当我们扩展我们的 API 时，我们将探索其他设置状态码的方法，以便我们可以更精细地控制它们。这种更精细的控制将允许我们在 API 中遇到错误时指定额外的状态码。
- en: 4.3.3 Finishing the rest of the APIs
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 完成其余的 API
- en: In the previous section, we created two APIs to support getting a hardcoded
    list of files and posting a file. You should have enough knowledge of the basics
    to create the remaining endpoints and unit tests on your own. Take a few minutes
    to create some unit tests for the remaining endpoints and then code up the remaining
    APIs to get those tests to pass.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了两个 API 来支持获取硬编码的文件列表和上传文件。你应该有足够的关于基础知识的了解来创建剩余的端点和单元测试。花几分钟时间为剩余的端点创建一些单元测试，然后编写剩余的
    API 代码，以使这些测试通过。
- en: 4.4 Adding our API to Docker
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 将我们的 API 添加到 Docker
- en: Fantastic! Now that we have built our endpoints, we can run these APIs in a
    Docker container. We gained a lot of experience with Docker in chapter 2, so we
    can use that here. Essentially, we just need the API container from the previous
    chapter updated with the code we did here. Let’s see how we can get this code
    up and running in Docker.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们已经构建了端点，我们可以在Docker容器中运行这些API。在第2章中，我们获得了大量的Docker经验，所以我们可以在这里使用它。本质上，我们只需要将上一章中的API容器更新为我们这里所做的代码。让我们看看如何将这段代码在Docker中运行起来。
- en: 4.4.1 Preparing the project
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 准备项目
- en: We have tested our code and should feel comfortable deploying it. Having faith
    in our suite of tests is needed for continuous integration and delivery. If you
    are not comfortable with deploying code after it passes all your tests, ask yourself
    why. Then figure out what additional steps and safeguards you need. We may need
    additional tests to cover edge cases, load testing, better coverage, static code
    analysis, and similar. The idea of automated tests is to help improve software
    delivery time and quality.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经测试了我们的代码，应该对部署感到舒适。对测试套件的信心是持续集成和交付所必需的。如果你在所有测试通过后对部署代码感到不舒服，问问自己为什么。然后找出你需要采取的额外步骤和安全措施。我们可能需要额外的测试来覆盖边缘情况、负载测试、更好的覆盖率、静态代码分析等。自动化测试的想法是帮助提高软件交付时间和质量。
- en: So, we should be ready to deploy the code. However, we were previously using
    Uvicorn to run the FastAPI application. Remember that Uvicorn is ASGI (Asynchronous
    Server Gateway Interface) compliant and goes hand in hand with FastAPI. We need
    to include it in our current project for completeness’ sake. By installing it
    in our project, we will be able to generate a list of requirements for the project.
    So, ensure it is installed by using `pip` `install` `uvicorn`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该准备好部署代码。然而，我们之前使用Uvicorn来运行FastAPI应用程序。记住，Uvicorn是ASGI（异步服务器网关接口）兼容的，并且与FastAPI相辅相成。为了完整性，我们需要在我们的当前项目中包含它。通过在我们的项目中安装它，我们将能够生成项目的要求列表。所以，确保使用`pip
    install uvicorn`来安装它。
- en: After adding that additional dependency, we want to create a list of requirements
    that will be installed on the container. Remember that we had previously tried
    to keep the size of our Docker images to a minimum; furthermore, we should never
    only assume that a required package for our project exists on the server. Some
    IDEs will provide options to generate and manage the requirements.txt (the standard
    naming convention for Python requirements). However, if our IDE does not, we can
    always generate it from the command line with `pip` `freeze` `>` `requirements.txt`.
    Once we do that, we can review the requirements to ensure we have our desired
    packages. For instance, we may want to ensure that `uvicorn` and `fastapi` are
    present. Note that we may see additional requirements because of other dependencies
    we have installed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了额外的依赖项之后，我们希望创建一个列表，列出将在容器上安装的要求。记住，我们之前试图将Docker镜像的大小保持最小；此外，我们永远不应该只假设我们的项目所需的包存在于服务器上。一些IDE将提供生成和管理requirements.txt（Python要求的标准命名约定）的选项。然而，如果我们的IDE没有提供，我们总是可以从命令行使用`pip
    freeze > requirements.txt`来生成它。一旦我们这样做，我们就可以审查要求，确保我们有我们想要的包。例如，我们可能想确保`uvicorn`和`fastapi`存在。请注意，我们可能会看到由于我们安装的其他依赖项而出现的额外要求。
- en: With the requirements.txt and application folder in hand, we should have everything
    we need to run this in Docker.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有requirements.txt和应用程序文件夹，我们应该有在Docker中运行此代码所需的一切。
- en: 4.4.2 Docker setup
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 Docker设置
- en: Using our previous Docker experience (we could just copy a previous setup we
    have or start from scratch), we end up with a folder structure similar to
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前的Docker经验（我们可以复制我们已有的设置或从头开始），我们最终得到一个类似于以下结构的文件夹：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'where the app folder will contain our application code. At the moment, we only
    need a few source files: main.py, files.py, and the associated __init__.py. Although
    it is quite possible there may be additional files present specific to the IDE,
    there is no need to copy those over.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代码将存放在app文件夹中。目前，我们只需要几个源文件：main.py、files.py以及相关的__init__.py。尽管很可能存在一些特定于IDE的额外文件，但无需复制这些文件。
- en: The Dockerfile is where all the heavy lifting comes into play, but since our
    structure is the same, we do not need to change anything.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile是所有重头戏发生的地方，但由于我们的结构相同，我们不需要做任何更改。
- en: Listing 4.11  Our Dockerfile
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.11  我们的Dockerfile
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#1 Uses the alpine version of our Python image, so the size of the image is
    reduced'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用我们的Python镜像的alpine版本，因此镜像的大小减小'
- en: '#2 Ensures that we set the working directory for the container'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 确保我们为容器设置了工作目录'
- en: '#3 Copies the requirements to the image'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 将需求复制到镜像中'
- en: '#4 Updates the image and adds our additional dependencies'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 更新镜像并添加我们的额外依赖项'
- en: '#5 Updates pip and installs the requirements'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 更新pip并安装需求'
- en: '#6'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '#6'
- en: '#7 Copies the application code over to the image'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 将应用程序代码复制到镜像中'
- en: '#8 Starts uvicorn using our application and binding it to port 8000'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 使用我们的应用程序启动uvicorn并将其绑定到端口8000'
- en: 'Next, we want the docker-compose.yml file to manage the building of the service
    for us. We will only have a single service at this point:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望docker-compose.yml文件能为我们管理服务的构建。目前我们只有一个服务：
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once these are in place, we should be able to run the usual `docker-compose`
    `build` and `docker-compose up` commands to start our container. After navigating
    our browser over to http://localhost:8000/files/, we should see the hardcoded
    value returned. In our case, it is `[{"file":"File_1"},{"file":"File_2"}]`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些设置到位，我们应该能够运行常规的 `docker-compose` `build` 和 `docker-compose up` 命令来启动我们的容器。在将浏览器导航到
    http://localhost:8000/files/ 后，我们应该看到返回的硬编码值。在我们的例子中，它是 `[{"file":"File_1"},{"file":"File_2"}]`。
- en: 4.5 Documenting our API
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 记录我们的API
- en: Great! We are moving right along. While most of our API is hardcoded, we will
    continue to refine it as we move forward. However, the hardcoded values are only
    a part of what makes our API unusable. Our main problem is that nobody knows about
    it, and if they knew about it, how would they use it? We need documentation, and
    OpenAPI ([https://www.openapis.org/](https://www.openapis.org/)) comes to our
    rescue. This is a standard that allows us to create interactive documentation,
    and others to discover how the API works and how it generates client code and
    server code, among other things.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们正在稳步前进。虽然我们的大部分API都是硬编码的，但我们将继续在前进的过程中对其进行改进。然而，硬编码的值只是使我们的API无法使用的一部分。我们主要的问题是没有人知道这一点，如果他们知道了，他们将如何使用它？我们需要文档，而OpenAPI
    ([https://www.openapis.org/](https://www.openapis.org/)) 就是我们救星。这是一个允许我们创建交互式文档的标准，并让其他人发现API是如何工作的，以及它是如何生成客户端代码和服务器端代码的，以及其他事情。
- en: Remember API-driven design from the beginning of the chapter? Well, it is possible
    to give an OpenAPI specification to generate not only client code that would consume
    that API, but also the beginnings of the server-side code that will process those
    requests. With our Docker container up and running, we should have support out
    of the box for two flavors of documentation based on the OpenAPI specification.
    We will cover both documentation frameworks in the following sections.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 记得章节开头提到的API驱动设计吗？嗯，我们可以提供一个OpenAPI规范来生成不仅会消费该API的客户端代码，还包括处理这些请求的服务器端代码的起点。随着我们的Docker容器启动并运行，我们应该能够直接支持基于OpenAPI规范的两种文档格式。我们将在接下来的几节中介绍这两个文档框架。
- en: 4.5.1 Swagger
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 Swagger
- en: Swagger is a set of tools for implementing the OpenAPI definition, but for historical
    reasons, many people may still refer to the OpenAPI definition as a Swagger specification,
    Swagger definition, or just Swagger. One of the most useful tools that you will
    likely find yourself using is Swagger Editor ([https://editor.swagger.io/](https://editor.swagger.io/)),
    which provides a side-by-side view of the OpenAPI definition and the resulting
    output. We can browse the Swagger documentation generated by FastAPI by navigating
    over to http://localhost:8000/docs. From there, we can view the documentation
    and experiment with the API. In this case, though, we want to click the link that
    should take us to http://localhost:8000/openapi.json and display the OpenAPI JSON.
    We can save or just copy and paste it into the online Swagger Editor. Figure 4.2
    is a sample screenshot of what we see.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 是一组用于实现OpenAPI定义的工具，但由于历史原因，许多人可能仍然将OpenAPI定义称为Swagger规范、Swagger定义或仅仅是Swagger。你可能会发现自己使用的一个最有用的工具是Swagger
    Editor ([https://editor.swagger.io/](https://editor.swagger.io/))，它提供了OpenAPI定义和结果输出的并排视图。我们可以通过导航到
    http://localhost:8000/docs 来浏览FastAPI生成的Swagger文档。从那里，我们可以查看文档并尝试使用API。然而，在这种情况下，我们想要点击链接，该链接应带我们到
    http://localhost:8000/openapi.json 并显示OpenAPI JSON。我们可以保存或直接复制粘贴到在线Swagger编辑器中。图4.2
    是我们看到的示例截图。
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH04_F02_Kardell.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述自动生成](../Images/CH04_F02_Kardell.png)'
- en: Figure 4.2  Online Swagger Editor
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2 在线Swagger编辑器
- en: You can play around with editing the API to gain a better understanding. Note
    that the online editor will prompt us to convert the JSON to YAML. We do not have
    to do this, but it does make it a little easier to edit in place.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试编辑API来加深理解。注意，在线编辑器会提示我们将JSON转换为YAML。我们不必这样做，但这确实使就地编辑变得容易一些。
- en: The FastAPI framework supports several ways to help customize this documentation
    further, and we will be looking at that later on.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI框架支持多种方式来自定义此文档，我们将在稍后探讨这一点。
- en: 4.5.2 Redoc
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 Redoc
- en: FastAPI also supports Redoc, a free and open source tool for creating documentation.
    It provides a responsive three-panel view that has become popular, especially
    when working with larger APIs. Again, FastAPI provides this documentation out
    of the box, and we can see it by going to http://localhost:8000/redoc. Figure
    4.3 shows our sample API documentation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI还支持Redoc，这是一个免费的开源工具，用于创建文档。它提供了一个响应式的三个面板视图，这在处理大型API时特别受欢迎。同样，FastAPI自带提供此文档，我们可以通过访问http://localhost:8000/redoc来查看它。图4.3显示了我们的示例API文档。
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH04_F03_Kardell.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](../Images/CH04_F03_Kardell.png)'
- en: Figure 4.3  FastAPI documentation with Redoc
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.3  使用Redoc的FastAPI文档
- en: Stripe, a popular payment service uses a similar three-panel view for their
    APIs. However, they created a tool called Markdoc ([https://markdoc.dev/](https://markdoc.dev/))
    that helps generate their documentation. There are more tools for handling API
    documentation and documentation in general. Futuristic FinTech likely already
    provides multiple tools for this purpose, so we want to follow our company’s current
    standards and suggest new tools as needed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 流行支付服务Stripe使用类似的三个面板视图来展示他们的API。然而，他们创建了一个名为Markdoc（[https://markdoc.dev/](https://markdoc.dev/））的工具，帮助生成他们的文档。还有更多工具用于处理API文档和一般文档。未来主义金融科技可能已经为这个目的提供了多个工具，因此我们希望遵循我们公司的当前标准，并在需要时建议新的工具。
- en: 4.5.3 What is so great about API documentation?
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.3 API文档有什么好处？
- en: Documentation is one of those things that can be a struggle to get right, which
    is why the ability of FastAPI to provide us with OpenAPI documentation is so fantastic.
    Why? Because we can address one of the main documentation pain points, which is
    that it becomes stale quickly. With FastAPI, we can decorate our functions so
    that they generate the documentation, meaning we are less likely to be out of
    sync between what the documentation shows and what the code is doing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是那些可能很难做对的事情之一，这就是为什么FastAPI提供OpenAPI文档的能力如此出色。为什么？因为我们能够解决主要文档痛点之一，即它很快就会过时。使用FastAPI，我们可以装饰我们的函数，使它们生成文档，这意味着我们不太可能使文档显示的内容与代码执行的内容不同步。
- en: 'That is not all though. We really only touched on the basics of what is available.
    In addition to being able to interactively see the APIs and try them out, here
    are some of the other cool features available:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不是全部。我们实际上只是触及了可用的基本内容。除了能够交互式地查看API并尝试它们之外，这里还有一些其他酷炫的功能：
- en: Providing contact information in the form of URL or email addresses that end
    users can use
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供以URL或电子邮件地址形式存在的联系信息，供最终用户使用
- en: Licensing information about your APIs
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于你的API的许可信息
- en: Pointing to different servers (e.g., a test server, sandbox, or production)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向不同的服务器（例如，测试服务器、沙盒或生产服务器）
- en: Providing examples of requests/responses
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供请求/响应示例
- en: Generating server-side code to handle requests to the APIs
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成服务器端代码以处理对API的请求
- en: Generating client-side code to interact with the APIs
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成客户端代码以与API交互
- en: Those are just some interesting features of designing APIs that conform to the
    OpenAPI specification. To learn more, check out *Designing APIs with Swagger and
    OpenAPI* (2022, Manning) by Joshua S. Ponelat and Lukas L. Rosenstock.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是符合OpenAPI规范设计的API的一些有趣特性。要了解更多信息，请参阅Joshua S. Ponelat和Lukas L. Rosenstock合著的《使用Swagger和OpenAPI设计API》（2022年，Manning）。
- en: 4.6 Managing our APIs
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 管理我们的API
- en: At this point, our API is small, consisting of a single `POST` and four `GET`
    statements. As our API grows, we need to have a strategy in place to manage it.
    This is best determined early as once APIs are in production and used by clients,
    it becomes more difficult to get a handle on the situation. Earlier, we mentioned
    the challenges of managing APIs such as versioning, documentation, monitoring,
    and so forth. We introduce the use of API management software so that you have
    some knowledge of its capabilities. We use API management as an umbrella term
    to cover the components that are found in the tool.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的API很小，只包含一个`POST`请求和四个`GET`请求。随着我们的API的增长，我们需要制定一个管理策略。这最好在早期确定，因为一旦API投入生产并被客户使用，就变得难以控制。之前，我们提到了管理API的挑战，如版本控制、文档、监控等。我们引入API管理软件的使用，以便您对其功能有所了解。我们将API管理作为一个总称，涵盖工具中发现的组件。
- en: We will incorporate an API Manager by WSO2 ([https://wso2.com/](https://wso2.com/))
    into our solution just to highlight some of the benefits of using an API manager.
    There are many API management solutions, but we have worked directly with WSO2
    and Mulesoft Anypoint ([https://mng.bz/4a2V](https://mng.bz/4a2V)) in the FinTech
    industry.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把WSO2的API管理器（[https://wso2.com/](https://wso2.com/)）集成到我们的解决方案中，以突出使用API管理器的某些好处。有许多API管理解决方案，但我们已经在金融科技行业直接与WSO2和Mulesoft
    Anypoint（[https://mng.bz/4a2V](https://mng.bz/4a2V)）合作。
- en: The WSO2 solution was easy to integrate into our solution. In addition, the
    documentation and tutorials for WSO2 are highly informative. As mentioned before,
    the use of Docker makes switching out components easy. Feel free to work on integrating
    other API managers into your solution that may better match your environment.
    The underlying mechanics and benefits from working with an API manager should
    be the same across the board.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: WSO2解决方案很容易集成到我们的解决方案中。此外，WSO2的文档和教程信息量很大。正如之前提到的，使用Docker使得更换组件变得容易。请随意将其他API管理器集成到您的解决方案中，这些API管理器可能更适合您的环境。与API管理器合作的基础机制和好处应该是普遍适用的。
- en: 4.6.1 Benefits of API management
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.1 API管理的优势
- en: API managers can provide a more centralized approach to managing your APIs.
    If your business has multiple applications, they are likely to run on different
    servers, require different authentication, and expose multiple points to the outside
    world from a networking perspective. API managers provide a way to centralize
    your API management. They offer features that help monetize APIs, protect against
    potential attacks with rate limiting (which can also be used for monetization
    by supplying different tiers), and provide authentication/authorization.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: API管理器可以提供更集中的方法来管理您的API。如果您的业务有多个应用程序，它们可能运行在不同的服务器上，需要不同的身份验证，并且从网络角度来看，向外界暴露多个点。API管理器提供了一种集中管理API的方法。它们提供帮助货币化API、通过速率限制（这也可以通过提供不同层来用于货币化）来防范潜在攻击以及提供身份验证/授权的功能。
- en: Another aspect of managing APIs in larger corporations is providing a central
    place for our users to access. If we have distinct services and business units
    in our company, they more than likely have different servers handling their APIs,
    yet want to provide a single experience to their users. We can have all the APIs
    sent to a single endpoint, and then the API manager can direct the request to
    the appropriate server in your network.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型企业中管理API的另一个方面是为我们的用户提供一个中心位置进行访问。如果我们公司有明确的服务和业务单元，它们很可能有不同服务器处理它们的API，但仍然希望为用户提供单一体验。我们可以将所有API发送到单个端点，然后API管理器可以将请求定向到您网络中的适当服务器。
- en: Once our requests are flowing through a centralized location, we can provide
    additional benefits to our users. One of them is a common interface to view and
    manage APIs as an end-user. If you have experience with APIs such as Google APIs,
    you should be aware that they offer a console to subscribe to various APIs. Sometimes,
    as companies grow and acquire other companies or merge, multiple products can
    be listed under the same company but provide a disjointed experience. By using
    an API manager, customers can view all your API offerings in one location.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的请求通过一个集中位置流动，我们就可以为用户提供额外的便利。其中之一是为最终用户提供一个通用的界面来查看和管理API。如果您有使用像Google
    API这样的API的经验，您应该知道它们提供了一个控制台来订阅各种API。有时，随着公司成长并收购其他公司或合并，多个产品可能属于同一公司，但提供的是不连贯的体验。通过使用API管理器，客户可以在一个位置查看所有API产品。
- en: In addition to a better user experience, API managers offer increased analytics
    for our APIs. We can find out the number of calls, which API versions are in use,
    and a plethora of other insights. These analytics can lead to additional benefits
    such as rate limiting, load balancing, and monetization. Many APIs offer a pay-as-we-play
    model, where we are charged by API usage. API managers help facilitate that monetization
    process.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更好的用户体验外，API 管理器还为我们的 API 提供了更多的分析。我们可以找出调用的次数、正在使用的 API 版本以及大量其他见解。这些分析可以带来额外的收益，如速率限制、负载均衡和货币化。许多
    API 提供按使用付费的模式，我们根据 API 使用情况付费。API 管理器有助于促进这一货币化过程。
- en: Finally, lifecycle management is another benefit of using a third-party tool
    such as WSO2\. Having a tool that helps enforce good lifecycle management practices
    provides a better experience for your customers and developers. We can see the
    distinct phases of an API and move APIs between different states. As shown in
    figure 4.4, we have an API that is currently in a published state, with options
    to bring it back to a created or deprecated state.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，生命周期管理是使用第三方工具如 WSO2 的另一个好处。拥有一个帮助执行良好生命周期管理实践的工具有助于为您的客户和开发者提供更好的体验。我们可以看到
    API 的不同阶段，并在不同状态之间移动 API。如图 4.4 所示，我们有一个当前处于发布状态的 API，可以选择将其恢复到创建或弃用状态。
- en: 4.6.2 Adding WSO2 API manager to our project
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.2 将 WSO2 API 管理器添加到我们的项目中
- en: 'First, we add WSO2 to our Docker setup, create a new folder named wso2, and
    place the following Dockerfile there:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 WSO2 添加到我们的 Docker 设置中，创建一个名为 wso2 的新文件夹，并将以下 Dockerfile 放在那里：
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is not much to our Dockerfile, but for consistency, we are sticking with
    the same layout as for previous setups. The real work happens in our docker-compose.yml
    file where we added the WSO2 service:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Dockerfile 中没有太多内容，但为了保持一致性，我们继续使用与之前设置相同的布局。真正的工作发生在我们的 docker-compose.yml
    文件中，我们在其中添加了 WSO2 服务：
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`port` `9443` is the management console where we will be doing most of our
    work, and the other ports (8243/8280) are the default ports that we ensure are
    exposed for their respective request types. Once we complete the usual `docker-compose`
    `build` and `docker-compose` `up` commands, we should be able to log in with the
    default username and password of `admin/admin`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`port` `9443` 是管理控制台，我们将在这里进行大部分工作，其他端口（8243/8280）是确保为相应请求类型公开的默认端口。一旦我们完成常规的
    `docker-compose` `build` 和 `docker-compose` `up` 命令，我们应该能够使用默认用户名和密码 `admin/admin`
    登录。'
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH04_F04_Kardell.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  自动生成的描述](../Images/CH04_F04_Kardell.png)'
- en: Figure 4.4  Lifecycle management by WSO2
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4  WSO2 的生命周期管理
- en: 4.6.3 OpenAPI Version
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.3 OpenAPI 版本
- en: One problem that we encountered while defining our API to WSO2 was `OpenAPI`
    `content` `validation` `failed!` We loaded our OpenAPI specification into the
    online Swagger Editor and received the error `Structural` `error` `at` `openapi`
    `should` `match pattern "^3\.0\.\d(-.+)?$"` `pattern:` `^3\.0\.\d(-.+)?$`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义我们的 API 到 WSO2 时，我们遇到了一个问题：`OpenAPI` `content` `validation` `failed!` 我们将
    OpenAPI 规范加载到在线 Swagger 编辑器中，并收到错误 `Structural` `error` `at` `openapi` `should`
    `match pattern "^3\.0\.\d(-.+)?$"` `pattern:` `^3\.0\.\d(-.+)?$`。
- en: The online Swagger Editor provided more information, and while it may be a little
    cryptic for those having no experience with regular expressions, it pointed to
    the version number being incorrect. It seems that both our Docker image for WSO2
    and the Swagger Editor do not currently support the latest version, but our FastAPI
    container does. To be sure we are using the correct version, we can double-check
    the OpenAPI site.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在线 Swagger 编辑器提供了更多信息，尽管对于那些没有正则表达式经验的用户来说可能有点晦涩，但它指出版本号不正确。似乎我们的 WSO2 Docker
    镜像和 Swagger 编辑器目前都不支持最新版本，但我们的 FastAPI 容器支持。为了确保我们使用的是正确版本，我们可以再次检查 OpenAPI 网站。
- en: 'ChatGPT was aware of the latest version, and when we posted the specification
    and asked it “Is this a valid OpenAPI specification?” we received the following
    response:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 知道最新版本，当我们发布规范并询问它“这是一个有效的 OpenAPI 规范吗？”时，我们收到了以下回复：
- en: '**![image](../Images/Response-Chatgpt.png)** The OpenAPI specification you
    have posted is quite extensive, and at a glance, it seems to be structured correctly
    according to the OpenAPI 3.1.0 specifications. However, there are several nuances
    and small details in such a spec that need to be right for it to be valid. Here
    are some key points and common issues to check in a detailed spec like this.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**![图片](../Images/Response-ChatGPT.png)** 您发布的OpenAPI规范相当广泛，乍一看，似乎是根据OpenAPI
    3.1.0规范正确构建的。然而，这样的规范中存在一些细微之处和细节，必须正确才能使其有效。以下是一些关键点和在如此详细的规范中需要检查的常见问题。'
- en: Out of curiosity, we also tried to type in an invalid OpenAPI version (a much
    higher number), and ChatGPT said that it was not valid.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 出于好奇，我们还尝试输入了一个无效的OpenAPI版本（一个更高的数字），ChatGPT说这不是有效的。
- en: We could go about tackling this problem in a few ways. It might be that there
    is an updated version of WSO2 that supports version 3.1.0\. However, this may
    not always be practical or quick in a production environment. We could look to
    downgrade FastAPI back to a previous version, but let’s assume there is functionality
    or bug fixes we need in the current version. In this case, we can update our API
    to report back the version of 3.0.0\. We could also just manually update the generated
    document before uploading it to WSO2\. However, there is also an option from within
    WSO2 to go directly to a URL, and we want to be able to employ that.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以几种方式解决这个问题。可能有一个更新的WSO2版本支持3.1.0版本。然而，在生产环境中，这可能并不总是实际或快速。我们可以将FastAPI降级到之前的版本，但让我们假设我们需要在当前版本中的功能或错误修复。在这种情况下，我们可以更新我们的API以报告3.0.0版本。我们也可以在将其上传到WSO2之前手动更新生成的文档。然而，WSO2内部也有一个选项可以直接访问URL，我们希望能够使用它。
- en: We update our main.py, adding the following.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新了main.py，添加了以下内容。
- en: Listing 4.12  Adjusting the OpenAPI version
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.12 调整OpenAPI版本
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#1 Imports the get_openapi to allow us to customize the OpenAPI documentation;
    our previous code remains the same.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 导入get_openapi以允许我们自定义OpenAPI文档；我们的代码保持不变。'
- en: '#2 Defines a custom method'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义一个自定义方法'
- en: '#3 These fields are required when calling get_openapi.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 在调用get_openapi时，这些字段是必需的。'
- en: '#4 This is how we updated the OpenAPI version, and we had to fix a problem
    with WSO2 API manager.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 这是更新OpenAPI版本的方法，并且我们必须修复WSO2 API管理器的问题。'
- en: With that in place, if we rebuild and restart Docker, we should see `"openapi":"3.0.0"`
    instead of `"openapi":"3.1.0"` when viewing the JSON. We should also see the error
    resolved when viewed in the online Swagger Editor. Now, we can move on to creating
    the API in WSO2.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，如果我们重新构建并重启Docker，在查看JSON时应该看到`"openapi":"3.0.0"`而不是`"openapi":"3.1.0"`。我们还应该在在线Swagger编辑器中看到错误已解决。现在，我们可以继续在WSO2中创建API。
- en: 4.6.4 Create an API in WSO2
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.4 在WSO2中创建一个API
- en: 'We can create an API by going through the following steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤创建一个API：
- en: Click the Create API button.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建API按钮。
- en: Under REST API, click Import Open API.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REST API下，点击导入Open API。
- en: For the OpenAPI URL, enter http://api:8000/openapi.json. We should see that
    the URL is validated by the system.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于OpenAPI URL，输入http://api:8000/openapi.json。我们应该看到系统已验证该URL。
- en: 'Enter a name (this is what the API will be known as in WSO2):'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个名称（这是API在WSO2中将被识别的名称）：
- en: The context is a way to distinguish the API URL in WSO2.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上下文是区分WSO2中API URL的一种方式。
- en: The version of the API.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: API的版本。
- en: The endpoint should be http://api:8000.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端点应该是http://api:8000。
- en: Click Create.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建。
- en: On the left pane, under Deploy, click Deployments.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板下，在部署下点击部署。
- en: Click Deploy.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击部署。
- en: 'On the left pane, under Test, click Try Out:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板下，在测试下点击试用：
- en: We will be directed to a similar Swagger Doc screen we saw earlier.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将被引导到一个与之前看到的类似的Swagger文档屏幕。
- en: Click Generate Key.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击生成密钥。
- en: Try out your APIs.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试运行你的API。
- en: With this API in place, the thing to notice is that we no longer make a request
    directly to our backend of http://api:8000\. Instead, we are going to make requests
    to https://localhost:8243/sample/0.0.1/files, which is the API manager, the context
    we chose, version, and our API. If we were to keep the API manager in place, we
    would stop exposing `port` `8000` in Docker so that we would force anyone interested
    in using the APIs through the single-entry point.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在此API就绪后，需要注意的事情是，我们不再直接向我们的后端http://api:8000发送请求。相反，我们将向https://localhost:8243/sample/0.0.1/files发送请求，这是API管理器，我们选择的环境，版本和我们的API。如果我们保留API管理器，我们将停止在Docker中暴露`端口`
    `8000`，这样就可以强制任何有兴趣使用API的人通过单一入口点。
- en: Note that as we currently have things set up, we won’t be saving the APIs permanently
    in the manager. So, remember that if we spend a lot of time setting up and configuring
    the APIs, anything we do is not permanent. We just wanted to set up this sandbox
    because we believe it is beneficial for you to have some experience with API management
    tools as you are likely to encounter them, especially in larger companies.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，根据我们目前设置的配置，我们不会在管理器中永久保存API。所以，记住如果我们花费大量时间设置和配置API，我们所做的一切都不是永久的。我们只是想设置这个沙盒，因为我们相信，对于你来说，有一些API管理工具的经验是有益的，因为你很可能会遇到它们，尤其是在大公司中。
- en: 4.6.5 Troubleshooting
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.5 故障排除
- en: When working with an API manager and trying an API out, the most common error
    is
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当与API管理器一起尝试API时，最常见的错误是
- en: '[PRE20]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Missing` `Credentials` error is caused by not selecting Generate Key before
    testing the API. When working with APIs in a production environment, we have to
    generate keys to use with the API either through a dashboard or through another
    API. In trying out our APIs, we are simply generating a temporary token to use
    for a brief time.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: “缺少凭证”错误是由于在测试API之前没有选择生成密钥而引起的。在生产环境中与API一起工作时，我们必须通过仪表板或另一个API生成密钥来使用API。在尝试我们的API时，我们只是简单地生成一个临时令牌，用于短时间内使用。
- en: Working with an API manager or through the OpenAPI documentation pages is a
    helpful way of doing some initial evaluation and exploratory testing. However,
    once we settle on the APIs that we are going to use, we will need to start using
    additional tools that are more specialized and offer more robust functionality.
    The following sections illustrate some of the additional tools that we will be
    using.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过API管理器或通过OpenAPI文档页面进行工作是一种进行初步评估和探索性测试的有帮助的方式。然而，一旦我们确定了将要使用的API，我们就需要开始使用更多专业化和提供更强大功能的额外工具。以下部分展示了我们将要使用的一些额外工具。
- en: 4.7 Testing with Postman
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 使用Postman进行测试
- en: The Postman API platform is a popular tool to assist with the API lifecycle,
    collaboration between developers and other teams, as well as with API governance.
    We have primarily used it in testing capacity, although the platform offers many
    more capabilities.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Postman API平台是一个流行的工具，用于协助API生命周期管理，以及开发人员与其他团队之间的协作，以及API治理。我们主要将其用于测试功能，尽管该平台提供了许多其他功能。
- en: One of our favorite features is the ability to `import`/`export` `curl` versions
    of the command. `curl` is a ubiquitous command line utility that lets us get or
    send data using a variety of protocols. Many systems administrators will ask you
    for a `curl` equivalent of your `RESTful API` call when troubleshooting network/routing
    problems, so having the ability to produce one quickly and easily can be helpful
    for your entire team.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最喜欢的一个功能是能够`导入`/`导出`命令的`curl`版本。`curl`是一个无处不在的命令行实用程序，它允许我们使用各种协议获取或发送数据。许多系统管理员在解决网络/路由问题时，会要求你提供`RESTful
    API`调用的`curl`等效命令，因此能够快速轻松地生成一个对于整个团队来说可能是有帮助的。
- en: Collaboration between team members is also easy with Postman, and we have worked
    closely with our QA department to help develop test scripts that can be used for
    component and integration tests. Let’s look at how we can use Postman to validate
    data that is returned from our API. This is similar to what we might be doing
    with our unit tests while developing. However, the perspective is different because
    these may be run as part of a larger CI/CD pipeline or as part of QA testing process.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 与团队成员之间的协作在Postman中也同样容易，我们已经与我们的QA部门紧密合作，帮助开发可用于组件和集成测试的测试脚本。让我们看看我们如何使用Postman验证从我们的API返回的数据。这与我们在开发时可能进行的单元测试类似。然而，视角是不同的，因为这些可能作为更大型的CI/CD管道的一部分或作为QA测试过程的一部分运行。
- en: 'We will continue to use the http://localhost:8000/files as our example. Of
    course, we could also take on the challenge of building a Postman test using an
    API manager layer. In Postman, we can create a collection that is used to group
    various requests. Then we can create a new `GET` request that points to the http://localhost:8000/files
    and click Send. We should see a nicely formatted JSON response that we have condensed
    here: `[{"file":"File_1"},{"file":"File_2"}]`.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用 http://localhost:8000/files 作为我们的示例。当然，我们也可以接受挑战，使用API管理层构建一个Postman测试。在Postman中，我们可以创建一个用于分组各种请求的集合。然后我们可以创建一个新的`GET`请求，指向
    http://localhost:8000/files 并点击发送。我们应该看到一个格式良好的JSON响应，我们在这里进行了简化：`[{"file":"File_1"},{"file":"File_2"}]`。
- en: 'Once we have confirmed we are successfully connecting and receiving responses
    from the endpoint, we can add a few tests as well: click the Tests tab, and you
    can add some straightforward tests to get an idea of how the syntax works. First,
    let’s test that we have a valid `200` response code using the following listing.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确认我们已成功连接并从端点接收响应，我们也可以添加一些测试：点击“测试”标签页，你可以添加一些简单的测试来了解语法是如何工作的。首先，让我们使用以下列表来测试我们是否有一个有效的`200`响应代码。
- en: Listing 4.13  Sample Postman test
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.13  样本Postman测试
- en: '[PRE21]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '#1 Check if response format is json'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 检查响应格式是否为json'
- en: '#2 Check if response status is 200'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 检查响应状态是否为200'
- en: When sending our request, we should see that the Test Results tab is populated,
    and we have a passing test. We add a few more tests, as shown in the following
    listing.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送我们的请求时，我们应该看到测试结果标签页已填充，并且我们有一个通过测试。我们添加了更多测试，如以下列表所示。
- en: Listing 4.14  More Postman tests
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.14  更多Postman测试
- en: '[PRE22]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Some of these tests are fragile—meaning they may be easily broken by the data
    or ordering—so we would expect this code to run against known data. Let’s use
    the test that looks for `File_1` to make it a little more robust. Because our
    data is in an array, we should be guaranteed when parsing that we will always
    parse them in that order, as opposed to an object where the `key`/`value` pairs
    may not always be returned in the way we see it. Still, the ordering of the JSON
    depends on factors outside of our control. We may be guaranteed that there is
    a `File_1`, but maybe it is not always returned first. How can we write a more
    robust test? What if we iterated through the array using a `for-each` loop?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些测试是脆弱的——这意味着它们可能很容易被数据或顺序破坏——因此我们预计此代码将在已知数据上运行。让我们使用查找`File_1`的测试来使其更加健壮。因为我们的数据在数组中，我们应该保证在解析时我们总是按该顺序解析它们，而不是对象，其中`key`/`value`对可能不会总是以我们看到的方式返回。然而，JSON的顺序取决于我们无法控制的因素。我们可能保证存在一个`File_1`，但它可能并不总是首先返回。我们如何编写一个更健壮的测试？如果我们使用`for-each`循环遍历数组会怎样？
- en: Listing 4.15  Using a `for-each` loop in Postman
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.15  在Postman中使用`for-each`循环
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now we define a variable to indicate whether we found our desired item, so no
    matter where it appears in the array, we will find it. That is a more flexible
    test, and depending on your familiarity with the language, it might be your first
    attempt, and since it works, that may be enough. However, we can clarify the test
    a bit using the `some` method.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义一个变量来指示我们是否找到了我们想要的项目，这样无论它在数组中的位置如何，我们都能找到它。这是一个更灵活的测试，并且根据你对语言的熟悉程度，这可能是你的第一次尝试，并且由于它有效，这可能就足够了。然而，我们可以使用`some`方法稍微澄清测试。
- en: Listing 4.16  Cleaning up our test
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.16  清理我们的测试
- en: '[PRE24]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that the `some` method is part of ECMAScript 5+ and is available outside
    of Postman. We have found that using Postman and these test scripts is a fantastic
    way to introduce newer QA resources to some type of automation. We just scratched
    the surface of what Postman has to offer; it is a great tool that we have seen
    used at various FinTech companies, as well as in other industries.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`some`方法是ECMAScript 5+的一部分，并且可以在Postman之外使用。我们发现使用Postman和这些测试脚本是一种介绍新QA资源到某种自动化方式的绝佳方式。我们只是触及了Postman所能提供的表面；它是一个我们在各种FinTech公司以及其他行业中看到使用的优秀工具。
- en: 4.8 Load testing with Locust
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 使用Locust进行负载测试
- en: Earlier, we introduced the testing pyramid that primarily included testing types
    we would consider functional. Here, we introduce load testing, which falls into
    the nonfunctional testing category. Figure 4.5 outlines some types of testing.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们介绍了测试金字塔，它主要包含我们会考虑的功能性测试类型。在这里，我们介绍负载测试，它属于非功能性测试类别。图4.5概述了一些测试类型。
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH04_F05_Kardell.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](../Images/CH04_F05_Kardell.png)'
- en: Figure 4.5 Software testing categories
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5 软件测试类别
- en: We want to ensure our APIs will be responsive, see where performance bottlenecks
    might be, and determine the capacity of the system for future planning. To prepare
    for all of that, we can look to a framework called Locust. Locust lets us use
    our budding Python skills to script tests used for load testing.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想确保我们的API将是响应的，看到性能瓶颈可能在哪里，并确定系统的容量以供未来规划。为此，我们可以参考一个名为Locust的框架。Locust允许我们使用我们正在发展的Python技能来编写用于负载测试的测试脚本。
- en: We can easily get started by telling ChatGPT to “create a sample locust test
    for the http://localhost:8000/files endpoint,” and that provides some easy-to-follow
    steps. First, we want to install Locust with `pip` `install` `locust`. Also, we
    create a locustfile.py as follows.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过告诉 ChatGPT “为 http://localhost:8000/files 端点创建一个 Locust 测试示例” 来轻松开始，这提供了一些易于遵循的步骤。首先，我们想要使用
    `pip install locust` 安装 Locust。同时，我们创建一个 locustfile.py 文件，如下所示。
- en: Listing 4.17  Simple Locust file
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.17  简单的 Locust 文件
- en: '[PRE25]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: From the directory with locustfile.py, run the command `locust`. This will prompt
    you to open your browser to the default location http://localhost:8089\. Here,
    we will enter the number of users, spawn rate, the host, and how long it should
    run for (we clicked the Advanced options) to get that (see figure 4.6).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 locustfile.py 目录下运行命令 `locust`。这将提示你打开浏览器到默认位置 http://localhost:8089。在这里，我们将输入用户数量、孵化率、主机以及它应该运行多长时间（我们点击了“高级选项”）以获取（见图
    4.6）。
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH04_F06_Kardell.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述自动生成](../Images/CH04_F06_Kardell.png)'
- en: Figure 4.6  Starting a new test with Locust
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.6  使用 Locust 启动新的测试
- en: From there, we can see the test run and get metrics around how our API is performing.
    Obviously, in this case, we are dealing with hardcoded values, so we will have
    a better opportunity later to come back and explore load testing our APIs. However,
    we can go ahead and get some experience with Locust and load testing now. Can
    we add tests for the other endpoints? If we need a reminder of what they were
    or what they should be returning, do not forget our living documentation at http://localhost:8000/docs.
    With additional tests, our code should look like the following listing.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以看到测试运行并获得关于我们的 API 性能的指标。显然，在这种情况下，我们正在处理硬编码的值，所以我们将在稍后有机会回来探索我们的 API
    的负载测试。然而，我们现在可以继续使用 Locust 和负载测试来获得一些经验。我们能否为其他端点添加测试？如果我们需要提醒它们是什么或者它们应该返回什么，不要忘记我们的实时文档在
    http://localhost:8000/docs。通过添加额外的测试，我们的代码应该看起来像下面的列表。
- en: Listing 4.18  Locust test
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.18  Locust 测试
- en: '[PRE26]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#1 Creates a FileUser class that inherits from HttpUser'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 创建一个继承自 HttpUser 的 FileUser 类'
- en: '#2 Sets a random wait time ranging from 1 to 2.5 seconds between requests to
    simulate a user pausing between actions'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 在请求之间设置一个 1 到 2.5 秒的随机等待时间，以模拟用户在动作之间的暂停'
- en: '#3 Defines the host where the API requests will be sent'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 定义 API 请求将发送到的主机'
- en: '#4 The task decorator defines a user-simulated action.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 任务装饰器定义了一个用户模拟的动作。'
- en: '#5 Issues a GET against'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 对'
- en: the /files URI
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: /files URI
- en: Now, we can rerun Locust to see it hitting the various endpoints. Although our
    endpoints are currently hardcoded, they will return the path parameters used.
    So, to make things more interesting, let’s add some code to each of these tests
    so that the parameters are unique, and that will show us hitting more endpoints
    in the Locust dashboard. Take a few minutes to see whether you can replace the
    hardcoded `file_ids` and `record_ids` with a random number, and then rerun the
    tests. The next listing shows the sample we came up with.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重新运行 Locust 来查看它正在击中各种端点。虽然我们的端点目前是硬编码的，但它们将返回使用的路径参数。所以，为了使事情更有趣，让我们为这些测试中的每一个添加一些代码，使得参数是唯一的，这样我们就可以在
    Locust 控制台中看到更多的端点被击中。花几分钟时间看看你是否可以用随机数替换硬编码的 `file_ids` 和 `record_ids`，然后重新运行测试。下面的列表显示了我们所提出的示例。
- en: Listing 4.19  Locust
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.19  Locust
- en: '[PRE27]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '#1 Generates a random file_id in the range from 1 to 9'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 在 1 到 9 的范围内生成一个随机的 file_id'
- en: 'After rerunning our tests, we can see a lot more variety in the endpoints being
    accessed. At this point, we may have noticed a problem when executing the tests
    in Locust on the dashboard. If not, take a look at the Failures tab in Locust.
    You should see a number of failures for the `POST` method on `/files` with the
    error `HTTPError(''405` `Client` `Error: Method` `Not` `Allowed` `for` `url:`
    `/files'')`. It looks like we missed something in our API code. But before checking
    it, let’s take a look at another big problem with our Locust tests—no `assert`
    statements.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '重新运行我们的测试后，我们可以看到访问端点的更多多样性。在这个时候，我们可能已经注意到了在 Locust 控制台中执行测试时出现的问题。如果没有，请查看
    Locust 的“失败”选项卡。你应该会看到 `/files` 上 `POST` 方法的多个失败，错误信息为 `HTTPError(''405 Client
    Error: Method Not Allowed for url: /files'')`。看起来我们在我们的 API 代码中遗漏了一些东西。但在检查它之前，让我们看看
    Locust 测试的另一个大问题——没有 `assert` 语句。'
- en: Similarly to all our other tests, we want to make sure we are doing some sort
    of the `assert` statement. Let’s start by ensuring a valid response each time.
    Feel free to give that a try before reading further.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们所有的其他测试一样，我们想要确保我们进行了一些 `assert` 语句。让我们先确保每次都得到一个有效的响应。在继续阅读之前，不妨试一试。
- en: Listing 4.20  Locust test
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.20  Locust 测试
- en: '[PRE28]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '#1 Previous code setup from listing 4. 1 9'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 列表 4.1 9 中的先前代码设置'
- en: '#2 Uses the Locust task decorator to define what Locust should be executing'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用 Locust 任务装饰器定义 Locust 应该执行的内容'
- en: '#3 Defines a get_files method that executes a GET against the /files URI and
    checks the HTTP status was 200'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 定义了一个 get_files 方法，它对 /files URI 执行 GET 请求并检查 HTTP 状态码为 200'
- en: '#4 Makes requests using a random file_id in the range from 1 to 9'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 使用 1 到 9 范围内的随机 file_id 发起请求'
- en: '#5 Makes requests using a random file_id in the range from 1 to 9 and a random
    record_id in the range from 1 to 1 9'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 使用 1 到 9 范围内的随机 file_id 和 1 到 19 范围内的随机 record_id 发起请求'
- en: 'Now that we have some assert statements, we can see an `Unexpected` `status`
    `code:` `405` in the Exceptions tab in addition to the Failures tab. Let’s check
    out the logs for the API container and see what’s there. The logs show two interesting
    problems:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些 assert 语句，我们可以在异常标签页中看到 `Unexpected` `status` `code:` `405`，除了失败标签页。让我们检查
    API 容器的日志，看看有什么。日志显示两个有趣的问题：
- en: '[PRE29]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As we saw, the `POST` is getting a `405` `Method` `Not` `Allowed`, and we also
    see a `307` `Temporary` `Redirect`. When we review our code that defines the endpoints,
    we see that there was a trailing slash for some endpoints but not for others:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`POST` 请求得到了 `405` `Method` `Not` `Allowed` 的响应，我们还看到了一个 `307` `Temporary`
    `Redirect`。当我们回顾定义端点的代码时，我们发现有些端点后面有斜杠，而有些则没有：
- en: '[PRE30]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: All the Locust requests left the trailing slash off the requests, so let’s make
    sure we are consistent in both the server and the client. In our example, we are
    going to remove the trailing slashes from the server portion. Rebuilding our containers
    and rerunning our tests give us a more consistent experience without errors in
    the logs or failures in Locust. We do see that we still have exceptions in Locust.
    This is because we coded all our assert statements to be expecting a `200` return
    code. However, when we refer to the documentation (or by looking at the code),
    we are reminded that our `POST` request responds with a `201` not `200`. With
    that taken care of, we see our tests running normally, with review failures, exceptions,
    and the associated analytics as shown in figure 4.7.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 Locust 请求都没有在请求中包含尾部斜杠，所以让我们确保服务器和客户端都是一致的。在我们的例子中，我们将从服务器部分移除尾部斜杠。重新构建我们的容器并重新运行测试，给我们带来了更一致的经历，没有错误日志或
    Locust 中的失败。我们确实看到 Locust 中仍然有异常。这是因为我们编写了所有的 assert 语句，期望返回 `200` 状态码。然而，当我们参考文档（或查看代码）时，我们被提醒我们的
    `POST` 请求响应的是 `201` 而不是 `200`。处理完这个问题后，我们看到测试正常运行，有审查失败、异常以及如图 4.7 所示的相关分析。
- en: '![A screenshot of a graph  Description automatically generated](../Images/CH04_F07_Kardell.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![一个图表的截图  自动生成的描述](../Images/CH04_F07_Kardell.png)'
- en: Figure 4.7  View of successive Locust runs
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.7  连续的 Locust 运行视图
- en: 4.9 Improving our code
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9 改进我们的代码
- en: Now that we have both unit and load tests, you should feel comfortable working
    within your code to make improvements. Even though the code is straightforward,
    we can still take advantage of some benefits of FastAPI. This section shows the
    benefits of versioning, using prefixes, documentation, and validation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了单元测试和负载测试，你应该可以在代码中工作以进行改进感到舒适。尽管代码很简单，我们仍然可以利用 FastAPI 的一些好处。本节展示了版本控制、使用前缀、文档和验证的好处。
- en: 4.9.1 Using a prefix and versioning
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9.1 使用前缀和版本控制
- en: You may have noticed that each of our endpoints in the router includes`/files`.
    While this works fine, we would also like to include a version number, as well
    as put the endpoint under an `api` endpoint in the URL. We want to end up with
    something like `/api/v1/files` as our initial standard. Using `/api` helps with
    organizing our APIs in one area. This can help with web server configuration,
    firewall rules, monitoring, and similar. The `v1` indicates the API version, and
    we can use it to support multiple API versions. Remember that once end-users start
    consuming the API, it is unwise to make breaking changes to your API that would
    force them to upgrade their applications. In these cases, you should provide the
    new API under `/v2` and eventually phase out prior versions when possible. Remember,
    the `/api/v1` is just a suggestion. You could name the endpoint anything you choose
    and use any versioning scheme based on your needs.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们路由器中的每个端点都包括`/files`。虽然这没问题，但我们还想包括一个版本号，并将端点放在URL中的`api`端点下。我们希望最终得到类似`/api/v1/files`的初始标准。使用`/api`有助于将我们的API组织在一个区域。这可以帮助进行Web服务器配置、防火墙规则、监控等。`v1`表示API版本，我们可以用它来支持多个API版本。记住，一旦最终用户开始使用API，就不应该对API进行破坏性更改，这会迫使他们升级他们的应用程序。在这些情况下，你应该在`/v2`下提供新的API，并在可能的情况下逐步淘汰旧版本。记住，`/api/v1`只是一个建议。你可以命名端点，并根据自己的需求使用任何版本控制方案。
- en: 'We refactor our code to add the additional `/api/v1` to our endpoints by using
    the `prefix` parameter available in `APIRouter`. We update our files.py:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`APIRouter`中可用的`prefix`参数重构我们的代码，为端点添加额外的`/api/v1`。我们更新了`files.py`：
- en: '[PRE31]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then, we remove the `/files` from each of our defined endpoints. Table 4.3 shows
    the differences.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从我们定义的每个端点中移除`/files`。表4.3显示了差异。
- en: Table 4.3 Effects of using a `prefix` parameter on the router
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.3 使用`prefix`参数对路由器的影响
- en: '| Before | After |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 之前 | 之后 |'
- en: '| `@router.get("/files")` | `@router.get("")` |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `@router.get("/files")` | `@router.get("")` |'
- en: '| `@router.get("/files /{file_id}")` | `@router.get("/{file_id}")` |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `@router.get("/files /{file_id}")` | `@router.get("/{file_id}")` |'
- en: '| `@router.post("/files ", status_code=status.HTTP_201_CREATED)` | `@router.post("",
    status_code= status.HTTP_201_CREATED)` |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `@router.post("/files ", status_code=status.HTTP_201_CREATED)` | `@router.post("",
    status_code= status.HTTP_201_CREATED)` |'
- en: '| `@router.get("/files /{file_id}/records")` | `@router.get("/{file_id}/records")`
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `@router.get("/files /{file_id}/records")` | `@router.get("/{file_id}/records")`
    |'
- en: '| `@router.get("/files /{file_id}/records/{record_id}")` | `@router.get("/{file_id}/records/{record_id}")`
    |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `@router.get("/files /{file_id}/records/{record_id}")` | `@router.get("/{file_id}/records/{record_id}")`
    |'
- en: We can see that by using the prefix, we now have a little less typing to do
    in each endpoint. We also need to rerun our unit tests to see whether things still
    work, and as we may have suspected, our tests are all failing with `404` `errors`
    because they are no longer going to the correct URL. We need to go ahead and update
    our unit tests to include the `/api/v1` and rerun them.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，通过使用前缀，我们现在在每个端点中需要输入的字符更少了。我们还需要重新运行我们的单元测试，看看是否仍然正常工作，正如我们可能预料的那样，我们的测试都失败了，显示`404`错误，因为它们不再指向正确的URL。我们需要继续更新我们的单元测试，包括`/api/v1`，并重新运行它们。
- en: 4.9.2 Adding Pydantic
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9.2 添加Pydantic
- en: Pydantic is a widely used data validation library that comes bundled with FastAPI.
    We will incorporate it here to move away from our hardcoded strings (although
    we will still be returning hardcoded values). By adding Pydantic, we position
    our code to be more easily expanded in the future and are able to take advantage
    of some of its features for validation and documentation.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic是一个广泛使用的数据验证库，它捆绑在FastAPI中。我们将在这里使用它来摆脱我们的硬编码字符串（尽管我们仍然会返回硬编码的值）。通过添加Pydantic，我们使我们的代码更容易在未来扩展，并能够利用其一些功能进行验证和文档化。
- en: Later, we will look to build objects that model actual ACH files and records.
    For now, let’s take a look at how Pydantic will enhance our current APIs. Our
    first endpoint performs a `GET` on `/api/v1/files/{file_id}` where we previously
    returned a JSON string. It looks something like this (with the new prefix defined).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将致力于构建模拟实际ACH文件和记录的对象。目前，让我们看看Pydantic将如何增强我们当前的API。我们的第一个端点在`/api/v1/files/{file_id}`上执行`GET`操作，我们之前返回的是一个JSON字符串。它看起来像这样（带有新定义的前缀）。
- en: Listing 4.21  Our previous hardcoded function
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.21 我们之前的硬编码函数
- en: '[PRE32]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, we create an `AchFile` class that will model the hardcoded value we were
    returning in the previous listing.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个`AchFile`类，它将模拟我们在上一个列表中返回的硬编码值。
- en: Listing 4.22  Our first `Pydantic` class
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.22  我们第一个`Pydantic`类
- en: '[PRE33]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With that simple class in place, we can update the router to return an instance
    of that class.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的类设置到位后，我们可以更新路由器以返回该类的实例。
- en: Listing 4.23  Updating our route to use our newly created `Pydantic` class
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.23  更新我们的路由以使用我们新创建的`Pydantic`类
- en: '[PRE34]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Our unit tests should still pass, so we have not broken anything. If we were
    to start this up in Docker, we would run into an error of `ModuleNotFoundError:`
    `No` `module named` `'ach'`. This is because Python does not know where to find
    our class, and there is a possibility that we even forgot to copy it over! Before
    starting, add another `COPY` statement to your Dockerfile and set the `PYTHONPATH`.
    This should get our code up and running.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试仍然应该通过，所以我们没有破坏任何东西。如果我们开始在Docker中启动，我们会遇到一个`ModuleNotFoundError:` `No`
    `module named` `'ach'`的错误。这是因为Python不知道在哪里找到我们的类，甚至有可能我们忘记复制它了！在启动之前，请向您的Dockerfile中添加另一个`COPY`语句并设置`PYTHONPATH`。这应该能让我们的代码正常运行。
- en: Listing 4.24  Updating our Dockerfile
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.24  更新我们的Dockerfile
- en: '[PRE35]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now we should be able to bring down Docker, build, and bring our containers
    up again. If we take a look at the documentation, we will see an `AchFile` in
    the schema section. Let’s continue to expand on the documentation by adding a
    `Field` method to provide additional documentation.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够关闭Docker，构建，并再次启动我们的容器。如果我们查看文档，我们将在模式部分看到一个`AchFile`。让我们通过添加一个`Field`方法来提供额外的文档来继续扩展文档。
- en: Listing 4.25  Expanding the documentation of our `AchFile` class
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.25  扩展我们的`AchFile`类的文档
- en: '[PRE36]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '#1 Imports the Field function'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 导入Field函数'
- en: '#2 Adds parameters that will help with the OpenAPI documentation'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 添加有助于OpenAPI文档的参数'
- en: By adding some examples, title, and description, the schema becomes more meaningful.
    Figure 4.8 shows how the OpenAPI documentation was updated.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一些示例、标题和描述，模式变得更加有意义。图4.8显示了OpenAPI文档是如何更新的。
- en: '![A computer screen shot of a computer code  Description automatically generated](../Images/CH04_F08_Kardell.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![计算机代码屏幕截图  自动生成的描述](../Images/CH04_F08_Kardell.png)'
- en: Figure 4.8  Our updated `AchFile` schema
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.8  我们更新的`AchFile`模式
- en: This is just the beginning of making our API user-friendly. We will expand on
    the concept as we build more APIs.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是使我们的API用户友好的开始。随着我们构建更多的API，我们将扩展这个概念。
- en: 4.9.3 Validation with Pydantic
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9.3 使用Pydantic进行验证
- en: Another benefit of Pydantic is its built-in validation capabilities. Validation
    of data entering the environment is a must in any production system (unless we
    are looking to test the resilience of our system). We should not rely on the UI
    or another system to validate data. If end-users are given free rein to enter
    any type of data in a field, they will do so, and it does not matter whether it
    makes sense. By combining Pydantic with FastAPI we can get a lot of validation
    for free where we may have once needed a lot of boilerplate code.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic的另一个优点是其内置的验证功能。在任何生产系统中，验证进入环境中的数据是必须的（除非我们正在测试我们系统的弹性）。我们不应该依赖于UI或另一个系统来验证数据。如果最终用户被允许在字段中输入任何类型的数据，他们将会这样做，而且它是否有意义并不重要。通过将Pydantic与FastAPI结合使用，我们可以免费获得很多验证，而以前我们可能需要大量的模板代码。
- en: 'For example, we could enforce our `file_id` to be at least one character and
    contain only lowercase letters, underscores, and numbers. There are multiple approaches
    to enforcing such validations. In Pydantic, for instance, we can use a regular
    expression. By simply adding a pattern parameter to the field, we can enforce
    this constraint:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以强制`file_id`至少有一个字符，并且只包含小写字母、下划线和数字。有多种方法可以强制执行此类验证。例如，在Pydantic中，我们可以使用正则表达式。通过简单地向字段添加一个模式参数，我们可以强制执行这个约束：
- en: '[PRE37]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now that we are enforcing validation, let us jump back to `main.py` and add
    an exception handler when a validation error occurs. In this case, we will return
    a `400` `status` along with some detailed error information. We need to be careful
    that our exception messages do not leak sensitive information. In this case, it
    is a validation error triggered by missing or malformed fields. Still, this may
    be more appropriate for a development environment; in production, we may want
    to have a more robust method of translating the error into a known message to
    reduce the risk of exposing any sensitive data. Our exception handler should look
    like the following.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在正在执行验证，让我们回到 `main.py` 并在发生验证错误时添加一个异常处理程序。在这种情况下，我们将返回一个 `400` `状态`，以及一些详细的错误信息。我们需要小心，确保我们的异常消息不会泄露敏感信息。在这种情况下，这是一个由缺失或格式不正确的字段触发的验证错误。尽管如此，这可能更适合开发环境；在生产环境中，我们可能希望有一种更健壮的方法将错误转换为已知消息，以降低泄露任何敏感数据的风险。我们的异常处理程序应如下所示。
- en: Listing 4.26  Validation in Pydantic
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.26  Pydantic 中的验证
- en: '[PRE38]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '#1 Decorator that registers a custom exception handler for ValidationError
    exceptions'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 为 ValidationError 异常注册自定义异常处理器的装饰器'
- en: '#2 Ensures the HTTP status of 400 is returned along with error details'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 确保返回 HTTP 状态码 400 以及错误详情'
- en: From here, we can add additional unit tests that confirm our validation behavior.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以添加额外的单元测试来确认我们的验证行为。
- en: Listing 4.27  Validating our exception behavior
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.27  验证我们的异常行为
- en: '[PRE39]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '#1 A test that passes validation'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 一个通过验证的测试'
- en: '#2 Testing when we receive an exception condition. Notice the status code of
    400 and also a detailed message explaining what the pattern is.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 测试我们收到异常条件时的情况。注意状态码为 400，以及一个详细的消息解释了模式是什么。'
- en: We add the positive case to show that we accept a lowercase `file_id`, and when
    uppercase values are used, we see the error telling us what the pattern should
    be.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了积极案例来显示我们接受小写 `file_id`，并且当使用大写值时，我们看到错误告诉我们应该是什么模式。
- en: In fact, we get a lot of useful information returned by default. Whether it
    is appropriate to show all this to your end-user may be another matter. API usage
    is in most cases fine to return detailed information, but we want to caution against
    revealing too much. For instance, you may notice that most sites do not tell you
    whether you have typed your username or password incorrectly. They simply say
    that one or the other is incorrect. This is a conscious design decision made to
    prevent malicious users from attempting to determine a list of valid users. Therefore,
    we sometimes return more generic information to the user and log the details in
    a system log. In this case, we are fine since it is acting as an interactive guide
    to the API.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，默认情况下，我们得到了很多有用的信息。是否适合将这些信息全部展示给最终用户可能又是另一回事。在大多数情况下，API 使用返回详细信息是正常的，但我们想警告不要泄露太多信息。例如，你可能注意到大多数网站不会告诉你是否输入了错误的用户名或密码。他们只是简单地说你有一个或两个是不正确的。这是一个有意识的设计决策，旨在防止恶意用户试图确定有效用户列表。因此，我们有时会向用户返回更通用的信息，并在系统日志中记录详细信息。在这种情况下，我们是可以的，因为它充当了
    API 的交互式指南。
- en: Listing 4.28  Detailed error that we receive from Pydantic
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.28  从 Pydantic 收到的详细错误
- en: '[PRE40]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We just touched on the basics of validation in Pydantic and FastAPI. A broad
    range of validation options in addition to regular expressions, as well as the
    ability to create custom validators, are available. We will explore this in later
    chapters.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚简要介绍了 Pydantic 和 FastAPI 中验证的基础知识。除了正则表达式之外，还有广泛的验证选项，以及创建自定义验证器的功能。我们将在后面的章节中探讨这一点。
- en: 4.9.4 Troubleshooting Pydantic
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9.4 Pydantic 故障排除
- en: We may see a `500` `Internal` `Server` `Error` if we failed to copy over our
    updated API code. In our custom handler, we are intercepting the validation error
    thrown and returning a `400` `error` code. If we see something similar to error
    shown in the following listing, we have likely made that oversight or our handler
    is not working.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有复制我们的更新 API 代码，我们可能会看到 `500` `内部` `服务器` `错误`。在我们的自定义处理程序中，我们正在拦截抛出的验证错误，并返回
    `400` `错误`代码。如果我们看到以下列表中显示的错误类似情况，我们可能已经犯了那个疏忽，或者我们的处理程序没有正常工作。
- en: Listing 4.29  Docker error in FastAPI
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.29  FastAPI 中的 Docker 错误
- en: '[PRE41]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: API-driven design promotes an API-first approach to development and ensures
    your software meets today’s distributed nature.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 驱动的开发促进了一种以 API 为首的开发方法，并确保你的软件满足当今的分布式特性。
- en: Exploring the design and testing of APIs is crucial for interaction with software
    components in microservices, distributed systems, and packages.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 API 的设计和测试对于与微服务、分布式系统和软件包中的软件组件交互至关重要。
- en: REST is the primary API standard discussed, but GraphQL and SOAP are other important
    standards with unique pros and cons.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 是讨论的主要 API 标准，但 GraphQL 和 SOAP 也是其他重要标准，各有其独特的优缺点。
- en: APIs act as contracts requiring adherence to usage terms and providing stable,
    scalable endpoints with SLAs for consumers.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 作为合同，要求遵守使用条款，并为消费者提供具有 SLA 的稳定、可扩展的端点。
- en: API-driven design emphasizes clear use cases, versioning, comprehensive documentation,
    and robust security and validation.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 驱动的设计强调清晰的使用案例、版本控制、全面文档以及强大的安全和验证。
- en: Effective API monitoring and analytics are essential for capacity assessment,
    using tools such as OpenTelemetry, Prometheus, and Grafana.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的 API 监控和分析对于容量评估至关重要，使用 OpenTelemetry、Prometheus 和 Grafana 等工具。
- en: Initial API tasks are simple, focusing on uploading and viewing files and records
    with a clear interaction flow.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始的 API 任务很简单，主要关注上传和查看文件及记录，具有清晰的交互流程。
- en: FastAPI is used for building APIs, starting with basic `GET` endpoints, and
    supporting pagination and asynchronous processing for performance.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastAPI 用于构建 API，从基本的 `GET` 端点开始，并支持分页和异步处理以提高性能。
- en: Unit tests validate API endpoints during development, while additional tests
    such as BDD can assess API behavior and performance.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试在开发过程中验证 API 端点，而如 BDD 等附加测试可以评估 API 的行为和性能。
- en: API documentation via OpenAPI standards ensures alignment between implementation
    and user understanding, offering tools such as Swagger and Redoc.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 OpenAPI 标准，API 文档确保了实现与用户理解之间的对齐，提供了 Swagger 和 Redoc 等工具。
- en: API management tools such as WSO2 centralize management, provide lifecycle control,
    and facilitate API monitoring, monetization, and user experience.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 管理工具如 WSO2 集中管理，提供生命周期控制，并促进 API 监控、货币化和用户体验。
