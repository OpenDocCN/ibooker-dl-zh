- en: '4 APIs: The piping between our components'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 个 API：我们组件之间的管道
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: An introduction to the FastAPI framework
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastAPI 框架简介
- en: Documenting APIs using the OpenAPI standard
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OpenAPI 标准记录 API
- en: Testing our APIs using Postman and Locust
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Postman 和 Locust 测试我们的 API
- en: API management with WSO2
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 WSO2 进行 API 管理
- en: In this sprint, we work on another research spike where we explore designing
    and testing application program interfaces (APIs). An API is simply a way to interact
    with a software component. Regardless of whether we are dealing with microservices
    and distributed systems or using packages from `npm`/`pip`, we utilize APIs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个冲刺中，我们致力于另一个研究激增，其中我们探索设计和测试应用程序程序接口（API）。API 简单来说就是与软件组件交互的一种方式。无论我们是在处理微服务和分布式系统，还是使用
    `npm`/`pip` 的包，我们都利用 API。
- en: 4.1 API-driven design
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 API 驱动设计
- en: Generally, when we mention APIs in this book, we are talking about the REST
    (Representational State Transfer) API standard. However, there are other standards
    as well, such as GraphQL and the older SOAP (Simple Object Access Protocol). We
    may also come across message queuing, such as IBM Websphere MQ and RabbitMQ. Table
    4.1 shows some pros and cons of the more common approaches to implementing APIs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们在这本书中提到 API 时，我们是在谈论 REST（表示状态传输）API 标准。然而，还有其他标准，例如 GraphQL 和较老的 SOAP（简单对象访问协议）。我们可能还会遇到消息队列，如
    IBM Websphere MQ 和 RabbitMQ。表 4.1 展示了一些常见实现 API 方法的好处和坏处。
- en: Table 4.1 Pros and cons of different APIs
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.1 不同 API 的优缺点
- en: '|  | REST | SOAP | GraphQL |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|  | REST | SOAP | GraphQL |'
- en: '| Pros | Simple; builds on standard HTTP methodsMultiple data formats can be
    supported, although JSON is the most common. | Relies on XML-based messagingEnterprise-level
    security | EfficientSingle endpointStrongly typed |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 简单；基于标准 HTTP 方法支持多种数据格式，尽管 JSON 是最常用的。 | 依赖于基于 XML 的消息企业级安全 | 高效单一端点强类型
    |'
- en: '| Cons | Versioning and breaking changes can be complex to manage.The number
    of endpoints may become inconvenient. | Complex to implementWordy XML-based messages
    | Steeper learning curve |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 缺点 | 版本控制和破坏性变更可能难以管理。端点数量可能变得不便。 | 实施复杂基于 XML 的消息 | 学习曲线陡峭 |'
- en: APIs act as a contract parties agree to abide by. The consumer of the API agrees
    to abide by any terms of use and licensing agreements and follow any documentation
    and standards established by the provider. In turn, the API provider provides
    a stable and scalable endpoint to access. Subscriptions to APIs also provide tools
    to make costs, usage, and a Service Level Agreement (SLA) transparent.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: API 作为各方同意遵守的合同。API 的消费者同意遵守任何使用条款和许可协议，并遵循提供者建立的任何文档和标准。反过来，API 提供者提供了一个稳定且可扩展的端点以访问。API
    订阅还提供了工具，使成本、使用情况和服务水平协议（SLA）透明。
- en: 'With the adoption of distributed computing, many developers and architects
    have become interested in API-driven design. Often, we can expect our software
    to be deployed in the cloud or in a containerized environment. In these cases,
    we want to make sure we consider APIs. As with most design objectives, we want
    to keep some of the following things in mind:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着分布式计算的应用，许多开发者和架构师对 API 驱动的架构产生了兴趣。通常，我们可以预期我们的软件将被部署在云端或容器化环境中。在这些情况下，我们想要确保我们考虑了
    API。与大多数设计目标一样，我们想要记住以下几点：
- en: '*Clear use case**s*—An API should not serve as a Swiss Army knife that can
    deal with customers, accounts, and transactions. Instead, the design should be
    kept simple, straightforward, and consistent.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*清晰的用例**—API 不应作为瑞士军刀，能够处理客户、账户和交易。相反，设计应保持简单、直接和一致。'
- en: '*Versionin**g*—Anticipate versioning and having to deprecate older API versions.
    Having to maintain multiple versions of an API can lead to increased technical
    debt with each change. Tools such as WSO2 API Manager and the Anypoint Platform
    by Mulesoft can help with versioning, governance, and many other tasks regarding
    APIs.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*版本控制**—预测版本控制并弃用旧版 API。需要维护多个版本的 API 可能会导致每次更改都增加技术债务。WSO2 API 管理器和 Mulesoft
    的 Anypoint 平台等工具可以帮助进行版本控制、治理以及许多其他与 API 相关的任务。'
- en: '*Documentatio**n*—Comprehensive up-to-date documentation ensures easy consumption
    of our API. Standards such as OpenAPI allow our APIs to produce documentation
    that can be made available online with tools such as Swagger and Redoc.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文档**—全面的最新文档确保我们的 API 容易被消费。例如，OpenAPI 等标准允许我们的 API 生成可以通过 Swagger 和 Redoc
    等工具在线提供的文档。'
- en: '*Performance and scalin**g*—Our APIs should be able to scale to larger datasets,
    which means that we may need to introduce paging for very large datasets. We also
    need to determine acceptable wait times for API requests and how to handle longer-running
    requests.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*性能和扩展性*—我们的API应该能够扩展到更大的数据集，这意味着我们可能需要为非常大的数据集引入分页。我们还需要确定API请求的可接受等待时间以及如何处理长时间运行的请求。'
- en: '*Security and validatio**n*—Remember that a UI that validates user input is
    only half the battle. We need to ensure that the server is validating input, as
    well to prevent hackers and bad actors from exploiting our APIs.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全和验证*—记住，一个验证用户输入的UI只是战斗的一半。我们需要确保服务器也在验证输入，以防止黑客和不良行为者利用我们的API。'
- en: '*Monitoring and analytic**s*—Ensuring our APIs are functioning when accessed
    by end-users and have sufficient capacity can only be done with appropriate monitoring
    and logging. We may want to consider OpenTelemetry and tools such as Prometheus
    and Grafana to support the observability and monitoring of our APIs.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*监控和分析*—确保我们的API在用户访问时正常工作并且有足够的容量，这只能通过适当的监控和日志记录来实现。我们可能需要考虑OpenTelemetry以及Prometheus和Grafana等工具来支持我们API的可观察性和监控。'
- en: There are other considerations as well, and APIs is a topic whole books have
    been written about. At this point, we just want to provide you with enough knowledge
    to make you more proficient in your software development role. If you are interested
    in additional information on RESTful APIs, visit [https://restfulapi.net/](https://restfulapi.net/).
    If you are looking for a deeper understanding of APIs and additional hands-on
    exercise, *The Design of Web APIs* (2019, Manning) by Arnaud Lauret is an excellent
    resource.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些考虑因素，API是一个有很多书籍讨论的主题。在这个阶段，我们只想提供足够的知识，使你在软件开发角色中更加熟练。如果你对RESTful API有更多兴趣，请访问[https://restfulapi.net/](https://restfulapi.net/)。如果你想要对API有更深入的理解和更多的实践练习，Arnaud
    Lauret的《Web API设计》（2019年，Manning出版社）是一本极好的资源。
- en: 4.2 Our APIs
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 我们的API
- en: Before developing the endpoints for our APIs, we think about the tasks we need
    to perform. At this point, we won’t be dealing with many complicated tasks, but
    only upload files, view files, and view records. Table 4.2 shows what our APIs
    may look like. Note that `:fileId` and `:recordId` are placeholders for identifiers
    that will be returned by other queries.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发我们的API端点之前，我们会考虑需要执行的任务。在这个阶段，我们不会处理很多复杂任务，而只是上传文件、查看文件和查看记录。表4.2显示了我们的API可能的样子。请注意，`:fileId`和`:recordId`是其他查询将返回的标识符的占位符。
- en: Table 4.2 API overview
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.2 API概述
- en: '| HTTP method | Uniform resource identifier | Description |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| HTTP方法 | 统一资源标识符 | 描述 |'
- en: '| `POST` | `/files` | Uploads a file to the system |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/files` | 将文件上传到系统中 |'
- en: '| `GET` | `/files` | Returns a list of uploaded files |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/files` | 返回已上传文件的列表 |'
- en: '| `GET` | `/files/:fileId` | Returns details on a specific file |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/files/:fileId` | 返回特定文件的详细信息 |'
- en: '| `GET` | `/files/:fileId/records` | Returns records for a specific file |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/files/:fileId/records` | 返回特定文件的记录 |'
- en: '| `GET` | `/files/:fileId/records/:recordId` | Returns details for a specific
    record |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/files/:fileId/records/:recordId` | 返回特定记录的详细信息 |'
- en: While the table provides a good overview of our APIs, it may be helpful to think
    in terms of the flow of these APIs and how to obtain these identifiers. Figure
    4.1 shows the interaction between a user and the API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然表格提供了我们API的良好概述，但考虑这些API的流程以及如何获取这些标识符可能会有所帮助。图4.1显示了用户与API之间的交互。
- en: PlantUML
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: PlantUML
- en: PlantUML ([https://plantuml.com/](https://plantuml.com/)) is a fantastic tool
    for creating many kinds of UML diagrams such as sequence, use case, state diagrams,
    and more, as well as other diagrams for UI mockups, Gantt diagrams, and WBS diagrams.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: PlantUML ([https://plantuml.com/](https://plantuml.com/)) 是一个创建各种UML图（如序列图、用例图、状态图等）以及UI原型、甘特图和WBS图的出色工具。
- en: PlantUML is a great tool to use for many of these diagrams because it is a text-based
    interface. We can produce diagrams just by entering text into an editor! That
    means they are easy to update, easy to store in version control, and can be compared
    against previous versions. There are plugins available for our IDE as well, and
    we often use this tool from within VS Code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: PlantUML 是使用这些图的一个很好的工具，因为它是一个基于文本的界面。我们只需在编辑器中输入文本就能生成图表！这意味着它们易于更新，易于存储在版本控制中，并且可以与之前的版本进行比较。我们的IDE也有可用的插件，我们经常在VS
    Code中使用这个工具。
- en: Throughout the book, we use diagrams produced with PlantUML.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们使用PlantUML生成的图表。
- en: '![A screenshot of a computer program  Description automatically generated](../Images/CH04_F01_Kardell.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图  自动生成的描述](../Images/CH04_F01_Kardell.png)'
- en: Figure 4.1  Sequence diagram produced by PlantUML
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1  由PlantUML生成的序列图
- en: Hopefully, you can better understand now how a user may employ these initial
    APIs. These APIs should provide us with a good starting point for the project
    as they meet the requirements regarding uploading and viewing data. We can expand
    on these APIs by including query parameters to help retrieve specific data. For
    example, we may want to select files by date/time or select all batch header records
    from a specific file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在能更好地理解用户如何使用这些初始API。这些API应该为我们提供项目的良好起点，因为它们满足上传和查看数据的要求。我们可以通过包括查询参数来扩展这些API，以帮助检索特定数据。例如，我们可能想按日期/时间选择文件，或从特定文件中选择所有批次标题记录。
- en: 4.3 Building our APIs with FastAPI
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 使用FastAPI构建我们的API
- en: Previously, we built a simple health check API using FastAPI, but now we will
    examine FastAPI in more depth and start building our APIs to deal with ACH processing.
    Let’s take a look at building of our `GET` APIs first as they should be relatively
    simple to provide stubs for. In other words, we do not need to have a database
    yet. We can simply return a hardcoded value for now to make sure everything is
    working as expected.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用FastAPI构建了一个简单的健康检查API，但现在我们将更深入地研究FastAPI，并开始构建我们的API来处理ACH处理。让我们首先看看构建我们的`GET`
    API，因为它们应该相对简单，可以提供占位符。换句话说，我们目前不需要数据库。我们可以简单地返回一个硬编码的值，以确保一切按预期工作。
- en: While this approach will give you some basic understanding of how FastAPI works,
    it does not mean that we won’t worry about topics such as pagination and asynchronous
    processing, which are required in a full-fledged production system to have a functional
    API. For now, keep in mind that returning large results such as thousands of ACH
    records not only takes time (resulting in the user waiting for the data), but
    presenting data on a UI becomes difficult. That is where the concept of allowing
    paging becomes useful. While UI components can do this with a large dataset, it
    will also become necessary to allow the API to handle requesting portions of the
    data. Likewise, uploading large ACH files may take time to process, and the user
    will be unsure whether the process was successful; furthermore, chances are the
    request will timeout from the user side. Using asynchronous processing, where
    a response is sent to let the user know the file was successfully uploaded and
    where further processing is done to load the file, becomes paramount. We will
    touch on this again in chapter 12.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法会给你一些关于FastAPI如何工作的基本理解，但这并不意味着我们不会担心诸如分页和异步处理等主题，这些主题在一个完整的生产系统中是必要的，以便拥有一个功能性的API。目前，请记住，返回大量结果，如数千条ACH记录，不仅耗时（导致用户等待数据），而且在UI上呈现数据也变得困难。这就是允许分页的概念变得有用的地方。虽然UI组件可以处理大量数据集，但也将有必要允许API处理数据的一部分请求。同样，上传大量的ACH文件可能需要时间来处理，用户将不确定过程是否成功；此外，请求可能从用户端超时。使用异步处理，其中发送响应以让用户知道文件已成功上传，并且进行进一步处理以加载文件，变得至关重要。我们将在第12章再次涉及这一点。
- en: 'For now, we start with a simple project that has the following folder structure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们从以下文件夹结构的一个简单项目开始：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We make sure to install the following requirements for our IDE, which should
    be maintained in a requirements.txt like when using Docker. However, if we have
    simply dived in and started installing Python packages, then IDEs such as JetBrains
    Pycharm allow us to create a requirements.txt file based on the requirements for
    our project. In this sprint, we focus on gaining experience with APIs and FastAPI,
    so installing packages into the IDE works well for now:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保为我们的IDE安装以下要求，这些要求应像使用Docker时一样维护在requirements.txt中。然而，如果我们只是直接跳入并开始安装Python包，那么像JetBrains
    Pycharm这样的IDE允许我们根据项目需求创建一个requirements.txt文件。在这个冲刺中，我们专注于获得API和FastAPI的经验，所以现在将包安装到IDE中是可行的：
- en: '`pip` `install` `fastapi`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip` `install` `fastapi`'
- en: '`pip` `install` `pytest`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip` `install` `pytest`'
- en: '`pip` `install` `httpx`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip` `install` `httpx`'
- en: We keep the routers in a separate folder, which makes it easier to manage our
    application as it grows. We could also refer to the YAGNI principle and keep things
    simple by not using a router yet, but for time and space constraints, we are going
    to jump ahead slightly. The routers/files.py holds the API endpoints we will build
    in the upcoming sections. For now, we only focus on the basics, as shown in the
    following listing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将路由器保存在一个单独的文件夹中，这使得随着应用程序的增长更容易管理。我们也可以参考 YAGNI 原则，通过不使用路由器来保持简单，但鉴于时间和空间限制，我们将稍微提前一点。routers/files.py
    包含我们在接下来的章节中将要构建的 API 端点。现在，我们只关注以下列表所示的基本内容。
- en: Listing 4.1  Basic FastAPI router
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1  基本FastAPI路由器
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#1 Imports APIRouter from fastapi, needed to define URIs for the application'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从 fastapi 导入 APIRouter，用于定义应用程序的 URI'
- en: '#2 Creates a router that will be used to define specific URIs'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 创建一个用于定义特定 URI 的路由器'
- en: We then have the main.py that will pull in the router. The next listing shows
    how the router is incorporated into the application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有 main.py，它将引入路由器。接下来的列表显示了如何将路由器集成到应用程序中。
- en: Listing 4.2  FastAPI entry point
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2  FastAPI 入口点
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#1 Imports the fastapi class needed to create the application and our previously
    defined routes'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 导入创建应用程序和之前定义的路由所需的 fastapi 类'
- en: '#2 Defines the application and assigns it to the app'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义应用程序并将其分配给 app'
- en: '#3 Includes our routes in the application'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 在应用程序中包含我们的路由'
- en: With this basic structure, we can now look at adding some routes!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个基本结构，我们现在可以看看添加一些路由！
- en: 4.3.1 Retrieving files with GET /files
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 使用 GET /files 获取文件
- en: Our first route should return a list of files (and eventually some information
    from the file header record). For now, we are going to hardcode a response. Because
    we have already defined the router, we just need to add the following code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个路由应该返回文件列表（以及最终从文件头记录中获取的一些信息）。现在，我们将硬编码一个响应。因为我们已经定义了路由器，所以我们只需要添加以下代码。
- en: Listing 4.3  Our first API route
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3  我们的第一个 API 路由
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 A decorator that defines the route /files/'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 一个定义 /files/ 路由的装饰器'
- en: '#2 An asynchronous function that returns a hardcoded response for testing'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 一个异步函数，用于测试返回硬编码的响应'
- en: Here we defined the route with `@router.get("/files")` and an asynchronous function
    called `read_files` that returns a hardcoded JSON array of files.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `@router.get("/files")` 定义了路由，并调用了一个名为 `read_files` 的异步函数，该函数返回一个硬编码的文件
    JSON 数组。
- en: To check whether this code works, let’s write a `pytest`, as shown in the following
    listing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查这段代码是否工作，让我们编写一个 `pytest`，如下所示。
- en: Listing 4.4  Testing our first endpoint
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4  测试我们的第一个端点
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 Necessary imports for our test'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 测试所需的必要导入'
- en: '#2 Defines the TestClient'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 定义 TestClient'
- en: '#3 Defines a test to validate the /files endpoint'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 定义一个测试来验证 /files 端点'
- en: '#4 Makes a request to the /files endpoint'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 向 /files 端点发送请求'
- en: '#5 Asserts the response code is 200 and that the response is as expected'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 断言响应代码是 200，并且响应符合预期'
- en: Here we import `TestClient` and our app. Next, we define a client we can use
    to make requests. By calling the `get("/files"),` we make a `GET` request to the
    URL `/files`, and that should be a valid endpoint. We assert that we received
    the HTTP status of `200`. Then we have our hardcoded JSON string. This should
    match whatever we were returning from the endpoint in main.py. Even if running
    this test worked flawlessly, we still might have doubts whether it is running
    or validating our data properly. This can sometimes be a common concern when we
    first start using unit tests. We can play around with changing the status code
    we are checking (make it a value other than `200`), the JSON string, the endpoint
    from `"files"`, or the request type from `get`. Changing those values should cause
    the test to fail and verify that the test is validating our logic.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 `TestClient` 和我们的应用程序。接下来，我们定义一个客户端，我们可以用它来发送请求。通过调用 `get("/files")`，我们向
    URL `/files` 发送了一个 `GET` 请求，这应该是一个有效的端点。我们断言我们收到了 HTTP 状态码 `200`。然后我们有我们的硬编码 JSON
    字符串。这应该与我们在 main.py 的端点返回的内容相匹配。即使运行这个测试完美无缺，我们仍然可能怀疑它是否正确地运行或验证我们的数据。当我们刚开始使用单元测试时，这有时可能是一个常见的担忧。我们可以通过更改我们正在检查的状态码（使其不是
    `200` 的值）、JSON 字符串、从 `"files"` 的端点或请求类型从 `get` 来玩弄这些值。更改这些值应该导致测试失败，并验证测试是否正在验证我们的逻辑。
- en: Types of tests
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'Being able to run unit tests can be of great benefit to our development cycle.
    Unit tests give us a starting point to execute the code and go through the entire
    process—from start to finish. But what type of test is this: Is it a unit test,
    integration test, or something else?'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 能够运行单元测试对我们的开发周期有很大的好处。单元测试为我们提供了一个起点，执行代码并完成整个过程——从开始到结束。但这是什么类型的测试：这是一个单元测试、集成测试，还是其他类型的测试？
- en: We hope that you agree with the statement that developers should be testing
    their code. Different systems, conditions, and code bases can make testing difficult,
    but they should be released without some sort of testing on our end only in extremely
    rare circumstances.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您同意这样一个观点：开发者应该测试他们的代码。不同的系统、条件和代码库可能会使测试变得困难，但在极其罕见的情况下，他们才应该在没有某种测试的情况下发布。
- en: In most cases, developers will be primarily concerned with *unit tests*. The
    following figure shows that unit testing makes up the base of the testing pyramid,
    and this is where we will spend a lot of time creating tests, especially if we
    are following a test-driven development approach.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，开发者将主要关注*单元测试*。以下图显示单元测试构成了测试金字塔的基础，这是我们将在其中花费大量时间创建测试的地方，尤其是如果我们遵循测试驱动开发方法。
- en: '![](../Images/CH04_UN01_Kardell.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_UN01_Kardell.png)'
- en: A typical testing pyramid
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 典型的测试金字塔
- en: '*Component testing* may be where the previous test fits. It typically isolates
    a component such as an API so that we can evaluate it in isolation, which may
    help us catch more of the edge cases with malformed requests or other exception
    conditions.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*组件测试*可能是之前测试适合的地方。它通常将组件（如API）隔离，以便我们可以单独评估它，这有助于我们捕捉到更多异常情况，如格式不正确的请求或其他异常条件。'
- en: '*Integration tests* typically test multiple components and involve more dependencies
    than unit or component testing. As such, they are primarily concerned with ensuring
    the components can work together.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*集成测试*通常测试多个组件，比单元测试或组件测试涉及更多的依赖项。因此，它们主要关注确保组件可以协同工作。'
- en: '*UI testing* is the next layer. It shouldn’t be surprising that validating
    the UI using automated tools to crawl our UI validating functionality is similar
    to a user working through various tasks within the application.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*UI测试*是下一层。使用自动化工具爬取我们的UI验证功能来验证UI，这类似于用户在应用程序中完成各种任务，这并不令人惊讶。'
- en: At the top of the pyramid, we have *manual and exploratory testing*. This is
    where we (or the QA team) are trying to find ways to break the software or look
    for inconsistencies in the interface and behavior.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔的顶部，我们有*手动和探索性测试*。这是我们在尝试找到破坏软件或查找界面和行为不一致的方法的地方。
- en: We have just briefly touched on a few of the major testing categories here.
    There are additional types of testing and other ways to break it down, which we
    will cover later.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只是简要地提到了一些主要的测试类别。还有其他类型的测试和分解方法，我们将在稍后介绍。
- en: One final thing to note is that the tests become less isolated, slower, and
    more fragile as we move up the pyramid. We use the term “fragile” to indicate
    that the test gets harder to automate and is more likely to break because of its
    continually changing nature.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是，随着我们向上移动金字塔，测试变得越来越不独立、越来越慢、越来越脆弱。我们使用“脆弱”一词来表示测试变得越来越难以自动化，并且更有可能因为其不断变化的本性而崩溃。
- en: The test category is important only when it comes to the amount of setup and
    time it may take to get the test to work. Tests near the bottom of the pyramid
    are usually isolated and run quickly. So, at the moment, it is easy to run this
    test as a unit test because the API is returning a hardcoded value. Once we are
    further along and need to retrieve data from the database or other APIs, and components
    start coming into play, this test may not be appropriate to run as part of our
    development test suite but rather as part of a continuous integration and delivery
    (CI/CD) pipeline.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类别的重要性仅在于设置量和测试运行所需的时间。金字塔底部的测试通常比较独立且运行速度快。因此，目前，由于API返回的是硬编码的值，运行这个测试作为单元测试是很容易的。一旦我们进一步发展，需要从数据库或其他API检索数据，组件开始发挥作用，这个测试可能不适合作为我们的开发测试套件的一部分运行，而应该作为持续集成和持续交付（CI/CD）管道的一部分运行。
- en: While we believe it is useful to have these tests function as unit tests, the
    reality is we may want to work this as a BDD-style test since they could be considered
    higher-level tests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们认为这些测试作为单元测试是有用的，但现实情况是，我们可能希望以BDD风格的测试来处理这个问题，因为它们可以被认为是更高级别的测试。
- en: After ensuring that `pytest-bdd` is installed (`pip` `install` `pytest-bdd`),
    we create a `features` folder and a `step_defs` folder underneath our tests directory.
    Our folder structure for the tests folder should now look something like
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保`pytest-bdd`已安装（`pip install pytest-bdd`）后，我们在测试目录下创建一个`features`文件夹和一个`step_defs`文件夹。我们的测试文件夹的目录结构现在应该看起来像这样。
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `files.feature` will store our scenarios so we can work with the `/files`
    endpoint. Remember that we are defining the feature and various scenarios in this
    file using a `Given/When/Then` format. The following listing is a simple example
    of ensuring the status code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`files.feature`将存储我们的场景，以便我们可以处理/files端点。记住，我们在这个文件中使用`Given/When/Then`格式定义了特性和各种场景。以下列表是一个确保状态码的简单示例。'
- en: Listing 4.5  Feature file for our BDD test
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.5  BDD测试的特性文件
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, to power the feature file, we create corresponding step definitions in
    our test_files_feature.py.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了激活特性文件，我们在test_files_feature.py中创建相应的步骤定义。
- en: Listing 4.6  Step definitions for our BDD test
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6  BDD测试的步骤定义
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 Imports what is needed for testing'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 导入测试所需的模块'
- en: '#2 Loads the feature we defined in listing 4.5'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 加载我们在列表4.5中定义的特性'
- en: '#3 Creates a fixture to store responses from the API; the hash will be empty.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 创建一个固定值来存储API的响应；哈希将为空。'
- en: '#4 Decorates the function with “when” to handle the condition from our feature
    file. Note that the endpoint is pulled from the feature file and will be /files.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 使用“when”装饰器来处理特性文件中的条件。注意，端点是从特性文件中提取的，将是/files。'
- en: '#5 At the moment, we are only handling GET requests and will raise an exception
    for anything else. We will revist this line to add more functionality as needed.
    Notice how the response from the API is stored in our api_response fixture.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 目前，我们只处理GET请求，对于其他任何请求都将抛出异常。我们将重新访问此行以添加所需的功能。注意，API的响应存储在我们的api_response固定值中。'
- en: '#6 Decorates the function with “then” to handle the “then” phrase from our
    feature file. Note that the status_code which we specified in the feature file
    is substituted for status_code.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 使用“then”装饰器来处理特性文件中的“then”短语。注意，我们在特性文件中指定的状态码被替换为status_code。'
- en: '#7 Checks whether the status code was what we expected, which the feature file
    specified should be 200'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 检查状态码是否是我们预期的，即特性文件指定的应该是200'
- en: Here we loaded the `files.feature` and defined functions to handle the `when`
    and `then` of our feature file. In addition, we have a fixture to store the API
    response for use between the calls. Notice, that although we coded the `when`
    to accept multiple types of HTTP requests, we only support a `GET` request at
    this point. As we create a more robust API that incorporates `POST`, `PUT`, and
    `DELETE` requests, we will need to expand it, or we will receive a `NotImplementedError`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们加载了`files.feature`并定义了处理特性文件中的`when`和`then`的函数。此外，我们有一个固定值来存储API响应，以便在调用之间使用。注意，尽管我们编写了`when`以接受多种类型的HTTP请求，但我们目前只支持GET请求。随着我们创建一个更健壮的API，它包含`POST`、`PUT`和`DELETE`请求，我们需要扩展它，否则我们将收到`NotImplementedError`。
- en: Again, we may want to experiment with the scenario of changing the `GET` to
    another request just to see the `NotImplementedError`, and then change the status
    code or endpoint to get a feeling for different scenarios we may run into when
    coding.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可能想要尝试将`GET`请求改为其他请求的场景，只是为了看到`NotImplementedError`，然后更改状态码或端点，以了解我们可能在编码时遇到的不同场景。
- en: 4.3.2 Adding a file with POST /files
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 使用POST /files添加文件
- en: We now expand our example with a `POST` request to the same `/files` endpoint.
    This approach could potentially be used to upload our ACH file. Since we have
    an existing endpoint and tests established, let’s look at how we might work on
    this task from a more behavior-driven development approach. When working with
    a `POST` request we usually see a `201` `status` code, which means “created.”
    Since we are uploading a file and expecting it to be stored on the server, a `201`
    `CREATED` response should work for us. Thus, we can update our feature file with
    the scenario shown in the following listing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在通过向同一/files端点发送`POST`请求来扩展我们的示例。这种方法可能被用来上传我们的ACH文件。由于我们已经有了一个现有的端点和测试，让我们看看我们可能如何从更行为驱动的开发方法来处理这个任务。当处理`POST`请求时，我们通常看到`201`状态码，这意味着“已创建”。由于我们正在上传文件并期望它在服务器上存储，因此`201`
    `CREATED`响应对我们来说是合适的。因此，我们可以更新特性文件，如下列所示的场景。
- en: Listing 4.7  BDD test for our `POST` request
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.7  `POST`请求的BDD测试
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 We are reusing the same feature file here, so we do not need to adjust any
    of the “when” or “then” decorators.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们在这里重用了相同的特性文件，因此我们不需要调整任何“when”或“then”装饰器。'
- en: When we run this test, we should first receive the `NotImplementedError` since
    we have not handled our client making a `POST` request, which we address now with
    the following code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个测试时，我们首先应该收到 `NotImplementedError`，因为我们没有处理客户端发出的 `POST` 请求，我们现在用以下代码解决这个问题。
- en: Listing 4.8  Updating our steps to support the `POST` request
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.8  更新我们的步骤以支持 `POST` 请求
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '#1 Handling of the previous request remains the same.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 对之前请求的处理保持不变。'
- en: '#2 We now add a way to handle POST requests.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 现在我们添加一种处理 POST 请求的方法。'
- en: '#3 Continues to alert developers when they try to do something we have not
    yet coded for'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 当开发者尝试执行我们尚未编写的功能时，会继续提醒开发者'
- en: 'Now that we are making a `POST` request, we should see an error returned from
    our server because we have not actually handled a `POST` request. Note that in
    the previous code, we have a hardcoded post value being used for the request.
    Eventually, we will update the test to make this dynamic, but for now, we just
    want to get the basic setup. Running our test again results in the test failing
    because we receive a `405` `METHOD` `NOT ALLOWED` status:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在发送 `POST` 请求，我们应该从我们的服务器收到一个错误，因为我们实际上没有处理 `POST` 请求。请注意，在之前的代码中，我们使用了一个硬编码的
    post 值用于请求。最终，我们将更新测试以使其动态化，但就目前而言，我们只想得到基本设置。再次运行我们的测试会导致测试失败，因为我们收到了 `405` `METHOD`
    `NOT ALLOWED` 状态码：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This makes perfect sense because we have not actually coded the server to handle
    our `POST` request. Let’s jump over to the `app/routers/files.py` and implement
    it (feel free to give it a shot before moving on).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全合理，因为我们实际上并没有编写服务器代码来处理我们的 `POST` 请求。让我们跳转到 `app/routers/files.py` 并实现它（在继续之前，你可以尝试一下）。
- en: Listing 4.9  Defining our `POST` endpoint
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.9  定义我们的 `POST` 端点
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 Updates the import to include the Request object'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 更新导入以包括请求对象'
- en: '#2 Previous endpoint implementation'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 之前的端点实现'
- en: '#3 Creates a function decorated with the POST verb and the URI, which is going
    to return a hardcoded value for now'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 创建一个用 POST 动词和 URI 装饰的函数，现在将返回一个硬编码的值'
- en: Rerunning the test still fails, but this time because we are returning a `200`
    code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行测试仍然失败，但这次是因为我们返回了一个 `200` 状态码。
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is technically fine since we have not created anything. However, let’s
    look at how we can update the status code because we will be creating data in
    the future. We update our files.py to include an import of status and update the
    `@router.post` as shown in the following listing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这是可以的，因为我们没有创建任何东西。然而，让我们看看我们如何更新状态码，因为我们将在未来创建数据。我们将更新 `files.py` 以包含对
    `status` 的导入，并更新 `@router.post`，如下所示。
- en: Listing 4.10  Supporting the `201` `status`
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10  支持状态 `201`
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#1 We import that status object from fastapi.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们从 fastapi 导入那个状态对象。'
- en: '#2 Previous code'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 之前的代码'
- en: '#3 We update the decorator to specify status_code along with a 20 1 .'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 我们更新装饰器以指定状态码和 20 1 。'
- en: Setting the `status_code` will return the `201` for all cases, and we can now
    rerun our test and see that it passes. Note that setting the status code this
    way will cause this endpoint to always return a `201`. Later, as we expand our
    APIs, we will explore other ways of setting that status code so that it allows
    us to have finer control over them. This finer control will allow us to specify
    additional status codes when errors are encountered in our APIs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `status_code` 将在所有情况下返回 `201`，现在我们可以重新运行我们的测试，并看到它通过了。请注意，以这种方式设置状态码将导致此端点始终返回
    `201`。稍后，当我们扩展我们的 API 时，我们将探索其他设置状态码的方法，以便我们可以更精细地控制它们。这种更精细的控制将允许我们在 API 中遇到错误时指定额外的状态码。
- en: 4.3.3 Finishing the rest of the APIs
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 完成其余的 API
- en: In the previous section, we created two APIs to support getting a hardcoded
    list of files and posting a file. You should have enough knowledge of the basics
    to create the remaining endpoints and unit tests on your own. Take a few minutes
    to create some unit tests for the remaining endpoints and then code up the remaining
    APIs to get those tests to pass.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了两个 API 来支持获取硬编码的文件列表和上传文件。你应该有足够的关于基础知识的了解来创建剩余的端点和单元测试。花几分钟时间为剩余的端点创建一些单元测试，然后编写剩余的
    API 代码，以使这些测试通过。
- en: 4.4 Adding our API to Docker
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 将我们的 API 添加到 Docker
- en: Fantastic! Now that we have built our endpoints, we can run these APIs in a
    Docker container. We gained a lot of experience with Docker in chapter 2, so we
    can use that here. Essentially, we just need the API container from the previous
    chapter updated with the code we did here. Let’s see how we can get this code
    up and running in Docker.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们已经构建了端点，我们可以在Docker容器中运行这些API。在第2章中，我们获得了大量的Docker经验，所以我们可以在这里使用它。本质上，我们只需要将上一章中的API容器更新为我们这里所做的代码。让我们看看如何将这段代码在Docker中运行起来。
- en: 4.4.1 Preparing the project
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 准备项目
- en: We have tested our code and should feel comfortable deploying it. Having faith
    in our suite of tests is needed for continuous integration and delivery. If you
    are not comfortable with deploying code after it passes all your tests, ask yourself
    why. Then figure out what additional steps and safeguards you need. We may need
    additional tests to cover edge cases, load testing, better coverage, static code
    analysis, and similar. The idea of automated tests is to help improve software
    delivery time and quality.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经测试了我们的代码，应该对部署感到舒适。对测试套件的信心是持续集成和交付所必需的。如果你在所有测试通过后对部署代码感到不舒服，问问自己为什么。然后找出你需要采取的额外步骤和安全措施。我们可能需要额外的测试来覆盖边缘情况、负载测试、更好的覆盖率、静态代码分析等。自动化测试的想法是帮助提高软件交付时间和质量。
- en: So, we should be ready to deploy the code. However, we were previously using
    Uvicorn to run the FastAPI application. Remember that Uvicorn is ASGI (Asynchronous
    Server Gateway Interface) compliant and goes hand in hand with FastAPI. We need
    to include it in our current project for completeness’ sake. By installing it
    in our project, we will be able to generate a list of requirements for the project.
    So, ensure it is installed by using `pip` `install` `uvicorn`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该准备好部署代码。然而，我们之前使用Uvicorn来运行FastAPI应用程序。记住，Uvicorn是ASGI（异步服务器网关接口）兼容的，并且与FastAPI相辅相成。为了完整性，我们需要在我们的当前项目中包含它。通过在我们的项目中安装它，我们将能够生成项目的要求列表。所以，确保使用`pip
    install uvicorn`来安装它。
- en: After adding that additional dependency, we want to create a list of requirements
    that will be installed on the container. Remember that we had previously tried
    to keep the size of our Docker images to a minimum; furthermore, we should never
    only assume that a required package for our project exists on the server. Some
    IDEs will provide options to generate and manage the requirements.txt (the standard
    naming convention for Python requirements). However, if our IDE does not, we can
    always generate it from the command line with `pip` `freeze` `>` `requirements.txt`.
    Once we do that, we can review the requirements to ensure we have our desired
    packages. For instance, we may want to ensure that `uvicorn` and `fastapi` are
    present. Note that we may see additional requirements because of other dependencies
    we have installed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了额外的依赖项之后，我们希望创建一个列表，列出将在容器上安装的要求。记住，我们之前试图将Docker镜像的大小保持最小；此外，我们永远不应该只假设我们的项目所需的包存在于服务器上。一些IDE将提供生成和管理requirements.txt（Python要求的标准命名约定）的选项。然而，如果我们的IDE没有提供，我们总是可以从命令行使用`pip
    freeze > requirements.txt`来生成它。一旦我们这样做，我们就可以审查要求，确保我们有我们想要的包。例如，我们可能想确保`uvicorn`和`fastapi`存在。请注意，我们可能会看到由于我们安装的其他依赖项而出现的额外要求。
- en: With the requirements.txt and application folder in hand, we should have everything
    we need to run this in Docker.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有requirements.txt和应用程序文件夹，我们应该有在Docker中运行此代码所需的一切。
- en: 4.4.2 Docker setup
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 Docker设置
- en: Using our previous Docker experience (we could just copy a previous setup we
    have or start from scratch), we end up with a folder structure similar to
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前的Docker经验（我们可以复制我们已有的设置或从头开始），我们最终得到一个类似于以下结构的文件夹：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'where the app folder will contain our application code. At the moment, we only
    need a few source files: main.py, files.py, and the associated __init__.py. Although
    it is quite possible there may be additional files present specific to the IDE,
    there is no need to copy those over.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代码将存放在app文件夹中。目前，我们只需要几个源文件：main.py、files.py以及相关的__init__.py。尽管很可能存在一些特定于IDE的额外文件，但无需复制这些文件。
- en: The Dockerfile is where all the heavy lifting comes into play, but since our
    structure is the same, we do not need to change anything.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile是所有重头戏发生的地方，但由于我们的结构相同，我们不需要做任何更改。
- en: Listing 4.11  Our Dockerfile
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.11  我们的Dockerfile
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#1 Uses the alpine version of our Python image, so the size of the image is
    reduced'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用我们的Python镜像的alpine版本，因此镜像的大小减小'
- en: '#2 Ensures that we set the working directory for the container'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Copies the requirements to the image'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Updates the image and adds our additional dependencies'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Updates pip and installs the requirements'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '#6'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Copies the application code over to the image'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Starts uvicorn using our application and binding it to port 8000'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want the docker-compose.yml file to manage the building of the service
    for us. We will only have a single service at this point:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once these are in place, we should be able to run the usual `docker-compose`
    `build` and `docker-compose up` commands to start our container. After navigating
    our browser over to http://localhost:8000/files/, we should see the hardcoded
    value returned. In our case, it is `[{"file":"File_1"},{"file":"File_2"}]`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 Documenting our API
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Great! We are moving right along. While most of our API is hardcoded, we will
    continue to refine it as we move forward. However, the hardcoded values are only
    a part of what makes our API unusable. Our main problem is that nobody knows about
    it, and if they knew about it, how would they use it? We need documentation, and
    OpenAPI ([https://www.openapis.org/](https://www.openapis.org/)) comes to our
    rescue. This is a standard that allows us to create interactive documentation,
    and others to discover how the API works and how it generates client code and
    server code, among other things.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Remember API-driven design from the beginning of the chapter? Well, it is possible
    to give an OpenAPI specification to generate not only client code that would consume
    that API, but also the beginnings of the server-side code that will process those
    requests. With our Docker container up and running, we should have support out
    of the box for two flavors of documentation based on the OpenAPI specification.
    We will cover both documentation frameworks in the following sections.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.1 Swagger
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swagger is a set of tools for implementing the OpenAPI definition, but for historical
    reasons, many people may still refer to the OpenAPI definition as a Swagger specification,
    Swagger definition, or just Swagger. One of the most useful tools that you will
    likely find yourself using is Swagger Editor ([https://editor.swagger.io/](https://editor.swagger.io/)),
    which provides a side-by-side view of the OpenAPI definition and the resulting
    output. We can browse the Swagger documentation generated by FastAPI by navigating
    over to http://localhost:8000/docs. From there, we can view the documentation
    and experiment with the API. In this case, though, we want to click the link that
    should take us to http://localhost:8000/openapi.json and display the OpenAPI JSON.
    We can save or just copy and paste it into the online Swagger Editor. Figure 4.2
    is a sample screenshot of what we see.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH04_F02_Kardell.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2  Online Swagger Editor
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can play around with editing the API to gain a better understanding. Note
    that the online editor will prompt us to convert the JSON to YAML. We do not have
    to do this, but it does make it a little easier to edit in place.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The FastAPI framework supports several ways to help customize this documentation
    further, and we will be looking at that later on.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.2 Redoc
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FastAPI also supports Redoc, a free and open source tool for creating documentation.
    It provides a responsive three-panel view that has become popular, especially
    when working with larger APIs. Again, FastAPI provides this documentation out
    of the box, and we can see it by going to http://localhost:8000/redoc. Figure
    4.3 shows our sample API documentation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH04_F03_Kardell.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3  FastAPI documentation with Redoc
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Stripe, a popular payment service uses a similar three-panel view for their
    APIs. However, they created a tool called Markdoc ([https://markdoc.dev/](https://markdoc.dev/))
    that helps generate their documentation. There are more tools for handling API
    documentation and documentation in general. Futuristic FinTech likely already
    provides multiple tools for this purpose, so we want to follow our company’s current
    standards and suggest new tools as needed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.3 What is so great about API documentation?
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Documentation is one of those things that can be a struggle to get right, which
    is why the ability of FastAPI to provide us with OpenAPI documentation is so fantastic.
    Why? Because we can address one of the main documentation pain points, which is
    that it becomes stale quickly. With FastAPI, we can decorate our functions so
    that they generate the documentation, meaning we are less likely to be out of
    sync between what the documentation shows and what the code is doing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'That is not all though. We really only touched on the basics of what is available.
    In addition to being able to interactively see the APIs and try them out, here
    are some of the other cool features available:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Providing contact information in the form of URL or email addresses that end
    users can use
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Licensing information about your APIs
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointing to different servers (e.g., a test server, sandbox, or production)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing examples of requests/responses
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating server-side code to handle requests to the APIs
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating client-side code to interact with the APIs
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those are just some interesting features of designing APIs that conform to the
    OpenAPI specification. To learn more, check out *Designing APIs with Swagger and
    OpenAPI* (2022, Manning) by Joshua S. Ponelat and Lukas L. Rosenstock.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Managing our APIs
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, our API is small, consisting of a single `POST` and four `GET`
    statements. As our API grows, we need to have a strategy in place to manage it.
    This is best determined early as once APIs are in production and used by clients,
    it becomes more difficult to get a handle on the situation. Earlier, we mentioned
    the challenges of managing APIs such as versioning, documentation, monitoring,
    and so forth. We introduce the use of API management software so that you have
    some knowledge of its capabilities. We use API management as an umbrella term
    to cover the components that are found in the tool.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: We will incorporate an API Manager by WSO2 ([https://wso2.com/](https://wso2.com/))
    into our solution just to highlight some of the benefits of using an API manager.
    There are many API management solutions, but we have worked directly with WSO2
    and Mulesoft Anypoint ([https://mng.bz/4a2V](https://mng.bz/4a2V)) in the FinTech
    industry.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The WSO2 solution was easy to integrate into our solution. In addition, the
    documentation and tutorials for WSO2 are highly informative. As mentioned before,
    the use of Docker makes switching out components easy. Feel free to work on integrating
    other API managers into your solution that may better match your environment.
    The underlying mechanics and benefits from working with an API manager should
    be the same across the board.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.1 Benefits of API management
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: API managers can provide a more centralized approach to managing your APIs.
    If your business has multiple applications, they are likely to run on different
    servers, require different authentication, and expose multiple points to the outside
    world from a networking perspective. API managers provide a way to centralize
    your API management. They offer features that help monetize APIs, protect against
    potential attacks with rate limiting (which can also be used for monetization
    by supplying different tiers), and provide authentication/authorization.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of managing APIs in larger corporations is providing a central
    place for our users to access. If we have distinct services and business units
    in our company, they more than likely have different servers handling their APIs,
    yet want to provide a single experience to their users. We can have all the APIs
    sent to a single endpoint, and then the API manager can direct the request to
    the appropriate server in your network.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Once our requests are flowing through a centralized location, we can provide
    additional benefits to our users. One of them is a common interface to view and
    manage APIs as an end-user. If you have experience with APIs such as Google APIs,
    you should be aware that they offer a console to subscribe to various APIs. Sometimes,
    as companies grow and acquire other companies or merge, multiple products can
    be listed under the same company but provide a disjointed experience. By using
    an API manager, customers can view all your API offerings in one location.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: In addition to a better user experience, API managers offer increased analytics
    for our APIs. We can find out the number of calls, which API versions are in use,
    and a plethora of other insights. These analytics can lead to additional benefits
    such as rate limiting, load balancing, and monetization. Many APIs offer a pay-as-we-play
    model, where we are charged by API usage. API managers help facilitate that monetization
    process.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Finally, lifecycle management is another benefit of using a third-party tool
    such as WSO2\. Having a tool that helps enforce good lifecycle management practices
    provides a better experience for your customers and developers. We can see the
    distinct phases of an API and move APIs between different states. As shown in
    figure 4.4, we have an API that is currently in a published state, with options
    to bring it back to a created or deprecated state.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.2 Adding WSO2 API manager to our project
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we add WSO2 to our Docker setup, create a new folder named wso2, and
    place the following Dockerfile there:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is not much to our Dockerfile, but for consistency, we are sticking with
    the same layout as for previous setups. The real work happens in our docker-compose.yml
    file where we added the WSO2 service:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`port` `9443` is the management console where we will be doing most of our
    work, and the other ports (8243/8280) are the default ports that we ensure are
    exposed for their respective request types. Once we complete the usual `docker-compose`
    `build` and `docker-compose` `up` commands, we should be able to log in with the
    default username and password of `admin/admin`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH04_F04_Kardell.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4  Lifecycle management by WSO2
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 4.6.3 OpenAPI Version
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One problem that we encountered while defining our API to WSO2 was `OpenAPI`
    `content` `validation` `failed!` We loaded our OpenAPI specification into the
    online Swagger Editor and received the error `Structural` `error` `at` `openapi`
    `should` `match pattern "^3\.0\.\d(-.+)?$"` `pattern:` `^3\.0\.\d(-.+)?$`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The online Swagger Editor provided more information, and while it may be a little
    cryptic for those having no experience with regular expressions, it pointed to
    the version number being incorrect. It seems that both our Docker image for WSO2
    and the Swagger Editor do not currently support the latest version, but our FastAPI
    container does. To be sure we are using the correct version, we can double-check
    the OpenAPI site.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'ChatGPT was aware of the latest version, and when we posted the specification
    and asked it “Is this a valid OpenAPI specification?” we received the following
    response:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '**![image](../Images/Response-Chatgpt.png)** The OpenAPI specification you
    have posted is quite extensive, and at a glance, it seems to be structured correctly
    according to the OpenAPI 3.1.0 specifications. However, there are several nuances
    and small details in such a spec that need to be right for it to be valid. Here
    are some key points and common issues to check in a detailed spec like this.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Out of curiosity, we also tried to type in an invalid OpenAPI version (a much
    higher number), and ChatGPT said that it was not valid.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: We could go about tackling this problem in a few ways. It might be that there
    is an updated version of WSO2 that supports version 3.1.0\. However, this may
    not always be practical or quick in a production environment. We could look to
    downgrade FastAPI back to a previous version, but let’s assume there is functionality
    or bug fixes we need in the current version. In this case, we can update our API
    to report back the version of 3.0.0\. We could also just manually update the generated
    document before uploading it to WSO2\. However, there is also an option from within
    WSO2 to go directly to a URL, and we want to be able to employ that.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: We update our main.py, adding the following.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.12  Adjusting the OpenAPI version
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#1 Imports the get_openapi to allow us to customize the OpenAPI documentation;
    our previous code remains the same.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Defines a custom method'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '#3 These fields are required when calling get_openapi.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '#4 This is how we updated the OpenAPI version, and we had to fix a problem
    with WSO2 API manager.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: With that in place, if we rebuild and restart Docker, we should see `"openapi":"3.0.0"`
    instead of `"openapi":"3.1.0"` when viewing the JSON. We should also see the error
    resolved when viewed in the online Swagger Editor. Now, we can move on to creating
    the API in WSO2.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.4 Create an API in WSO2
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create an API by going through the following steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Click the Create API button.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under REST API, click Import Open API.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the OpenAPI URL, enter http://api:8000/openapi.json. We should see that
    the URL is validated by the system.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter a name (this is what the API will be known as in WSO2):'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The context is a way to distinguish the API URL in WSO2.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The version of the API.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The endpoint should be http://api:8000.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Create.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left pane, under Deploy, click Deployments.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Deploy.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the left pane, under Test, click Try Out:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will be directed to a similar Swagger Doc screen we saw earlier.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Generate Key.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Try out your APIs.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this API in place, the thing to notice is that we no longer make a request
    directly to our backend of http://api:8000\. Instead, we are going to make requests
    to https://localhost:8243/sample/0.0.1/files, which is the API manager, the context
    we chose, version, and our API. If we were to keep the API manager in place, we
    would stop exposing `port` `8000` in Docker so that we would force anyone interested
    in using the APIs through the single-entry point.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Note that as we currently have things set up, we won’t be saving the APIs permanently
    in the manager. So, remember that if we spend a lot of time setting up and configuring
    the APIs, anything we do is not permanent. We just wanted to set up this sandbox
    because we believe it is beneficial for you to have some experience with API management
    tools as you are likely to encounter them, especially in larger companies.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.5 Troubleshooting
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with an API manager and trying an API out, the most common error
    is
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Missing` `Credentials` error is caused by not selecting Generate Key before
    testing the API. When working with APIs in a production environment, we have to
    generate keys to use with the API either through a dashboard or through another
    API. In trying out our APIs, we are simply generating a temporary token to use
    for a brief time.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Working with an API manager or through the OpenAPI documentation pages is a
    helpful way of doing some initial evaluation and exploratory testing. However,
    once we settle on the APIs that we are going to use, we will need to start using
    additional tools that are more specialized and offer more robust functionality.
    The following sections illustrate some of the additional tools that we will be
    using.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 4.7 Testing with Postman
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Postman API platform is a popular tool to assist with the API lifecycle,
    collaboration between developers and other teams, as well as with API governance.
    We have primarily used it in testing capacity, although the platform offers many
    more capabilities.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: One of our favorite features is the ability to `import`/`export` `curl` versions
    of the command. `curl` is a ubiquitous command line utility that lets us get or
    send data using a variety of protocols. Many systems administrators will ask you
    for a `curl` equivalent of your `RESTful API` call when troubleshooting network/routing
    problems, so having the ability to produce one quickly and easily can be helpful
    for your entire team.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration between team members is also easy with Postman, and we have worked
    closely with our QA department to help develop test scripts that can be used for
    component and integration tests. Let’s look at how we can use Postman to validate
    data that is returned from our API. This is similar to what we might be doing
    with our unit tests while developing. However, the perspective is different because
    these may be run as part of a larger CI/CD pipeline or as part of QA testing process.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'We will continue to use the http://localhost:8000/files as our example. Of
    course, we could also take on the challenge of building a Postman test using an
    API manager layer. In Postman, we can create a collection that is used to group
    various requests. Then we can create a new `GET` request that points to the http://localhost:8000/files
    and click Send. We should see a nicely formatted JSON response that we have condensed
    here: `[{"file":"File_1"},{"file":"File_2"}]`.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have confirmed we are successfully connecting and receiving responses
    from the endpoint, we can add a few tests as well: click the Tests tab, and you
    can add some straightforward tests to get an idea of how the syntax works. First,
    let’s test that we have a valid `200` response code using the following listing.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.13  Sample Postman test
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '#1 Check if response format is json'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Check if response status is 200'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: When sending our request, we should see that the Test Results tab is populated,
    and we have a passing test. We add a few more tests, as shown in the following
    listing.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.14  More Postman tests
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Some of these tests are fragile—meaning they may be easily broken by the data
    or ordering—so we would expect this code to run against known data. Let’s use
    the test that looks for `File_1` to make it a little more robust. Because our
    data is in an array, we should be guaranteed when parsing that we will always
    parse them in that order, as opposed to an object where the `key`/`value` pairs
    may not always be returned in the way we see it. Still, the ordering of the JSON
    depends on factors outside of our control. We may be guaranteed that there is
    a `File_1`, but maybe it is not always returned first. How can we write a more
    robust test? What if we iterated through the array using a `for-each` loop?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.15  Using a `for-each` loop in Postman
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now we define a variable to indicate whether we found our desired item, so no
    matter where it appears in the array, we will find it. That is a more flexible
    test, and depending on your familiarity with the language, it might be your first
    attempt, and since it works, that may be enough. However, we can clarify the test
    a bit using the `some` method.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.16  Cleaning up our test
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that the `some` method is part of ECMAScript 5+ and is available outside
    of Postman. We have found that using Postman and these test scripts is a fantastic
    way to introduce newer QA resources to some type of automation. We just scratched
    the surface of what Postman has to offer; it is a great tool that we have seen
    used at various FinTech companies, as well as in other industries.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 4.8 Load testing with Locust
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we introduced the testing pyramid that primarily included testing types
    we would consider functional. Here, we introduce load testing, which falls into
    the nonfunctional testing category. Figure 4.5 outlines some types of testing.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH04_F05_Kardell.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 Software testing categories
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We want to ensure our APIs will be responsive, see where performance bottlenecks
    might be, and determine the capacity of the system for future planning. To prepare
    for all of that, we can look to a framework called Locust. Locust lets us use
    our budding Python skills to script tests used for load testing.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: We can easily get started by telling ChatGPT to “create a sample locust test
    for the http://localhost:8000/files endpoint,” and that provides some easy-to-follow
    steps. First, we want to install Locust with `pip` `install` `locust`. Also, we
    create a locustfile.py as follows.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.17  Simple Locust file
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: From the directory with locustfile.py, run the command `locust`. This will prompt
    you to open your browser to the default location http://localhost:8089\. Here,
    we will enter the number of users, spawn rate, the host, and how long it should
    run for (we clicked the Advanced options) to get that (see figure 4.6).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH04_F06_Kardell.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6  Starting a new test with Locust
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: From there, we can see the test run and get metrics around how our API is performing.
    Obviously, in this case, we are dealing with hardcoded values, so we will have
    a better opportunity later to come back and explore load testing our APIs. However,
    we can go ahead and get some experience with Locust and load testing now. Can
    we add tests for the other endpoints? If we need a reminder of what they were
    or what they should be returning, do not forget our living documentation at http://localhost:8000/docs.
    With additional tests, our code should look like the following listing.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.18  Locust test
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#1 Creates a FileUser class that inherits from HttpUser'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Sets a random wait time ranging from 1 to 2.5 seconds between requests to
    simulate a user pausing between actions'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Defines the host where the API requests will be sent'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '#4 The task decorator defines a user-simulated action.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Issues a GET against'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: the /files URI
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can rerun Locust to see it hitting the various endpoints. Although our
    endpoints are currently hardcoded, they will return the path parameters used.
    So, to make things more interesting, let’s add some code to each of these tests
    so that the parameters are unique, and that will show us hitting more endpoints
    in the Locust dashboard. Take a few minutes to see whether you can replace the
    hardcoded `file_ids` and `record_ids` with a random number, and then rerun the
    tests. The next listing shows the sample we came up with.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.19  Locust
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '#1 Generates a random file_id in the range from 1 to 9'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'After rerunning our tests, we can see a lot more variety in the endpoints being
    accessed. At this point, we may have noticed a problem when executing the tests
    in Locust on the dashboard. If not, take a look at the Failures tab in Locust.
    You should see a number of failures for the `POST` method on `/files` with the
    error `HTTPError(''405` `Client` `Error: Method` `Not` `Allowed` `for` `url:`
    `/files'')`. It looks like we missed something in our API code. But before checking
    it, let’s take a look at another big problem with our Locust tests—no `assert`
    statements.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to all our other tests, we want to make sure we are doing some sort
    of the `assert` statement. Let’s start by ensuring a valid response each time.
    Feel free to give that a try before reading further.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.20  Locust test
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '#1 Previous code setup from listing 4. 1 9'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses the Locust task decorator to define what Locust should be executing'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Defines a get_files method that executes a GET against the /files URI and
    checks the HTTP status was 200'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Makes requests using a random file_id in the range from 1 to 9'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Makes requests using a random file_id in the range from 1 to 9 and a random
    record_id in the range from 1 to 1 9'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have some assert statements, we can see an `Unexpected` `status`
    `code:` `405` in the Exceptions tab in addition to the Failures tab. Let’s check
    out the logs for the API container and see what’s there. The logs show two interesting
    problems:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As we saw, the `POST` is getting a `405` `Method` `Not` `Allowed`, and we also
    see a `307` `Temporary` `Redirect`. When we review our code that defines the endpoints,
    we see that there was a trailing slash for some endpoints but not for others:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: All the Locust requests left the trailing slash off the requests, so let’s make
    sure we are consistent in both the server and the client. In our example, we are
    going to remove the trailing slashes from the server portion. Rebuilding our containers
    and rerunning our tests give us a more consistent experience without errors in
    the logs or failures in Locust. We do see that we still have exceptions in Locust.
    This is because we coded all our assert statements to be expecting a `200` return
    code. However, when we refer to the documentation (or by looking at the code),
    we are reminded that our `POST` request responds with a `201` not `200`. With
    that taken care of, we see our tests running normally, with review failures, exceptions,
    and the associated analytics as shown in figure 4.7.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a graph  Description automatically generated](../Images/CH04_F07_Kardell.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7  View of successive Locust runs
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 4.9 Improving our code
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have both unit and load tests, you should feel comfortable working
    within your code to make improvements. Even though the code is straightforward,
    we can still take advantage of some benefits of FastAPI. This section shows the
    benefits of versioning, using prefixes, documentation, and validation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.1 Using a prefix and versioning
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that each of our endpoints in the router includes`/files`.
    While this works fine, we would also like to include a version number, as well
    as put the endpoint under an `api` endpoint in the URL. We want to end up with
    something like `/api/v1/files` as our initial standard. Using `/api` helps with
    organizing our APIs in one area. This can help with web server configuration,
    firewall rules, monitoring, and similar. The `v1` indicates the API version, and
    we can use it to support multiple API versions. Remember that once end-users start
    consuming the API, it is unwise to make breaking changes to your API that would
    force them to upgrade their applications. In these cases, you should provide the
    new API under `/v2` and eventually phase out prior versions when possible. Remember,
    the `/api/v1` is just a suggestion. You could name the endpoint anything you choose
    and use any versioning scheme based on your needs.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'We refactor our code to add the additional `/api/v1` to our endpoints by using
    the `prefix` parameter available in `APIRouter`. We update our files.py:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then, we remove the `/files` from each of our defined endpoints. Table 4.3 shows
    the differences.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.3 Effects of using a `prefix` parameter on the router
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Before | After |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: '| `@router.get("/files")` | `@router.get("")` |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: '| `@router.get("/files /{file_id}")` | `@router.get("/{file_id}")` |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: '| `@router.post("/files ", status_code=status.HTTP_201_CREATED)` | `@router.post("",
    status_code= status.HTTP_201_CREATED)` |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| `@router.get("/files /{file_id}/records")` | `@router.get("/{file_id}/records")`
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| `@router.get("/files /{file_id}/records/{record_id}")` | `@router.get("/{file_id}/records/{record_id}")`
    |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: We can see that by using the prefix, we now have a little less typing to do
    in each endpoint. We also need to rerun our unit tests to see whether things still
    work, and as we may have suspected, our tests are all failing with `404` `errors`
    because they are no longer going to the correct URL. We need to go ahead and update
    our unit tests to include the `/api/v1` and rerun them.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.2 Adding Pydantic
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pydantic is a widely used data validation library that comes bundled with FastAPI.
    We will incorporate it here to move away from our hardcoded strings (although
    we will still be returning hardcoded values). By adding Pydantic, we position
    our code to be more easily expanded in the future and are able to take advantage
    of some of its features for validation and documentation.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Later, we will look to build objects that model actual ACH files and records.
    For now, let’s take a look at how Pydantic will enhance our current APIs. Our
    first endpoint performs a `GET` on `/api/v1/files/{file_id}` where we previously
    returned a JSON string. It looks something like this (with the new prefix defined).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.21  Our previous hardcoded function
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, we create an `AchFile` class that will model the hardcoded value we were
    returning in the previous listing.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.22  Our first `Pydantic` class
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With that simple class in place, we can update the router to return an instance
    of that class.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.23  Updating our route to use our newly created `Pydantic` class
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Our unit tests should still pass, so we have not broken anything. If we were
    to start this up in Docker, we would run into an error of `ModuleNotFoundError:`
    `No` `module named` `'ach'`. This is because Python does not know where to find
    our class, and there is a possibility that we even forgot to copy it over! Before
    starting, add another `COPY` statement to your Dockerfile and set the `PYTHONPATH`.
    This should get our code up and running.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.24  Updating our Dockerfile
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now we should be able to bring down Docker, build, and bring our containers
    up again. If we take a look at the documentation, we will see an `AchFile` in
    the schema section. Let’s continue to expand on the documentation by adding a
    `Field` method to provide additional documentation.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.25  Expanding the documentation of our `AchFile` class
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '#1 Imports the Field function'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Adds parameters that will help with the OpenAPI documentation'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: By adding some examples, title, and description, the schema becomes more meaningful.
    Figure 4.8 shows how the OpenAPI documentation was updated.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '![A computer screen shot of a computer code  Description automatically generated](../Images/CH04_F08_Kardell.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8  Our updated `AchFile` schema
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is just the beginning of making our API user-friendly. We will expand on
    the concept as we build more APIs.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.3 Validation with Pydantic
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another benefit of Pydantic is its built-in validation capabilities. Validation
    of data entering the environment is a must in any production system (unless we
    are looking to test the resilience of our system). We should not rely on the UI
    or another system to validate data. If end-users are given free rein to enter
    any type of data in a field, they will do so, and it does not matter whether it
    makes sense. By combining Pydantic with FastAPI we can get a lot of validation
    for free where we may have once needed a lot of boilerplate code.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could enforce our `file_id` to be at least one character and
    contain only lowercase letters, underscores, and numbers. There are multiple approaches
    to enforcing such validations. In Pydantic, for instance, we can use a regular
    expression. By simply adding a pattern parameter to the field, we can enforce
    this constraint:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now that we are enforcing validation, let us jump back to `main.py` and add
    an exception handler when a validation error occurs. In this case, we will return
    a `400` `status` along with some detailed error information. We need to be careful
    that our exception messages do not leak sensitive information. In this case, it
    is a validation error triggered by missing or malformed fields. Still, this may
    be more appropriate for a development environment; in production, we may want
    to have a more robust method of translating the error into a known message to
    reduce the risk of exposing any sensitive data. Our exception handler should look
    like the following.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.26  Validation in Pydantic
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '#1 Decorator that registers a custom exception handler for ValidationError
    exceptions'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Ensures the HTTP status of 400 is returned along with error details'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: From here, we can add additional unit tests that confirm our validation behavior.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.27  Validating our exception behavior
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '#1 A test that passes validation'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Testing when we receive an exception condition. Notice the status code of
    400 and also a detailed message explaining what the pattern is.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: We add the positive case to show that we accept a lowercase `file_id`, and when
    uppercase values are used, we see the error telling us what the pattern should
    be.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we get a lot of useful information returned by default. Whether it
    is appropriate to show all this to your end-user may be another matter. API usage
    is in most cases fine to return detailed information, but we want to caution against
    revealing too much. For instance, you may notice that most sites do not tell you
    whether you have typed your username or password incorrectly. They simply say
    that one or the other is incorrect. This is a conscious design decision made to
    prevent malicious users from attempting to determine a list of valid users. Therefore,
    we sometimes return more generic information to the user and log the details in
    a system log. In this case, we are fine since it is acting as an interactive guide
    to the API.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.28  Detailed error that we receive from Pydantic
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We just touched on the basics of validation in Pydantic and FastAPI. A broad
    range of validation options in addition to regular expressions, as well as the
    ability to create custom validators, are available. We will explore this in later
    chapters.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.4 Troubleshooting Pydantic
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We may see a `500` `Internal` `Server` `Error` if we failed to copy over our
    updated API code. In our custom handler, we are intercepting the validation error
    thrown and returning a `400` `error` code. If we see something similar to error
    shown in the following listing, we have likely made that oversight or our handler
    is not working.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.29  Docker error in FastAPI
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: API-driven design promotes an API-first approach to development and ensures
    your software meets today’s distributed nature.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the design and testing of APIs is crucial for interaction with software
    components in microservices, distributed systems, and packages.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST is the primary API standard discussed, but GraphQL and SOAP are other important
    standards with unique pros and cons.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs act as contracts requiring adherence to usage terms and providing stable,
    scalable endpoints with SLAs for consumers.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API-driven design emphasizes clear use cases, versioning, comprehensive documentation,
    and robust security and validation.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective API monitoring and analytics are essential for capacity assessment,
    using tools such as OpenTelemetry, Prometheus, and Grafana.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial API tasks are simple, focusing on uploading and viewing files and records
    with a clear interaction flow.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FastAPI is used for building APIs, starting with basic `GET` endpoints, and
    supporting pagination and asynchronous processing for performance.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests validate API endpoints during development, while additional tests
    such as BDD can assess API behavior and performance.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API documentation via OpenAPI standards ensures alignment between implementation
    and user understanding, offering tools such as Swagger and Redoc.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API management tools such as WSO2 centralize management, provide lifecycle control,
    and facilitate API monitoring, monetization, and user experience.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
