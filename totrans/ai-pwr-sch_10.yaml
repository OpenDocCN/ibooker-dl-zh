- en: 8 Signals-boosting models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 信号增强模型
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Aggregating user signals to create popularity-based ranking model
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合用户信号以创建基于流行度的排名模型
- en: Normalizing signals for noisy query input
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对噪声查询输入进行信号归一化
- en: Fighting signal spam in crowdsourced signals
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在众包信号中打击信号垃圾邮件
- en: Applying time decays to prioritize recent signals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用时间衰减以优先考虑近期信号
- en: Blending multiple signal types together into one model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多种信号类型混合到一个模型中
- en: Choosing query-time versus index-time boosting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择查询时增强或索引时增强
- en: 'In chapter 4, we covered three different categories of reflected intelligence:
    signals boosting (popularized relevance), collaborative filtering (personalized
    relevance), and learning to rank (generalized relevance). In this chapter, we’ll
    dive deeper into the first of these, implementing signals boosting to enhance
    the relevance ranking of your most popular queries and documents.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，我们介绍了三种不同类别的反射智能：信号增强（流行相关性）、协同过滤（个性化相关性）和排序学习（泛化相关性）。在本章中，我们将深入探讨这些中的第一个，实现信号增强以增强您最热门的查询和文档的相关性排名。
- en: In most search engines, a relatively small number of queries tend to make up
    a large portion of the total query volume. These popular queries, called *head
    queries*, also tend to lead to more signals (such as clicks and purchases in an
    e-commerce use case), which enable stronger inferences about the popularity of
    top search results.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数搜索引擎中，相对较少的查询往往占很大一部分总查询量。这些热门查询，称为*头部查询*，也倾向于产生更多信号（例如电子商务用例中的点击和购买），这有助于对顶级搜索结果的热度做出更强的推断。
- en: Signals-boosting models directly harness these stronger inferences and are the
    key to ensuring your most important and highest-visibility queries are best tuned
    to return the most relevant documents.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 信号增强模型直接利用这些更强的推理，并确保您最重要的和最高可见度的查询得到最佳调整以返回最相关的文档。
- en: 8.1 Basic signals boosting
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 基本信号增强
- en: In section 4.2.2, we built our first signals-boosting model on the RetroTech
    dataset, enabling a significant boost in relevance for the most frequently searched
    and clicked search results. In this section, we’ll quickly recap the process of
    creating a simple signals-boosting model, which we’ll build upon in the upcoming
    sections to tackle some more advanced needs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在4.2.2节中，我们在RetroTech数据集上构建了我们的第一个信号增强模型，显著提高了最常搜索和点击的搜索结果的相关性。在本节中，我们将快速回顾创建简单信号增强模型的过程，我们将在接下来的章节中在此基础上解决一些更高级的需求。
- en: You’ll recall from section 4.2.2 that signals-boosting models aggregate useful
    user behavioral signals on documents (such as click signals) that occur as the
    result of a specific query. We used a search for `ipad` and boosted each document
    based on how many times it was previously clicked in the results for that search.
    Figure 8.1 demonstrates the before (no signals boosting) and after (signals boosting
    on) search results for the query `ipad`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您会记得从4.2.2节中，信号增强模型聚合了文档上的有用用户行为信号（如点击信号），这些信号是特定查询的结果。我们使用对`ipad`的搜索，并根据该搜索结果中该文档被点击的次数来增强每个文档。图8.1展示了查询`ipad`在应用信号增强前后的搜索结果。
- en: '![figure](../Images/CH08_F01_Grainger.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/CH08_F01_Grainger.png)'
- en: Figure 8.1 Before and after applying a signals-boosting model. Signals boosting
    improves relevance by pushing the most popular items to the top of the search
    results.
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1 应用信号增强模型前后的对比。信号增强通过将最受欢迎的项目推到搜索结果顶部来提高相关性。
- en: The signals-boosting model that led to the improved relevance in figure 8.1
    is a basic signals-boosting model. It looks at each document ever clicked for
    a given query and applies a boost equal to the total number of past clicks on
    that document for that query.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 导致图8.1中相关性提高的信号增强模型是一个基本的信号增强模型。它查看给定查询中每个曾经被点击的文档，并应用与该查询在该文档上的过去点击总数相等的增强。
- en: While this basic signals-boosting model covered in section 4.2.2 provides greatly
    improved relevance, it is unfortunately susceptible to some data biases and even
    manipulation. In section 8.2, we’ll discuss some techniques for removing noise
    in the signals to maximize the quality of your signals-boosting models and reduce
    the likelihood of undesirable biases.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章4.2.2节中介绍的基本信号增强模型极大地提高了相关性，但它不幸地容易受到一些数据偏差甚至操纵的影响。在8.2节中，我们将讨论一些去除信号中的噪声的技术，以最大化信号增强模型的质量并降低不希望偏差的可能性。
- en: 8.2 Normalizing signals
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 归一化信号
- en: It is important to normalize incoming user queries prior to aggregation so that
    variations are treated as the same query. Given that end users can enter any arbitrary
    text as a query, the aggregated signals are inherently noisy. The basic signals-boosting
    model from chapter 4 (and recapped in section 8.1) does no normalization. It generates
    aggregated boosts for each query and document pair, but since incoming queries
    haven’t been normalized into a common form, variations of a query will be treated
    as entirely separate queries. The following listing produces a list of top queries
    that boost the most popular iPad model in their search results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在聚合之前对传入的用户查询进行标准化非常重要，以便将变体视为相同的查询。鉴于最终用户可以将任何任意文本作为查询输入，聚合的信号本质上是有噪声的。第4章中的基本信号增强模型（在第8.1节中总结）没有进行标准化。它为每个查询和文档对生成聚合的增强，但由于传入的查询尚未标准化为共同的形式，查询的变体将被视为完全不同的查询。以下列表生成了一个列表，列出了在搜索结果中增强最受欢迎的iPad型号的顶级查询。
- en: Listing 8.1 Aggregating signals and retrieving relevant queries
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1 聚合信号并检索相关查询
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#1 Defines the signals aggregation query'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义信号聚合查询'
- en: '#2 Runs the aggregation from the signals collection to the basic_signals_boosts
    collection'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 从信号集合运行聚合到基本信号增强集合'
- en: '#3 Loads signals boosts for the specified query and collection'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 加载指定查询和集合的信号增强'
- en: '#4 The most popular iPad model'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 最受欢迎的iPad型号'
- en: '#5 Returns the list of top signals boosts for the specified document'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 返回指定文档的顶级信号增强列表'
- en: 'Output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This listing aggregates all signals by their queries and stores each query along
    with the number of occurrences into a new collection. You can see from the output
    that many variations of the same queries exist in the basic signals-boosting model.
    The biggest culprit of the variations seems to be case-sensitivity, as we see
    `iPad`, `ipad`, `Ipad`, and `IPad` as common variants. Spacing appears to be another
    problem, with `ipad` `2` versus `i pad` `2` versus `ipad2`. We even see singular
    versus plural representations in `ipad` versus `ipads`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表通过其查询聚合所有信号，并将每个查询及其出现次数存储到一个新的集合中。您可以从输出中看到，在基本信号增强模型中存在许多相同查询的变体。变体的最大罪魁祸首似乎是对大小写敏感，因为我们看到`iPad`、`ipad`、`Ipad`和`IPad`作为常见变体。空格似乎也是另一个问题，有`ipad`
    `2`与`i pad` `2`与`ipad2`之间的区别。我们甚至在`ipad`与`ipads`中看到了单数与复数表示。
- en: Keyword search fields usually normalize queries to be case-insensitive, use
    stemming to ignore plural versions of terms, and split on case changes and letter-to-number
    transitions between words. It is likewise useful to normalize signals, as keeping
    separate query terms and boosts for variations that are non-distinguishable by
    the search engine can be counterproductive. Failing to normalize terms diffuses
    the value of your signals, since the signals are divided across variations of
    the same keywords with lower boosts, as opposed to being coalesced into more meaningful
    queries with stronger boosts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 关键词搜索字段通常将查询标准化为不区分大小写，使用词干分析来忽略术语的复数形式，并在单词之间的大小写变化和字母到数字的转换处分割。同样，对信号进行标准化也很有用，因为保持不同查询术语和增强的变体，这些变体对于搜索引擎来说无法区分，可能是适得其反的。未能标准化术语会分散信号的价值，因为信号被分散到具有较低增强的相同关键词的变体中，而不是合并成更有意义的查询并具有更强的增强。
- en: It is up to you to figure out how sophisticated your query normalization should
    be prior to signals aggregation, but even just lowercasing incoming queries to
    make the signals aggregation case-insensitive can go a long way. The following
    listing demonstrates the same basic signals aggregation as before, but this time
    with the queries lowercased first.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在信号聚合之前，您需要确定查询标准化应该有多复杂，但即使只是将传入的查询转换为小写以使信号聚合不区分大小写，也能走很长的路。以下列表演示了与之前相同的信号聚合基本操作，但这次首先将查询转换为小写。
- en: Listing 8.2 Case-insensitive signals aggregation
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2 不区分大小写的信号聚合
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#1 Normalizing case by lowercasing each query'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 通过将每个查询转换为小写来标准化情况'
- en: '#2 Grouping by normalized query increases the count of signals for those queries,
    increasing the signals boost'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 按标准化查询分组增加了这些查询的信号计数，增加了信号增强'
- en: '#3 The most popular iPad model'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 最受欢迎的iPad型号'
- en: 'Output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The list of raw boosted queries is already looking much cleaner! Not only is
    there less redundancy, but notice that the strength of the signals boosts has
    increased, because more signals are being attributed to a canonical form of the
    query (the lowercased version).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 原始增强查询列表看起来已经整洁多了！不仅冗余更少，而且请注意，信号增强的强度已经增加，因为更多的信号被归因于查询的规范形式（小写版本）。
- en: Lowercasing the queries and maybe removing whitespace or extraneous characters
    is often sufficient normalization for queries prior to aggregating signals. The
    important takeaway from this section, though, is that the signals-boosting model
    becomes stronger the more you can ensure that identical queries are treated as
    the same when aggregated.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将查询转换为小写，也许删除空白或多余的字符，通常在聚合信号之前对查询进行充分规范就足够了。然而，本节的重要启示是，信号增强模型越强，你就能确保在聚合时将相同的查询视为相同。
- en: Variations in queries aren’t the only kind of noise we need to worry about in
    our data. In the next section, we’ll talk about how we can overcome significant
    potential problems caused by spam in our user-generated click signals.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 查询中的变化并不是我们需要担心数据中的唯一类型的噪声。在下一节中，我们将讨论如何克服由垃圾邮件引起的潜在的重大问题。
- en: 8.3 Fighting signal spam
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 拒绝信号垃圾邮件
- en: Anytime we use crowdsourced data, such as click signals, to influence the behavior
    of the search engine, we need to ask ourselves “How might the data inputs be manipulated
    to create an undesirable result?” In this section, we’ll demonstrate how the search
    engine can be spammed with click signals to manipulate search results, and how
    you can stop it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候我们使用如点击信号这样的众包数据来影响搜索引擎的行为时，我们需要问自己“数据输入如何被操纵以产生不理想的结果？”在本节中，我们将展示如何通过点击信号垃圾邮件来操纵搜索结果，以及如何阻止它。
- en: 8.3.1 Using signal spam to manipulate search results
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 使用信号垃圾邮件来操纵搜索结果
- en: Let’s imagine we have a user who, for whatever reason, really hates *Star Wars*
    and thinks that the most recent movies are complete garbage. They feel so strongly,
    in fact, that they want to ensure any searches for `star wars` return a physical
    trash can for purchase as the top search result. This user knows a thing or two
    about search engines and has noticed that your killer relevance algorithms seem
    to be using user signals and signals boosting. Figure 8.2 shows the default response
    for the query `star` `wars`, with signals boosting bringing the most popular products
    to the top of the search results.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象有一个用户，出于某种原因，非常讨厌*星球大战*，并认为最新的电影完全是垃圾。他们感情如此强烈，以至于他们想要确保任何搜索`star wars`都能返回作为顶级搜索结果的物理垃圾桶。这个用户对搜索引擎略知一二，并注意到你的杀手级相关性算法似乎在使用用户信号和信号增强。图8.2显示了查询`star`
    `wars`的默认响应，信号增强将最受欢迎的产品带到搜索结果的顶部。
- en: '![figure](../Images/CH08_F02_Grainger.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH08_F02_Grainger.png)'
- en: Figure 8.2 The most popular search results for the query `star wars`, with signals
    boosting turned on. These are the expected results when there is no malicious
    signal spam.
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2 在查询`star wars`时最受欢迎的搜索结果，信号增强已开启。在没有恶意信号垃圾邮件的情况下，这些是预期的结果。
- en: The user decides that since your search engine ranking is based upon popular
    items, they will spam the search engine with a bunch of searches for `star wars`.
    They will follow up each search with fake clicks on the Star Wars–themed trash
    can they found, attempting to make the trash can show up at the top of the search
    results.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 用户决定既然你的搜索引擎排名基于流行项目，他们将通过大量搜索`star wars`来垃圾邮件搜索引擎。他们将跟随每次搜索后对找到的星战主题垃圾桶的虚假点击，试图使垃圾桶出现在搜索结果的顶部。
- en: In order to simulate this scenario, we’ll run a simple script in the following
    listing to generate 5,000 queries for `star wars` and 5,000 corresponding clicks
    on the trash can after running that query.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这种场景，我们将在以下列表中运行一个简单的脚本，以生成5,000个`star wars`查询和在该查询后对垃圾桶进行5,000次相应的点击。
- en: Listing 8.3 Generating spam query and click signals
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3 生成垃圾查询和点击信号
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 Document for the trash can the spammer wants to move to the top of the search
    results'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将垃圾邮件想要移至搜索结果顶部的内容文档'
- en: '#2 Generates and sends 5,000 query and click signals to the search engine'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 生成并发送5,000个查询和点击信号到搜索引擎'
- en: '#3 Generates and sends 5,000 query and click signals to the search engine'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 生成并发送5,000个查询和点击信号到搜索引擎'
- en: '#4 Runs the signals aggregation to generate the signals-boosting model including
    the spammy signals'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 运行信号聚合以生成包括垃圾信号的信号增强模型'
- en: Listing 8.3 sends thousands of spammy query and click signals to our search
    engine, modeling the same outcome we would see if a user searched and clicked
    on a particular search result thousands of times. The listing then reruns the
    basic signals aggregation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 向我们的搜索引擎发送数千个垃圾查询和点击信号，模拟了如果用户搜索并点击特定的搜索结果数千次我们会看到的结果。该列表然后重新运行基本的信号聚合。
- en: To see the effect of the malicious user’s spammy click behavior on our search
    results, the following listing runs a search for the query `star wars`, now incorporating
    the manipulated signals-boosting model.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到恶意用户垃圾点击行为对我们搜索结果的影响，以下列表运行了查询 `star wars`，现在结合了操纵后的信号增强模型。
- en: Listing 8.4 Search results affected by spam user signals
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.4 受垃圾用户信号影响的搜索结果
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '#1 Loads signals boosts from the signals-boosting model that included the spammy
    signals'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从包含垃圾信号的信号增强模型中加载信号增强'
- en: '#2 Boosts the star wars query using the signals-boosting model'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用信号增强模型提升星球大战查询'
- en: Figure 8.3 shows the new manipulated search results generated from listing 8.4,
    with the Star Wars trash can in the top spot.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 显示了从列表 8.4 生成的新的操纵后的搜索结果，其中星球大战垃圾桶位于顶部位置。
- en: '![figure](../Images/CH08_F03_Grainger.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/CH08_F03_Grainger.png)'
- en: Figure 8.3 Search results manipulated by a user spamming the search engine with
    fake signals to affect the top result. The user was able to modify the top result
    just by clicking on it many times.
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.3 用户通过向搜索引擎发送虚假信号来操纵搜索结果。用户只需多次点击就能修改顶部结果。
- en: The spammer was successful, and these manipulated search results will now be
    seen by every subsequent visitor who searches for `star wars` on the RetroTech
    website! Looks like we’re going to need to make our signals-boosting model more
    robust to combat this kind of signal spam.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾邮件发送者成功了，这些被操纵的搜索结果现在将出现在每个在 RetroTech 网站上搜索 `star wars` 的后续访客面前！看起来我们需要使我们的信号增强模型更加健壮，以对抗这种信号垃圾。
- en: 8.3.2 Combating signal spam through user-based filtering
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 通过基于用户的过滤来对抗信号垃圾
- en: If you are going to use crowdsourced data like user signals to influence the
    search engine ranking, it’s important to take steps to minimize users’ ability
    to manipulate your signals-based ranking algorithm.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用如用户信号这样的众包数据来影响搜索引擎排名，那么采取步骤最小化用户操纵基于信号的排名算法的能力是很重要的。
- en: To combat the Star Wars trash can problem we just demonstrated, the simplest
    technique is to ensure that duplicate clicks by the same user only get one “vote”
    in the signals-boosting aggregation. That way, whether a malicious user clicks
    one time or a million times, their clicks only count as one signal and therefore
    have no material effect on the signals-boosting model. The following listing reworks
    the signals aggregation query to only count unique click signals from each user.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对抗我们刚刚展示的星球大战垃圾桶问题，最简单的技术是确保同一用户重复点击只获得信号增强聚合中的一个“投票”。这样，无论恶意用户点击一次还是一百万次，他们的点击只算作一个信号，因此对信号增强模型没有实质性的影响。以下列表重新设计了信号聚合查询，只计算每个用户的唯一点击信号。
- en: Listing 8.5 Deduplicating noisy user signals
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.5 去除噪声用户信号
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '#1 Signal date is the most recent signal from the user if there are duplicates.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 信号日期是如果有重复的用户最新的信号。'
- en: '#2 Group by user to limit each user to one “vote” per query/doc pair in the
    signals-boosting model.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 按用户分组以限制每个用户在信号增强模型中对每个查询/文档对只有一个“投票”。'
- en: If we rerun the `star wars` query from listing 8.3 with this new `signals_boosts_
    anti_spam` model, we’ll see that our normal search results have returned and look
    the same as in figure 8.2\. This is because the extra, spammy signals from our
    malicious user have all been reduced to a single bad signal, as shown in table
    8.1\.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用新的 `signals_boosts_anti_spam` 模型重新运行列表 8.3 中的 `star wars` 查询，我们会看到我们的正常搜索结果已经返回，看起来与图
    8.2 中的相同。这是因为恶意用户的额外垃圾信号都被减少为单个不良信号，如表 8.1 所示。
- en: Table 8.1 The 5,000 spammy signals have been deduplicated to 1 signal in the
    antispam signals-boosting model.
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 8.1 5,000 个垃圾信号在反垃圾信号增强模型中已去重为 1 个信号。
- en: '| model | query | doc | boost |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 模型 | 查询 | 文档 | 增强 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Before spam signals `(normalized_signals_boosts)`  | star wars  | 400032015667  |
    0 (no signals yet)  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 在垃圾信号之前 `(normalized_signals_boosts)` | star wars | 400032015667 | 0（尚未有信号）|'
- en: '| After spam signals `(normalized_signals_boosts)`  | star wars  | 400032015667  |
    5000  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 在处理垃圾邮件信号 `(normalized_signals_boosts)` 之后 | 星球大战 | 400032015667 | 5000 |'
- en: '| After spam signals cleanup `(signals_boosts_anti_spam)`  | star wars  | 400032015667  |
    1  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 在清理垃圾邮件信号之后 `(signals_boosts_anti_spam)` | 星球大战 | 400032015667 | 1 |'
- en: You can see that the aggregated signals count in the `signals_boosts_anti_spam`
    model has a total much closer to the `normalized_signals_boosts` model that we
    built before the spam signals were generated. Since each user is limited to one
    signal per query/document pair in the `signals_boosts_anti_spam` model, the ability
    for users to manipulate the signals-boosting model is now substantially reduced.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`signals_boosts_anti_spam`模型中的聚合信号计数与我们在生成垃圾邮件信号之前构建的`normalized_signals_boosts`模型的总数非常接近。由于在`signals_boosts_anti_spam`模型中，每个用户在每个查询/文档对中仅限于一个信号，因此用户操纵信号增强模型的能力现在大大降低。
- en: You could, of course, identify any user accounts that appear to be spamming
    your search engine and remove their signals entirely from your signals-boosting
    aggregation, but reducing the reach of the signals through deduplication is simpler
    and often accomplishes the same end goal of restoring a good, crowdsourced relevance
    ranking.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以识别出任何似乎在垃圾邮件你的搜索引擎的用户账户，并从你的信号增强聚合中完全删除它们的信号，但通过去重减少信号的范围要简单得多，并且通常可以达到恢复良好、众包相关排名的相同最终目标。
- en: 'In listing 8.5, we used user IDs as the key identifier to deduplicate spammy
    signals, but any identifier will work here: user ID, session ID, browser ID, IP
    address, or even some kind of browser fingerprint. As long as you find some value
    to uniquely identify users or to otherwise identify low-quality traffic (like
    bots and web scrapers), you can use that information to deduplicate signals. If
    none of those techniques work, and you have too much noise in your click signals,
    you can also choose to only look at click signals from known (authenticated) users
    who you can presumably be much more confident are legitimate traffic.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表8.5中，我们使用用户ID作为关键标识符来去重垃圾邮件信号，但任何标识符在这里都适用：用户ID、会话ID、浏览器ID、IP地址，甚至某种类型的浏览器指纹。只要你能找到一些可以唯一标识用户或识别低质量流量（如机器人和网络爬虫）的价值，你就可以使用这些信息来去重信号。如果上述技术都不奏效，并且你的点击信号中噪音太多，你也可以选择只查看已知（已认证）用户的点击信号，你可能会更有信心认为这是合法流量。
- en: One final way to mitigate signal spam is to find a way to separate the important
    signal types from the noisy ones that can be easily manipulated. For example,
    generating signals from running queries and clicking on search results is easy.
    Signals from purchasing a product are much harder to manipulate, as they require
    users to log in or enter payment information before a purchase will be recorded.
    The odds of someone maliciously purchasing 5,000 Star Wars trash cans are quite
    low, because there are multiple financial and logistical barriers to doing this.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 减少信号垃圾的一种最终方法是通过找到一种方法来区分重要的信号类型和那些容易被操纵的嘈杂信号。例如，从运行查询和点击搜索结果中生成信号是很容易的。而从购买产品中产生的信号则要难以操纵得多，因为它们需要用户在购买记录之前登录或输入支付信息。恶意购买5000个星球大战垃圾桶的可能性相当低，因为这样做存在多个金融和物流障碍。
- en: Not only is it valuable to weight purchases as stronger signals than clicks
    from the standpoint of fighting spam, it is also valuable from a relevance standpoint,
    because purchases are more clear indicators of intent. In the next section, we’ll
    walk through how we can combine different signal types into a signals-boosting
    model that considers the relative importance of each different signal type.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅从打击垃圾邮件的角度来看，将购买行为视为比点击更强烈的信号是有价值的，而且从相关性的角度来看，这也是有价值的，因为购买行为更能清楚地表明用户的意图。在下一节中，我们将介绍如何将不同的信号类型组合成一个考虑每种不同信号类型相对重要性的信号增强模型。
- en: 8.4 Combining multiple signal types
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 组合多种信号类型
- en: Thus far we’ve only worked with two signal types—queries and clicks. For some
    search engines (such as web search engines), click signals may be the only good
    source of crowdsourced data available to build a signals-boosting model. Many
    different signal types exist, however, which can provide additional and often
    much better inputs for building a signals-boosting model.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理了两种信号类型——查询和点击。对于某些搜索引擎（如网络搜索引擎），点击信号可能是构建信号增强模型可用的唯一良好来源的众包数据。然而，存在许多不同的信号类型，它们可以为构建信号增强模型提供额外的、通常更好的输入。
- en: 'In our RetroTech dataset, we have several kinds of signals that are common
    to e-commerce use cases:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 RetroTech 数据集中，我们有几种在电子商务用例中常见的信号：
- en: query
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询
- en: click
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击
- en: add-to-cart
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加到购物车
- en: purchase
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买
- en: While clicks in response to queries are helpful, they don’t necessarily imply
    a strong interest in the product, as someone could just be browsing to see what’s
    available. If someone adds a product to their shopping cart, this typically represents
    a much stronger signal of interest than a click. A purchase is an even stronger
    signal that a user is interested in a product, as the user is willing to pay money
    to receive the item for which they searched.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对查询的点击有帮助，但它们并不一定意味着对产品的强烈兴趣，因为某人可能只是浏览以查看有什么可用。如果某人将产品添加到他们的购物车中，这通常比点击代表更强的兴趣信号。购买是一个更强的信号，表明用户对产品感兴趣，因为用户愿意为搜索到的商品支付金钱。
- en: 'While some e-commerce websites may receive enough traffic to ignore click signals
    entirely and only focus on add-to-cart and purchase signals, it is often more
    useful to include all signal types when calculating signals boosts. Thankfully,
    combining multiple signal types is as simple as assigning relative weights as
    multipliers to each signal type when performing the signals aggregation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些电子商务网站可能拥有足够的流量来完全忽略点击信号，而只关注添加到购物车和购买信号，但在计算信号提升时，通常包括所有信号类型更有用。幸运的是，在信号聚合时，将相对权重作为乘数分配给每个信号类型非常简单：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By counting each click as 1 signal, each add-to-cart as 10 signals, and each
    purchase as 25 signals, a purchase carries `25` times as much weight and an add-to-cart
    carries `10` times as much weight as a click in the signals-boosting model. This
    helps reduce noise from less reliable signals and boosts more reliable signals
    while still making use of the large volume of less reliable signals in cases where
    better signals are less prevalent (like new or obscure items).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '通过将每个点击计为 1 个信号，每个添加到购物车计为 10 个信号，每个购买计为 25 个信号，在信号提升模型中，购买比点击重 25 倍，添加到购物车比点击重
    10 倍。这有助于减少来自不可靠信号的噪声，同时提高更可靠信号的权重，同时在更好的信号不太普遍的情况下（如新产品或冷门商品）仍然利用大量不可靠信号。 '
- en: The following listing demonstrates a signals aggregation designed to combine
    different signal types with different weights.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表演示了一个信号聚合设计，旨在将不同权重的不同信号类型组合在一起。
- en: Listing 8.6 Combining multiple signal types with different weights
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.6 使用不同权重的多个信号类型组合
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**#1 Multiple signals are combined with different relative weights to calculate
    a total boost value.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1 通过将多个信号以不同的相对权重组合，来计算总的提升值。**'
- en: '#2 Each signal type is summed independently before being combined.**  **You
    can see from the SQL query that the overall boost for each query/document pair
    is calculated by counting all clicks with a weight of `1`, counting all add-to-cart
    signals and multiplying them by a weight of `10`, and counting all purchase signals
    and multiplying them by a weight of `25`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**#2 每种信号类型在组合之前都是独立求和的。**  **您可以从 SQL 查询中看到，每个查询/文档对的总体提升是通过计算所有点击（权重为 `1`），计算所有添加到购物车信号并将其乘以权重
    `10`，以及计算所有购买信号并将其乘以权重 `25` 来计算的。**'
- en: These suggested weights of 10x for add-to-cart signals and 25x for purchase
    signals should work well in many e-commerce scenarios, but these relative weights
    are also fully configurable for each domain. Your website may be set up such that
    almost everyone who adds a product to their cart purchases the product (for example,
    a grocery store delivery app, where the only purpose of using the website is to
    fill a shopping cart and purchase). In these cases, you could find that adding
    an item to a shopping cart adds no additional value, but that *removing* an item
    from a shopping cart should potentially carry a penalty, indicating that the product
    is a bad match for the query.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些建议的权重（添加到购物车信号为 10 倍，购买信号为 25 倍）在许多电子商务场景中应该效果良好，但这些相对权重也可以为每个领域完全配置。您的网站可能被设置为几乎每个人将产品添加到购物车都会购买该产品（例如，一个杂货店配送应用程序，使用网站的唯一目的是填充购物车并购买）。在这些情况下，您可能会发现将项目添加到购物车不会增加任何额外的价值，但*从购物车中移除*项目可能具有潜在的惩罚，表明该产品与查询不匹配。
- en: In this case, you may want to introduce the idea of *negative signals boosts*.
    Just as we’ve discussed clicks, add-to-carts, and purchases as signals of user
    intent, your user experience may also have numerous ways to measure user dissatisfaction
    with your search results. For example, you might have a thumbs-down button or
    a remove-from-cart button, or you may be able to track product returns after a
    purchase. You may even want to count documents in the search results that were
    skipped over and record a “skip” signal for those documents to indicate that the
    user saw them but didn’t show interest. We’ll cover the topic of managing clicked
    versus skipped documents in chapter 11 when we discuss click modeling.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可能想引入**负面信号增强**的概念。就像我们讨论点击、加入购物车和购买一样，作为用户意图的信号，你的用户体验也可能有无数种方式来衡量用户对你搜索结果的不满。例如，你可能有一个点赞按钮或从购物车中移除按钮，或者你可能能够在购买后跟踪产品退货。你可能甚至想要计算搜索结果中被跳过的文档，并为这些文档记录一个“跳过”信号，以表明用户看到了它们，但没有表现出兴趣。我们将在第11章讨论点击建模时，涵盖管理点击与跳过文档的主题。
- en: 'Thankfully, handling negative feedback is just as easy as handling positive
    signals: instead of just assigning increasingly positive weights to signals, you
    can also assign increasingly negative weights to negative signals. Here’s an example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，处理负面反馈与处理正面信号一样简单：你不仅可以对信号分配越来越积极的权重，还可以对负面信号分配越来越消极的权重。以下是一个例子：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This simple, linear function provides a highly configurable signals-based ranking
    model, taking in multiple input parameters and returning a ranking score based
    on the relative weights of those parameters. You can combine as many useful signals
    as you want into this weighted signals aggregation to improve the robustness of
    the model. Of course, tuning the weights of each of the signal types to achieve
    an optimal balance may take some effort. You can do this manually, or you can
    use a machine learning technique called learning to rank to do this. We’ll explore
    learning to rank in chapters 10 and 11.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的线性函数提供了一个高度可配置的基于信号的排名模型，它接受多个输入参数，并根据这些参数的相对权重返回一个排名分数。你可以将尽可能多的有用信号组合到这个加权信号聚合中，以提高模型的鲁棒性。当然，调整每种信号类型的权重以实现最佳平衡可能需要一些努力。你可以手动进行，或者可以使用一种称为学习排名的机器学习技术来完成。我们将在第10章和第11章中探讨学习排名。
- en: 'Not only is it important to weight different kinds of signals relative to each
    other, but it can also sometimes be necessary to weight the *same* kind of signals
    differently against each other. In the next section, we’ll discuss one key example
    of doing this: assigning higher value to more recent interactions.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅需要根据彼此的重要性对不同的信号进行加权，有时还可能需要将**相同**类型的信号以不同的方式相互加权。在下一节中，我们将讨论一个关键示例：对更近期的交互赋予更高的价值。
- en: 8.5 Time decays and short-lived signals
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 时间衰减和短暂信号
- en: Signals don’t always maintain their usefulness indefinitely. In the last section,
    we showed how signals-boosting models can be adjusted to weight different kinds
    of signals as more important than others. In this section, we’ll address a different
    challenge—factoring in the “temporal value” of signals as they age and become
    less useful.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 信号并不总是无限期地保持其有用性。在上一个章节中，我们展示了如何调整信号增强模型，使其将不同类型的信号视为比其他信号更重要。在本节中，我们将讨论一个不同的挑战——在信号随着时间的推移而变得不那么有用时，考虑信号的“时间价值”。
- en: 'Imagine three different search engine use cases:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 想象三种不同的搜索引擎使用场景：
- en: An e-commerce search engine with stable products
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有稳定产品的电子商务搜索引擎
- en: A job search engine
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个求职搜索引擎
- en: A news website
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新闻网站
- en: For an e-commerce search engine, like RetroTech, the documents (products) often
    stay around for years, and the best products are often those that have a long
    track record of interest.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像RetroTech这样的电子商务搜索引擎，文档（产品）通常可以持续多年，而最好的产品往往是那些有长期兴趣记录的产品。
- en: In a job search engine, the documents (jobs) may only stick around for a few
    weeks or months until the job is filled, and then they disappear forever. While
    the documents are present, however, newer clicks or job applications aren’t necessarily
    any more important as signals than older interactions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个求职搜索引擎中，文档（工作）可能只存在几周或几个月，直到工作被填补，然后它们永远消失。然而，当文档存在时，新的点击或求职申请并不一定比旧的交互作为信号更重要。
- en: In a news search engine, while the news articles stick around forever, newer
    articles are generally much more important than older articles, and newer signals
    are also more important than older signals, as people’s interests change on a
    daily, if not hourly, basis.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在新闻搜索引擎中，尽管新闻文章会永远存在，但新文章通常比旧文章更重要，新信号也比旧信号更重要，因为人们的兴趣每天，甚至每小时都在变化。
- en: Let’s dive into these use cases and demonstrate how to best handle the time-sensitivity
    of signals when performing signals boosting.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入这些用例，并展示在执行信号增强时如何最好地处理信号的时间敏感性。
- en: 8.5.1 Handling time-insensitive signals
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.1 处理非时间敏感信号
- en: 'In our RetroTech use case, our documents are intentionally old, having been
    around for a decade or more, and interest in them likely only increases as the
    products become older and more “retro”. As a result, we don’t often have massive
    spikes in popularity for items, and newer signals don’t necessarily carry significantly
    more importance than older signals. This type of use case is a bit atypical, but
    plenty of search use cases do deal with “static” document sets like this. The
    best solution in this case is the strategy we’ve already taken in this chapter:
    process all signals within a reasonable period of months or years and give them
    equal weight. When all time periods carry the same weight, the signals-boosting
    model likely doesn’t need to be rebuilt very often, since the model changes slowly
    over time. The frequent processing of signals is unnecessary computational overhead.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的RetroTech用例中，我们的文档故意很旧，已经存在十年或更长时间，随着产品变得越老越“复古”，对它们的兴趣可能只会增加。因此，我们很少看到物品流行度的巨大波动，新信号不一定比旧信号重要得多。这种用例有点不典型，但许多搜索用例确实处理像这样的“静态”文档集。在这种情况下，最好的解决方案是我们已经在本章中采取的策略：在合理的时间范围内处理所有信号，并给予它们相同的权重。当所有时间段具有相同的权重时，信号增强模型可能不需要经常重建，因为模型随时间缓慢变化。频繁处理信号是不必要的计算开销。
- en: In a job search use case, however, the scenario is very different. For the sake
    of argument, let’s say that on average it takes 30 days to fill a job opening.
    This means the document representing that job will only be present in the search
    engine for 30 days, and any signals collected for that document are only useful
    for signals boosting during that 30-day window. When a job is posted, it will
    typically be very popular for the first few days, since it is new and is likely
    to attract many existing job seekers, but all interactions with that job at any
    point during the 30 days are just as useful. In this case, all click signals should
    get equal weight, and all job application signals should likewise receive an equal
    weight (at a weight higher than the click signals). Given the very short lifetime
    of the documents, however, it is important that all signals be processed as quickly
    as possible to make the best use of their value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在职位搜索用例中，情况却非常不同。为了辩论的目的，让我们假设平均需要30天来填补一个职位空缺。这意味着代表该职位的文档将在搜索引擎中存在30天，为该文档收集的任何信号也只有在那30天的信号增强窗口内才有用。当职位发布时，它通常在前几天非常受欢迎，因为它新鲜，可能会吸引许多现有的求职者，但在30天内的任何时间与该职位的互动都同样有用。在这种情况下，所有点击信号应该得到相同的权重，所有职位申请信号也应同样得到相同的权重（权重高于点击信号）。然而，由于文档的寿命非常短，因此尽快处理所有信号以充分利用其价值是非常重要的。
- en: Use cases with short-lived documents, like in the job search use case, aren’t
    usually the best candidates for signals boosting, as the documents may be deleted
    by the time the signals-boosting model becomes any good. As a result, it can often
    make more sense to look at personalized models (like collaborative filtering,
    covered in chapter 9) and generalizable relevance models (like learning to rank,
    covered in chapters 10 and 11) for these use cases.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像职位搜索用例这样的短期文档用例，通常不是信号增强的最佳候选者，因为文档可能在信号增强模型变得有效之前就被删除。因此，对于这些用例，查看个性化模型（如第9章中介绍的协同过滤）和可推广的相关性模型（如第10章和第11章中介绍的排序学习）可能更有意义。
- en: In both the RetroTech and the job search use cases, the signals were just as
    useful for the entire duration of the document’s existence. In the news search
    use case, which we’ll look at next, the value of the signals declines over time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在RetroTech和职位搜索用例中，信号在整个文档存在期间都同样有用。在接下来的新闻搜索用例中，我们将看到信号的价值会随着时间的推移而下降。
- en: 8.5.2 Handling time-sensitive signals
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.2 处理时间敏感信号
- en: In a news search engine use case, the most recently published news usually gets
    the most interaction, so more recent signals are considerably more valuable than
    older signals. Some news items may be very popular and relevant for days or longer,
    but generally the signals from the last ten minutes are more valuable than the
    signals from the last hour, which are more valuable than the signals from the
    last day, and so on. News search is an extreme use case where signals both need
    to be processed quickly and where more recent signals need to be weighted as substantially
    more important than older signals.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在新闻搜索引擎用例中，最新发布的新闻通常获得最多的互动，因此较新的信号比旧信号更有价值。一些新闻条目可能非常受欢迎和相关性高，可能持续数天或更长时间，但通常来说，过去十分钟内的信号比过去一小时的信号更有价值，过去一小时的信号比过去一天的信号更有价值，依此类推。新闻搜索是一个极端用例，其中信号需要快速处理，并且较新的信号需要被赋予比旧信号大得多的权重。
- en: One easy way to model this is by using a decay function, such as a half-life
    function, which cuts the weight assigned to a signal by half (50%) over equally
    spaced time spans. For example, a decay function with a half-life of 30 days would
    assign 100% weight to a signal that happens “now”, 75% weight to a signal from
    15 days ago, 50% weight to a signal from 30 days ago, 25% weight to a signal from
    60 days ago, 12.5% weight to a signal from 90 days ago, and so on. The math for
    calculating a signal’s time-based weight using a decay function is
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的方式来模拟这种情况是使用衰减函数，例如半衰期函数，它将分配给信号的权重减半（50%）在等间隔的时间段内。例如，半衰期为30天的衰减函数会给“现在”发生的信号分配100%的权重，给15天前的信号分配75%的权重，给30天前的信号分配50%的权重，给60天前的信号分配25%的权重，给90天前的信号分配12.5%，依此类推。使用衰减函数计算信号基于时间的权重的数学公式是
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When applying this calculation, the `starting_weight` will usually be the relative
    weight of a signal based upon its type, such as a weight of `1` for clicks, `10`
    for add-to-cart signals, and `25` for purchase signals. If you are not combining
    multiple signal types, then the `starting_weight` will just be `1`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用这个计算时，`starting_weight` 通常是基于信号类型的相对权重，例如点击的权重为 `1`，加入购物车信号的权重为 `10`，购买信号的权重为
    `25`。如果你没有结合多种信号类型，那么 `starting_weight` 将只是 `1`。
- en: The `signal_age` is how old the signal is, and the `half_life` is how long it
    takes for the signal to lose half of its value. Figure 8.4 demonstrates how this
    decay function affects signal weights over time for different half-life values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`signal_age` 是信号的年龄，`half_life` 是信号减半其价值所需的时间。图8.4展示了这种衰减函数如何影响不同半衰期值下信号权重随时间的变化。'
- en: '![figure](../Images/CH08_F04_Grainger.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/CH08_F04_Grainger.png)'
- en: Figure 8.4 Signal decay over time based upon various half-life values. As the
    half-life increases, individual signals maintain their boosting power for longer.
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.4 基于各种半衰期值的信号衰减。随着半衰期的增加，单个信号保持其增强能力的时间更长。
- en: The 1-day half-life is very aggressive and is impractical in most use cases,
    as it is unlikely you would be able to collect enough signals in a day to power
    meaningful signals boosting, and the likelihood of your signals becoming irrelevant
    that quickly is low.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 1天的半衰期非常激进，在大多数用例中都不实用，因为你不太可能在一天内收集到足够的信号来增强有意义的信号，而且信号迅速变得无关的可能性也很低。
- en: The 30-day, 60-day, and 120-day half-lives are effective at aggressively discounting
    older signals while still keeping residual value from the discounted signals over
    a six to twelve month period. If you have very long-lived documents, you could
    push out even longer, making use of signals over the course of many years. The
    following listing demonstrates an updated signal aggregation query that implements
    a half-life of 30 days for each signal.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 30天、60天和120天的半衰期在积极折价旧信号的同时，仍然在六到十二个月期间保持折价信号的残余价值。如果你有非常持久的文档，你可以将时间推得更长，利用多年的信号。以下列表演示了一个更新后的信号聚合查询，为每个信号实现了30天的半衰期。
- en: Listing 8.7 Applying time decay to the signals-boosting model
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.7 将时间衰减应用于信号增强模型
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 The latest possible signal date. This should be now() in a live system,
    but it can be set to a fixed date for a frozen dataset like RetroTech.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 可能的最晚信号日期。在实时系统中，这应该是 now()，但对于像 RetroTech 这样的冻结数据集，可以设置为固定日期。'
- en: '#2 A function could be added here to differentiate weights for different signal
    types.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 可以在这里添加一个函数来区分不同信号类型的权重。'
- en: '#3 The half-life calculation'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 半衰期计算'
- en: '#4 Gets the most recent unique signal per user, query, and product combination'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 获取每个用户、查询和产品组合的最新唯一信号'
- en: '#5 Only includes signals up to the target date'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 只包括目标日期之前的信号'
- en: 'This decay function has a few unique configurable parameters:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个衰减函数有几个独特的可配置参数：
- en: It contains a `half_life_days` parameter, which calculates a weighted average
    using a configurable half-life, which we’ve set as `30` days to start.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含一个`half_life_days`参数，该参数使用可配置的半衰期计算加权平均值，我们将其设置为`30`天开始。
- en: It contains a `signal_weight` parameter, which can be replaced with a function
    returning a weight by signal type, as shown in the last section (“click” = 1,
    “add-to-cart” = 10, “purchase” = 25, etc.).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含一个`signal_weight`参数，可以替换为返回信号类型的函数，如上一节所示（“click” = 1，“add-to-cart” = 10，“purchase”
    = 25等）。
- en: It contains a `target_date` parameter, which is the date at which a signal gets
    the full value of `1`. Any signals before this date will be decayed based on the
    half-life, and any signals after this date will be ignored (filtered out).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含一个`target_date`参数，这是信号获得`1`的全值的日期。在此日期之前的任何信号都将根据半衰期衰减，而在此日期之后的任何信号都将被忽略（过滤掉）。
- en: Your `target_date` will usually be the current date, so that you are making
    use of your most up-to-date signals and assigning them the highest weight. However,
    you could also apply it to past periods if your documents have seasonal patterns
    that repeat monthly or yearly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`target_date`通常将是当前日期，这样你就可以利用你最新的信号并将它们分配最高的权重。然而，如果你的文档有每月或每年重复的季节性模式，你也可以将其应用于过去的时间段。
- en: While our product documents don’t change very often, and the most recent signals
    aren’t necessarily any more valuable than older signals, there are potentially
    annual patterns we could find in a normal e-commerce dataset. For example, certain
    types of products may be more popular around major holidays like Mother’s Day,
    Father’s Day, and Black Friday. Likewise, searches for something like a “shovel”
    may take on a different meaning in the summer (shovel for digging dirt) versus
    the winter (shovel for removing snow from the sidewalk). If you explore your signals,
    any number of trends may emerge for which time sensitivity should affect how your
    signals are weighted.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的产品文档变化不频繁，而且最新的信号不一定比旧信号更有价值，但在正常的电子商务数据集中可能存在潜在的年度模式。例如，某些类型的商品可能在母亲节、父亲节和黑色星期五等重大节日更受欢迎。同样，对“铲子”等物品的搜索在夏季（用于挖土）与冬季（用于清除人行道上的雪）可能具有不同的含义。如果你探索你的信号，可能会出现许多趋势，时间敏感性应影响你的信号权重。
- en: Ultimately, signals are a lagging indicator. They reflect what your users just
    did, but they are only useful as predictions of future behavior if the patterns
    learned are likely to repeat themselves.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，信号是一个滞后指标。它们反映了你的用户刚刚做了什么，但只有当学习到的模式可能重复时，它们作为未来行为预测才有用。
- en: Having now explored techniques for improving our signals models through query
    normalization, mitigating spam and relevance manipulation, combining multiple
    signal types with different relative weights, and applying time decays to signals,
    you should be able to flexibly implement the signals-boosting models most appropriate
    for your use case. When rolling out signals boosting at scale, however, there
    are two different approaches you can take to optimize for flexibility versus performance,
    which we’ll cover in the next section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了通过查询归一化、减轻垃圾邮件和相关性操纵、结合不同相对权重的多种信号类型以及应用信号的时间衰减来改进我们的信号模型的技术，你应该能够灵活地实施最适合你用例的信号增强模型。然而，在以规模推出信号增强时，你可以采取两种不同的方法来优化灵活性与性能，我们将在下一节中介绍。
- en: '8.6 Index-time vs. query-time boosting: Balancing scale vs. flexibility'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 索引时间与查询时间增强：平衡规模与灵活性
- en: All the signals-boosting models in the chapter have been demonstrated using
    *query-time boosting*, which loads signals boosts for each query from a separate
    sidecar collection at query time and modifies the query to add the boosts before
    sending it to the search engine. It’s also possible to implement signals-boosting
    models using *index-time boosting*, where boosts are added directly to documents
    for the queries to which those boosts apply. In this section, we’ll show you how
    to implement index-time boosting and discuss the benefits and tradeoffs of query-time
    boosting versus index-time boosting.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有信号提升模型都使用 *查询时提升* 进行了演示，该提升在查询时从单独的副车集合中加载信号提升，并在将其发送到搜索引擎之前修改查询以添加提升。也有可能使用
    *索引时提升* 来实现信号提升模型，其中提升直接添加到应用提升的查询的文档中。在本节中，我们将向您展示如何实现索引时提升，并讨论查询时提升与索引时提升之间的利弊。
- en: 8.6.1 Tradeoffs when using query-time boosting
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6.1 使用查询时提升时的权衡
- en: Query-time boosting, as we’ve seen, turns each query into a two-step process.
    Each incoming user query is looked up in a signals-boosting collection, and any
    boosted documents found are used to modify the user’s query. Query-time boosting
    is the most common way to implement signals boosting, but it comes with benefits
    and drawbacks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，查询时提升将每个查询转化为一个两步过程。每个用户查询都会在信号提升集合中进行查找，并使用找到的任何提升文档来修改用户的查询。查询时提升是实现信号提升最常见的方式，但它既有优点也有缺点。
- en: Benefits of query-time boosting
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查询时提升的优势
- en: 'Query-time boosting’s primary architectural characteristic is that it keeps
    the main search collection (`products`) and the signals-boosting collection (`*_signals_boosts`)
    separate. This separation provides several benefits:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 查询时提升的主要架构特点是它将主搜索集合（`products`）和信号提升集合（`*_signals_boosts`）保持分离。这种分离提供了几个好处：
- en: It allows the signals for each query to be updated incrementally by only modifying
    the one document representing that query.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许通过仅修改代表该查询的一个文档来增量更新每个查询的信号。
- en: It allows boosting to be turned on or off easily by just not doing a lookup
    or modifying the user’s query.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许通过不执行查找或修改用户的查询来轻松开启或关闭提升。
- en: It allows different signals-boosting algorithms to be swapped in at any time.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许在任何时候交换不同的信号提升算法。
- en: Ultimately, the flexibility to change signals boosts at any point in time based
    on the current context is the major advantage of query-time signals boosting.
    This enables easier incorporation of real-time signals and easier experimentation
    with different ranking functions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，能够在任何时间根据当前上下文更改信号提升的灵活性是查询时信号提升的主要优势。这使实时信号的整合和不同排名函数的实验更容易进行。
- en: Drawbacks of query-time boosting
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查询时提升的缺点
- en: 'Although it’s flexible, query-time boosting also introduces some significant
    downsides affecting query performance, scale, and relevance, which may make it
    inappropriate for certain use cases:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它很灵活，但查询时提升也引入了一些影响查询性能、规模和相关的重大缺点，这可能会使其不适合某些用例：
- en: It requires an extra search to look up boosts before the boosted search is executed,
    adding more processing (executing two searches) and latency (the final query must
    wait on the results of the signals lookup query before being processed).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要在执行提升搜索之前进行额外的搜索来查找提升，这增加了更多的处理（执行两个搜索）和延迟（最终的查询必须在处理之前等待信号查找查询的结果）。
- en: It leads to unfortunate tradeoffs between relevance (boosting all relevant documents)
    and scalability (limiting the number of boosted documents to keep query times
    and query throughput reasonable).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它导致了相关性（提升所有相关文档）和可扩展性（限制提升文档的数量以保持查询时间和查询吞吐量合理）之间的不幸权衡。
- en: It makes pagination inefficient and potentially inaccurate, as increasing the
    number of boosts to account for the increasing document offset while paging through
    results will slow the query down and possibly result in documents being pushed
    to earlier pages (missed by the user) or later pages (seen as duplicates by the
    user).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得分页效率低下，并且可能不准确，因为增加提升数量以适应增加的文档偏移量，在翻页过程中会减慢查询速度，并可能导致文档被推到更早的页面（用户错过）或更晚的页面（用户视为重复）。
- en: The first downside is straightforward, as each query essentially becomes two
    queries executed back-to-back, increasing the total search time. The second downside
    may not be as obvious. In query-time boosting, we look up a specific number of
    documents to boost higher in the search results for a query. In our `ipad` search
    example from figure 8.1 (see listing 4.7 for the code), the boost for the query
    ultimately becomes
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个缺点很明显，因为每个查询本质上变成了两个连续执行的查询，从而增加了总体的搜索时间。第二个缺点可能不那么明显。在查询时间boosting中，我们查找一定数量的文档来提升查询结果中的搜索排名。在我们的8.1图例中的`ipad`搜索示例中（代码见4.7列表），查询的最终boost变为
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This boost contains 10 documents, but only because that is the number of boosts
    we requested. Assuming we only showed ten documents on the first page, the whole
    first page will look good, but what if the user navigates to page 2? In this case,
    no boosted documents will be shown, because only the first 10 documents with signals
    for the query were boosted!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个boost包含10个文档，但这仅仅是因为我们请求了这么多的boost。假设我们只在第一页显示了10个文档，整个第一页看起来会很好，但用户如果导航到第2页会怎样呢？在这种情况下，将不会显示任何boosted文档，因为只有具有查询信号的前10个文档被boosted！
- en: 'To boost documents for the second page, we would need to ensure we have at
    least enough document boosts to cover the full first two pages, which means increasing
    from 10 boosts to 20 boosts (modifying the `limit` parameter to 20 on the boost
    lookup query):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为第2页boost文档，我们需要确保我们有足够的文档boost来覆盖前两页的全部内容，这意味着将boost的数量从10个增加到20个（在boost查找查询中将`limit`参数修改为20）：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can mostly solve this problem by increasing the number of boosts looked
    up every time someone navigates to the “next” page, but this will aggressively
    slow down subsequent queries, as page 3 will require looking up and applying 30
    boosts, page 10 will require 100 boosts, and so on. For a use case where only
    a small number of boosted documents exist for each query, this is not a big problem,
    but for many use cases, there may be hundreds or thousands of documents that would
    benefit from being boosted. In our query for `ipad`, there are more than 200 documents
    that contain aggregated signals, so most of those documents will never be boosted
    unless someone pages very deep into the search results. At that point, the queries
    are likely to be slow and could even time out.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过增加每次有人导航到“下一页”时查找的boost数量来解决这个问题的绝大部分，但这将极大地减慢后续查询的速度，因为第3页需要查找和应用30个boost，第10页需要100个boost，以此类推。对于每个查询只存在少量boosted文档的情况，这并不是一个大问题，但对于许多用例，可能有数百或数千个文档将受益于被boost。在我们的`ipad`查询中，有超过200个包含聚合信号的文档，所以除非有人翻到搜索结果的很后面，否则这些文档中的大多数永远不会被boost。到那时，查询可能会变慢，甚至可能超时。
- en: 'Only including a subset of the boosts presents another problem: search results
    aren’t always strictly ordered by the boost value! We’ve assumed that requesting
    the top 10 boosts will be enough for the first page of 10 results, but the boost
    is only one of the factors that affects relevance. It could be that documents
    further down in the boost list have a higher base relevance score and that if
    their boosts were also loaded, they would jump up to the first page of search
    results.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 只包含boost的子集又带来了另一个问题：搜索结果并不总是严格按照boost值排序！我们假设请求前10个boost将足以覆盖10个结果的第1页，但boost只是影响相关性的因素之一。可能是文档列表中更靠后的文档具有更高的基本相关性分数，如果它们的boost也被加载，它们可能会跳到搜索结果的第一页。
- en: As a result, when a user navigates from page 1 to 2 and the number of boosts
    loaded increases, unwanted reranking may occur, where results might jump up to
    page 1 and never be seen or jump down to page 2 and be seen again as duplicates.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当用户从第1页导航到第2页且加载的boost数量增加时，可能会发生不希望的重新排序，结果可能会跳到第1页而永远看不到，或者跳到第2页再次被看到作为重复项。
- en: Even if these results are much more relevant than search results without signals
    boosting applied, it doesn’t make for an optimal user experience. Index-time signals
    boosting can help overcome these drawbacks, as we’ll show in the next section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这些结果比没有应用信号boosting的搜索结果更相关，但这并不构成最佳的用户体验。索引时间信号boosting可以帮助克服这些缺点，我们将在下一节中展示。
- en: 8.6.2 Implementing index-time signals boosting
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6.2 实现索引时间信号boosting
- en: Index-time signals boosting turns the signals-boosting problem on its head—instead
    of boosting popular documents for queries at query time, we boost popular queries
    for documents at indexing time. This is accomplished by adding popular queries
    to a field in each document, along with their boost value. Then, at query time,
    we simply search on the new field, and if the field contains the term from our
    query, it gets automatically boosted based on the boost value indexed for the
    term.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 索引时间信号增强将信号增强问题颠倒过来——不是在查询时间对查询的流行文档进行增强，而是在索引时间对文档的流行查询进行增强。这是通过将流行查询及其增强值添加到每个文档的字段中实现的。然后，在查询时间，我们只需在新的字段上搜索，如果该字段包含来自我们查询的术语，它将根据为该术语索引的增强值自动增强。
- en: 'When implementing index-time boosting, we use the exact same signals aggregations
    to generate pairs of documents and boost weights for each query. Once those signals
    boosts have been generated, we just have to add one additional step to our workflow:
    updating the products collection to add a field to each document containing each
    term for which the document should be boosted, along with that term’s associated
    signals boost. The following listing demonstrates this additional step.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现索引时间增强时，我们使用完全相同的信号聚合来生成文档对和每个查询的增强权重。一旦生成了这些信号增强，我们只需在我们的工作流程中添加一个额外的步骤：更新产品集合，为每个文档添加一个字段，包含文档应增强的每个术语，以及该术语相关的信号增强。以下列表展示了这个额外的步骤。
- en: Listing 8.8 Indexing boosts into the main product collection
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.8 将增强索引到主要产品集合中
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#1 Loads a previously generated signals-boosting model'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 加载之前生成的信号增强模型'
- en: '#2 Registers the product table so we can load from it and save back to it with
    boosts added'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 注册产品表，以便我们可以从中加载并添加增强后保存回它'
- en: '#3 Inserts all keywords with signals boosts for each document into a new signals_boosts
    field on the document'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 将每个文档的所有带信号增强的关键词插入到文档的新信号增强字段中'
- en: '#4 Saves the products back to the boosted products collection, with the updated
    signals_boosts added'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 将产品保存回增强产品集合，并添加更新的信号增强'
- en: The code reads all previously generated signals boosts for each product document
    and then maps the queries and boosts into a new `signals_boosts` field on that
    document. The `signals_boosts` field has a comma-separated list of terms (user
    queries) with a corresponding weight for each term.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 代码读取每个产品文档之前生成的所有信号增强，然后将查询和增强映射到该文档的新`signals_boosts`字段上。`signals_boosts`字段包含一个以逗号分隔的术语列表（用户查询），每个术语都有一个相应的权重。
- en: 'When using Solr as your search engine (the default), this `signals_boosts`
    field is a specialized field containing a `DelimitedPayloadBoostFilter` filter,
    which allows for terms (queries) to be indexed with associated boosts that can
    be used to influence query-time scoring. For example, for the most popular iPad,
    the product document will now be modified to look as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Solr作为您的搜索引擎（默认）时，这个`signals_boosts`字段是一个特殊字段，包含一个`DelimitedPayloadBoostFilter`过滤器，允许术语（查询）被索引，并带有相关的增强，这些增强可以用来影响查询时间评分。例如，对于最受欢迎的iPad，产品文档现在将被修改如下：
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This format for specifying index-time term boosts will vary from search engine
    to search engine. At query time, this `signals_boosts` field will be searched
    upon, and if the query is present in the field, the relevance score for that document
    will be boosted by the indexed payload for the matched query. The following listing
    demonstrates how to perform a query utilizing index-time signals boosts.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 指定索引时间术语增强的格式将因搜索引擎而异。在查询时间，将搜索此`signals_boosts`字段，如果查询存在于字段中，该文档的相关性评分将根据匹配查询的索引负载进行增强。以下列表展示了如何执行利用索引时间信号增强的查询。
- en: Listing 8.9 Ranking search results with index-time boosts
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.9 使用索引时间增强进行排名搜索结果
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '#1 Boosting the relevance score based upon the indexed signals boosts for the
    query'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 根据查询的索引信号增强来增强相关性评分'
- en: While support for querying on index-time boosted terms is handled differently
    by various search engines, in the case of Solr (our default search engine), this
    translates internally into a `boost` parameter value of `payload("signals_boosts",`
    `"ipad",` `1, "first")` being added to the search request to boost documents by
    the payload attached to the *first* match of the query `ipad` in the `signals_boosts`
    field (or `1` if no payload was indexed). See section 3.2 if you want a refresher
    on influencing ranking like this through functions and multiplicative boosts.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然各种搜索引擎对索引时间增强项的查询支持处理方式不同，但在Solr（我们的默认搜索引擎）的情况下，这内部转化为向搜索请求中添加一个`boost`参数值`payload("signals_boosts",
    "ipad", 1, "first")`，通过附加到查询`ipad`在`signals_boosts`字段中的第一个匹配项的负载来增强文档（如果没有索引负载，则为`1`）。如果您想回顾如何通过函数和乘法增强来影响排名，请参阅第3.2节。
- en: Figure 8.5 shows the results of this index-time signals boosting. As you can
    see, the results now look similar to the query-time signals-boosting output shown
    previously in figure 8.1.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5显示了这种索引时间信号增强的结果。正如您所看到的，现在结果看起来与之前在图8.1中显示的查询时间信号增强输出相似。
- en: '![figure](../Images/CH08_F05_Grainger.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH08_F05_Grainger.png)'
- en: Figure 8.5 Index-time signals boosting, demonstrating similar results as query-time
    index boosting
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.5 索引时间信号增强，展示了与查询时间索引增强类似的结果
- en: The relevance scores will likely not be identical when performing index-time
    boosting versus query-time boosting, as the math is different when scoring an
    indexed payload versus a boosted query term. The relative ordering of results
    should be very similar, though. The index-time signals boosting will also apply
    to all documents with a matching signals-boost payload, whereas query-time signals
    boosting only applies to the top-*N* documents that are explicitly boosted in
    the query.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行索引时间增强与查询时间增强时，相关性分数可能不会完全相同，因为当对索引负载进行评分时与对增强查询术语进行评分时的数学不同。尽管如此，结果的相对顺序应该非常相似。索引时间信号增强也将适用于所有具有匹配信号增强负载的文档，而查询时间信号增强仅适用于查询中明确增强的前*N*个文档。
- en: 8.6.3 Tradeoffs when implementing index-time boosting
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6.3 实施索引时间增强时的权衡
- en: Index-time boosting, as we’ve seen, moves most of the work of performing signals
    boosting from the query execution phase to the indexing phase of your searches.
    This solves some of the problems inherent in query-time boosting, but it also
    introduces some new challenges, which we’ll discuss in this section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，索引时间增强将执行信号增强的大部分工作从查询执行阶段转移到搜索的索引阶段。这解决了查询时间增强中固有的某些问题，但也引入了一些新的挑战，我们将在本节中讨论。
- en: Benefits of index-time boosting
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 索引时间增强的优点
- en: 'Index-time boosting solves most of the drawbacks of query-time boosting:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 索引时间增强解决了查询时间增强的大部分缺点：
- en: The query workflow is simpler and faster because it doesn’t require doing two
    queries—one to look up the signals boosts and another to run a boosted query using
    those signals boosts.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询工作流程更简单、更快，因为它不需要执行两个查询——一个用于查找信号增强，另一个使用这些信号增强运行增强查询。
- en: Each query is more efficient and faster as the number of boosted documents increases,
    because the query is a single keyword search against the `signals_ boosts` field
    as opposed to a longer query containing the increasing list of boosted documents.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着增强文档数量的增加，每个查询都变得更高效、更快，因为查询是对`signals_boosts`字段的单个关键字搜索，而不是包含不断增加的增强文档的长查询。
- en: Results paging is no longer a problem, because *all* documents matching the
    query are boosted, not just the top-*N* that can be efficiently loaded and added
    to the query.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果分页不再是问题，因为*所有*与查询匹配的文档都被增强了，而不仅仅是那些可以高效加载并添加到查询中的前*N*个文档。
- en: Given these characteristics, index-time boosting can substantially improve the
    relevance and consistency of results ordering by ensuring all queries receive
    consistent and complete boosting of all their matching documents. It can also
    substantially improve query speed by removing query terms (the doc boosts) and
    eliminating extra lookups prior to execution of the main query.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些特性，索引时间增强可以通过确保所有查询都接收到其所有匹配文档的一致和完整的增强，从而显著提高结果排序的相关性和一致性。它还可以通过删除查询术语（文档增强）和消除在执行主查询之前进行的额外查找来显著提高查询速度。
- en: Drawbacks of index-time boosting
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 索引时间增强的缺点
- en: If index-time boosting solves all the problems of query-time boosting, why wouldn’t
    we always use index-time signals boosting?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引时间增强解决了查询时间增强的所有问题，为什么我们总是不使用索引时间信号增强呢？
- en: The main drawback of index-time boosting is that since the boost values for
    a query are indexed onto each document (each document contains the terms for which
    that document should be boosted), adding or removing a keyword from the signals-boosting
    model requires reindexing all documents associated with that keyword. If signals-boosting
    aggregations are updated incrementally (on a per-keyword basis), this means potentially
    reindexing all the documents within your search engine on a continuous basis.
    If your signals-boosting model is updated in batch for your entire index, this
    means potentially reindexing all your documents every time your signals-boosting
    model is regenerated.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 索引时间提升的主要缺点是，由于查询的增强值被索引到每个文档上（每个文档包含该文档应增强的术语），从信号增强模型中添加或删除关键词需要重新索引与该关键词相关的所有文档。如果信号增强聚合是按关键词增量更新的，这意味着可能需要持续不断地重新索引您搜索引擎内的所有文档。如果您的信号增强模型是批量更新整个索引的，这意味着每次信号增强模型被重新生成时，可能需要重新索引所有文档。
- en: This kind of indexing pressure adds operational complexity to your search engine.
    To keep query performance fast and consistent, given this indexing pressure, you
    may want to separate the indexing of documents onto separate servers from where
    the search indexes are hosted for serving queries.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种索引压力会给您的搜索引擎增加操作复杂性。为了保持查询性能快速且一致，考虑到这种索引压力，您可能希望将文档的索引分离到与搜索索引托管服务器不同的单独服务器上，以服务于查询。
- en: 'Separation of concerns: Indexing vs. querying'
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关注点分离：索引与查询
- en: When performing high-volume indexing, it may be architecturally best to isolate
    your indexing servers from your querying servers if possible. Otherwise, memory
    or CPU pressure from busy indexing operations can affect query latency and throughput.
    Not all search engines support this separation of concerns between indexing and
    query servers, but many do.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行高量索引时，如果可能的话，最好将索引服务器与查询服务器隔离开来。否则，繁忙的索引操作产生的内存或CPU压力可能会影响查询延迟和吞吐量。并非所有搜索引擎都支持索引服务器和查询服务器之间这种关注点的分离，但许多搜索引擎都支持。
- en: Elasticsearch and OpenSearch, for instance, support this separation of concerns
    using the concept of *follower indexes*, while Solr does it through supporting
    different *replica types*. All three of these engines have the concepts of *shards*,
    which are partitions containing a subset of the documents in a collection, and
    *replicas*, which are exact copies of all the data belonging to their shard. Each
    shard has a leader that is responsible for receiving updates and forwarding them
    to all replicas.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Elasticsearch和OpenSearch通过使用`follower indexes`的概念支持这种关注点的分离，而Solr则是通过支持不同的`replica
    types`来实现。这三个引擎都有`shards`的概念，即包含集合中部分文档的分区，以及`replicas`的概念，即其分片所有数据的精确副本。每个分片都有一个领导者，负责接收更新并将它们转发到所有副本。
- en: By default, leaders send all document updates to every replica of a shard, and
    each replica then (redundantly) indexes the document so that it is available immediately
    to be searched on that replica. Unfortunately, the tradeoff for immediate availability
    is that high-volume indexing will consume resources on every replica, which can
    slow down query performance across the entire search engine.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，领导者将所有文档更新发送到分片的所有副本，然后每个副本（冗余地）索引该文档，以便它立即可在副本上被搜索。不幸的是，即时可用性的代价是高量索引会消耗每个副本的资源，这可能会降低整个搜索引擎的查询性能。
- en: By changing the replica type in Solr for replicas on query servers from `NRT`
    (near-real-time) to either `TLOG` (transaction log) or `PULL`, you’ll instruct
    replicas to pull prebuilt index files from the shard’s leader (which is already
    indexing documents) instead of performing duplicate indexing. Similarly in Elasticsearch
    and OpenSearch, if you configure a follower index, the servers hosting the follower
    index will replicate prebuilt index files from the leader index instead of redundantly
    indexing the document. Some other search engines and vector databases have similar
    abilities to segregate indexing operations and query operations across servers
    that you can explore.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Solr中将查询服务器上的副本类型从`NRT`（近实时）更改为`TLOG`（事务日志）或`PULL`，您将指示副本从分片领导者（它已经在索引文档）那里拉取预构建的索引文件，而不是执行重复索引。在Elasticsearch和OpenSearch中类似地，如果您配置了从索引副本，托管从索引副本的服务器将从领导者索引复制预构建的索引文件，而不是冗余地索引文档。一些其他搜索引擎和向量数据库具有类似的跨服务器隔离索引操作和查询操作的能力，您可以探索这些能力。
- en: If you plan to do index-time signals boosting and expect to be constantly reindexing
    signals at high volumes, you should strongly consider isolating index and query-time
    operations. This ensures your query performance isn’t negatively affected by the
    significant additional indexing overhead from ongoing signals-boosting aggregations.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划进行索引时间信号增强并预计将不断以高量重新索引信号，您应强烈考虑隔离索引和查询时间操作。这确保您的查询性能不会因持续信号增强聚合的显著额外索引开销而受到负面影响。
- en: The other drawback of index-time boosting is that making changes to your signals-boosting
    function can require more planning. For example, if you want to change your weight
    for click versus purchase signals from 1:25 to 1:20, you’ll need to create a `signals_boosts_2`
    field with the new weights, reindex all your documents adding the new boosts,
    and then flip over your query to use the new field instead of the original `signals_boosts`
    field. Otherwise, your boost values and ranking scores will fluctuate inconsistently
    until all your documents’ scores have been updated.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 索引时间增强的另一个缺点是，对您的信号增强函数进行更改可能需要更多的规划。例如，如果您想将点击信号与购买信号的权重从1:25更改为1:20，您需要创建一个带有新权重的`signals_boosts_2`字段，重新索引所有文档并添加新的增强，然后切换查询以使用新字段而不是原始的`signals_boosts`字段。否则，您的增强值和排名分数将不一致地波动，直到所有文档的分数都已更新。
- en: If those drawbacks can be worked around, however, implementing index-time signals
    boosting can solve all the drawbacks of query-time signals boosting, leading to
    better query performance, full support for results paging, and the use of all
    signals from all documents as opposed to just a sampling from the most popular
    documents.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果能够克服这些缺点，实施索引时间信号增强可以解决查询时间信号增强的所有缺点，从而提高查询性能，完全支持结果分页，并使用所有文档的所有信号，而不是仅从最受欢迎的文档中采样。
- en: As we’ve seen in this chapter, signals boosting allows for popularized relevance—boosting
    the most important items for specific queries. In the next chapter, we’ll implement
    personalized relevance—adjusting ranking on a per-user basis, using each user’s
    signals (relative to other users) to learn their specific interests.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中看到的，信号增强允许流行相关性——增强特定查询的最重要项目。在下一章中，我们将实现个性化相关性——根据每个用户进行调整的排名，使用每个用户的信号（相对于其他用户）来学习他们的特定兴趣。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Signals boosting is a type of ranking algorithm that aggregates user signal
    counts per query and uses those counts as relevance boosts for that query in the
    future. This ensures the most popular items for each query are pushed to the top
    of the search results.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号增强是一种排名算法，它聚合每个查询的用户信号计数，并使用这些计数作为未来该查询的相关性增强。这确保了每个查询最受欢迎的项目被推到搜索结果的最顶部。
- en: Normalizing queries by treating different variations (case, spelling, etc.)
    as the same query helps clean up noise in user signals and builds a more robust
    signals-boosting model.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将不同的变体（大小写、拼写等）视为相同的查询来规范化查询有助于清理用户信号中的噪声，并构建一个更健壮的信号增强模型。
- en: Crowdsourced data is subject to manipulation, so it is important to explicitly
    prevent spam and malicious signals from affecting the quality of your relevance
    models.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 群智数据容易受到操纵，因此，明确防止垃圾邮件和恶意信号影响您相关性模型的质量是很重要的。
- en: You can combine different signal types into a single signals-boosting model
    by assigning relative weights to each type and doing a weighted sum of values
    across signal types. This enables you to give more relevance to stronger signals
    (positive or negative) and reduce noise from weaker signals.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过为每种类型分配相对权重并对信号类型进行加权求和，将不同的信号类型组合成一个单一的信号增强模型。这使得您能够给予更强的信号（正面或负面）更多的相关性，并减少较弱信号的噪声。
- en: Introducing a time-decay function enables recent signals to carry more weight
    than older signals, allowing older signals to phase out over time.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入时间衰减函数可以使近期信号比旧信号具有更大的权重，允许旧信号随时间逐渐消失。
- en: Signals-boosting models can be productionized using query-time signals boosting
    (more flexible) or index-time signals boosting (more scalable and more consistent
    relevance ranking).**
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用查询时间信号增强（更灵活）或索引时间信号增强（更可扩展且更一致的相关性排名）可以将信号增强模型投入生产。
