- en: 10 Making some games
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 制作一些游戏
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Adding randomness to our programs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的程序中添加随机性
- en: Designing and programming a code-breaking logic game
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和编程一个密码破解逻辑游戏
- en: Designing and programming a press-your-luck dice game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和编程一个“运气”掷骰子游戏
- en: People learn to program for many reasons. Some people want to automate tedious
    tasks as we did in the previous chapter. Some people want to work with artificial
    intelligence (AI; you’ll get a taste of that in chapter 11). Other people want
    to make interactive websites, Android or iOS apps, or Alexa skills. There’s an
    endless amount of stuff that programmers can make.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 人们学习编程的原因有很多。有些人想要自动化我们在上一章中做的繁琐任务。有些人想要与人工智能（AI；你将在第11章中尝到一些）一起工作。其他人想要制作交互式网站、Android或iOS应用，或者Alexa技能。程序员可以制作的东西是无穷无尽的。
- en: Another popular reason to learn programming is to create games. For that reason,
    we thought we’d continue our Copilot programming journey with you by designing
    two small computer games. The first is a code-breaking game where you use clues
    to identify the computer’s secret code. The second is a two-player dice game where
    each player needs to balance risk and luck to reach the required number of points
    before the other player does. Instead of using graphics and animation, these games
    use text. We’ve made this decision to help us stay focused on the game logic,
    rather than the way that the game is represented or the way that the player interacts
    with the games. Along the way, we offer some next steps if you’re interested in
    taking your game-making abilities further. And don’t worry, your current skills
    are a great start to that!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个学习编程的流行原因是创建游戏。因此，我们认为我们应该继续我们的Copilot编程之旅，与你一起设计两个小型电脑游戏。第一个是一个密码破解游戏，你使用线索来识别电脑的秘密代码。第二个是一个两人掷骰子游戏，每个玩家都需要平衡风险和运气，在另一个玩家之前达到所需的分数。这些游戏不使用图形和动画，而是使用文本。我们做出这个决定是为了帮助我们专注于游戏逻辑，而不是游戏的表现方式或玩家与游戏交互的方式。在这个过程中，如果你对进一步提高你的游戏制作能力感兴趣，我们会提供一些下一步的建议。而且不用担心，你现在的技能是迈向那个目标的良好开端！
- en: 10.1 Game programs
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 游戏程序
- en: If you think about playing a board game with your family or friends, you can
    break down what happens in two major phases. The first phase is game setup. This
    will include setting up the game board, giving each player starting funds or cards,
    and so on. The second phase is the playing of the game. In a board game, the game
    typically includes a person taking a turn and, assuming no one has won yet, another
    person taking a turn. With each turn, the game state (board, players’ funds, etc.)
    all change. We need to take care to implement each of these phases when programming
    a computer game as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑与家人或朋友玩桌面游戏，你可以将发生的事情分解为两个主要阶段。第一个阶段是游戏设置。这包括设置游戏板，给每个玩家提供起始资金或卡片等。第二个阶段是游戏进行。在桌面游戏中，游戏通常包括一个人轮流，假设还没有人获胜，另一个人轮流。随着每一轮的进行，游戏状态（板，玩家的资金等）都会发生变化。在编程电脑游戏时，我们需要注意实现这些阶段中的每一个。
- en: In many programming environments catered to video game design, the two phases
    are often separate standard functions. There’s a setup function for what is done
    to set up the game and an update function to change the state of the game either
    because a player has taken an action or because time has passed. Figure 10.1 shows
    the basic flow for video games.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多针对视频游戏设计的编程环境中，这两个阶段通常被作为独立的常规函数。有一个设置函数用于设置游戏，还有一个更新函数用于改变游戏状态，这可能是因为玩家采取了行动，或者是因为时间已经过去。图10.1显示了视频游戏的基本流程。
- en: '![figure](../Images/10-1.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/10-1.png)'
- en: Figure 10.1 Basic flow of most video games
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1 大多数视频游戏的基本流程
- en: 'Let’s focus on the update part of the game for a moment. Suppose a player can
    press a button on their keyboard to move forward in a 2D game. The update function
    will cause the player’s character to move forward and also check to see if the
    player’s movement caused the player to interact with something in the game world.
    Some games also change state based on time, regardless of a player’s actions.
    In those games, the update function would also update the state of the game itself
    (e.g., move the ghosts in a game of Pac-Man). At the end of every time step or
    user action, the game will check for end conditions. End conditions typically
    include the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时关注一下游戏的更新部分。假设玩家可以按键盘上的按钮在 2D 游戏中向前移动。更新函数将使玩家的角色向前移动，并检查玩家的移动是否使玩家与游戏世界中的某个物体发生了交互。一些游戏也会根据时间改变状态，而不管玩家的动作如何。在这些游戏中，更新函数也会更新游戏本身的状态（例如，在
    Pac-Man 游戏中移动幽灵）。在每个时间步或用户动作结束时，游戏将检查结束条件。结束条件通常包括以下内容：
- en: A player won the game by achieving an objective.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家通过完成目标赢得了游戏。
- en: A player lost the game by falling off a cliff, running into a monster, and so
    on.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家因从悬崖上掉下来、撞到怪物等原因输掉了游戏。
- en: A player chose to quit the game.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家选择退出游戏。
- en: There are many programming environments that cater to game design, and we recommend
    the Python pygame module [1] as a good starting place. If you continue pursuing
    game design beyond that, we recommend checking out Unity [2] for 3D game design.
    In this chapter though, we’ll be working with just standard Python to show you
    how to design a basic game without having to dive into these new environments.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多编程环境针对游戏设计，我们推荐 Python 的 pygame 模块 [1] 作为良好的起点。如果您继续追求游戏设计，我们建议您查看 Unity
    [2] 以进行 3D 游戏设计。然而，在本章中，我们将仅使用标准 Python 来向您展示如何设计一个基本游戏，而无需深入这些新环境。
- en: 10.2 Adding randomness
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 添加随机性
- en: Many games, including the two that we’ll build in this chapter, rely on randomness
    to make them fun. In our first game, we’ll need the computer to generate the random
    digits of the number that we’ll be deducing. In the second game, we’ll need to
    roll dice, which just amounts to generating random numbers between one and six.
    Enemy behavior, initial orientation of a puzzle, or amount of damage caused by
    attacks, that is, randomness, is typically involved in all of these and many other
    aspects of game design.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏，包括我们在本章中将要构建的两个游戏，都依赖于随机性来使它们变得有趣。在我们的第一个游戏中，我们需要计算机生成我们将要推断的数字的随机数字。在第二个游戏中，我们需要掷骰子，这仅仅相当于生成介于
    1 和 6 之间的随机数。敌人的行为、谜题的初始方向或攻击造成的伤害，即随机性，通常涉及游戏设计的所有这些和其他许多方面。
- en: We’ll therefore need to be able to generate random numbers in our Python programs.
    To learn how to do that, let’s use Copilot Chat, much as we did in the previous
    chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要能够在我们的 Python 程序中生成随机数。为了了解如何做到这一点，让我们使用 Copilot Chat，就像我们在上一章中所做的那样。
- en: LPHumanI need to generate random numbers in my **Python program. How can I do
    this?**
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman 我需要在我的 **Python 程序中生成随机数。我该如何操作？**
- en: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the random module
    in Python to generate random numbers. Here’s an example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot 您可以使用 Python 中的 random 模块来生成随机数。以下是一个示例：'
- en: '[PRE0]`*[PRE1]`*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]`*[PRE1]`*'
- en: '*`*import random*`*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import random*`*'
- en: '*`*# Generate a random integer between 1 and 10 (inclusive)*`*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Generate a random integer between 1 and 10 (inclusive)*`*'
- en: '*`*random_number = random.randint(1, 10)*`*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*random_number = random.randint(1, 10)*`*'
- en: '*`*print(random_number)*`*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(random_number)*`*'
- en: '*`*# Generate a random float between 0 and 1*`*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Generate a random float between 0 and 1*`*'
- en: '*`*random_float = random.random()*`*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*random_float = random.random()*`*'
- en: '*`*print(random_float)*`*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(random_float)*`*'
- en: '*[PRE2]*[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE2]*[PRE3]'
- en: This code imports the random module and then uses the `randint` function to
    generate a random integer between 1 and 10 (inclusive), and the `random` function
    to generate a random float between 0 and 1.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码导入 random 模块，然后使用 `randint` 函数生成一个介于 1 和 10（包含）之间的随机整数，并使用 `random` 函数生成一个介于
    0 和 1 之间的随机浮点数。
- en: Copilot suggests using functions inside of a module called random to generate
    the random numbers. Let’s check whether the random module is built into Python.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 建议使用名为 random 的模块中的函数来生成随机数。让我们检查一下 random 模块是否是 Python 内置的。
- en: LPHumanIs this random module built into Python?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman 这个随机模块是 Python 内置的吗？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, the random module is a
    built-in module in Python, so you don’t need to install any additional modules
    to use it. You can simply import it in your Python code and start using its functions.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 是的，random模块是Python的一个内置模块，所以你不需要安装任何额外的模块来使用它。你只需在你的Python代码中导入它，然后开始使用它的函数。'
- en: 'We’ll follow Copilot’s suggestion and import this module to test the two functions
    that we just learned. We’ll do this at the Python >>> prompt, which we’ve used
    in previous chapters to explore how Python features work. To get to the Python
    prompt, press Ctrl-Shift-P, type `REPL`, and then select Python: Start REPL.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将遵循Copilot的建议导入这个模块来测试我们刚刚学到的两个函数。我们将在Python >>>提示符下这样做，这是我们之前章节用来探索Python功能的地方。要进入Python提示符，请按Ctrl-Shift-P，输入`REPL`，然后选择Python:
    Start REPL。'
- en: 'Based on Copilot’s response to our first question, we know that we can use
    the `randint` function to generate a random integer in a range from the lowest
    allowed number to the highest allowed number. We might use this function to generate
    individual digits that could be assembled into a larger number. Each digit is
    between 0 and 9, so we’ll ask `randint` for some random numbers between 0 and
    9:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Copilot对我们第一个问题的回答，我们知道我们可以使用`randint`函数在从最低允许数值到最高允许数值的范围内生成一个随机整数。我们可能会使用这个函数来生成可以组合成更大数字的单独的数字。每个数字在0到9之间，因此我们将请求`randint`函数生成0到9之间的随机数：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 We happened to get the maximum value.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们恰好得到了最大值。'
- en: '#2 We happened to get the minimum value.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们恰好得到了最小值。'
- en: 'Or, we might want to generate rolls of a die. Each roll is between 1 and 6,
    so we can ask `randint` for some random numbers between 1 and 6:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可能想要生成骰子的点数。每次投掷的点数在1到6之间，因此我们可以请求`randint`函数生成1到6之间的随机数：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The other function that Copilot told us about is called `random`. (Yes, both
    the module and this function are called `random`! So, we’ll need to use `random.random()`
    to call this function.) This one doesn’t generate a random integer; rather, it
    generates a random fractional number between 0 and 1 (not including 1). For example,
    rather than a random number like 5, you’ll get a random number like 0.1926502\.
    These kinds of numbers, with decimals, are referred to as floats (or floating-point
    numbers). Here are a few calls of this function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot还告诉我们另一个函数叫做`random`。（是的，模块和这个函数都叫做`random`！所以，我们需要使用`random.random()`来调用这个函数。）这个函数不会生成随机整数；相反，它生成介于0和1之间（不包括1）的随机分数数。例如，你可能会得到一个像0.1926502这样的随机数。这类带有小数的数字被称为浮点数（或浮点数）。以下是这个函数的一些调用示例：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can imagine this function being useful for games as well. For example, you
    can think of these float values as probabilities that an event occurs, with higher
    numbers corresponding to higher probabilities. You could then use these floats
    to determine whether an event should happen or not. For the games in this chapter,
    though, we won’t need this function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象这个函数在游戏中也很有用。例如，你可以将这些浮点值视为事件发生的概率，数值越高表示概率越高。然后你可以使用这些浮点值来确定事件是否应该发生。然而，在本章的游戏中，我们不需要这个函数。
- en: '10.3 Example 1: Bulls and Cows'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 示例1：猜数字游戏
- en: '*Our first game will be based on an old code-breaking game called Bulls and
    Cows. It might remind you of the game Wordle (but don’t worry if you haven’t played
    Wordle before). We’ll be able to play this game against the computer. Randomness
    plays a critical role in this game, as we’ll see.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们的第一个游戏将基于一个古老的密码破解游戏，叫做猜数字游戏。这可能会让你想起Wordle游戏（但如果你之前没有玩过Wordle也不要担心）。我们将能够与电脑玩这个游戏。在这个游戏中，随机性扮演着至关重要的角色，我们将看到。*'
- en: '*### 10.3.1 How the game works'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*### 10.3.1 游戏的工作原理'
- en: In this game, Player 1 thinks up a secret code, which is a sequence of four
    digits. Player 2 has to figure out what that secret code is. In our version of
    the game, the computer will be Player 1, and the human player will be Player 2.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，玩家1想出一个秘密代码，这是一个由四个数字组成的序列。玩家2必须猜出这个秘密代码是什么。在我们的游戏中，电脑将是玩家1，而人类玩家将是玩家2。
- en: Here’s how it works. The computer will randomly choose four distinct digits
    (duplicate digits aren’t allowed) as the secret code. For example, it might choose
    the digits 1862\. Then, you’ll guess what you think the computer’s four digits
    are. For example, you might guess 3821.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作方式。电脑将随机选择四个不同的数字（不允许重复数字）作为秘密代码。例如，它可能会选择数字1862。然后，你将猜测你认为电脑的四个数字是什么。例如，你可能会猜测3821。
- en: For each guess, you’re told two things. First, you’re told how many digits in
    your guess match the corresponding position in the secret code exactly. We’ll
    refer to digits that are in the correct place in the secret code as “correct.”
    Say that the secret code is 1862, and you guess 3821\. The second digit in both
    your guess and the secret code is 8, so that’s a match. There are no other matches,
    so you would be told for this guess that the number of correct digits is 1.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个猜测，您会得到两个信息。首先，您会被告知您的猜测中有多少位数字与秘密代码中相应位置完全匹配。我们将把在秘密代码中正确位置的数字称为“正确的”。比如说秘密代码是
    1862，而您的猜测是 3821。您的猜测和秘密代码的第二位数字都是 8，所以这是一个匹配。没有其他匹配，所以您会被告知这个猜测中正确的数字数量是 1。
- en: Second, you’re told how many digits in your guess exist at some other position
    in the secret code. We’ll refer to digits that are in the secret code but in a
    different location as “misplaced.” Let’s again use 1862 for the secret code and
    3821 for your guess. The third digit in your guess is 2\. It doesn’t match the
    third digit of the secret code (that’s a 6), but there is a 2 somewhere else in
    the secret code. Similarly, the fourth digit in your guess is a 1\. It doesn’t
    match the fourth digit of the secret code, but there is a 1 somewhere else in
    the secret code. All told, two of your digits (1 and 2) exist in the secret code,
    although they don’t match their expected position. You would be told from this
    guess that the number of misplaced digits is 2\. You can use these clues to narrow
    down what the secret code could be.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您会被告知您的猜测中有多少位数字在秘密代码中的某个其他位置存在。我们将把在秘密代码中但位置不同的数字称为“错位的”。再次以 1862 作为秘密代码，3821
    作为您的猜测。您的猜测中的第三位数字是 2。它不匹配秘密代码中的第三位数字（那是 6），但在秘密代码的某个其他位置有一个 2。同样，您的猜测中的第四位数字是
    1。它不匹配秘密代码中的第四位数字，但在秘密代码的某个其他位置有一个 1。总的来说，您的两个数字（1 和 2）存在于秘密代码中，尽管它们没有匹配它们预期的位置。您会从这个猜测中得知错位的数字数量是
    2。您可以使用这些线索来缩小秘密代码可能是什么的范围。
- en: Wordle
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Wordle
- en: If you’ve played Wordle before, you might notice some similarities between Wordle
    and our game here. Wordle uses letters, and ours uses digits, but the type of
    feedback you receive for your guesses is similar. In both cases, you’re told about
    letters or digits that are in the right or wrong place. In Wordle, you’re given
    a clue about each of your letters on its own. For example, if the first letter
    of your guess is *h*, you might be told that the *h* is in the word but in the
    wrong place. By contrast, in our game, you’re not given hints about each digit
    individually but instead are given hints about your guess in aggregate. Still,
    we hope you’re struck by these similarities and by the fact that you’re building
    something that resembles a recent, worldwide phenomenon of a game!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前玩过 Wordle，您可能会注意到 Wordle 和我们这里的游戏之间的一些相似之处。Wordle 使用字母，而我们使用数字，但您对猜测的反馈类型是相似的。在两种情况下，您都会被告知关于字母或数字在正确或错误位置的信息。在
    Wordle 中，您会得到关于您每个字母的线索。例如，如果您的猜测的第一个字母是 *h*，您可能会被告知 *h* 在单词中，但位置不正确。相比之下，在我们的游戏中，您不会得到关于每个数字的单独线索，而是会得到关于您的猜测的整体线索。尽管如此，我们希望您会被这些相似之处以及您正在构建的东西与最近全球现象的游戏相似之处所吸引！
- en: We found a free version of Bulls and Cows that you can play at [www.mathsisfun.com/games/bulls-and-cows.xhtml](http://www.mathsisfun.com/games/bulls-and-cows.xhtml).
    We recommend that you play a few rounds of the game before continuing, just so
    the way the game works is crystal clear in your head. (Note that they use the
    terminology *bulls* instead of *correct* and *cows* instead of *misplaced*.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了一个免费的“猜数字”游戏版本，您可以在 [www.mathsisfun.com/games/bulls-and-cows.xhtml](http://www.mathsisfun.com/games/bulls-and-cows.xhtml)
    上玩。我们建议您在继续之前玩几轮游戏，这样游戏的工作方式就能在您脑海中变得非常清晰。（注意，他们使用“bulls”而不是“correct”，使用“cows”而不是“misplaced”。）
- en: In table 10.1, we’ve provided an example interaction with the game. We’ve included
    a Comments column to convey our thinking and what we learned from each guess.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在表 10.1 中，我们提供了一个与游戏的交互示例。我们包括了一个注释列，以传达我们的思考和从每个猜测中学到的知识。
- en: Table 10.1 Example of playing the game
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 10.1 游戏示例
- en: '| Guess | Misplaced | Correct | Comments |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 猜测 | 错位 | 正确 | 注释 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0123  | 1  | 0  | One of 0, 1, 2, 3 is in the answer; none are in the correct
    location.  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 0123  | 1  | 0  | 答案中包含 0、1、2、3 中的一个数字；没有数字在正确的位置。  |'
- en: '| 4567  | 3  | 0  | Three of 4, 5, 6, 7 are in the answer; none are in the
    correct location.  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 4567  | 3  | 0  | 答案中包含 4、5、6、7 中的 3 个数字；没有数字在正确的位置。  |'
- en: '| 9045  | 0  | 1  | Because one number from 0123 and three numbers from 4567
    are in the answer, we know 8 and 9 aren’t in the answer. We know at least one
    of the numbers 4 or 5 must be in the answer from prior guesses and that 0 could
    be in the answer. One correct means that either 4 or 5 is in the correct location,
    either 4 or 5 isn’t present in the solution, and 0 isn’t in the solution.  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 9045  | 0  | 1  | 因为0123中的一个数字和4567中的三个数字在答案中，我们知道8和9不在答案中。我们知道至少有一个数字4或5必须来自之前的猜测，而0可能在答案中。一个正确意味着4或5在正确的位置，或者4或5不在解决方案中，而0不在解决方案中。  |'
- en: '| 9048  | 0  | 0  | We know 8, 9, and 0 aren’t in the answer from prior guesses.
    Zero correct and zero misplaced tells us 4 is also not in the answer, and from
    the previous guess, we now know that 5 is the last digit.  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 9048  | 0  | 0  | 从之前的猜测中，我们知道8、9和0不在答案中。零个正确和零个放错告诉我们4也不在答案中，而从之前的猜测中，我们现在知道5是最后一位数字。  |'
- en: '| 1290  | 1  | 0  | Going back to the original guess, we want to know which
    digit of 1, 2, and 3 is in the answer. We know 9 and 0 aren’t in the answer, so
    one misplaced means either 1 or 2 is in the answer and 3 isn’t in the answer.
    In addition, whichever of the numbers 1 and 2 are in the answer, it’s currently
    in the wrong spot.  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 1290  | 1  | 0  | 回到最初的猜测，我们想知道1、2和3中的哪个数字在答案中。我们知道9和0不在答案中，所以一个数字放错意味着1或2在答案中，而3不在答案中。此外，无论1和2中的哪个数字在答案中，它目前都放在了错误的位置。  |'
- en: '| 6715  | 2  | 1  | Because 4 isn’t in the solution, we know from the second
    guess that 5, 6, and 7 are. Our guess here tells us that 1 isn’t in the answer
    and that 6 and 7 are in the wrong place. Since 1 isn’t in the answer, 2 must be
    (from the previous guess). Because 5 is at the end and we’ve tried 2 in the second
    and third position previously with zero correct, 2 must be in the first position.
    Because we’ve tried 6 in the first and third position and neither were correct,
    6 must be in the second position. That leaves 7 for the third position. We’ve
    got it.  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 6715  | 2  | 1  | 因为4不在解决方案中，我们知道从第二个猜测中5、6和7在。我们的猜测告诉我们1不在答案中，而6和7放错了位置。由于1不在答案中，2必须是（从之前的猜测中）。因为5在最后一位，我们之前在第二和第三位尝试了2，但都没有正确，所以2必须在第一位。因为我们尝试了6在第一和第三位，但都不正确，所以6必须在第二位。这样，第三位就剩下7了。我们找到了答案。  |'
- en: '| 2675  | 0  | 4  | Yes, this is correct.  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 2675  | 0  | 4  | 是的，这是正确的。  |'
- en: The challenge of the game is that you have a limited number of guesses in which
    you must successfully guess the computer’s secret code. In our example from table
    10.1, we took seven guesses to guess the code 2675\. For each guess, we were given
    the number of digits misplaced and the number of digits correct to guide our thinking.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的挑战在于你必须在有限的猜测次数内成功猜出计算机的秘密代码。在我们表10.1中的例子中，我们用了七个猜测来猜出代码2675。对于每个猜测，我们都得到了数字放错的数量和数字正确的数量来指导我们的思考。
- en: In the free version of the game that we just mentioned, you’re not allowed to
    include the same digit multiple times in your guess. For example, the guess 1231
    wouldn’t be allowed because of the two 1s. We’ll maintain this restriction in
    our version of the game as well.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚才提到的游戏的免费版本中，你不允许在猜测中包含相同的数字多次。例如，猜测1231是不允许的，因为有两个1。在我们的游戏版本中，我们也将保持这一限制。
- en: 10.3.2 Top-down design
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 自顶向下的设计
- en: Our overall task is to write a program to play the Bulls and Cows game against
    the computer. Let’s do top-down design on this large task, just as we did in chapters
    7 and 9\. What has to happen during this game? Answering that question will help
    us break down the game into smaller tasks. To help us with this, we took the rules
    of the game and our example and thought through what happens at each step of the
    game. Each of those high-level steps appears in figure 10.2, so let’s break them
    down one by one.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的整体任务是编写一个程序来与计算机玩Bulls and Cows游戏。让我们对这个大任务进行自顶向下的设计，就像我们在第7章和第9章中所做的那样。在这个游戏中，必须发生什么？回答这个问题将帮助我们把这个游戏分解成更小的任务。为了帮助我们，我们思考了游戏的规则和我们的例子，并思考了游戏每个步骤会发生什么。这些高级步骤都出现在图10.2中，所以让我们逐一分解它们。
- en: '![figure](../Images/10-2.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/10-2.png)'
- en: Figure 10.2 Steps in the Bulls and Cows game
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2 Bulls and Cows游戏步骤
- en: We’ll start with the setup. For us to be able to play the game, the computer
    has to randomly generate a secret code. We need to ensure that the secret code
    doesn’t have any duplicate digits. To us, this sounds like something that’s sufficiently
    complicated and self-contained, so it should be its own subtask function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从设置开始。为了能够玩游戏，电脑必须随机生成一个秘密代码。我们需要确保这个秘密代码没有重复的数字。对我们来说，这听起来像是足够复杂且自成一体的东西，因此它应该是一个独立的子任务函数。
- en: After the computer generates its secret code, we can move to the gameplay itself.
    Here’s where the player starts making their guesses. We might think that we could
    just use `input` to ask the player for their guesses and thereby avoid having
    a separate function for this. But we do need to ensure that the player enters
    the correct number of digits and that they don’t include duplicate digits in their
    guess. This is more than we can do with a single call of `input`, so we’ll make
    this its own function as well.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 电脑生成其秘密代码后，我们可以进入游戏本身。这里是玩家开始猜测的地方。我们可能会认为我们可以简单地使用`input`来询问玩家的猜测，从而避免为这个任务创建一个单独的函数。但我们需要确保玩家输入了正确的数字数量，并且他们的猜测中没有重复的数字。这超出了我们用一个`input`调用的能力，所以我们将把这个任务也作为一个单独的函数来处理。
- en: 'Once the player makes their valid guess, we need to figure out two things:
    How many digits are correct, and how many digits are misplaced? Should we have
    one function to carry out both of these tasks? Or, maybe we should have two functions,
    one for the correct information and one for the misplaced information? We see
    good arguments on each side. If we put the tasks together into the same function,
    we keep the player feedback centralized in one place, and that may make it easier
    for us to confirm it’s written correctly. On the other hand, having two separate
    functions would make it easier to test each type of feedback (correct or misplaced)
    at the expense of spreading out the logic for the feedback across two functions.
    We somewhat arbitrarily chose to use a single function here, but if you were hoping
    to have two separate functions, we encourage you to try that on your own after
    you finish working through this section.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦玩家做出有效的猜测，我们需要弄清楚两件事：有多少数字是正确的，有多少数字是错误的？我们应该有一个函数来完成这两个任务吗？或者，也许我们应该有两个函数，一个用于正确信息，一个用于错误信息？我们在两边都看到了很好的论据。如果我们把任务合并到同一个函数中，我们可以把玩家反馈集中在一个地方，这可能使我们更容易确认它是否正确编写。另一方面，有两个独立的函数会使测试每种类型的反馈（正确或错误）变得更容易，但代价是分散了反馈逻辑到两个函数中。我们在这里多少有些任意地选择使用一个函数，但如果你希望有两个独立的函数，我们鼓励你在完成本节内容后自己尝试一下。
- en: Let’s take stock. We have a function to generate the computer’s secret code.
    We have a function to get the player’s next guess. We have a function to get the
    correct/misplaced clues for the player’s guess. Those are three major subtasks
    that we’re happy to split out of our top-level function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们盘点一下。我们有一个生成电脑秘密代码的函数。我们有一个获取玩家下一个猜测的函数。我们有一个获取玩家猜测的正确/错误提示的函数。这些都是我们乐意从顶层函数中分离出来的三个主要子任务。
- en: Is there any other subtask to split out? There’s certainly a little more work
    to do in our top-level function. For example, we need to detect if the player’s
    guess matches the secret code and end the game in that case. We feel that we don’t
    need a separate function for that, though. To determine whether the user’s guess
    equals the secret code, we can use Python’s `==` operator, which tells us directly
    whether two values are equal. And to end the game, we can use a `return` statement
    to end the top-level game function and thereby stop the program. Similarly, if
    the player uses all of their guesses without getting the secret code, then we
    need to tell them that they lost the game, but again, we should be able to do
    this with a small amount of Python code. As such, we’ll stop here with our main
    top-level function calling three subtask functions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 是否还有其他可以分离的子任务？在我们的顶层函数中确实还有更多的工作要做。例如，我们需要检测玩家的猜测是否与秘密代码匹配，并在这种情况下结束游戏。尽管如此，我们觉得我们不需要为这个任务单独创建一个函数。为了确定用户的猜测是否等于秘密代码，我们可以使用Python的`==`运算符，它直接告诉我们两个值是否相等。而为了结束游戏，我们可以使用`return`语句来结束顶层游戏函数，从而停止程序。同样，如果玩家用完了所有的猜测而没有猜出秘密代码，那么我们需要告诉他们他们输了游戏，但同样，我们可以用一小段Python代码来完成这个任务。因此，我们将在这里停止，我们的主要顶层函数调用三个子任务函数。
- en: When we worked through our spelling suggestions problem in chapter 7, we needed
    to break one of our subtasks into sub-subtasks. But here, each of our three subtasks
    will be manageable as a single function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第7章中处理拼写建议问题时，我们需要将我们的一个子任务分割成子子任务。但在这里，我们的三个子任务中的每一个都可以作为一个单独的函数来管理。
- en: 'For example, let’s think again about our first subtask: generating the computer’s
    secret code, with no duplicate digits allowed. Could we split any sub-subtasks
    out of here? Maybe we could have a function to check whether there are any duplicate
    digits in a proposed secret code. Then, we could keep generating secret codes,
    calling our sub-subtask function until it tells us that there are no duplicates.
    That would work, but we could also just generate the secret code digit by digit
    and not allow a duplicate to be added to the code in the first place. This latter
    plan seems to not need any sub-subtask to be split.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们再次思考我们的第一个子任务：生成计算机的秘密代码，不允许有重复的数字。我们能否从这个地方分割出任何子子任务？也许我们可以有一个函数来检查一个建议的秘密代码中是否有任何重复的数字。然后，我们可以继续生成秘密代码，调用我们的子子任务函数，直到它告诉我们没有重复。这会有效，但我们也可以逐个生成秘密代码的数字，并从一开始就不允许将重复的数字添加到代码中。这个后者的计划似乎不需要分割出任何子子任务。
- en: 'Now let’s think about our second subtask: getting the player’s next guess.
    We could split out a sub-subtask to tell us whether a guess is valid (i.e., it
    has the correct length and has no duplicates). While we could surely do that,
    it’s not much of a stretch to do this with a couple of checks in the subtask function
    itself. (Did your mind just go back to our example in chapter 7 about valid passwords
    and detecting valid passwords, where we split the check for validity into its
    own function? If so, the difference is that checking whether a password is valid
    is likely a more substantial task than the validity checks we need here.) It would
    certainly be okay to break this into another sub-subtask, but we’ll move forward
    without doing so. We’ve already argued that our third subtask is fine as is, so
    we’ll stop our top-down design here.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来考虑我们的第二个子任务：获取玩家的下一个猜测。我们可以将一个子子任务分割出来，告诉我们一个猜测是否有效（即，它有正确的长度且没有重复）。虽然我们当然可以这样做，但在子任务函数本身进行几个检查就足够了。(你的思绪是否回到了第7章中的例子，关于有效密码和检测有效密码，我们将有效性检查分割成自己的函数？如果是这样，区别在于检查密码是否有效可能是一个比我们这里需要的有效性检查更实质性的任务。)当然，我们可以将其分割成另一个子子任务，但我们不会这样做。我们已经论证了我们的第三个子任务本身是可行的，所以我们的自顶向下设计就到这里为止。
- en: We’ll name our top-level function `play`. In it, we’ll call three functions
    corresponding to the three subtasks that we just identified. We’ll call the function
    for our first subtask (generating the computer’s secret code) `random_string`,
    the function for our second subtask (getting the player’s next guess) `get_guess`,
    and the function for our third subtask (providing feedback to the player) `guess_result`.
    See figure 10.3 for this top-down design depicted as a tree.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将命名我们的顶级函数为`play`。在其中，我们将调用三个函数，分别对应我们刚刚确定的三个子任务。我们将我们的第一个子任务（生成计算机的秘密代码）的函数命名为`random_string`，第二个子任务（获取玩家的下一个猜测）的函数命名为`get_guess`，第三个子任务（向玩家提供反馈）的函数命名为`guess_result`。请参见图10.3，了解这种自顶向下设计以树状图的形式表示。
- en: '![figure](../Images/10-3.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/10-3.png)'
- en: Figure 10.3 Top-down design for the Bulls and Cows game. The top-most (left-most)
    function is `play`, which calls `random_string`, `get_guess`, and `guess_result`.
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.3 Bulls and Cows游戏的自顶向下设计。最顶层（最左侧）的函数是`play`，它调用`random_string`、`get_guess`和`guess_result`。
- en: 10.3.3 Parameters and return types
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 参数和返回类型
- en: '*Normally, we define the types of parameters and return value for each function
    during the top-down design itself, but we wanted to discuss that separately here
    because there are some subtle aspects this time. For example, you may already
    be imagining that we’ll use integers to represent the secret code and guesses;
    but, as we’ll see shortly, this isn’t the best choice. We’ll make some decisions
    about how we’ll represent the data for all the functions before we write each
    one.*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*通常，我们在自顶向下的设计过程中本身定义每个函数的参数类型和返回值，但这次我们想在这里单独讨论这一点，因为有一些细微的方面。例如，你可能已经在想象我们将使用整数来表示秘密代码和猜测；但是，正如我们很快就会看到的，这并不是最佳选择。在我们为每个函数编写之前，我们将就如何表示所有函数的数据做出一些决定。*'
- en: '*The `play` function is our top-level function and the starting point for our
    game. It would be possible to have this function take no parameters. Somewhere
    in the code of the function, we’d have to hard-code the fact that the secret code
    has four digits and that the player gets, say, 10 guesses. But that wouldn’t be
    very flexible. What if we wanted to play a version of the game where the secret
    code is seven digits and the player gets 100 guesses? We’d have to go into the
    code and make all the necessary changes. So, to make the game easily configurable,
    we can provide some parameters to this function. For example, rather than always
    having the secret code be four digits, we could use a parameter to allow the length
    of the secret code to be set to whatever we want. Similarly, rather than putting
    the maximum number of player guesses directly into the function, we could make
    that a parameter as well so that we can easily change it. Then, all we need to
    do to alter the gameplay is to call this function with different values for these
    parameters, without having to mess around with the code of the function itself.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*`play`函数是我们顶级函数，也是我们游戏的起点。这个函数可以没有任何参数。在函数的某个地方，我们不得不硬编码秘密代码有四个数字以及玩家有，比如说，10次猜测的事实。但这不会很灵活。如果我们想玩一个秘密代码有七个数字且玩家有100次猜测的游戏版本，我们就必须进入代码并做出所有必要的更改。因此，为了使游戏易于配置，我们可以向这个函数提供一些参数。例如，而不是总是让秘密代码是四位数字，我们可以使用一个参数来允许秘密代码的长度设置为任何我们想要的。同样，而不是直接将玩家猜测的最大次数放入函数中，我们也可以将其作为一个参数，这样我们就可以轻松地更改它。然后，要改变游戏玩法，我们只需要用这些参数的不同值调用这个函数，而不必修改函数本身的代码。'
- en: Using parameters and variables to avoid magic numbers
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用参数和变量来避免魔法数字
- en: The number of allowed guesses and the number of digits in the secret code are
    good examples that we can use to explain an important principle in code design.
    This principle is that when we write code, if a number can be a parameter or variable,
    it should be. This principle ensures the code is as versatile as possible. When
    programmers see a number being used, rather than a friendly name, they call this
    a “magic number” and that’s what we want to avoid. In our discussion about the
    number of guesses the player gets or the number of digits for the secret code,
    those should be parameters if we abide by this principle. At some point, these
    parameters need to be given concrete numbers for the code to work, but we should
    assign them values at the highest level of the code as possible (e.g., the player
    might set these parameters when the game starts).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 允许猜测的次数和秘密代码中的数字位数是我们可以用来解释代码设计中一个重要原则的好例子。这个原则是，当我们编写代码时，如果一个数字可以是参数或变量，它应该是。这个原则确保代码尽可能灵活。当程序员看到使用的是数字而不是友好的名称时，他们称之为“魔法数字”，这正是我们想要避免的。在我们讨论玩家获得的猜测次数或秘密代码的位数时，如果我们遵守这个原则，那些应该是参数。在某个时候，这些参数需要给出具体的数字以便代码能够工作，但我们应该尽可能在代码的最高级别分配它们的值（例如，玩家可能在游戏开始时设置这些参数）。
- en: To help adhere to this general principle, whenever you see a raw number (e.g.,
    4) in the code, ask yourself if that could be a parameter or variable. More often
    than not, it should be.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助遵守这一基本原则，每当你在代码中看到原始数字（例如，4）时，问问自己这能否是一个参数或变量。通常情况下，它应该是。
- en: Adding these parameters is another example, as per our discussion in chapter
    3, of making functions general purpose rather than unnecessarily restrictive.
    Our `random_string` function is the function that generates the computer’s secret
    code. Why did we put `string` in this function name? Shouldn’t we be returning
    a random integer, like 1862? What does a string have to do with this?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在第3章中的讨论，添加这些参数是另一个例子，说明如何使函数通用而不是不必要的限制。我们的`random_string`函数是生成计算机秘密代码的函数。为什么我们在函数名中放`string`？我们不应该返回一个像1862这样的随机整数吗？字符串与这个有什么关系？
- en: Well, the problem with returning an integer is that the secret code might start
    with 0\. A secret code like 0825 is a perfectly valid four-digit secret code.
    But 0825 as an integer is 825, which doesn’t have enough digits. The string `'0825'`
    is just four characters that happen to each be digits, so there’s no problem with
    starting a string like this with a `'0'`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，返回整数的问题在于秘密代码可能以0开头。像0825这样的秘密代码是一个完全有效的四位秘密代码。但0825作为一个整数是825，这没有足够的数字。字符串`'0825'`只是恰好每个都是数字的四个字符，所以以`'0'`开头没有问题。
- en: 'Beyond that, let’s think ahead about what we’ll eventually need to be doing
    with the computer’s secret code. We’ll need to compare it digit by digit with
    the player’s guess to determine which digits match. Using indexing on strings
    will give us easy access to each character of the string, which is exactly what
    we need. It’s more challenging to access each individual digit of an integer:
    integers don’t support indexing!'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，让我们提前思考我们最终需要与计算机的秘密代码做什么。我们需要逐位比较它与玩家的猜测，以确定哪些数字匹配。使用字符串的索引将使我们能够轻松访问字符串中的每个字符，这正是我们所需要的。访问整数的每个单独的数字更具挑战性：整数不支持索引！
- en: 'So, our `random_string` function will take the required number of digits of
    the secret code as a parameter and will return a random string of that length,
    where each character in the string is a digit character. When we talk about digits
    in a string, all we’re referring to are the characters of the string. They happen
    to be digit characters, but they’re still characters, just like `''a''` or `''*''`.
    Don’t be confused by the fact that the string might look like a number! Here’s
    an example showing that these strings work the same way every other string works:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`random_string`函数将接受秘密代码所需数字的数量作为参数，并返回一个相同长度的随机字符串，其中字符串中的每个字符都是数字字符。当我们谈论字符串中的数字时，我们指的是字符串的字符。它们碰巧是数字字符，但它们仍然是字符，就像`'a'`或`'*'`一样。不要被字符串看起来像数字的事实所迷惑！以下是一个示例，说明这些字符串与其他字符串以相同的方式工作：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 We access characters of the string as we always do.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们像往常一样访问字符串的字符。'
- en: '#2 We can’t add a string and an integer.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们不能将字符串和整数相加。'
- en: '#3 This is string concatenation, not numeric addition.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 这不是字符串连接，而是数字相加。'
- en: What about `get_guess`, the function to get the next guess from the player?
    As with `random_string`, this function will need to know the number of digits
    of a valid guess, so we’ll make that a parameter. It will return a string giving
    the player’s guess.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`get_guess`函数呢，它是用来从玩家那里获取下一个猜测的？与`random_string`一样，这个函数需要知道有效猜测的数字数量，所以我们将它作为一个参数。它将返回一个字符串，给出玩家的猜测。
- en: Finally, let’s talk about `guess_result`, the function that tells us how many
    digits are correct and how many are misplaced. This function will need both the
    player’s guess string and the computer’s secret code string in order to make comparisons
    between them, so we’ll need this function to take those two parameters. We need
    to return two pieces of information—the number of digits that are correct and
    the number of digits that are misplaced—so we’ll return a list of two integers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们谈谈`guess_result`函数，这个函数告诉我们有多少位数字是正确的，有多少位是放错了位置的。这个函数将需要玩家的猜测字符串和计算机的秘密代码字符串来进行比较，因此我们需要这个函数接受这两个参数。我们需要返回两份信息——正确的数字数量和放错位置的数字数量——所以我们将返回一个包含两个整数的列表。
- en: 10.3.4 Implementing our functions
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 实现我们的函数
- en: Having completed our top-down design, we can now work with Copilot to write
    the code for each of our functions. As always, we’re going to write the functions
    in order from bottom to top. This means that we’ll first implement our three subtask
    functions and then ultimately implement our top-level `play` function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了我们的自顶向下设计后，我们现在可以与Copilot一起编写我们每个函数的代码。一如既往，我们将从下到上编写函数。这意味着我们首先将实现我们的三个子任务函数，然后最终实现我们的顶级`play`函数。
- en: random_string
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: random_string
- en: As always when working with Copilot to generate code, we provide the `def` line
    and docstring and then Copilot writes the code. In each code listing, we’ll also
    provide some guidance about how the code works.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，当与Copilot一起生成代码时，我们提供`def`行和文档字符串，然后Copilot编写代码。在每一份代码列表中，我们还会提供一些关于代码如何工作的指导。
- en: We want our `random_string` function to take the number of digits in a secret
    code as a parameter and return a random secret code without duplicates. In the
    code for this function, we might expect Copilot to use `random.randint` in a loop
    that continues running as long as we don’t have enough digits. To avoid adding
    duplicate digits, the code would add a random digit to the secret code only if
    that digit isn’t already in there. We found such a solution in our Copilot results,
    and that’s the one we’ve chosen to present in the following listing.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的`random_string`函数接受秘密代码中的数字数量作为参数，并返回一个没有重复的随机秘密代码。在这个函数的代码中，我们可能期望Copilot使用`random.randint`在一个循环中，只要我们没有足够的数字，这个循环就会继续运行。为了避免添加重复的数字，代码只有在那个数字尚未存在于秘密代码中时，才会将一个随机数字添加到秘密代码中。我们在Copilot的结果中找到了这样的解决方案，这就是我们在以下列表中展示的解决方案。
- en: Listing 10.1 Function `random_string` for generating a secret code
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.1 用于生成秘密代码的函数`random_string`
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 Don’t forget to import the random module.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 不要忘记导入random模块。'
- en: '#2 Starts with the empty string (no digits so far) as the secret code'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 从空字符串（目前还没有数字）开始作为秘密代码'
- en: '#3 Loops while we still need digits'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 当我们还需要数字时循环'
- en: '#4 Generates a random integer from 0 to 9'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 生成一个从0到9的随机整数'
- en: '#5 If this digit isn’t already in the secret code . . .'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 如果这个数字还没有在秘密代码中 . . .'
- en: '#6 . . . add this digit to the secret code.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 . . . 将这个数字添加到秘密代码中。'
- en: '#7 Returns the secret code'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 返回秘密代码'
- en: We’re not focusing on testing in this chapter, but even if we were, we wouldn’t
    include exact tests in our docstring for this function. That’s because this function
    has a random result. Randomness can make testing functions difficult because it’s
    hard to control the random values you get. What we could do is add a test to our
    docstring that at least checks that the generated secret code contains the correct
    number of characters, that there are no duplicate characters, and that each character
    is a valid digit. You can also test such functions by running them and observing
    that their result is always within the bounds of your random range and that the
    results appear random.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们并没有专注于测试，即使我们是在测试，我们也不会在这个函数的文档字符串中包含精确的测试。这是因为这个函数的结果是随机的。随机性可能会使测试函数变得困难，因为很难控制你得到的随机值。我们可以做的是在我们的文档字符串中添加一个测试，至少检查生成的秘密代码包含正确的字符数，没有重复的字符，并且每个字符都是有效的数字。你也可以通过运行这些函数并观察它们的结果始终在你的随机范围内，并且结果看起来是随机的来测试这样的函数。
- en: If you did carry through with testing, you’d find that we have a perfectly fine
    implementation of this function and that there’s no need to do more. If you just
    want the game to work, you can skip to where we start writing the `get_guess`
    function. If you’d like to learn more about Python and function design, we’d like
    to take this opportunity to spend a bit more time looking at different solutions
    to this function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你坚持进行测试，你会发现我们对这个函数的实现非常完美，没有必要做更多。如果你只想让游戏工作，你可以跳到开始编写`get_guess`函数的地方。如果你想了解更多关于Python和函数设计的信息，我们想利用这个机会花更多的时间来查看这个函数的不同解决方案。
- en: We encourage you to check out the Copilot suggestions in the window that appears
    when you press Ctrl-Enter to see some of the other possibilities. For example,
    we can start with a list of all the integers from 0 to 9 and then use a function
    called `random.shuffle` to shuffle that list into random order. Then, all we do
    is take the first `length` integers from that shuffled list (where `length` is
    the length of the secret code), and that’s the secret code! We’re guaranteed not
    to get any duplicate digits because the original list that we shuffle doesn’t
    have any duplicate digits. That version of the function might look like the following
    listing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你检查当你按下Ctrl-Enter时出现的窗口中的Copilot建议，以查看其他可能性。例如，我们可以从一个包含从0到9的所有整数的列表开始，然后使用一个名为`random.shuffle`的函数将这个列表随机排序。然后，我们只需从那个打乱顺序的列表中取出前`length`个整数（其中`length`是秘密代码的长度），这就是秘密代码！我们保证不会得到任何重复的数字，因为打乱顺序的原始列表中没有重复的数字。这个函数的版本可能如下所示。
- en: Listing 10.2 Alternative solution for the function `random_string`
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2 函数`random_string`的替代解决方案
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '#1 Creates the list [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 创建列表 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]'
- en: '#2 Shuffles the list in a random order'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 以随机顺序打乱列表'
- en: '#3 Returns the first “length” digits from the shuffled list'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 从打乱顺序的列表中返回前“length”个数字'
- en: If you want to learn more about what this code is doing, you have the tools
    to do that! Don’t assume that the code is out of your grasp. You can ask Copilot
    to explain the code. You might get an explanation like the following.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于这段代码的功能，你拥有相应的工具去做！不要假设代码超出了你的理解范围。你可以让Copilot解释代码。你可能会得到以下这样的解释。
- en: LPHumanWhat does my `random_string` function do?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman我的`random_string`函数做什么？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot The code is a Python function
    called `random_string` that takes an integer `length` as input and returns a string
    of the given length, where each character is a digit from 0 to 9, and with no
    repeated digits.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 该代码是一个名为`random_string`的Python函数，它接受一个整数`length`作为输入，并返回一个给定长度的字符串，其中每个字符都是0到9之间的数字，且没有重复的数字。'
- en: The function first creates a list of digits from 0 to 9 using the `range` function
    and the `list` constructor. It then shuffles the list using the `shuffle` function
    from the random module. This ensures that the digits are in a random order.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先使用`range`函数和`list`构造函数创建一个从0到9的数字列表。然后使用random模块中的`shuffle`函数打乱列表。这确保了数字的随机顺序。
- en: Finally, the function uses a list comprehension to convert the first `length`
    digits of the shuffled list to strings and join them together into a single string
    using the `join` method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该函数使用列表推导式将打乱列表的前`length`个数字转换为字符串，并使用`join`方法将它们连接成一个单一的字符串。
- en: Overall, the `random_string` function generates a random string of digits with
    no repeated digits, which can be useful for generating unique identifiers or passwords.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，`random_string`函数生成一个没有重复数字的随机数字字符串，这对于生成唯一的标识符或密码很有用。
- en: What’s a *list comprehension*? You don’t need to figure this out on your own,
    you can ask Copilot to explain it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是*列表推导式*？你不需要自己解决这个问题，你可以询问Copilot来解释它。
- en: LPHumanHow does that list comprehension work?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman这个列表推导式是如何工作的？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot The list comprehension in the
    `random_string` function is used to convert the first `length` digits of the shuffled
    list to strings and join them together into a single string using the `join` method.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot该函数中的列表推导式用于将打乱列表的前`length`个数字转换为字符串，并使用`join`方法将它们连接成一个没有分隔符的单个字符串。'
- en: 'Here’s a breakdown of how the list comprehension works:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是列表推导式是如何工作的分解：
- en: '`str(d)` for d in `digits[:length]` is the expression that generates the list
    of strings. It takes each digit in the first `length` elements of the `digits`
    list, converts it to a string using the `str` function, and returns the resulting
    string.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`str(d)` for d in `digits[:length]`是生成字符串列表的表达式。它将`digits`列表前`length`个元素中的每个数字转换为字符串，使用`str`函数，并返回结果字符串。'
- en: '`digits[:length]` is the iterable that the list comprehension operates on.
    It takes the first `length` elements of the `digits` list, which have been shuffled
    randomly.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`digits[:length]`是列表推导式操作的迭代器。它取`digits`列表的前`length`个元素，这些元素已经被随机打乱。'
- en: The entire list comprehension is enclosed in square brackets, which creates
    a new list from the elements generated by the expression.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个列表推导式被括号包围，它从表达式生成的元素中创建了一个新列表。
- en: Finally, the `join` method is called on the resulting list of strings to join
    them together into a single string with no separator between them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在生成的字符串列表上调用`join`方法，将它们连接成一个没有分隔符的单个字符串。
- en: Some of this text from Copilot may not be completely understandable, but you
    could keep asking it to explain what you’re unsure about until you’re satisfied
    you understand how this is working.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot的一些文本可能不完全易懂，但你可以继续询问它解释你不确定的部分，直到你满意地理解了它是如何工作的。
- en: We didn’t need to show this second working solution for this function, but we
    want to take this opportunity to remind you of how far you’ve come. As you’ve
    progressed through the book, you’ve been developing tools and techniques to understand
    and create software as well as the confidence to learn and keep learning more!
    Getting back to the problem at hand, let’s code our next function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要展示这个函数的第二个工作解决方案，但我们要借此机会提醒你已经走了多远。随着你通过本书的进展，你一直在开发工具和技术来理解和创建软件，以及学习和持续学习的信心！回到我们手头的这个问题，让我们编写我们的下一个函数。
- en: get_guess
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: get_guess
- en: Our `get_guess` function takes the number of required digits as a parameter
    and returns a valid guess from the player. Remember that for a guess to be valid,
    it must contain the right number of digits, and it must not have any duplicate
    digits. Here’s what we got from Copilot in the following listing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`get_guess`函数接受所需数字的数量作为参数，并从玩家那里返回一个有效的猜测。记住，为了使猜测有效，它必须包含正确的数字数量，并且不能有任何重复的数字。以下是我们从Copilot获取的以下列表中的内容。
- en: Listing 10.3 Function `get_guess` for user input
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.3 函数`get_guess`用于用户输入
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#1 First tries to get a valid guess from the player'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 首先尝试从玩家那里获取一个有效的猜测'
- en: '#2 While length is wrong, or the guess isn’t all digits or has duplicates .
    . .'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 当长度错误，或者猜测不是全部数字或者有重复时……'
- en: '#3 . . . subsequently tries to get a valid guess from the player'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 ……随后尝试从玩家那里获取一个有效的猜测'
- en: '#4 Returns the valid guess'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 返回有效的猜测'
- en: That `while-loop` condition is a complex one! The final part, `len(set(guess))`
    `!=` `length`, is responsible for checking whether the user entered any duplicate
    digits. It’s using a Python set to do that. We did see this trick back in chapter
    7, section 7.7.7, but that was a while ago! So, if you need a refresher, don’t
    hesitate to ask Copilot for an explanation of that line.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 `while-loop` 条件是复杂的！最后一部分，`len(set(guess))` `!=` `length`，负责检查用户是否输入了任何重复的数字。它是使用
    Python 集合来做到这一点的。我们确实在第七章的 7.7.7 节中看到过这个技巧，但那是很久以前的事情了！所以，如果你需要复习，不要犹豫，向 Copilot
    请求解释那一行。
- en: guess_result
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: guess_result
- en: 'Our `guess_result` function takes two strings as parameters: the player’s most
    recent guess and the secret code. It returns a list of two integers: the number
    of correct digits and the number of misplaced digits.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `guess_result` 函数接受两个字符串作为参数：玩家的最新猜测和秘密代码。它返回一个包含两个整数的列表：正确数字的数量和错误数字的数量。
- en: This is a tricky function to get right, so even though we haven’t been showing
    the tests we’d want to run in prior functions, we’re going to provide some explicit
    tests in the docstring for this function. We’re adding these docstring tests because
    the logic for this function is going to be complex enough that it will be hard
    to determine whether the code is correct by solely reading the code. For our docstring
    tests, we’ll need some good example cases of different secret codes and user guesses
    to ensure the number of correct and misplaced digits returned by the function
    are as expected. Of course, per chapter 6, you’d likely want to add even more
    test cases if you were interested in doing serious testing. Our first test case
    is
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个难以正确实现的函数，因此尽管我们之前没有在先前的函数中展示我们想要运行的测试，但我们将在该函数的文档字符串中提供一些明确的测试。我们添加这些文档字符串测试是因为这个函数的逻辑将足够复杂，以至于仅通过阅读代码很难确定代码是否正确。对于我们的文档字符串测试，我们需要一些不同秘密代码和用户猜测的示例案例，以确保函数返回的正确和错误数字的数量符合预期。当然，根据第
    6 章，如果你对进行严肃的测试感兴趣，你可能还想添加更多的测试用例。我们的第一个测试用例是
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The correct return value here is `[1,` `2]` because there’s one digit that’s
    correct (the 8), and two misplaced digits (the 2 and the 1). Our second test case
    is
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的正确返回值是 `[1,` `2]`，因为有一个数字是正确的（8），还有两个错误的数字（2 和 1）。我们的第二个测试用例是
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The correct return value this time is `[0,` `4]` because there are zero correct
    digits, but all four digits of the guess are misplaced. Here’s our complete docstring,
    including test cases, and the code from Copilot.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的正确返回值是 `[0,` `4]`，因为没有正确的数字，但猜测中的所有四个数字都是错误的。以下是我们的完整文档字符串，包括测试用例和 Copilot
    的代码。
- en: Listing 10.4 Function `guess_result` to get the result of a guess
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4 函数 `guess_result` 用于获取猜测的结果
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#1 This variable is for the correct digits.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这个变量用于记录正确的数字。'
- en: '#2 This variable is for the misplaced digits.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这个变量用于记录错误的数字。'
- en: '#3 Goes through each index of the digit strings'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 遍历数字字符串的每个索引'
- en: '#4 This digit is correct.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 这个数字是正确的。'
- en: '#5 Increases correct count by 1'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 将正确计数增加 1'
- en: '#6 This isn’t a match but is misplaced.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 这不是匹配但却是错误的。'
- en: '#7 Increases misplaced count by 1'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 将错误计数增加 1'
- en: '#8 Returns both results in a list'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 返回列表中的两个结果'
- en: The use of `elif` is subtle here. If it were written as `if` rather than `elif`,
    then the code would be wrong! Do you see why? If not, try conversing with Copilot
    before continuing to read our explanation here.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用 `elif` 是微妙的。如果它被写成 `if` 而不是 `elif`，那么代码就会出错！你明白为什么吗？如果不明白，在继续阅读这里的解释之前，试着与
    Copilot 进行对话。
- en: Suppose that the `if` condition `guess[i]` `==` `secret_code[i]` is `True`.
    In that case, we increase `correct` by 1, and we skip the `elif` statements. (Remember,
    the `elif` statements run only if the preceding `if` and any preceding `elif`
    conditions are `False`.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `if` 条件 `guess[i]` `==` `secret_code[i]` 是 `True`。在这种情况下，我们将 `correct` 增加
    1，并跳过 `elif` 语句。（记住，只有当前面的 `if` 和任何前面的 `elif` 条件为 `False` 时，`elif` 语句才会运行。）
- en: Now, imagine we changed the `elif` to an `if`. If the `if` condition `guess[i]`
    `==` `secret_code[i]` is `True`, we’d still increase `correct` by 1\. But then,
    we’d check the `guess[i]` `in` `secret_code` condition, and this one would be
    `True` as well. After all, we just said that `guess[i]` `==` `secret_code[i]`,
    which proves that `guess[i]` is indeed somewhere in `secret_code`. So, we’d erroneously
    do the `misplaced` `+=` `1`, which we certainly don’t want to do (it’s a matched
    digit, not a misplaced one too)!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，如果我们把`elif`改为`if`。如果`if`条件`guess[i] == secret_code[i]`为`True`，我们仍然会增加`correct`的值。但然后，我们会检查`guess[i]
    in secret_code`条件，这个条件也会是`True`。毕竟，我们刚刚说过`guess[i] == secret_code[i]`，这证明了`guess[i]`确实在`secret_code`中某个位置。所以，我们会错误地执行`misplaced
    += 1`，而这绝对是我们不希望做的（它是一个匹配的数字，而不是一个错误的数字）！
- en: play
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: play
- en: We’re done with our subtask functions! Now all we need to do is write the `play`
    top-level function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了子任务函数！现在我们只需要编写`play`顶级函数。
- en: 'Our `play` function takes two integers as parameters: the number of digits
    in the secret code and guesses, and the number of guesses that the player has
    to guess the secret code. It doesn’t return anything—it just plays the game! Our
    final prompt and code for this function is given in the following listing.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`play`函数接受两个整数作为参数：秘密代码中的数字数量和猜测次数，以及玩家需要猜测秘密代码的猜测次数。它不返回任何内容——它只是玩游戏！我们这个函数的最终提示和代码如下所示。
- en: Listing 10.5 Function `play` for playing the game
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.5 游戏的`play`函数
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#1 Generates the computer’s secret code'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 生成计算机的秘密代码'
- en: '#2 Loops once for each possible player guess'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 对每个可能的玩家猜测循环一次'
- en: '#3 Gets the next valid guess from the player'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 从玩家那里获取下一个有效的猜测'
- en: '#4 Gets the “correct” and “misplaced” feedback for this guess'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 获取对这个猜测的“正确”和“错误位置”反馈'
- en: '#5 Tells the player the hints'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 告诉玩家提示信息'
- en: '#6 Player correctly guesses the secret code!'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 玩家正确猜出了秘密代码！'
- en: '#7 Exits the function; this ends the game.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 退出函数；这标志着游戏的结束。'
- en: '#8 If we get here, then the player ran out of guesses.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 如果我们到达这里，那么玩家已经用完了猜测次数。'
- en: 'If we ran our program now, nothing would happen. That’s because we haven’t
    called the `play` function yet! We always need to remember to call our top-level
    function. To call it, we can add this line below the `play` function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行程序，什么也不会发生。那是因为我们还没有调用`play`函数！我们总是需要记得调用我们的顶级函数。要调用它，我们可以在`play`函数下方添加这一行：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `4` means that we’re playing with four-digit codes and guesses, and the
    `10` means that we have 10 guesses to correctly guess the secret code. You can
    change these arguments to tune the game how you like.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 数字`4`表示我们正在使用四位数代码和猜测，而数字`10`表示我们有10次机会正确猜测秘密代码。你可以更改这些参数来调整你喜欢的游戏。
- en: 'Let’s give our game a whirl before we continue. We’ll show our first few guesses
    and then our final guess:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们试玩一下我们的游戏。我们将展示我们的前几个猜测，然后是我们的最终猜测：
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ve succeeded in designing a computer game, which is a very different kind
    of program than the other programs we’ve written in this book. Our computer game
    interacts with the user, has randomness, involves two players (the human player
    guessing and the computer player providing the correct/misplaced clues), and has
    winning and losing conditions. That’s a lot of new stuff! However, we also hope
    that you see how much we’ve learned and brought forward from prior chapters. We’re
    still doing top-down design, still designing functions, still testing code, still
    reading code, and still conversing with Copilot. You hadn’t written a game prior
    to this chapter, but essentially, you already had the skills to do that. Don’t
    let a seemingly new type of program or app stop you from trying to do it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功设计了一个计算机游戏，这与其他我们在本书中编写的程序非常不同。我们的计算机游戏与用户互动，具有随机性，涉及两个玩家（人类玩家猜测和计算机玩家提供正确/错误提示），并且有胜负条件。这有很多新内容！然而，我们也希望你能看到我们从前面的章节中学到了多少，并取得了哪些进步。我们仍在进行自顶向下的设计，仍在设计函数，仍在测试代码，仍在阅读代码，并且仍在与Copilot进行对话。在写这一章之前，你可能没有编写过游戏，但本质上，你已经具备了编写游戏所需的技能。不要让看似新的程序或应用类型阻止你尝试去做。
- en: 10.3.5 Adding a graphical interface for Bulls and Cows
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.5 为Bulls and Cows添加图形界面
- en: You might be disappointed that our game doesn’t look much like a game you’ve
    recently played because there are no graphics, just text. For example, there’s
    no nice area to type in, no buttons to click, and no graphical interface at all.
    We’ve already argued why we focus on text games in this chapter, but it doesn’t
    mean that turning this game into a graphical interface version is entirely out
    of your grasp because you could interact with Copilot to see if it can help you
    get started.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对我们的游戏看起来不像你最近玩过的游戏而感到失望，因为没有图形，只有文本。例如，没有好的输入区域，没有可以点击的按钮，也没有任何图形界面。我们已经在本章中讨论了为什么我们专注于文本游戏，但这并不意味着将这个游戏转换成图形界面版本完全超出了你的能力范围，因为你可以通过与Copilot交互来查看它是否可以帮助你开始。
- en: The challenge is that programmers create graphical user interfaces using a style
    of programming called *event-driven programming,* which we haven’t taught you
    yet and is too large to teach in this chapter. You can likely read through event-driven
    programming code and make some sense of it, and that’s what you’d need to do if
    you ask Copilot to write code to produce a graphical interface. That said, if
    Copilot doesn’t give you what you want, it may be difficult to fix without first
    becoming familiar with event-driven programming. There’s a nice book on game programming
    that includes graphical user interfaces and event-driven programming in Python
    called *Invent Your Own Computer Games with Python* [3] if you’d like to learn
    more.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于程序员使用一种称为*事件驱动编程*的编程风格来创建图形用户界面，这是我们还没有教过你的，而且在这个章节中也无法详细讲解。你可能会阅读事件驱动编程的代码并对其有所理解，如果你要求Copilot编写代码来生成图形界面，你将需要这样做。然而，如果Copilot没有给你你想要的结果，在没有首先熟悉事件驱动编程的情况下，可能很难修复。如果你想要了解更多，有一本关于游戏编程的好书，它包括使用Python的图形用户界面和事件驱动编程，书名为*用Python发明你自己的电脑游戏*
    [3]。
- en: Event-driven programming
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 事件驱动编程
- en: Event-driven programming is commonly used for programs that interact with users.
    At a high level, the program sets up a way for the user to interact with the program
    (e.g., by pressing buttons or entering text) and then just sits and waits for
    the user to do something, sometimes updating the state of the game while waiting
    for the user input. Once the human interacts with the game, the code recognizes
    this interaction as an *event*,and each event has code associated with it that
    should execute when the event occurs. For example, when a user clicks the Quit
    Game button, it triggers the code that needs to be executed when the user wants
    to quit (e.g., saving the state of the game and exiting the program).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动编程通常用于与用户交互的程序。在较高层次上，程序设置了一种用户与程序交互的方式（例如，通过按按钮或输入文本），然后只是坐着等待用户做些什么，有时在等待用户输入的同时更新游戏状态。一旦人类与游戏交互，代码就会将这种交互识别为*事件*，每个事件都与执行时应该运行的代码相关联。例如，当用户点击退出游戏按钮时，它会触发当用户想要退出时需要执行的代码（例如，保存游戏状态并退出程序）。
- en: 'We were quite impressed by what Copilot gave us when we asked it to create
    the graphical interface for Bulls and Cows, so we’d like to show you how well
    it did. The code is somewhat readable even without knowing event-driven programming.
    For example, you can probably find the title of the game and change it. To do
    this, we asked Copilot Chat the following question:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们要求Copilot为Bulls and Cows创建图形界面时，我们对它给出的结果印象深刻，所以我们想展示它做得有多好。即使不了解事件驱动编程，代码也相对容易阅读。例如，你可能可以找到游戏的标题并更改它。为此，我们向Copilot
    Chat提出了以下问题：
- en: LPHumanCan you convert this program to use a graphical interface instead of
    a text interface?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman能否将这个程序转换为使用图形界面而不是文本界面？
- en: Copilot responded to us by laying out, step by step, the changes that we’d need
    to make to do so. It then rewrote the code so that the game now used a graphical
    interface with buttons and edit boxes, rather than a text interface. See figure
    10.4 for the new interface. The code to generate this interface is on the website
    for the book in case you’re interested in running it yourself or learning about
    the code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot通过逐步列出我们需要做出的更改来回应我们。然后它重写了代码，使游戏现在使用带有按钮和编辑框的图形界面，而不是文本界面。有关新界面的详细信息，请参阅图10.4。生成此界面的代码可以在本书的网站上找到，如果你有兴趣运行它或了解代码的话。
- en: '![figure](../Images/10-4.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/10-4.png)'
- en: Figure 10.4 The graphical interface for the game as provided by Copilot. Note
    that it shows the secret code, presumably to help with testing (you’d want to
    remove that before playing the game).
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4 由Copilot提供的游戏图形界面。请注意，它显示了秘密代码，可能是为了帮助测试（您在玩游戏之前应该将其删除）。
- en: '10.4 Example 2: Bogart'
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 示例2：Bogart
- en: '*Our second game will be a two-player dice game. In Bulls and Cows, one of
    our players was human and the other was the computer. This time, we’ll write a
    game for two human players. Randomness again will play a key role. Once we’re
    done, you can play against a friend or family member!*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们的第二个游戏将是一款两人掷骰子游戏。在Bulls and Cows中，我们的一个玩家是人类，另一个是电脑。这次，我们将为两个玩家编写游戏。随机性再次将扮演关键角色。完成后，您可以和朋友或家人玩！*'
- en: '*### 10.4.1 How the game works'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*### 10.4.1 游戏的工作原理'
- en: The game that we’ll be writing here is called Bogart and was designed by Crab
    Fragment Labs. This is a dice game for two players. The game also uses a pot of
    chips or coins. We obviously won’t need actual dice or chips, though, as we’re
    implementing this as a computer game.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的游戏被称为Bogart，由Crab Fragment Labs设计。这是一款两人掷骰子游戏。游戏还使用筹码或硬币。显然，我们不需要实际的骰子或筹码，因为我们正在将其作为电脑游戏实现。
- en: Bogart
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Bogart
- en: 'The Bogart game was designed by James Ernest (© 1999 James Ernest and Cheapass
    Games, used by permission; [https://crabfragmentlabs.com/](https://crabfragmentlabs.com/)).
    You can download the instructions for the original game for free as part of a
    .pdf file of games: [https://crabfragmentlabs.com/shop/p/chief-herman-1](https://crabfragmentlabs.com/shop/p/chief-herman-1).
    If you enjoy the game and can’t stop playing our re-creation, we encourage you
    to support the work that Crab Fragment Labs is doing. We thank them for letting
    us use their game here!'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Bogart游戏由詹姆斯·欧内斯特设计（© 1999 詹姆斯·欧内斯特和Cheapass Games，经许可使用；[https://crabfragmentlabs.com/](https://crabfragmentlabs.com/))。您可以从以下链接免费下载原始游戏的说明手册作为游戏.pdf文件的一部分：[https://crabfragmentlabs.com/shop/p/chief-herman-1](https://crabfragmentlabs.com/shop/p/chief-herman-1)。如果您喜欢这款游戏，并且无法停止玩我们的复制品，我们鼓励您支持Crab
    Fragment Labs正在进行的工作。我们感谢他们允许我们在这里使用他们的游戏！
- en: When the game starts, the pot of chips is empty (has no chips in it). One of
    the two players is randomly chosen to start the game. From there, each player
    takes turns until the game is over. We’ll first explain what it means for a player
    to take a turn and then give the rules for when the game ends. Figure 10.5 provides
    an overview of the flow of the game as well.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏开始时，筹码堆是空的（里面没有筹码）。两个玩家中的一个被随机选中开始游戏。从那里，每个玩家轮流进行，直到游戏结束。我们首先解释玩家如何进行回合，然后给出游戏结束的规则。图10.5还提供了游戏流程的概述。
- en: At the beginning of a player’s turn, one chip gets added to the pot, and that
    player rolls one die. If that die is a 1, then the player’s turn is over, and
    they don’t collect any chips. If that die isn’t a 1, then the player gets to decide
    whether to continue their turn or not. If they decide not to continue their turn,
    they collect all the chips from the pot (making the pot empty).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家回合开始时，一枚筹码被加入筹码堆，该玩家掷一枚骰子。如果那枚骰子是1，那么玩家的回合就结束了，他们不会收集任何筹码。如果那枚骰子不是1，那么玩家可以决定是否继续他们的回合。如果他们决定不继续回合，他们将收集筹码堆中的所有筹码（使筹码堆为空）。
- en: '![figure](../Images/10-5.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-5.png)'
- en: Figure 10.5 Player turn in Bogart
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.5 Bogart游戏中的玩家回合
- en: If they do decide to continue their turn, then two chips get added to the pot,
    and they roll two dice. If one or both of those dice is a 1, then the player’s
    turn is over. Otherwise, the player again gets to decide whether to continue their
    turn or not.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们决定继续他们的回合，那么将有两枚筹码加入筹码堆，然后他们掷两枚骰子。如果其中一枚或两枚骰子是1，那么玩家的回合就结束了。否则，玩家再次决定是否继续他们的回合。
- en: If they continue their turn, then they roll three dice, then four dice, and
    then five dice. (Players can’t choose to skip a number of dice; they must work
    through the number of dice sequentially starting from one die.) If they ever roll
    a 1, then their turn ends, and they don’t collect any chips. If they decide not
    to continue their turn, then they collect all the chips from the pot.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们继续他们的回合，那么他们掷三枚骰子，然后掷四枚骰子，然后掷五枚骰子。（玩家不能选择跳过一定数量的骰子；他们必须从一枚骰子开始依次掷出所有骰子。）如果他们掷出了1，那么他们的回合结束，他们不会收集任何筹码。如果他们决定不继续回合，那么他们将从筹码堆中收集所有筹码。
- en: Rolling a 1 in this game is bad news for the current player. When rolling one
    die, the probability of rolling a 1 is low, only 1 in 6 (about 17%). When rolling
    two dice, the probability of rolling at least one 1 is higher, this time about
    31%. It’s higher still when rolling three dice (42%), four dice (52%), or five
    dice (60%). So, the longer you extend your turn, the higher the probability that
    you’ll eventually roll a 1 and get nothing for your turn. Worse, you’ll likely
    leave the pot quite full for the other player to collect if they play more conservatively
    than you. At the same time, the longer you extend your turn, the faster the chips
    in the pot accumulate and the more chips you can collect assuming that you do
    successfully end your turn eventually. The whole trick is to decide when to press
    your luck for more chips and when to take what you’ve got.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中掷出1点对当前玩家来说是个坏消息。掷一枚骰子时，掷出1点的概率很低，只有1/6（大约17%）。掷两枚骰子时，至少掷出一个1点的概率更高，这次大约是31%。掷三枚骰子时（42%），掷四枚骰子时（52%），或者掷五枚骰子时（60%），概率更高。所以，你延长回合的时间越长，最终掷出1点并一无所获的概率就越高。更糟糕的是，如果你比对方更保守地玩，你可能会给对方留下一个满满的赌注。同时，你延长回合的时间越长，赌注中的筹码积累得就越快，假设你最终成功结束回合，你可以收集的筹码就越多。整个技巧就是决定何时冒险获取更多筹码，何时收手。
- en: 'This is how a player’s turn works. Players alternate turns, rolling dice and
    collecting chips, until the game ends. There are two ways that the game can end:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是玩家回合的工作方式。玩家轮流进行回合，掷骰子并收集筹码，直到游戏结束。游戏有三种结束方式：
- en: If a player collects a total of 30 or more chips, then that player wins.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一名玩家总共收集到30枚或更多的筹码，那么这名玩家就赢了。
- en: 'Say a player on their turn rolls one die, then two dice, then three, then four,
    and then five, never once rolling a 1\. Then, that player instantly wins. It doesn’t
    matter how many chips they’ve collected: if they get to five dice of which none
    are a 1, they win.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设一名玩家在他们的回合中掷出一枚骰子，然后两枚，接着三枚，然后四枚，最后五枚，一次也没有掷出1点。那么，这名玩家立刻获胜。他们收集了多少筹码并不重要：如果他们掷出五枚骰子，其中没有一枚是1点，他们就会赢。
- en: Example game of Bogart
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 博格特游戏示例
- en: Let’s play out a few turns of the game to make sure we’re clear on how it all
    works. The pot starts out empty. Let’s say that Player 1 is the player randomly
    chosen to go first. We add one chip to the pot, and Player 1 rolls one die. Let’s
    say that they roll a 5\. Now Player 1 has to decide whether to end their turn
    and take the one chip from the pot or continue their turn.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩几轮游戏，以确保我们清楚游戏是如何运作的。赌注一开始是空的。假设玩家1是被随机选中的第一个玩家。我们向赌注中加一枚筹码，玩家1掷一枚骰子。假设他们掷出了5点。现在玩家1必须决定是否结束他们的回合并从赌注中拿走一枚筹码，或者继续他们的回合。
- en: Let’s say that they continue their turn. We add two chips to the pot; now the
    pot has three chips. Player 1 rolls two dice. Let’s say they roll a 4 and a 2.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 假设他们继续他们的回合。我们向赌注中加两枚筹码；现在赌注中有三枚筹码。玩家1掷两枚骰子。假设他们掷出了4点和2点。
- en: Should they end their turn and take the three chips? Nah, nah. They want more.
    They continue their turn. We add three chips to the pot; now the pot has six chips.
    Player 1 rolls three dice. This time, they roll a 6, a 5, and—oh no!—a 1\. Player
    1’s turn is over. They got no chips, and they left a juicy six chips in the pot
    for Player 2.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 他们应该结束回合并拿走三枚筹码吗？不，不。他们想要更多。他们继续他们的回合。我们向赌注中加三枚筹码；现在赌注中有六枚筹码。玩家1掷三枚骰子。这次，他们掷出了6点、5点，哦不！——一枚1点。玩家1的回合结束了。他们没有得到任何筹码，并且给玩家2留下了六个诱人的筹码。
- en: Now it’s Player 2’s turn. We add one chip to the pot—that’s seven chips now!—and
    Player 2 rolls one die. Let’s say that they roll a 2\. If Player 2 ends their
    turn now, they’ll collect the seven chips from the pot. That feels like a lot,
    so let’s say that Player 2 does decide to end their turn.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轮到玩家2了。我们在赌注中加一枚筹码——现在总共有七枚筹码了！——然后玩家2掷一枚骰子。假设他们掷出了2点。如果玩家2现在结束他们的回合，他们将收集赌注中的七枚筹码。这感觉很多，所以让我们假设玩家2决定结束他们的回合。
- en: 'Now the pot is empty, and it’s back to being Player 1’s turn. Player 1 has
    some catching up to do: they have 0 chips and Player 2 has 7 chips. We’ll stop
    here, but the game will continue until one of the players racks up 30 or more
    chips or they get to roll five dice and manage not to roll a single 1.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在赌注已经空了，轮到玩家1了。玩家1需要追赶：他们有0枚筹码，而玩家2有7枚筹码。我们在这里停下来，但游戏将继续进行，直到其中一名玩家积累到30枚或更多的筹码，或者他们掷出五枚骰子并且没有掷出任何1点。
- en: 10.4.2 Top-down design
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 自顶向下的设计
- en: 'As was the case when we implemented our Bulls and Cows game, implementing Bogart
    is a large problem for which we need top-down design. We’ll offer that design
    now, but here we encourage you to try it on your own before continuing. We recommend
    this because we found an effective top-down design to be subtle for this game
    due to the number of interacting elements. For example, a player’s turn can end
    in one of three ways: collect the chips, don’t collect the chips, and instantly
    win. We need to be able to determine which of these situations happened. As another
    example, after each player’s turn, we need to switch to the other player—except,
    unfortunately, not always: if a player wins the game, we want to stop the game
    right there and declare them the winner, not switch to the other player! We’ll
    primarily focus on our successful top-down design here, but we’ll occasionally
    justify why we made our decisions and what went wrong with other decisions.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在实现我们的牛牛游戏时的情况一样，实现博加特是一个大问题，我们需要自顶向下的设计。我们现在将提供这个设计，但在这里我们鼓励你在继续之前自己尝试一下。我们推荐这样做是因为我们发现，由于交互元素的众多，这个游戏的自顶向下设计非常微妙。例如，玩家的回合可以以三种方式结束：收集筹码、不收集筹码，以及立即获胜。我们需要能够确定这些情况中的哪一种发生了。作为另一个例子，在每个玩家的回合之后，我们需要切换到另一个玩家——但不幸的是，并不总是这样：如果一个玩家赢得了游戏，我们希望在那一刻停止游戏并宣布他们为胜者，而不是切换到另一个玩家！我们将主要关注我们的成功自顶向下设计，但偶尔我们会解释我们为什么做出某些决定，以及其他决定为什么出错。
- en: 'We’ll name our top-level function `play`. Here are the main subtasks that we’ll
    need to solve for our game:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将命名我们的顶级函数为`play`。以下是我们需要解决游戏的主要子任务：
- en: Initialize the pot, and start Player 1 and Player 2 with zero chips. This is
    part of the game setup phase.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化筹码池，并将玩家1和玩家2的筹码数设为零。这是游戏设置阶段的一部分。
- en: Randomly choose Player 1 or Player 2 to start the game. This too is part of
    the game setup.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机选择玩家1或玩家2开始游戏。这同样是游戏设置的一部分。
- en: 'Now we enter the gameplay phase. While the game isn’t over, do the following:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们进入游戏阶段。只要游戏没有结束，就执行以下操作：
- en: Print the number of chips in the pot, number of chips Player 1 has, and number
    of chips Player 2 has.
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印筹码池中的筹码数，玩家1的筹码数，以及玩家2的筹码数。
- en: Take a full turn for the current player.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为当前玩家转动一圈。
- en: If the current player won chips, give the chips to the current player, and reset
    the pot to have zero chips.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前玩家赢得了筹码，就将筹码给当前玩家，并将筹码池重置为零筹码。
- en: Switch to the other player’s turn.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到另一个玩家的回合。
- en: Print the name of the player (Player 1 or Player 2) who won the game.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印获胜游戏的玩家（玩家1或玩家2）的名字。
- en: At this point in the book, we suspect you’ve become familiar enough with the
    code from Copilot to have some nice intuition about which of these tasks will
    require separate functions. Task 1 is just a few variable assignments, so we don’t
    need a separate function for that. Other tasks for which we don’t need a separate
    function are task 2 (just a call to `random.randint`), 3a (just a few `print`
    calls), and 4 (a `print` call). We’ll capture each of the remaining subtasks in
    a function. The following subsections describe each of the remaining subtasks.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们怀疑你已经足够熟悉Copilot的代码，对哪些任务需要单独的函数有一些很好的直觉。任务1只是几个变量赋值，所以我们不需要为那个任务创建一个单独的函数。我们不需要为以下任务创建单独函数的任务还包括任务2（只是一个对`random.randint`的调用）、3a（几个`print`调用）和4（一个`print`调用）。我们将把剩余的子任务捕获在函数中。以下小节将描述每个剩余的子任务。
- en: Task 3\. While the game isn’t over
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务3。当游戏没有结束时
- en: We’ll have a `while` loop that continues while the game isn’t over, so we’ll
    need a function to tell us whether the game is over! How can the function know
    whether the game is over? It’ll need to know the current number of chips that
    Player 1 has and the current number of chips that Player 2 has. That way, it can
    check whether one of these is at least 30\. But remember that there’s another
    way for the game to end, and that’s when a player rolls five dice, none of which
    is a 1\. Therefore, this function will also need to know the most recent dice
    rolls for the current player.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个`while`循环，只要游戏没有结束就会继续，所以我们需要一个函数来告诉我们游戏是否结束！这个函数如何知道游戏是否结束？它需要知道当前玩家1和玩家2的筹码数。这样，它可以检查这些数中的任何一个是否至少为30。但记住，游戏还有另一种结束方式，那就是当一个玩家掷出五颗骰子，且没有一颗是1时。因此，这个函数还需要知道当前玩家的最近一次骰子滚动情况。
- en: 'We’ll name this function `game_over`. It will take three parameters: Player
    1 chips, Player 2 chips, and list of rolls. It will return `True` if the game
    is over and `False` otherwise. The code for this function will need to check a
    few conditions, but we should be able to do that without splitting it out into
    further subtasks.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个函数命名为`game_over`。它将接受三个参数：玩家1的筹码、玩家2的筹码和骰子点数列表。如果游戏结束，则返回`True`，否则返回`False`。这个函数的代码需要检查几个条件，但我们应该能够做到这一点，而无需将其拆分成更小的子任务。
- en: Task 3b. Take a full turn for the current player
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务3b. 为当前玩家进行一次完整的回合
- en: 'We’ll name this function `take_full_turn`. The function *needs* to know how
    many chips are in the pot right now, so that it can update that as needed. It’ll
    also need to return the updated number of chips in the pot. Beyond that, there’s
    a lot that we need to manage to carry out a full turn, so we’re going to need
    to keep the complexity of this function under control. Here’s what comes to mind
    for what this function may need to do:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个函数命名为`take_full_turn`。这个函数*需要*知道现在筹码堆中有多少筹码，以便根据需要更新它。它还需要返回更新后的筹码堆中的筹码数量。除此之外，我们还需要管理很多事情才能完成一个完整的回合，因此我们需要控制这个函数的复杂性。以下是这个函数可能需要做的事情：
- en: Allow the player to roll one die, then two dice, then three dice, and so on
    until the player’s turn is over.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许玩家掷一个骰子，然后掷两个骰子，然后掷三个骰子，依此类推，直到玩家的回合结束。
- en: Update the current player’s number of chips based on what happened on this turn.
    We could add an additional return value to communicate this updated information
    to whoever called this function.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据本轮发生的情况更新当前玩家的筹码数量。我们可以添加一个额外的返回值来将此更新信息传达给调用此函数的人。
- en: Determine whether the game is over. We could add an additional return value
    where `True` means that the game is over and `False` means that it isn’t.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断游戏是否结束。我们可以在返回值中添加一个额外的值，其中`True`表示游戏结束，`False`表示游戏未结束。
- en: We initially tried to have the function do all three of these things but were
    unable to receive satisfactory code from Copilot. This isn’t too surprising because
    we’re asking the function to do too much. This led us to focus on the core of
    this function, which is point 1.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初尝试让函数完成这三件事，但无法从Copilot那里获得令人满意的代码。这并不令人惊讶，因为我们要求函数做太多。这导致我们专注于这个函数的核心，即第1点。
- en: But OK, if we focus only on point 1, then how are we going to update the current
    player’s number of chips (point 2), and how will we know whether the game is over
    (point 3)? For point 2, the solution we thought of is to not update the current
    player’s chip count at all in this function, instead returning the total number
    of chips in the pot after this turn.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 但好吧，如果我们只关注第1点，那么我们如何更新当前玩家的筹码数量（第2点），以及我们如何知道游戏是否结束（第3点）？对于第2点，我们想到的解决方案是在这个函数中根本不更新当前玩家的筹码计数，而是返回本轮后筹码堆中的总筹码数量。
- en: For example, if there were 10 chips in the pot and this player’s turn generated
    6 chips, then we’d return 16\. The player may or may not get to collect these
    16 chips—it depends on how their turn ended—but we won’t deal with that here (this
    is for the calling function to manage now).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果筹码堆中有10个筹码，而这个玩家的回合产生了6个筹码，那么我们将返回16。玩家可能或可能无法收集这16个筹码——这取决于他们的回合如何结束——但我们现在不会处理这个问题（这是由调用函数来管理的）。
- en: For point 3 (knowing whether the game is over), our solution is to have the
    function return the most recent list of rolls as part of its return value. (This
    list of rolls will also be needed by the calling function for point 2.) The function
    that calls this one can then use those rolls to determine whether the game is
    over.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第3点（知道游戏是否结束），我们的解决方案是让函数将其返回值的一部分作为最近的骰子点数列表。这个点数列表（对于第2点）也将由调用函数所需。调用这个函数的函数可以使用这些点数来确定游戏是否结束。
- en: 'In summary, our function will take the number of chips in the pot as a parameter
    and will return a list of two values: the new number of chips in the pot after
    the player’s turn and the most recent list of rolls.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们的函数将筹码堆中的筹码数量作为参数，并返回两个值：玩家回合后筹码堆中新的筹码数量和最近的骰子点数列表。
- en: 'To take a full turn, we’ll need to be able to roll dice: first one die, then
    two dice, then three dice, and so on. We’ll split this out into a function named
    `roll_dice`. It will take the number of dice to roll as a parameter and will return
    a list of rolls. For example, if we ask the function to roll three dice, we might
    get back `[6,` `1,` `4]`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成一个完整的回合，我们需要能够掷骰子：首先掷一个骰子，然后掷两个骰子，然后掷三个骰子，依此类推。我们将这部分拆分成一个名为`roll_dice`的函数。它将接受要掷的骰子数量作为参数，并返回一个点数列表。例如，如果我们要求该函数掷三个骰子，我们可能会得到回执`[6,
    1, 4]`。
- en: We’ll also need to be able to determine whether the turn is over based on the
    most recent list of rolls. If the player rolled any 1s or rolled five dice none
    of which is a 1, then the turn is over. We’ll split that out too into a function
    named `turn_over`. It will take the list of rolls as a parameter and will return
    `True` if the turn is over and `False` if not.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要能够根据最近的点数列表确定回合是否结束。如果玩家掷出了任何1，或者掷出了五个骰子且没有一个是1，那么回合就结束了。我们将这部分也拆分出来，命名为`turn_over`。它将接受点数列表作为参数，如果回合结束则返回`True`，如果没有结束则返回`False`。
- en: If the turn isn’t over, then we’ll need to ask the player whether they want
    to continue their turn. We’ll ask for a yes (y) or no (n) response. We can do
    that using a call to the `input` function. If the player wants to keep going,
    we can again call `roll_dice`. We don’t need a separate function for asking for
    user input, so we won’t break this part down any further. If we wanted to validate
    the user’s input (rejecting any response that’s not y or n), that would increase
    the complexity enough so that we’d probably split it out.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回合还没有结束，我们需要询问玩家他们是否想要继续他们的回合。我们将要求他们给出是（y）或否（n）的回应。我们可以通过调用`input`函数来实现。如果玩家想要继续，我们可以再次调用`roll_dice`。我们不需要一个单独的函数来请求用户输入，所以我们将不会进一步分解这部分。如果我们想要验证用户的输入（拒绝任何不是y或n的回应），这将增加足够的复杂性，以至于我们可能会将其拆分出来。
- en: 'In summary, we’ve split out two subtasks for our `take_full_turn` function:
    `roll_ dice` and `turn_over`. These functions don’t need to be broken down any
    further. For `roll_dice`, we can use `random.randint` in a loop to generate the
    rolls that we need. And, `turn_over` will amount to a couple of checks on the
    dice rolls to determine whether they ended the turn for which we won’t need any
    further breaking down.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们已经将`take_full_turn`函数拆分成了两个子任务：`roll_dice`和`turn_over`。这些函数不需要进一步拆分。对于`roll_dice`，我们可以使用`random.randint`循环生成所需的点数。而`turn_over`将涉及对骰子点数的几个检查，以确定它们是否结束了我们不需要进一步拆分的回合。
- en: Task 3c. If the current player won chips
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务3c. 如果当前玩家赢得了筹码
- en: When a player’s turn ends, we’re furnished with the new number of chips in the
    pot and the final list of rolls that ended the turn. We need to determine whether
    the player gets those chips or not. (If the final list of rolls doesn’t contain
    a 1, then the player collects the chips; otherwise, they don’t, and the chips
    stay in the pot.)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家的回合结束时，我们会得到新筹码数量和结束回合的最终骰子点数列表。我们需要确定玩家是否获得了这些筹码。（如果最终的点数列表中不包含1，则玩家收集筹码；否则，他们不收集，筹码留在筹码堆中。）
- en: We’ll split out a function to tell us whether the player collects the chips
    or not. We’ll name it `wins_chips`. This function will take the most recent list
    of rolls as a parameter and will return `True` if the player wins the chips and
    `False` otherwise.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将拆分出一个函数来告诉我们玩家是否收集了筹码。我们将将其命名为`wins_chips`。这个函数将接受最近的点数列表作为参数，如果玩家赢得了筹码则返回`True`，否则返回`False`。
- en: Task 3d. Switch to the other player’s turn
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务3d. 切换到另一玩家的回合
- en: 'We’ll name this function `switch_player`. Suppose that the current player has
    just finished their turn. We need to switch to the other player’s turn, but only
    if the game isn’t over yet. Our function will encapsulate this logic. It will
    need to call `game_over` to determine whether the game is over, so we need at
    least three parameters for `switch_player`: player 1’s chips, player 2’s chips,
    and the most recent list of dice rolls. We’ll also need a parameter to indicate
    the current player (1 or 2), so that we can return the number of the new current
    player. So, the function will take those four parameters, and it will return a
    1 or a 2 indicating the player that we’re switching to next.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个函数命名为`switch_player`。假设当前玩家刚刚完成他们的回合。我们需要切换到另一个玩家的回合，但前提是游戏还没有结束。我们的函数将封装这个逻辑。它需要调用`game_over`来确定游戏是否结束，因此我们需要至少三个参数给`switch_player`：玩家1的筹码，玩家2的筹码，以及最近的骰子滚动列表。我们还需要一个参数来指示当前玩家（1或2），这样我们就可以返回下一个新当前玩家的编号。因此，该函数将接受这四个参数，并返回一个1或2，表示我们将切换到的下一个玩家。
- en: If the game is over, this function won’t do anything. And if the game isn’t
    over, then we’ll need to change a 1 to a 2 or a 2 to a 1\. We already have the
    `game_over` function, and that’s sufficient for breaking down this function.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏结束，这个函数不会做任何事情。如果游戏没有结束，那么我们需要将1改为2或将2改为1。我们已经有`game_over`函数，这足以分解这个函数。
- en: We’ve finished our top-down design! Check out figure 10.6 for our tree of functions.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了自顶向下的设计！查看图10.6以了解我们的函数树。
- en: '![figure](../Images/10-6.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/10-6.png)'
- en: Figure 10.6 Top-down design for the Bogart game
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.6 博加特游戏的顶向下设计
- en: 10.4.3 Implementing our functions
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3 实现我们的函数
- en: Now it’s time to work with Copilot to write the code for each of our functions.
    As always, we’ll start with leaf functions and move our way up (left in the diagram),
    implementing our top-level `play` function only when all other functions have
    been implemented. We can start with any leaf function. We’ll start with the `game_over`
    function because it’s needed both by `play` and by `switch_player`. Then, we’ll
    move on to other functions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候与Copilot一起编写我们每个函数的代码了。一如既往，我们将从叶函数开始，逐步向上（在图中向左），只有在所有其他函数都已实现后，才实现顶级`play`函数。我们可以从任何叶函数开始。我们将从`game_over`函数开始，因为它既需要`play`，也需要`switch_player`。然后，我们将继续处理其他函数。
- en: game_over
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: game_over
- en: 'This function takes three parameters: the number of chips that Player 1 has,
    the number of chips that Player 2 has, and the most recent list of rolls. It returns
    `True` if the game is over, and `False` if not, as shown in the following listing.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受三个参数：玩家1拥有的筹码数量，玩家2拥有的筹码数量，以及最近的骰子滚动列表。如果游戏结束，则返回`True`，如果没有结束，则返回`False`，如下所示。
- en: Listing 10.6 `game_over` function in Bogart
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.6 博加特游戏的`game_over`函数
- en: '[PRE17]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#1 The three ways that the game is over'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 游戏结束的三种方式'
- en: 'Remember that there are three ways for the game to be over: Player 1 has at
    least 30 chips, Player 2 has at least 30 chips, or a player managed to roll five
    dice on their last turn without rolling a 1.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，游戏有三种结束方式：玩家1至少有30个筹码，玩家2至少有30个筹码，或者某个玩家在最后一轮中成功掷出五个骰子而没有掷出1。
- en: Returning a Boolean directly
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 直接返回布尔值
- en: 'You may have expected to see the code this way, with the use of `if-else` and
    actual `return` `True` and `return` `False` lines:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望看到代码是这样的，使用`if-else`和实际的`return True`和`return False`行：
- en: '[PRE18]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This would work, but it’s more common to see programmers use a `return` statement
    directly with the `True`/`False` expression. It works because the result of the
    expression is what is being returned. If the expression is true, `True` gets returned,
    and if the expression is false, `False` gets returned. That’s exactly the same
    thing that the `if-else` version does!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这会工作，但更常见的是程序员直接使用`return`语句与`True`/`False`表达式。这是因为表达式的结果是返回的内容。如果表达式为真，则返回`True`，如果表达式为假，则返回`False`。这与`if-else`版本做的是完全相同的事情！
- en: roll_dice
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: roll_dice
- en: This is the function that rolls our dice and adds randomness to our game. It
    takes the number of dice to roll as a parameter, and it returns the list of dice
    rolls. We’ll expect Copilot to make use of `random.randint` here, as shown in
    listing 10.7.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是掷骰子并给我们的游戏增加随机性的函数。它接受要掷的骰子数量作为参数，并返回骰子滚动列表。我们期望Copilot在这里使用`random.randint`，如列表10.7所示。
- en: In addition to returning the list of rolls, it’s also helpful if this function
    prints each dice roll. That way, the player can see exactly what they rolled.
    In the docstring, we ask Copilot to print the rolls (in addition to returning
    the list of rolls).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 除了返回滚动列表外，如果此函数还能打印出每次掷骰子的结果，那就更有帮助了。这样，玩家就可以看到他们确切掷出了什么。在文档字符串中，我们要求 Copilot
    打印滚动结果（除了返回滚动列表之外）。
- en: Listing 10.7 `roll_dice` function in Bogart
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.7 Bogart 中的 `roll_dice` 函数
- en: '[PRE19]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#1 List of dice rolls (integers between 1 and 6), starts empty'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 骰子滚动列表（介于 1 和 6 之间的整数），开始为空'
- en: '#2 Loops n times, once per roll'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 循环 n 次，每次掷一次骰子'
- en: '#3 Uses “randint” to generate a random integer between 1 and 6'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 使用“randint”生成介于 1 和 6 之间的随机整数'
- en: '#4 Prints roll for players to see'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 打印滚动结果供玩家查看'
- en: '#5 Adds roll to list of rolls'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 将滚动结果添加到滚动列表中'
- en: '#6 Returns list of rolls'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 返回滚动列表'
- en: turn_over
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: turn_over
- en: This function takes the most recent list of rolls and uses that to determine
    whether the current player’s turn is over or not. It returns `True` if the turn
    is over, and `False` if not, as shown in the following listing.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受最近的滚动列表，并使用该列表确定当前玩家的回合是否结束。如果回合结束，则返回 `True`，如果没有结束，则返回 `False`，如以下列表所示。
- en: Listing 10.8 `turn_over` function in Bogart
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.8 Bogart 中的 `turn_over` 函数
- en: '[PRE20]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#1 The two ways for the turn to be over'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 回合结束的两种方式'
- en: There are two ways for the player’s turn to be over. The first is when there’s
    a 1 in the list of rolls. The second is when the player has rolled five dice.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的回合结束有两种方式。第一种是当滚动列表中出现 1 时。第二种是当玩家掷了五颗骰子。
- en: Is `len(rolls)` `==` `5` really enough for the turn to be over? Don’t we have
    to check whether there were any 1s rolled? No, if the player rolls five dice,
    then their turn is over no matter what, regardless of what the dice rolls were.
    If they rolled any 1s, then the turn is over because they rolled a 1 (and they
    won’t collect any chips). If they didn’t roll any 1s, then the turn is still over
    (and they’ll win the game automatically in this case).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`len(rolls)` `==` `5` 真的足够使回合结束吗？我们不是还要检查是否掷出了任何 1 吗？不，如果玩家掷了五颗骰子，那么无论骰子结果如何，他们的回合就结束了。如果他们掷出了任何
    1，那么回合就结束了（因为他们掷出了 1，并且不会收集任何筹码）。如果他们没有掷出任何 1，那么回合仍然结束（在这种情况下，他们将自动赢得游戏）。'
- en: take_full_turn
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: take_full_turn
- en: 'We’re ready for `take_full_turn` now, as shown in listing 10.9\. This function
    takes the number of chips currently in the pot as a parameter. It will process
    all the rolls from a full turn for the current player and then returns a list
    of two values: the new number of chips in the pot and the final list of rolls.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好 `take_full_turn`，如列表 10.9 所示。此函数接受当前赌注中筹码的数量作为参数。它将处理当前玩家的完整回合的所有滚动，然后返回两个值：赌注中新的筹码数量和最终的滚动列表。
- en: Listing 10.9 `take_full_turn` function in Bogart
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.9 Bogart 中的 `take_full_turn` 函数
- en: '[PRE21]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '#1 Rolls one dice'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 掷一颗骰子'
- en: '#2 Adds one chip to the pot'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 向赌注中添加一枚筹码'
- en: '#3 While the current player’s turn isn’t over . . .'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 当当前玩家的回合没有结束时 ...'
- en: '#4 . . . asks the player if they want to continue their turn.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 ... 询问玩家是否想继续他们的回合。'
- en: '#5 If they do want to continue their turn . . .'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 如果他们想继续他们的回合 ...'
- en: '#6 . . . rolls one more dice than last time.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 ... 比上一次多掷一颗骰子。'
- en: '#7 Adds new chips to the pot'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 向赌注中添加新的筹码'
- en: '#8 Gets out of the while loop'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 退出 while 循环'
- en: '#9 Returns both number of chips in the pot and the final list of rolls'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '#9 返回赌注中的筹码数量和最终的滚动列表'
- en: wins_chips
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: wins_chips
- en: This function takes a list of rolls as a parameter. If the rolls are good (i.e.,
    contain no 1s), then the player will collect the chips. If the rolls contain any
    1s, then the player won’t collect the chips. This function returns `True` if the
    player gets to collect the chips, and `False` otherwise, as shown in the following
    listing.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个滚动列表作为参数。如果滚动结果良好（即不包含 1），则玩家将收集筹码。如果滚动结果包含任何 1，则玩家不会收集筹码。此函数在以下列表中返回
    `True` 如果玩家可以收集筹码，否则返回 `False`。
- en: Listing 10.10 `wins_chips` function in Bogart
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.10 Bogart 中的 `wins_chips` 函数
- en: '[PRE22]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 Returns True when there are no 1s, and returns False otherwise'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 当没有 1 时返回 True，否则返回 False'
- en: switch_player
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: switch_player
- en: 'This function takes four parameters: the number of chips that Player 1 has,
    the number of chips that Player 2 has, the most recent list of rolls (rolled by
    the current player), and the number of the current player. If the game isn’t over,
    this function returns the number of the other player. If the game is over, then
    the function returns the current player (because there’s no turn for the other
    player!). See the following listing.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受四个参数：玩家1拥有的筹码数量、玩家2拥有的筹码数量、当前玩家最近掷出的骰子列表（由当前玩家掷出）以及当前玩家的编号。如果游戏尚未结束，则该函数返回另一个玩家的编号。如果游戏结束，则该函数返回当前玩家（因为另一个玩家没有回合！）。请参见以下列表。
- en: Listing 10.11 `switch_player` function in Bogart
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.11 Bogart中的`switch_player`函数
- en: '[PRE23]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 If game isn’t over . . .'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 如果游戏尚未结束...'
- en: '#2 . . . switches from 1 to 2 or from 2 to 1.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 ...从1切换到2或从2切换到1。'
- en: '#3 Returns new current player'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 返回新的当前玩家'
- en: play
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: play
- en: We’ve made it all the way up to our `play` function! We’ve decided to write
    this function without any parameters. You might wonder if we could make the code
    more flexible by adding, say, a parameter for the number of chips required to
    win (currently 30). You could certainly do that; we haven’t done that here to
    keep the number of parameters smaller throughout the code. This function doesn’t
    return anything. Instead, it plays the game, as shown in the following listing.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了`play`函数！我们决定不添加任何参数来编写这个函数。你可能想知道我们是否可以通过添加一个参数来使代码更灵活，比如为赢得所需的筹码数量（目前为30）添加一个参数。你当然可以这样做；我们在这里没有这样做是为了保持代码中参数数量的较小。这个函数不返回任何内容。相反，它玩游戏，如下面的列表所示。
- en: Listing 10.12 `play` function in Bogart
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.12 Bogart中的`play`函数
- en: '[PRE24]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 Starts pot and players with 0 chips'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 开始筹码池和玩家，初始筹码为0'
- en: '#2 Randomly makes Player 1 or Player 2 start the game'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 随机让玩家1或玩家2开始游戏'
- en: '#3 While the game isn’t over . . .'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 当游戏尚未结束时...'
- en: '#4 . . . prints the current state of the game.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 ...打印当前游戏状态。'
- en: '#5 Lets the current player have their turn'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 让当前玩家进行回合'
- en: '#6 If current player wins chips . . .'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 如果当前玩家赢得筹码...'
- en: '#7 . . . and it’s Player 1 . . .'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 ...然后轮到玩家1...'
- en: '#8 . . . gives Player 1 the chips from the pot; . . .'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 ...将筹码池中的筹码给玩家1；...'
- en: '#9 . . . otherwise, gives Player 2 the chips from the pot.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '#9 ...否则，将筹码池中的筹码给玩家2。'
- en: '#10 Resets pot to now have 0 chips'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '#10 将筹码池重置为0筹码'
- en: '#11 Switches to the other player’s turn'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '#11 切换到另一个玩家的回合'
- en: '#12 Prints out who wins'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '#12 打印出获胜者'
- en: We now have all the code that we need for the game. Just add
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了游戏所需的所有代码。只需添加
- en: '[PRE25]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: below all of your existing code to call our `play` function, and then you’ll
    be able to play!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在你现有的所有代码下方添加调用我们的`play`函数，然后你就可以玩游戏了！
- en: Customizing the game
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义游戏
- en: 'We’re happy with what Copilot has given us, and the game is certainly playable.
    But, admittedly, the interaction with the players could be a little more user-friendly.
    For example, here’s how the game might start when we run it and press y a few
    times:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Copilot给出的结果很满意，游戏当然可以玩。但是，诚实地讲，与玩家的互动可以更友好一些。例如，当我们运行游戏并多次按下y时，游戏可能会这样开始：
- en: 'Pot chips: 0'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 筹码池筹码：0
- en: 'Player 1 chips: 0'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家1筹码：0
- en: 'Player 2 chips: 0'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家2筹码：0
- en: Player 2 turn
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家2回合
- en: '4'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: Continue? (y/n) y
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Continue? (y/n) y
- en: '5'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '2'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: Continue? (y/n) y
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Continue? (y/n) y
- en: '3'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '1'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '4'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'Pot chips: 6'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 筹码池筹码：6
- en: 'Player 1 chips: 0'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家1筹码：0
- en: 'Player 2 chips: 0'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家2筹码：0
- en: Player 1 turn
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家1回合
- en: '2'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: Continue? (y/n)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 继续吗？(y/n)
- en: There’s no welcome message. Numbers like 4, 5, 2, and so on are just there,
    with no context of what they mean. The game asks us whether we want to “Continue?
    (y/n).” Continue what, though? It isn’t clear.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 没有欢迎信息。像4、5、2这样的数字只是在那里，没有任何上下文说明它们的意义。游戏会询问我们是否想要“继续？(y/n)”。继续什么？这并不清楚。
- en: We can make the interaction with the players more pleasant by spicing up the
    `print` calls in our functions. We can just put what we want in each `print` statement
    ourselves. Why not just use Copilot? It’s likely easier to just do it rather than
    trying to cajole Copilot to print exactly what we want. For example, the following
    listing shows a new version of `play` where we’ve added more `print` calls to
    explain what’s going on and to better format the game output.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在我们的函数中增加`print`调用来使与玩家的互动更加愉快。我们只需自己将想要的内容放入每个`print`语句中即可。为什么不直接使用Copilot呢？这样做可能比试图说服Copilot打印出我们想要的确切内容要容易得多。例如，下面的列表显示了`play`的新版本，我们在其中添加了更多的`print`调用，以解释正在发生的事情，并更好地格式化游戏输出。
- en: Listing 10.13 `play` function in Bogart with better formatting
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.13 Bogart中格式更好的`play`函数
- en: '[PRE26]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#1 Prints welcome message'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 打印欢迎信息'
- en: '#2 Prints a blank line'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 打印一个空行'
- en: '#3 Prints message saying that the current player got chips'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 打印消息说明当前玩家获得了筹码'
- en: '#4 Separates each turn from the next'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 将每个回合与下一个回合分开'
- en: 'We encourage you to add `print` calls elsewhere as well to make the game interaction
    even better! For example, in `roll_dice`, you could add a `print` call to tell
    the players that dice are about to be rolled (**ROLLS** in the following output).
    In `take_full_ turn`, you could add a `print` call to print the number of chips
    in the pot prior to asking the player whether they’d like to continue their turn.
    Here’s what an interaction with our game looks like after we made those changes:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你在其他地方也添加`print`调用，以使游戏交互更加出色！例如，在`roll_dice`中，你可以添加一个`print`调用来告诉玩家骰子即将被掷出（以下输出中的**ROLLS**）。在`take_full_turn`中，你可以添加一个`print`调用来在询问玩家是否想继续他们的回合之前打印出筹码池中的筹码数量。以下是我们在做出这些更改后与我们的游戏交互的示例：
- en: Welcome to Bogart!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到Bogart！
- en: 'Pot chips: 0'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 筹码池筹码：0
- en: 'Player 1 chips: 0'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家1筹码：0
- en: 'Player 2 chips: 0'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家2筹码：0
- en: Player 2 turn
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家2回合
- en: '**ROLLS**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROLLS**'
- en: '2'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: The pot currently has 1 chips.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 筹码池目前有1个筹码。
- en: Continue turn? (y/n) y
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 继续回合？(y/n) y
- en: '**ROLLS**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROLLS**'
- en: '6'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '3'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: The pot currently has 3 chips.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 筹码池目前有3个筹码。
- en: Continue turn? (y/n) y
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 继续回合？(y/n) y
- en: '**ROLLS**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROLLS**'
- en: '1'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '6'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
- en: 'Pot chips: 6'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 筹码池筹码：6
- en: 'Player 1 chips: 0'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家1筹码：0
- en: 'Player 2 chips: 0'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家2筹码：0
- en: Player 1 turn
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家1回合
- en: '**ROLLS**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROLLS**'
- en: '5'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: The pot currently has 7 chips.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 筹码池目前有7个筹码。
- en: Continue turn? (y/n)
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 继续回合？(y/n)
- en: Try making such changes to your code as well. Make the game yours!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 也尝试对你的代码做出这样的修改。让你的游戏变得独一无二！
- en: 'In this chapter, we used Copilot to help us write two computer games: a logic
    game (similar to Wordle, but with numbers), and a two-player dice game. We were
    able to do this using the skills we’ve honed throughout the book, including problem
    decomposition, writing clear docstrings, and interacting with Copilot Chat.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Copilot帮助我们编写了两个电脑游戏：一个逻辑游戏（类似于Wordle，但使用数字），和一个两人掷骰子游戏。我们能够做到这一点，得益于我们在整本书中学到的技能，包括问题分解、编写清晰的docstrings以及与Copilot
    Chat交互。
- en: 10.5 Exercises
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 练习
- en: 'There is an error in the following `guess_result` function that leads to incorrect
    counts of correct and misplaced digits. Identify and fix the error:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下`guess_result`函数中存在一个错误，导致正确和错误放置的数字计数不正确。找出并修复错误：
- en: '[PRE27]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '2\. Modify the `get_guess` function from this chapter to include error messages
    that guide the player to enter a valid guess. Ensure that these messages are clear
    and helpful. Be creative! Here are some examples:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 将本章中的`get_guess`函数修改为包含错误信息，引导玩家输入有效的猜测。确保这些信息清晰且有帮助。发挥创意！以下是一些示例：
- en: '“Error: Guess must contain only digits.”'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: “错误：猜测必须只包含数字。”
- en: '“Error: Guess must not contain repeated digits.”'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: “错误：猜测不得包含重复的数字。”
- en: 3\. Why did we choose to pass the number of digits and the number of guesses
    as parameters to the `play` function for the Bulls and Cows game? How does this
    decision enhance the flexibility of the game?
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 为什么我们选择将数字的位数和猜测的次数作为参数传递给Bulls and Cows游戏的`play`函数？这个决定如何提高游戏的灵活性？
- en: 4\. Implement a simple dice game where the player rolls two dice. If the total
    is 7 or 11, the player wins. If the total is 2, 3, or 12, the player loses. For
    any other total, the player continues to roll until they either match their initial
    roll (win) or roll a 7 (lose). Think carefully about how you want to divide the
    main problem here into smaller subproblems!
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 实现一个简单的掷骰子游戏，玩家掷两个骰子。如果总和是7或11，玩家获胜。如果总和是2、3或12，玩家失败。对于任何其他总和，玩家继续掷骰子，直到他们要么匹配他们的初始掷骰结果（获胜）要么掷出7（失败）。仔细思考你如何想将主要问题分解成更小的子问题！
- en: 5\. Implement a version of the Bogart game where one player is human and the
    other is the computer. To do this, you’ll need to come up with some rules that
    the computer can use to end their turn. For example, the computer will certainly
    want to stop rolling dice when the number of chips that they’ve already accumulated
    on their turn is enough for them to win the game! The computer will also likely
    want to stop rolling once it can earn a large number of chips on its current turn.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5. 实现一个Bogart游戏的版本，其中一个玩家是人类，另一个是电脑。为此，你需要想出一些电脑可以用来结束他们回合的规则。例如，电脑当然希望在他们的回合中积累足够的筹码以赢得游戏时停止掷骰子！电脑也可能希望在当前回合中能够赚取大量筹码时停止掷骰子。
- en: '6\. *The Price Is Right* game show is a great source of little games that may
    be fun to implement. For example, you can try implementing the game called Any
    Number:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6. *《价格猜猜看》* 游戏节目是许多有趣游戏的绝佳来源。例如，你可以尝试实现名为 Any Number 的游戏：
- en: '[https://priceisright.fandom.com/wiki/Any_Number](https://priceisright.fandom.com/wiki/Any_Number)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://priceisright.fandom.com/wiki/Any_Number](https://priceisright.fandom.com/wiki/Any_Number)'
- en: In your game, the player should continue to choose numbers until all the digits
    of one of the prizes are revealed; that’s the prize that the player wins.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的游戏中，玩家应该继续选择数字，直到揭示出其中一个奖项的所有数字；那就是玩家赢得的奖项。
- en: '7\. Create a simple game using the Pygame library. In this game, the player
    controls a character that moves left and right to collect falling objects. The
    objective is to collect as many objects as possible without missing them. You
    can be flexible here with how the objects in your game look, so have fun with
    it! As a potential extension: Can you think of how you would keep track of the
    player’s high score?'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7. 使用 Pygame 库创建一个简单的游戏。在这个游戏中，玩家控制一个角色左右移动以收集下落的物体。目标是尽可能多地收集物体而不要错过任何一个。你可以在这里对游戏中物体的外观灵活处理，尽情享受乐趣！作为一个潜在的扩展：你能想到如何跟踪玩家的最高分吗？
- en: Summary
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Games have a common program flow that includes game setup and gameplay.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏有一个常见的程序流程，包括游戏设置和游戏玩法。
- en: Randomness is an important ingredient of many games.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机性是许多游戏的重要成分。
- en: We can add randomness to our Python games by using functions in the random module.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用 random 模块中的函数来为我们的 Python 游戏添加随机性。
- en: We can implement games with Copilot using the same workflow that we’ve used
    throughout the book, with problem decomposition playing a key role.*****
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用与本书中相同的流程实现游戏，其中问题分解起着关键作用。*****
