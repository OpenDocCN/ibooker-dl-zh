- en: 10 Making some games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding randomness to our programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing and programming a code-breaking logic game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing and programming a press-your-luck dice game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: People learn to program for many reasons. Some people want to automate tedious
    tasks as we did in the previous chapter. Some people want to work with artificial
    intelligence (AI; you’ll get a taste of that in chapter 11). Other people want
    to make interactive websites, Android or iOS apps, or Alexa skills. There’s an
    endless amount of stuff that programmers can make.
  prefs: []
  type: TYPE_NORMAL
- en: Another popular reason to learn programming is to create games. For that reason,
    we thought we’d continue our Copilot programming journey with you by designing
    two small computer games. The first is a code-breaking game where you use clues
    to identify the computer’s secret code. The second is a two-player dice game where
    each player needs to balance risk and luck to reach the required number of points
    before the other player does. Instead of using graphics and animation, these games
    use text. We’ve made this decision to help us stay focused on the game logic,
    rather than the way that the game is represented or the way that the player interacts
    with the games. Along the way, we offer some next steps if you’re interested in
    taking your game-making abilities further. And don’t worry, your current skills
    are a great start to that!
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 Game programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you think about playing a board game with your family or friends, you can
    break down what happens in two major phases. The first phase is game setup. This
    will include setting up the game board, giving each player starting funds or cards,
    and so on. The second phase is the playing of the game. In a board game, the game
    typically includes a person taking a turn and, assuming no one has won yet, another
    person taking a turn. With each turn, the game state (board, players’ funds, etc.)
    all change. We need to take care to implement each of these phases when programming
    a computer game as well.
  prefs: []
  type: TYPE_NORMAL
- en: In many programming environments catered to video game design, the two phases
    are often separate standard functions. There’s a setup function for what is done
    to set up the game and an update function to change the state of the game either
    because a player has taken an action or because time has passed. Figure 10.1 shows
    the basic flow for video games.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 Basic flow of most video games
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s focus on the update part of the game for a moment. Suppose a player can
    press a button on their keyboard to move forward in a 2D game. The update function
    will cause the player’s character to move forward and also check to see if the
    player’s movement caused the player to interact with something in the game world.
    Some games also change state based on time, regardless of a player’s actions.
    In those games, the update function would also update the state of the game itself
    (e.g., move the ghosts in a game of Pac-Man). At the end of every time step or
    user action, the game will check for end conditions. End conditions typically
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A player won the game by achieving an objective.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A player lost the game by falling off a cliff, running into a monster, and so
    on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A player chose to quit the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many programming environments that cater to game design, and we recommend
    the Python pygame module [1] as a good starting place. If you continue pursuing
    game design beyond that, we recommend checking out Unity [2] for 3D game design.
    In this chapter though, we’ll be working with just standard Python to show you
    how to design a basic game without having to dive into these new environments.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 Adding randomness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many games, including the two that we’ll build in this chapter, rely on randomness
    to make them fun. In our first game, we’ll need the computer to generate the random
    digits of the number that we’ll be deducing. In the second game, we’ll need to
    roll dice, which just amounts to generating random numbers between one and six.
    Enemy behavior, initial orientation of a puzzle, or amount of damage caused by
    attacks, that is, randomness, is typically involved in all of these and many other
    aspects of game design.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll therefore need to be able to generate random numbers in our Python programs.
    To learn how to do that, let’s use Copilot Chat, much as we did in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanI need to generate random numbers in my **Python program. How can I do
    this?**
  prefs: []
  type: TYPE_NORMAL
- en: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the random module
    in Python to generate random numbers. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]`*[PRE1]`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import random*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Generate a random integer between 1 and 10 (inclusive)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*random_number = random.randint(1, 10)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*print(random_number)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Generate a random float between 0 and 1*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*random_float = random.random()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*print(random_float)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE2]*[PRE3]'
  prefs: []
  type: TYPE_NORMAL
- en: This code imports the random module and then uses the `randint` function to
    generate a random integer between 1 and 10 (inclusive), and the `random` function
    to generate a random float between 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot suggests using functions inside of a module called random to generate
    the random numbers. Let’s check whether the random module is built into Python.
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanIs this random module built into Python?
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, the random module is a
    built-in module in Python, so you don’t need to install any additional modules
    to use it. You can simply import it in your Python code and start using its functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll follow Copilot’s suggestion and import this module to test the two functions
    that we just learned. We’ll do this at the Python >>> prompt, which we’ve used
    in previous chapters to explore how Python features work. To get to the Python
    prompt, press Ctrl-Shift-P, type `REPL`, and then select Python: Start REPL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on Copilot’s response to our first question, we know that we can use
    the `randint` function to generate a random integer in a range from the lowest
    allowed number to the highest allowed number. We might use this function to generate
    individual digits that could be assembled into a larger number. Each digit is
    between 0 and 9, so we’ll ask `randint` for some random numbers between 0 and
    9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We happened to get the maximum value.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 We happened to get the minimum value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, we might want to generate rolls of a die. Each roll is between 1 and 6,
    so we can ask `randint` for some random numbers between 1 and 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The other function that Copilot told us about is called `random`. (Yes, both
    the module and this function are called `random`! So, we’ll need to use `random.random()`
    to call this function.) This one doesn’t generate a random integer; rather, it
    generates a random fractional number between 0 and 1 (not including 1). For example,
    rather than a random number like 5, you’ll get a random number like 0.1926502\.
    These kinds of numbers, with decimals, are referred to as floats (or floating-point
    numbers). Here are a few calls of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can imagine this function being useful for games as well. For example, you
    can think of these float values as probabilities that an event occurs, with higher
    numbers corresponding to higher probabilities. You could then use these floats
    to determine whether an event should happen or not. For the games in this chapter,
    though, we won’t need this function.
  prefs: []
  type: TYPE_NORMAL
- en: '10.3 Example 1: Bulls and Cows'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Our first game will be based on an old code-breaking game called Bulls and
    Cows. It might remind you of the game Wordle (but don’t worry if you haven’t played
    Wordle before). We’ll be able to play this game against the computer. Randomness
    plays a critical role in this game, as we’ll see.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*### 10.3.1 How the game works'
  prefs: []
  type: TYPE_NORMAL
- en: In this game, Player 1 thinks up a secret code, which is a sequence of four
    digits. Player 2 has to figure out what that secret code is. In our version of
    the game, the computer will be Player 1, and the human player will be Player 2.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how it works. The computer will randomly choose four distinct digits
    (duplicate digits aren’t allowed) as the secret code. For example, it might choose
    the digits 1862\. Then, you’ll guess what you think the computer’s four digits
    are. For example, you might guess 3821.
  prefs: []
  type: TYPE_NORMAL
- en: For each guess, you’re told two things. First, you’re told how many digits in
    your guess match the corresponding position in the secret code exactly. We’ll
    refer to digits that are in the correct place in the secret code as “correct.”
    Say that the secret code is 1862, and you guess 3821\. The second digit in both
    your guess and the secret code is 8, so that’s a match. There are no other matches,
    so you would be told for this guess that the number of correct digits is 1.
  prefs: []
  type: TYPE_NORMAL
- en: Second, you’re told how many digits in your guess exist at some other position
    in the secret code. We’ll refer to digits that are in the secret code but in a
    different location as “misplaced.” Let’s again use 1862 for the secret code and
    3821 for your guess. The third digit in your guess is 2\. It doesn’t match the
    third digit of the secret code (that’s a 6), but there is a 2 somewhere else in
    the secret code. Similarly, the fourth digit in your guess is a 1\. It doesn’t
    match the fourth digit of the secret code, but there is a 1 somewhere else in
    the secret code. All told, two of your digits (1 and 2) exist in the secret code,
    although they don’t match their expected position. You would be told from this
    guess that the number of misplaced digits is 2\. You can use these clues to narrow
    down what the secret code could be.
  prefs: []
  type: TYPE_NORMAL
- en: Wordle
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’ve played Wordle before, you might notice some similarities between Wordle
    and our game here. Wordle uses letters, and ours uses digits, but the type of
    feedback you receive for your guesses is similar. In both cases, you’re told about
    letters or digits that are in the right or wrong place. In Wordle, you’re given
    a clue about each of your letters on its own. For example, if the first letter
    of your guess is *h*, you might be told that the *h* is in the word but in the
    wrong place. By contrast, in our game, you’re not given hints about each digit
    individually but instead are given hints about your guess in aggregate. Still,
    we hope you’re struck by these similarities and by the fact that you’re building
    something that resembles a recent, worldwide phenomenon of a game!
  prefs: []
  type: TYPE_NORMAL
- en: We found a free version of Bulls and Cows that you can play at [www.mathsisfun.com/games/bulls-and-cows.xhtml](http://www.mathsisfun.com/games/bulls-and-cows.xhtml).
    We recommend that you play a few rounds of the game before continuing, just so
    the way the game works is crystal clear in your head. (Note that they use the
    terminology *bulls* instead of *correct* and *cows* instead of *misplaced*.)
  prefs: []
  type: TYPE_NORMAL
- en: In table 10.1, we’ve provided an example interaction with the game. We’ve included
    a Comments column to convey our thinking and what we learned from each guess.
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.1 Example of playing the game
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Guess | Misplaced | Correct | Comments |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0123  | 1  | 0  | One of 0, 1, 2, 3 is in the answer; none are in the correct
    location.  |'
  prefs: []
  type: TYPE_TB
- en: '| 4567  | 3  | 0  | Three of 4, 5, 6, 7 are in the answer; none are in the
    correct location.  |'
  prefs: []
  type: TYPE_TB
- en: '| 9045  | 0  | 1  | Because one number from 0123 and three numbers from 4567
    are in the answer, we know 8 and 9 aren’t in the answer. We know at least one
    of the numbers 4 or 5 must be in the answer from prior guesses and that 0 could
    be in the answer. One correct means that either 4 or 5 is in the correct location,
    either 4 or 5 isn’t present in the solution, and 0 isn’t in the solution.  |'
  prefs: []
  type: TYPE_TB
- en: '| 9048  | 0  | 0  | We know 8, 9, and 0 aren’t in the answer from prior guesses.
    Zero correct and zero misplaced tells us 4 is also not in the answer, and from
    the previous guess, we now know that 5 is the last digit.  |'
  prefs: []
  type: TYPE_TB
- en: '| 1290  | 1  | 0  | Going back to the original guess, we want to know which
    digit of 1, 2, and 3 is in the answer. We know 9 and 0 aren’t in the answer, so
    one misplaced means either 1 or 2 is in the answer and 3 isn’t in the answer.
    In addition, whichever of the numbers 1 and 2 are in the answer, it’s currently
    in the wrong spot.  |'
  prefs: []
  type: TYPE_TB
- en: '| 6715  | 2  | 1  | Because 4 isn’t in the solution, we know from the second
    guess that 5, 6, and 7 are. Our guess here tells us that 1 isn’t in the answer
    and that 6 and 7 are in the wrong place. Since 1 isn’t in the answer, 2 must be
    (from the previous guess). Because 5 is at the end and we’ve tried 2 in the second
    and third position previously with zero correct, 2 must be in the first position.
    Because we’ve tried 6 in the first and third position and neither were correct,
    6 must be in the second position. That leaves 7 for the third position. We’ve
    got it.  |'
  prefs: []
  type: TYPE_TB
- en: '| 2675  | 0  | 4  | Yes, this is correct.  |'
  prefs: []
  type: TYPE_TB
- en: The challenge of the game is that you have a limited number of guesses in which
    you must successfully guess the computer’s secret code. In our example from table
    10.1, we took seven guesses to guess the code 2675\. For each guess, we were given
    the number of digits misplaced and the number of digits correct to guide our thinking.
  prefs: []
  type: TYPE_NORMAL
- en: In the free version of the game that we just mentioned, you’re not allowed to
    include the same digit multiple times in your guess. For example, the guess 1231
    wouldn’t be allowed because of the two 1s. We’ll maintain this restriction in
    our version of the game as well.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.2 Top-down design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our overall task is to write a program to play the Bulls and Cows game against
    the computer. Let’s do top-down design on this large task, just as we did in chapters
    7 and 9\. What has to happen during this game? Answering that question will help
    us break down the game into smaller tasks. To help us with this, we took the rules
    of the game and our example and thought through what happens at each step of the
    game. Each of those high-level steps appears in figure 10.2, so let’s break them
    down one by one.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 Steps in the Bulls and Cows game
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll start with the setup. For us to be able to play the game, the computer
    has to randomly generate a secret code. We need to ensure that the secret code
    doesn’t have any duplicate digits. To us, this sounds like something that’s sufficiently
    complicated and self-contained, so it should be its own subtask function.
  prefs: []
  type: TYPE_NORMAL
- en: After the computer generates its secret code, we can move to the gameplay itself.
    Here’s where the player starts making their guesses. We might think that we could
    just use `input` to ask the player for their guesses and thereby avoid having
    a separate function for this. But we do need to ensure that the player enters
    the correct number of digits and that they don’t include duplicate digits in their
    guess. This is more than we can do with a single call of `input`, so we’ll make
    this its own function as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the player makes their valid guess, we need to figure out two things:
    How many digits are correct, and how many digits are misplaced? Should we have
    one function to carry out both of these tasks? Or, maybe we should have two functions,
    one for the correct information and one for the misplaced information? We see
    good arguments on each side. If we put the tasks together into the same function,
    we keep the player feedback centralized in one place, and that may make it easier
    for us to confirm it’s written correctly. On the other hand, having two separate
    functions would make it easier to test each type of feedback (correct or misplaced)
    at the expense of spreading out the logic for the feedback across two functions.
    We somewhat arbitrarily chose to use a single function here, but if you were hoping
    to have two separate functions, we encourage you to try that on your own after
    you finish working through this section.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take stock. We have a function to generate the computer’s secret code.
    We have a function to get the player’s next guess. We have a function to get the
    correct/misplaced clues for the player’s guess. Those are three major subtasks
    that we’re happy to split out of our top-level function.
  prefs: []
  type: TYPE_NORMAL
- en: Is there any other subtask to split out? There’s certainly a little more work
    to do in our top-level function. For example, we need to detect if the player’s
    guess matches the secret code and end the game in that case. We feel that we don’t
    need a separate function for that, though. To determine whether the user’s guess
    equals the secret code, we can use Python’s `==` operator, which tells us directly
    whether two values are equal. And to end the game, we can use a `return` statement
    to end the top-level game function and thereby stop the program. Similarly, if
    the player uses all of their guesses without getting the secret code, then we
    need to tell them that they lost the game, but again, we should be able to do
    this with a small amount of Python code. As such, we’ll stop here with our main
    top-level function calling three subtask functions.
  prefs: []
  type: TYPE_NORMAL
- en: When we worked through our spelling suggestions problem in chapter 7, we needed
    to break one of our subtasks into sub-subtasks. But here, each of our three subtasks
    will be manageable as a single function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s think again about our first subtask: generating the computer’s
    secret code, with no duplicate digits allowed. Could we split any sub-subtasks
    out of here? Maybe we could have a function to check whether there are any duplicate
    digits in a proposed secret code. Then, we could keep generating secret codes,
    calling our sub-subtask function until it tells us that there are no duplicates.
    That would work, but we could also just generate the secret code digit by digit
    and not allow a duplicate to be added to the code in the first place. This latter
    plan seems to not need any sub-subtask to be split.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s think about our second subtask: getting the player’s next guess.
    We could split out a sub-subtask to tell us whether a guess is valid (i.e., it
    has the correct length and has no duplicates). While we could surely do that,
    it’s not much of a stretch to do this with a couple of checks in the subtask function
    itself. (Did your mind just go back to our example in chapter 7 about valid passwords
    and detecting valid passwords, where we split the check for validity into its
    own function? If so, the difference is that checking whether a password is valid
    is likely a more substantial task than the validity checks we need here.) It would
    certainly be okay to break this into another sub-subtask, but we’ll move forward
    without doing so. We’ve already argued that our third subtask is fine as is, so
    we’ll stop our top-down design here.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll name our top-level function `play`. In it, we’ll call three functions
    corresponding to the three subtasks that we just identified. We’ll call the function
    for our first subtask (generating the computer’s secret code) `random_string`,
    the function for our second subtask (getting the player’s next guess) `get_guess`,
    and the function for our third subtask (providing feedback to the player) `guess_result`.
    See figure 10.3 for this top-down design depicted as a tree.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 Top-down design for the Bulls and Cows game. The top-most (left-most)
    function is `play`, which calls `random_string`, `get_guess`, and `guess_result`.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 10.3.3 Parameters and return types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Normally, we define the types of parameters and return value for each function
    during the top-down design itself, but we wanted to discuss that separately here
    because there are some subtle aspects this time. For example, you may already
    be imagining that we’ll use integers to represent the secret code and guesses;
    but, as we’ll see shortly, this isn’t the best choice. We’ll make some decisions
    about how we’ll represent the data for all the functions before we write each
    one.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The `play` function is our top-level function and the starting point for our
    game. It would be possible to have this function take no parameters. Somewhere
    in the code of the function, we’d have to hard-code the fact that the secret code
    has four digits and that the player gets, say, 10 guesses. But that wouldn’t be
    very flexible. What if we wanted to play a version of the game where the secret
    code is seven digits and the player gets 100 guesses? We’d have to go into the
    code and make all the necessary changes. So, to make the game easily configurable,
    we can provide some parameters to this function. For example, rather than always
    having the secret code be four digits, we could use a parameter to allow the length
    of the secret code to be set to whatever we want. Similarly, rather than putting
    the maximum number of player guesses directly into the function, we could make
    that a parameter as well so that we can easily change it. Then, all we need to
    do to alter the gameplay is to call this function with different values for these
    parameters, without having to mess around with the code of the function itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Using parameters and variables to avoid magic numbers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The number of allowed guesses and the number of digits in the secret code are
    good examples that we can use to explain an important principle in code design.
    This principle is that when we write code, if a number can be a parameter or variable,
    it should be. This principle ensures the code is as versatile as possible. When
    programmers see a number being used, rather than a friendly name, they call this
    a “magic number” and that’s what we want to avoid. In our discussion about the
    number of guesses the player gets or the number of digits for the secret code,
    those should be parameters if we abide by this principle. At some point, these
    parameters need to be given concrete numbers for the code to work, but we should
    assign them values at the highest level of the code as possible (e.g., the player
    might set these parameters when the game starts).
  prefs: []
  type: TYPE_NORMAL
- en: To help adhere to this general principle, whenever you see a raw number (e.g.,
    4) in the code, ask yourself if that could be a parameter or variable. More often
    than not, it should be.
  prefs: []
  type: TYPE_NORMAL
- en: Adding these parameters is another example, as per our discussion in chapter
    3, of making functions general purpose rather than unnecessarily restrictive.
    Our `random_string` function is the function that generates the computer’s secret
    code. Why did we put `string` in this function name? Shouldn’t we be returning
    a random integer, like 1862? What does a string have to do with this?
  prefs: []
  type: TYPE_NORMAL
- en: Well, the problem with returning an integer is that the secret code might start
    with 0\. A secret code like 0825 is a perfectly valid four-digit secret code.
    But 0825 as an integer is 825, which doesn’t have enough digits. The string `'0825'`
    is just four characters that happen to each be digits, so there’s no problem with
    starting a string like this with a `'0'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond that, let’s think ahead about what we’ll eventually need to be doing
    with the computer’s secret code. We’ll need to compare it digit by digit with
    the player’s guess to determine which digits match. Using indexing on strings
    will give us easy access to each character of the string, which is exactly what
    we need. It’s more challenging to access each individual digit of an integer:
    integers don’t support indexing!'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our `random_string` function will take the required number of digits of
    the secret code as a parameter and will return a random string of that length,
    where each character in the string is a digit character. When we talk about digits
    in a string, all we’re referring to are the characters of the string. They happen
    to be digit characters, but they’re still characters, just like `''a''` or `''*''`.
    Don’t be confused by the fact that the string might look like a number! Here’s
    an example showing that these strings work the same way every other string works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We access characters of the string as we always do.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 We can’t add a string and an integer.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 This is string concatenation, not numeric addition.'
  prefs: []
  type: TYPE_NORMAL
- en: What about `get_guess`, the function to get the next guess from the player?
    As with `random_string`, this function will need to know the number of digits
    of a valid guess, so we’ll make that a parameter. It will return a string giving
    the player’s guess.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s talk about `guess_result`, the function that tells us how many
    digits are correct and how many are misplaced. This function will need both the
    player’s guess string and the computer’s secret code string in order to make comparisons
    between them, so we’ll need this function to take those two parameters. We need
    to return two pieces of information—the number of digits that are correct and
    the number of digits that are misplaced—so we’ll return a list of two integers.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.4 Implementing our functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having completed our top-down design, we can now work with Copilot to write
    the code for each of our functions. As always, we’re going to write the functions
    in order from bottom to top. This means that we’ll first implement our three subtask
    functions and then ultimately implement our top-level `play` function.
  prefs: []
  type: TYPE_NORMAL
- en: random_string
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As always when working with Copilot to generate code, we provide the `def` line
    and docstring and then Copilot writes the code. In each code listing, we’ll also
    provide some guidance about how the code works.
  prefs: []
  type: TYPE_NORMAL
- en: We want our `random_string` function to take the number of digits in a secret
    code as a parameter and return a random secret code without duplicates. In the
    code for this function, we might expect Copilot to use `random.randint` in a loop
    that continues running as long as we don’t have enough digits. To avoid adding
    duplicate digits, the code would add a random digit to the secret code only if
    that digit isn’t already in there. We found such a solution in our Copilot results,
    and that’s the one we’ve chosen to present in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.1 Function `random_string` for generating a secret code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Don’t forget to import the random module.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Starts with the empty string (no digits so far) as the secret code'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Loops while we still need digits'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Generates a random integer from 0 to 9'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 If this digit isn’t already in the secret code . . .'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 . . . add this digit to the secret code.'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Returns the secret code'
  prefs: []
  type: TYPE_NORMAL
- en: We’re not focusing on testing in this chapter, but even if we were, we wouldn’t
    include exact tests in our docstring for this function. That’s because this function
    has a random result. Randomness can make testing functions difficult because it’s
    hard to control the random values you get. What we could do is add a test to our
    docstring that at least checks that the generated secret code contains the correct
    number of characters, that there are no duplicate characters, and that each character
    is a valid digit. You can also test such functions by running them and observing
    that their result is always within the bounds of your random range and that the
    results appear random.
  prefs: []
  type: TYPE_NORMAL
- en: If you did carry through with testing, you’d find that we have a perfectly fine
    implementation of this function and that there’s no need to do more. If you just
    want the game to work, you can skip to where we start writing the `get_guess`
    function. If you’d like to learn more about Python and function design, we’d like
    to take this opportunity to spend a bit more time looking at different solutions
    to this function.
  prefs: []
  type: TYPE_NORMAL
- en: We encourage you to check out the Copilot suggestions in the window that appears
    when you press Ctrl-Enter to see some of the other possibilities. For example,
    we can start with a list of all the integers from 0 to 9 and then use a function
    called `random.shuffle` to shuffle that list into random order. Then, all we do
    is take the first `length` integers from that shuffled list (where `length` is
    the length of the secret code), and that’s the secret code! We’re guaranteed not
    to get any duplicate digits because the original list that we shuffle doesn’t
    have any duplicate digits. That version of the function might look like the following
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.2 Alternative solution for the function `random_string`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Creates the list [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Shuffles the list in a random order'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Returns the first “length” digits from the shuffled list'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about what this code is doing, you have the tools
    to do that! Don’t assume that the code is out of your grasp. You can ask Copilot
    to explain the code. You might get an explanation like the following.
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanWhat does my `random_string` function do?
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot The code is a Python function
    called `random_string` that takes an integer `length` as input and returns a string
    of the given length, where each character is a digit from 0 to 9, and with no
    repeated digits.'
  prefs: []
  type: TYPE_NORMAL
- en: The function first creates a list of digits from 0 to 9 using the `range` function
    and the `list` constructor. It then shuffles the list using the `shuffle` function
    from the random module. This ensures that the digits are in a random order.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the function uses a list comprehension to convert the first `length`
    digits of the shuffled list to strings and join them together into a single string
    using the `join` method.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the `random_string` function generates a random string of digits with
    no repeated digits, which can be useful for generating unique identifiers or passwords.
  prefs: []
  type: TYPE_NORMAL
- en: What’s a *list comprehension*? You don’t need to figure this out on your own,
    you can ask Copilot to explain it.
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanHow does that list comprehension work?
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot The list comprehension in the
    `random_string` function is used to convert the first `length` digits of the shuffled
    list to strings and join them together into a single string using the `join` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of how the list comprehension works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`str(d)` for d in `digits[:length]` is the expression that generates the list
    of strings. It takes each digit in the first `length` elements of the `digits`
    list, converts it to a string using the `str` function, and returns the resulting
    string.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`digits[:length]` is the iterable that the list comprehension operates on.
    It takes the first `length` elements of the `digits` list, which have been shuffled
    randomly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The entire list comprehension is enclosed in square brackets, which creates
    a new list from the elements generated by the expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `join` method is called on the resulting list of strings to join
    them together into a single string with no separator between them.
  prefs: []
  type: TYPE_NORMAL
- en: Some of this text from Copilot may not be completely understandable, but you
    could keep asking it to explain what you’re unsure about until you’re satisfied
    you understand how this is working.
  prefs: []
  type: TYPE_NORMAL
- en: We didn’t need to show this second working solution for this function, but we
    want to take this opportunity to remind you of how far you’ve come. As you’ve
    progressed through the book, you’ve been developing tools and techniques to understand
    and create software as well as the confidence to learn and keep learning more!
    Getting back to the problem at hand, let’s code our next function.
  prefs: []
  type: TYPE_NORMAL
- en: get_guess
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our `get_guess` function takes the number of required digits as a parameter
    and returns a valid guess from the player. Remember that for a guess to be valid,
    it must contain the right number of digits, and it must not have any duplicate
    digits. Here’s what we got from Copilot in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.3 Function `get_guess` for user input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '#1 First tries to get a valid guess from the player'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 While length is wrong, or the guess isn’t all digits or has duplicates .
    . .'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 . . . subsequently tries to get a valid guess from the player'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Returns the valid guess'
  prefs: []
  type: TYPE_NORMAL
- en: That `while-loop` condition is a complex one! The final part, `len(set(guess))`
    `!=` `length`, is responsible for checking whether the user entered any duplicate
    digits. It’s using a Python set to do that. We did see this trick back in chapter
    7, section 7.7.7, but that was a while ago! So, if you need a refresher, don’t
    hesitate to ask Copilot for an explanation of that line.
  prefs: []
  type: TYPE_NORMAL
- en: guess_result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our `guess_result` function takes two strings as parameters: the player’s most
    recent guess and the secret code. It returns a list of two integers: the number
    of correct digits and the number of misplaced digits.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a tricky function to get right, so even though we haven’t been showing
    the tests we’d want to run in prior functions, we’re going to provide some explicit
    tests in the docstring for this function. We’re adding these docstring tests because
    the logic for this function is going to be complex enough that it will be hard
    to determine whether the code is correct by solely reading the code. For our docstring
    tests, we’ll need some good example cases of different secret codes and user guesses
    to ensure the number of correct and misplaced digits returned by the function
    are as expected. Of course, per chapter 6, you’d likely want to add even more
    test cases if you were interested in doing serious testing. Our first test case
    is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The correct return value here is `[1,` `2]` because there’s one digit that’s
    correct (the 8), and two misplaced digits (the 2 and the 1). Our second test case
    is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The correct return value this time is `[0,` `4]` because there are zero correct
    digits, but all four digits of the guess are misplaced. Here’s our complete docstring,
    including test cases, and the code from Copilot.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.4 Function `guess_result` to get the result of a guess
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '#1 This variable is for the correct digits.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 This variable is for the misplaced digits.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Goes through each index of the digit strings'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 This digit is correct.'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Increases correct count by 1'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 This isn’t a match but is misplaced.'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Increases misplaced count by 1'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Returns both results in a list'
  prefs: []
  type: TYPE_NORMAL
- en: The use of `elif` is subtle here. If it were written as `if` rather than `elif`,
    then the code would be wrong! Do you see why? If not, try conversing with Copilot
    before continuing to read our explanation here.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that the `if` condition `guess[i]` `==` `secret_code[i]` is `True`.
    In that case, we increase `correct` by 1, and we skip the `elif` statements. (Remember,
    the `elif` statements run only if the preceding `if` and any preceding `elif`
    conditions are `False`.)
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine we changed the `elif` to an `if`. If the `if` condition `guess[i]`
    `==` `secret_code[i]` is `True`, we’d still increase `correct` by 1\. But then,
    we’d check the `guess[i]` `in` `secret_code` condition, and this one would be
    `True` as well. After all, we just said that `guess[i]` `==` `secret_code[i]`,
    which proves that `guess[i]` is indeed somewhere in `secret_code`. So, we’d erroneously
    do the `misplaced` `+=` `1`, which we certainly don’t want to do (it’s a matched
    digit, not a misplaced one too)!
  prefs: []
  type: TYPE_NORMAL
- en: play
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re done with our subtask functions! Now all we need to do is write the `play`
    top-level function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `play` function takes two integers as parameters: the number of digits
    in the secret code and guesses, and the number of guesses that the player has
    to guess the secret code. It doesn’t return anything—it just plays the game! Our
    final prompt and code for this function is given in the following listing.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.5 Function `play` for playing the game
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Generates the computer’s secret code'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Loops once for each possible player guess'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Gets the next valid guess from the player'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Gets the “correct” and “misplaced” feedback for this guess'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Tells the player the hints'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Player correctly guesses the secret code!'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Exits the function; this ends the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 If we get here, then the player ran out of guesses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we ran our program now, nothing would happen. That’s because we haven’t
    called the `play` function yet! We always need to remember to call our top-level
    function. To call it, we can add this line below the `play` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `4` means that we’re playing with four-digit codes and guesses, and the
    `10` means that we have 10 guesses to correctly guess the secret code. You can
    change these arguments to tune the game how you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give our game a whirl before we continue. We’ll show our first few guesses
    and then our final guess:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We’ve succeeded in designing a computer game, which is a very different kind
    of program than the other programs we’ve written in this book. Our computer game
    interacts with the user, has randomness, involves two players (the human player
    guessing and the computer player providing the correct/misplaced clues), and has
    winning and losing conditions. That’s a lot of new stuff! However, we also hope
    that you see how much we’ve learned and brought forward from prior chapters. We’re
    still doing top-down design, still designing functions, still testing code, still
    reading code, and still conversing with Copilot. You hadn’t written a game prior
    to this chapter, but essentially, you already had the skills to do that. Don’t
    let a seemingly new type of program or app stop you from trying to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.5 Adding a graphical interface for Bulls and Cows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be disappointed that our game doesn’t look much like a game you’ve
    recently played because there are no graphics, just text. For example, there’s
    no nice area to type in, no buttons to click, and no graphical interface at all.
    We’ve already argued why we focus on text games in this chapter, but it doesn’t
    mean that turning this game into a graphical interface version is entirely out
    of your grasp because you could interact with Copilot to see if it can help you
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge is that programmers create graphical user interfaces using a style
    of programming called *event-driven programming,* which we haven’t taught you
    yet and is too large to teach in this chapter. You can likely read through event-driven
    programming code and make some sense of it, and that’s what you’d need to do if
    you ask Copilot to write code to produce a graphical interface. That said, if
    Copilot doesn’t give you what you want, it may be difficult to fix without first
    becoming familiar with event-driven programming. There’s a nice book on game programming
    that includes graphical user interfaces and event-driven programming in Python
    called *Invent Your Own Computer Games with Python* [3] if you’d like to learn
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven programming
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Event-driven programming is commonly used for programs that interact with users.
    At a high level, the program sets up a way for the user to interact with the program
    (e.g., by pressing buttons or entering text) and then just sits and waits for
    the user to do something, sometimes updating the state of the game while waiting
    for the user input. Once the human interacts with the game, the code recognizes
    this interaction as an *event*,and each event has code associated with it that
    should execute when the event occurs. For example, when a user clicks the Quit
    Game button, it triggers the code that needs to be executed when the user wants
    to quit (e.g., saving the state of the game and exiting the program).
  prefs: []
  type: TYPE_NORMAL
- en: 'We were quite impressed by what Copilot gave us when we asked it to create
    the graphical interface for Bulls and Cows, so we’d like to show you how well
    it did. The code is somewhat readable even without knowing event-driven programming.
    For example, you can probably find the title of the game and change it. To do
    this, we asked Copilot Chat the following question:'
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanCan you convert this program to use a graphical interface instead of
    a text interface?
  prefs: []
  type: TYPE_NORMAL
- en: Copilot responded to us by laying out, step by step, the changes that we’d need
    to make to do so. It then rewrote the code so that the game now used a graphical
    interface with buttons and edit boxes, rather than a text interface. See figure
    10.4 for the new interface. The code to generate this interface is on the website
    for the book in case you’re interested in running it yourself or learning about
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 The graphical interface for the game as provided by Copilot. Note
    that it shows the secret code, presumably to help with testing (you’d want to
    remove that before playing the game).
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '10.4 Example 2: Bogart'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Our second game will be a two-player dice game. In Bulls and Cows, one of
    our players was human and the other was the computer. This time, we’ll write a
    game for two human players. Randomness again will play a key role. Once we’re
    done, you can play against a friend or family member!*'
  prefs: []
  type: TYPE_NORMAL
- en: '*### 10.4.1 How the game works'
  prefs: []
  type: TYPE_NORMAL
- en: The game that we’ll be writing here is called Bogart and was designed by Crab
    Fragment Labs. This is a dice game for two players. The game also uses a pot of
    chips or coins. We obviously won’t need actual dice or chips, though, as we’re
    implementing this as a computer game.
  prefs: []
  type: TYPE_NORMAL
- en: Bogart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Bogart game was designed by James Ernest (© 1999 James Ernest and Cheapass
    Games, used by permission; [https://crabfragmentlabs.com/](https://crabfragmentlabs.com/)).
    You can download the instructions for the original game for free as part of a
    .pdf file of games: [https://crabfragmentlabs.com/shop/p/chief-herman-1](https://crabfragmentlabs.com/shop/p/chief-herman-1).
    If you enjoy the game and can’t stop playing our re-creation, we encourage you
    to support the work that Crab Fragment Labs is doing. We thank them for letting
    us use their game here!'
  prefs: []
  type: TYPE_NORMAL
- en: When the game starts, the pot of chips is empty (has no chips in it). One of
    the two players is randomly chosen to start the game. From there, each player
    takes turns until the game is over. We’ll first explain what it means for a player
    to take a turn and then give the rules for when the game ends. Figure 10.5 provides
    an overview of the flow of the game as well.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of a player’s turn, one chip gets added to the pot, and that
    player rolls one die. If that die is a 1, then the player’s turn is over, and
    they don’t collect any chips. If that die isn’t a 1, then the player gets to decide
    whether to continue their turn or not. If they decide not to continue their turn,
    they collect all the chips from the pot (making the pot empty).
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 Player turn in Bogart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If they do decide to continue their turn, then two chips get added to the pot,
    and they roll two dice. If one or both of those dice is a 1, then the player’s
    turn is over. Otherwise, the player again gets to decide whether to continue their
    turn or not.
  prefs: []
  type: TYPE_NORMAL
- en: If they continue their turn, then they roll three dice, then four dice, and
    then five dice. (Players can’t choose to skip a number of dice; they must work
    through the number of dice sequentially starting from one die.) If they ever roll
    a 1, then their turn ends, and they don’t collect any chips. If they decide not
    to continue their turn, then they collect all the chips from the pot.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling a 1 in this game is bad news for the current player. When rolling one
    die, the probability of rolling a 1 is low, only 1 in 6 (about 17%). When rolling
    two dice, the probability of rolling at least one 1 is higher, this time about
    31%. It’s higher still when rolling three dice (42%), four dice (52%), or five
    dice (60%). So, the longer you extend your turn, the higher the probability that
    you’ll eventually roll a 1 and get nothing for your turn. Worse, you’ll likely
    leave the pot quite full for the other player to collect if they play more conservatively
    than you. At the same time, the longer you extend your turn, the faster the chips
    in the pot accumulate and the more chips you can collect assuming that you do
    successfully end your turn eventually. The whole trick is to decide when to press
    your luck for more chips and when to take what you’ve got.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how a player’s turn works. Players alternate turns, rolling dice and
    collecting chips, until the game ends. There are two ways that the game can end:'
  prefs: []
  type: TYPE_NORMAL
- en: If a player collects a total of 30 or more chips, then that player wins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Say a player on their turn rolls one die, then two dice, then three, then four,
    and then five, never once rolling a 1\. Then, that player instantly wins. It doesn’t
    matter how many chips they’ve collected: if they get to five dice of which none
    are a 1, they win.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Example game of Bogart
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s play out a few turns of the game to make sure we’re clear on how it all
    works. The pot starts out empty. Let’s say that Player 1 is the player randomly
    chosen to go first. We add one chip to the pot, and Player 1 rolls one die. Let’s
    say that they roll a 5\. Now Player 1 has to decide whether to end their turn
    and take the one chip from the pot or continue their turn.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say that they continue their turn. We add two chips to the pot; now the
    pot has three chips. Player 1 rolls two dice. Let’s say they roll a 4 and a 2.
  prefs: []
  type: TYPE_NORMAL
- en: Should they end their turn and take the three chips? Nah, nah. They want more.
    They continue their turn. We add three chips to the pot; now the pot has six chips.
    Player 1 rolls three dice. This time, they roll a 6, a 5, and—oh no!—a 1\. Player
    1’s turn is over. They got no chips, and they left a juicy six chips in the pot
    for Player 2.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s Player 2’s turn. We add one chip to the pot—that’s seven chips now!—and
    Player 2 rolls one die. Let’s say that they roll a 2\. If Player 2 ends their
    turn now, they’ll collect the seven chips from the pot. That feels like a lot,
    so let’s say that Player 2 does decide to end their turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the pot is empty, and it’s back to being Player 1’s turn. Player 1 has
    some catching up to do: they have 0 chips and Player 2 has 7 chips. We’ll stop
    here, but the game will continue until one of the players racks up 30 or more
    chips or they get to roll five dice and manage not to roll a single 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 10.4.2 Top-down design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As was the case when we implemented our Bulls and Cows game, implementing Bogart
    is a large problem for which we need top-down design. We’ll offer that design
    now, but here we encourage you to try it on your own before continuing. We recommend
    this because we found an effective top-down design to be subtle for this game
    due to the number of interacting elements. For example, a player’s turn can end
    in one of three ways: collect the chips, don’t collect the chips, and instantly
    win. We need to be able to determine which of these situations happened. As another
    example, after each player’s turn, we need to switch to the other player—except,
    unfortunately, not always: if a player wins the game, we want to stop the game
    right there and declare them the winner, not switch to the other player! We’ll
    primarily focus on our successful top-down design here, but we’ll occasionally
    justify why we made our decisions and what went wrong with other decisions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll name our top-level function `play`. Here are the main subtasks that we’ll
    need to solve for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the pot, and start Player 1 and Player 2 with zero chips. This is
    part of the game setup phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Randomly choose Player 1 or Player 2 to start the game. This too is part of
    the game setup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we enter the gameplay phase. While the game isn’t over, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the number of chips in the pot, number of chips Player 1 has, and number
    of chips Player 2 has.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a full turn for the current player.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the current player won chips, give the chips to the current player, and reset
    the pot to have zero chips.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the other player’s turn.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the name of the player (Player 1 or Player 2) who won the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point in the book, we suspect you’ve become familiar enough with the
    code from Copilot to have some nice intuition about which of these tasks will
    require separate functions. Task 1 is just a few variable assignments, so we don’t
    need a separate function for that. Other tasks for which we don’t need a separate
    function are task 2 (just a call to `random.randint`), 3a (just a few `print`
    calls), and 4 (a `print` call). We’ll capture each of the remaining subtasks in
    a function. The following subsections describe each of the remaining subtasks.
  prefs: []
  type: TYPE_NORMAL
- en: Task 3\. While the game isn’t over
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll have a `while` loop that continues while the game isn’t over, so we’ll
    need a function to tell us whether the game is over! How can the function know
    whether the game is over? It’ll need to know the current number of chips that
    Player 1 has and the current number of chips that Player 2 has. That way, it can
    check whether one of these is at least 30\. But remember that there’s another
    way for the game to end, and that’s when a player rolls five dice, none of which
    is a 1\. Therefore, this function will also need to know the most recent dice
    rolls for the current player.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll name this function `game_over`. It will take three parameters: Player
    1 chips, Player 2 chips, and list of rolls. It will return `True` if the game
    is over and `False` otherwise. The code for this function will need to check a
    few conditions, but we should be able to do that without splitting it out into
    further subtasks.'
  prefs: []
  type: TYPE_NORMAL
- en: Task 3b. Take a full turn for the current player
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ll name this function `take_full_turn`. The function *needs* to know how
    many chips are in the pot right now, so that it can update that as needed. It’ll
    also need to return the updated number of chips in the pot. Beyond that, there’s
    a lot that we need to manage to carry out a full turn, so we’re going to need
    to keep the complexity of this function under control. Here’s what comes to mind
    for what this function may need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow the player to roll one die, then two dice, then three dice, and so on
    until the player’s turn is over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the current player’s number of chips based on what happened on this turn.
    We could add an additional return value to communicate this updated information
    to whoever called this function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine whether the game is over. We could add an additional return value
    where `True` means that the game is over and `False` means that it isn’t.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We initially tried to have the function do all three of these things but were
    unable to receive satisfactory code from Copilot. This isn’t too surprising because
    we’re asking the function to do too much. This led us to focus on the core of
    this function, which is point 1.
  prefs: []
  type: TYPE_NORMAL
- en: But OK, if we focus only on point 1, then how are we going to update the current
    player’s number of chips (point 2), and how will we know whether the game is over
    (point 3)? For point 2, the solution we thought of is to not update the current
    player’s chip count at all in this function, instead returning the total number
    of chips in the pot after this turn.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if there were 10 chips in the pot and this player’s turn generated
    6 chips, then we’d return 16\. The player may or may not get to collect these
    16 chips—it depends on how their turn ended—but we won’t deal with that here (this
    is for the calling function to manage now).
  prefs: []
  type: TYPE_NORMAL
- en: For point 3 (knowing whether the game is over), our solution is to have the
    function return the most recent list of rolls as part of its return value. (This
    list of rolls will also be needed by the calling function for point 2.) The function
    that calls this one can then use those rolls to determine whether the game is
    over.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, our function will take the number of chips in the pot as a parameter
    and will return a list of two values: the new number of chips in the pot after
    the player’s turn and the most recent list of rolls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To take a full turn, we’ll need to be able to roll dice: first one die, then
    two dice, then three dice, and so on. We’ll split this out into a function named
    `roll_dice`. It will take the number of dice to roll as a parameter and will return
    a list of rolls. For example, if we ask the function to roll three dice, we might
    get back `[6,` `1,` `4]`.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also need to be able to determine whether the turn is over based on the
    most recent list of rolls. If the player rolled any 1s or rolled five dice none
    of which is a 1, then the turn is over. We’ll split that out too into a function
    named `turn_over`. It will take the list of rolls as a parameter and will return
    `True` if the turn is over and `False` if not.
  prefs: []
  type: TYPE_NORMAL
- en: If the turn isn’t over, then we’ll need to ask the player whether they want
    to continue their turn. We’ll ask for a yes (y) or no (n) response. We can do
    that using a call to the `input` function. If the player wants to keep going,
    we can again call `roll_dice`. We don’t need a separate function for asking for
    user input, so we won’t break this part down any further. If we wanted to validate
    the user’s input (rejecting any response that’s not y or n), that would increase
    the complexity enough so that we’d probably split it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, we’ve split out two subtasks for our `take_full_turn` function:
    `roll_ dice` and `turn_over`. These functions don’t need to be broken down any
    further. For `roll_dice`, we can use `random.randint` in a loop to generate the
    rolls that we need. And, `turn_over` will amount to a couple of checks on the
    dice rolls to determine whether they ended the turn for which we won’t need any
    further breaking down.'
  prefs: []
  type: TYPE_NORMAL
- en: Task 3c. If the current player won chips
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a player’s turn ends, we’re furnished with the new number of chips in the
    pot and the final list of rolls that ended the turn. We need to determine whether
    the player gets those chips or not. (If the final list of rolls doesn’t contain
    a 1, then the player collects the chips; otherwise, they don’t, and the chips
    stay in the pot.)
  prefs: []
  type: TYPE_NORMAL
- en: We’ll split out a function to tell us whether the player collects the chips
    or not. We’ll name it `wins_chips`. This function will take the most recent list
    of rolls as a parameter and will return `True` if the player wins the chips and
    `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Task 3d. Switch to the other player’s turn
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ll name this function `switch_player`. Suppose that the current player has
    just finished their turn. We need to switch to the other player’s turn, but only
    if the game isn’t over yet. Our function will encapsulate this logic. It will
    need to call `game_over` to determine whether the game is over, so we need at
    least three parameters for `switch_player`: player 1’s chips, player 2’s chips,
    and the most recent list of dice rolls. We’ll also need a parameter to indicate
    the current player (1 or 2), so that we can return the number of the new current
    player. So, the function will take those four parameters, and it will return a
    1 or a 2 indicating the player that we’re switching to next.'
  prefs: []
  type: TYPE_NORMAL
- en: If the game is over, this function won’t do anything. And if the game isn’t
    over, then we’ll need to change a 1 to a 2 or a 2 to a 1\. We already have the
    `game_over` function, and that’s sufficient for breaking down this function.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve finished our top-down design! Check out figure 10.6 for our tree of functions.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 Top-down design for the Bogart game
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 10.4.3 Implementing our functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now it’s time to work with Copilot to write the code for each of our functions.
    As always, we’ll start with leaf functions and move our way up (left in the diagram),
    implementing our top-level `play` function only when all other functions have
    been implemented. We can start with any leaf function. We’ll start with the `game_over`
    function because it’s needed both by `play` and by `switch_player`. Then, we’ll
    move on to other functions.
  prefs: []
  type: TYPE_NORMAL
- en: game_over
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This function takes three parameters: the number of chips that Player 1 has,
    the number of chips that Player 2 has, and the most recent list of rolls. It returns
    `True` if the game is over, and `False` if not, as shown in the following listing.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.6 `game_over` function in Bogart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The three ways that the game is over'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that there are three ways for the game to be over: Player 1 has at
    least 30 chips, Player 2 has at least 30 chips, or a player managed to roll five
    dice on their last turn without rolling a 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Returning a Boolean directly
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You may have expected to see the code this way, with the use of `if-else` and
    actual `return` `True` and `return` `False` lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This would work, but it’s more common to see programmers use a `return` statement
    directly with the `True`/`False` expression. It works because the result of the
    expression is what is being returned. If the expression is true, `True` gets returned,
    and if the expression is false, `False` gets returned. That’s exactly the same
    thing that the `if-else` version does!
  prefs: []
  type: TYPE_NORMAL
- en: roll_dice
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is the function that rolls our dice and adds randomness to our game. It
    takes the number of dice to roll as a parameter, and it returns the list of dice
    rolls. We’ll expect Copilot to make use of `random.randint` here, as shown in
    listing 10.7.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to returning the list of rolls, it’s also helpful if this function
    prints each dice roll. That way, the player can see exactly what they rolled.
    In the docstring, we ask Copilot to print the rolls (in addition to returning
    the list of rolls).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.7 `roll_dice` function in Bogart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '#1 List of dice rolls (integers between 1 and 6), starts empty'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Loops n times, once per roll'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Uses “randint” to generate a random integer between 1 and 6'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Prints roll for players to see'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Adds roll to list of rolls'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Returns list of rolls'
  prefs: []
  type: TYPE_NORMAL
- en: turn_over
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This function takes the most recent list of rolls and uses that to determine
    whether the current player’s turn is over or not. It returns `True` if the turn
    is over, and `False` if not, as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.8 `turn_over` function in Bogart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The two ways for the turn to be over'
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways for the player’s turn to be over. The first is when there’s
    a 1 in the list of rolls. The second is when the player has rolled five dice.
  prefs: []
  type: TYPE_NORMAL
- en: Is `len(rolls)` `==` `5` really enough for the turn to be over? Don’t we have
    to check whether there were any 1s rolled? No, if the player rolls five dice,
    then their turn is over no matter what, regardless of what the dice rolls were.
    If they rolled any 1s, then the turn is over because they rolled a 1 (and they
    won’t collect any chips). If they didn’t roll any 1s, then the turn is still over
    (and they’ll win the game automatically in this case).
  prefs: []
  type: TYPE_NORMAL
- en: take_full_turn
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’re ready for `take_full_turn` now, as shown in listing 10.9\. This function
    takes the number of chips currently in the pot as a parameter. It will process
    all the rolls from a full turn for the current player and then returns a list
    of two values: the new number of chips in the pot and the final list of rolls.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.9 `take_full_turn` function in Bogart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Rolls one dice'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Adds one chip to the pot'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 While the current player’s turn isn’t over . . .'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 . . . asks the player if they want to continue their turn.'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 If they do want to continue their turn . . .'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 . . . rolls one more dice than last time.'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Adds new chips to the pot'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Gets out of the while loop'
  prefs: []
  type: TYPE_NORMAL
- en: '#9 Returns both number of chips in the pot and the final list of rolls'
  prefs: []
  type: TYPE_NORMAL
- en: wins_chips
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This function takes a list of rolls as a parameter. If the rolls are good (i.e.,
    contain no 1s), then the player will collect the chips. If the rolls contain any
    1s, then the player won’t collect the chips. This function returns `True` if the
    player gets to collect the chips, and `False` otherwise, as shown in the following
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.10 `wins_chips` function in Bogart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Returns True when there are no 1s, and returns False otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: switch_player
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This function takes four parameters: the number of chips that Player 1 has,
    the number of chips that Player 2 has, the most recent list of rolls (rolled by
    the current player), and the number of the current player. If the game isn’t over,
    this function returns the number of the other player. If the game is over, then
    the function returns the current player (because there’s no turn for the other
    player!). See the following listing.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.11 `switch_player` function in Bogart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '#1 If game isn’t over . . .'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 . . . switches from 1 to 2 or from 2 to 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Returns new current player'
  prefs: []
  type: TYPE_NORMAL
- en: play
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve made it all the way up to our `play` function! We’ve decided to write
    this function without any parameters. You might wonder if we could make the code
    more flexible by adding, say, a parameter for the number of chips required to
    win (currently 30). You could certainly do that; we haven’t done that here to
    keep the number of parameters smaller throughout the code. This function doesn’t
    return anything. Instead, it plays the game, as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.12 `play` function in Bogart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Starts pot and players with 0 chips'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Randomly makes Player 1 or Player 2 start the game'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 While the game isn’t over . . .'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 . . . prints the current state of the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Lets the current player have their turn'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 If current player wins chips . . .'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 . . . and it’s Player 1 . . .'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 . . . gives Player 1 the chips from the pot; . . .'
  prefs: []
  type: TYPE_NORMAL
- en: '#9 . . . otherwise, gives Player 2 the chips from the pot.'
  prefs: []
  type: TYPE_NORMAL
- en: '#10 Resets pot to now have 0 chips'
  prefs: []
  type: TYPE_NORMAL
- en: '#11 Switches to the other player’s turn'
  prefs: []
  type: TYPE_NORMAL
- en: '#12 Prints out who wins'
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the code that we need for the game. Just add
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: below all of your existing code to call our `play` function, and then you’ll
    be able to play!
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the game
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’re happy with what Copilot has given us, and the game is certainly playable.
    But, admittedly, the interaction with the players could be a little more user-friendly.
    For example, here’s how the game might start when we run it and press y a few
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pot chips: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Player 1 chips: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Player 2 chips: 0'
  prefs: []
  type: TYPE_NORMAL
- en: Player 2 turn
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: Continue? (y/n) y
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: Continue? (y/n) y
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pot chips: 6'
  prefs: []
  type: TYPE_NORMAL
- en: 'Player 1 chips: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Player 2 chips: 0'
  prefs: []
  type: TYPE_NORMAL
- en: Player 1 turn
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: Continue? (y/n)
  prefs: []
  type: TYPE_NORMAL
- en: There’s no welcome message. Numbers like 4, 5, 2, and so on are just there,
    with no context of what they mean. The game asks us whether we want to “Continue?
    (y/n).” Continue what, though? It isn’t clear.
  prefs: []
  type: TYPE_NORMAL
- en: We can make the interaction with the players more pleasant by spicing up the
    `print` calls in our functions. We can just put what we want in each `print` statement
    ourselves. Why not just use Copilot? It’s likely easier to just do it rather than
    trying to cajole Copilot to print exactly what we want. For example, the following
    listing shows a new version of `play` where we’ve added more `print` calls to
    explain what’s going on and to better format the game output.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 10.13 `play` function in Bogart with better formatting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Prints welcome message'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Prints a blank line'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Prints message saying that the current player got chips'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Separates each turn from the next'
  prefs: []
  type: TYPE_NORMAL
- en: 'We encourage you to add `print` calls elsewhere as well to make the game interaction
    even better! For example, in `roll_dice`, you could add a `print` call to tell
    the players that dice are about to be rolled (**ROLLS** in the following output).
    In `take_full_ turn`, you could add a `print` call to print the number of chips
    in the pot prior to asking the player whether they’d like to continue their turn.
    Here’s what an interaction with our game looks like after we made those changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to Bogart!
  prefs: []
  type: TYPE_NORMAL
- en: 'Pot chips: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Player 1 chips: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Player 2 chips: 0'
  prefs: []
  type: TYPE_NORMAL
- en: Player 2 turn
  prefs: []
  type: TYPE_NORMAL
- en: '**ROLLS**'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: The pot currently has 1 chips.
  prefs: []
  type: TYPE_NORMAL
- en: Continue turn? (y/n) y
  prefs: []
  type: TYPE_NORMAL
- en: '**ROLLS**'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: The pot currently has 3 chips.
  prefs: []
  type: TYPE_NORMAL
- en: Continue turn? (y/n) y
  prefs: []
  type: TYPE_NORMAL
- en: '**ROLLS**'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
  prefs: []
  type: TYPE_NORMAL
- en: 'Pot chips: 6'
  prefs: []
  type: TYPE_NORMAL
- en: 'Player 1 chips: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Player 2 chips: 0'
  prefs: []
  type: TYPE_NORMAL
- en: Player 1 turn
  prefs: []
  type: TYPE_NORMAL
- en: '**ROLLS**'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: The pot currently has 7 chips.
  prefs: []
  type: TYPE_NORMAL
- en: Continue turn? (y/n)
  prefs: []
  type: TYPE_NORMAL
- en: Try making such changes to your code as well. Make the game yours!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we used Copilot to help us write two computer games: a logic
    game (similar to Wordle, but with numbers), and a two-player dice game. We were
    able to do this using the skills we’ve honed throughout the book, including problem
    decomposition, writing clear docstrings, and interacting with Copilot Chat.'
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is an error in the following `guess_result` function that leads to incorrect
    counts of correct and misplaced digits. Identify and fix the error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '2\. Modify the `get_guess` function from this chapter to include error messages
    that guide the player to enter a valid guess. Ensure that these messages are clear
    and helpful. Be creative! Here are some examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '“Error: Guess must contain only digits.”'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '“Error: Guess must not contain repeated digits.”'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Why did we choose to pass the number of digits and the number of guesses
    as parameters to the `play` function for the Bulls and Cows game? How does this
    decision enhance the flexibility of the game?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Implement a simple dice game where the player rolls two dice. If the total
    is 7 or 11, the player wins. If the total is 2, 3, or 12, the player loses. For
    any other total, the player continues to roll until they either match their initial
    roll (win) or roll a 7 (lose). Think carefully about how you want to divide the
    main problem here into smaller subproblems!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5\. Implement a version of the Bogart game where one player is human and the
    other is the computer. To do this, you’ll need to come up with some rules that
    the computer can use to end their turn. For example, the computer will certainly
    want to stop rolling dice when the number of chips that they’ve already accumulated
    on their turn is enough for them to win the game! The computer will also likely
    want to stop rolling once it can earn a large number of chips on its current turn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '6\. *The Price Is Right* game show is a great source of little games that may
    be fun to implement. For example, you can try implementing the game called Any
    Number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://priceisright.fandom.com/wiki/Any_Number](https://priceisright.fandom.com/wiki/Any_Number)'
  prefs: []
  type: TYPE_NORMAL
- en: In your game, the player should continue to choose numbers until all the digits
    of one of the prizes are revealed; that’s the prize that the player wins.
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Create a simple game using the Pygame library. In this game, the player
    controls a character that moves left and right to collect falling objects. The
    objective is to collect as many objects as possible without missing them. You
    can be flexible here with how the objects in your game look, so have fun with
    it! As a potential extension: Can you think of how you would keep track of the
    player’s high score?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Games have a common program flow that includes game setup and gameplay.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Randomness is an important ingredient of many games.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add randomness to our Python games by using functions in the random module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can implement games with Copilot using the same workflow that we’ve used
    throughout the book, with problem decomposition playing a key role.*****
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
