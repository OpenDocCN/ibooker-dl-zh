- en: 'Chapter 4\. Beyond the 70%: Maximizing Human Contribution'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve seen how AI coding assistants like Cursor, Cline, Copilot, and Windsurf
    have transformed how software is built, shouldering much of the grunt work and
    boilerplate—about 70%.^([1](ch04.html#id534)) But what about that last “30%” of
    the job that separates a toy solution from a production-ready system? This gap
    includes the hard parts: understanding complex requirements, architecting maintainable
    systems, handling edge cases, and ensuring code correctness. In other words, while
    AI can generate *code*, it often struggles with *engineering*.'
  prefs: []
  type: TYPE_NORMAL
- en: Tim O’Reilly, [reflecting on decades of technology shifts](https://oreil.ly/BYrNh),
    reminds us that each leap in automation has changed *how* we program but not *why*
    we need skilled programmers. We’re not facing the end of programming but rather
    “the end of programming as we know it today,” meaning developers’ roles are evolving,
    not evaporating.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge for today’s engineers is to embrace AI for what it does best (the
    first 70%) while doubling down on the durable skills and insights needed for the
    remaining 30%. This article dives into expert insights to identify which human
    skills remain crucial. We’ll explore what senior and midlevel developers should
    continue to leverage and what junior developers must invest in to thrive alongside
    AI.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter’s goal, then, is to offer you pragmatic guidance for maximizing
    the value of that irreplaceable 30%, with actionable takeaways for engineers at
    every level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Senior Engineers and Developers: Leverage Your Experience with AI'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re a senior engineer, you should see the advent of AI coding tools as
    an opportunity to amplify your impact—if you leverage your experience in the right
    ways. Senior developers typically possess deep domain knowledge, intuition for
    what could go wrong, and the ability to make high-level technical decisions.
  prefs: []
  type: TYPE_NORMAL
- en: These strengths are part of the 30% that AI can’t handle alone. This section
    looks at how seasoned developers can maximize their value.
  prefs: []
  type: TYPE_NORMAL
- en: Be the Architect and the Editor in Chief
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let AI handle the first draft of code while you focus on architecting the solution
    and then refining the AI’s output. In many organizations, [Steve Yegge](https://oreil.ly/QtJ7_)
    writes that we may see a shift where teams need “only senior associates” who “(a)
    describe the tasks to be done; i.e., create the prompts, and (b) review the resulting
    work for accuracy and correctness.” Embrace that model. As a senior dev, you can
    translate complex requirements into effective prompts or specifications for an
    AI assistant, then use your critical eye to vet every line produced. You are effectively
    pair programming with the AI—it’s the fast typer, but you’re the brain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maintain high standards during review: ensure the code meets your organization’s
    quality, security, and performance benchmarks. By acting as architect and editor,
    you prevent the “high review burden” from overwhelming you. (A cautionary note:
    if junior staff simply throw raw AI output over the wall to you, push back—instill
    a process where they must verify AI-generated work first, so you’re not the sole
    safety net.)'
  prefs: []
  type: TYPE_NORMAL
- en: Use AI as a Force Multiplier for Big Initiatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Senior engineers often drive large projects or tackle hairy refactors that juniors
    can’t approach alone. AI can supercharge these efforts by handling a lot of mechanical
    changes or exploring alternatives under your guidance. Yegge introduced the term
    [*chat-oriented programming* (CHOP)](https://oreil.ly/QtJ7_) for this style of
    working—“coding via iterative prompt refinement,” with the AI as a collaborator.
    Leverage CHOP to be more ambitious in what you take on.
  prefs: []
  type: TYPE_NORMAL
- en: Having AI assistance lowers the bar for when a project is worth investing time
    in at all since what might have taken days can now be done in hours. Senior devs
    can thus attempt those “Wouldn’t it be nice if…?” projects that always seemed
    slightly out of reach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key is to remain the guiding mind: you decide which tools or approaches
    to pursue, and you integrate the pieces into a cohesive whole. Your experience
    allows you to sift the AI’s suggestions—accepting those that fit, rejecting those
    that don’t.'
  prefs: []
  type: TYPE_NORMAL
- en: Mentor and Set Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another crucial role for senior engineers is to coach less-experienced team
    members on effective use of AI and on the timeless best practices. You likely
    have hard-won knowledge of pitfalls that juniors may not see, like memory leaks,
    off-by-one errors, and concurrency hazards.
  prefs: []
  type: TYPE_NORMAL
- en: With juniors now potentially generating code via AI, it’s important to teach
    them how to self-review and test that code. Set an example by demonstrating how
    to thoroughly test AI contributions, and encourage a culture of questioning and
    verifying machine output. Some organizations (including even law firms) have instituted
    rules that if someone uses an AI to generate code or writing, they must *disclose
    it and verify the results themselves*—not just assume a senior colleague will
    catch mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a senior engineer, champion such norms on your team: AI is welcome, but
    diligence is required. By mentoring juniors in this way, you offload some of the
    oversight burden and help them grow into that 30% skill set more quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: Continue to Cultivate Domain Mastery and Foresight
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your broad experience and context are more important than ever. Senior developers
    often have historical knowledge of why things in the company are built a certain
    way or how an industry operates. This domain mastery lets you catch AI’s missteps
    that a newcomer wouldn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Continue investing in understanding the problem domain deeply. That might mean
    staying up-to-date with the business’s needs, user feedback, or new regulations
    that affect the software. AI won’t automatically incorporate these considerations
    unless you tell it to. When you combine your domain insight with AI’s speed, you
    get the best outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Also, use your foresight to steer AI. For instance, if you know that a quick
    fix will create maintenance pain down the line, you can instruct the AI to implement
    a more sustainable solution. Trust the instincts you’ve honed over the years—if
    a code snippet looks “off” or too good to be true, dig in. Nine times out of ten,
    your intuition has spotted something that the AI didn’t account for. Being able
    to foresee the second- and third-order effects of code is a hallmark of senior
    engineers; don’t let the convenience of AI blunt that habit. Instead, apply it
    to whatever the AI produces.
  prefs: []
  type: TYPE_NORMAL
- en: Hone Your Soft Skills and Leadership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With AI shouldering some coding, senior developers can spend more energy on
    the human side of engineering: communicating with stakeholders, leading design
    meetings, and making judgment calls that align technology with business strategy.
    [Tim O’Reilly and others](https://oreil.ly/rbIKm) suggest that as rote coding
    becomes easier, the value shifts to deciding *what* to build and *how to orchestrate*
    complex systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Senior engineers are often the ones orchestrating and seeing the big picture.
    Step up to that role. Volunteer to write that architecture roadmap, to evaluate
    which tools (AI or otherwise) to adopt, or to define your org’s AI coding guidelines.
    These are tasks AI can’t do—they require experience, human discretion, and, often,
    cross-team consensus building. By amplifying your leadership presence, you ensure
    that you’re not just a code generator (replaceable by another tool) but an indispensable
    technical leader guiding the team.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, continue doing what seasoned developers do best: seeing the forest
    for the trees. AI will help you chop a lot more trees, but someone still needs
    to decide *which* trees to cut and *how* to build a stable house from the lumber.
    Your judgment, strategic thinking, and mentorship are now even more critical.
    A senior developer who harnesses AI effectively can be dramatically more productive
    than one who doesn’t—but the ones who truly excel will be those who apply their
    human strengths to amplify the AI’s output, not just let it run wild.'
  prefs: []
  type: TYPE_NORMAL
- en: As one Redditor [observed](https://oreil.ly/HulC9), “AI is a programming force
    multiplier” that “greatly increases the productivity of senior programmers.” The
    multiplier effect is real, but it’s your expertise that’s being multiplied. Keep
    that expertise sharp and at the center of the development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Midlevel Engineers: Adapt and Specialize'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Midlevel engineers face perhaps the most significant pressure to evolve. Many
    of the tasks that traditionally occupied your time—implementing features, writing
    tests, debugging straightforward issues—are becoming increasingly automatable.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn’t mean obsolescence; it means elevation. The focus shifts from writing
    code to more building specialized knowledge, which the following sections explore.
  prefs: []
  type: TYPE_NORMAL
- en: Learn to Manage Systems Integration and Boundaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As systems become more complex, understanding and managing the boundaries between
    components becomes crucial. This includes API design, event schemas, and data
    models—all requiring careful consideration of business requirements and future
    flexibility. Deepen your computer science fundamentals, including gaining an advanced
    understanding of disciplines like:'
  prefs: []
  type: TYPE_NORMAL
- en: Data structures and algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed-systems principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database internals and query optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network protocols and security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This knowledge helps you understand the implications of AI-generated code and
    make better architectural decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Learn to handle edge cases and ambiguity too. Real-world software is rife with
    oddball scenarios and changing requirements. AI tends to solve the general case
    by default. It’s up to the developer to ask “What if…?” and probe for weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: The durable skills here are critical thinking and foresight—enumerating edge
    cases, anticipating failures, and addressing them in code or design. This might
    mean thinking of null input, network outages, unusual user actions, or integration
    with other systems.
  prefs: []
  type: TYPE_NORMAL
- en: Build Your Domain Expertise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Understanding the business context or the user’s environment will reveal edge
    cases that a generic AI simply doesn’t know about. Experienced engineers habitually
    consider these scenarios. Practice systematically testing boundaries and questioning
    assumptions. Specialize in complex domains where human understanding remains crucial.
    Generic domains include:'
  prefs: []
  type: TYPE_NORMAL
- en: Financial systems with regulatory requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Healthcare systems with privacy concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time systems with strict performance requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machine learning infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software-engineering-specific domains include frontend and backend engineering,
    mobile development, DevOps, and security engineering, to name a few. Domain expertise
    provides context that current AI tools lack and helps you make better decisions
    about where and how to apply them.
  prefs: []
  type: TYPE_NORMAL
- en: Master Performance Optimization and DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While LLMs can suggest basic optimizations, identifying and resolving system-wide
    performance issues requires a deep understanding of the entire stack, from database
    query patterns to frontend rendering strategies. Understanding how systems run
    in production becomes more valuable as code generation becomes more automated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Focus on fields like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and observability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance profiling and optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security practices and compliance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost management and optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus on Code Review and Quality Assurance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With AI writing lots of code, the ability to rigorously review and test that
    code becomes even more critical. “Everyone will need to get a lot more serious
    about testing and reviewing code,” Yegge [emphasizes](https://oreil.ly/QtJ7_).
    Treat AI-generated code as you would a human junior developer’s output: you are
    the code reviewer responsible for catching bugs, security flaws, or sloppy implementations.
    This means strengthening your skills in unit testing, integration testing, and
    debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing good tests is a durable skill that forces you to understand the spec
    and verify correctness. It’s wise to assume nothing works until proven otherwise.
    AI often yields functional but unoptimized code until you guide it through iterative
    improvement. This can be due to a number of reasons, including that the training
    data coding models are trained on don’t reflect all best practices as completely
    as they could.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cultivate a testing mindset: verify every critical logic path, use static analysis
    or linters, and don’t shy away from rewriting AI-given code if it doesn’t meet
    your quality bar. Even if you’re following the “AI as validator” pattern discussed
    in the previous chapter, quality assurance is not an area to simply outsource
    to AI—it’s where human diligence shines. When software doesn’t work as expected,
    you need real problem-solving chops to diagnose and fix it. AI can assist with
    debugging (for example, by suggesting possible causes), but it lacks true understanding
    of the specific context in which your application runs. Human testers possess
    domain-specific knowledge and an understanding of user expectations that AI currently
    lacks. This insight is vital when assessing the relevance and impact of potential
    issues. Diagnosing complex bugs often requires creative problem solving and the
    ability to consider a broad range of factors—skills that are inherently human.
    And evaluating the ethical implications of software behavior, such as fairness
    and accessibility, requires human sensitivity and judgment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Being able to reason through a complex bug—reproducing it, isolating the cause,
    understanding the underlying systems (OS, databases, libraries)—is a timeless
    engineering skill. This often requires a strong grasp of fundamentals (how memory
    and state work, concurrency, etc.) that junior developers must learn through practice.
    Use AI as a helper (it might explain error messages or suggest fixes), but *don’t
    rely on it thoughtlessly*. The skill to methodically troubleshoot and apply first
    principles when debugging sets great developers apart. It’s also a feedback loop:
    debugging AI-written code will teach you to prompt the AI better next time or
    avoid certain patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: Learn Systems Thinking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software projects are not just isolated coding tasks; they exist within a larger
    context of user needs, timelines, legacy code, and team processes. AI has no innate
    sense of the big picture, like your project’s history or the rationale behind
    certain decisions (unless you explicitly feed all that into the prompt, which
    is often impractical). Humans need to carry that context.
  prefs: []
  type: TYPE_NORMAL
- en: The durable skill here is systems thinking—understanding how a change in one
    part of the system might impact another, how the software serves the business
    objectives, and how all the moving pieces connect.^([2](ch04.html#id574)) This
    holistic perspective lets you use AI outputs appropriately. For example, if an
    AI suggests a clever shortcut that contradicts a regulatory requirement or company
    convention, you’ll catch it because you know the context. Make it a point to learn
    the background of your projects and read design docs, so you can develop your
    judgment about what fits and what doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Be Adaptable—and Never Stop Learning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, a metaskill: the ability to learn new tools and adapt to change. The
    field of AI-assisted development is evolving rapidly. Engineers who keep an open
    mind and learn how to effectively use new AI features will remain ahead of the
    curve—Tim O’Reilly [suggests that](https://oreil.ly/BYrNh) developers who are
    “eager to learn new skills” will see the biggest productivity boosts from AI.
    Invest in learning the *fundamentals* deeply and staying curious about new techniques.
    This combination enables you to harness AI as a tool without becoming dependent
    on it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s a balancing act: use AI to accelerate your growth, but also occasionally
    practice without it to ensure you’re not skipping core learning (some developers
    do an [“AI detox”](https://oreil.ly/XFPqu) periodically to keep their raw coding
    skills sharp). In short, be the engineer who learns constantly—that’s a career-proof
    skill in any era.'
  prefs: []
  type: TYPE_NORMAL
- en: Get Good at Cross-Functional Communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ability to translate between business requirements and technical solutions
    becomes more valuable as implementation time decreases. Engineers who can effectively
    communicate with product managers, designers, and other stakeholders will become
    increasingly valuable. Good areas of focus here include:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements gathering and analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical writing and documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project planning and estimation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team leadership and mentoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn System Design and Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of spending days implementing a new feature, midlevel engineers might
    spend that time designing robust systems that gracefully handle scale and failure
    modes. This requires deep understanding of distributed systems principles, database
    internals, and cloud infrastructure—areas where LLMs currently provide limited
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Practice designing systems that solve real-world problems at scale. These skills
    remain valuable regardless of how code is generated, as they require understanding
    business requirements and engineering trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a coherent system requires understanding trade-offs, constraints,
    and the “big picture” beyond writing a few functions. AI can generate code but
    won’t automatically choose the best architecture for a complex problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall design—how components interact, how data flows, how to ensure scalability
    and security—is part of that 30% that demands human insight; this includes the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Load balancing and caching strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data partitioning and replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failure modes and recovery procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost optimization and resource management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Senior developers have long honed this skill, and midlevel and junior devs should
    actively cultivate it. Think in terms of patterns and principles (like separation
    of concerns and modularity)—these guide an AI-generated solution toward maintainability.
    Remember, *solid architecture doesn’t emerge by accident*; it needs an experienced
    human hand on the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: Use AI!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember that AI should be an integral part of your workflow—it’s not something
    to resist. Practical ways to incorporate AI into your daily work include:'
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding initial code structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick prototypes and proof of concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pair programming for faster debugging and problem solving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suggesting optimizations and alternative approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling repetitive code patterns while you focus on architecture and design
    decisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Venture into UI and UX Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s a growing narrative that midlevel software engineers should “just quit”—that
    pure engineering skills will become obsolete as AI handles the implementation
    details. While the conclusion is overstated, the discourse about the importance
    of skills beyond engineering (like design) deserves examination. In a representative
    exchange on X in December 2024, [@fchollet wrote](https://oreil.ly/BokTH):'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll soon be in a world where you can turn test-time compute into competence—for
    the first time in the history of software, marginal cost will become critical.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To which @garrytan replied:'
  prefs: []
  type: TYPE_NORMAL
- en: UX, design, actual dedication to the craft will take center stage in this next
    moment.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Actually make something people want. Software and coding won’t be the gating
    factor. It is the ability to be a polymath and smart/effective in many domains
    together that creates great software.
  prefs: []
  type: TYPE_NORMAL
- en: Successful software creation has always required more than just coding ability.
    What’s changing is not the death of engineering but rather the lowering of pure
    implementation barriers. This shift actually makes engineering judgment and design
    thinking more crucial, not less.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what makes applications like Figma, Notion, or VSCode successful.
    It’s not just technical excellence—it’s the deep understanding of user needs,
    workflows, and pain points. This understanding comes from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: User experience design thinking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep domain knowledge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding of human psychology and behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System design that considers performance, reliability, and scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business model alignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best engineers have always been more than just coders. They’ve been problem
    solvers who understand both technical constraints and human needs. As AI tools
    reduce the friction of implementation, this holistic understanding becomes even
    more valuable.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this doesn’t mean every engineer needs to become a UX designer. Instead,
    it means developing stronger product thinking abilities and building better collaboration
    skills with designers and product managers. It means thinking more about users,
    understanding their psychology and behavior patterns, and learning to make technical
    decisions that support user experience goals. You’re at the point of achieving
    technical elegance: now balance it out with close attention to practical user
    needs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tan went on to post:'
  prefs: []
  type: TYPE_NORMAL
- en: UX, design, actual dedication to the craft will take center stage in this next
    moment.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Actually make something people want. Software and coding won’t be the gating
    factor. It is the ability to be a polymath and smart/effective in many domains
    together that creates great software.
  prefs: []
  type: TYPE_NORMAL
- en: The future belongs to engineers who can bridge the gap between human needs and
    technical solutions—whether that’s through developing better design sensibilities
    themselves or through more effective collaboration with dedicated designers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Junior Developers: Thrive Alongside AI'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re a junior or less-experienced developer, you might feel a mix of excitement
    and anxiety about AI. AI assistants can write code that you might not know how
    to write yourself, potentially accelerating your learning. Yet there are headlines
    about the [“death of the junior developer”](https://oreil.ly/QtJ7_), suggesting
    entry-level coding jobs are at risk. Contrary to popular speculation, while AI
    is significantly changing the early-career experience, junior developers *are
    not obsolete*.
  prefs: []
  type: TYPE_NORMAL
- en: You need to be proactive in developing skills that ensure you’re contributing
    value beyond what an AI can churn out. The traditional path of learning through
    implementing basic CRUD applications and simple features will evolve as these
    tasks become increasingly automated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a typical junior task: implementing a new API endpoint following existing
    patterns. Previously, this might have taken a day of coding and testing. With
    AI assistance, the implementation time might drop to an hour, but the crucial
    skills become:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the existing system architecture well enough to specify the requirement
    correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing the generated code for security implications and edge cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring the implementation maintains consistency with existing patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing comprehensive tests that verify business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These skills can’t be learned purely through tutorial following or AI prompting—they
    require hands-on experience with production systems and mentorship from senior
    engineers.
  prefs: []
  type: TYPE_NORMAL
- en: This evolution presents both challenges and opportunities for early-career developers.
    The bar for entry-level positions may rise, requiring stronger fundamental knowledge
    to effectively review and validate AI-generated code. However, this shift also
    means junior engineers can potentially tackle more interesting problems earlier
    in their careers.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how to invest in yourself to handle that 30% gap effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Learn the Fundamentals—Don’t Skip the “Why”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s tempting to lean on AI for answers to every question (“How do I do X in
    Python?”) and never truly absorb the underlying concepts. Resist that urge. Use
    AI as a tutor, not just an answer vending machine. For example, when AI gives
    you a piece of code, ask *why* it chose that approach, or have it explain the
    code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you understand concepts like data structures, algorithms, memory
    management, and concurrency without always deferring to AI. The reason is simple:
    when the AI’s output is wrong or incomplete, you need your own mental model to
    recognize and fix it. If you’re not actively engaging with why the AI is generating
    certain code, you might actually learn less, hindering your growth. So take time
    to read documentation, write small programs from scratch, and solidify your core
    knowledge. These fundamentals are durable; they’ll serve you even as the tools
    around you change.'
  prefs: []
  type: TYPE_NORMAL
- en: Practice Problem Solving and Debugging Without the AI Safety Net
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build real confidence, sometimes you have to fly solo. Many developers advocate
    doing an “AI-free day” or otherwise limiting AI assistance periodically. This
    ensures you can still solve problems with just your own skills, which is important
    for avoiding skill atrophy. You’ll find it forces you to truly think through a
    problem’s logic, which in turn makes you better at using AI (since you can direct
    it more intelligently).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, whenever you encounter a bug or error in AI-generated code, jump
    in and debug it *yourself* before asking the AI to fix it. You’ll learn much more
    by stepping through a debugger or adding print statements to see what’s going
    wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Consider AI suggestions as hints, not final answers. Over time, tackling those
    last tricky bits of a task will build your skill in the very areas AI struggles—exactly
    what makes you valuable.
  prefs: []
  type: TYPE_NORMAL
- en: Focus on Testing and Verification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a junior dev, one of the best habits you can develop is writing tests for
    your code. This is doubly true if you use AI to generate code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you get a chunk of code from an LLM, don’t assume it’s correct—challenge
    it. Write unit tests (or use manual tests) to see if it truly handles the requirements
    and edge cases. This accomplishes two things: it catches issues in the AI’s output,
    and it trains you to think about expected behavior before trusting an implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: You might even use the AI to help write tests, but *you* define what to test.
    [Yegge’s advice](https://oreil.ly/QtJ7_) about taking testing and code review
    seriously applies at all levels. If you cultivate a reputation for carefully verifying
    your work (AI-assisted or not), senior colleagues will trust you more, and you’ll
    avoid the scenario where they feel you’re just “dumping” questionable code on
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In practical terms, start treating testing as an integral part of development,
    not an afterthought. Learn how to use testing frameworks, how to do exploratory
    manual testing, and how to systematically reproduce bugs. These skills not only
    make you better at the 30% work, but they also accelerate your understanding of
    how the code really works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: if you catch a bug that the AI introduced, *you* just did something
    the AI couldn’t—that’s added value.'
  prefs: []
  type: TYPE_NORMAL
- en: Build an Eye for Maintainability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Junior devs often focus on “getting it to work.” But in the AI era, getting
    a basic working version is easy—the AI can do that. The harder part (and what
    you should focus on) is making code that’s readable, maintainable, and clean.
  prefs: []
  type: TYPE_NORMAL
- en: Start developing an eye for good code structure and style. Compare the AI’s
    output with best practices you know of; if the AI code is messy or overly complex,
    take the initiative to refactor it. For instance, if an LLM gives you a 50-line
    function that does too many things, you can split it into smaller functions. If
    variable names are unclear, rename them.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, pretend you’re reviewing a peer’s code, and improve the AI’s code
    as if a peer wrote it. This will help you internalize good design principles.
    Over time, you’ll start prompting the AI in ways that yield cleaner code to begin
    with (because you’ll specify the style you want). Software maintainers (often
    working months or years later) will thank you, and you’ll prove that you’re thinking
    beyond just “make it run”⁠—you’re thinking like an engineer. Keeping things maintainable
    is exactly in that human-driven 30%, so make it your concern from the start of
    your career.
  prefs: []
  type: TYPE_NORMAL
- en: Develop Your Prompting and Tooling Skills (Wisely)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s no denying that “prompt engineering”—the skill of interacting with AI
    tools effectively—is useful. As a junior dev, you should absolutely learn how
    to phrase questions to AI, how to give it proper context, and how to iterate on
    prompts to improve the output ([Chapter 2](ch02.html#ch02_the_art_of_the_prompt_communicating_effectively_w_1752630042971067)
    of this book is a good place to start). These are new skills that can set you
    apart (many experienced devs are still figuring this out too!). However, remember
    that prompting well is often a proxy for understanding the problem well. If you
    find you can’t get the AI to do what you want, it might be because *you* need
    to clarify your own understanding first. Use that as a signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'One strategy is to outline a solution in plain English yourself before asking
    the AI to implement it. Also, experiment with different AI tools (Copilot, Claude,
    etc.) to see their strengths and weaknesses. The more fluent you are with these
    assistants, the more productive you can be—but never treat their output as infallible.
    Think of AI like a super-charged Stack Overflow: an aid, not an authority.'
  prefs: []
  type: TYPE_NORMAL
- en: You might even build small personal projects using AI to push your limits (“Can
    I build a simple web app with AI’s help?”). Doing so will teach you how to integrate
    AI into a development workflow, which is a great skill to bring into a team. Just
    balance it with periods of working without the net, as mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Seek Feedback and Mentorship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lastly, one durable skill that will accelerate your growth is the ability to
    seek out feedback and learn from others. An AI won’t get offended if you ignore
    its advice, but your human teammates and mentors are invaluable for your development—especially
    when it comes to soft skills, leadership, communication, and navigating office
    politics.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t hesitate to ask a senior developer why they prefer one solution over another,
    especially if it differs from what an AI suggested. Discuss design decisions and
    trade-offs with more experienced colleagues—these conversations reveal how seasoned
    engineers think, and that’s gold for you. In code reviews, be extra receptive
    to comments about your AI-written code. If a reviewer points out that “this function
    isn’t thread-safe” or “this approach will have scaling issues,” take the time
    to understand the root issue. These are exactly the kinds of things an AI might
    miss, and you want to learn to catch them. Over time, you’ll build a mental checklist
    of considerations.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, find opportunities to pair program (even if remotely). Perhaps
    you can “pair” with a senior who uses AI in their workflow—you’ll observe how
    they prompt the AI and how they correct it. But even more important, you’ll see
    how they communicate, lead discussions, and handle delicate team dynamics. Being
    open to feedback and actively asking for guidance will help you mature from doing
    tasks that an AI could do to performing the high-value tasks that only humans
    can do. In a sense, you’re trying to acquire the wisdom that usually comes with
    experience, as efficiently as you can. That makes you more than just another coder
    in the room—it makes you the kind of engineer teams are eager to keep and promote.
  prefs: []
  type: TYPE_NORMAL
- en: Communicate and Collaborate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building software is a team sport. AI doesn’t attend meetings (thank goodness)—humans
    still must talk to other humans to clarify requirements, discuss trade-offs, and
    coordinate work. Strong communication skills are as valuable as ever. Practice
    asking good questions and describing problems clearly (both to colleagues and
    to AI).
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, prompting an AI is itself a form of communication; it requires
    you to precisely express what you want. This overlaps with a core engineering
    skill: *requirements analysis*.^([3](ch04.html#id631)) If you can formulate a
    clear prompt or spec, it means you’ve thought through the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, sharing knowledge, writing documentation, and reviewing others’
    code are collaborative skills that AI cannot replace. In the future, as developers
    work “with” AI, the human-to-human collaboration in a team—making sure the right
    problems are being solved—stays vital. One emerging trend is that developers may
    focus more on high-level design discussions (often with AI as a participant) and
    on coordinating tasks, essentially taking on more of a conductor role. Communication
    and leadership skills will serve you well in that conductor’s seat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shift Your Mindset: From Consuming to Creating'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s worth noting a mindset shift for juniors in the AI era: you need to move
    from just *consuming solutions to creating understanding*. In the past, you might
    have struggled through documentation to eventually write a feature; now an AI
    can hand you a solution on a platter. If you simply consume it (copy-paste and
    move on), you haven’t grown much.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, use each AI-given solution as a learning case. Dissect it, experiment
    with it, and consider how you might have arrived at it yourself. By treating AI
    outputs not as answers to end all questions but as interactive learning material,
    you ensure that you⁠—the human—are continuously leveling up. This way, rather
    than replacing your growth, AI accelerates it.
  prefs: []
  type: TYPE_NORMAL
- en: Many experts believe that while AI might reduce the need for large teams of
    junior “coder-grinders,” it also *raises the bar* for what it means to be a junior
    developer. The role is shifting to someone who can work effectively with AI and
    quickly climb the value chain. If you adopt the habits discussed in this section,
    you’ll distinguish yourself as a junior developer who doesn’t just bring what
    an AI could bring (any company can get that via a subscription) but who brings
    insight, reliability, and continuous improvement—traits of a future senior developer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Next Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To thrive in an AI-enhanced development world, engineers at all levels should
    double down on the enduring skills and practices that AI cannot (yet) replicate.
    These capabilities will remain crucial no matter how advanced our tools become.
    In particular, focus on these areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Strengthening your system design and architecture expertise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practicing systems thinking and maintaining a contextual understanding of the
    big picture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Honing your skills in critical thinking, problem solving, and foresight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building expertise in specialized domains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing code, testing, debugging, and quality assurance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving your communication and collaboration skills
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapting to change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuously learning, keeping your fundamentals strong while gaining new skills
    and updating your knowledge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These skills form the human advantage in software engineering. They are durable
    because they don’t expire with the next framework or tooling change; if anything,
    AI’s rise makes them more pronounced. Simon Willison has [argued that](https://oreil.ly/5F3O7)
    AI assistance actually makes strong programming skills *more* valuable, not less,
    because those with expertise can leverage the tools to far greater effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'A powerful machine in unskilled hands can be dangerous or wasted, but in capable
    hands it’s transformative. In the AI era, an experienced engineer is like a seasoned
    pilot with a new advanced copilot: the journey can go faster and farther, but
    the pilot must still navigate the storms and ensure a safe landing.'
  prefs: []
  type: TYPE_NORMAL
- en: Software engineering has always been a field of continuous change—from assembly
    language to high-level programming, from on-prem servers to the cloud, and now
    from manual coding to AI-assisted development. Each leap has automated some aspect
    of programming, yet each time, developers have adapted and found even more to
    do. In response to a Tim O’Reilly [note](https://oreil.ly/BYrNh), one HN commenter
    [remarked](https://oreil.ly/OewGO) that past innovations “almost always resulted
    in more work, more growth, more opportunities” for developers. The rise of AI
    is no different. Rather than making developers irrelevant, it is reshaping the
    skill set needed to succeed. The mundane 70% of coding is getting easier; the
    challenging 30% becomes an even larger part of our value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To maximize that human 30%, focus on the timeless engineering skills: understanding
    problems deeply, designing clean solutions, scrutinizing code for quality, and
    considering the users and context. Experienced programmers are gaining more from
    AI because they know how to guide it and what to do when it falters. Those who
    combine these skills with AI tools will outperform those who have only one or
    the other. In fact, the [consensus emerging among experts](https://oreil.ly/5gfvc)
    is that AI is a tool for the skilled: that “LLMs are power tools meant for power
    users.” This means the onus is on each of us to become that “power user”—to cultivate
    the expertise that lets us wield these new tools effectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the craft of software engineering is more than writing code that
    works. It’s about writing code that *works well*—in a real-world environment,
    over time, and under evolving requirements. Today’s AI models can assist with
    writing code but cannot yet ensure the code works well in all those dimensions.
    That’s the developer’s job.
  prefs: []
  type: TYPE_NORMAL
- en: By doubling down on the skills just outlined, senior developers can continue
    to lead and innovate, midlevel developers can deepen their expertise, and junior
    developers can accelerate their journey to mastery. AI will handle more and more
    of the routine, but your creativity, intuition, and thoughtful engineering will
    turn that raw output into something truly valuable. AI is a powerful tool, but
    it’s all about how we use it. Good engineering practices, human judgment, and
    a willingness to learn will remain essential.
  prefs: []
  type: TYPE_NORMAL
- en: In practical terms, whether you are pair programming with an “eager junior”
    AI that writes your functions or reviewing a diff full of AI-generated code, never
    forget to apply your uniquely human lens. Ask, Does this solve the *right* problem?
    Will others be able to understand and maintain this? What are the risks and edge
    cases? Those questions are your responsibility. The future of programming will
    indeed involve less typing every semicolon by hand and more directing and curating—but
    it will still require developers at the helm who have the wisdom to do it right.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, great software engineering has always been about problem solving,
    not just code slinging. AI doesn’t change that: it simply challenges us to elevate
    our problem solving to the next level. Embrace that challenge, and you’ll thrive
    in this new chapter of our industry.'
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch04.html#id534-marker)) This chapter is based on two essays I first
    published on my Substack newsletter: Addy Osmani, [“Beyond the 70%: Maximizing
    the Human 30% of AI-Assisted Coding”](https://oreil.ly/PMFsp), *Elevate with Addy
    Osmani*, March 13, 2025; and Addy Osmani, [“Future-Proofing Your Software Engineering
    Career”](https://oreil.ly/1EoW8), *Elevate with Addy Osmani*, December 23, 2024\.'
  prefs: []
  type: TYPE_NORMAL
- en: '^([2](ch04.html#id574-marker)) To learn more about systems thinking, check
    out Donella H. Meadows, *Thinking in Systems: A Primer*, 2nd edition (Rizzoli,
    2008); and Peter M. Senge, *The Fifth Discipline: The Art and Practice of the
    Learning Organization* (Crown, 2010).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch04.html#id631-marker)) For more on this topic, see Mark Richards and
    Neal Ford, *Fundamentals of Software Architecture*, 2nd edition (O’Reilly, 2025);
    and Mark Richards, Neal Ford, and Raju Gandhi, *Head First Software Architecture*
    (O’Reilly, 2024).
  prefs: []
  type: TYPE_NORMAL
