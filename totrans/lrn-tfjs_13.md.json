["```py\n[\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n],\n[\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n],\n```", "```py\nconstpixelShift=async(inputTensor,mutations=[])=>{// Add 1px white padding to height and width\nconstpadded=inputTensor.pad(![1](assets/1.png)[[1,1],[1,1],],1)constcutSize=inputTensor.shapefor(leth=0;h<3;h++){for(letw=0;w<3;w++){![2](assets/2.png)mutations.push(padded.slice([h,w],cutSize))![3](assets/3.png)}}padded.dispose()returnmutations}\n```", "```py\n// Creates combinations take any two from array // (like Python itertools.combinations) constcombos=async(tensorArray)=>{conststartSize=tensorArray.lengthfor(leti=0;i<startSize-1;i++){for(letj=i+1;j<startSize;j++){constoverlay=tf.tidy(()=>{returntf.where(![1](assets/1.png)tf.less(tensorArray[i],tensorArray[j]),![2](assets/2.png)tensorArray[i],![3](assets/3.png)tensorArray[j]![4](assets/4.png))})tensorArray.push(overlay)}}}\n```", "```py\nconst createDataObject = async () => {\n  const inDice = require('./dice.json').data\n  const diceData = {}\n  // Create new data from each die\n  for (let idx = 0; idx < inDice.length; idx++) {\n    const die = inDice[idx]\n    const imgTensor = tf.tensor(die)\n    // Convert this single die into 200+ variations\n    const results = await runAugmentation(imgTensor, idx)\n    console.log('Unique Results:', idx, results.shape)\n    // Store results\n    diceData[idx] = results.arraySync()\n    // clean\n    tf.dispose([results, imgTensor])\n  }\n\n  const jsonString = JSON.stringify(diceData)\n  fs.writeFile('dice_data.json', jsonString, (err) => {\n    if (err) throw err\n    console.log('Data written to file')\n  })\n}\n```", "```py\nconstdiceImages=[].concat(![1](assets/1.png)diceData['0'],diceData['1'],diceData['2'],diceData['3'],diceData['4'],diceData['5'],diceData['6'],diceData['7'],diceData['8'],)// Now the answers to their corresponding index constanswers=[].concat(newArray(diceData['0'].length).fill(0),![2](assets/2.png)newArray(diceData['1'].length).fill(1),newArray(diceData['2'].length).fill(2),newArray(diceData['3'].length).fill(3),newArray(diceData['4'].length).fill(4),newArray(diceData['5'].length).fill(5),newArray(diceData['6'].length).fill(6),newArray(diceData['7'].length).fill(7),newArray(diceData['8'].length).fill(8),)// Randomize these two sets together tf.util.shuffleCombo(diceImages,answers)![3](assets/3.png)\n```", "```py\nconsttrainX=tf.tensor(diceImages).expandDims(3)![1](assets/1.png)consttrainY=tf.oneHot(answers,numOptions)![2](assets/2.png)\n```", "```py\nconst model = tf.sequential()\nmodel.add(tf.layers.flatten({ inputShape }))\nmodel.add(tf.layers.dense({\n    units: 64,\n    activation: 'relu',\n}))\nmodel.add(tf.layers.dense({\n    units: 8,\n    activation: 'relu',\n}))\nmodel.add(tf.layers.dense({\n    units: 9,\n    kernelInitializer: 'varianceScaling',\n    activation: 'softmax',\n}))\n```", "```py\nconst dicify = async () => {\n  const modelPath = '/dice-model/model.json'\n  const dModel = await tf.loadLayersModel(modelPath)\n\n  const grid = await cutData(\"input\")\n  const predictions = await predictResults(dModel, grid)\n  await displayPredictions(predictions)\n\n  tf.dispose([dModel, predictions])\n  tf.dispose(grid)\n}\n```", "```py\nconstnumDice=32constpreSize=numDice*10constcutData=async(id)=>{constimg=document.getElementById(id)constimgTensor=tf.browser.fromPixels(img,1)![1](assets/1.png)constresized=tf.image.resizeNearestNeighbor(![2](assets/2.png)imgTensor,[preSize,preSize])constcutSize=numDiceconstheightCuts=tf.split(resized,cutSize)![3](assets/3.png)constgrid=heightCuts.map((sliver)=>![4](assets/4.png)tf.split(sliver,cutSize,1))returngrid}\n```", "```py\nconstdisplayPredictions=async(answers)=>{tf.tidy(()=>{constdiceTensors=diceData.map(![1](assets/1.png)(dt)=>tf.tensor(dt))const{indices}=tf.topk(answers)constanswerIndices=indices.dataSync()consttColumns=[]for(lety=0;y<numDice;y++){consttRow=[]for(letx=0;x<numDice;x++){constcurIndex=y*numDice+x![2](assets/2.png)tRow.push(diceTensors[answerIndices[curIndex]])}constoneRow=tf.concat(tRow,1)![3](assets/3.png)tColumns.push(oneRow)}constdiceConstruct=tf.concat(tColumns)![4](assets/4.png)// Print the reconstruction to the canvas\nconstcan=document.getElementById('display')tf.browser.toPixels(diceConstruct,can)![5](assets/5.png)})}\n```"]