- en: 7 Accelerating and improving UI automation using AI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 使用AI加速和改进UI自动化
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: How to create UI automation rapidly using GitHub Copilot and ChatGPT
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用GitHub Copilot和ChatGPT快速创建UI自动化
- en: How to improve UI automation rapidly using GitHub Copilot and ChatGPT
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用GitHub Copilot和ChatGPT快速提高UI自动化
- en: If there is one area in the software testing industry that has garnered the
    most attention regarding the use of AI tools, it’s UI automation. As large language
    models (LLMs) began capturing attention, people in the testing world quickly focused
    on how UI automated checks could be easily generated through tools such as Copilot
    and ChatGPT. The possibilities and ideas around using AI tools for UI automation
    have been expanding rapidly. But although the enthusiasm for these tools is significant,
    and tool vendors and automators alike rush to use AI, we must be mindful of where
    and how AI can be of use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在软件测试行业中有一个领域在AI工具的使用方面获得了最多的关注，那就是UI自动化。随着大型语言模型（LLMs）开始吸引人们的注意，测试领域的人们迅速关注了如何通过Copilot和ChatGPT等工具轻松生成UI自动化检查。围绕使用AI工具进行UI自动化的可能性和想法正在迅速扩展。尽管对这些工具的热情很高，工具供应商和自动化人员都急于使用AI，但我们必须注意AI在哪里以及如何有用。
- en: Success with AI in creating automation is as much about knowing *when* to use
    AI tooling as it is about knowing *how* to use it. For this reason, this chapter
    focuses on how to break down the process of creating and maintaining automated
    checks and discover where AI tools can speed up our processes, while ensuring
    that we still deliver valuable automation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用AI创建自动化方面取得成功，不仅在于知道*何时*使用AI工具，还在于知道*如何*使用它。因此，本章重点介绍如何分解创建和维护自动化检查的过程，并发现AI工具如何加快我们的流程，同时确保我们仍然提供有价值的自动化。
- en: 7.1 Rapidly creating UI automation
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 快速创建UI自动化
- en: Head to ChatGPT and ask it to generate a Selenium test in Java that automates
    a login page, and it will happily oblige. This might seem like an effective path
    to take, but let’s take a look at a brief example of this process and see what
    happens. For the prompt, we can use
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 前往ChatGPT并要求它生成一个Java Selenium测试，用于自动化登录页面，它会欣然从命。这看起来可能是一条有效的途径，但让我们简要看看这个过程的一个例子，看看会发生什么。对于提示，我们可以使用
- en: '|'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Assuming the role of a test automator, create an automated test using Selenium
    and Java that automates and validates the log in process for an application |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 假设测试自动化者的角色，使用Selenium和Java创建一个自动化测试，用于自动化和验证应用程序的登录过程 |'
- en: It will return a code example such as
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回一个代码示例，例如
- en: '|'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The code looks correct and would likely compile. But if we were to bring this
    code into our automation framework, we should ask ourselves, “How much of this
    would we need to change to make it work with our product under test?” Chances
    are we would need to
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来是正确的，并且很可能会编译。但如果我们要把这段代码带入我们的自动化框架，我们应该问自己，“我们需要修改多少才能让它与我们的测试产品一起工作？”可能性很大，我们需要
- en: Remove the `Driver` instantiation to use our own driver factory.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除`Driver`实例化以使用我们自己的驱动器工厂。
- en: Point the check to the correct application by updating `driver.get`.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过更新`driver.get`将检查指向正确的应用程序。
- en: Move the `findElements` methods to relevant Page objects.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`findElements`方法移动到相关的页面对象中。
- en: Update the selectors so that they are using the ones that align with our product.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新选择器，以便它们使用与我们的产品一致的选择器。
- en: Update the assertion to meet our assumptions.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新断言以符合我们的假设。
- en: Before we know it, we’ve ended up replacing nearly all the code suggested by
    ChatGPT, which doesn’t feel like an efficient use of our time. This is because
    although tools such as ChatGPT and Copilot can rapidly generate code on demand,
    they lack the context of our systems. That is, if we ask these tools to create
    our automated checks with little input provided, the result will be code that
    requires extensive rework. Instead, we want to take a more symbiotic approach,
    using AI tools in targeted ways to help us with specific tasks in creating automated
    UI checks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没意识到，我们几乎已经用ChatGPT建议的所有代码替换了，这并不感觉像是我们时间的高效利用。这是因为尽管ChatGPT和Copilot等工具可以快速按需生成代码，但它们缺乏我们系统的上下文。也就是说，如果我们让这些工具在提供很少输入的情况下创建我们的自动化检查，结果将是需要大量重写的代码。相反，我们希望采取一种更共生的方法，有针对性地使用AI工具来帮助我们完成创建自动化UI检查的特定任务。
- en: Consider the visualization in figure 7.1, which breaks down the various components
    included in a common automated check that works on the UI layer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑图7.1中的可视化，它分解了包含在常见的基于UI层的自动化检查中的各种组件。
- en: As we can see, there are many moving parts—from the framework itself, which
    handles the dependencies and reporting of automated checks, to the various activities
    that an automated check carries out to create state, interact with a UI, and assert
    against expectations. Each of these parts can be guided using AI, so, rather than
    attempting to rely on an AI to create everything at once, we focus on specific
    tasks throughout building and maintaining of our automated check and use LLMs
    to speed up the process.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有许多动态部分——从处理自动化检查的依赖关系和报告的框架本身，到自动化检查执行的各种活动，以创建状态、与UI交互以及断言期望。这些部分都可以通过AI进行指导，因此，我们不是试图依赖AI一次性创建所有内容，而是在构建和维护自动化检查的过程中专注于具体任务，并使用LLMs来加速这个过程。
- en: AI compared to record and playback tools
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与记录和回放工具相比，AI
- en: A valid question to ask is how the use of AI differs from record and playback
    tools and their ability to record our actions and convert them into code. If we
    were to use LLMs to generate automated checks, then the difference wouldn’t be
    great. In fact, record and playback tools would likely be better because they
    are interacting with the system and implicitly learning about the product’s context
    and rules during recording.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得提出的问题是，AI的使用与记录和回放工具及其记录我们的动作并将它们转换为代码的能力有何不同。如果我们使用LLMs来生成自动化检查，那么这种差异不会很大。事实上，记录和回放工具可能会更好，因为它们在与系统交互时，在记录过程中隐式地学习产品的上下文和规则。
- en: However, one limitation of record and playback is when they encounter more complex
    frameworks that will be arranged using approaches such as Page Object and Screenplay
    patterns to make them more maintainable. Record and playback tools tend to output
    resulting code as a script run by itself, separate from others. When that script
    needs to be integrated into the framework, we will likely need to rework and reorganize
    our initial script dramatically, which brings us back to the initial problem—slow
    progress in creating automated UI checks.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，记录和回放的一个局限性在于，当它们遇到更复杂的框架时，这些框架将使用诸如页面对象和剧本模式等方法进行安排，以使其更易于维护。记录和回放工具往往会将生成的代码作为独立运行的脚本输出，与其他代码分离。当这个脚本需要集成到框架中时，我们可能需要大幅重写和重组我们的初始脚本，这又把我们带回了最初的问题——自动化UI检查的创建进度缓慢。
- en: What this chapter proposes is that we use LLMs in very specific situations,
    targeting specific actions. If we want to rapidly create Page objects, then an
    LLM can help us with that task—its output can be quickly plugged into a wider
    framework with minimum rework.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提出的是，我们在非常具体的情况下使用LLMs，针对特定的动作。如果我们想快速创建页面对象，LLM可以帮助我们完成这项任务——它的输出可以快速集成到一个更广泛的框架中，最小化重写。
- en: '![](../../OEBPS/Images/CH07_F01_Winteringham2.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F01_Winteringham2.png)'
- en: Figure 7.1 A visual representation of the component parts of an automated UI
    check
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 自动化UI检查组件部分的视觉表示
- en: To demonstrate this process, let’s take a look at how we can use tools such
    as Copilot and ChatGPT in our automation workflow, selecting specific actions
    that AI tools can assist with, by building an automated check for the website
    [https://automationintesting.online](https://automationintesting.online), which
    is a mock bed-and-breakfast booking site that can be used to practice various
    testing and automation activities.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个过程，让我们看看我们如何可以在自动化工作流程中使用诸如Copilot和ChatGPT等工具，通过构建针对网站[https://automationintesting.online](https://automationintesting.online)的自动化检查来选择AI工具可以协助的具体动作，这是一个模拟的民宿预订网站，可以用来练习各种测试和自动化活动。
- en: 'In this example, we check whether a message is shown in the admin section of
    the website. To do this, we’ll need to codify the following steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们检查消息是否显示在网站的管理员部分。为此，我们需要将以下步骤编码化：
- en: Launch a browser.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动浏览器。
- en: Head to [automationintesting.online](https://automationintesting.online).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[automationintesting.online](https://automationintesting.online)。
- en: Complete the Contact Us form on the home page.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主页面上完成联系我们表单。
- en: Head to the Admin section of the site and log in.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往网站的管理员部分并登录。
- en: Load the Message section and confirm that the created message appears.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载消息部分并确认创建的消息出现。
- en: This process is summarized in figure 7.2.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程在图7.2中进行了总结。
- en: '![](../../OEBPS/Images/CH07_F02_Winteringham2.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F02_Winteringham2.png)'
- en: Figure 7.2 Visual representation of the automated UI check that will be created
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 自动化UI检查的视觉表示
- en: Although the example itself is nothing spectacular, what we’ll learn is that
    we can accelerate our work using AI tools as we complete each step—so let’s begin.
    For reference, you can review the code that was generated for this example on
    GitHub ([https://mng.bz/4pXB](https://mng.bz/4pXB)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子本身并不引人注目，但我们将了解到，我们可以通过使用AI工具来加速我们的工作，每完成一步——让我们开始吧。为了参考，你可以查看GitHub上为这个例子生成的代码（[https://mng.bz/4pXB](https://mng.bz/4pXB)）。
- en: Setting up Copilot
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Copilot
- en: This chapter assumes that you have installed and configured the Copilot plugin
    within your IDE. If you haven’t already completed the setup process, you can find
    installation instructions in appendix B.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你已经在你IDE中安装并配置了Copilot插件。如果你还没有完成设置过程，你可以在附录B中找到安装说明。
- en: Activity 7.1
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 活动7.1
- en: Follow the steps in this chapter to see whether you can generate a similar automated
    check. As always, remember that the output that comes from ChatGPT and Copilot
    may differ from what has been captured in the following example.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章的步骤进行，看看你是否能生成类似的自动检查。像往常一样，请记住，来自ChatGPT和Copilot的输出可能与以下示例中捕获的输出不同。
- en: 7.1.1 Setting up a project
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 设置项目
- en: 'We’ll carry out the example in this section in Java. This is a useful language
    to demonstrate the value of using AI tools, because Java is known for its reliance
    on boilerplate code (a great place in which LLMs can help build for us). For our
    first step, we need to create a new Maven project and, once the project is created,
    add the following dependencies into our `pom.xml` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中使用Java进行示例。这是一种演示使用AI工具价值的有用语言，因为Java以其依赖模板代码（LLMs可以帮助我们构建的好地方）而闻名。在我们的第一步，我们需要创建一个新的Maven项目，一旦项目创建完成，就将以下依赖项添加到我们的`pom.xml`文件中：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we have everything we need to start developing our automated check.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了开始开发我们的自动检查所需的一切。
- en: With our dependencies in place, we can create the necessary packages—`com.example`
    and our `Test` class—which we’ll name `MessageTest`. From here, we can begin to
    use Copilot to build our automated check, but we need to prompt Copilot with some
    information to begin the process. So first we add in a `WebDriver` variable inside
    our `MessageTest` class
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的依赖项就绪后，我们可以创建必要的包——`com.example`和我们的`Test`类，我们将它命名为`MessageTest`。从这里，我们可以开始使用Copilot构建我们的自动检查，但我们需要向Copilot提供一些信息以开始这个过程。所以首先我们在`MessageTest`类中添加一个`WebDriver`变量
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'followed by the code comment:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着是代码注释：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The combination of code and comment acts sufficiently as a prompt to trigger
    the following response from Copilot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 代码和注释的组合足以作为提示来触发Copilot的以下响应：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is a good start, but it’s missing the driver instantiation and `BeforeAll`
    hook, which we can add to the next line below the `WebDriverManager` call:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好的开始，但它缺少了驱动程序实例化和`BeforeAll`钩子，我们可以在`WebDriverManager`调用下面的下一行添加：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'which gives us the following Before hook:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下`Before`钩子：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To tweak or not to tweak prompts: Making the efficient choice'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 是否调整提示：做出高效的选择
- en: Another observation about working with prompts to generate desired output is
    that it can be tempting to want to tweak a prompt multiple times to produce the
    right output, which can be time consuming. In the previous example, the code comment
    was likely not clear enough for Copilot to produce the complete code snippet we
    required. The options then are to improve the prompt or add the missing sections
    of code that are required. In this context, adding the required code made sense.
    I knew what I required, and spending time tweaking the prompt would have been
    wasteful. However, if my knowledge of what I wanted was shallower, then I might
    have chosen to tweak the prompt further. Efficiency is created by being aware
    of what is the right choice to make at a given time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用提示生成所需输出的另一个观察是，可能会诱使人们多次调整提示以产生正确的输出，这可能会很耗时。在先前的例子中，代码注释可能对Copilot来说不够清晰，无法生成我们所需的完整代码片段。那么，可以选择改进提示或添加所需的代码部分。在这种情况下，添加所需的代码是有意义的。我知道我需要什么，花费时间调整提示将是浪费的。然而，如果我对想要的东西的了解较浅，我可能会选择进一步调整提示。效率是通过意识到在特定时刻做出正确选择而产生的。
- en: We have our `BeforeAll` hook in place, so next we want to create a teardown
    hook, which we can do by adding the annotation
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了`BeforeAll`钩子，所以接下来我们想要创建一个拆卸钩子，我们可以通过添加以下注释来实现：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: prompting Copilot to return
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 提示Copilot返回
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our second prompt is arguably more accurate than the first one because we are
    beginning to flesh out the context in which Copilot can be prompted. The more
    we add to our codebase, the more potential Copilot has to accurately add in what
    we want. Finally, to verify that everything is working, let’s add in a bare-bones
    `@Test` to ensure that everything is running:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个提示词可能比第一个更准确，因为我们开始具体化Copilot可以提示的上下文。我们添加到我们的代码库越多，Copilot就越有可能准确地添加我们想要的。最后，为了验证一切是否正常工作，让我们添加一个裸骨的`@Test`来确保一切都在运行：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So far, so good. We’ve set up our project and our initial test with the support
    of Copilot. We’ve also observed that, initially, Copilot is lacking details to
    help recommend the correct lines of code. But as we develop, we’ll start to observe
    its accuracy improve. This is a great start—now let’s see how tools such as ChatGPT
    can help speed up our work even more.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。我们在Copilot的支持下设置了我们的项目以及初始测试。我们还观察到，最初，Copilot缺乏细节来帮助推荐正确的代码行。但随着我们的发展，我们将开始观察到其准确性的提高。这是一个很好的开始——现在让我们看看工具如ChatGPT如何帮助我们更快地完成工作。
- en: 7.1.2 Creating our initial check with ChatGPT support
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 在ChatGPT的支持下创建我们的初始检查
- en: With the framework in place, we can turn our attention to completing the Contact
    Us form on the home page. To help contextualize what we’ll be working with, see
    figure 7.3.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架就绪后，我们可以将注意力转向完成主页上的“联系我们”表单。为了帮助具体化我们将要处理的内容，请参阅图7.3。
- en: '![](../../OEBPS/Images/CH07_F03_Winteringham2.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F03_Winteringham2.png)'
- en: Figure 7.3 The Contact Us form on the website under test
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 测试网站上的“联系我们”表单
- en: The figure shows multiple form fields to complete and a Submit button, all of
    which we will need to codify in our automated check. To do this, we’ll need to
    create a Page object that captures each of the elements, which we’ll use in our
    check to populate and submit the form. This process is a laborious one (and one
    that I personally find to be time consuming and boring, which are the types of
    emotional triggers explored in chapter 1). So, how can we speed up the process
    of creating Page objects? We could use Copilot to help us author our classes,
    but the process of identifying each CSS selector for each element has the potential
    to take up a lot of time. Instead, let’s take a look at how we could use a prompt
    in ChatGPT to rapidly create our Page object for us.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了需要完成的多个表单字段和一个提交按钮，所有这些我们都需要在我们的自动化检查中进行编码。为此，我们需要创建一个页面对象来捕获每个元素，我们将使用它来填充和提交表单。这个过程是费时的（而且我个人觉得这个过程既耗时又无聊，这是第一章中探讨的情感触发类型）。那么，我们如何加快创建页面对象的过程呢？我们可以使用Copilot来帮助我们编写类，但识别每个元素的每个CSS选择器的过程可能会占用大量时间。相反，让我们看看我们如何使用ChatGPT中的提示来快速创建我们的页面对象。
- en: 'First, let’s take a look at a prompt that can be used to trigger ChatGPT to
    generate our Page object (you can copy and paste the prompt into ChatGPT: [https://mng.bz/QVpm](https://mng.bz/QVpm)).
    We set out instructions with the delimiter tactic:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看一个可以触发ChatGPT生成我们的页面对象的提示词（你可以将提示词复制并粘贴到ChatGPT中：[https://mng.bz/QVpm](https://mng.bz/QVpm)）。我们使用分隔策略设置了指令：
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| You are an expert Java Developer. Convert the HTML delimited by three hashes
    into a Java Selenium Page object using the `PageFactory` library and `@FindBy`
    annotations. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 你是一位Java开发专家。使用`PageFactory`库和`@FindBy`注解，将三个井号分隔的HTML转换为Java Selenium页面对象。
    |'
- en: 'We provide HTML in the delimited section:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在分隔部分提供HTML：
- en: '|'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Breaking down the prompt, we can observe that it takes this form:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 分析提示词，我们可以观察到它采取以下形式：
- en: Clear instructions at the start, informing ChatGPT of what we want to achieve
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开头的清晰指令，告知ChatGPT我们想要实现的目标
- en: A list of constraints that specifies clear instructions for what we expect from
    ChatGPT, stating which libraries and methods we’d like to explicitly use when
    creating our Page object
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列约束，明确指出我们对ChatGPT的期望，说明在创建我们的页面对象时我们希望明确使用哪些库和方法
- en: 'To create the Page object, we take the prompt we have just explored and add
    the HTML from our Contact form to the bottom before pasting it into ChatGPT. Again,
    feel free to use the already created prompt available on GitHub at [https://mng.bz/QVpm](https://mng.bz/QVpm):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建页面对象，我们将刚刚探索的提示词添加到我们的联系表单HTML的底部，然后将其粘贴到ChatGPT中。再次提醒，你可以使用GitHub上已经创建的提示词，链接为[https://mng.bz/QVpm](https://mng.bz/QVpm)：
- en: '|'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![管理页面Logo](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Entering this prompt into ChatGPT yields the following code for our Page object:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将此提示输入ChatGPT，得到以下用于我们的页面对象的代码：
- en: '|'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![OpenAI Logo](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: ChatGPT has not only successfully created a class that includes all the necessary
    methods required to complete and submit the contact form, but this was also done
    rapidly after a single prompt. In this example, the class was quite small, but
    regular Page objects can be pretty large. The time taken to write and maintain
    Page objects is compounded by the amount we require. So, by using ChatGPT to rapidly
    generate our code for us, we can continue developing our automated check faster.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT不仅成功创建了一个包含完成和提交联系表单所需所有必要方法的类，而且这是在单个提示后迅速完成的。在这个例子中，类相当小，但常规页面对象可能相当大。编写和维护页面对象所需的时间会随着我们所需数量的增加而增加。因此，通过使用ChatGPT快速生成我们的代码，我们可以更快地开发我们的自动化检查。
- en: Testability and AI tools
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 测试性和AI工具
- en: Even with AI tools, the testability of a product influences a tool’s effectiveness.
    The way in which the HTML for the Contact Us form has been created can be said
    to have a high *testability.* The HTML is semantically correct, and it contains
    clear, stable HTML attributes in the `input` and `textarea` elements that ChatGPT
    can predict to put into the created class. If, however, the HTML we are working
    with requires us to identify more complex selectors, perhaps due to autogenerated
    IDs or a lack of HTML elements, then the performance of our prompt may not be
    as effective, requiring us to update and tweak our Page object to better suit
    our needs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有AI工具，产品的可测试性也会影响工具的有效性。创建“联系我们”表单的HTML方式可以说具有很高的*可测试性*。HTML是语义正确的，并且在`input`和`textarea`元素中包含清晰的、稳定的HTML属性，ChatGPT可以预测并将其放入创建的类中。然而，如果我们正在处理的HTML需要我们识别更复杂的选择器，可能是因为自动生成的ID或HTML元素的缺乏，那么我们的提示的性能可能不会那么有效，需要我们更新和调整我们的页面对象以更好地满足我们的需求。
- en: 'With our Page object created, we can head back to `MessageTest` and tab through
    Copilot’s suggestions to create our necessary Contact Us form-filling code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建好页面对象后，我们可以回到`MessageTest`并按Tab键浏览Copilot的建议来创建我们需要的“联系我们”表单填写代码：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Copilot has read our object and helped us map out filling in the form. But
    although it can read the methods that exist in `ContactFormPage` and predict what’s
    next, it lacks context on validation rules for each form field, which affects
    the test data it creates. Unlike in the previous chapter, in which test data was
    accurately set based on expectations, the data returned is generic and will cause
    problems. For example, the validation rule set for the Phone Number field requires
    11 or more digits to be entered, so our predicted test data would cause our automated
    test to fail. Therefore, let’s update the `enterPhone` parameter with data that
    will pass the phone number validation:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot读取了我们的对象并帮助我们绘制了填写表单的流程图。尽管它可以读取`ContactFormPage`中存在的函数并预测下一步，但它缺乏对每个表单字段验证规则的上下文，这影响了它创建的测试数据。与上一章不同，其中测试数据是基于预期准确设置的，返回的数据是通用的，并可能导致问题。例如，为电话号码字段设置的验证规则要求输入11位或更多的数字，因此我们的预测测试数据会导致我们的自动化测试失败。因此，让我们更新`enterPhone`参数，使用将通过电话号码验证的数据：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With our message created, we now want to log in, which can be achieved by following
    a pattern similar to the one we have just followed. First, we create the necessary
    code to head to the Admin page:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建好消息后，现在想要登录，可以通过遵循与我们刚刚遵循的类似模式来实现。首先，我们创建必要的代码以跳转到管理页面：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, returning to our current chat with ChatGPT, we can reuse our earlier
    prompt to create a Page object for the admin login page, this time simply referring
    to the original prompt and providing it with new HTML to generate our class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，回到我们与ChatGPT的当前聊天中，我们可以重用我们之前的提示来为管理登录页面创建一个页面对象，这次只需简单地引用原始提示并提供新的HTML来生成我们的类：
- en: '|'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![管理页面Logo](../../OEBPS/Images/logo-MW.png)'
- en: '| Follow the previous prompt again, but this time use the following HTML:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '| 再次遵循之前的提示，但这次使用以下HTML：'
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'This yields the following `LoginPage` code to add to our project:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们项目添加了以下`LoginPage`代码：
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![OpenAI Logo](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Next, we create the `LoginPage` class in our code, fixing our missing imports,
    and then return to `MessageTest` and use Copilot to create our login step by tabbing
    through suggestions to produce the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在代码中创建 `LoginPage` 类，修复我们的缺失导入，然后回到 `MessageTest` 并使用 Copilot 通过按提示创建以下登录步骤：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we can execute one more loop of using ChatGPT and Copilot to complete
    our automated test by first adding the necessary code to navigate to the message
    page:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以再执行一次使用 ChatGPT 和 Copilot 完成自动化测试的循环，首先添加必要的代码以导航到消息页面：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we create our final Page object, this time tweaking our prompt to ChatGPT
    to create a method that returns a count of messages:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建我们的最终页面对象，这次调整我们的提示以让 ChatGPT 创建一个返回消息计数的函数：
- en: '|'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Follow the prompt again, this time I require a method that returns me the
    count of messages:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '| 再次遵循提示，这次我需要一个返回消息计数的函数：'
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'It returns the following `MessagePage` class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回以下 `MessagePage` 类：
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Like before, we create a `MessagePage` class in our codebase, fix our imports,
    and return to `MessageTest` to let Copilot predict the following code to complete
    our automated check:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们在代码库中创建一个 `MessagePage` 类，修复我们的导入，然后回到 `MessageTest` 让 Copilot 预测以下代码以完成我们的自动化检查：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 7.1.3 Filling in gaps from generated code
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 从生成的代码中填补空白
- en: 'This completes our automated check, but if we were to run this code, it would
    likely result in the failure of the automated check. The failure occurs because,
    to get the message count, we must wait for the count to load, which is missing
    from our automated check. Although this failure differs from the incorrect test
    data being added by Copilot we experienced earlier, the reason for our current
    problem is similar. ChatGPT predicts the code we require based on what the prompt
    is asking and the HTML provided. It lacks the ability to understand what parts
    of our system may require waits in place to prevent an automated check from failing.
    However, we can resolve this problem by returning to ChatGPT and submitting the
    prompt:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们的自动化检查，但如果运行这段代码，很可能会导致自动化检查失败。失败的原因是我们必须等待消息计数加载，而我们的自动化检查中缺少这一步骤。尽管这种失败与我们之前遇到的
    Copilot 添加的错误测试数据不同，但我们当前问题的原因相似。ChatGPT 根据提示内容和提供的 HTML 预测我们需要的代码。它缺乏理解我们系统哪些部分可能需要等待以防止自动化检查失败的能力。然而，我们可以通过回到
    ChatGPT 并提交以下提示来解决这个问题：
- en: '|'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Can you improve the `MessagePage` class and have it wait for the message
    list to load |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 你能改进 `MessagePage` 类，使其等待消息列表加载吗 |'
- en: 'ChatGPT responds with an updated version of `MessagePage`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 响应了一个更新版本的 `MessagePage`：
- en: '|'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'This is a step forward in improving our automated check, but it also demonstrates
    again how ChatGPT is trained on older versions of libraries and APIs. If we copy
    this code over to our check, we’ll see that `WebDriverWait` makes errors because
    it no longer takes integers—a change that came in after ChatGPT was trained on
    Selenium material. So, we need to update `WebDriverWait` to take a `Duration`
    parameter instead:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在提高我们的自动化检查方面的一个进步，但也再次展示了 ChatGPT 是如何基于较旧的库和 API 版本进行训练的。如果我们把这段代码复制到我们的检查中，我们会看到
    `WebDriverWait` 出现错误，因为它不再接受整数——这是在 ChatGPT 接受 Selenium 材料训练之后发生的改变。因此，我们需要将 `WebDriverWait`
    更新为接受 `Duration` 参数：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, to improve the feedback we get from our automated test, we update
    the assertion suggested by Copilot to a more informative one:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了提高我们从自动化测试中获得的反馈，我们将 Copilot 提出的断言更新为一个更具有信息量的版本：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With all this in place, assuming there are no extra messages on the platform,
    we can run the check and see it pass. The key behavior to observe is how we used
    Copilot and ChatGPT to rapidly build our automated check. Instead of sending a
    prompt to ChatGPT such as
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些准备就绪的情况下，假设平台上没有额外的消息，我们可以运行检查并看到它通过。关键的行为是观察我们如何使用 Copilot 和 ChatGPT 快速构建我们的自动化检查。而不是向
    ChatGPT 发送如下提示
- en: '|'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Create an automated test for a contact us form and check if the message has
    been created |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 创建一个用于联系我们的表单的自动化测试，并检查消息是否已创建 |'
- en: which would result in quite a generic output requiring a lot of modification,
    we worked through each step of our automated check using Copilot and ChatGPT to
    rapidly create parts of the check, switching between tools to help us solve specific
    problems. If we return to our area-of-effect model, this approach is summarized
    in figure 7.4.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法会产生相当通用的输出，需要大量修改。我们通过Copilot和ChatGPT的每个步骤来处理我们的自动化检查，快速创建检查的部分，在工具之间切换以帮助我们解决特定问题。如果我们回到我们的影响范围模型，这种方法在图7.4中得到了总结。
- en: The model shows us that if we are able to identify the specific actions that
    occur in an automated check—like determining what state a check requires or what
    assertions to make—then we can use an LLM effectively with said actions. As demonstrated
    in the example, ChatGPT and Copilot (and other LLM tools) are incredibly fast
    at predicting and generating code for our automation. However, they lack access
    to the context of the product we’re automating. Problems such as incorrect test
    data and missing waits require us to lead the creation of automation, with AI
    tools offering support where we need it most.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 模型显示，如果我们能够识别自动化检查中发生的特定操作——比如确定检查需要什么状态或需要做出什么断言——那么我们可以有效地使用LLM（大型语言模型）进行这些操作。正如示例中所示，ChatGPT和Copilot（以及其他LLM工具）在预测和生成自动化代码方面非常快速。然而，它们无法访问我们正在自动化的产品的上下文。诸如错误的测试数据和缺少等待等问题需要我们引导自动化创建，而AI工具则在我们最需要的地方提供支持。
- en: '![](../../OEBPS/Images/CH07_F04_Winteringham2.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F04_Winteringham2.png)'
- en: Figure 7.4 Area-of-effect model showing the skills an individual and tooling
    bring to the development of automated checks
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 展示个人和工具在自动化检查开发中带来的影响范围模型
- en: Activity 7.2
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 活动7.2
- en: 'Use Copilot and ChatGPT to create your own automated check with [https://automationintesting.online](https://automationintesting.online).
    This time, create an automated check that does the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Copilot和ChatGPT创建您自己的自动化检查，请访问[https://automationintesting.online](https://automationintesting.online)。这次，创建一个执行以下操作的自动化检查：
- en: Logs in to the admin section of the site
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录到网站的管理员部分
- en: Creates a new room
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的房间
- en: Asserts that the room appears on the home page
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言房间出现在主页上
- en: Use the prompts shared in the example to generate your own Page objects, or
    build your own prompts that might be more effective.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用示例中共享的提示来生成您自己的页面对象，或者构建可能更有效的提示。
- en: 7.2 Improving existing UI automation
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 改进现有的UI自动化
- en: Our initial example demonstrated how we can work with LLM tools to rapidly create
    new automated checks, but what about existing checks? Working with automation
    means handling automated checks that fail due to flakiness or rapid changes within
    the product under test. How can LLM tools help us improve our automation rapidly,
    while ensuring they still deliver value? Let’s go back to the automated check
    we have just created and see how the patterns of use for LLMs can help us make
    more robust automated checks.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的示例演示了如何与LLM工具合作快速创建新的自动化检查，但对于现有的检查又如何呢？与自动化工作意味着处理由于测试产品中的快速变化或不可靠性导致的失败的自动化检查。LLM工具如何帮助我们快速改进自动化，同时确保它们仍然提供价值？让我们回到我们刚刚创建的自动化检查，看看LLM的使用模式如何帮助我们创建更健壮的自动化检查。
- en: 7.2.1 Updating state management to use an appropriate layer
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 更新状态管理以使用适当的层
- en: If we assess what our automated check is focused on, we can see that the goal
    is to check whether messages can be seen in the Admin panel. What this means for
    our state management is that we don’t need to create our message through the UI.
    It’s slow and potentially brittle. So, let’s instead take a look at how we can
    create the message with an API call so that we can improve our automated check
    and learn how to use LLMs to build API calls.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们评估我们的自动化检查关注的内容，我们可以看到目标是检查消息是否可以在管理员面板中看到。这意味着对于我们的状态管理来说，我们不需要通过UI创建消息。这既慢又可能脆弱。因此，让我们看看我们如何通过API调用创建消息，这样我们可以改进我们的自动化检查并学习如何使用LLM构建API调用。
- en: 'Our goal is to capture the HTTP request sent when creating a message via the
    Contact Us page and codify that into our automated test. So, our first step is
    to capture the HTTP request as a `curl` command by following these steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是捕获通过“联系我们”页面创建消息时发送的HTTP请求，并将其编码到我们的自动化测试中。因此，我们的第一步是按照以下步骤捕获HTTP请求作为一个`curl`命令：
- en: Open up Dev Tools within our browser.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的浏览器中打开开发者工具。
- en: Select the Network tab.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择网络标签。
- en: Manually send a message via the Contact Us form in the UI.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过UI中的“联系我们”表单手动发送消息。
- en: Locate the HTTP request on the Network tab and then copy the request to a `curl`
    command (right-click the request in Dev Tools).
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网络标签页上找到 HTTP 请求，然后将其复制到 `curl` 命令中（在开发者工具中右键单击请求）。
- en: 'With our command located, we can once again build a prompt that will convert
    our `curl` request into the required Java code using the following prompt. We
    first set out instructions for prompt and use delimiter tactic:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确定了命令位置后，就可以再次构建一个提示，将我们的 `curl` 请求转换为所需的 Java 代码，使用以下提示。我们首先为提示设置指令并使用分隔符策略：
- en: '|'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Convert the following `curl` request delimited by triple hashes into Java
    using the following rules:   1.  The request is encapsulated in a method   2. 
    The method will use spring framework to send the HTTP request   3.  The HTTP response
    doesn’t need parsing   4.  The method will take a POJO that represents the HTTP
    payload as a parameter |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 将以下由三个井号分隔的 `curl` 请求转换为 Java，使用以下规则：   1.  请求封装在方法中   2.  方法将使用 Spring 框架发送
    HTTP 请求   3.  HTTP 响应不需要解析   4.  方法将接受一个表示 HTTP 负载的 POJO 作为参数 |'
- en: 'We provide the `curl` request in the delimited section:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在分隔的段落中提供了 `curl` 请求：
- en: '|'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '|'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Similar to the prompt we used to create Page objects, this prompt sets out
    what we want ChatGPT to do in the initial sentence before adding specific instructions
    to help ChatGPT predict the correct code we require—for example, stating that
    the method wants the body payload parameter to come in the format of a POJO (Plain
    Old Java Object), ensuring that ChatGPT generates a solution that utilizes Java
    classes to construct our payload, rather than a JSON object stored within a large
    String that would be hard to parse and maintain. Passing the prompt in with the
    `curl` request added to the bottom of the prompt will yield the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们用来创建页面对象的提示类似，这个提示在添加具体指令以帮助 ChatGPT 预测我们所需的正确代码之前，在第一句话中说明了我们想要 ChatGPT
    做的事情。例如，指出该方法希望体负载参数以 POJO（Plain Old Java Object）的格式传入，确保 ChatGPT 生成的解决方案使用 Java
    类来构建我们的负载，而不是存储在大型字符串中的 JSON 对象，这将难以解析和维护。将带有 `curl` 请求的提示添加到底部并将提示传递进去，将得到以下代码：
- en: '|'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'This predicted code requires new dependencies to be added to our project, which
    we can request from ChatGPT with the following prompt:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个预测的代码需要向我们的项目中添加新的依赖项，我们可以使用以下提示从 ChatGPT 请求：
- en: '|'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| What dependencies are required for this method? |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 该方法需要哪些依赖项？ |'
- en: which results in ChatGPT returning
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致 ChatGPT 返回
- en: '|'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: We can then add the dependency into our `pom.xml`, ensuring that we are using
    the latest versions, followed by copying the HTTP request code into our framework
    in a new package named `requests`. I opted to rename the class from `HttpRequestSender`
    to `MessageRequest`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将依赖项添加到我们的 `pom.xml` 文件中，确保我们使用的是最新版本，接着将 HTTP 请求代码复制到我们的框架中一个新的名为 `requests`
    的包中。我选择将类名从 `HttpRequestSender` 改为 `MessageRequest`。
- en: 'This gives us the required code to send a request, but because we informed
    ChatGPT that `sendRequest` would take a POJO parameter for the body of our request,
    we next need ChatGPT to create the code to build our POJO. To do this, we return
    to our existing chat with ChatGPT and add the following prompt:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了发送请求所需的代码，但由于我们通知 ChatGPT `sendRequest` 将需要一个表示请求体的 POJO 参数，我们接下来需要 ChatGPT
    创建构建我们的 POJO 的代码。为此，我们回到与 ChatGPT 的现有对话中，并添加以下提示：
- en: '|'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Create me a POJO for `MessagePayload` including constructors and getter and
    setter methods |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 为 `MessagePayload` 创建一个包含构造函数和 getter 以及 setter 方法的 POJO |'
- en: 'The prompt makes it clear that we require constructors and getter/setter methods
    because these will be necessary for creating and sending our HTTP request. Sending
    the prompt to ChatGPT yields the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 提示清楚地表明我们需要构造函数和 getter/setter 方法，因为这些对于创建和发送我们的 HTTP 请求是必要的。将提示发送到 ChatGPT
    得到以下代码：
- en: '|'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '|'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Because we provided the `curl` request in the initial prompt, ChatGPT can predict
    what the code for our POJO should look like to create a message to send via HTTP,
    which can then be copied over to a `MessagePayload` class in the `requests` package
    of our project.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们提供了初始提示中的`curl`请求，ChatGPT可以预测我们的POJO创建通过HTTP发送消息的代码应该是什么样子，然后可以复制到我们项目`requests`包中的`MessagePayload`类。
- en: 'With our classes in place to create a message payload and send a request to
    the `POST /message/` endpoint, we can then return to our `MessageTest` and use
    Copilot to improve our check. First, we remove the following section of our check:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们放置好用于创建消息负载并发送请求到`POST /message/`端点的类之后，我们可以回到`MessageTest`并使用Copilot来改进我们的检查。首先，我们移除以下检查部分：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'and start typing `MessagePayload` to trigger Copilot to add the following code
    as a replacement:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 并开始输入`MessagePayload`以触发Copilot添加以下代码作为替换：
- en: '[PRE31]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Similar to when we used Copilot to generate code for creating a message in
    the UI, running the automated check for the first time will result in a failure.
    The check will run and then receive a 400-status code because the predicted test
    data didn’t match the validation rules again. Therefore, to ensure that our message
    matches the necessary validation rules, we need to update the following methods
    with correct test data:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们使用Copilot在UI中生成创建消息的代码时，第一次运行自动检查会导致失败。检查将运行并收到400状态码，因为预测的测试数据再次不符合验证规则。因此，为了确保我们的消息符合必要的验证规则，我们需要更新以下方法以正确的测试数据：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once these test data parameters are updated, we should now see the automated
    check pass again.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些测试数据参数被更新，我们现在应该看到自动检查再次通过。
- en: This example demonstrates that we can use LLM tools to help us update specific
    aspects of our automated checks to make them more robust, but it requires us to
    have a good analytical eye for which areas of our checks require improvement.
    This is because we have knowledge of both our automated checks and our system
    under test, which is lacking in the tools we’ve used so far. For example, if we
    were to give ChatGPT the prompt
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明我们可以使用LLM工具帮助我们更新自动检查的特定方面，使其更加健壮，但这要求我们具备良好的分析眼光，了解哪些检查区域需要改进。这是因为我们既了解我们的自动检查，也了解我们正在测试的系统，这是我们迄今为止使用的工具所缺乏的。例如，如果我们给ChatGPT以下提示
- en: '|'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-MW.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-MW.png)'
- en: '| Suggest ways in which this automated test can be improved to make it less
    flakey |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 建议如何改进这个自动测试，使其不那么不可靠 |'
- en: 'and then add our automated check code to the prompt, these would be the returned
    suggestions (in summary):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将我们的自动检查代码添加到提示中，这些将是返回的建议（总结）：
- en: '|'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../../OEBPS/Images/logo-openai.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/logo-openai.png)'
- en: '|    •   Add explicit waits   •   Use stable locators   •   Handle asynchronous
    operations   •   Isolate the test   •   Retry failed actions   •   Check for error
    conditions   •   Review and update the test environment |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|   •   添加显式等待   •   使用稳定的定位器   •   处理异步操作   •   隔离测试   •   重试失败的操作   •   检查错误条件  
    •   审查和更新测试环境 |'
- en: These are all legitimate considerations, but they are generic problems and don’t
    necessarily give us enough information to solve specific problems. So instead,
    we frame the process of improvement, looking to tools to help us rapidly generate
    the necessary code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是合法的考虑因素，但它们是通用问题，并不一定给我们提供足够的信息来解决具体问题。因此，我们构建改进过程，寻求工具帮助我们快速生成必要的代码。
- en: Activity 7.3
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 活动七.3
- en: Using ChatGPT and Copilot, try turning the login process into an API call as
    well. For this exercise, you will need to create the code to
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ChatGPT和Copilot，尝试将登录过程转换为API调用。为此练习，你需要编写代码
- en: Send credentials to `POST /auth/login`
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将凭证发送到`POST /auth/login`
- en: Extract the `token` value from the HTTP response
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从HTTP响应中提取`token`值
- en: Store the `token` value as a cookie in the browser before heading to the message
    page
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前往消息页面之前，将`token`值存储为浏览器中的cookie
- en: 7.2.2 Getting into the groove with AI tools
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 使用AI工具进入状态
- en: This chapter demonstrated that regardless of whether we are building UI automation,
    API automation, or something entirely different, the pattern of success with AI
    is always the same. Our deep understanding of the design and structure of automated
    checks informs us when and where to use AI tools to help us with specific tasks
    to create and maintain valuable automation. The marketing around AI automation
    would have us believe that our role in creating automated checks is limited when
    AI is involved. But if we want automation that helps us create high-quality products,
    then our best course of action is to build a relationship with AI tools that places
    our skillset at the core of the work.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了无论我们是在构建UI自动化、API自动化还是其他完全不同的东西，使用AI的成功模式始终相同。我们对自动化检查的设计和结构的深入了解让我们知道何时何地使用AI工具来帮助我们完成特定任务以创建和维护有价值的自动化。围绕AI自动化的营销可能会让我们相信，当涉及AI时，我们在创建自动化检查中的作用是有限的。但如果我们想要帮助我们创建高质量产品的自动化，那么我们最好的行动方案是与AI工具建立关系，将我们的技能集置于工作的核心。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Attempting to generate a whole automated UI test using only a tool such as ChatGPT
    will likely require a lot of rework. Instead, we want to use AI tools selectively
    at specific points of the UI automation process.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用ChatGPT等工具尝试生成整个自动化UI测试可能需要大量的重做。相反，我们希望在UI自动化过程的特定点上选择性地使用AI工具。
- en: Starting a new project with a tool such as Copilot can yield varying results.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Copilot等工具开始一个新项目可能会产生不同的结果。
- en: The more detail we add to our project, the more accurate Copilot will be.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在项目中添加的细节越多，Copilot就会越准确。
- en: With the right type of prompt, we can rapidly generate Page objects in ChatGPT
    by providing it with HTML and instructions to convert it.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供HTML和转换指令，我们可以使用正确的提示类型在ChatGPT中快速生成页面对象。
- en: We can rapidly generate automated checks by combining ChatGPT and Copilot (or
    similar tools).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过结合ChatGPT和Copilot（或类似工具）快速生成自动化检查。
- en: The output of AI tools is not 100% accurate, because it lacks context—for example,
    with test data or using up-to-date methods from libraries.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AI工具的输出并非100%准确，因为它缺乏上下文——例如，使用测试数据或使用来自库的最新方法。
- en: Success with AI tools when creating automated checks comes from using AI tools
    to complete specific tasks within the creation process.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建自动化检查时使用AI工具的成功来自于在创建过程中使用AI工具完成特定任务。
- en: We lead the creation process, identifying when AI tools can help us speed it
    up.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们领导创建过程，确定何时AI工具可以帮助我们加快速度。
- en: If we are able to identify improvements to specific elements of an automated
    check, we can employ AI tools to make the improvements faster.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们能够识别自动化检查特定元素的可改进之处，我们可以使用AI工具更快地完成这些改进。
- en: If we ask LLMs to evaluate our checks and offer improvements, we get generic
    answers in return.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们要求LLMs评估我们的检查并提出改进意见，我们会得到一些通用的答案作为回报。
- en: We can use the same process of using AI tools on specific tasks within our automated
    checks to maintain them.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用在自动化检查中特定任务上使用AI工具的相同过程来维护它们。
