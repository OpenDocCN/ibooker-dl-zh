["```py\nv = torch.tensor([0.11, 0.01, 0.98, 0.12, 0.98,  ①\n                ,0.85, 0.03, 0.55, 0.49, 0.99,\n                0.02, 0.31, 0.55, 0.87, 0.63],\n                dtype=torch.float64)             ②\n\nfirst_element = v[0]\nthird_element = v[2]                             ③\n\nlast_element = v[-1]\nsecond_last_element = v[-2]                      ④\n\nsecond_to_fifth_elements = v[1:4]                ⑤\n\nfirst_to_third_elements = v[:2]\nlast_two_elements = v[-2:]                       ⑥\n\nnum_elements_in_v = len(v)\n\nu = np.array([0.11, 0.01, 0.98, 0.12, 0.98, 0.85, 0.03,\n              0.55, 0.49, 0.99, 0.02, 0.31, 0.55, 0.87,\n              0.63])\n\nu = torch.from_numpy(u)                          ⑦\n\ndiff = v.sub(u)                                  ⑧\n\nu1 = u.numpy()                                   ⑨\n```", "```py\nX = torch.tensor(                                      ①\n     [\n        [0.11, 0.09], [0.01, 0.02], [0.98, 0.91],\n        [0.12, 0.21], [0.98, 0.99], [0.85, 0.87],\n        [0.03, 0.14], [0.55, 0.45]                     ②\n     ]\n )\n\nprint(\"Shape of the matrix is: {}\".format(X.shape))    ③\n\nfirst_element = X[0, 0]                                ④\n\nrow_0 = X[0, :]                                        ⑤\nrow_1 = X[1, 0:2]                                      ⑥\n\ncolumn_0 = X[:, 0]                                     ⑦\ncolumn_1 = X[:, 1]                                     ⑧\n```", "```py\nfirst_3_training_examples = X[:3, ]               ①\n                                                  ②\nprint(\"Sharpness of 5-7 training examples is: {}\"\n       .format(X[5:8, 1]))                        ③\n```", "```py\ntensor = torch.rand((5, 5, 3))                                  ①\n                                                                ②\nI49 = torch.tensor([[0, 8, 16, 24, 32, 40, 48,  56,  64],       ③\n               [64,   72,  80,  88,  96, 104, 112, 120, 128],\n                [128, 136, 144, 152, 160, 168, 176, 184, 192],\n                [192, 200, 208, 216, 224, 232, 240, 248, 255]],\n               )                                                ④\n\nimg = torch.tensor(cv2.imread('../../Figures/dog3.jpg'))        ⑤\nimg_b = img[:, :, 0]                                            ⑥\nimg_g = img[:, :, 1]                                            ⑥\nimg_r = img[:, :, 2]                                            ⑥\nimg_cropped = img[0:100, 0:100, :]                              ⑦\n```", "```py\nI49 = torch.stack([torch.arange(0, 72, 8), torch.arange(64, 136, 8),   ①\n                torch.arange(128, 200, 8), torch.arange(192, 264, 8)])\n\nI49_t = torch.transpose(I49, 0, 1)                                     ②\n\nfor i in range(0, I49.shape[0]):\n    for j in range(0, I49.shape[1]):\n        assert I49[i][j] == I49_t[j][i]                                ③\n\nassert torch.allclose(I49_t, I49.T, 1e-5)                              ④\n```", "```py\na = torch.tensor([1, 2, 3])\nb = torch.tensor([4, 5, 6])\na_dot_b = torch.dot(a, b)\nprint(\"Dot product of these two vectors is: \"\n              \"{}\".format(a_dot_b))               ①\n\n# Dot product of perpendicular vectors is zero\nvx = torch.tensor([1, 0]) # a vector along X-axis\nvy = torch.tensor([0, 1]) # a vector along Y-axis\nprint(\"Example dot product of orthogonal vectors:\"\n              \" {}\".format(torch.dot(vx, vy)))    ②\n```", "```py\nX = torch.tensor([[0.11, 0.09], [0.01, 0.02], [0.98, 0.91], [0.12, 0.21], ①\n              [0.98, 0.99], [0.85, 0.87], [0.03, 0.14], [0.55, 0.45],\n              [0.49, 0.51], [0.99, 0.01], [0.02, 0.89], [0.31, 0.47],\n              [0.55, 0.29], [0.87, 0.76], [0.63, 0.24]])                  ②\n\nw = torch.rand((2, 1))                                                    ③\nb = 5.0\n  = torch.matmul(X, w) + b                                                ④\n```", "```py\nA = torch.tensor([[1, 2], [3, 4], [5, 6]])\nB = torch.tensor([[7, 8], [9, 10]])\n\nC = torch.matmul(A, B)                              ①\n                                                    ②\n  w = torch.tensor([1, 2, 3])\n  x = torch.tensor([4, 5, 6])\n  assert torch.dot(w, x) == torch.matmul(w.T, x)    ③\n```", "```py\nassert torch.all(torch.matmul(A, B).T == torch.matmul(B.T, A.T))  ①\n\nassert torch.all(torch.matmul(A.T, x).T == torch.matmul(x.T, A))  ②\n```", "```py\ndef determinant(A):\n    return torch.linalg.det(A)\n\ndef inverse(A):\n    return torch.linalg.inv(A)\n\nA = torch.tensor([[2, 3], [2, 2]], dtype=torch.float    ①\n\nA_inv = inverse(A)                                      ②\n\nI = torch.eye(2)                                        ③\n\nassert torch.all(torch.matmul(A, A_inv) == I)           ④\nassert torch.all(torch.matmul(A_inv, A) == I)\n\nassert torch.all(torch.matmul(I, A) ==  A)\nassert torch.all(A == torch.matmul(A,I))                ⑤\n```", "```py\nB = torch.tensor([[1, 1], [2, 2]], dtype=torch.float)   ①\ntry:\n\n    B_inv = inverse(B)                                  ②\n\nexcept RuntimeError as e:\n    print(\"B cannot be inverted: {}\".format(B, e))\n```", "```py\ndef pseudo_inverse(A):\n    return torch.matmul(torch.linalg.inv(torch.matmul(A.T, A)), A.T)\n\n①\nX = torch.column_stack((X, torch.ones(15))) ②\n\n③\nw = torch.matmul(pseudo_inverse(X), y)      ④\n\nprint(\"The solution is {}\".format(w))       ⑤\n```", "```py\nfrom torch import linalg as LA\n\nA = torch.tensor([[0.707, 0.707, 0],\n       [-0.707, 0.707, 0], [0, 0, 1]])    ①\n\nl, e = LA.eig(A)                          ②\n\nprint(\"Eigen values are {}\".format(l))\nprint(\"Eigen vectors are {}\".format(e.T)) ③\n```", "```py\ndef rotation_matrix_2d(theta):                                            ①\n     return torch.tensor([[cos(radians(theta)), -sin(radians(theta))],\n                      [sin(radians(theta)), cos(radians(theta))]])\n\ndef rotation_matrix_3d(theta, axis):                                      ②\n     if axis == 0:                                                        ③\n       return torch.tensor([[1, 0, 0],\n                        [0, cos(radians(theta)),-sin(radians(theta))],\n                        [0, sin(radians(theta)),cos(radians(theta))]])\n     elif axis == 1:                                                      ④\n       return torch.tensor([[cos(radians(theta)),0,-sin(radians(theta))],\n                        [0, 1, 0],\n                        [sin(radians(theta)),0,cos(radians(theta))]])\n     elif axis == 2:                                                      ⑤\n       return torch.tensor([[cos(radians(theta)),-sin(radians(theta)),0],\n                        [sin(radians(theta)),cos(radians(theta)),0],\n                        [0, 0, 1]])\n```", "```py\nu = torch.tensor.array([1, 1, 1], dtype=torch.float)  ①\n\nR3dz = rotation_matrix_3d(45, 2)                      ②\nv = torch.matmul(R3dz, u_row)                         ③\n\nR3dx = rotation_matrix_3d(45, 0)                      ④\nw = torch.matmul(R3dx, u_row)                         ⑤\n```", "```py\nR_30 = rotation_matrix_2d(30)                      ①\n\nassert torch.allclose(\n    torch.linalg.inv(R_30),\n    R_30.T\n\n    )                                              ②\n\nassert torch.allclose(\n    torch.matmul(R_30, R_30.T),\n    torch.eye(2)                                   ③\n    )\n\nu = torch.tensor([[4],[0]], dtype=torch.float)\n\nv = torch.matmul(R_30, u)                          ④\n\nassert torch.linalg.norm(u) ==torch.linalg.norm(v)  ⑤\n\nR_neg30 = rotation_matrix_2d(-30)\nw = torch.matmul(R_neg30, v)                       ⑥\nassert torch.all(w == u)\n\nassert torch.allclose(R_30, R_neg30.T)\nassert torch.allclose(\n    torch.matmul(R_30, R_neg30),\n    torch.eye(2))                                  ⑦\n```", "```py\nR = torch.tensor([[0.7071, 0.7071, 0],\n             [-0.7071, 0.7071, 0],                      ①\n             [0, 0, 1]])\n\nl, e = LA.eig(R)                                        ②\n\n③\naxis_of_rotation = e[:, torch.where(l == 1.0)]          ④\n\naxis_of_rotation = torch.squeeze(axis_of_rotation)\n\nassert torch.allclose(\n    axis_of_rotation.real,\n    torch.tensor([0, 0, 1], dtype=torch.float)          ⑤\n)\n\np = torch.randint(0, 10, (1,)) * axis_of_rotation\nassert torch.allclose(torch.matmul(R, p.real), p.real)  ⑥\n```", "```py\ndef diagonalize(matrix):                              ①\n\n    try:\n        l, e = torch.linalg.eig(matrix)               ②\n\n        sigma = torch.diag(l)                         ③\n\n        return e, torch.diag(l), torch.linalg.inv(e)  ④\n    except np.linalg.LinAlgError:\n        print(\"Cannot diagonalize matrix!\")\n\nA = torch.tensor([[0.7071, 0.7071, 0],\n              [-0.7071, 0.7071, 0],                   ⑤\n              [0, 0, 1]])\n\nS, sigma, S_inv = diagonalize(A)\n\nA1 = torch.matmul(S, torch.matmul(sigma, S_inv))      ⑥\n\nassert torch.allclose(A, A1.real)                     ⑦\n```", "```py\nA = torch.tensor([[1, 2, 1], [2, 2, 3], [1, 3, 3]],\n                        dtype=torch.float)         ①\nassert torch.all(A == A.T)                         ②\nb = torch.tensor([8, 15, 16], dtype=torch.cfloat)  ③\n\nx_0 = torch.matmul(torch.linalg.inv(A),\n                                b.real)            ④\n\nw, S = torch.linalg.eig(A)                         ⑤\n\n 1 = torch.matmul(S.T, b)                          ⑥\n\n 2 = torch.matmul(torch.diag(1/ w), y1)            ⑦\n\nx_1 = torch.matmul(S, y2)                          ⑧\n\nassert torch.allclose(x_0, x_1.real)               ⑨\n```", "```py\ndef spectral_decomposition(A):\n  assert len(A.shape) == 2                                    ①\n\n     and A.shape[0] == A.shape[1]                             ②\n\n     and torch.all(A == A.T)                                  ③\n\n  l, e = torch.linalg.eig(A)                                  ④\n\n  assert len(torch.unique(l.real)) == A.shape[0],\n         ``Eigen values are not distinct!\"\n\n  C = torch.zeros((A.shape[0],\n                          A.shape[0],                         ⑤\n                          A.shape[0]))\n\n  for i, lambda_i in enumerate(l):\n      e_i = e[:, i]\n      e_i = e_i.reshape((3, 1))\n      C[i, :, :] = (lambda_i * torch.matmul(e_i, e_i.T)).real ⑥\n  return C\n\nA = torch.tensor([[1, 2, 1], [2, 2, 3], [1, 3, 3]]).float()\nC = spectral_decomposition(A)\n\nA1 = C.sum(axis=0)                                            ⑦\n\nassert torch.allclose(A, A1)                                  ⑧\n```", "```py\nellipse_eq = sy.Eq(5*x**2 + 5*y**2 +\n                      6*x*y, 20)                   ①\n\nA = torch.tensor([[5, 3], [3, 5]]).float()\n\nl, S = torch.linalg.eig(A)\n\nx_axis_vec = torch.zeros((A.shape[0]))             ②\n\nfirst_eigen_vec = S[:, 0]                          ③\n\ndot_prod = torch.dot(x_axis_vec, first_eigen_vec)  ④\n\ntheta = math.acos(dot_prod)\ntheta = math.degrees(theta)                        ⑤\n```"]