<html><head></head><body>
<div id="sbo-rt-content"><div class="readable-text" id="p1">
<h1 class="readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">2</span> </span><span class="chapter-title-text">Parsing payments</span></h1>
</div>
<div class="introduction-summary">
<h3 class="introduction-header"><span class="CharOverride-1">This chapter covers</span><span class="CharOverride-1"/></h3>
<ul>
<li class="readable-text" id="p2"><span class="CharOverride-2">Working with generative AI to parse an ACH file</span></li>
<li class="readable-text" id="p3"><span class="CharOverride-2">Unit testing in Python</span></li>
<li class="readable-text" id="p4"><span class="CharOverride-2">Agile concepts</span></li>
</ul>
</div>
<div class="readable-text" id="p5">
<p>This chapter explains the fundamentals of files formatted by an Automated Clearing House (ACH). You will work on parsing an initial sample file to better understand some of the record layouts used, as well as the software development practice of unit testing. You will also expand your knowledge of generative AI and see how to apply it to a real-world problem.</p>
</div>
<div class="readable-text" id="p6">
<h2 class="readable-text-h2"><span class="num-string">2.1</span> Modernizing our legacy software</h2>
</div>
<div class="readable-text" id="p7">
<p>Now that we have gone through PI planning and have been assigned our project, we will begin working on our first spike. In SAFe, spikes are a type of story, often referred to as an <span class="Italics">enabler story.</span> A variety of enabler story categories may be used (e.g., exploration, architectural, infrastructure, and compliance). In our case, our story may be classified as an exploration type or a research spike. However, the details are not as important as our activities because the particulars may vary between Agile frameworks. Essentially, this story aims to provide the team with some experience working in Python and learning about the ACH file layout so that we can understand prospective solutions better. </p>
</div>
<div class="readable-text intended-text" id="p8">
<p>The stories assigned to the team in this sprint can shed light on the business needs driving the modernization effort. The current ACH system runs on the mainframe system, and it is highly coupled with the existing architecture. This coupling prevents the system from being maintained easily. The business has been keeping metrics on various key performance indicators (KPIs):</p>
</div>
<ul>
<li class="readable-text" id="p9"><em>Release cadenc</em><em>e</em>—Shows how often the development teams release new features and updates</li>
<li class="readable-text" id="p10"><em>Defect backlo</em><em>g</em>—Shows the number of defects identified during development and release</li>
<li class="readable-text" id="p11"><em>Escaped defect</em><em>s</em>—Shows the number of defects identified after the software has been released</li>
<li class="readable-text" id="p12"><em>Customer satisfactio</em><em>n</em>—Indicates how happy the customer is with our product/service</li>
</ul>
<div class="readable-text" id="p13">
<p>These metrics have shown that there has been a steady increase in the time it takes to make regulatory enhancements and general bug fixes as the system’s code base has grown in both size and complexity.</p>
</div>
<div class="readable-text intended-text" id="p14">
<p>Currently, we do not have any knowledge of ACH files, and understanding and navigating the COBOL code will take time; moreover, we may need to request access. The team will have to gain insight into the COBOL code so that they can better assist in converting functionality from one area to another. In the interim, the team is supposed to tackle the project from the ground up. The team also has first access to generative AI tools to help evaluate their use since the company is looking into using Gen AI to improve productivity. Our manager believes that the team is in a unique position to evaluate the tools to help us with this effort.</p>
</div>
<div class="readable-text intended-text" id="p15">
<p>The company gave us access to both premium ChatGPT and GitHub Copilot membership. They have also asked that we test out the free version of ChatGPT because, if the free version is comparable to the premium one, they would much rather save some money. In addition, our manager has reminded us not to paste any proprietary or confidential information into ChatGPT because that would be a potential violation of the nondisclosure agreement (NDA) we have in place. This means we cannot paste the COBOL code and convert it to Python or ask ChatGPT to interpret existing code. Instead, we should focus on isolating, sanitizing, and generalizing code samples before plugging them into ChatGPT. </p>
</div>
<div class="readable-text intended-text" id="p16">
<p>Our plan is to do a little research on what exactly an ACH is and what type of format we’ll be working with. We are familiar with JSON as we have done a fair amount of web-based work before. Either way, we are excited to get moving on to this project: getting into some code and working on a project is why we wanted this job in the first place, so let’s begin!</p>
</div>
<div class="readable-text" id="p17">
<h2 class="readable-text-h2"><span class="num-string">2.2</span> Understanding the ACH</h2>
</div>
<div class="readable-text" id="p18">
<p>The ACH network allows banks and credit unions to transfer money without establishing a separate relationship. Given that there are over 10,000 banks and credit unions in the United States, that is quite an undertaking! So, how does it work? </p>
</div>
<div class="readable-text intended-text" id="p19">
<p>A common type of ACH transaction is known as Prearranged Payment and Deposit (PPD). It is often used for direct deposit of paychecks (and recurring bill payments, gym memberships, and social security payments, to name a few). Let us say our employer has an account at bank X. Every two weeks or twice a month, they need to pay us, but we use a different bank, bank Y. To get the money to you, a few days before payday, our employer or their payroll processor will create a file containing the information needed to execute the payment. It includes the amount of our take-home pay, our account number, and a <em>routing transit number.</em> A routing transit number is a unique number that identifies a bank—in this case, the bank of the end recipient of the transaction: bank Y. The payroll processor will transmit the file containing the employee wages info to bank X. Bank X accepts the file and combines it with other files they receive. Next, it sends one file to either the Federal Reserve or a private company called The Clearing House. These two entities are known as <em>ACH operators </em><em>or</em><em> clearing houses</em>. ACH operators accept files from thousands of banks, sort the transactions based on their routing transit numbers, and create new files for each bank receiving transactions. These files are then transmitted to the banks, which then receive and post the transactions.</p>
</div>
<div class="readable-text intended-text" id="p20">
<p>ACH files use a format defined by Nacha, the organization that sets standards for the ACH network. Figure 2.1 shows the ACH processing flow. </p>
</div>
<div class="browsable-container figure-container" id="p21">
<img alt="A diagram of a company  Description automatically generated" height="420" src="../Images/CH02_F01_Kardell.png" style="width: 100%; max-width: max-content;" width="741"/>
<h5 class="figure-container-h5"><span class="">Figure 2.1</span><span class=""> </span><span class="">ACH processing flow</span></h5>
</div>
<div class="readable-text" id="p22">
<h2 class="readable-text-h2"><span class="num-string">2.3</span> Parsing an ACH file</h2>
</div>
<div class="readable-text" id="p23">
<p>So, we have been assigned a story to parse an ACH file and store it in the database. The story has subtasks for parsing each of the record formats found in an ACH file, as well as storing the results in a database.</p>
</div>
<div class="readable-text intended-text" id="p24">
<p>The ACH file standard was created in the 1970s and has undergone various updates and expansions since then. This is great because it means that plenty of information is available on the standard. We start by doing some research on ACH, finding that an ACH file is a fixed-width ASCII file with each line being 94 characters long. These lines are known as records, and each record consists of fields that are at fixed positions. A fixed-width file with records at fixed positions should mean parsing is a relatively straightforward task.</p>
</div>
<div class="readable-text intended-text" id="p25">
<p>Digging a little bit further, we see that there are six types of ACH records that may be present in a file. It seems there are a few types of header records, and each has a trailer record known as a control record that wraps up the data. We also find an overview of the record types and file structure (see figure 2.2). Further details on the records and their corresponding fields (such as the position, whether it is required, etc.) are available at <a href="https://achdevguide.nacha.org/ach-file-details"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/achdevguide.nacha.org/ach-file-details</span></a>. </p>
</div>
<div class="browsable-container figure-container" id="p26">
<img alt="" height="504" src="../Images/CH02_F02_Kardell.png" style="width: 100%; max-width: max-content;" width="781"/>
<h5 class="figure-container-h5"><span class="">Figure 2.2</span><span class=""> </span><span class="">ACH file layout</span></h5>
</div>
<div class="readable-text" id="p27">
<p>Figure 2.2 gives us an idea of the file structure; however, let’s also look at a sample file that we will be working with so we can get a better idea of what a file may look like. Figure 2.3 may look a bit daunting, but once we break down the records into their fields, it is relatively straightforward.</p>
</div>
<div class="browsable-container figure-container" id="p28">
<img alt="" height="509" src="../Images/CH02_F03_Kardell.png" style="width: 100%; max-width: max-content;" width="781"/>
<h5 class="figure-container-h5"><span class="">Figure 2.3</span><span class=""> </span><span class="">Example ACH file</span></h5>
</div>
<div class="readable-text" id="p29">
<p>Based on the structure and file sample, we know that we will have to parse the following record types:</p>
</div>
<ul>
<li class="readable-text" id="p30"><em>Type </em><em>1</em>—A file header record with a single record per file</li>
<li class="readable-text" id="p31"><em>Type </em><em>5</em>—A batch header record with multiple batches per file</li>
<li class="readable-text" id="p32"><em>Type </em><em>6</em>—Entry records, with multiple entries per batch</li>
<li class="readable-text" id="p33"><em>Type 7</em>—Addenda records with zero or multiple records per entry record</li>
<li class="readable-text" id="p34"><em>Type </em><em>8</em>—A batch control record that encloses the entry and addenda records</li>
<li class="readable-text" id="p35"><em>Type </em><em>9</em>—A file trailer record that encloses all the batch records</li>
</ul>
<div class="readable-text" id="p36">
<p>While we have not gotten access to the legacy COBOL code, a team member found a confluence (a wiki provided by Atlassian) site with the flow chart that provides some insight into the processing of an ACH file (figure 2.4).</p>
</div>
<div class="browsable-container figure-container" id="p37">
<img alt="" height="434" src="../Images/CH02_F04_Kardell.png" style="width: 100%; max-width: max-content;" width="877"/>
<h5 class="figure-container-h5"><span class="">Figure 2.4</span><span class=""> </span><span class="">ACH processing flow</span></h5>
</div>
<div class="readable-text" id="p38">
<p>Your first task is to check your favorite search engine to see what is available. You may find some existing packages (<code>pyNacha</code>, <code>py-nacha</code>, and <code>pynacha</code>). Those appear to be various projects exploring how to create and parse ACH files. Further digging also shows some of these projects came from <code>carta-ach</code>, which again came from <code>python-ach</code>. These projects have been forked many times, but most appear to have not been updated for some time. As they are not actively maintained, it may not be wise to base your project on them. However, they appear to have a permissive MIT license (more on licensing concerns later), so we could possibly fork a project to get started. We can also lean on some of our generative AI tools for some help as well.</p>
</div>
<div class="readable-text" id="p39">
<h3 class="readable-text-h3"><span class="num-string">2.3.1</span> Asking ChatGPT to parse an ACH file</h3>
</div>
<div class="readable-text" id="p40">
<p>We can start by asking ChatGPT the question, “Can you write a Python program to parse an ACH file?”<em> </em>When we try this in ChatGPT 3.5, it gives us the basics of an <code>ACH</code> class that can parse a file, as shown in the next listing. </p>
</div>
<div class="browsable-container listing-container" id="p41">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.1<span class="CharOverride-5"> </span>ACH parser from ChatGPT 3.5</h5>
<div class="code-area-container">
<pre class="code-area">class ACHParser:     #1
    def __init__(self, ach_file_path):     #2
        self.ach_file_path = ach_file_path #2
        self.records = []     

    def parse(self):
        with open(self.ach_file_path, 'r') as file:
            lines = file.readlines() #3

        record_type = None
        current_record = {}

        for line in lines:
            record_code = line[0]    #4
            if record_code == '1':     #5
                record_type = 'header' #5
            elif record_code == '6':    #5
                record_type = 'batch'   #5
            elif record_code == '7':    #5
                record_type = 'entry'   #5
            elif record_code == '9':    #5
                record_type = 'footer' #5

            if record_type:
                current_record[record_type] = line.strip()
                if record_type == 'footer':
                    self.records.append(current_record)
                    current_record = {}
                    record_type = None

    def get_records(self):
        return self.records


if __name__ == "__main__":
    ach_file_path = "example.ach"
    <span>parser = ACHParser(ach_file_path)</span>
<span>    parser.parse()</span>

<span>    </span>records = parser.get_records()
    for record in records:
        print(record)</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Defines a class </span>
<span class="CharOverride-6">named ACHParser</span>
<br/>#2 
     <span class="CharOverride-6">The __init__ function is used as a constructor for our class.</span>
<br/>#3 
     <span class="CharOverride-6">Reads the entire file</span>
<br/>#4 
     <span class="CharOverride-6">Determines the first character and stores it in record_code</span>
<br/>#5 
     <span class="CharOverride-6">Performs processing based on the record_code; notice there is no record_code 5 or 8.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p42">
<p>The program does not look too bad; however, despite our current limited knowledge of ACH, we can see that it has some problems:</p>
</div>
<ul>
<li class="readable-text" id="p43">Missing a record type code of <code>5</code>.</li>
<li class="readable-text" id="p44">Missing a record type code of <code>8</code>.</li>
<li class="readable-text" id="p45">The <code>record_type</code> lables are incorrect, as <code>6</code> is listed as a <code>batch</code> instead of an <code>entry</code>, and <code>7</code> is listed as <code>entry</code> instead of <code>addenda</code>.</li>
</ul>
<div class="readable-text" id="p46">
<p>We try switching over to the updated ChatGPT 4 and ask it the same question. We are presented with the code shown in the following listing. Again, keep in mind that the nondeterministic nature of LLMs may lead to different results.</p>
</div>
<div class="browsable-container listing-container" id="p47">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.2<span class="CharOverride-5"> </span>ACH parser from ChatGPT 4</h5>
<div class="code-area-container">
<pre class="code-area">def parse_ach(filename):
    records = []   #1

    with open(filename, 'r') as file:
        lines = file.readlines()

        for line in lines:
            record_type = line[0]

            if record_type == '1':  # File Header Record #2
                record = {                                #2
                    'record_type': 'File Header',         #2
                    'priority_code': line[1:3],           #2
                    'immediate_destination': line[3:13],  #2
                    'immediate_origin': line[13:23],      #2
                    # ... additional fields               #2
                }

            elif record_type == '5':  # Batch Header Record
                record = {
                    'record_type': 'Batch Header',
                    'service_class_code': line[1:4],
                    'company_name': line[4:20],
                    # ... additional fields
                }

            elif record_type == '6':  # Entry Detail Record
                record = {
                    'record_type': 'Entry Detail',
                    'transaction_code': line[1:3],
                    'receiving_dfi_id': line[3:11],
                    'account_number': line[12:29],
                    'amount': line[29:39],
                    # ... additional fields
                }

            elif record_type == '7':  # Addenda Record
                record = {
                    'record_type': 'Addenda',
                    # ... additional fields based on the
                    # specific addenda type
                }

            elif record_type == '8':  # Batch Control Record #3
                record = {                                    #3
                    'record_type': 'Batch Control',           #3
                    # ... additional fields                   #3
                }

            elif record_type == '9':  # File Control Record
                record = {
                    'record_type': 'File Control',
                    # ... additional fields
                }

            else:
                print(f"Unknown record type: {record_type} in line: {line}")
                continue

            records.append(record) #4

    return records #5


# Test the function with an ACH file
parsed_records = parse_ach('path_to_ach_file.txt')
for record in parsed_records:#6
    print(record)            </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">An empty array to store ACH records into</span>
<br/>#2 
     <span class="CharOverride-6">Each record_type is stored as a dictionary; some of the fields were provided by ChatGPT.</span>
<br/>#3 
     <span class="CharOverride-6">ChatGPT 4 did generate a record type 8 this time.</span>
<br/>#4 
     <span class="CharOverride-6">ACH records are </span>
<span class="CharOverride-6">added to our array.</span>
<br/>#5 
     <span class="CharOverride-6">The records are returned.</span>
<br/>#6 
     <span class="CharOverride-6">The returned records are printed out using a for-each loop.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p48">
<p>This program seems to be a little more built out. We see the batch control record (record type 8) this time, and some of the lines have a sample parsing done as well. This seems to be a good start; however, we want to keep the program testable. If we separate the parsing logic into separate functions, we can pass both well-formatted records and invalid data to the function to test it. Let’s see if we can get ChatGPT to do that somewhat tedious process.</p>
</div>
<div class="readable-text intended-text" id="p49">
<p>We simply ask ChatGPT: </p>
</div>
<div class="readable-text prompt" id="p50">
<p><strong class="prompt-head-image"><img alt="image" height="32" src="../Images/Prompt-Icon.png" width="33"/></strong> Can you update the above program so that the parsing of each record type is a separate function?</p>
</div>
<div class="readable-text" id="p51">
<p>The program is updated to break each of the record types into its own function. The relevant changes are shown in the following listing. Notice that we have been provided with parser functions (<code>parse_file_header</code>, <code>parse_batch_header</code>, etc.) and that these have been stubbed out by ChatGPT (meaning we will have to provide implementation details to parse the actual data).</p>
</div>
<div class="browsable-container listing-container" id="p52">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.3<span class="CharOverride-5"> </span>Parsing with separate functions</h5>
<div class="code-area-container">
<pre class="code-area">def parse_ach(filename):
    records = []

    parser_functions = {          #1
        '1': parse_file_header,    #1
        '5': parse_batch_header,   #1
        '6': parse_entry_detail,   #1
        '7': parse_addenda,        #1
        '8': parse_batch_control,  #1
        '9': parse_file_control    #1
    }                              #1

    with open(filename, 'r') as file:
        lines = file.readlines()

        for line in lines:
            record_type = line[0]
            parser = parser_functions.get(record_type) #2

            if parser:                       #3
                records.append(parser(line)) 
            else:                            
                print(f"Unknown record type: 
   <span class="CharOverride-7">➥</span>{record_type} in line: {line}") #4
                continue

    return records
…                               #5
def parse_file_control(line):    #5
    return {                     #5
        'record_type': 'File Control',  #5
        # ... additional fields    #5
    }  #5
…                                #5</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Defines needed parsing functions in a dictionary</span>
<br/>#2 
     <span class="CharOverride-6">Retrieves the appropriate function based on the first character we stored in record_type</span>
<br/>#3 
     <span class="CharOverride-6">Calls the parse function </span>
<span class="CharOverride-6">with the appropriate data</span>
<br/>#4 
     <span class="CharOverride-6">Calls the parse function </span>
<span class="CharOverride-6">with the appropriate data</span>
<br/>#5 
     <span class="CharOverride-6">One of the sample stubs </span>
<span class="CharOverride-6">for the parser_functions</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p53">
<p>In the tests/data folder, there is also a sample.ach file (as we saw in figure 2.2) that we can plug into these sample programs to examine how they process the file and play around with the results. Now it would be a good time to take a break and run the sample ACH file through these programs to see how they work. This is helpful if we do not quite understand ACH file processing yet or if we are unfamiliar with some of the constructs used in the Python program.</p>
</div>
<div class="readable-text intended-text" id="p54">
<p>It is a powerful tool to help us get started. Many developers have templates, shells, or skeleton programs they use to get started with particular tasks. Or they may choose a particular program to copy and paste. Of course, the problem with copying/pasting is that you may inevitably miss something and introduce a compile-time problem or bug that you then need to troubleshoot. The same thing can happen when using a template to start your program. </p>
</div>
<div class="readable-text intended-text" id="p55">
<p>These templates or code produced from generative AI can be useful, especially if we are willing to look at the code and learn from it. Maybe we will learn a new way to do something or maybe we will find a new technique to apply. Still, maybe we find a bug in the produced code. The point is that it can be a helpful tool as long as we use it and do not take the output for granted; the code produced must be treated as our own code, meaning it should be tested and verified through our unit testing and quality assurance (QA) process. </p>
</div>
<div class="readable-text" id="p56">
<h3 class="readable-text-h3"><span class="num-string">2.3.2</span> Parsing an ACH file with Copilot</h3>
</div>
<div class="readable-text" id="p57">
<p>After seeing what ChatGPT has to offer us, let’s use Copilot to see whether it can get us closer. We first enter the following into an empty Python script:</p>
</div>
<div class="callout-container sidebar-container prompt-response-sidebar">
<div class="browsable-container listing-container" id="p58">
<img alt="" class="_idGenObjectAttribute-6 prompt-head-image" height="32" src="../Images/Prompt-Icon.png" width="33"/>
<div class="code-area-container">
<pre class="code-area"><code>	# Function to parse an ACH file</code></pre>
</div>
</div>
</div>
<div class="readable-text" id="p59">
<p>It does an okay job, but not quite what we wanted, so we try again with an updated prompt:</p>
</div>
<div class="callout-container sidebar-container prompt-response-sidebar">
<div class="browsable-container listing-container" id="p60">
<img alt="" class="_idGenObjectAttribute-6 prompt-head-image" height="32" src="../Images/Prompt-Icon.png" width="33"/>
<div class="code-area-container">
<pre class="code-area"><code>	# Write a class to parse an ACH file for each NACHA record type and return a list of transactions.</code></pre>
</div>
</div>
</div>
<div class="readable-text" id="p61">
<p>As we are typing, the “for each NACHA record type and return a list of transactions” is automatically populated. We then enter an expanded comment:</p>
</div>
<div class="callout-container sidebar-container prompt-response-sidebar">
<div class="browsable-container listing-container" id="p62">
<img alt="" class="_idGenObjectAttribute-6 prompt-head-image" height="32" src="../Images/Prompt-Icon.png" width="33"/>
<div class="code-area-container">
<pre class="code-area"><code>	# Write a class to parse an ACH file with separate functions for each NACHA record type and return a list of transactions.</code></pre>
</div>
</div>
</div>
<div class="readable-text" id="p63">
<p>This prompt gives us the following output, with the full listing available in copilot_ach_parse_with_functions.py.</p>
</div>
<div class="browsable-container listing-container" id="p64">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.4<span class="CharOverride-5"> </span>Copilot ACH parser</h5>
<div class="code-area-container">
<pre class="code-area">    def parse_ach_file(self):
        with open(self.ach_file, 'r') as f:
            for line in f:
                if line.startswith('1'): self.transactions
                         .append( 
<span class="CharOverride-7">➥</span> self.parse_ach_batch_header(line)) #1
                elif line.startswith('5'):
                    self.transactions
                      <span class="CharOverride-7">➥</span> .append(
self.parse_ach_batch_control(line))#2
                elif line.startswith('6'):
                    self.transactions
                       .append(self.parse_ach_entry_detail(line))
                elif line.startswith('7'):
                    self.transactions
                       .append(self.parse_ach_addenda_record(line))
                elif line.startswith('8'):                               
                    self.transactions
                      <span class="CharOverride-7">➥</span> .append( 
self.parse_ach_file_control(line)) #3
                else: #4
                    raise ValueError(
<span class="CharOverride-7">➥</span>'Invalid ACH record type') #5</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Incorrectly calls a parse_ach_batch_header routine when this is the file header record</span>
<br/>#2 
     <span class="CharOverride-6">The batch header record is being parsed incorrectly as a batch control record.</span>
<br/>#3 
     <span class="CharOverride-6">The batch control record is listed incorrectly as file control.</span>
<br/>#4 
     <span class="CharOverride-6">Missing an elif statement for file control records (type 9)</span>
<br/>#5 
     <span class="CharOverride-6">A ValueError is raised when we do not have a valid ACH record type.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p65">
<p>We can see that it created a class and functions to parse individual record types. However, we also see multiple problems:</p>
</div>
<ul>
<li class="readable-text" id="p66">Record type 1 is calling a parse routine for <code>parse_ach_batch_header</code>, whereas it should be parsed as a file header.</li>
<li class="readable-text" id="p67">Record type 5 is calling a parse routine for <code>parse_ach_batch_control</code>, whereas it should have been parsed as a batch header.</li>
<li class="readable-text" id="p68">Record type 8 is calling a parse routine for <code>parse_ach_file_control</code>, whereas it should have been parsed as a batch control.</li>
<li class="readable-text" id="p69">The file trailer record (record type 9) is missing.</li>
</ul>
<div class="readable-text" id="p70">
<p>So, while this code also gives us another viable template, it does not necessarily produce something right out of the box to use. One helpful thing that it does provide is code to raise a <code>ValueError</code> with <code>invalid</code> <code>ACH</code> <code>record</code> <code>type</code>, so we would certainly run into an error right away when we try to load a test ACH file as the missing type 9 should cause an error on any well-formatted ACH file.</p>
</div>
<div class="readable-text" id="p71">
<h3 class="readable-text-h3"><span class="num-string">2.3.3</span> Generative AI: Trust but verify</h3>
</div>
<div class="readable-text" id="p72">
<p>Certainly, both ChatGPT and Copilot are able to get us started with meaningful templates we can expand on later. However, they both have some problems generating the code, which highlights the importance of verification mentioned earlier. We must understand the produced code and not just take for granted that it is correct. This is especially important when we expect code to apply business rules and logic to the functions we want to generate. For instance, when using generative AI to assist in creating purely functional code—such as a button to submit a form or read a file—it will be immediately obvious if there is a syntax error or if it does not perform according to specifications, as it will not compile. However, if it is missing a record type or has some other problem, it could introduce bugs that are harder to find, especially if we don’t understand those business rules. We make this point multiple times only to drive home the importance of generative AI being a powerful tool but still only a tool. Think of the process of building a chair. We can build a chair with just a hand saw or we can have a shop full of the latest and greatest tools, but if we do not know how to use them, we will likely end up sitting on the floor.</p>
</div>
<div class="readable-text intended-text" id="p73">
<p>So, how do we go about verifying the code that generative AI produces for us? By using extreme programming (XP) development practices such as test-driven development (TDD). We previously mentioned the need for reliable high-quality software in FinTech. </p>
</div>
<div class="readable-text intended-text" id="p74">
<p>TDD boils down to the concept of writing tests before code by letting tests drive our development. One of the benefits is that we have highly testable code. We will use the TDD principles throughout this book and show various ways to automate our tests. Regardless of whether we decide to adopt a test-driven approach to our development practice, there are real benefits to thinking about how our code is tested. Questions such as the following are always considered when using a TDD approach:</p>
</div>
<ul>
<li class="readable-text" id="p75">Is this code that needs to be tested, or will we need to regression-test this code?</li>
<li class="readable-text" id="p76">How do I test this code?</li>
<li class="readable-text" id="p77">How will others understand this code?</li>
</ul>
<div class="readable-text" id="p78">
<p>The answers to these questions are usually found through unit tests, and when thinking about unit tests, we should be thinking about TDD.</p>
</div>
<div class="readable-text intended-text" id="p79">
<p>We can also make use of our Integrated Development Environment (IDE) and any available plugins it may come with. These tools may include customizable formatting options and default highlighting of syntax problems. As soon as our development team grows beyond just one person, there are real benefits to enforcing some standards in our code.</p>
</div>
<div class="readable-text intended-text" id="p80">
<p>Our company will likely provide us with the tools to use. These may help identify problems with generated code right away. Tools such as Snyk which can scan our code for vulnerabilities are discussed in chapter 3. At the very least, we want to ensure that the code meets our company’s policies and standards.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p81">
<h5 class="callout-container-h5 readable-text-h5">Reduce cognitive load with formatting and linters</h5>
</div>
<div class="readable-text" id="p82">
<p>Cognitive load can be interpreted as the amount of information we need to keep in our brains while coding. There are many ways to reduce cognitive load within your code. Providing consistency within the code helps reduce cognitive load. It also helps with scanning tools, onboarding, and avoiding errors.</p>
</div>
<div class="readable-text" id="p83">
<p>Developers have enough to worry about even without the concerns regarding code formatting, comments, and similar. If we believe the number of spaces (or tabs) to indent a line would not get anyone riled up, we are in for a rude awakening. Seemingly trivial formatting decisions or coding practices may cause heated debates. Hopefully, many problems have been put to rest by the adoption of opinionated formatters, such as black when using Python and linters when using SonarLint.</p>
</div>
<div class="readable-text" id="p84">
<p>We may find that legacy software in FinTech written in languages such as COBOL or RPG was constrained by line lengths of 80 or 132 characters and, in some flavors, required starting code in a specific column (specifically COBOL). Similar requirements are also present in RPG and other early languages. While modern languages have pretty much done away with those types of restrictions, developers quickly learned that maybe there was too much freedom. Today, many programming languages have various formatters that enforce some structure into our code, often forcing your code to adhere to a standard developed for the language. Whether it is Perl (perltidy), Go (gofmt), or JavaScript (Prettier), or Python (black), formatters are another tool we should investigate as soon as we start learning a new language.</p>
</div>
<div class="readable-text" id="p85">
<p>Linters play a similar role by ensuring our code stays clean and does not fall into common language pitfalls such as identifying unused imports, unused variables, invalid comparisons, and problematic casting, to name a few. SonarLint is a popular linter available for many languages and IDEs. It also provides integration into SonarQube, a product that helps identify and manage problems. Other linters are also available, such as ESLint when working with JavaScript or TypeScript. </p>
</div>
<div class="readable-text" id="p86">
<p>Both formatters and linters can be built into your IDE or are available through plugins within the IDE. So, it is not a big inconvenience to start using them. However, ensure that you are using something approved by the team and that it is configured correctly. These tools can also be helpful in making you a better programmer overall, as they often tell us why this is the best practice and how to avoid it. We often find ourselves reading why SonarLint has flagged something or looking up additional examples or further information on best practices because the linters flagged something.</p>
</div>
</div>
<div class="readable-text" id="p87">
<h2 class="readable-text-h2"><span class="num-string">2.4</span> Automated testing</h2>
</div>
<div class="readable-text" id="p88">
<p>Regardless of whether we are coding the initial script to parse the ACH file by hand or getting started with a generative AI tool, we want to ensure that we are using unit tests. We prefer a TDD approach and will often find that we favor it. However, we do not have to strictly subscribe to that approach to receive the benefits. We are looking for short development cycles, mixing testing and coding. We should have a pretty good idea at this point that parsing an ACH file properly is going to be somewhat complex task. However, reading a file and ensuring that we have all the lines is not an insurmountable task, and we should be able to achieve it easily enough. So, why not start with a unit test that ensures we received all the lines from the file?</p>
</div>
<div class="readable-text intended-text" id="p89">
<p>A continuing theme is the need for high-quality software and verifying our results, especially in the context of generated code. This section explores the use of unit testing with <code>pytest</code> to help validate both generated code and the code we built ourselves. We also discuss the need for smaller and faster feedback cycles while coding, and we will try to apply that to our code here as well. </p>
</div>
<div class="readable-text intended-text" id="p90">
<p>Even before we try to write tests for parsing individual fields from the record types, we may want to ask ourselves questions such as</p>
</div>
<ul>
<li class="readable-text" id="p91">Can I read a file?</li>
<li class="readable-text" id="p92">How many records are in the file?</li>
<li class="readable-text" id="p93">Can I parse a record of type 1? How about a record of type 5?</li>
</ul>
<div class="readable-text" id="p94">
<p>We start small with the initial steps and then go deeper into the actual functionality of our code. In the following sections, we will start with a well-formatted sample file and work our way through it by creating tests. Each section will illustrate the creation of a small unit test to validate our well-formatted file.</p>
</div>
<div class="readable-text" id="p95">
<h3 class="readable-text-h3"><span class="num-string">2.4.1</span> Testing the number of records read</h3>
</div>
<div class="readable-text" id="p96">
<p>We will test the number of records read from our ACH file before we start addressing any problems that we may have noticed in our generated code. This testing covers the first two bullet points we listed at the beginning of this section. Verifying the number of records may seem trivial, but it helps put us in the mindset of testing our code and helps verify that we are indeed accomplishing this critical task. Our unit test needs to verify the number of records from the file. We can get the record out by opening the file in most editors, or we can employ a command line to get the number of lines by using <code>wc</code> <code>-l</code> in Unix or a <code>Get-Content</code> and <code>Measure-Object</code> in PowerShell. If we are unsure how to get the number of lines from a file, we may want to ask generative AI if it has any ideas and maybe even learn a new trick or two!</p>
</div>
<div class="readable-text intended-text" id="p97">
<p>Depending on how we got here, our test may be failing because of one of those missing record types or because of some other error such as an incorrect file path, permissions, or any number of other reasons. Now, as an exercise, it would be good to work on getting this first test up and running before we continue with the code. Otherwise, we can just continue by using the sample code provided on GitHub.</p>
</div>
<div class="readable-text" id="p98">
<h3 class="readable-text-h3"><span class="num-string">2.4.2</span> Parsing the records</h3>
</div>
<div class="readable-text" id="p99">
<p>You can find information about the ACH layout at <a href="https://achdevguide.nacha.org/ach-file-overview"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/achdevguide.nacha.org/ach-file-overview</span></a>. Let’s recall some of the main aspects of the file format:</p>
</div>
<ul>
<li class="readable-text" id="p100">It is a fixed-width ASCII file.</li>
<li class="readable-text" id="p101">Records are 94 characters in length.</li>
<li class="readable-text" id="p102">Each line is known as a record.</li>
<li class="readable-text" id="p103">Each record contains fields that are at fixed positions.</li>
<li class="readable-text" id="p104">Order of records and fields matters.</li>
</ul>
<div class="readable-text" id="p105">
<p>This format makes processing and validating files more interesting. We do not have an XML Schema Definition that we can utilize. Nor do we have the freedom of formatting that XML and JSON provide. </p>
</div>
<div class="readable-text intended-text" id="p106">
<p>Although it has constraints compared to other file formats, it was in use before the other formats were born. It would be an interesting challenge for us to ensure we process the file correctly and handle some of the tasks in daily ACH processing. We create a new Python project in our IDE and use the response from ChatGPT 4 as our starting point.</p>
</div>
<div class="browsable-container listing-container" id="p107">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.5<span class="CharOverride-5"> </span>Starting point for our ACH parser</h5>
<div class="code-area-container">
<pre class="code-area">def parse_file_header(line):
    return {
        'record_type': 'File Header',
        'priority_code': line[1:3],
        'immediate_destination': line[3:13],
        'immediate_origin': line[13:23],
        # ... additional fields
    }

def parse_batch_header(line):
    return {
        'record_type': 'Batch Header',
        'service_class_code': line[1:4],
        'company_name': line[4:20],
        # ... additional fields
    }

def parse_entry_detail(line):
    return {
        'record_type': 'Entry Detail',
        'transaction_code': line[1:3],
        'receiving_dfi_id': line[3:11],
        'account_number': line[12:29],
        'amount': line[29:39],
        # ... additional fields
    }

def parse_addenda(line):
    return {
        'record_type': 'Addenda',
        # ... additional fields based on the specific addenda type
    }

def parse_batch_control(line):
    return {
        'record_type': 'Batch Control',
        # ... additional fields
    }

def parse_file_control(line):
    return {
        'record_type': 'File Control',
        # ... additional fields
    }

def parse_ach(filename):
    records = []

    parser_functions = {
        '1': parse_file_header,
        '5': parse_batch_header,
        '6': parse_entry_detail,
        '7': parse_addenda,
        '8': parse_batch_control,
        '9': parse_file_control
    }

    with open(filename, 'r') as file:
        lines = file.readlines()

        for line in lines:
            record_type = line[0]
            parser = parser_functions.get(record_type)

            if parser:
                records.append(parser(line))
            else:
                print(f"Unknown record type: {record_type} in line: {line}")
                continue

    return records


# Test the function with an ACH file
parsed_records = parse_ach('path_to_ach_file.txt')
for record in parsed_records:
    print(record)</pre>
</div>
</div>
<div class="readable-text" id="p108">
<p>We created a basic folder structure for the project consisting of</p>
</div>
<ul>
<li class="readable-text" id="p109"><code>ach_processor</code>—Where our Python module lives</li>
<li class="readable-text" id="p110"><code>docs</code>—Where any necessary documentation lives</li>
<li class="readable-text" id="p111"><code>tests</code>—Where our unit tests live</li>
<li class="readable-text" id="p112"><code>venv</code>—Our virtual environment (to keep our project and dependencies separated)</li>
<li class="readable-text" id="p113"><code>README.md</code>—A markdown document to get into more details about the project and structure</li>
<li class="readable-text" id="p114"><code>requirements.txt</code>—A list of required Python dependencies that can be used by a CI/CD pipeline to build the project</li>
</ul>
<div class="browsable-container listing-container" id="p115">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.6<span class="CharOverride-5"> </span>Project folder structure</h5>
<div class="code-area-container">
<pre class="code-area">ACH_Parser/
├─ ach_processor/
├─ docs/
├─ tests/
├─ venv/
├─ README.md
├─ requirements.txt</pre>
</div>
</div>
<div class="readable-text" id="p116">
<p>After setting up the project, we run the <code>black</code> command to format the source code. With PyCharm, the IDE was smart enough to see the package installed and prompted us to set up Black from within the IDE since <code>black </code>was supported out of the box. </p>
</div>
<div class="readable-text intended-text" id="p117">
<p>With that accomplished, we can begin working on parsing the ACH records. At this point, with our exploratory spike, we are only looking to simply parse the records. Input validation is an important aspect of processing any type of data as it is defensive coding.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p118">
<h5 class="callout-container-h5 readable-text-h5">Defensive coding</h5>
</div>
<div class="readable-text" id="p119">
<p>Defensive coding is a proactive approach to dealing with unanticipated input, errors, and general misuse that occur when users get their hands on your software. For instance, if you ask your user to enter a number between 1 and 5, they are likely to enter anything but the numbers 1, 2, 3, 4, or 5. You can expect them to enter a, b, %, 1231482, nonprintable characters, and a wide range of other inputs! </p>
</div>
<div class="readable-text" id="p120">
<p>The practices of input validation, error handling, fail-safe defaults, output sanitization, logging/monitoring, and static analysis are some aspects of defensive coding. As we move on with the project, we will keep these principles in mind.</p>
</div>
</div>
<div class="readable-text" id="p121">
<h3 class="readable-text-h3"><span class="num-string">2.4.3</span> File header record (type 1)</h3>
</div>
<div class="readable-text" id="p122">
<p>A file header record contains important information about the institution the file came from and what it is destined for. Some file details, such as creation date and time, can also help determine whether the file has been loaded before, although we will rely on hashing the contents of the file as well. </p>
</div>
<div class="readable-text intended-text" id="p123">
<p>A powerful feature of ChatGPT is the ability to remember conversations; if we are signed into ChatGPT, we can go in and ask it to expand the parsing of the <code>parse_file_header</code> routine. This will give us another good starting point, and then we can even go in and ask it to create a unit test for the header record as well. </p>
</div>
<div class="readable-text intended-text" id="p124">
<p>However, when we tried this approach, we ran into a few problems such as the file creation date being eight positions instead of six (it used a four-digit year). The record itself was not 94 bytes long, which also gave an error during parsing. We used the sample.ach file and that header record as an expected result and then ran the <code>pytest</code> against that.</p>
</div>
<div class="readable-text intended-text" id="p125">
<p>Let’s look at the unit test and break it down (listing 2.7). We start by defining the function name, and by convention, the name begins with <code>test_</code>, which helps identify the function as something for <code>pytest</code> to pick up and run.</p>
</div>
<div class="readable-text intended-text" id="p126">
<p>Next, we have our sample line that is going to be passed to the parse routine. We also use <code>expected_result</code>, which is defined as a dictionary. We could also embed this directly into our <code>assert</code> statement, but for clarity, it is often easier to break it. By using a dictionary, we also employ our IDE. For instance, PyCharm provides a nice comparison window if this test fails, where we can see where the difference is. We then define the parser and call the routine with our <code>sample_header</code>. </p>
</div>
<div class="readable-text intended-text" id="p127">
<p>Finally, we have an <code>assert</code>, which is where the actual check is done. If the result is not the same as the <code>expected_result</code>, we will see the error message. We can include as many <code>assert</code> statements as necessary. For instance, we may assert the response of an HTTP call was successful prior to checking fields that we expected to be returned.</p>
</div>
<div class="readable-text intended-text" id="p128">
<p>The subsequent parsing of other records will also follow this code pattern, so whether we code it by hand, copy/paste, or use generative AI, we should be able to come up with similar tests for the other record formats.</p>
</div>
<div class="browsable-container listing-container" id="p129">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.7<span class="CharOverride-5"> </span><code>pytest</code> for parsing a file header record</h5>
<div class="code-area-container">
<pre class="code-area">def test_parse_file_header():
    sample_header = "101 267084131 6910 
<span class="CharOverride-7">➥</span>001340402200830A094101DEST NAME 
              <span class="CharOverride-7">➥</span>ORIGIN NAME            XXXXXXXX" #1

    expected_result = {               #2
        "record_type_code": "1",       #2
        "priority_code": "01",         #2
        …                              #2
        "reference_code": "XXXXXXXX",  #2
    }                                  #2

    parser = AchFileProcessor() #3
    result = parser._parse_file_header(sample_header) #4
    assert result == expected_result, 
<span class="CharOverride-7">➥</span> f"Expected {expected_result}, but got {result}" #5</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Defines a record that we want to test the parser against</span>
<br/>#2 
     <span class="CharOverride-6">Defines a dictionary that contains the parsed fields</span>
<br/>#3 
     <span class="CharOverride-6">Creates an instance of our AchFileProcessor class</span>
<br/>#4 
     <span class="CharOverride-6">Calls the function to parse the file header and return a result. This method is meant to be private, but for ease of testing, we are accessing it directly.</span>
<br/>#5 
     <span class="CharOverride-6">Compares the returned result to the expected result; this causes pytest to throw an error if they do not match.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p130">
<p>We could certainly have told ChatGPT to create unit tests for us as well. As mentioned earlier, we are looking to “trust but verify” when it comes to using these tools. It may be possible to generate both the code and the tests, but given that we are also trying to understand ACH better, that may be counterproductive. For instance, if the tool generated a bad function for us to parse the file, it may also be likely to generate incorrect unit tests. We may end up with unit tests that appear to pass and validate the code only to find they are both wrong. When generating the code, we can understand it better by writing the unit tests ourselves (or generate the unit tests and write the code).</p>
</div>
<div class="readable-text intended-text" id="p131">
<p>Still, there are benefits to seeing what may be generated when asking for unit tests. We prompt ChatGPT with </p>
</div>
<div class="readable-text prompt" id="p132">
<p><strong class="prompt-head-image"><img alt="image" height="32" src="../Images/Prompt-Icon.png" width="33"/></strong> Given the python function below to parse a Nacha ACH File Header, please provide unit tests for it.</p>
</div>
<div class="readable-text" id="p133">
<p>We are presented with the following.</p>
</div>
<div class="browsable-container listing-container" id="p134">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.8<span class="CharOverride-5"> </span>ChatGPT generated <code>pytests</code></h5>
<div class="code-area-container">
<pre class="code-area">def test_parse_file_header_with_incorrect_length(self):
line = "101094000123"  # Truncated line
# Assuming your method raises a ValueError for incorrect input
with pytest.raises(ValueError):    #1
   self.parser._parse_file_header(line)

def test_parse_file_header_with_invalid_record_type(self):
line = "201 0940001234567890123200602161645A094101 
<span class="CharOverride-7">➥</span> Your Bank          Your Company       12345678"
# Assuming your parser validates the record type 
# and raises an exception for invalid types
with pytest.raises(ValueError):
   self.parser._parse_file_header(line)

def test_parse_file_header_with_extra_whitespace(self):
line = "1  094000123   4567890123 200602 1616A 09410 
<span class="CharOverride-7">➥</span> Your Bank          Your Company       12345678  "
# Assuming your parser can handle extra whitespaces gracefully
   expected = {
   "record_type_code": "1",
   "priority_code": " 0",
      "immediate_destination": "94000123",
   "immediate_origin": "4567890123",
   "file_creation_date": "20060",
   "file_creation_time": "2161",
   "file_id_modifier": "6",
   "record_size": "A 0",       #2
   "blocking_factor": "94",
   "format_code": "1",
      "immediate_destination_name": "Your Bank",
      "immediate_origin_name": "Your Company",
      "reference_code": "12345678",
   }
   # This test might fail based on the specific handling  
   # of spaces in your implementation 
   assert self.parser._parse_file_header(line) == expected

# Add more tests as needed for your implementation specifics</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">pytest.raises can be used to validate that specific errors are thrown, which is great for testing edge cases and exception conditions.</span>
<br/>#2 
     <span class="CharOverride-6">Extra white space caused invalid values to be used—most obvious was the record_size switching from 094 to “A 0”.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p135">
<p>We can see that these unit tests cover incorrect lengths of lines, invalid type, and extra whitespace. The invalid type and incorrect length lines may be useful tests, but we are unsure what happened with the extra whitespace test. It looks as if it was meant to add trailing space, but it also added spaces within the record itself. Since this is a fixed-length record, this will obviously lead to validation errors later. Still, it did provide us with some direction for additional tests when we get to that point. In addition, we saw how we may validate expected errors using the <code>pytest.raises</code> syntax.</p>
</div>
<div class="readable-text intended-text" id="p136">
<p>Of course, right now, we are following the happy path, not trying to focus too much on the input validation. We simply want to see whether we can get an ACH file parsed at this stage.</p>
</div>
<div class="readable-text" id="p137">
<h3 class="readable-text-h3"><span class="num-string">2.4.4</span> Batch header record (type 5)</h3>
</div>
<div class="readable-text" id="p138">
<p>As the name implies, batch header records indicate the start of a batch for a particular company. There can be multiple batches per file and all the entry and addenda records that are contained within the batch belong to that company.</p>
</div>
<div class="readable-text intended-text" id="p139">
<p>For the parsing of the batch header record, we can return to the IDE and let Copilot get us started, and then also ask it to help us define a <code>pytest</code> as well. We use the following prompt: </p>
</div>
<div class="readable-text prompt" id="p140">
<p><strong class="prompt-head-image"><img alt="image" height="32" src="../Images/Prompt-Icon.png" width="33"/></strong> # Define a test function to test parsing an ACH batch header record using <code>AchFileProcessor._parse_batch_header()</code>.</p>
</div>
<div class="readable-text" id="p141">
<p>We can review that in <code>test_parsing_file_header.py</code>. </p>
</div>
<div class="readable-text intended-text" id="p142">
<p>While the initial function to parse the batch header looks reasonable, the <code>pytest</code> itself needs more work in terms of the <code>sample_batch_header</code> that gets passed to the _<code>parse_batch_header</code>. The line is 181 characters long, which is more than the fixed 94 bytes required by the format. It looks as if the name of each field was put into the position of the test record. Also, on further inspection, we find that it does not include all the fields in the record format. However, when we began typing the name of the field, we were impressed to see the field was populated and used the data from the sample, although with mixed results.</p>
</div>
<div class="readable-text intended-text" id="p143">
<p>Still, it is a very impressive result and more than enough to get us started and complete a passing test using the sample.ach file we have been working with. After working on the parsing routine and the expected result, we were able to pass another test.</p>
</div>
<div class="readable-text intended-text" id="p144">
<p>Hopefully, you were able to parse this record and add a unit test on your own. If not, no worries—there are still more types ahead and plenty of chances to give it a try! Even though it might be jumping the gun, we also want to look at behavior-driven development (BDD) and show a few sample tests that could be used if we were looking into that type of approach. </p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p145">
<h5 class="callout-container-h5 readable-text-h5">What is behavior-driven development?</h5>
</div>
<div class="readable-text" id="p146">
<p>Behavior-driven development is an approach to developing software where we create tests around the behavior of the software, and then use them as part of the acceptance criteria for determining whether a project is complete. What makes this type of testing unique is that all stakeholders work closely together to develop these scenarios. Formalizing these user requirements helps ensure that we build a project that meets users’ expectations.</p>
</div>
<div class="readable-text" id="p147">
<p>Each BDD test is described by a series of <code>given</code>/<code>when</code>/<code>then</code> statements that directly relate to desired functionality. We can run these tests from our IDE just like we did with our unit tests. The difference is just in the approach to designing the tests and the level at which they execute.</p>
</div>
</div>
<div class="readable-text" id="p148">
<p>As we progress through the project, we will look to expand our BDD testing; for now, we create a very simple test that confirms we have successfully parsed the record type field. While we have a unit test that confirms this already, it will make for a simple introduction to setting up a BDD-style test.</p>
</div>
<div class="readable-text intended-text" id="p149">
<p>We first define a feature file, which identifies the feature that we are testing along with various test scenarios. The feature file is written in a human-readable language so that anyone can make sense of it. The <code>batch_header.feature</code> is included in the code and shown in the next listing.</p>
</div>
<div class="browsable-container listing-container" id="p150">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.9<span class="CharOverride-5"> </span>Parsing an ACH batch header</h5>
<div class="code-area-container">
<pre class="code-area">Feature: Parsing a Nacha Batch Header

  Scenario: We have a record type of 5
    When We parse the batch header 
<span class="CharOverride-7">➥</span>"5200Company name    DiscretionaryData   Company
 IDARCComp desc 0216232302160471061000010000001"
    <span class="CharOverride-7">➥</span> Then The record type should be 5</pre>
</div>
</div>
<div class="readable-text" id="p151">
<p>We define the feature and then a simple scenario of “We have a record type 5.” The scenario can be named anything, but obviously, we want to convey what this test is going to do. The <code>when</code> and <code>then</code> statements are where the real work happens—in our example, <em>when</em> we are parsing the header record, and <em>then</em> we want to ensure we have a record type of 5.</p>
</div>
<div class="readable-text intended-text" id="p152">
<p>Once we have that information, our next step is to wire the feature file together with what are known as <em>step definitions</em>. This is how we translate the human-readable text into something that we can execute with <code>pytest</code>. For brevity, we will show a sample of the “then” step definition. The rest of the code is available in <code>test_batch_header.py</code> for you to browse.</p>
</div>
<div class="browsable-container listing-container" id="p153">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.10<span class="CharOverride-5"> </span>Behavior-driven development testing in Python</h5>
<div class="code-area-container">
<pre class="code-area">@then(parsers.parse("the record type should be {type_5}"))
def then_record_type_code_should_be(record, type_5):
    assert (
        record["record_type_code"] == type_5
    ), f"Expected {type_5}, but got {record['record_type_code']}"</pre>
</div>
</div>
<div class="readable-text" id="p154">
<p>We decorate the function with <code>@then</code> and parse the text string. Within that string, we have <code>{type_5}</code>. This is a dynamic value that will be pulled in from the feature file. So, while we used “the record type should be 5,” the 5 becomes a parameter to the function, and we could easily create other scenarios where we test other values. We then define the function, passing it the value we parse, a record (which is a Python fixture—more on that later), and an <code>assert</code> statement that we have seen before. This can then be run along with any other test, and we are done coding when this test passes. Of course, we already coded this, but in later chapters, we will work to define these scenarios beforehand, when we work on features. We could potentially come up with additional scenarios for each field or simply expand the “then” portion of our test to include multiple <code>then</code> statements for each field.</p>
</div>
<div class="readable-text" id="p155">
<h2 class="readable-text-h2"><span class="num-string">2.5</span> Entry detail record (type 6)</h2>
</div>
<div class="readable-text" id="p156">
<p>The entry detail records contain individual transaction data, including the account number and amount to credit or debit the account. Keep in mind that the parsing of the records can vary slightly, based on the type of records being processed. The batch header record contains the type of entry records present in the batch, and this is known as the standard entry class (SEC) code.</p>
</div>
<div class="readable-text intended-text" id="p157">
<p>The parsing of an entry detail record proved more challenging for ChatGPT and in our formulation of the prompts for it. Initially, we tried the expanded prompt </p>
</div>
<div class="readable-text prompt" id="p158">
<p><strong class="prompt-head-image"><img alt="image" height="32" src="../Images/Prompt-Icon.png" width="33"/></strong> Fully define the _<code>parse_entry_detail</code> method and provide a <code>pytest</code> to validate it. </p>
</div>
<div class="readable-text" id="p159">
<p>While ChatpGPT did provide a method and <code>pytest</code>, it failed to meaningfully parse the record. We tried again with </p>
</div>
<div class="readable-text prompt" id="p160">
<p><strong class="prompt-head-image"><img alt="image" height="32" src="../Images/Prompt-Icon.png" width="33"/></strong> Please the full layout for the NACHA Type 6 record.</p>
</div>
<div class="readable-text" id="p161">
<p>Then ChatGPT started calling the type 6 record an addenda record and parsing it with the fields associated with that record. We realized that there are different types of entry details records (CCD, CTX, PPD, etc.), so we tried to redirect with </p>
</div>
<div class="readable-text prompt" id="p162">
<p><strong class="prompt-head-image"><img alt="image" height="32" src="../Images/Prompt-Icon.png" width="33"/></strong> Please use the full layout for the NACHA Type 6 CCD record.</p>
</div>
<div class="readable-text" id="p163">
<p>While the system correctly identified the type as a cash concentration disbursement, it still referred to the entry as an addenda record.</p>
</div>
<div class="readable-text intended-text" id="p164">
<p>Using Copilot produced better results, populating the correct field names as we typed and allowing us to quickly create a template that took just a little updating to make the test pass. However, the underlying theme we have seen so far is that while both tools are powerful, they need us to validate the results and not plug them in blindly. Thus, we can see that knowing the domain is important if we want to be able to validate our results.</p>
</div>
<div class="readable-text" id="p165">
<h3 class="readable-text-h3"><span class="num-string">2.5.1</span> Addenda record (type 7)</h3>
</div>
<div class="readable-text" id="p166">
<p>The addenda record contains additional payment-related information that applies to the entry detail record. There may be multiple addenda records per entry detail record.</p>
</div>
<div class="readable-text intended-text" id="p167">
<p>When Copilot was prompted with </p>
</div>
<div class="readable-text prompt" id="p168">
<p><strong class="prompt-head-image"><img alt="image" height="32" src="../Images/Prompt-Icon.png" width="33"/></strong> Define a function to parse a Nacha Addenda Record.</p>
</div>
<div class="readable-text" id="p169">
<p>it produced several code suggestions. The following listing shows the closest valid suggestion. It uses all the required fields, but the offsets are not quite right.</p>
</div>
<div class="browsable-container listing-container" id="p170">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.11<span class="CharOverride-5"> </span>Parsing function for an addenda record</h5>
<div class="code-area-container">
<pre class="code-area">def parseAddendaRecord(record):
    # Create a dictionary to hold the parsed record
    parsedRecord = {
        'recordType': record[0:1],
        'typeCode': record[1:2],
        'paymentRelatedInformation': record[2:80],
        'addendaSequenceNumber': record[80:87],
        'entryDetailSequenceNumber': record[87:94]
    }

    return parsedRecord</pre>
</div>
</div>
<div class="readable-text" id="p171">
<p>In addition to the general parsing being incorrect, we would prefer to use snake case for the dictionary keys. We can try refining the prompt again by defining a function to parse a Nacha addenda record using a dictionary and snake case for the keys. This provides the keys with the formatting we prefer, but we still need to update the offsets.</p>
</div>
<div class="browsable-container listing-container" id="p172">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.12<span class="CharOverride-5"> </span>Parsing function for an addenda record using the snake case</h5>
<div class="code-area-container">
<pre class="code-area">def parseAddendaRecordSnake(record):
    # Create a dictionary to hold the parsed record
    parsedRecord = {
        'record_type': record[0:1],
        'type_code': record[1:2],
        'payment_related_information': record[2:80],
        'addenda_sequence_number': record[80:87],
        'entry_detail_sequence_number': record[87:94]
    }

    return parsedRecord</pre>
</div>
</div>
<div class="readable-text" id="p173">
<p>To get the correct parsing, we need to adjust <code>type_code</code>, <code>payment_related_information</code>, and <code>addenda_sequence_number</code>. The following listing shows the updated return statement that could be used.</p>
</div>
<div class="browsable-container listing-container" id="p174">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.13<span class="CharOverride-5"> </span>Updated return statement with corrected fields</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">…    
return {
   "record_type_code": record[0],
   "addenda_type_code": record<strong>[1:3]</strong>,
   "payment_related_information": record<strong>[3:83]</strong>,
   "addenda_sequence_number": record<strong>[83:87]</strong>,
   "entry_detail_sequence_number": record[87:94],
}
…</pre>
</div>
</div>
<div class="readable-text" id="p175">
<h3 class="readable-text-h3"><span class="num-string">2.5.2</span> Batch control record (type 8)</h3>
</div>
<div class="readable-text" id="p176">
<p>The batch control record is the trailer record for each batch and is a required record. We use fields from the record, such as total debit/credit amount and the record count, to validate that we received the correct batch contents. The following listing shows that Copilot took a different approach to parsing this record.</p>
</div>
<div class="browsable-container listing-container" id="p177">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.14<span class="CharOverride-5"> </span>Copilot parsing a batch control record</h5>
<div class="code-area-container">
<pre class="code-area">def parse_ach_batch_control_record(record):
# Define a dictionary to hold the parsed data
    parsed_record = {}

    # Define the fields in the record
    fields = [
        "record_type",
        "service_class_code",
        "entry_count",
        "entry_hash",
        "total_debit_entry_dollar_amount",
        "total_credit_entry_dollar_amount",
        "company_identification",
        "message_authentication_code",
        "reserved",
        "originating_dfi_identification",
        "batch_number"
    ]

    # Define the field lengths
    field_lengths = [
        1, # record_type
        3, # service_class_code
        6, # entry_count
        10, # entry_hash
        12, # total_debit_entry_dollar_amount
        12, # total_credit_entry_dollar_amount
        10, # company_identification
        19, # message_authentication_code
        6, # reserved
        8, # originating_dfi_identification
        7 # batch_number
    ]

    # Define the field start positions
    field_start_positions = [0]
    for field_length in field_lengths:
        field_start_positions.append(field_start_positions[-1] + field_length)

    # Parse the fields
    for i in range(len(fields)):
        field = fields[i]
        start_position = field_start_positions[i]
        end_position = field_start_positions[i + 1]
        parsed_record[field] = record[start_position:end_position]

    # Return the parsed record
    return parsed_record</pre>
</div>
</div>
<div class="readable-text" id="p178">
<p>This code looks a bit of overengineered because the nature of this widely used fixed-position file format means that the field positions will not be changing. As a matter of personal preference, we like to see the actual offsets being used, as shown listing 2.12. The offsets will also make our job easier when dealing with errors in parsing a record. Having the field as <code>'entry_detail_sequence_number':</code> <code>record[87:94]</code> means we know where the field <code>entry_detail_sequence_number</code> begins and ends. We are also willing to allow these magic numbers to exist in the code because they are limited to this specific area and not sprinkled throughout the code. Of course, we could also create variables named <code>BEGIN_ENTRY_DETAIL_SEQUENCE_NUMBER_POS</code> and <code>END_ENTRY_DETAIL_SEQUENCE_NUMBER_POS</code> and use them if we find a compelling reason. Now, let us take a look at parsing the file trailer record.</p>
</div>
<div class="readable-text" id="p179">
<h3 class="readable-text-h3"><span class="num-string">2.5.3</span> File trailer record (type 9)</h3>
</div>
<div class="readable-text" id="p180">
<p>The final record in an ACH file is the file trailer record (also known as a file control record). The file trailer record provides fields such as batch count and entry/addenda count we use to validate the file was received correctly. Note that the format required the number of records to be a multiple of 10. So, you may find files or software that will pad created ACH files out with records that consist of all 9s. However, most software does not require this to be done anymore.</p>
</div>
<div class="readable-text intended-text" id="p181">
<p>In the following listing, we are back to Copilot parsing the records as we would expect. The fields were all cast integers.</p>
</div>
<div class="browsable-container listing-container" id="p182">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.15<span class="CharOverride-5"> </span>Parsing the file trailer record</h5>
<div class="code-area-container">
<pre class="code-area">def parse_ach_trailer_record(record):
    return {
        "record_type": record[0],
        "batch_count": int(record[1:7]),
        "block_count": int(record[7:13]),
        "entry_count": int(record[13:21]),
        "entry_hash": int(record[21:31]),
        "total_debit_amount": int(record[31:43]),
        "total_credit_amount": int(record[43:55]),
    }</pre>
</div>
</div>
<div class="readable-text" id="p183">
<p>While this code parses the records correctly, we are missing the last field, which is marked as reserved. So, while it may not be necessary at this time, we may still want to consider including it just for the sake of completeness.</p>
</div>
<div class="readable-text intended-text" id="p184">
<p>We may also want to create a sample BDD test because, conceivably, subject matter experts (SMEs) may provide us with specific use cases for parsing this record (or any of these records). A BDD style test may look like the following listing.</p>
</div>
<div class="browsable-container listing-container" id="p185">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.16<span class="CharOverride-5"> </span>BDD style test for type 9—file trailer record</h5>
<div class="code-area-container">
<pre class="code-area">Feature: Parsing a Nacha File Trailer

  Scenario: We have a record type of 9
     Given the File Trailer Record "9000010000010000000740198019800000000007825000114611480"
     When We parse the file trailer
     Then the record type should be 9
     And the batch count should be 10
     And the block count should be 1
     And the entry count should be 74
     And the entry hash should be 0198019800
     And the total debit amount should be 78.25
     And the total credit amount should be 1146114.80</pre>
</div>
</div>
<div class="readable-text" id="p186">
<h3 class="readable-text-h3"><span class="num-string">2.5.4</span> Passed!</h3>
</div>
<div class="readable-text" id="p187">
<p>Wow, we made it! That was a whirlwind of coding and testing. Even with generative AI helping out, that was a lot to take in. Let us now recap what we have just accomplished. We started using small development cycles to build unit tests to validate the parsing of the various ACH record types. It is important to understand that we started by breaking the program created by generative AI into functions (we had asked ChatGPT to do this for us before we started). Having generative AI create functions allowed us to create unit tests more easily for each record type. Otherwise, we would have had to figure out a way to determine if the records were parsed correctly and check them after the file was loaded.</p>
</div>
<div class="readable-text intended-text" id="p188">
<p>Each time, we started by creating a unit test that should fail and then coded just enough to make it pass. At this point, we should be relatively familiar with the process and ready to apply the same concept to other parts of our project.</p>
</div>
<div class="readable-text" id="p189">
<h2 class="readable-text-h2"><span class="num-string">2.6</span> The not-so-happy path</h2>
</div>
<div class="readable-text" id="p190">
<p>Congratulations! We just finished parsing what is very likely our first ACH file. We concentrated on what is sometimes referred to as “the happy path.” This is where everything goes as expected, without throwing any kind of errors. We used a single well-formatted ACH file throughout our parsing to illustrate the process.</p>
</div>
<div class="readable-text intended-text" id="p191">
<p>We should now also consider the not-so-happy path, which is probably what we are more likely to encounter in our day-to-day coding. Our not-so-happy path will cover some of the problems that can occur when loading a file. There are scenarios where the file or a batch may be rejected or where an entry can trigger a rejection. We will examine exceptions and handling/recovering from problems with ACH files further in chapter 9. For now, we just want to touch on some of the possibilities.</p>
</div>
<div class="readable-text intended-text" id="p192">
<p>We will identify some of the possible rejection scenarios and provide sample ACH files and <code>pytests</code> to code for them. When a file is rejected, we often must go back to the originator to request a new one. If any transactions have posted, they may need to be reversed as part of the rejection process. For now, we are focusing more on identifying bad files than recovering from them. Of course, we will provide a finished example that addresses the <code>pytests</code>, if you want to skip ahead. Obviously, we would encourage you to work through these scenarios as the particular scenarios we have chosen do not require extensive knowledge of ACH processing.</p>
</div>
<div class="readable-text intended-text" id="p193">
<p>We will also be adding further validation later, as the project expands. For now, we are just expanding our proof of concept.</p>
</div>
<div class="readable-text" id="p194">
<h3 class="readable-text-h3"><span class="num-string">2.6.1</span> File rejection</h3>
</div>
<div class="readable-text" id="p195">
<p>ACH files can be rejected when formatted incorrectly. Remember that the order of the records is important. An ACH file consists of batches, and each batch contains entry and addenda records. Both a batch and the entire file have trailer records. All the records should be 94 characters long. So, for the first scenario, we want to tackle dealing with a file where records may not be the correct length.</p>
</div>
<div class="readable-text intended-text" id="p196">
<p>Why would a file be produced with records shorter than 94 bytes? Before SFTP (Secure File Transfer Protocol) became common, we would encounter this when ftp was set to truncate trailing spaces. While ftp is not as prevalent as before, it could still be used internally to transfer files, so the original use case may be valid. In addition, files may be routed and retransmitted or even created/updated on someone’s computer. As banks merge and acquire each other, these file problems may still pop up. Since the Nacha spec requires 94-byte records, we will seek to enforce that. We have included ACH_Parser_v3 containing empty unit tests to help us validate our changes.</p>
</div>
<div class="readable-text intended-text" id="p197">
<p>For each of these challenges, we expect the parser to accumulate a list of errors. This list should hopefully keep the parsing code relatively simple because we are not worried about input errors at this point. This approach also has the added benefit of being able to validate the expected results in our unit tests. If we know our file has two short lines, we should also expect two of those error messages. For now, we will only log an error message if it is a string, but you may expand your project or choose another approach.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p198">
<h5 class="callout-container-h5 readable-text-h5">Code challenge; benefit 1</h5>
</div>
<div class="readable-text" id="p199">
<p>We started with a relatively simple program to parse our ACH file. Going back and handling these changes will help us gather some real-world experience because we are likely going to be maintaining and updating existing code more than writing code from the ground up.</p>
</div>
<div class="readable-text" id="p200">
<p>The relatively simple change to check for a record length forces us to deal with exceptions and think about how we might want to identify, format, and store them. It also presents us with some choices in how we code this: Do we continue to store this unparsed record along with the other records? If not, where does it go, and how does a user know which record had an error?</p>
</div>
<div class="readable-text" id="p201">
<p>Seemingly mundane choices can sometimes have a significant influence down the road. So, this is just something to keep in mind and watch for as we work through the program.</p>
</div>
</div>
<div class="readable-text" id="p202">
<h3 class="readable-text-h3"><span class="num-string">2.6.2</span> Batch rejection</h3>
</div>
<div class="readable-text" id="p203">
<p>Individual batches may also be rejected from a file, and one reason is that the trace numbers are not ascending. A trace number appears on each entry detail record (type 6). As the name implies, these trace numbers provide a way to identify an ACH transaction within a batch. The first eight digits of a trace number are the routing number of the Originating Depository Financial Institution (ODFI)—in other words, what bank or financial institution the transaction came from—and the last seven digits of the trace number are in ascending order (but not necessarily sequential).</p>
</div>
<div class="readable-text intended-text" id="p204">
<p>A unique trace number provides a means to reconcile and report on these ACH transactions and the ability to trace a transaction through the payment system for both regulatory and compliance reasons. We can now expand the ACH parser to consider these trace numbers. Again ACH_Parser_v3 has some unit tests that we can use to verify whether our program parsed the file correctly.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p205">
<h5 class="callout-container-h5 readable-text-h5">Code challenge; benefit 2</h5>
</div>
<div class="readable-text" id="p206">
<p>This challenge gets a little more complicated in how we will choose where and when to handle these exceptions. We started off with our functions being named _<code>parse_entry_detail</code>. If we choose to update the code to handle verification in that parse routine, will we update that function name since it is no longer just parsing? Will one routine call another, or will we call two routines or just use one routine? Do we parse the record first and then check the trace number, or do we check it before parsing the whole record? </p>
</div>
<div class="readable-text" id="p207">
<p>Sometimes, we want to make changes with surgical precision for both time and complexity reasons. Other times, we may opt for a shotgun approach when there are multiple things that must be accomplished. Either way, you should still be working in short cycles, making sure to test often.</p>
</div>
</div>
<div class="readable-text" id="p208">
<h3 class="readable-text-h3"><span class="num-string">2.6.3</span> Entry rejection</h3>
</div>
<div class="readable-text" id="p209">
<p>An entry may be rejected if the addenda flag is not consistent with the existence of an addenda record. The entry detail record contains a flag indicating whether the next record is an addenda record. Addenda records include additional information for ACH transactions and are sometimes required for specific SEC codes. With only 94 bytes to work with, it is sometimes necessary to have addenda records to pass additional information about the transaction along.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p210">
<h5 class="callout-container-h5 readable-text-h5">Code challenge; benefit 3</h5>
</div>
<div class="readable-text" id="p211">
<p>Coding this challenge requires us to look ahead or look behind as we need to be able to determine whether we expect an addenda record. This goes back to making decisions and then deal with them later. </p>
</div>
<div class="readable-text" id="p212">
<p>For instance, the existing code had read all the lines and then used a <code>for-each</code> loop to iterate through them. Having the <code>for-each</code> loop is handy, but now we potentially need a way to index our list of lines. If we need to conserve memory because we expect large ACH files, we may not want to read all the lines in, and therefore, we would have to take another approach to finding an addenda record.</p>
</div>
<div class="readable-text" id="p213">
<p>This is all part of the software development process. Thinking about and planning our changes will help us address some of these challenges and hopefully future-proof our code.</p>
</div>
<div class="readable-text" id="p214">
<p>When we come across a bad design choice that we or a co-worker have made, learn from it. Even if it is annoying and makes you rework a lot of code, you can take something away from the experience!</p>
</div>
</div>
<div class="readable-text" id="p215">
<h2 class="readable-text-h2"><span class="num-string">2.7</span> Interpreting the code</h2>
</div>
<div class="readable-text" id="p216">
<p>Depending on your experience with Python, you may have some questions about the code that was produced as part of this example. The following sections examine the code in more detail to provide additional insight into the Python code we have written, covering the Python <code>switch</code> statement, type hints, and secure coding.</p>
</div>
<div class="readable-text" id="p217">
<h3 class="readable-text-h3"><span class="num-string">2.7.1</span> Where’s my switch statement?</h3>
</div>
<div class="readable-text" id="p218">
<p>There are six record types for ACH that we need to parse. If you have some programming experience, you have likely come across the <code>if</code>/<code>if</code> <code>else</code>/<code>else</code> construct for flow control. In Python, we would see this as </p>
</div>
<div class="browsable-container listing-container" id="p219">
<div class="code-area-container">
<pre class="code-area">if condition1:
elif condition2:
else:</pre>
</div>
</div>
<div class="readable-text" id="p220">
<p>At some point, we probably also coded rather large <code>if</code> statements with multiple conditions before someone introduced you to a <code>switch/case</code> statement. Early in Python (circa 2006), support for <code>switch</code>/<code>case</code> statements was debated and finally rejected. However, as of Python 3.10, there is support for the match statement (<span class="Hyperlink">h</span><a href="https://peps.python.org/pep-0634/"><span class="Hyperlink">ttps:</span><span class="Hyperlink">/</span><span class="Hyperlink">/peps.python.org/pep-0634/</span></a>), which provides the means to create a <code>switch</code> statement, as shown in the next listing. </p>
</div>
<div class="browsable-container listing-container" id="p221">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.17<span class="CharOverride-5"> </span>Creating a <code>switch</code> statement using <code>match</code></h5>
<div class="code-area-container">
<pre class="code-area">parsed_record = match record_type: #1
     case '1': #2
         self._parse_file_header(line)
…
     case '7':
            self._parse_addenda(line)
…
     case _: #3
            print(f"Unknown record type: {record_type} in line: {line}")
            continue</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Uses the match keyword to create cases for the record_type field</span>
<br/>#2 
     <span class="CharOverride-6">Each condition has </span>
<span class="CharOverride-6">a case statement.</span>
<br/>#3 
     <span class="CharOverride-6">The default case is identified </span>
<span class="CharOverride-6">with an underscore.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p222">
<p>With millions of lines of Python code written before the <code>match</code> construct became available, generative AI is likely to show you the <code>if</code>/<code>elif</code> or another common practice of creating a Dictionary to store the choices as was done in the sample program.</p>
</div>
<div class="browsable-container listing-container" id="p223">
<h5 class="listing-container-h5 browsable-container-h5">Listing 2.18<span class="CharOverride-5"> </span>Using a Dictionary</h5>
<div class="code-area-container">
<pre class="code-area">parser_functions = {                       #1
            "1": self._parse_file_header,   #1
            "5": self._parse_batch_header,  #1
            "6": self._parse_entry_detail,  #1
            "7": self._parse_addenda,       #1
            "8": self._parse_batch_control, #1
            "9": self._parse_file_control,  #1
        }                                   #1
…
                parser = parser_functions.get(record_type) #2
…
                    self.records.append(parser(line)) #3</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-6">Defines a Dictionary of functions that can be called</span>
<br/>#2 
     <span class="CharOverride-6">Retrieves the function from the Dictionary based on the record_type</span>
<br/>#3 
     <span class="CharOverride-6">Calls the parser for the given line and appends the results to the records variable</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p224">
<p>This code declares the functions for each type and calls the appropriate function. One thing that would make us favor another approach is that we cannot see whether the parameters should be passed to the function. We may not even be able to tell if they are functions. One way to handle this is using type hints.</p>
</div>
<div class="readable-text" id="p225">
<h3 class="readable-text-h3"><span class="num-string">2.7.2</span> Type hints</h3>
</div>
<div class="readable-text" id="p226">
<p>Type hints have been around since Python 3.5 and were defined in <a href="https://peps.python.org/pep-0484"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/peps.python.org/pep-0484</span></a>. While Python uses duck typing, the addition of type hints can help make the code more maintainable. In our opinion, it goes back to having to choose between freedom to code and the code longevity. When writing Python code, it is great not to be constrained by static typing; instead, we can focus more on the code. However, as more Python code comes into existence, or when we must start looking at other people’s code, we want some of those guides. So, while Python does not enforce type hints at runtime, there are tools that can be used to do static type checking based on these type hints, as well as just the benefits of documentation.</p>
</div>
<div class="readable-text intended-text" id="p227">
<p>We also wonder whether the popularity of Python and the migration of developers to it from other languages have also brought some of their baggage. We believe these additions to the language are important, and as they have gone through the Python Enhancement Proposal (PEP) process, the community agrees. Of course, our backgrounds are in statically typed languages, so these make sense. If we came from LISP or Scheme, would we want to see a bunch of parentheses added to the language?</p>
</div>
<div class="readable-text intended-text" id="p228">
<p>Our original problem with the dictionary approach to flow control was that we did not have a way to tell what parameters could be passed to the functions we were calling. We can update the <code>parser_functions</code> to use type-hinting:</p>
</div>
<div class="browsable-container listing-container" id="p229">
<div class="code-area-container">
<pre class="code-area">parser_functions: Dict[str, Callable[[str], Dict[str, str]]] = {</pre>
</div>
</div>
<div class="readable-text" id="p230">
<p>The variable <code>parser_functions</code> is now defined as a Dictionary that contains a string (<code>str</code>) for the record type and a <code>Callable</code> that represents the function being called. The <code>Callable</code> takes a list of parameters, and in this case, we see it takes one string that is denoted by <code>[str]</code> and that it returns a dictionary of strings, which is our parsed record.</p>
</div>
<div class="readable-text intended-text" id="p231">
<p>After seeing the type hint for this, maybe we decide to rewrite our code to take advantage of one of those other constructs because that seems confusing! By embracing the use of type hints, we could then move to static type checkers such as mypy, Pyright, and Pyre. In our opinion, static type checking is a must-have for enterprise applications where there are large teams or the project is long-lived (and we assume they will be). Other developers diving into the code base for the first time or after a hiatus on the project will find them immensely helpful. Of course, Python is going to remain a dynamically typed language (see <a href="https://mng.bz/oKEM"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/mng.bz/oKEM</span></a>), but the proliferation of tools and their adoption should show that there is at least some benefit to type checking.</p>
</div>
<div class="readable-text" id="p232">
<h3 class="readable-text-h3"><span class="num-string">2.7.3</span> Secure coding</h3>
</div>
<div class="readable-text" id="p233">
<p>There has been concern that generative AI may not be producing code that is secure or code that is even good. This is not only true for generative AI but also for humans: we all make mistakes. Going back to our tool analogy, we need to remember that generative AI is just another tool we should be using, which is why we advocate the use of formatting and linters to help identify problems within our code.</p>
</div>
<div class="readable-text intended-text" id="p234">
<p>Corporations use a number of tools available on the market to scan their code looking for flaws and security holes. These tools include Fortify on Demand, Veracode, Snyk, and Amazon’s CodeWhisperer. The primary goal of this software is to look for insecure coding patterns. They often use the OWASP 10, SANS Top 25, and other lists as guides to the problems they identify.</p>
</div>
<div class="readable-text intended-text" id="p235">
<p>Many times, these are incorporated into a CI/CD pipeline; however, we also have options for handling them inside our IDE as well. Since The Fantastic Fintech Company uses JetBrains, we can take advantage of some of their included features. For instance, in our requirements.txt for our Python project, PyCharm will detect vulnerabilities in our dependencies (see figure 2.5). We can see the Common Vulnerabilities and Exposures (CVE) ID and a short description of the vulnerability.</p>
</div>
<div class="browsable-container figure-container" id="p236">
<img alt="A screenshot of a computer error  Description automatically generated" height="143" src="../Images/CH02_F05_Kardell.png" style="width: 100%; max-width: max-content;" width="788"/>
<h5 class="figure-container-h5"><span class="">Figure 2.5</span><span class=""> </span><span class="">An example dependency </span></h5>
</div>
<div class="readable-text" id="p237">
<p>By clicking More actions, we can simply choose to update to a newer version, as shown in figure 2.6. Of course, this action would require further application testing, but it is certainly nice to be alerted to potential problems before our code even makes it to the CI/CD pipeline.</p>
</div>
<div class="browsable-container figure-container" id="p238">
<img alt="A screenshot of a computer error  Description automatically generated" height="170" src="../Images/CH02_F06_Kardell.png" style="width: 100%; max-width: max-content;" width="443"/>
<h5 class="figure-container-h5">Figure 2.6 Options to handle vulnerability</h5>
</div>
<div class="readable-text" id="p239">
<p>Chances are most companies have either adopted a static analysis tool or are currently evaluating them. Having the ability to allow developers to view and troubleshoot problems directly in the IDE is another way to boost productivity.</p>
</div>
<div class="readable-text" id="p240">
<h2 class="readable-text-h2">Summary</h2>
</div>
<ul>
<li class="readable-text" id="p241">We explored how to incorporate generative AI into our development workflow, learning what to ask (prompt engineering) and how to clarify our intent (problem formulation).</li>
<li class="readable-text" id="p242">We focused on modernizing an ACH system running on legacy mainframe architecture using metrics such as release cadence and defect backlog.</li>
<li class="readable-text" id="p243">We utilized ChatGPT and GitHub Copilot to understand ACH file layouts better while ensuring that no confidential data is exposed.</li>
<li class="readable-text" id="p244">ACH network facilitates seamless money transfers between banks, and it is commonly used for transactions such as payroll and bill payment.</li>
<li class="readable-text" id="p245">ACH files are fixed-width ASCII files with specific record types that require careful parsing of file header, batch header, entry details, addenda, batch control, and file trailer records.</li>
<li class="readable-text" id="p246">ACH parsing can be validated using unit tests with TDD to obtain reliable, high-quality software.</li>
<li class="readable-text" id="p247">Linters and formatters such as SonarLint and black can be used to enforce coding standards and reduce cognitive load.</li>
<li class="readable-text" id="p248">Scenarios in which ACH files may have errors can be handled using robust code that accounts for unexpected inputs and edge cases.</li>
<li class="readable-text" id="p249">Type hints can be implemented in Python for enhanced code clarity and maintainability, which helps easier collaboration and onboarding.</li>
<li class="readable-text" id="p250">Security concerns can be addressed by using static analysis tools to identify coding vulnerabilities and ensure compliance with security standards.</li>
<li class="readable-text" id="p251">This chapter reiterated the importance of robust testing practices, iterative development, and early detection of potential problems using IDE plugins.</li>
</ul>
</div></body></html>