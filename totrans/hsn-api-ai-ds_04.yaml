- en: Chapter 3\. Creating Your Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “You don’t seem to give much thought to the matter in hand,” I said at last,
    interrupting Holmes’ musical disquisition.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “No data yet,” he answered. “It is a capital mistake to theorize before you
    have all the evidence. It biases the judgement.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “You will have your data soon,” I remarked.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sir Arthur Conan Doyle, *A Study in Scarlet* (Ward Lock & Co., 1887)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html#chapter_2), you designed the API architecture and set
    up your GitHub Codespace environment. In this chapter, you will create the database
    and the Python code to read from it.
  prefs: []
  type: TYPE_NORMAL
- en: Since you are creating a data API, this chapter is important. It will walk you
    through the process of designing your database structures, creating them in the
    SQLite database, creating Python code to read the database, and creating unit
    tests to verify all of these pieces work together.
  prefs: []
  type: TYPE_NORMAL
- en: If you are in a rush to see how this code works, you can use the files in the
    *chapter3/complete* folder, and come back later to follow the instructions step
    by step.
  prefs: []
  type: TYPE_NORMAL
- en: Components of Your API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, [Figure 2-2](ch02.html#future_state_architecture_ch2)
    showed the application architecture you are implementing. The API in that diagram
    is made up of several components. [Figure 3-1](#application_components_ch3) shows
    these components and the software you will use to implement them.
  prefs: []
  type: TYPE_NORMAL
- en: '![API components](assets/haad_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. API components
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are four major subcomponents of the API. The data transfer and validation
    components are used to ensure that the API requests and responses have valid data
    and conform to their definitions. You will create these with Pydantic. You will
    create the API controller with FastAPI. It handles all of the processing of the
    API along with other functions you will learn. You will create the database classes
    using SQLAlchemy. These classes handle querying the database and storing the data
    in Python classes. Since SQLite is a file-based database and you’ll deploy it
    along with your API code, the diagram shows it as a fourth component of the API.
  prefs: []
  type: TYPE_NORMAL
- en: Software Used in This Chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The software introduced in this chapter will focus on databases: creating them,
    reading data from them, and testing them (see [Table 3-1](#tools_table_chapter_3)).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. New tools or services used in this chapter
  prefs: []
  type: TYPE_NORMAL
- en: '| Software name | Version | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| pytest | 8 | Unit-testing library |'
  prefs: []
  type: TYPE_TB
- en: '| SQLAlchemy | 2 | Object-Relational Mapping (ORM) library to connect Python
    to SQLite |'
  prefs: []
  type: TYPE_TB
- en: '| SQLite | 3 | Stores the data used by the APIs |'
  prefs: []
  type: TYPE_TB
- en: SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As shown in [Figure 3-1](#application_components_ch3), the API uses the read
    replica database, which is a read-only copy of the website database that receives
    quick updates from the website database. The SWC website contains large amounts
    of data about fantasy teams, NFL players, managers, scoring, and numerous other
    data points that used by a fantasy football league host.
  prefs: []
  type: TYPE_NORMAL
- en: For your project, you will simulate this with a condensed database using SQLite.
    SQLite is well suited for learning projects because it is file based and the entire
    database can easily be stored in a Git repository like the one you’ll be using.
  prefs: []
  type: TYPE_NORMAL
- en: Although considered a lightweight database, SQLite supports all the SQL commands
    that you will use and is fully supported by SQLAlchemy, which you’ll use for Python
    database work. It is a great choice to begin the prototyping of a project. You
    might replace it with a traditional database such as PostgreSQL or MySQL as the
    application or API develops. But it is used in many production applications as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: You will use SQLite 3 for your project.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQLAlchemy is a popular Python database toolkit and ORM. It works nicely with
    FastAPI, which will be introduced in [Chapter 3](#chapter_3). Here are a few of
    the jobs that SQLAlchemy does for Python developers:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides query access to databases using Python, without using SQL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It populates Python objects with the data from the source database without requiring
    any conversion of data types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports a variety of databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows the same Python code to be used with different underlying databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates queries as prepared statements, which combat SQL injection attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*SQL injection* is a serious vulnerability in any software that accepts input
    from users and queries a database with it, including web applications and APIs.
    It occurs when bad actors insert malicious code into inputs that are intended
    for data values.'
  prefs: []
  type: TYPE_NORMAL
- en: Using *prepared statements* (also known as parameterized statements) instead
    of raw SQL queries is one technique to reduce the risk of SQL injection. For more
    information, reference [OWASP’s article on SQL injection](https://oreil.ly/24SAy).
  prefs: []
  type: TYPE_NORMAL
- en: You will be using SQLAlchemy 2 for your project.
  prefs: []
  type: TYPE_NORMAL
- en: pytest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will be using pytest, a Python testing library, throughout Part I to create
    tests for the Python code you write. You will create *unit tests* to verify that
    individual parts of your code work as intended. You will also use it to *regression-test*
    your code as you make changes or update libraries.
  prefs: []
  type: TYPE_NORMAL
- en: You will be using pytest 8 for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your SQLite Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Change to *chapter3* and open SQLite with a new database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The version of SQLite may differ from what is shown, because it is automatically
    included in your Codespace.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To save screen real estate, I have trimmed the directory listing in the terminal
    prompt of my Codespace. You can configure this by editing the */home/codespace/.bashrc*
    file in VS Code. Find the `export PROMPT_DIRTRIM` statement and set it to `export
    PROMPT_DIRTRIM=1`. Then, execute this terminal command: **`source ~/.bashrc`**.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Database Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this project, you will create several tables and load them with data. [Figure 3-2](#database_structure_ch3)
    displays the structure of the tables you will create.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will create these tables by executing Structured Query Language (SQL) statements.
    As mentioned previously, SQL is a language used frequently by data scientists.
    This book does not teach the syntax of SQL, but the scripts used are fairly basic.
    To learn more about SQL, I recommend *Learning SQL: Generate, Manipulate, and
    Retrieve Data, 3rd Edition*, by Alan Beaulieu (O’Reilly, 2020).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Database table structure](assets/haad_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Database table structure
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Be sure you are still at the `sqlite` prompt, and one-by-one execute the following
    SQL statements, one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a breakdown of one of the statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_your_database_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`CREATE TABLE` is standard SQL syntax, and `player` is the name for this table.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_your_database_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `player_id` is the name of a single column with a data type of `INTEGER`
    that is a required field. If you insert a row in this table with this value, an
    error will occur.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_your_database_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: After all the columns are defined, the `player_id` value is defined as the *primary
    key*, which is the value in this table that will always be unique and can be used
    to join to other tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that all five tables were created, enter **`.tables`**, resulting
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Understanding Table Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to notice about the tables is that each column has a data type
    defined. The data types used are `INTEGER` for identifier values, `VARCHAR` for
    names and text fields, `DATE` for date fields, and `FLOAT` for scoring value fields
    that have a decimal. All fields have a `NOT NULL` statement because they are required.
    Each table has a `PRIMARY KEY()` constraint on the table’s identifier field. This
    ensures that these values are unique in each table.
  prefs: []
  type: TYPE_NORMAL
- en: In [“Designing APIs for Data Scientists”](ch01.html#designing_APIs_data_scientists),
    I recommended that APIs support querying by the last changed date. This allows
    them to use APIs in data pipelines and only retrieve records that have changed
    since a point in time. (This is a major time-saver.) You will enable this by populating
    the `last_changed_date` column in each table.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in [Figure 3-2](#database_structure_ch3), each table is related to
    at least one other table. This is accomplished using `FOREIGN KEY` statements
    in the child table, which references the primary key in the parent table. For
    an example, look at the definition of the `team` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `FOREIGN KEY` statement inserts a column named `league_id` into the child
    table (`team`), which links it to a matching record in the parent table (`league`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `team_player` is the only table that has two foreign keys, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It has two foreign keys because it is an *association table*, which serves as
    a child that associates two separate parent tables. In your database, a player
    can be on many fantasy teams and a team can have many fantasy players. The `team_player`
    table enables this *many-to-many relationship*. Later, this relationship will
    be reflected in the Python classes that are mapped to these tables.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the tables follow a similar design, with data fields that serve
    the purpose of the data they are storing. You are ready to load data into the
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Your Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the tables are created, you will populate them with football data.
    You will use SQLite’s `.import` tool to load data files that are in CSV format.
    You will find data files in this chapter’s */data* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Before you execute the import, you need to configure SQLite to enforce foreign
    keys. This means that if you try to insert a record into a child table (a table
    containing the `FOREIGN KEY` statement) that doesn’t match a record in the parent
    table (the table named in the `REFERENCES` of a foreign key), an error will occur
    and the record won’t be imported. For example, when foreign keys are enforced,
    you can’t insert a record in the `performance` table that uses a `player_id` value
    that isn’t in the `player` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Turn on foreign key enforcement with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare the import statement to recognize CSV format with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands from the `sqlite` prompt to load the data. Run them
    in the order shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following commands to verify that the correct number of records was
    loaded into each table. The `performance` table has been loaded with records using
    two different `last_changed_date` values so that you can verify date searching
    functions are working correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To exit the SQLite application, type **`.exit`**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You have loaded sample data in your database, which represents the data from
    the SWC website data. Now you’ll start using it with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Your Data Using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways to access this data in Python. For example, you could
    create a connection to the database and execute SQL queries directly. This sounds
    simple, but you would quickly run into several issues, such as mapping the SQLite
    data types into Python objects. You would also need to take steps to avoid SQL
    injection attacks when you accept input from your API users.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this manual work, you will use an ORM, which handles the process of
    reading database tables and creating Python objects from them. You will be using
    a very common Python ORM: SQLAlchemy.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing SQLAlchemy in Your Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLAlchemy is the first Python library that you will need to install directly
    in your Codespace. You want to be certain of the version of SQLAlchemy installed,
    so first create a `pip` requirements file in the directory with your Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your editor, create a file named *requirements.txt* with the following contents,
    and save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This file will be used to install libraries from the `pip` Python package manager.
    These libraries are stored on the internet, and `pip` will automatically download
    them to your Codespace.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, you will add additional Python libraries to your Codespace.
    Using the requirements file is a convenient way to install multiple libraries
    and make sure the versions of the libraries are all compatible with one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the library, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a message that says SQLAlchemy 2.0 or higher has been successfully
    installed or was “already satisfied.” To verify the installation, type **`pip3
    show SQLAlchemy`** and you will receive a confirmation similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Creating Python Files for Database Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will now create the files that are required to query the database using
    Python. [Table 3-2](#file_table_chapter_3) explains the purpose of all the files
    you will have when this chapter is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-2\. Purpose of the Chapter 3 files
  prefs: []
  type: TYPE_NORMAL
- en: '| Filename | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *crud.py* | Helper function to query the database |'
  prefs: []
  type: TYPE_TB
- en: '| *database.py* | Configures SQLAlchemy to use the SQLite database |'
  prefs: []
  type: TYPE_TB
- en: '| *models.py* | Defines the SQLAlchemy classes related to the database tables
    |'
  prefs: []
  type: TYPE_TB
- en: '| *requirements.txt* | Used to install specific versions of libraries with
    the `pip` package manager |'
  prefs: []
  type: TYPE_TB
- en: '| test_crud.py | The pytest file to unit-test your SQLAlchemy files |'
  prefs: []
  type: TYPE_TB
- en: The file named *models.py* will contain the Python representation of the data.
    The classes in this file will be used when you query databases in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the two tasks that you need to perform in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the SQLAlchemy classes to store information from database tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the relationship between these tables so that the Python code can access
    the related tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The term *model* is used in a lot of different ways in this book, which is unavoidable
    but confusing. In this instance, the SQLAlchemy model is a Python representation
    of the data from the SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file with the following contents, and name it *models.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at *models.py* piece by piece. At the top of most Python files,
    you will find `import` statements. The power of the Python ecosystem comes from
    the variety of external libraries you can use. The process you will use in this
    book is to install the libraries using the `pip` package manager, and then reference
    them in your code using import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_your_database_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Because this file will create Python representations of the database tables,
    you first import the data types that SQLAlchemy will use for the database fields.
    For more information about SQLAlchemy data types, reference the [SQLAlchemy Type
    Hierarchy](https://oreil.ly/Z1jfo).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_your_database_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you import SQLAlchemy’s relationship functionality, which enables foreign
    key relationships between tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_your_database_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `database` import refers to the *database.py* file with the SQLAlchemy configuration.
    You are using the `Base` class, which is a standard template you’ll use for the
    classes in the *models.py* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to begin the definition of the `Player` class, which is the Python
    class you’ll use to store data from the SQLite `player` table. You do this using
    the `class` statement, stating the name of the class and specifying that it will
    be a subclass of the `Base` template imported from the *database.py* file. Use
    the magic command `*tablename*` to tell SQLAlchemy to reference the `player` table.
    Because of this statement, when you ask SQLAlchemy to query `Player`, it will
    know behind the scenes to access the `player` table in the database. This is one
    of the key benefits of an ORM—mapping the Python code automatically to the underlying
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the `Player` class definition maps additional details about the
    database table. Each statement defines one attribute in the class using the `Column`
    method provided by SQLAlchemy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a few things to notice about the definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: The attribute names are automatically matched to the column names in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data types used (e.g., `String`, `Integer`) are SQLAlchemy data types that
    you specified in your `import` statement at the beginning of the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `primary_key` definition provides several benefits from SQLAlchemy, such
    as query optimization, enforcing uniqueness, and enabling relationships between
    classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Along with the definition of the tables, you define the foreign key relationship
    between the tables using the `relationship()` function. This results in a `Player​.per⁠formances`
    attribute that will return all the related rows from the `performance` table for
    each row in the `player` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another kind of relationship, which uses the `team_player` association
    table to connect `player` to `team`. By defining `secondary="team_player"`, this
    relationship allows a `Player` record to have an attribute named `Player.teams`.
    This is the many-to-many relationship that was discussed when creating the database
    tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the definition for the `Performance` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This class has a `player` relationship that is the mirror image of the `performances`
    relationship in the `player` table. When you look at these two relationships together,
    you can see that the `back_populates` statement in one refers to the variable
    assigned in the other. Together these allow a two-way relationship between the
    parent (`player`) and child (`performance`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the `League` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`League` is going to be the topmost parent class in your code, as was reflected
    in [Figure 3-2](#database_structure_ch3). The `teams` relationship will be used
    to enable `League.teams` in this class and has a matching relationship in the
    `Team` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the next block of code, which defines the `Team` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this file has matching relationships to connect with the `league`
    table and indirectly to the `player` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last class definition is for the `team-player` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `TeamPlayer` class is created without any relationships, because those are
    defined on the `Team` and `Player` classes. You have now defined all of the SQLAlchemy
    models needed for the new database tables and the necessary database configuration
    file. Excellent progress!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Database Configuration File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, a file named *database.py* will set up the SQLAlchemy configuration to
    connect to the SQLite database, along with some other Python objects that you’ll
    use for database work. The tasks that you need to accomplish in this file are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a database connection that points to the SQLite database and has the
    correct settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a parent class that you’ll use to define the Python table classes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a file with the following contents, and name it *database.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at this file piece by piece. Three specific functions are imported
    from the SQLAlchemy libraries. Although it would be possible to import the entire
    SQLAlchemy library all at once, it is better to import specific functions to limit
    possible conflicts between duplicate functions in multiple libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The next three steps work together to get the *session*, which is a SQLAlchemy
    object that manages the conversation with the database. Create a database URL
    that tells SQLAlchemy what type of database you’ll be using (SQLite) and where
    to find the file (in the same folder as this file, with the name *fantasy_data.db*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this database URL, create an `engine` object, with one configuration
    setting that allows multiple connections to this database without an error being
    thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the `engine` object to create a session named `SessionLocal` that
    points to that engine and adds a couple of more configuration settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The last command in this file creates a `Base` class. This is a standard template
    SQLAlchemy provides for the models you will create in the *models.py* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Creating SQLAlchemy Helper Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The files created so far give you a connection to the database and classes that
    represent database tables. Next, you will create the file *crud.py* that contains
    query functions. This strange-sounding name stands for Create, Read, Update, Delete
    (CRUD).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file with the following contents, and name it *crud.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the import statements in *crud.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_your_database_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Session` and `joinedload` are used by the query functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_your_database_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `date` will be an important data type to allow you to filter by date.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_your_database_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This import lets you reference the model file that you created. These functions
    reference the classes that you created in *models.py* and use SQLAlchemy built-in
    functions to retrieve data using prepared SQL statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the first query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The parameters in this function include a database session, which the function
    will use to connect to the database, and a specific `player_id` value. By using
    `filter(models.Player.player_id == player_id).first()`, this function looks up
    a specific `Player.player_id` value and returns the first matching instance. Because
    you have defined `player_id` as a primary key in the *models.py* file and the
    SQLite database, this query will return a single result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of the next function adds several new parameters to the `.query()`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `skip` and `limit` parameters will be used for *pagination*, which allows
    the user to specify a set of records in chunks rather than a full list. The `min_last_changed_date`
    parameter will be used to exclude records older than a specified date.
  prefs: []
  type: TYPE_NORMAL
- en: The `int = 0` on the `skip` parameter sets a default value of zero. If this
    parameter isn’t sent in a call to this function, `skip` will default to zero.
    The `limit` has a default of 100\. There is no default given for `min_last_changed_date`,
    `first_name`, and `last_name`, so those default to null.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the function uses the queries to filter the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The last statement applies the `skip` and `limit` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This statement applies the `skip` and `limit` parameters to grab a specific
    chunk of records from the query results. The `skip` instructs the query to skip
    a number of records from the beginning of the results, and `limit` instructs the
    query to return only a certain number of records. For instance, a user might begin
    by skipping zero and limiting 20\. This would return the first 20 records. They
    could call it again, this time skipping 20 and limiting 20\. This would grab the
    next 20.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_leagues` function uses a new statement, so it is worth a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This function uses the `.options(joinedload(models.League.teams))` statement.
    This is a type of *eager loading*, which causes SQLAlchemy to retrieve the joined
    `team` data when it retrieves the `league` data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final set of queries are designed to support AI and large language models,
    based on the recommendation to provide a separate endpoint for analytics questions.
    You will create endpoints that provide counts for users, leagues, and teams. This
    will help the AI use the pagination functions, and it will answer questions about
    the number of records without making large API calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You have created all the SQLAlchemy classes and helper functions. Since all
    of the functions in *crud.py* are reading (querying) data, you have only implemented
    the “r” in CRUD. That is appropriate, because all of your user stories require
    read-only functionality. If you were developing an API that allowed creating,
    updating, or deleting records, this file could be extended with additional functions.
    Now it is time to unit-test these queries with pytest.
  prefs: []
  type: TYPE_NORMAL
- en: Installing pytest in Your Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that all the database code is written, you are ready to test it. You will
    use the pytest library for this task. First, add an entry to the *requirements.txt*
    file for pytest. The updated file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To install pytest, execute the following command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a message that says pytest 8.1.0 or higher has been successfully
    installed or was “already satisfied.” To verify the installation, type **`pip3
    show Pytest`** and you will receive a confirmation similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Testing Your SQLAchemy Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the library’s summary says, pytest is simple to use. There are a couple of
    naming conventions that pytest expects. Any file that contains tests will have
    a filename beginning with *test* followed by an underscore or ending with an underscore
    followed by *test*. Inside the test file, pytest will execute any function name
    beginning with *test*.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the test functions, you will include an `assert` statement. If it returns
    true, the flow continues. If all assertions evaluate as true in the test, the
    test returns with a success status. If an assertion evaluates as false, the code
    raises an `AssertionError` and the test evaluates as false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your unit tests will be very basic: they will check that the row counts returned
    from your SQLAlchemy classes match the values you checked in the previous SQL
    query.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named *test_crud.py* with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: First, look at how this file follows the conventions expected by pytest. The
    file is named *test_crud.py*, so it will be recognized as a test file automatically.
    The file contains six function names beginning with *test_*. These will be executed
    when the file runs. Each of these test functions ends with an `assert` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function needs a bit of explanation. On top of the function is the
    decorator `@pytest.fixture(scope="function")`. A fixture is used during the *arrange*
    phase, which prepares the testing setup. This fixture uses session scope, which
    means it will run once for each function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of the `db_session()` function creates a database session, pauses
    while the test function uses the session (through the `yield` statement), and
    then closes the session when the test completes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the date-based queries are working correctly, the queries for `performance`
    check the full results and then results that are limited using `last_changed_date`.
    First remember that in the SQL queries earlier you got the following results for
    the `performance` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the first result using pytest, this function does not include a data
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the second result, the next function uses a `last_changed_date` value
    of `2024_04_01`, set in the `test_date` variable at the top of the testing code.
    That date is earlier that all by 2,711 records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The last test verifies one of the analytics queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the tests, enter the **`pytest test_crud.py`** command and you should
    see an output that looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You have verified that your SQLAlchemy classes and a few helper functions work
    correctly—way to go! The database work is done.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SQL is one of the essential skills for data professionals. The number of resources
    available is limitless, but here are a couple to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Learning SQL, 3rd Edition*, by Alan Beaulieu (O’Reilly, 2020)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SQL Pocket Guide, 4th Edition*, by Alice Zhao (O’Reilly, 2021)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about SQLAlchemy, check out [the official SQLAlchemy 2 documentation](https://oreil.ly/PhsUf).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you created your database and the SQLAlchemy code to read
    it. Here is what you accomplished in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You designed your database tables and their relationships.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You created a database using SQLite and created all of your tables using SQL
    commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You imported data from CSV files to load your tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You created the Python model files and database configuration files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You created helper functions to query your database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You unit-tested the end-to-end database functionality using pytest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html#chapter_4), you will create the FastAPI code to use
    this data and publish it as a REST API.
  prefs: []
  type: TYPE_NORMAL
