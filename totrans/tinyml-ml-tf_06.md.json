["```py\n#include \"tensorflow/lite/micro/examples/hello_world/output_handler.h\"\n#include \"Arduino.h\"\n#include \"tensorflow/lite/micro/examples/hello_world/constants.h\"\n```", "```py\n// Adjusts brightness of an LED to represent the current y value\nvoid HandleOutput(tflite::ErrorReporter* error_reporter, float x_value,\n                  float y_value) {\n// Track whether the function has run at least once\nstatic bool is_initialized = false;\n\n// Do this only once\nif (!is_initialized) {\n  // Set the LED pin to output\n  pinMode(LED_BUILTIN, OUTPUT);\n  is_initialized = true;\n}\n```", "```py\n// Calculate the brightness of the LED such that y=-1 is fully off\n// and y=1 is fully on. The LED's brightness can range from 0-255.\nint brightness = (int)(127.5f * (y_value + 1));\n```", "```py\n// Set the brightness of the LED. If the specified pin does not support PWM,\n// this will result in the LED being on when y > 127, off otherwise.\nanalogWrite(LED_BUILTIN, brightness);\n```", "```py\n// Log the current brightness value for display in the Arduino plotter\nerror_reporter->Report(\"%d\\n\", brightness);\n```", "```py\n                         [ R G B Y ]\n```", "```py\n#include \"tensorflow/lite/micro/examples/hello_world/output_handler.h\"\n#include \"am_bsp.h\"\n```", "```py\nvoid HandleOutput(tflite::ErrorReporter* error_reporter, float x_value,\n                  float y_value) {\n  // The first time this method runs, set up our LEDs correctly\n  static bool is_initialized = false;\n  if (!is_initialized) {\n    // Set up LEDs as outputs\n    am_hal_gpio_pinconfig(AM_BSP_GPIO_LED_RED, g_AM_HAL_GPIO_OUTPUT_12);\n    am_hal_gpio_pinconfig(AM_BSP_GPIO_LED_BLUE, g_AM_HAL_GPIO_OUTPUT_12);\n    am_hal_gpio_pinconfig(AM_BSP_GPIO_LED_GREEN, g_AM_HAL_GPIO_OUTPUT_12);\n    am_hal_gpio_pinconfig(AM_BSP_GPIO_LED_YELLOW, g_AM_HAL_GPIO_OUTPUT_12);\n    // Ensure all pins are cleared\n    am_hal_gpio_output_clear(AM_BSP_GPIO_LED_RED);\n    am_hal_gpio_output_clear(AM_BSP_GPIO_LED_BLUE);\n    am_hal_gpio_output_clear(AM_BSP_GPIO_LED_GREEN);\n    am_hal_gpio_output_clear(AM_BSP_GPIO_LED_YELLOW);\n    is_initialized = true;\n  }\n```", "```py\n// Set the LEDs to represent negative values\nif (y_value < 0) {\n  // Clear unnecessary LEDs\n  am_hal_gpio_output_clear(AM_BSP_GPIO_LED_GREEN);\n  am_hal_gpio_output_clear(AM_BSP_GPIO_LED_YELLOW);\n  // The blue LED is lit for all negative values\n  am_hal_gpio_output_set(AM_BSP_GPIO_LED_BLUE);\n  // The red LED is lit in only some cases\n  if (y_value <= -0.75) {\n    am_hal_gpio_output_set(AM_BSP_GPIO_LED_RED);\n  } else {\n    am_hal_gpio_output_clear(AM_BSP_GPIO_LED_RED);\n  }\n```", "```py\n  // Set the LEDs to represent positive values\n} else if (y_value > 0) {\n  // Clear unnecessary LEDs\n  am_hal_gpio_output_clear(AM_BSP_GPIO_LED_RED);\n  am_hal_gpio_output_clear(AM_BSP_GPIO_LED_BLUE);\n  // The green LED is lit for all positive values\n  am_hal_gpio_output_set(AM_BSP_GPIO_LED_GREEN);\n  // The yellow LED is lit in only some cases\n  if (y_value >= 0.75) {\n    am_hal_gpio_output_set(AM_BSP_GPIO_LED_YELLOW);\n  } else {\n    am_hal_gpio_output_clear(AM_BSP_GPIO_LED_YELLOW);\n  }\n}\n```", "```py\n// Log the current X and Y values\nerror_reporter->Report(\"x_value: %f, y_value: %f\\n\", x_value, y_value);\n```", "```py\ngit clone https://github.com/tensorflow/tensorflow.git\ncd tensorflow\n```", "```py\nmake -f tensorflow/lite/micro/tools/make/Makefile \\\n  TARGET=sparkfun_edge hello_world_bin\n```", "```py\ntensorflow/lite/micro/tools/make/gen/ \\\n  sparkfun_edge_cortex-m4/bin/hello_world.bin\n```", "```py\ntest -f tensorflow/lite/micro/tools/make/gen/ \\\n  sparkfun_edge_cortex-m4/bin/hello_world.bin \\\n  &&  echo \"Binary was successfully created\" || echo \"Binary is missing\"\n```", "```py\ncp tensorflow/lite/micro/tools/make/downloads/AmbiqSuite-Rel2.0.0/ \\\n  tools/apollo3_scripts/keys_info0.py \\\n  tensorflow/lite/micro/tools/make/downloads/AmbiqSuite-Rel2.0.0/ \\\n  tools/apollo3_scripts/keys_info.py\n```", "```py\npython3 tensorflow/lite/micro/tools/make/downloads/ \\\n  AmbiqSuite-Rel2.0.0/tools/apollo3_scripts/create_cust_image_blob.py \\\n  --bin tensorflow/lite/micro/tools/make/gen/ \\\n  sparkfun_edge_cortex-m4/bin/hello_world.bin \\\n  --load-address 0xC000 \\\n  --magic-num 0xCB -o main_nonsecure_ota \\\n  --version 0x0\n```", "```py\npython3 tensorflow/lite/micro/tools/make/downloads/ \\\n  AmbiqSuite-Rel2.0.0/tools/apollo3_scripts/create_cust_wireupdate_blob.py \\\n  --load-address 0x20000 \\\n  --bin main_nonsecure_ota.bin \\\n  -i 6 \\\n  -o main_nonsecure_wire \\\n  --options 0x1\n```", "```py\n# macOS:\nls /dev/cu*\n\n# Linux:\nls /dev/tty*\n```", "```py\n/dev/cu.Bluetooth-Incoming-Port\n/dev/cu.MALS\n/dev/cu.SOC\n```", "```py\n# macOS:\nls /dev/cu*\n\n# Linux:\nls /dev/tty*\n```", "```py\n/dev/cu.Bluetooth-Incoming-Port\n/dev/cu.MALS\n/dev/cu.SOC\n/dev/cu.wchusbserial-1450\n```", "```py\nexport DEVICENAME=<*your device name here*>\n\n```", "```py\nexport BAUD_RATE=921600\n```", "```py\npython3 tensorflow/lite/micro/tools/make/downloads/ \\\n  AmbiqSuite-Rel2.0.0/tools/apollo3_scripts/ \\\n  uart_wired_update.py -b ${BAUD_RATE} \\\n  ${DEVICENAME} -r 1 -f main_nonsecure_wire.bin -i 6\n```", "```py\nConnecting with Corvette over serial port /dev/cu.usbserial-1440...\nSending Hello.\nReceived response for Hello\nReceived Status\nlength =  0x58\nversion =  0x3\nMax Storage =  0x4ffa0\nStatus =  0x2\nState =  0x7\nAMInfo =\n0x1\n0xff2da3ff\n0x55fff\n0x1\n0x49f40003\n0xffffffff\n[...lots more 0xffffffff...]\nSending OTA Descriptor =  0xfe000\nSending Update Command.\nnumber of updates needed =  1\nSending block of size  0x158b0  from  0x0  to  0x158b0\nSending Data Packet of length  8180\nSending Data Packet of length  8180\n[...lots more Sending Data Packet of length  8180...]\n```", "```py\n[...lots more Sending Data Packet of length  8180...]\nSending Data Packet of length  8180\nSending Data Packet of length  6440\nSending Reset Command.\nDone.\n```", "```py\nscreen ${DEVICENAME} 115200\n```", "```py\nx_value: 1.1843798*2^2, y_value: -1.9542645*2^-1\n```", "```py\n#include \"tensorflow/lite/micro/examples/hello_world/output_handler.h\"\n#include \"LCD_DISCO_F746NG.h\"\n#include \"tensorflow/lite/micro/examples/hello_world/constants.h\"\n```", "```py\n// The LCD driver\nLCD_DISCO_F746NG lcd;\n```", "```py\n// The colors we'll draw\nconst uint32_t background_color = 0xFFF4B400;  // Yellow\nconst uint32_t foreground_color = 0xFFDB4437;  // Red\n// The size of the dot we'll draw\nconst int dot_radius = 10;\n```", "```py\n// Size of the drawable area\nint width;\nint height;\n// Midpoint of the y axis\nint midpoint;\n// Pixels per unit of x_value\nint x_increment;\n```", "```py\n// Animates a dot across the screen to represent the current x and y values\nvoid HandleOutput(tflite::ErrorReporter* error_reporter, float x_value,\n                  float y_value) {\n  // Track whether the function has run at least once\n  static bool is_initialized = false;\n\n  // Do this only once\n  if (!is_initialized) {\n    // Set the background and foreground colors\n    lcd.Clear(background_color);\n    lcd.SetTextColor(foreground_color);\n    // Calculate the drawable area to avoid drawing off the edges\n    width = lcd.GetXSize() - (dot_radius * 2);\n    height = lcd.GetYSize() - (dot_radius * 2);\n    // Calculate the y axis midpoint\n    midpoint = height / 2;\n    // Calculate fractional pixels per unit of x_value\n    x_increment = static_cast<float>(width) / kXrange;\n    is_initialized = true;\n  }\n```", "```py\n// Set the background and foreground colors\nlcd.Clear(background_color);\nlcd.SetTextColor(foreground_color);\n```", "```py\nwidth = lcd.GetXSize() - (dot_radius * 2);\nheight = lcd.GetYSize() - (dot_radius * 2);\n```", "```py\n// Calculate the y axis midpoint\nmidpoint = height / 2;\n// Calculate fractional pixels per unit of x_value\nx_increment = static_cast<float>(width) / kXrange;\n```", "```py\n// Clear the previous drawing\nlcd.Clear(background_color);\n```", "```py\n// Calculate x position, ensuring the dot is not partially offscreen,\n// which causes artifacts and crashes\nint x_pos = dot_radius + static_cast<int>(x_value * x_increment);\n```", "```py\n// Calculate y position, ensuring the dot is not partially offscreen\nint y_pos;\nif (y_value >= 0) {\n  // Since the display's y runs from the top down, invert y_value\n  y_pos = dot_radius + static_cast<int>(midpoint * (1.f - y_value));\n} else {\n  // For any negative y_value, start drawing from the midpoint\n  y_pos =\n      dot_radius + midpoint + static_cast<int>(midpoint * (0.f - y_value));\n}\n```", "```py\n// Draw the dot\nlcd.FillCircle(x_pos, y_pos, dot_radius);\n```", "```py\n// Log the current X and Y values\nerror_reporter->Report(\"x_value: %f, y_value: %f\\n\", x_value, y_value);\n```", "```py\nmake -f tensorflow/lite/micro/tools/make/Makefile \\\n  TARGET=mbed TAGS=\"CMSIS disco_f746ng\" generate_hello_world_mbed_project\n```", "```py\ntensorflow/lite/micro/tools/make/gen/mbed_cortex-m4/prj/ \\\n  hello_world/mbed\n```", "```py\ncd tensorflow/lite/micro/tools/make/gen/mbed_cortex-m4/prj/ \\\n  hello_world/mbed\n```", "```py\nmbed config root .\n```", "```py\nmbed deploy\n```", "```py\npython -c 'import fileinput, glob;\nfor filename in glob.glob(\"mbed-os/tools/profiles/*.json\"):\n  for line in fileinput.input(filename, inplace=True):\n    print(line.replace(\"\\\"-std=gnu++98\\\"\",\"\\\"-std=c++11\\\", \\\"-fpermissive\\\"\"))'\n```", "```py\nmbed compile -m DISCO_F746NG -t GCC_ARM\n```", "```py\ncp ./BUILD/DISCO_F746NG/GCC_ARM/mbed.bin\n```", "```py\ncp ./BUILD/DISCO_F746NG/GCC_ARM/mbed.bin /Volumes/DIS_F746NG/\n```", "```py\nls /dev/tty*\n```", "```py\n/dev/tty.usbmodem1454203\n```", "```py\nscreen /<*dev/tty.devicename*> 9600\n\n```", "```py\nx_value: 1.1843798*2^2, y_value: -1.9542645*2^-1\n```"]