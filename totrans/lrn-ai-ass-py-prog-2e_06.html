<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div class="readable-text" id="p1">
<h1 class="readable-text-h"><span class="calibre22"><span class="calibre22">7</span></span> <span class="calibre22">Problem decomposition</span></h1>
</div>
<div class="readable-text">
<h3 class="introduction-header">This chapter covers</h3>
<ul class="calibre24">
<li class="readable-text1" id="p2">Understanding problem decomposition and why we need to do it</li>
<li class="readable-text1" id="p3">Using top-down design to carry out problem decomposition and write programs</li>
<li class="readable-text1" id="p4">Writing a spelling suggestions program using top-down design</li>
</ul>
</div>
<div class="readable-text" id="p5">
<p class="calibre15">In chapter 3, we talked about why we shouldn’t ask Copilot to solve big problems. Imagine what could happen if we asked Copilot to “Design a two-player strategy game.” </p>
</div>
<div class="readable-text" id="p6">
<p class="calibre15">In the worst case, Copilot wouldn’t do anything useful. We observe this sometimes when Copilot gives us comments again and again but never provides us with real code.</p>
</div>
<div class="readable-text" id="p7">
<p class="calibre15">In the best case, we’d get a canned program with all the decisions made for us. That program may not match what we wanted. Part of the power of being a programmer is customizing what we’re creating. Even if we didn’t want to customize anything, what would we do if the program from Copilot had flaws? It would be difficult for us to fix a large program that we don’t understand.</p>
</div>
<div class="readable-text" id="p8">
<p class="calibre15">For us to get a program that does what we want, we need to feed small subproblems to Copilot and assemble those solutions into our own program. The focus of this chapter is learning how to break large problems into smaller subproblems, which is essential to being able to solve the large problems we want to solve.</p>
</div>
<div class="readable-text" id="p9">
<h2 class="readable-text-h1" id="sigil_toc_id_98"><span class="calibre22">7.1</span> Problem decomposition</h2>
</div>
<div class="readable-text" id="p10">
<p class="calibre15">Problem decomposition involves starting with a large problem that may not be fully specified and breaking it down into subproblems, each of which is well-defined and useful for solving our overall problem. Our goal is then to write a function to solve each of those subproblems. We may be able to do this for some subproblems with a reasonable amount of code, but other subproblems may still be too big for us to capture in a function of reasonable size. (In chapter 3, we mentioned that we want to keep functions short—something like 12–20 lines—to give us the best chance of getting good code from Copilot, testing that code, and fixing bugs in that code if necessary.) If a subproblem is still too large to be implemented in a single function, then we further divide that subproblem into sub-subproblems of their own. Hopefully, each of those sub-subproblems will be small enough now, but if not, we’ll continue dividing those too! The key reason we do this is to manage complexity. Each function should be simple enough so that we can understand its purpose and so that Copilot can solve it well. If something does go wrong, we won’t have too much code to trawl through to find the problem. When we write code that is extremely complex, we’re likely to make mistakes. The same goes for Copilot! And, when we have mistakes in long, complex code, they aren’t easy to find and fix. It’s hard to overstate the importance of problem decomposition for quality code.</p>
</div>
<div class="readable-text" id="p11">
<p class="calibre15">The process of starting with a large problem and breaking it down is called <em class="calibre18">problem decomposition</em>. The way we’re doing this here is synonymous with the software engineering technique known as <em class="calibre18">top-down design</em>. It’s called top-down design because we’re starting with the large task we want to complete and breaking it down into smaller tasks. Once we’ve completed the top-down design, we can implement the resulting functions in code. We’ll have one function for our overall problem, which will call the functions for each of our subproblems. Each of those subproblem functions will further call their own functions, as needed, to solve any of their sub-subproblems, and so on.</p>
</div>
<div class="readable-text" id="p12">
<p class="calibre15">As we discussed in chapter 3, we’re looking to end up with functions that each have a small role to play in our overall program and whose behavior is clearly defined. We need those functions so that we can call them to reduce the complexity of functions that would otherwise be too complex. To improve clarity and ease of understanding, we seek to design functions that have a small number of parameters and return a small amount of highly useful information.</p>
</div>
<div class="readable-text" id="p13">
<h2 class="readable-text-h1" id="sigil_toc_id_99"><span class="calibre22">7.2</span> Small examples of top-down design</h2>
</div>
<div class="readable-text" id="p14">
<p class="calibre15">We’ll soon jump into a more authentic example of how top-down design works, but we’d first like to set the stage using a couple of our earlier examples. Let’s think about the design of a function we previously wrote in chapter 3: <code class="calibre25">get_strong_password</code>. It repeatedly prompts the user for a password until they enter a strong password. Don’t go back and look at that code—we want to start fresh here.</p>
</div>
<div class="readable-text" id="p15">
<p class="calibre15">Suppose that we want to use a top-down design to solve this task. If it were one small, well-defined task, we could implement it directly as a single function. However, for this task, we do see a subtask; namely, what’s a strong password? What are the rules around that? To us, this sounds like a subtask that we can try to carve out of this function to make it simpler. Indeed, in chapter 3, when we wrote this function, we did call our earlier <code class="calibre25">is_strong_password</code> function, which makes the True/False decision about what it means for a password to be strong.</p>
</div>
<div class="readable-text" id="p16">
<p class="calibre15">We can depict this top-down design as shown in figure 7.1. For ease of displaying what will ultimately be large figures later in the chapter, we’re going to consistently show the design from left to right rather than top to bottom, but the same fundamental principles still apply.<span/></p>
</div>
<div class="browsable-container" id="p17">
<img alt="figure" src="../Images/7-1.png" class="calibre60"/>
<h5 class="figure-container-h"><span>Figure 7.1</span> Functions diagram for the <code class="calibre25">get_strong_password</code> function. <code class="calibre25">get_strong_password</code> calls <code class="calibre25">is_strong_password</code>.</h5>
</div>
<div class="readable-text" id="p18">
<p class="calibre15">This figure indicates that it’s our goal to have <code class="calibre25">get_strong_password</code> call <code class="calibre25">is_strong_ password</code> to do some of its work. </p>
</div>
<div class="readable-text" id="p19">
<p class="calibre15">Now, for our second example, recall from chapter 3 that we also wrote a <code class="calibre25">best_word</code> function that takes a list of words as its parameter and returns the one worth the most points. Again, don’t go back and look at that code—we want to figure it out again here. Let’s think about what the code for this task might look like. It will probably use a loop to consider each word, and in that loop, it will need to keep track of the best word we’ve seen so far. For each word, we need to figure out how many points it’s worth by adding up the number of points for each of its letters. Remember that <em class="calibre18">a</em> is worth 1 point, <em class="calibre18">b</em> is worth 3 points, <em class="calibre18">c</em> is worth 3 points, <em class="calibre18">d</em> is worth 2 points, <em class="calibre18">e</em> is worth 1 point, and so on.</p>
</div>
<div class="readable-text" id="p20">
<p class="calibre15">Whoa there! We’re really going in-depth on this “How many points each letter is worth” thing. This sounds like a subtask to us. If we had a function that we could call to tell us the number of points each word is worth, we wouldn’t need to worry about this points business in our <code class="calibre25">best_word</code> function. In chapter 3, we wrote a function called <code class="calibre25">num_points</code> that carries out exactly this subtask: take a word as a parameter and return its total point value. We can call <code class="calibre25">num_points</code> from <code class="calibre25">best_word</code>, as depicted in figure 7.2. Again, this makes the task of <code class="calibre25">best_word</code> easier for us.<span/></p>
</div>
<div class="browsable-container" id="p21">
<img alt="figure" src="../Images/7-2.png" class="calibre60"/>
<h5 class="figure-container-h"><span>Figure 7.2</span> Functions diagram for <code class="calibre25">best_word</code></h5>
</div>
<div class="readable-text" id="p22">
<p class="calibre15">In chapter 3, we happened to write these functions from subtask to task, from the leaf function to the parent function. We’ll continue to do that in this chapter, but we’ll do the top-down design first to figure out which functions we’ll need.</p>
</div>
<div class="readable-text" id="p23">
<p class="calibre15">These two examples from chapter 3 we just talked about are small, and you may indeed be able to get their code written by powering ahead with a single function. But with large examples, problem decomposition is the only way to keep the complexity under control. </p>
</div>
<div class="readable-text" id="p24">
<p class="calibre15">We’ll next dive into a larger example of top-down design. The key skill that we want you to take from this chapter is how to break a large problem down into smaller subproblems. We encourage you to read through the upcoming example multiple times. On your first read, aim for a high-level view of how the pieces fit together to solve the overall problem. On your second read, feel free to dive deeper into how each function works on its own.</p>
</div>
<div class="readable-text" id="p25">
<h2 class="readable-text-h1" id="sigil_toc_id_100"><span class="calibre22">7.3</span> Spelling suggestions</h2>
</div>
<div class="readable-text" id="p26">
<p class="calibre15">For the rest of the chapter, we’re going to solve a problem from beginning to end using top-down design. We want you to be sucessful when you use this approach on your own to solve your own problems, so you’ll see top-down design reappear throughout the remainder of the book.</p>
</div>
<div class="readable-text" id="p27">
<p class="calibre15">Oops—did we have a typo there? <em class="calibre18">Sucessful</em>? That was supposed to be <em class="calibre18">successful</em>. English words can be tricky to spell sometimes! You’ve probably run into many such words. Is it thorough or thourough? Acceptable or acceptible? Receive or recieve? We’re going to write a program that takes a word that’s potentially misspelled and offers possible corrections to that misspelling. It’s a basic spell-checker for individual words!</p>
</div>
<div class="readable-text" id="p28">
<p class="calibre15">How are we supposed to come up with these possible corrections? Well, let’s look at the pairs of words we just provided and discuss the types of mistakes they exemplify.</p>
</div>
<div class="readable-text" id="p29">
<p class="calibre15">The mistake we made with the word <em class="calibre18">sucessful</em> is that we left out one letter—we need to add a <em class="calibre18">c</em> in there to get the correct word <em class="calibre18">successful</em>. So, in general, it seems like a good idea to consider adding a letter to a misspelled word because that might be exactly what’s needed to fix it. We’re going to consider adding any possible letter in any possible position, not just adding a copy of a letter that’s already there. This will help us fix misspelled words such as <em class="calibre18">acknowlege</em> (which is missing a <em class="calibre18">d</em>).</p>
</div>
<div class="readable-text" id="p30">
<p class="calibre15">There are other types of mistakes we’ll want to consider too. For example, the mistake in <em class="calibre18">thourough</em> isn’t that we’re missing a letter, but that we have an extra letter—we need to delete the first <em class="calibre18">u</em> to get <em class="calibre18">thorough</em>. We’re therefore going to consider removing any single letter from a misspelled word to see if that fixes it.</p>
</div>
<div class="readable-text" id="p31">
<p class="calibre15">What other mistakes can we fix? Well, there’s that misspelled word <em class="calibre18">acceptible</em>. That’s a new type of mistake: there’s no missing or extra letter, but there is a letter that should be changed to another letter. That is, if we change the <em class="calibre18">i</em> to an <em class="calibre18">a</em>, we arrive at the correctly spelled word <em class="calibre18">acceptable</em>. To that end, we can try changing each letter to each other letter in the alphabet to see if that fixes the misspelling.</p>
</div>
<div class="readable-text" id="p32">
<p class="calibre15">There are many ways to fix misspelled words beyond the three that we just gave. But we’ll stop here because we think that fixing three types of mistakes is sufficient for our purposes of demonstrating top-down design. This means that our program will fail to correct the misspelled word <em class="calibre18">recieve</em> to <em class="calibre18">receive</em>, because we won’t be fixing the mistake of having two letters in the wrong order. We’ll also fail to correct the misspelled word <em class="calibre18">camoflague</em> to camouflage, because we’ll be fixing only one mistake in a misspelled word (<em class="calibre18">camoflague</em> has two different errors, one missing <em class="calibre18">u</em> and one added <em class="calibre18">u</em>). Once you finish the chapter, we encourage you to continue to improve your program and learn more about correcting misspelled words if you’d like to go further.</p>
</div>
<div class="readable-text" id="p33">
<h2 class="readable-text-h1" id="sigil_toc_id_101"><span class="calibre22">7.4</span> Spelling suggestions using top-down design</h2>
</div>
<div class="readable-text" id="p34">
<p class="calibre15">Our task is to “write a program that takes a word that’s potentially misspelled and offers possible corrections to that misspelling.” That’s a big task that we definitely don’t want to try to jam into a single function. </p>
</div>
<div class="readable-text" id="p35">
<p class="calibre15">Many programs—whether they analyze data, provide spelling suggestions, or guess the author of an unknown text—have three distinct tasks to perform. First, there’s the input task: we need to acquire the data on which our program will run. Second, there’s the process task, where the program does whatever it’s supposed to do with that data. Now, processing the data is all well and good, but it’s useless if our users don’t know what our programs discovered through that processing. That’s where the third step, the output step, comes in, and it’s where we communicate something to the user. Table 7.1 summarizes this process.</p>
</div>
<div class="browsable-container" id="p36">
<h5 class="browsable-container-h"><span>Table 7.1</span> A summary of the input, process data, and output tasks</h5>
<table class="calibre36">
<thead class="calibre37">
<tr class="calibre38">
<th class="calibre39">
<div class="readable-text">
         Phase 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         Role 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         Spelling Suggestions Example 
       </div></th>
</tr>
</thead>
<tbody class="calibre40">
<tr class="calibre38">
<td class="calibre41">  Input <br class="calibre1"/></td>
<td class="calibre41">  Take, as input, the information needed for the function. <br class="calibre1"/></td>
<td class="calibre41">  Provide the misspelled word <em class="calibre18">sucessful</em> and a collection of real words (properly spelled words). <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  Process data <br class="calibre1"/></td>
<td class="calibre41">  Perform the operation specified by the function on that data. <br class="calibre1"/></td>
<td class="calibre41">  Consider changes to that word that might result in a correctly spelled word, for example, adding a letter <em class="calibre18">c</em> either before or after the <em class="calibre18">c</em> in <em class="calibre18">sucessful</em> would produce the real word <em class="calibre18">successful</em>. Many other incorrect words (i.e., <em class="calibre18">scucessful</em> obtained by adding the letter <em class="calibre18">c</em> before the <em class="calibre18">u</em>) may also be attempted, but only real words should be in the result. <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41">  Output <br class="calibre1"/></td>
<td class="calibre41">  Return the result of that data processing. <br class="calibre1"/></td>
<td class="calibre41">  Return the suggestion “successful”. <br class="calibre1"/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p37">
<p class="calibre15">You can see this input-process-output model at work back in our data processing example from chapter 2. We needed to read the data from the CSV file (that’s the input step), determine the number of passing yards for each quarterback (that’s the process step), and then output the quarterbacks and their passing yards (that’s the output step).</p>
</div>
<div class="readable-text" id="p38">
<p class="calibre15">We can think about our Spelling Suggestions problem in a similar way. What’s amazing here is that the input-process-output model gives us exactly the three subproblems that we’ll want to solve in our top-down design. Here’s what we mean (also see the example in table 7.1):</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p39"> For the input step, we need to ask the user for the word for which they want to obtain spelling suggestions. </li>
<li class="readable-text1" id="p40"> For the process step, we need to figure out all the possible suggestions for the user’s word. </li>
<li class="readable-text1" id="p41"> For the output step, we need to tell the user about all the spelling suggestions that we found during the process step. </li>
</ul>
<div class="readable-text" id="p42">
<p class="calibre15">Notice that we started with one large problem to solve (the overall Spelling Suggestions problem), and now we have three smaller problems to solve. Our main or top-level function will end up calling any functions that result from this problem decomposition. We’ll name this main function <code class="calibre25">spell_check</code>.</p>
</div>
<div class="readable-text" id="p43">
<p class="calibre15">It’s often but not always the case that we need a separate function for each of the subproblems we identify. Take a look at the input step again. We need to ask the user for a word. While we could split off a separate function for this subtask, that would be overkill. Why? This is because Python already has a built-in function for asking the user for input! The function is called <code class="calibre25">input</code>, and we saw it at work in chapter 3, section 3.3.7, when we were asking the user to enter passwords.</p>
</div>
<div class="readable-text" id="p44">
<p class="calibre15">Do we need to split off a separate function for the output step? No again! The output step is just outputting stuff to the user. We know that we can do that with Python’s already-existing print function. Again, it wouldn’t be a mistake to split off a function for this, and you may have done so if you were doing this problem decomposition on your own. What you’d notice, though, is that the function would be very short, consisting of not much more than a call of <code class="calibre25">print</code>—and at that point you might think again about whether you want it as a separate function or not.</p>
</div>
<div class="readable-text" id="p45">
<p class="calibre15">The process step, by comparison, is going to involve a lot more work. There’s quite a bit that goes into figuring out all the possible spelling suggestions! We have to support deleting a letter, inserting a letter, changing one letter to another, and so on, which is way too much to keep all in our main <code class="calibre25">spell_check</code> function. We need a separate function for the process step. This is what we need to work on next.</p>
</div>
<div class="readable-text" id="p46">
<h2 class="readable-text-h1" id="sigil_toc_id_102"><span class="calibre22">7.5</span> Breaking down the process subproblem</h2>
</div>
<div class="readable-text" id="p47">
<p class="calibre15">We need a name for our function that implements the process step. We’ll call it <code class="calibre25">get_spelling_suggestions</code> because it will be responsible for returning the spelling suggestions for what the user typed. It certainly needs to take the user’s misspelled word as an argument, or it wouldn’t have access to it! </p>
</div>
<div class="readable-text" id="p48">
<p class="calibre15">Pause here for a second, though: Do you think this function needs any additional parameters? Answer: it does! Somehow the function needs to know which strings are real words in English. For example, it has to know about the words <em class="calibre18">successful</em>, <em class="calibre18">thorough</em>, <em class="calibre18">acceptable</em>, and thousands of other English words. We could do that in a couple of ways: we could pass a list or (Python) dictionary of real words as a parameter, or we could pass the name of a file that contains all the real words as a parameter. When you’re designing your functions, you’ll need to make similar decisions, focused on the inputs that the function needs to do its work and the return value that we need when it’s done.</p>
</div>
<div class="readable-text" id="p49">
<p class="calibre15">In addition to the misspelled word, we’re going to have our function take a parameter giving the name of a file that contains the list of valid words. There will be one valid word per line of this file. In the resources for this book, we’ve included one sample word list file called wordlist.txt that you can use. (We found a list of free dictionary words online with a simple internet search.)</p>
</div>
<div class="readable-text" id="p50">
<p class="calibre15">What do we need to do for this process step? We can think of four subtasks. This is more problem decomposition! Those subtasks are as follows:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p51"> <em class="calibre18">Get a list of words from the word list file.</em> A file of words is a good start, but it’s more convenient to have the words inside a Python list. That way, we can easily determine if a string is a valid word. We’ll name this function <code class="calibre25">create_word_list</code>. </li>
<li class="readable-text1" id="p52"> <em class="calibre18">Generate a list of all possible words from the user’s string.</em> We need to delete a letter, insert a letter, or change one letter to another letter. This is going to generate many strings, some of which are real words and others that aren’t real words. For example, from the string <code class="calibre25">sucessful</code>, it would generate the real word <em class="calibre18">successful</em>, but also the strings <code class="calibre25">xsuccesful</code>, <code class="calibre25">sucxcesful</code>, and <code class="calibre25">succesfrl</code>, which are clearly not real words. But that’s OK. For now, we just want to generate every possible word so that we don’t miss any. We’ll name this function <code class="calibre25">all_possible_words</code>. </li>
<li class="readable-text1" id="p53"> <em class="calibre18">Using the list of all possible words, generate a list of only the real words.</em> This is the step where we prune our full list of potential words down to those words that actually exist in English. We’ll name this function <code class="calibre25">all_real_words</code>. </li>
<li class="readable-text1" id="p54"> <em class="calibre18">Return a list of the unique words.</em> Why unique? We don’t want to return the same spelling suggestion twice, even though there may be two or more ways to arrive at that spelling suggestion from the user’s string. For example, to fix the word <em class="calibre18">sucessful</em>, there are two ways to do it: we can add the missing <em class="calibre18">c</em> before the <em class="calibre18">c</em> that’s already there, or we can add the <em class="calibre18">c</em> before the <em class="calibre18">e</em>. Both result in the correctly spelled word <em class="calibre18">successful</em>, but we only want to maintain that word once. </li>
</ul>
<div class="readable-text" id="p55">
<p class="calibre15">If we were to split out that final subtask—obtaining a list of unique words—into its own function, we’d call it something like <code class="calibre25">unique_words</code> or <code class="calibre25">only_unique_words</code>. While we could split out that subtask, and you’d be justified in doing so, we’ve decided to keep it as part of the <code class="calibre25">get_spelling_suggestions</code> function. The reason is that in Python, it ends up being just one line of code to remove duplicates from a list. For expediency, we’re telling you this now, but again, this would be a perfectly good subtask if you were doing this top-down design on your own.</p>
</div>
<div class="callout-container">
<div class="readable-text" id="p56">
<h5 class="callout-container-h">Multiple ways to break down problems</h5>
</div>
<div class="readable-text" id="p57">
<p class="calibre15">There’s no single correct way to do a top-down design and no single correct way to decompose problems into subproblems. For example, you may have been surprised that we decided to first generate all possible words (including fake ones that aren’t actually English words), and then prune that to the list of actual English words. Why not just check each possible word first, and only add it to our list if it’s a real word? We certainly could have done it that way too! If you had this alternate decomposition in mind, or we’ve piqued your curiosity, we encourage you to try this alternate design on your own after you’ve finished with the chapter.</p>
</div>
<div class="readable-text" id="p58">
<p class="calibre15">There’s also no shame in trying a top-down design and then abandoning it if the design isn’t working out. What might it mean for the design to not work out? Well, maybe you’re finding it difficult to break up large functions into distinct subproblems. Or maybe you’re getting dozens of tiny functions and starting to worry that your functions are too specific and not solving general problems. Or maybe you’re having to pass around many parameters, perhaps some of which are only there to be passed further and further until finally a function needs them. Or maybe you just want to play out an alternate top-down design to see how it goes! </p>
</div>
<div class="readable-text" id="p59">
<p class="calibre15">We encourage experimentation at the design phase before you settle on a final design for the code. In this experimentation, you’d try different possible functions and different inputs/outputs for functions. For example, earlier we debated whether the <code class="calibre25">get_spelling_suggestions</code> function should take a name of a file containing real words or a list (or dictionary) containing real words. Both options would be worth considering during your design phase.</p>
</div>
</div>
<div class="readable-text" id="p60">
<p class="calibre15">That leaves us with three subtasks we need to solve. We’re going to do our top-down design on these shortly. But first, let’s take stock of where we are right now (see figure 7.3). <span/></p>
</div>
<div class="browsable-container" id="p61">
<img alt="figure" src="../Images/7-3.png" class="calibre61"/>
<h5 class="figure-container-h"><span>Figure 7.3</span> Functions diagram showing the three subtasks of <code class="calibre25">get_spelling_suggestions</code></h5>
</div>
<div class="readable-text" id="p62">
<h3 class="readable-text-h2" id="sigil_toc_id_103"><span class="calibre22">7.5.1</span> Getting the list of words from the word list file</h3>
</div>
<div class="readable-text" id="p63">
<p class="calibre15">The function for this task is <code class="calibre25">create_word_list</code>. It will take one parameter, which is the name of the word list file, and will return the list of words from that file.</p>
</div>
<div class="readable-text" id="p64">
<p class="calibre15">Do we need any further top-down design on this function? Let’s imagine we thought the answer was yes. What subtasks could we split out? We could imagine the tasks of opening the file, reading its contents, and closing the file. But opening the file, as we learned in chapter 5, section 5.1.4, is done by just calling Python’s <code class="calibre25">open</code> function. Similarly, closing the file is done by just calling Python’s <code class="calibre25">close</code> function. What about reading the words from the file? That doesn’t sound much different from reading the lines of the CSV file in chapter 5, section 5.1.4. So we feel justified in leaving this function alone, without any further subtask splitting.</p>
</div>
<div class="readable-text" id="p65">
<h3 class="readable-text-h2" id="sigil_toc_id_104"><span class="calibre22">7.5.2</span> Generating the list of all possible words</h3>
</div>
<div class="readable-text" id="p66">
<p class="calibre15">The function for this task is <code class="calibre25">all_possible_words</code>, which will take one parameter giving us the string for which we want to provide spelling suggestions. It will return the list of all possible words that can be obtained by adding one letter, deleting one letter, or changing one letter.</p>
</div>
<div class="readable-text" id="p67">
<p class="calibre15">Adding one letter, deleting one letter, and changing one letter are three distinct types of tasks. Moreover, they don’t strike us as particularly simple tasks: they’re going to involve some sort of loop over the letters in the user’s string. Aha! Looks like we have some further top-down design to do on this one. In particular, we’re going to split three subtasks out of this function:</p>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p68"> <code class="calibre25">add_letter</code>—This function will take a string parameter and return a list of all strings that can be obtained by adding one letter anywhere in the word. </li>
<li class="readable-text1" id="p69"> <code class="calibre25">delete_letter</code>—This function will take a string parameter and return a list of all strings that can be obtained by deleting one letter. </li>
<li class="readable-text1" id="p70"> <code class="calibre25">change_letter</code>—This function will take a string parameter and return a list of all strings that can be obtained by changing one letter. </li>
</ul>
<div class="readable-text" id="p71">
<p class="calibre15">Table 7.2 provides what we expect each function will return for two different input strings. For both add_letter and change_letter, a large number of strings are returned because they will consider adding or changing every letter in English in every location in the input string.</p>
</div>
<div class="browsable-container" id="p72">
<h5 class="browsable-container-h"><span>Table 7.2</span> Examples of the <code class="calibre25">add_letter</code>, <code class="calibre25">delete_letter</code>, and <code class="calibre25">change_letter</code> function</h5>
<table class="calibre36">
<thead class="calibre37">
<tr class="calibre38">
<th class="calibre39">
<div class="readable-text">
         Input String 
       </div></th>
<th class="calibre39">
<div class="readable-text">
         Strings Returned by 
        <code class="calibre25">add_letter</code>
</div></th>
<th class="calibre39">
<div class="readable-text">
         Strings Returned by 
        <code class="calibre25">delete_letter</code>
</div></th>
<th class="calibre39">
<div class="readable-text">
         Strings Returned by 
        <code class="calibre25">change_letter</code>
</div></th>
</tr>
</thead>
<tbody class="calibre40">
<tr class="calibre38">
<td class="calibre41"> <code class="calibre25">cu</code> <br class="calibre1"/></td>
<td class="calibre41"> <code class="calibre25">acu, bcu, ccu, …, zcu cau, cbu, ccu, …, czu cua, cub, cuc, …, cuz</code> <br class="calibre1"/></td>
<td class="calibre41"> <code class="calibre25">u, c</code> <br class="calibre1"/></td>
<td class="calibre41"> <code class="calibre25">au, bu, du, …, zu, ca, cb, cc, …, cz</code> <br class="calibre1"/></td>
</tr>
<tr class="calibre38">
<td class="calibre41"> <code class="calibre25">cad</code> <br class="calibre1"/></td>
<td class="calibre41"> <code class="calibre25">acad, bcad, ccad, …, zcad caad, cbad, ccad, …, czad caad, cabd, cacd, …, cazd cada, cadb, cadc, …, cadz</code> <br class="calibre1"/></td>
<td class="calibre41"> <code class="calibre25">ad, cd, ca</code> <br class="calibre1"/></td>
<td class="calibre41"> <code class="calibre25">aad, bad, dad, …, za cbd, ccd, cdd, …, czd caa, cab, cac, …, caz</code> <br class="calibre1"/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p73">
<p class="calibre15">As usual, it’s important to think through whether we need to split out further subtasks from these three functions. However, given that the pattern we expect to see is just a loop through the letters, we’d be comfortable pushing forward here and revisiting our top-down design if our assumption proves to be incorrect. For now, we can tell you that we’ll be just fine without any further splitting. </p>
</div>
<div class="callout-container">
<div class="readable-text" id="p74">
<h5 class="callout-container-h">Knowing when to stop dividing into subtasks</h5>
</div>
<div class="readable-text" id="p75">
<p class="calibre15">In general, knowing when to stop breaking a task into smaller subtasks is more art than science. It takes practice designing programs to get intuition about where to stop. Many experienced developers often pause for each subtask and consider how complex it is to program and sketch the steps of the function out in their mind. If the solution isn’t straightforward, they often choose to divide it into more steps. But we don’t expect you to be able to do this yet. Some companies put out guidelines to encourage simple functions by suggesting limits on the number of lines permitted (e.g., no more than 12 lines), but many feel the limit should be on the complexity moreso than the length, although length and complexity are certainly related.</p>
</div>
<div class="readable-text" id="p76">
<p class="calibre15">When you’re just getting started, a decent proxy then is to limit the number of lines per function to something like 12–20. If you later find that a function ends up being just a single line, it’s still a subtask, but may not deserve its own function. (Sometimes, it’s okay to keep a short function though if it’s called many times by different functions or helps simplify the calling function.)</p>
</div>
<div class="readable-text" id="p77">
<p class="calibre15">It’s okay to get this wrong when you’re first practicing; we certainly have. Sometimes a subtask seems like it’ll make a simple function, only to end up being much more difficult than expected. In cases like that, you know to just subdivide it more. Likewise, we’ve had functions that were a single line and if they were used commonly or made the calling function simpler to understand, we just kept that line as a function.</p>
</div>
</div>
<div class="readable-text" id="p78">
<h3 class="readable-text-h2" id="sigil_toc_id_105"><span class="calibre22">7.5.3</span> Generating the list of all real words</h3>
</div>
<div class="readable-text" id="p79">
<p class="calibre15">The function for this task is <code class="calibre25">all_real_words</code>. It will take two parameters: the list of real words, and the list of all possible words. It will return a list consisting of only the real words from the full list of possible words. The code for this function would involve going through the list of possible words and checking whether each one shows up in the list of real words. As this task is a small, well-defined task that won’t yield a lot of code, we’re comfortable leaving this function alone without any further splitting. </p>
</div>
<div class="readable-text" id="p80">
<h2 class="readable-text-h1" id="sigil_toc_id_106"><span class="calibre22">7.6</span> Summary of our top-down design</h2>
</div>
<div class="readable-text" id="p81">
<p class="calibre15">We’ve reached the end of our top-down design process. You can see our final top-down design in figure 7.4.<span/></p>
</div>
<div class="browsable-container" id="p82">
<img alt="figure" src="../Images/7-4.png" class="calibre62"/>
<h5 class="figure-container-h"><span>Figure 7.4</span> Functions diagram with the three subtasks of <code class="calibre25">all_possible_words</code> added</h5>
</div>
<div class="readable-text" id="p83">
<p class="calibre15">Let’s not lose the forest for the trees here. If we zoom out, what we’ve done is break down our original big problem into several smaller problems, each of which we’re going to implement as a function. Our original <code class="calibre25">spell_check</code> problem may have felt overwhelming. That’s OK, though, because we broke it down into one primary subtask of <code class="calibre25">get_spelling_suggestions</code>. The <code class="calibre25">get_spelling_suggestions</code> function is still a big problem in its own right, but we were able to solve that through the same process: we split it into three subtasks. Two of those subtasks, <code class="calibre25">create_word_list</code> and <code class="calibre25">all_real_words</code>, felt as though they could be solved in a single function, but the other task, <code class="calibre25">all_possible_words</code>, was complex enough that we felt it needed three more additional subtasks (<code class="calibre25">add_letter</code>, <code class="calibre25">delete_letter</code>, and <code class="calibre25">change_letter</code>). The important thing we want you to take away from this is that we used the same technique of problem decomposition at every step to turn an initially daunting task into just a collection of solvable subtasks that will become functions.</p>
</div>
<div class="readable-text" id="p84">
<p class="calibre15">Our next step is to move from design to implementation. We know which functions we need now to solve our problem. It’s time for the code!</p>
</div>
<div class="readable-text" id="p85">
<h2 class="readable-text-h1" id="sigil_toc_id_107"><span class="calibre22">7.7</span> Implementing our functions</h2>
</div>
<div class="readable-text" id="p86">
<p class="calibre15">When you’re doing a top-down design, as we just did, you start with your overall problem and break it into subproblems. That’s why we started with <code class="calibre25">spell_check</code> (our overall problem) and eventually reached functions such as <code class="calibre25">add_letter</code>, which didn’t need any further splitting. But when we ask Copilot to implement these functions, we’re not going to work in the same order. Rather, we’re going to work in the <em class="calibre18">opposite</em> order, doing the smallest subproblems first, then moving onto the functions that depend on those subproblems. This corresponds to moving from right to left in a figure such as figure 7.4, starting with leaf functions and continuing to nonleaf functions.</p>
</div>
<div class="readable-text" id="p87">
<p class="calibre15">We implement functions in the opposite order like this so that Copilot knows about the smaller functions by the time we want to implement larger functions. That way, Copilot will be more likely to call our subtask functions as desired.</p>
</div>
<div class="readable-text" id="p88">
<p class="calibre15">We want to stay squarely focused on problem decomposition here, and we’ve made some decisions toward that end. First, while we’ll include some tests in our docstrings, we won’t be pursuing full testing in this example as we would have done in chapter 6. We encourage you to use doctest to run the tests that we do provide as well as add your own tests for further confidence in the code. Second, we haven’t dwelled much on our prompt engineering, instead focusing on the prompts that yielded good results. In the next chapter, we’ll focus on debugging, and that’s where we’ll return to prompt engineering. Third, we’re not focusing on reading and understanding the code in full detail. That said, we’ve included some annotations to explain what the code is doing and how it works. </p>
</div>
<div class="readable-text" id="p89">
<h3 class="readable-text-h2" id="sigil_toc_id_108"><span class="calibre22">7.7.1</span> create_word_list</h3>
</div>
<div class="readable-text" id="p90">
<p class="calibre15">We’ll start with our <code class="calibre25">create_word_list</code> function. As in chapter 3, we write the function header (the <code class="calibre25">def</code> line) and the docstring, and Copilot fills in the code. This is how we’ll have Copilot write the code for all the functions in this chapter.</p>
</div>
<div class="readable-text" id="p91">
<p class="calibre15">We already know what our <code class="calibre25">create_word_list</code> function is supposed to do: read the words from the word list file and return them as a Python list of words. We carefully write what we want in the docstring, as shown in listing 7.1.</p>
</div>
<div class="browsable-container" id="p92">
<h5 class="listing-container-h"><span>Listing 7.1</span> Function to read the list of words</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def create_word_list(filename):  </strong><span/> #1
<strong class="calibre17">    '''                             </strong><span/> #2
<strong class="calibre17">    filename is the name of a file that has one English word per line.</strong>

<strong class="calibre17">    Return a list of the words in the file.</strong>
    '''
    file = open(filename)       <span/> #3
    words = []
    for line in file:             <span/> #4
        words.append(line.strip())   <span/> #5
    file.close()
    return words</pre>
<div class="code-annotations-overlay-container">
     #1 The header we wrote ourselves
     <br class="calibre1"/>#2 The docstring we wrote ourselves
     <br class="calibre1"/>#3 Opens the file
     <br class="calibre1"/>#4 Loops through each line of the file
     <br class="calibre1"/>#5 Adds each word to our list of words
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p93">
<p class="calibre15">We’ve used a descriptive parameter name, <code class="calibre25">filename</code>, which gives a good clue to the purpose of the parameter. We’ve also been careful to use this parameter name in the docstring. Our docstring also makes it explicit that we want to <em class="calibre18">return</em> the list (rather than, say, print it).</p>
</div>
<div class="readable-text" id="p94">
<p class="calibre15">We haven’t included a test in the docstring for this function, and that’s because we didn’t want to distract from the overall goal of implementing each of our functions. If you wanted to, though, you know how! Specifically, we did this in chapter 6 where we created a small file for purposes of testing. Here, you could create a small file with one word per line but with only a few English words, and then test that the list of words we read from the file matches the words that we put in the file. We’re finished with our <code class="calibre25">create_word_list</code> function, so we can mark it as complete as in figure 7.5.<span/></p>
</div>
<div class="browsable-container" id="p95">
<img alt="figure" src="../Images/7-5.png" class="calibre63"/>
<h5 class="figure-container-h"><span>Figure 7.5</span> Full functions diagram with <code class="calibre25">create_word_list</code> finished</h5>
</div>
<div class="readable-text" id="p96">
<p class="calibre15">To save space, we won’t show the updated figure after we implement each function, but we’ll show it occasionally.</p>
</div>
<div class="readable-text" id="p97">
<h3 class="readable-text-h2" id="sigil_toc_id_109"><span class="calibre22">7.7.2</span> add_letter</h3>
</div>
<div class="readable-text" id="p98">
<p class="calibre15">Now we’ll work on the functions that <code class="calibre25">all_possible_words</code> needs, starting with <code class="calibre25">add_letter</code>. The <code class="calibre25">add_letter</code> function takes a string as a parameter and returns the list of potential words that can be formed by adding one letter to that string. Let’s think briefly about what to expect from this function with a quick example. If we gave the function the string <code class="calibre25">cu</code> (as in table 7.2) it’s going to generate a list of words with every letter added to each possible position. This means it should include strings that have an <code class="calibre25">a</code> added before <code class="calibre25">cu</code> to make <code class="calibre25">acu</code>, a <code class="calibre25">b</code> added before <code class="calibre25">cu</code> to make <code class="calibre25">bcu</code>, and so forth for the character before <code class="calibre25">cu</code> stopping with <code class="calibre25">zcu</code>. The function should also include every letter in between <code class="calibre25">c</code> and <code class="calibre25">u</code> to form <code class="calibre25">cau</code>, <code class="calibre25">cbu</code>, <code class="calibre25">ccu</code>… . , <code class="calibre25">czu</code>. Lastly (as there are three possible positions to add a letter), we’d expect the function to add every possible letter after <code class="calibre25">cu</code> to form <code class="calibre25">cua</code>, <code class="calibre25">cub</code>, <code class="calibre25">cuc</code>,… . , <code class="calibre25">cuz</code>. Our prompt to Copilot and the code generated by Copilot is shown in listing 7.2.</p>
</div>
<div class="browsable-container" id="p99">
<h5 class="listing-container-h"><span>Listing 7.2</span> Function to add any possible letter</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def add_letter(word):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    word is a string with at least one letter.</strong>

<strong class="calibre17">    Return a list of all the strings that can be obtained by</strong>
<strong class="calibre17">    adding one letter to word.</strong>
<strong class="calibre17">    '''</strong>
    words = []
    for i in range(len(word) + 1):        <span/> #1
        for c in 'abcdefghijklmnopqrstuvwxyz': <strong class="calibre17">   </strong><span/> #2
            new_word = word[:i] + c + word[i:]   <span/> #3
            words.append(new_word)      <span/> #4
    return words</pre>
<div class="code-annotations-overlay-container">
     #1 Loops through each index, from 0 to just past the final character
     <br class="calibre1"/>#2 Loops through each lowercase letter
     <br class="calibre1"/>#3 Forms a new word by placing character c at index i
     <br class="calibre1"/>#4 Adds this new word to our list of words
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p100">
<p class="calibre15">The code here is quite subtle and deserves careful testing. For example, notice that the outer loop uses <code class="calibre25">len(word) + 1</code>, rather than the more standard <code class="calibre25">len(word)</code>. Without the <code class="calibre25">+ 1</code>, we would add characters at each existing index of the word string. But that would actually miss the fact that we also want to be able to add letters <em class="calibre18">past</em> the existing letters! The <code class="calibre25">+ 1</code> adds one extra iteration where we add a character to the end of the string. </p>
</div>
<div class="readable-text" id="p101">
<p class="calibre15">For each index of the outer loop, we consider each possible lowercase letter in the inner loop. The line <code class="calibre25">new_word = word[:i] + c + word[i:]</code> uses string slicing, the technique of extracting letters out of a string using two indices, to add the current inner-loop character to the current outer-loop position.</p>
</div>
<div class="readable-text" id="p102">
<p class="calibre15">Although we aren’t spending much time on testing in this chapter because the focus is problem decomposition, you would want to test this function by giving it a single misspelled word (i.e., <em class="calibre18">cu</em>) and then printing the returned words and ensuring it includes strings such as <code class="calibre25">acu</code> (add at the start), <code class="calibre25">cau</code> (add in the middle), and <code class="calibre25">cua</code> (add at the end), as well as possible real words such as <em class="calibre18">cup</em> and <em class="calibre18">cut</em>.</p>
</div>
<div class="readable-text" id="p103">
<p class="calibre15">Note that we wouldn’t want to include exact tests in the docstring because the lists returned by this function are huge! For example, try typing this at the Python prompt:</p>
</div>
<div class="browsable-container" id="p104">
<div class="readable-text">
<pre class="code-area">&gt;&gt;&gt; add_letter('cu')</pre>
</div>
</div>
<div class="readable-text" id="p105">
<p class="calibre15">You’ll get a list with 78 strings in it! And that’s for our tiny <code class="calibre25">'cu'</code> string. The number of strings returned in the list grows significantly as we increase the number of characters in the parameter string. </p>
</div>
<div class="readable-text" id="p106">
<h3 class="readable-text-h2" id="sigil_toc_id_110"><span class="calibre22">7.7.3</span> delete_letter</h3>
</div>
<div class="readable-text" id="p107">
<p class="calibre15">Like <code class="calibre25">add_letter</code>, <code class="calibre25">delete_letter</code> takes a string as a parameter and returns a list of potential words. The difference is that rather than adding a letter, <code class="calibre25">delete_letter</code> deletes each possible letter from the string to arrive at new possible words. Let’s think about what we expect this function to do. If we give it the string “carf”, it should try deleting each letter to produce the strings “arf” by deleting “c”, “crf” by deleting “a”, “caf” by deleting “r”, and “car” by deleting “f”. Again, we gave the prompt to Copilot for this function, as shown in listing 7.3.</p>
</div>
<div class="browsable-container" id="p108">
<h5 class="listing-container-h"><span>Listing 7.3</span> Function to delete any letter</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def delete_letter(word):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    word is a string with at least one letter.</strong>

<strong class="calibre17">    Return a list of all the strings that can be obtained by</strong>
<strong class="calibre17">    deleting one letter from word.</strong>

<strong class="calibre17">    &gt;&gt;&gt; delete_letter('carf')</strong>
<strong class="calibre17">    ['arf', 'crf', 'caf', 'car']</strong>
<strong class="calibre17">    &gt;&gt;&gt; delete_letter('a')</strong>
<strong class="calibre17">    ['']</strong>
<strong class="calibre17">    '''</strong>
    words = []
    for i in range(len(word)):       <span/> #1
            new_word = word[:i] + word[i + 1:]     <span/> #2
            words.append(new_word)    <span/> #3
    return words</pre>
<div class="code-annotations-overlay-container">
     #1 Loops through each index, from 0 to the final character
     <br class="calibre1"/>#2 Forms a new word by deleting character at index i
     <br class="calibre1"/>#3 Adds this new word to our list of words
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p109">
<p class="calibre15">This code is similar to our code for <code class="calibre25">add_letter</code>. One difference is that we have only one loop this time, not two. The reason is that we don’t need an inner loop to loop through the letters <em class="calibre18">a</em>, <em class="calibre18">b</em>, <em class="calibre18">c</em>, <em class="calibre18">d</em>, and so on. That’s because we’re deleting letters that already exist in the word, rather than figuring out which letter to add. </p>
</div>
<div class="readable-text" id="p110">
<h3 class="readable-text-h2" id="sigil_toc_id_111"><span class="calibre22">7.7.4</span> change_letter</h3>
</div>
<div class="readable-text" id="p111">
<p class="calibre15">Now, it’s time for our third and final subtask of <code class="calibre25">all_possible_words: change_letter</code>! This function is responsible for generating words where one letter in the string is changed to some other letter. In thinking about what we’d like to see happen here, let’s consider the string <code class="calibre25">cu</code> again (as in table 7.2). We want this function to replace the letter <em class="calibre18">c</em> with all possible letters to create the strings <code class="calibre25">au</code>, <code class="calibre25">bu</code>, <code class="calibre25">du</code>… . , <code class="calibre25">zu</code> and to replace the letter <em class="calibre18">u</em> with all possible letters to create the strings <code class="calibre25">ca</code>, <code class="calibre25">cb</code>, <code class="calibre25">cc</code>… . , <code class="calibre25">cz</code>. (Note that we omit trying <code class="calibre25">cu</code> as that’s the initial string, we only consider changes to letters.) See listing 7.4 for our prompt and the code from Copilot.</p>
</div>
<div class="browsable-container" id="p112">
<h5 class="listing-container-h"><span>Listing 7.4</span> Function to change any letter</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def change_letter(word):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    word is a string with at least one letter.</strong>

<strong class="calibre17">    Return a list of all the strings that can be obtained by</strong>
<strong class="calibre17">    changing one letter to another letter in word.</strong>
<strong class="calibre17">    '''</strong>
    words = []
    for i in range(len(word)):         <span/> #1
        for c in 'abcdefghijklmnopqrstuvwxyz':      <span/> #2
            if c != word[i]:                            <span/> #3
                new_word = word[:i] + c + word[i + 1:]   <span/> #4
                words.append(new_word)   <span/> #5
    return words</pre>
<div class="code-annotations-overlay-container">
     #1 Loops through each index, from 0 to the final character
     <br class="calibre1"/>#2 Loops through each lowercase letter
     <br class="calibre1"/>#3 If c is a different letter from the letter at index i
     <br class="calibre1"/>#4 Forms a new word by changing the character at index i to character c
     <br class="calibre1"/>#5 Adds this new word to our list of words
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p113">
<p class="calibre15">This code is quite similar to our <code class="calibre25">add_letter</code> code! The main difference is that we use string slicing not to add a new character but to change an existing character.</p>
</div>
<div class="readable-text" id="p114">
<p class="calibre15">At this point, we’ve completed the three functions we need to implement <code class="calibre25">all_possible_words</code>. Check out figure 7.6, where we’ve marked off the substantial progress that we’ve made! We’ll next tackle <code class="calibre25">all_possible_words</code>.<span/></p>
</div>
<div class="browsable-container" id="p115">
<img alt="figure" src="../Images/7-6.png" class="calibre63"/>
<h5 class="figure-container-h"><span>Figure 7.6</span> Full functions diagram with <code class="calibre25">all_possible_words</code> helper functions finished</h5>
</div>
<div class="readable-text" id="p116">
<h3 class="readable-text-h2" id="sigil_toc_id_112"><span class="calibre22">7.7.5</span> all_possible_words</h3>
</div>
<div class="readable-text" id="p117">
<p class="calibre15">The reason we can now implement <code class="calibre25">all_possible_words</code> is that we’ve already implemented the three subtask functions that <code class="calibre25">all_possible_words</code> needs to do its job. When we ask Copilot to write this code, we’re expecting to see calls of <code class="calibre25">add_letter</code>, <code class="calibre25">delete_letter</code>, and <code class="calibre25">change_letter</code>. Take a look at listing 7.5, and you’ll see Copilot doing exactly this with the prompt we’ve given it.</p>
</div>
<div class="browsable-container" id="p118">
<h5 class="listing-container-h"><span>Listing 7.5</span> Function to generate all possible words</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def all_possible_words(word):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    word is a string with at least one letter.</strong>

<strong class="calibre17">    Return a list of all the strings that can be obtained by</strong>
<strong class="calibre17">    adding one letter to word, deleting one letter from word,</strong>
<strong class="calibre17">    or changing one letter in word.</strong>
<strong class="calibre17">    '''</strong>
    return add_letter(word) + delete_letter(word) \   <span/> #1
             + change_letter(word)   <span/> #2</pre>
<div class="code-annotations-overlay-container">
     #1 Calls helper functions to add a letter and delete a letter
     <br class="calibre1"/>#2 Calls helper function to change a letter
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p119">
<p class="calibre15">Generating all possible words is no easy feat. Yet, we’ve managed to do it with a single line of Python code here! It just calls to three helper functions and that’s it. This is exactly why we’re doing top-down design: to make complex functions much easier to implement by offloading much of their complexity to helper functions.</p>
</div>
<div class="readable-text" id="p120">
<h3 class="readable-text-h2" id="sigil_toc_id_113"><span class="calibre22">7.7.6</span> all_real_words</h3>
</div>
<div class="readable-text" id="p121">
<p class="calibre15">We’re close to being able to implement <code class="calibre25">get_spelling_suggestions</code>, but not quite, because we first need to implement its subtask function <code class="calibre25">all_real_words</code>. The <code class="calibre25">all_ real_words</code> function takes two parameters. The first parameter is the English word list (this will come from an English word list file). The second parameter is the list of possible words (this will come from <code class="calibre25">all_possible_words</code>). The function returns the list of possible words that are real words. Let’s do this!</p>
</div>
<div class="browsable-container" id="p122">
<h5 class="listing-container-h"><span>Listing 7.6</span> Function to generate all real words</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def all_real_words(word_list, possible_words):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    word_list is a list of English words.</strong>
<strong class="calibre17">    possible_words is a list of possible words.</strong>

<strong class="calibre17">    Return a list of words from possible_words that are in word_list.</strong>
<strong class="calibre17">    &gt;&gt;&gt; english_words = ['scarf', 'cat', 'card', 'cafe']</strong>
<strong class="calibre17">    &gt;&gt;&gt; possible_words = ['carfe', 'card', 'cat', 'cafe']</strong>
<strong class="calibre17">    &gt;&gt;&gt; all_real_words(english_words, possible_words)</strong>
<strong class="calibre17">    ['card', 'cat', 'cafe']</strong>
<strong class="calibre17">    '''</strong>
    real_words = []
    for word in possible_words:      <span/> #1
        if word in word_list:          <span/> #2
            real_words.append(word)   <span/> #3
    return real_words</pre>
<div class="code-annotations-overlay-container">
     #1 Loops through the possible words
     <br class="calibre1"/>#2 Is this word a real word?
     <br class="calibre1"/>#3 Yes: add the word to the list of real words that we’ll return
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p123">
<p class="calibre15">The test in the docstring is a good example of how this function works. It’s using the <code class="calibre25">english_words</code> list for the first parameter and the <code class="calibre25">possible_words</code> list as the second parameter. The function will return those words from <code class="calibre25">possible_words</code> that are also in <code class="calibre25">english_words</code>. We’re using this very small test case, rather than using thousands of English words, because this makes it much easier for us to determine by hand what the correct return value should be!</p>
</div>
<div class="readable-text" id="p124">
<p class="calibre15">Let’s check how well we’re progressing in figure 7.7. We’re getting close—just two functions to go!<span/></p>
</div>
<div class="browsable-container" id="p125">
<img alt="figure" src="../Images/7-7.png" class="calibre63"/>
<h5 class="figure-container-h"><span>Figure 7.7</span> Full functions diagram with <code class="calibre25">all_possible_words</code> and <code class="calibre25">all_real_words</code> finished</h5>
</div>
<div class="readable-text" id="p126">
<h3 class="readable-text-h2" id="sigil_toc_id_114"><span class="calibre22">7.7.7</span> get_spelling_suggestions</h3>
</div>
<div class="readable-text" id="p127">
<p class="calibre15">We’ve implemented <code class="calibre25">create_word_list</code>, <code class="calibre25">all_possible_words</code>, and <code class="calibre25">all_real_words</code>, and those are the only three subtask functions that <code class="calibre25">get_spelling_suggestions</code> needs. That means it’s time for us to implement <code class="calibre25">get_spelling_suggestions</code>!</p>
</div>
<div class="readable-text" id="p128">
<p class="calibre15">This function takes two parameters: the name of a file that contains real words (one word per line) and the string that we want to provide suggestions for. It returns the list of the unique suggestions. As always, when scrutinizing Copilot code for a nonleaf function, you want to check that it’s calling the helper functions that you expect it to be calling, as shown in listing 7.7. Before you move on, convince yourself that it’s calling all the helper functions that it should be calling.</p>
</div>
<div class="browsable-container" id="p129">
<h5 class="listing-container-h"><span>Listing 7.7</span> Function to return spelling suggestions</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def get_spelling_suggestions(word_file, possible_word):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    word_file is the name of a file that has one English word per line.</strong>
<strong class="calibre17">    possible_word is a string that may or may not be a real word.</strong>

<strong class="calibre17">    Return the list of all possible unique corrections </strong>
<strong class="calibre17">    for possible_word.</strong>
<strong class="calibre17">    '''</strong>
    word_list = create_word_list(word_file)       <span/> #1
    possible_words = all_possible_words(possible_word)       <span/> #2
    real_words = all_real_words(word_list, possible_words)   <span/> #3
    return list(set(real_words))   <span/> #4</pre>
<div class="code-annotations-overlay-container">
     #1 Gets the list of English words
     <br class="calibre1"/>#2 Gets the list of possible words
     <br class="calibre1"/>#3 Figures out which possible words are spelling suggestions
     <br class="calibre1"/>#4 Returns the unique list of spelling suggestions
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p130">
<p class="calibre15">That last line there is tricky. Apparently, it’s ensuring that we return only unique words—but how? Let’s ask Copilot to explain! Here’s the explanation that we got when we used the <code class="calibre25">/explain</code> command to Copilot:</p>
</div>
<div class="readable-text4" id="p131">
<p class="calibre54"><span class="response-head"><img alt="chatGpt" height="20" src="../Images/chatGpt.png" width="20" class="calibre64"/>Copilot</span> This line of Python code is performing two operations:</p>
</div>
<ol class="calibre28">
<li class="readable-text5" id="p132"> <code class="calibre25">set(real_words)</code>: This is creating a set from the <code class="calibre25">real_words</code> list. A set in Python is an unordered collection of unique elements. So, this operation is removing any duplicate elements from the <code class="calibre25">real_words</code> list. </li>
<li class="readable-text5" id="p133"> <code class="calibre25">list(set(real_words))</code>: This is converting the set back into a list. The result is a list where all elements are unique. </li>
</ol>
<div class="readable-text4" id="p134">
<p class="calibre54">So, in summary, this line of code is removing any duplicate words from the <code class="calibre25">real_ words</code> list.</p>
</div>
<div class="readable-text" id="p135">
<h3 class="readable-text-h2" id="sigil_toc_id_115"><span class="calibre22">7.7.8</span> spell_check</h3>
</div>
<div class="readable-text" id="p136">
<p class="calibre15">We’ve made it to our final function, <code class="calibre25">spell_check</code>! It takes one parameter: a string indicating the name of a word list file. It asks the user to type a string, and then shows the user all spelling corrections for that string.</p>
</div>
<div class="browsable-container" id="p137">
<h5 class="listing-container-h"><span>Listing 7.8</span> Our main function that interacts with the user</h5>
<div class="readable-text">
<pre class="code-area"><strong class="calibre17">def spell_check(word_file):</strong>
<strong class="calibre17">    '''</strong>
<strong class="calibre17">    word_file is the name of a file that has one English word per line.</strong>
<strong class="calibre17">    Ask user for a word.</strong>
<strong class="calibre17">    Print all possible corrections for the word, one per line.</strong>
<strong class="calibre17">    '''</strong>
    word = input('Enter a word: ')                         <span/> #1
    suggestions = get_spelling_suggestions(word_file, word)   <span/> #2
    for suggestion in suggestions:    <span/> #3
        print(suggestion)   <span/> #4</pre>
<div class="code-annotations-overlay-container">
     #1 Asks the user to type a string
     <br class="calibre1"/>#2 Gets the spelling suggestions for the user
     <br class="calibre1"/>#3 Loops through the spelling suggestions
     <br class="calibre1"/>#4 Prints each spelling suggestion on its own line
     <br class="calibre1"/>
</div>
</div>
</div>
<div class="readable-text" id="p138">
<p class="calibre15">Consult figure 7.8 to see that we have indeed implemented all of our functions!<span/></p>
</div>
<div class="browsable-container" id="p139">
<img alt="figure" src="../Images/7-8.png" class="calibre65"/>
<h5 class="figure-container-h"><span>Figure 7.8</span> Full functions diagram with all functions complete!</h5>
</div>
<div class="readable-text" id="p140">
<p class="calibre15">You need to add one line of code at the bottom of your Python program to actually call this function. Otherwise, your program won’t do anything because no function is being called! So, add this line at the bottom:</p>
</div>
<div class="browsable-container" id="p141">
<div class="readable-text">
<pre class="code-area">spell_check('wordlist.txt')</pre>
</div>
</div>
<div class="readable-text" id="p142">
<p class="calibre15">Now, assuming that you have the wordlist.txt file in your directory along with your Python program, you can run it! It will ask you to type a word. Try typing the misspelled word <em class="calibre18">sucessful</em> (the word that started it all!), and you should see the program provide the spelling suggestion of <em class="calibre18">successful</em>, like this:</p>
</div>
<div class="browsable-container" id="p143">
<div class="readable-text">
<pre class="code-area">Enter a word: sucessful
successful</pre>
</div>
</div>
<div class="readable-text" id="p144">
<p class="calibre15">Try other misspelled words too, such as <em class="calibre18">thourough</em> and <em class="calibre18">acceptible</em>. With these misspelled words so far, our program is replying with only a single spelling suggestion because there is only one real word a single edit away from the words we’re trying. We encourage you to try entering the word <em class="calibre18">carf</em> to see that our program can provide many possible spelling suggestions.</p>
</div>
<div class="readable-text" id="p145">
<p class="calibre15">Congratulations! You’ve completed your first real-world top-down design. Your program provides spelling suggestions for a word, much as a spellchecker does. We made the problem considerably easier to implement by doing some up-front design work to break down the original problem into smaller subproblems.</p>
</div>
<div class="readable-text" id="p146">
<p class="calibre15">Many computer scientists view problem decomposition as <em class="calibre18">the</em> most critical skill needed to write good software [1]. We saw the value of problem decomposition in this chapter: it made a large problem solvable by breaking it into smaller steps until each step was easier to solve. We applied this skill in this chapter using top-down design (start with the large task and break it into smaller tasks) to put it in practice. This skill remains critical when working with tools such as Copilot and ChatGPT because they perform better when solving small, well-defined problems compared to large problems. As mentioned at the beginning of the chapter, problem decomposition is more of an art than a science, and it takes practice to get it right. We’ll do more problem decomposition in our upcoming chapters to help give you more intuition into how to approach it yourself.</p>
</div>
<div class="readable-text" id="p147">
<h2 class="readable-text-h1" id="sigil_toc_id_116"><span class="calibre22">7.8</span> Exercises</h2>
</div>
<ol class="calibre28">
<li class="readable-text1" id="p148"> Using the examples of <code class="calibre25">get_strong_password</code> and <code class="calibre25">best_word</code> discussed previously, let’s apply the top-down design approach to a new problem. Suppose we want to write a function called <code class="calibre25">find_highest_scoring_word</code> that takes a list of sentences as its parameter and returns the word with the highest score from all the sentences. Each word’s score is calculated the same way as in the <code class="calibre25">best_word</code> function: 
    <ol class="calibre48">
<li class="calibre30"> Identify the subtasks needed to solve this problem. What are the individual functions you would design to break down the task into smaller, manageable pieces? </li>
<li class="calibre30"> Draw a function diagram similar to figures 7.1 and 7.2, depicting how these functions would call each other to solve the overall problem. </li>
</ol></li>
<li class="readable-text1" id="p149"> We talked about how sometimes a task is simple enough to be kept as it is, that is, not broken down into smaller tasks. Given the following tasks, decide if you would divide them into smaller subtasks. If so, list the subtasks and explain why. If not, explain why the task is simple enough to remain a single function. 
    <ol class="calibre48">
<li class="calibre30"> Reading a file and printing its contents </li>
<li class="calibre30"> Calculating the average grade for a class of students from a list of scores </li>
<li class="calibre30"> Finding the maximum value in a list of numbers </li>
<li class="calibre30"> Processing an order for an online store, which includes verifying the order, calculating the total price, applying discounts, and generating an invoice </li>
</ol></li>
<li class="readable-text1" id="p150"> Why did we choose to create the <code class="calibre25">create_word_list</code> function as a separate function? Could this task be kept as part of a larger function? Explain your reasoning. </li>
<li class="readable-text1" id="p151"> Imagine you need to change the way the spell-checker works. Specifically, you want to modify the <code class="calibre25">add_letter</code> function to exclude certain letters (e.g., <em class="calibre18">q</em>, <em class="calibre18">x</em>, <em class="calibre18">z</em>) from being added. How would you modify the program we’ve written? </li>
<li class="readable-text1" id="p152"> The following function processes a list of orders, calculates the total price with tax, applies a discount if applicable, and generates a summary report. </li>
</ol>
<div class="browsable-container" id="p153">
<div class="readable-text">
<pre class="code-area">def process_orders(orders):
    total_price = 0
    for order in orders:
        price = order['price']
        quantity = order['quantity']
        total_price += price * quantity
    tax = total_price * 0.08
    total_price_with_tax = total_price + tax
    report = f"Total price: ${total_price:.2f}\n"
    report += f"Tax: ${tax:.2f}\n"
    if total_price_with_tax &gt; 100:
        discount = total_price_with_tax * 0.1
        total_price_with_tax -= discount
        report += f"Discount: ${discount:.2f}\n"
    report += f"Total price with tax: ${total_price_with_tax:.2f}\n"
    print(report)

a = {'price': 20, 'quantity': 5}
lst = [a]
process_orders(lst)</pre>
</div>
</div>
<div class="readable-text" id="p154">
<p class="calibre15">Refactor (redesign) the <code class="calibre25">process_orders</code> function by breaking it down into smaller subproblems. Implement each subproblem as a separate function, and ensure the overall behavior remains the same.</p>
</div>
<ol class="faux-ol-li">
<li class="readable-text3" id="p155"><span class="faux-ol-li-counter">6. </span> In this exercise, you’re given a code snippet already broken down into two functions: a main function and a helper function. When we call the function with Test Case 2 in the following code, we get a <code class="calibre25">ZeroDivisionError</code>. Your task is to identify and fix the error based on the provided error message. </li>
</ol>
<div class="browsable-container" id="p156">
<div class="readable-text">
<pre class="code-area">def calculate_average(numbers):
    total = sum(numbers)
    count = len(numbers)
    return total / count

def process_numbers(data):
    valid_numbers = [n for n in data if isinstance(n, int)]
    average = calculate_average(valid_numbers)
    print(f"The average of the valid numbers is: {average}")

# Test Case 1
data = [10, 20, 'a', 30, 'b', 40]
process_numbers(data)

# Test Case 2
data = ['a', 'b']
process_numbers(data)</pre>
</div>
</div>
<div class="readable-text" id="p157">
<h2 class="readable-text-h1" id="sigil_toc_id_117">Summary</h2>
</div>
<ul class="calibre24">
<li class="readable-text1" id="p158"> We need to divide a big programming problem into smaller subproblems before we can effectively implement it. This is known as problem decomposition. </li>
<li class="readable-text1" id="p159"> Top-down design is a systematic technique for breaking a problem down into small subtask functions. </li>
<li class="readable-text1" id="p160"> In top-down design, we seek small functions that solve well-defined tasks and that can be used by one or more other functions. </li>
<li class="readable-text1" id="p161"> When we’re ready to implement our functions that arose from top-down design, we implement them from the bottom up; that is, we implement the leaf functions first, then functions that depend on those leaf functions, and so on until we implement the topmost function. </li>
</ul>
</div></body></html>