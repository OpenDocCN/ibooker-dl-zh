- en: Appendix A. Search and optimization libraries in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This appendix covers setting up the Python environment, along with essential
    libraries for mathematical programming, graph visualization, metaheuristic optimization,
    and machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: A.1 Setting up the Python environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This book assumes that you already have Python 3.6 or a newer version installed
    on your system. For installation instructions specific to your operating system,
    see this Beginner’s Guide: [https://wiki.python.org/moin/BeginnersGuide/](https://wiki.python.org/moin/BeginnersGuide/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, you can follow these steps to install Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the official website: [www.python.org/downloads/](https://www.python.org/downloads/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the version of Python to install.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the Python executable installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the executable installer. Make sure you check the Install Launcher for all
    users and Add Python 3.8 to PATH checkboxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that Python was successfully installed by typing `python –V` in a command
    prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that pip was installed by typing `pip -V` in a command prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install `virtualenv` by typing `pip install` `virtualenv` in a command prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are a Linux user, execute the following commands in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Install venv and create a Python virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you replace `python3.8` with the version of Python you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now access your virtual environment using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of macOS, Python is already preinstalled, but if you need to upgrade
    or install a specific version, you can use the macOS terminal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`venv` is included with python 3.8+. You can run the following command to create
    a virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now access your virtual environment using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A better option is to install a Python distribution as explained in the next
    subsection.
  prefs: []
  type: TYPE_NORMAL
- en: A.1.1 Using a Python distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python distributions, such as Anaconda or Miniconda, come with a package manager
    called `conda` that allows you to install a wide range of Python packages and
    manage different Python environments. Install `conda` for your OS using the guide
    found here: [https://conda.io/projects/conda/en/latest/user-guide/install/index.html](https://conda.io/projects/conda/en/latest/user-guide/install/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conda environments are used to manage multiple installations of different versions
    of Python packages and their dependencies. You can create a `conda` environment
    with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Access the newly created environment like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This command allows you to switch or move between environments.
  prefs: []
  type: TYPE_NORMAL
- en: A.1.2 Installing Jupyter Notebook and JupyterLab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jupyter is a multi-language, open-source web-based platform for interactive
    programming ([https://jupyter.org/](https://jupyter.org/)). The name “Jupyter”
    is a loose acronym meaning Julia, Python, and R. All of the code in this book
    is stored in Jupyter notebooks (.ipynb files), which can be opened and edited
    using JupyterLab or Jupyter Notebook. Jupyter Notebook feels more standalone,
    but JupyterLab feels more like an IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install JupyterLab using `pip` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or using `conda` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can install the Python ipywidgets package to automatically configure classic
    Jupyter Notebook and JupyterLab 3.0 to display ipywidgets using `pip` or `conda`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have an old version of Jupyter Notebook installed, you may need to manually
    enable the ipywidgets notebook extension with these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Google Colaboratory (Colab) can also be used. This cloud-based tool allows
    you to write, execute, and share Python code through the browser. It also provides
    free access to GPU and TPU for increased computational power. You can access Colab
    here: [https://colab.research.google.com/](https://colab.research.google.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: A.1.3 Cloning the book’s repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can clone this book’s code repository as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Many of the operations in this book are long and burdensome to code from scratch.
    Often, they’re highly standardized and can benefit from having a helper function
    take care of the various intricacies. `optalgotools` is a Python package developed
    for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these supporting tools locally without installing this package.
    To do so, you will need to download `optalgotools` in a local folder and add this
    folder to the system path. If you’re using Jupyter notebook or Jupyter lab, you
    can do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re using Colab, you can mount your Google Drive with these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then copy the `optalgotools` folder to your Google Drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'This package is also available on the Python Package Index (PyPI) repository
    here: [https://pypi.org/project/optalgotools/](https://pypi.org/project/optalgotools/).
    You can install it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use the `import` command to use these tools. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first line imports the `TSP` instance from the `problems` module, and the
    second line imports a simulated annealing solver from the `algorithms` module.
  prefs: []
  type: TYPE_NORMAL
- en: A.2 Mathematical programming solvers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Mathematical programming*, also known as *mathematical optimization*, is the
    process of finding the best solution to a problem that can be represented in mathematical
    terms. It involves formulating a mathematical model of a problem, determining
    the parameters of the model, and using mathematical and computational techniques
    to find a solution that maximizes or minimizes a particular objective function
    or set of objective functions subject to a set of constraints. Linear programming
    (LP), mixed-integer linear programming (MILP), and nonlinear programming (NLP)
    are examples of mathematical optimization problems. Several Python libraries can
    be used for solving mathematical optimization problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider the following production planning example from Guerte el al.’s
    *Linear Programming* [1]. A small woodworking shop produces two sizes of boxwood
    chess sets. Crafting the smaller set involves 3 hours of lathe machining, while
    the larger set requires 2 hours. With four skilled operators each working a 40-hour
    week, the shop has a total of 160 lathe-hours available weekly. The smaller chess
    set consumes 1 kg of boxwood, while the larger set requires 3 kg. However, due
    to scarcity, only 200 kg of boxwood can be obtained per week. Upon sale, each
    large chess set generates a profit of $12, while each small set yields $5 in profit.
    The objective is to determine the optimal weekly production quantities for each
    set to maximize profit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that *x*[1] and *x*[2] are decision variables that represent the
    number of small and large chess sets respectively to make. The total profit is
    the sum of the individual profits from making and selling the *x*[1] small sets
    and the *x*[2] large sets: profit = 5*x*[1] + 12*x*[2]. However, this profit is
    subject to the following constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: The total number of hours of machine time we will use is 3*x*[1] + 2*x*[2].
    This time shouldn’t exceed the maximum of 160 hours of machine time available
    per week. This means that 3*x*[1] + 2*x*[2] ≤ 160 (lathe-hours).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only 200 kg of boxwood is available each week. Since small sets use 1 kg for
    every set made, against 3 kg needed to make a large set, *x*[1] + 3*x*[2] ≤ 200
    (kg of boxwood).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The joinery cannot produce a negative number of chess sets, so we have two
    further non-negativity constraints: *x*[1] and *x*[2] >= 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This linear programming problem can be summarized as follows. Find *x*[1] and
    *x*[2] that maximize 5*x*[1] + 12*x*[2], subject to
  prefs: []
  type: TYPE_NORMAL
- en: 'Machining time constraint: 3*x*[1] + 2*x*[2] ≤ 160'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Weight constraint: *x*[1] + 3*x*[2] ≤ 200'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-negativity constraints: *x*[1] and *x*[2] ≥ 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see how we can solve this linear programming problem using different solvers.
  prefs: []
  type: TYPE_NORMAL
- en: A.2.1 SciPy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[SciPy](https://scipy.org/) is an open source scientific computing Python library
    that provides tools for optimization, linear algebra, and statistics. SciPy optimize
    is a submodule of the SciPy library, which includes solvers for nonlinear problems
    (with support for both local and global optimization algorithms), linear programing,
    constrained and nonlinear least-squares, root finding, and curve fitting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use SciPy, you will need to install it and its dependencies. You can install
    SciPy using the pip package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can use a Python distribution, such as Anaconda or Miniconda,
    that comes with SciPy and other scientific libraries pre-installed.
  prefs: []
  type: TYPE_NORMAL
- en: Listing A.1 shows the steps to solve the car manufacturing problem using SciPy.
    The code defines the coefficient vector `c` and the left-hand side (`lhs`) and
    right-hand side (`rhs`) of the constraint equations. The objective function represents
    the profit to be maximized. Since many optimization algorithms in SciPy are designed
    for minimization, the problem of profit maximization is typically converted into
    a minimization problem by minimizing the negative of the profit function. Moreover,
    constraints using the greater-than-or-equal-to sign cannot be defined directly.
    Less-than-or-equal-to must be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: Listing A.1 Solving the chess set problem using SciPy
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: ① Declare coefficients of the objective function.
  prefs: []
  type: TYPE_NORMAL
- en: ② Left-hand side of the machining time constraint
  prefs: []
  type: TYPE_NORMAL
- en: ③ Left-hand side of the weight constraint
  prefs: []
  type: TYPE_NORMAL
- en: ④ Right-hand side of the machining time constraint
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Right-hand side of the weight constraint
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Bounds of the decision variables
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Solve the linear programming problem.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Print the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code gives the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `linprog()` function used in the preceding code returns a data structure
    with several attributes such as `x` (the current solution vector), `fun` (the
    current value of the objective function), and `success` (`true` when the algorithm
    has completed successfully).
  prefs: []
  type: TYPE_NORMAL
- en: A.2.2 PuLP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PuLP](https://coin-or.github.io/pulp/) is a linear programming library in
    Python that allows you to define and solve linear optimization problems. There
    are two main classes in PuLP: `LpProblem` and `LpVariable`. PuLP variables can
    be declared individually or as “dictionaries” (variables indexed on another set).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install PuLP using pip as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code (a continuation of listing A.1) shows how to use PuLP to
    solve the chess set problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: ① Define the model.
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the decision variables.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Add constraints.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set the profit as the objective function.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Solve the optimization problem.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Print the solution.
  prefs: []
  type: TYPE_NORMAL
- en: PuLP implements several algorithms for solving linear programming (LP) and mixed-integer
    linear programming (MILP) problems. Examples include COIN-OR (computational infrastructure
    for operations research), CLP (COIN-OR linear programming), Cbc (COIN-OR branch
    and cut), CPLEX (Cplex), GLPK (GNU linear programming lit), SCIP (solving constraint
    integer programs), HiGHS (highly scalable global solver), Gurobi LP/MIP solver,
    Mosek optimizer, and the XPRESS LP solver.
  prefs: []
  type: TYPE_NORMAL
- en: A.2.3 Other mathematical programming solvers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several other libraries in Python for solving mathematical optimization
    problems. This is a non-exhaustive list of other available libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[OR-Tools](https://developers.google.com/optimization)—This is an open source
    software suite for optimization and constraint programming developed by Google.
    It includes a variety of algorithms and tools for solving problems in areas such
    as operations research, transportation, scheduling, and logistics. OR-Tools can
    be used to model and solve linear and integer programming problems, as well as
    constraint programming problems. Examples of OR-Tools solvers include GLOP (Google
    linear programming), Cbc (COIN-OR branch and cut), CP-SAT (constraint programming-satisfiability)
    solver, max flow and min cost flow solvers, the shortest path solver, and the
    BOP (binary optimization problem) solver. It is written in C++ and includes interfaces
    for several programming languages, including Python, C#, and Java. See section
    A.4.5 for more details and an example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Gurobi](https://www.gurobi.com/documentation/)—This is commercial optimization
    software that offers state-of-the-art solvers for linear programming, quadratic
    programming, and mixed integer programming. It has a Python interface that can
    be used to define and solve optimization problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CasADi](https://web.casadi.org/)—This is an open source tool for nonlinear
    optimization and algorithmic differentiation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python-MIP](https://www.python-mip.com/)—This is a Python library for solving
    mixed-integer programming problems. It is built on top of the Cbc open source
    optimization library and allows users to express optimization models in a high-level,
    mathematical programming language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pyomo](http://www.pyomo.org/)—This is an open source optimization modeling
    language that can be used to define and solve mathematical optimization problems
    in Python. It supports a wide range of optimization solvers, including for linear
    programming, mixed integer programming, and nonlinear optimization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GEKKO](https://gekko.readthedocs.io/en/latest/)—This is a Python package for
    machine learning and the optimization of mixed-integer and differential algebraic
    equations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CVXPY](https://www.cvxpy.org/)—This is an open source Python-embedded modeling
    language for convex optimization problems. It lets you express your problem in
    a natural way that follows the math, rather than in the restrictive standard form
    required by solvers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PyMathProg](https://pymprog.sourceforge.net/)—This is a mathematical programming
    environment for Python that allows for modeling, solving, analyzing, modifying,
    and manipulating linear programming problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Optlang](https://optlang.readthedocs.io/en/latest/)—This is a Python library
    for modeling and solving mathematical optimization problems. It provides a common
    interface to a series of optimization tools so that different solver backends
    can be changed in a transparent way. It is compatible with most of the popular
    optimization solvers like Gurobi, Cplex, and Ipopt (interior point optimizer).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python interface to conic optimization solvers (PICOS)](https://picos-api.gitlab.io/picos/)—This
    is a Python library for modeling and solving optimization problems. It can handle
    complex problems with multiple objectives, and it supports both local and global
    optimization methods. PICOS has interfaces to different solvers such as Gurobi,
    CPLEX, SCS (splitting conic solver), ECOS (embedded cone solver), and MOSEK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CyLP](https://github.com/coin-or/cylp)—This is a Python interface to COIN-OR’s
    linear and mixed-integer program solvers (CLP, Cbc, and CGL). COIN-OR (computational
    infrastructure for operations research) is a collection of open source software
    packages for operations research and computational optimization. It includes libraries
    for linear and integer programming, constraint programming, and other optimization
    techniques.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SymPy](https://www.sympy.org/en/index.html)—This is a Python library for symbolic
    mathematics. It can be used to solve equations, handle combinatorics, plot in
    2D/3D, or work on polynomials, calculus, discrete math, matrices, geometry, parsing,
    physics, statistics, and cryptography.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Other libraries*—These include but are not limited to, [MOSEK](https://docs.mosek.com/latest/pythonapi/index.html),
    [CVXOPT](https://cvxopt.org/), ,, , , and .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jupyter notebook “Listing A.1_Mathematical_programming_solvers.ipynb,” included
    in the GitHub repo for the book shows how to use some of these solvers to solve
    the chess set problem.
  prefs: []
  type: TYPE_NORMAL
- en: A.3 Graph and mapping libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following Python libraries are used in this book to process and visualize
    graphs, networks, and geospatial data.
  prefs: []
  type: TYPE_NORMAL
- en: A.3.1 NetworkX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[NetworkX](https://networkx.org/) is a library for working with graphs and
    networks in Python. It provides tools for creating, manipulating, and analyzing
    graph data, as well as for visualizing graph structures. NetworkX also contains
    approximations of graph properties and heuristic methods for optimization. You
    can install NetworkX as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let’s consider the traveling salesman problem (TSP). Listing A.2 shows the steps
    for creating a random undirected graph for this problem. Each randomly scattered
    node represents a city to be visited by the salesman, and the weight of each edge
    connecting the cities is calculated based on the Euclidian distance between the
    nodes using the `hypot` function, which calculates the square root of the sum
    of the squares. Christofides algorithm is used to solve this TSP instance—this
    algorithm provides a 3/2-approximation of TSP. This means that its solutions will
    be within a factor of 1.5 of the optimal solution length.
  prefs: []
  type: TYPE_NORMAL
- en: Listing A.2 Solving TSP using NetworkX
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: ① Create a random geometric graph with 20 nodes.
  prefs: []
  type: TYPE_NORMAL
- en: ② Set (0,0) as the home city/depot.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Create an independent shallow copy of the graph and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Calculate the distances between the nodes as the edge's weight.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Solve TSP using Christofides algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Highlight the closest edges on each node only.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Draw the route.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Print the route.
  prefs: []
  type: TYPE_NORMAL
- en: Figure A.1 shows the solution for this TSP.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPA_F01_Khamis.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.1 Solving TSP using Christofides algorithm implemented in NetworkX.
    The found route is 0, 10, 7, 2, 6, 1, 15, 14, 5, 17, 4, 9, 12, 18, 3, 19, 16,
    8, 11, 13, 0.
  prefs: []
  type: TYPE_NORMAL
- en: NetworkX supports a variety of graph search algorithms and can perform network
    analyses using packages within the geospatial Python ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: A.3.2 OSMnx
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[OSMnx](https://osmnx.readthedocs.io/en/stable/) is a Python library developed
    to ease the process of retrieving and manipulating data from [OpenStreetMap](https://www.openstreetmap.org)
    (OSM). It offers the ability to download the data (filtered) from OSM and returns
    the network as a NetworkX graph data structure. It is a free and open source geographic
    data for the world.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install OSMnx with `conda`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: OSMnx can be used to convert a text descriptor of a place into a NetworkX graph.
    Let’s use Times Square in New York City as an example in the following continuation
    of listing A.2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: ① Name of the place or point of interest
  prefs: []
  type: TYPE_NORMAL
- en: ② NetworkX graph of the named place
  prefs: []
  type: TYPE_NORMAL
- en: ③ Plot the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Figure A.2 shows the graph of Times Square based on driving mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPA_F02_Khamis.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.2 Times Square graph with drivable streets
  prefs: []
  type: TYPE_NORMAL
- en: '`network_type` allows you to select the type of street network based on the
    mobility mode: `all_private`, `all`, `bike`, `drive`, `drive_service`, or `walk`.
    You can highlight all the one-way edges in the Times Square street network using
    these two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Various properties of the graph can be examined, such as the graph type, edge
    (road) types, CRS projection, etc. For example, you can print the graph type using
    `type(graph)` and extract the nodes and edges of the graph as separate structures
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can further drill down to examine each individual node or edge.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also retrieve the street types for the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code line gives the following statistics about the Times
    Square road network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: More statistics can be generated using `osmnx.basic_stats(graph)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'GeoDataFrames can be easily converted to MultiDiGraphs by using `osmnx.graph_from_gdfs`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the same road network shown in figure A.2\. You can also save
    the street network in different formats as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: ① Save the street network as a PNG.
  prefs: []
  type: TYPE_NORMAL
- en: ② Save the street network as an SVG.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Save the graph to disk as an .osm XML file.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Save the street network as a GeoPackage file for GIS
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Save the street network as a GraphML file for OSMnx, NetworkX, or Gephi.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Save the graph as a shapefile.
  prefs: []
  type: TYPE_NORMAL
- en: A.3.3 GeoPandas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[GeoPandas](https://geopandas.org/en/stable/index.html) is an extension to
    Pandas that handles geospatial data by extending the datatypes of Pandas and the
    ability to query and manipulate spatial data. It provides tools for reading, writing,
    and manipulating geospatial data, as well as for visualizing and mapping data
    on a map. You can install GeoPandas using pip or conda as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'GeoPandas can handle different geospatial data formats such as shapefiles (.shp),
    CSV (comma separated values), GeoJSON, ESRI JSON, GeoPackage (.gpkg), GML, GPX
    (GPS exchange format), and KML (Keyhole Markup Language). For example, let’s assume
    we want to read Ontario’s health region data based on a shapefile that can be
    downloaded from the Ontario data catalogue included in the book’s GitHub repo
    (in the appendix B data folder). A shapefile is a popular geospatial data format
    for storing vector data (such as points, lines, and polygons). It is a widely
    used format for storing GIS data, and it’s supported by many GIS software packages,
    including ArcGIS and QGIS. A shapefile is actually a collection of several files
    with different extensions, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*.shp*—The main file, which contains the geospatial data (points, lines, or
    polygons)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.shx*—The index file, which allows for faster access to the data in the .shp
    file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.dbf*—The attribute file, which contains the attribute data (non-geographic
    information) for each feature in the .shp file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.prj*—The projection file, which defines the coordinate system and projection
    information for the data in the .shp file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.sbx*—A spatial index of the features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following continuation of listing A.2 shows how to read this geospatial
    data from [https://data.ontario.ca/dataset/ontario-s-health-region-geographic-data](https://data.ontario.ca/dataset/ontario-s-health-region-geographic-data),
    which is stored in the book’s GitHub repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: ① Define the base URL for the raw files.
  prefs: []
  type: TYPE_NORMAL
- en: ② Files associated with the shapefile.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Temporarily download the files from the specified URL.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Read the shapefile with geopandas.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Cleanup/remove the downloaded files.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Print the first n rows.
  prefs: []
  type: TYPE_NORMAL
- en: The complete version of [listing A.2](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.2_Graph_libraries.ipynb)
    is available in the book’s GitHub repo.
  prefs: []
  type: TYPE_NORMAL
- en: A.3.4 contextily
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[contextily](https://contextily.readthedocs.io/en/latest/) is a Python library
    for adding contextual basemaps to plots created with libraries such as Matplotlib,
    Plotly, and others. For example, contextily can be used to add context when we
    render the Ontario health region data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'contextily supports several different sources for basemaps, including the following
    commonly used sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*OpenStreetMap (OSM)*—This is the default source for contextily. It is a free
    and open source map service that provides a variety of different styles, including
    the default Mapnik style and others such as Humanitarian and Cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Stamen*—This source provides a variety of different map styles, including
    Toner, Terrain, and Watercolor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mapbox*—This source provides a variety of different map styles, including
    Streets, Outdoors, and Satellite. It requires an API key to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MapQuest*—This source provides a variety of different map styles, including
    OSM and Aerial. It requires an API key to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Here*—This source provides a variety of different map styles, including Normal
    Day and Normal Night. It requires an API key to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Google Maps*—This source provides a variety of different map styles, including
    Roadmap, Satellite, and Terrain. It requires an API key to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A.3.5 Folium
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Folium](https://python-visualization.github.io/folium/) is a library for creating
    interactive maps in Python using the Leaflet.js library. It provides tools for
    reading, writing, and manipulating geospatial data, as well as for visualizing
    and mapping data on a map. Folium can be used to create static or dynamic maps,
    as well as to customize the appearance and behavior of the map. The following
    continuation of listing A.2 shows how to use Folium to visualize Ontario Health
    regions on a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: ① Transform geometries to a new coordinate reference system (CRS).
  prefs: []
  type: TYPE_NORMAL
- en: ② Set starting location, initial zoom, and base layer source.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Simplify each region's polygon, as intricate details are unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Render the map.
  prefs: []
  type: TYPE_NORMAL
- en: The “[Listing A.2_Graph_libraries.ipynb](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.2_Graph_libraries.ipynb)”
    notebook available in the book’s GitHub repo provides examples of different ways
    of visualizing geospatial data, such as chloropleth map, cartogram map, bubble
    map, hexagonal binning, heat map, and cluster map.
  prefs: []
  type: TYPE_NORMAL
- en: A.3.6 Other libraries and tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a non-exhaustive list of other useful libraries and tools
    for working on geospatial data, graphs, and networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pyrosm](https://pyrosm.readthedocs.io/en/latest/)—This is another Python library
    for reading OpenStreetMap from Protocolbuffer Binary Format files (*.osm.pbf).
    It can be used to download and read OpenStreetMap data, extract features such
    as roads, buildings, and points of interest, and analyze and visualize the data.
    The main difference between Pyrosm and OSMnx is that OSMnx reads the data using
    an OverPass API, whereas Pyrosm reads the data from local OSM data dumps that
    are downloaded from the Protocolbuffer Binary Format file (*.osm.pbf) data providers
    (Geofabrik, BBBike) and converts it into GeoPandas GeoDataFrames. This makes it
    possible to parse OSM data faster and makes it more feasible to extract data covering
    large regions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pandana](https://udst.github.io/pandana/)—This is a Python library for network
    analysis that uses contraction hierarchies to calculate super-fast travel accessibility
    metrics and shortest paths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GeoPy](https://geopy.readthedocs.io/en/stable/)—This is a Python client for
    several popular geocoding web services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Graphviz](https://graphviz.org/)—This is a library for creating visualizations
    of graphs and tree structures in Python. It provides tools for defining the structure
    of a graph, as well as for rendering the graph in various formats, such as PNG,
    PDF, and SVG. Graphviz is a useful tool for visualizing algorithms that operate
    on graphs, such as graph search algorithms and graph traversal algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Gephi](https://gephi.org/)—This is a tool for visualizing and analyzing graphs
    and networks. It provides a graphical user interface for defining and customizing
    the appearance of graphs and diagrams, as well as for visualizing algorithms and
    data structures. Gephi can be used to visualize algorithms that operate on graph
    data, such as graph search algorithms and shortest path algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cytoscape](https://cytoscape.org/)—This is an open-source software platform
    for visualizing complex networks and integrating these with any type of attribute
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ipyleaflet](https://github.com/jupyter-widgets/ipyleaflet)—This is an interactive
    widgets library that is based on ipywidgets. ipywidgets, also known as jupyter-widgets
    or simply widgets, are interactive HTML widgets for Jupyter notebooks and the
    IPython kernel. Ipyleaflet brings mapping capabilities to the notebook and JupyterLab.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[hvPlot](https://hvplot.holoviz.org/)— This is a Python library that provides
    a high-level plotting API built on top of the HoloViews library. It can be used
    with GeoPandas to create interactive visualizations of geospatial data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[mplleaflet](https://github.com/jwass/mplleaflet)—This is another `leaflet`-based
    library, but it plays nicely with `matplotlib`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cartopy](https://scitools.org.uk/cartopy/docs/latest/)—Cartopy is a library
    for creating maps and geospatial plots in Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[geoplotlib](https://github.com/andrea-cuttone/geoplotlib)—geoplotlib is a
    library for creating maps and visualizations in Python. It provides tools for
    styling and customizing map elements, as well as for overlaying data on top of
    maps. geoplotlib can be used to create static or interactive maps and supports
    a variety of map projections and coordinate systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Shapely](https://shapely.readthedocs.io/en/stable/)—This is an open source
    Python library for performing geometric operations on objects in the Cartesian
    plane.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[deck.gl](https://deck.gl/)—This is an open source JavaScript library for WebGL-powered
    large dataset visualization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[kepler.gl](https://kepler.gl/)—This is a powerful open source geospatial analysis
    tool for large-scale data sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A.4 Metaheuristics optimization libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several libraries in Python that provide implementations of different
    metaheuristic optimization algorithms. The following subsections cover some commonly
    used libraries.
  prefs: []
  type: TYPE_NORMAL
- en: A.4.1 PySwarms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PySwarms](https://pyswarms.readthedocs.io/en/latest/index.html) is a library
    for implementing swarm intelligence algorithms in Python. It provides tools for
    defining, training, and evaluating swarm intelligence models, as well as for visualizing
    the optimization process. PySwarms supports a variety of swarm intelligence algorithms,
    including particle swarm optimization (PSO) and ant colony optimization (ACO).
    The next listing shows the steps for solving a function optimization problem using
    PSO implemented in PySwarms.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing A.3 Solving function optimization using PSO implemented in PySwarms
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: ① Import the Image class to enable the display of images within the notebook
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: ② Set up PSO as an optimizer with 50 particles and predefined parameters.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Solve the function optimization problem using PSO.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set up the sphere unimodal function to be optimized using PSO, and set up
    the number of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Plot the cost.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Plot the sphere function's mesh for better plots.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Adjust the figure limits.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Generate animation for the solution history on a contour.
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Render the animation.
  prefs: []
  type: TYPE_NORMAL
- en: A.4.2 Scikit-opt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Scikit-opt](https://scikit-opt.github.io/) is an optimization library that
    provides a simple and flexible interface for defining and running optimization
    problems with various metaheuristics, such as genetic algorithms, particle swarm
    optimization, simulated annealing, ant colony algorithm, immune algorithm, and
    artificial fish swarm algorithm. Scikit-opt can be used to solve both continuous
    and discrete problems. The following continuation of listing A.3 shows the steps
    for solving a function optimization problem using scikit-opt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: ① Define a multimodal function.
  prefs: []
  type: TYPE_NORMAL
- en: ② Solve the problem using simulated annealing (SA).
  prefs: []
  type: TYPE_NORMAL
- en: ③ Print the result.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider the TSP instance shown in figure A.3\. In this TSP, a travelling
    salesman must visit 20 major US cities starting from a specific city.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPA_F03_Khamis.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.3 Travelling salesman problem (TSP) for 20 major US cities
  prefs: []
  type: TYPE_NORMAL
- en: 'The following continuation of listing A.3 shows the steps for solving this
    problem using scikit-opt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: ① Define the TSP problem.
  prefs: []
  type: TYPE_NORMAL
- en: ② Calculate the total distance.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Solve the problem using PSO.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Print the solution.
  prefs: []
  type: TYPE_NORMAL
- en: A.4.3 NetworkX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NetworkX, introduced in the previous section, provides approximations of graph
    properties and heuristic methods for optimization. An example of these heuristics
    algorithms is simulated annealing. The following continuation of listing A.3 shows
    the steps for solving TSP using simulated annealing implemented in NetworkX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: ① Create a graph.
  prefs: []
  type: TYPE_NORMAL
- en: ② Add weighted edges to the graph, and remove selfloop edges.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Define pos as a dictionary of positions using the Fruchterman-Reingold force-directed
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Solve TSP using simulated annealing.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Print the route and the cost.
  prefs: []
  type: TYPE_NORMAL
- en: A.4.4 Distributed evolutionary algorithms in Python (DEAP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[DEAP](https://github.com/deap/deap) is a library for implementing genetic
    algorithms in Python. It provides tools for defining, training, and evaluating
    genetic algorithm models, as well as for visualizing the optimization process.
    DEAP supports a variety of genetic algorithm techniques, including selection,
    crossover, and mutation. The following continuation of listing A.3 shows the steps
    for solving TSP using simulated annealing implemented in DEAP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: ① Create a fitness function that minimizes the total distance
  prefs: []
  type: TYPE_NORMAL
- en: ② Create the genetic operator functions.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Calculate the route length.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Set the evaluation function.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Set an ordered crossover.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Set the shuffle mutation with probability 0.05.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Select the best individual among three randomly chosen individuals.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Set the population size.
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Set the hall of fame to select the best individual that ever lived in the
    population during the evolution.
  prefs: []
  type: TYPE_NORMAL
- en: ⑩ Solve the problem using a simple evolutionary algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: ⑪ Print the solution.
  prefs: []
  type: TYPE_NORMAL
- en: DEAP includes several built-in algorithms such as genetic algorithm (GA), evolutionary
    strategy (ES), genetic programming (GA), estimation of distribution algorithms
    (EDA), and particle swarm optimization (PSO).
  prefs: []
  type: TYPE_NORMAL
- en: A.4.5 OR-Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As previously mentioned, [OR-Tools](https://developers.google.com/optimization)
    (Operations Research Tools) is an open source library for optimization and constraint
    programming developed by Google. The following continuation of listing A.3 shows
    the steps for solving TSP using tabu search implemented in OR-Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: ① Convert a float array into an integer array for OR_Tools.
  prefs: []
  type: TYPE_NORMAL
- en: ② Define the problem data.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Define a constraint programming solver.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Get the distance between the cities.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Set up tabu search as a local search metaheuristic.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Print the solution.
  prefs: []
  type: TYPE_NORMAL
- en: The OR-Tools library also implements some metaheuristics but not as many as
    dedicated metaheuristics frameworks like DEAP. Examples include simulated annealing
    (SA), tabu search (TS), and guided local search (GLS).
  prefs: []
  type: TYPE_NORMAL
- en: A.4.6 Other libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following non-exhaustive list identifies other useful libraries and tools
    for solving optimization problems using metaheuristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[simanneal](https://github.com/perrygeo/simanneal)—This is an open source Python
    module for simulated annealing. Listing A.3 shows the steps for solving TSP using
    simulated annealing implemented in simanneal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Non-dominated Sorting Genetic Algorithm (NSGA-II)](https://pymoo.org/algorithms/moo/nsga2.html)—This
    is a solid multi-objective algorithm, widely used in many real-world applications.
    The algorithm is designed to find a set of solutions, called the Pareto front,
    which represents the trade-off between multiple conflicting objectives. NSGA-II
    implementations are available in pymoo and DEAP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python genetic algorithm (PyGAD)](https://pygad.readthedocs.io/en/latest/)—This
    is a library for implementing genetic algorithms and differential evolution in
    Python. It provides tools for defining, training, and evaluating genetic algorithm
    models, as well as for visualizing the optimization process. PyGAD supports a
    variety of genetic algorithm techniques, including selection, crossover, and mutation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Library for Evolutionary Algorithms in Python (LEAP)](https://leap-gmu.readthedocs.io/en/latest/index.html)—This
    is a general-purpose evolutionary algorithm (EA) package that is simple and easy
    to use. It provides a high-level abstraction for defining and running EAs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pyevolve](https://pyevolve.sourceforge.net/index.html)—This is a Python library
    that provides a simple and flexible API for implementing and running genetic algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Genetic algorithms made easy (EasyGA)](https://github.com/danielwilczak101/EasyGA)—This
    is another Python library for genetic algorithms with several built-in genetic
    operators, such as selection, crossover, and mutation. EasyGA and Pyevolve are
    simple libraries with less functionality and fewer predefined problems than other
    libraries such as DEAP and Pymoo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MEAPLY](https://mealpy.readthedocs.io/en/latest/index.html)—This is a Python
    library for population metaheuristic algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[swarmlib](https://pypi.org/project/swarmlib/)—This library implements several
    swarm optimization algorithms and visualizes their (intermediate) solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hive](https://rwuilbercq.github.io/Hive/)—This is a swarm-based optimization
    algorithm based on the intelligent foraging behavior of honeybees. Hive implements
    the artificial bee colony (ABC) algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pants](https://aco-pants.readthedocs.io/en/latest/)—This is a Python3 implementation
    of the ant colony optimization (ACO) metaheuristics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[mlrose](https://mlrose.readthedocs.io/en/stable/index.html)—This library provides
    implementations of hill climb, random hill climb, simulated annealing, and genetic
    algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixed integer distributed ant colony optimization ([MIDACO](http://www.midaco-solver.com/index.php/about))—This
    is a numerical high-performance library based on ACO for solving single- and multi-objective
    optimization problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[cuOpt](https://www.nvidia.com/en-us/ai-data-science/products/cuopt/): This
    is a Python SDK and cloud service provided by NVIDIA that provides access to GPU-accelerated
    logistics solvers relying on metaheuristics to calculate complex vehicle routing
    problems with a wide range of constraints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “[Listing A.3_Metaheuristics_libraries.ipynb](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.3_Metaheuristics_libraries.ipynb),”
    included in the book’s GitHub repo, shows how to use some of these metaheuristics
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: A.5 Machine learning libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Machine learning can be used to solve discrete optimization problems where an
    ML model is trained to output solutions directly from the input, usually represented
    as a graph. To train the model, the problem graph needs to be turned first into
    a feature vector using graph embedding/representation learning methods. Several
    Python libraries can be used for graph embedding and for solving optimization
    problems. The following subsections shed some light on the commonly used libraries.
  prefs: []
  type: TYPE_NORMAL
- en: A.5.1 node2vec
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[node2vec](https://snap.stanford.edu/node2vec/) is an algorithmic framework
    for learning low-dimensional representations of nodes in a graph. Given any graph,
    it can learn continuous feature representations for the nodes, which can then
    be used for various downstream ML tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install node2vec, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can install node2vec by cloning the repository from GitHub
    and running the setup.py file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The following code illustrates how to use node2vec to learn low-dimensional
    representations of nodes in a graph based on Zachary’s karate club dataset. This
    is a graph-based dataset commonly used in network analysis and graph-based machine
    learning algorithms. It represents a social network that contains information
    about the relationships between 34 individuals in a karate club. It was created
    and first described by Wayne W. Zachary in his paper “An Information Flow Model
    for Conflict and Fission in Small Groups” in 1977, and it has since become a popular
    benchmark dataset for evaluating graph-based machine learning algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Listing A.4 A node2vec example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: ① Create a sample graph
  prefs: []
  type: TYPE_NORMAL
- en: ② Create an instance of the Node2Vec class.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Learn the representations.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Get the representations of all nodes.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Get the representations of a specific node.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Print the representations of a specific node.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can visualize the generated low-dimensional representations using a dimensionality
    reduction technique such as t-SNE to project the representations onto a 2D or
    3D space, and then use a visualization library such as Matplotlib to plot the
    nodes in this space. t-distributed stochastic neighbor embedding (t-SNE) is a
    statistical method for visualizing high-dimensional data by giving each data point
    a location in a 2D or 3D map. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: ① Import the required libraries.
  prefs: []
  type: TYPE_NORMAL
- en: ② Perform t-SNE dimensionality reduction.
  prefs: []
  type: TYPE_NORMAL
- en: ③ Plot the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Running this code gives the visualization in figure A.4.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPA_F04_Khamis.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.4 t-SNE-based visualization for the low-dimensional representations
    generated by node2vec
  prefs: []
  type: TYPE_NORMAL
- en: A.5.2 DeepWalk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DeepWalk is a random walk-based method for graph embedding based on representation
    learning. For this example, we’ll use a DeepWalk module provided by the [Karate
    Club](https://karateclub.readthedocs.io/en/latest/) library. This library is an
    unsupervised machine learning extension for NetworkX. To use DeepWalk, you can
    install Karate Club as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following continuation of listing A.4 illustrates how to use DeepWalk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: ① Import DeepWalk. node2vec is also available.
  prefs: []
  type: TYPE_NORMAL
- en: ② Import principal component analysis (PCA).
  prefs: []
  type: TYPE_NORMAL
- en: ③ Create the Karate Club graph.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Define the DeepWalk mode, and fit the graph.
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Graph embedding.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Retrieve the club membership attribute of each node.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Define the DeepWalk mode, and fit the graph.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Visualize the embedding.
  prefs: []
  type: TYPE_NORMAL
- en: A.5.3 PyG
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PyG](https://www.pyg.org/) (PyTorch Geometric) is a library for implementing
    graph neural networks in Python using the PyTorch deep learning framework. It
    provides tools for defining, training, and evaluating graph neural network (GNN)
    models, as well as for visualizing the optimization process. PyG supports a variety
    of GNN architectures, including graph convolutional network (GCN) and graph attention
    networks (GATs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install PyG as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following continuation of listing A.4 shows how you can use PyG to generate
    Karate Club graph embedding using GCN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: ① Use the Karate Club dataset.
  prefs: []
  type: TYPE_NORMAL
- en: ② Graph Convolutional Network class
  prefs: []
  type: TYPE_NORMAL
- en: ③ Apply a final (linear) classifier.
  prefs: []
  type: TYPE_NORMAL
- en: ④ Final GNN embedding space
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Define the model.
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Define the loss criterion.
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Define an optimizer and clear gradient.
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Perform a single forward pass.
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Compute the loss solely based on the training nodes.
  prefs: []
  type: TYPE_NORMAL
- en: ⑩ Derive the gradients.
  prefs: []
  type: TYPE_NORMAL
- en: ⑪ Update the parameters based on the gradients.
  prefs: []
  type: TYPE_NORMAL
- en: ⑫ Convert 'h' from tenser format to the numpy format for visualizing.
  prefs: []
  type: TYPE_NORMAL
- en: ⑬ Visualize the embedding.
  prefs: []
  type: TYPE_NORMAL
- en: PyG is a well-supported library that provides several features, such as common
    benchmark datasets (e.g., KarateClub, CoraFull, Amazon, Reddit, Actor), data handling
    of graphs, mini-batches, data transforms, and learning methods on graphs (e.g.,
    node2vec, MLP, GCN, GAT, GraphSAGE, GraphUNet, DeepGCNLayer, GroupAddRev, and
    MetaLayer).
  prefs: []
  type: TYPE_NORMAL
- en: A.5.4 OpenAI Gym
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[OpenAI Gym](https://github.com/openai/gym) is a toolkit for developing and
    comparing reinforcement learning algorithms. It gives you access to variety of
    environments, such as'
  prefs: []
  type: TYPE_NORMAL
- en: '*Classic control*—A variety of classic control tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Box2d*—A 2D physics engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MuJoCo*—A physics engine that can do detailed, efficient simulations with
    contacts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Algorithmic*—A variety of algorithmic tasks, such as learning to copy a sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Atari*—A variety of Atari video games'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*gym-maze*—A simple 2D maze environment where an agent finds its way from the
    start position to the goal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Gymnasium](https://gymnasium.farama.org/) is a maintained fork of OpenAI’s
    Gym library. The following continuation of listing A.4 illustrates how to use
    OpenAI Gym:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: ① Install all included environments.
  prefs: []
  type: TYPE_NORMAL
- en: ② Create an environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this simple example, `MountainCar-v0` has discrete actions. You can also
    use `MountainCarCoutinous``-V0`, which has continuous actions corresponding to
    the force with which the car is pushed. The complete code listing is available
    in the book’s GitHub repo, in “[Listing A.4_ML_libraries.ipynb](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.4_ML_libraries.ipynb)”.
  prefs: []
  type: TYPE_NORMAL
- en: A.5.5 Flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Flow](https://flow-project.github.io/) is a deep reinforcement learning framework
    for mixed autonomy traffic. It allows you to run deep RL-based control experiments
    for traffic microsimulation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install Flow as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Flow within the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Flow enables studying complex, large-scale, and realistic multirobot control
    scenarios. It can be used to develop controllers that optimize the system-level
    velocity or other objectives in the presence of different types of vehicles, model
    noise, and road networks such as single-lane circular tracks, multi-lane circular
    tracks, figure-eight networks, loops with merge networks, and intersections.
  prefs: []
  type: TYPE_NORMAL
- en: A.5.6 Other libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a non-exhaustive list of other useful ML libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Deep Graph Library (DGL)](https://www.dgl.ai/)—A library for implementing
    graph neural networks in Python. It provides tools for defining, training, and
    evaluating GNN models, as well as for visualizing the optimization process. DGL
    supports a variety of GNN architectures, including GCN and GAT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stanford Network Analysis Platform (SNAP)](https://github.com/snap-stanford/snap)—A
    general-purpose, high-performance system for the analysis and manipulation of
    large, complex networks. SNAP includes a number of algorithms for network analysis,
    such as centrality measures, community detection, and graph generation. It is
    particularly well-suited for large-scale network analysis and is used in a variety
    of fields, including computer science, physics, biology, and social science.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Spektral](https://graphneural.network/)—An open-source Python library for
    graph neural networks (GNNs) built on top of TensorFlow and Keras. It is designed
    to make it easy to implement GNNs in research and production. It provides a high-level,
    user-friendly API for building GNNs, as well as a number of prebuilt layers and
    models for common tasks in graph deep learning. The library also includes utilities
    for loading and preprocessing graph data and for visualizing and evaluating the
    performance of GNNs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Jraph](https://github.com/deepmind/jraph) (pronounced “giraffe”)—A lightweight
    library for working with graph neural networks that also provides lightweight
    data structure for working with graphs. You can easily work with this library
    to construct and visualize your graph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GraphNets](https://github.com/deepmind/graph_nets)—A library for implementing
    GNNs in Python. It provides tools for defining, training, and evaluating GNN models,
    as well as for visualizing the optimization process. GraphNets supports a variety
    of GNN architectures, including GCN and GAT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stable-Baselines3 (SB3)](https://stable-baselines3.readthedocs.io/en/master/)—A
    set of reliable implementations of reinforcement learning algorithms in PyTorch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vowpal Wabbit (VW)](https://vowpalwabbit.org/index.html)—An open source ML
    library specifically designed for large-scale online learning. Developed originally
    at Yahoo Research, and currently at Microsoft Research, it is widely used for
    solving reductions and contextual bandits problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ray RLlib](https://docs.ray.io/en/latest/rllib/index.html)—An open source
    library for RL, offering support for production-level, highly distributed multi-agent
    RL workloads while maintaining unified and simple APIs for a large variety of
    industry applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[TF-Agents](https://www.tensorflow.org/agents)—A library for developing RL
    algorithms in TensorFlow, which includes a collection of environments, algorithms,
    and tools for training RL agents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Keras-RL](https://github.com/keras-rl/keras-rl)—A deep reinforcement learning
    library built on top of Keras. It provides an easy-to-use interface for developing
    and testing RL algorithms. Keras-RL supports a variety of RL algorithms such as
    deep Q-networks (DQN) and actor-critic methods. There are also built-in environments
    for testing RL algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[pyqlearning](https://github.com/accel-brain/accel-brain-code/tree/master/Reinforcement-Learning)—A
    Python library to implement reinforcement learning and deep reinforcement learning,
    especially for Q-learning, deep Q-network, and multi-agent deep Q-network, which
    can be optimized by annealing models such as simulated annealing, adaptive simulated
    annealing, and quantum Monte Carlo method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python Optimal Transport (POT)](https://pythonot.github.io/)—An open source
    Python library providing several solvers for optimization problems related to
    optimal transport for signals, image processing, and machine learning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “[Listing A.4_ML_libraries.ipynb](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.4_ML_libraries.ipynb)”
    notebook available in the book’s GitHub repo provides examples of how to install
    and use some of these libraries.
  prefs: []
  type: TYPE_NORMAL
- en: A.6 Projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'My course “ECE1724H: Bio-inspired Algorithms for Smart Mobility,” at the University
    of Toronto, features a collection of exemplary projects available in the “AI for
    Smart Mobility (AI4SM)” publication hub ([https://medium.com/ai4sm](https://medium.com/ai4sm))
    with Python code implementations. These projects encompass a broad spectrum of
    optimization algorithms covered in this book and their practical applications
    in the smart mobility domain. Among the topics tackled are'
  prefs: []
  type: TYPE_NORMAL
- en: Employing large language models for reinforcement learning in intelligent driving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forecasting traffic flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategizing the placement of EV charging stations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing food delivery services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predicting estimated times of arrival
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the deployment of traffic sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing cycling routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reorganizing urban fire districts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pricing strategies for ride-sharing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refining school bus routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability predictions for bikes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Districting for efficient waste collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing bus stop layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing dynamic pricing for public transportation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing student transportation and boarding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating hotel recommendations with route planning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining ideal locations for public parcel lockers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predictive responses and accessibility scoring for healthcare facilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
