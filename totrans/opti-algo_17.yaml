- en: Appendix A. Search and optimization libraries in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. Python 中的搜索和优化库
- en: This appendix covers setting up the Python environment, along with essential
    libraries for mathematical programming, graph visualization, metaheuristic optimization,
    and machine learning.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录涵盖了设置 Python 环境，以及数学编程、图形可视化、元启发式优化和机器学习的基本库。
- en: A.1 Setting up the Python environment
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 设置 Python 环境
- en: 'This book assumes that you already have Python 3.6 or a newer version installed
    on your system. For installation instructions specific to your operating system,
    see this Beginner’s Guide: [https://wiki.python.org/moin/BeginnersGuide/](https://wiki.python.org/moin/BeginnersGuide/).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设您已经在系统上安装了 Python 3.6 或更高版本。有关您操作系统的特定安装说明，请参阅此入门指南：[https://wiki.python.org/moin/BeginnersGuide/](https://wiki.python.org/moin/BeginnersGuide/)。
- en: 'For Windows, you can follow these steps to install Python:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 系统，您可以按照以下步骤安装 Python：
- en: 'Go to the official website: [www.python.org/downloads/](https://www.python.org/downloads/).'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往官方网站：[www.python.org/downloads/](https://www.python.org/downloads/)。
- en: Select the version of Python to install.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要安装的 Python 版本。
- en: Download the Python executable installer.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 Python 可执行安装程序。
- en: Run the executable installer. Make sure you check the Install Launcher for all
    users and Add Python 3.8 to PATH checkboxes.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行可执行安装程序。请确保选中“为所有用户安装启动器”和“将 Python 3.8 添加到 PATH”复选框。
- en: Verify that Python was successfully installed by typing `python –V` in a command
    prompt.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在命令提示符中输入 `python –V` 来验证 Python 是否成功安装。
- en: Verify that pip was installed by typing `pip -V` in a command prompt.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在命令提示符中输入 `pip -V` 来验证 pip 是否已安装。
- en: Install `virtualenv` by typing `pip install` `virtualenv` in a command prompt.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中输入 `pip install virtualenv` 来安装 `virtualenv`。
- en: 'If you are a Linux user, execute the following commands in the terminal:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是 Linux 用户，请在终端中执行以下命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Install venv and create a Python virtual environment:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 venv 并创建 Python 虚拟环境：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Make sure that you replace `python3.8` with the version of Python you are using.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 `python3.8` 替换为你正在使用的 Python 版本。
- en: 'You can now access your virtual environment using the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用以下命令访问您的虚拟环境：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the case of macOS, Python is already preinstalled, but if you need to upgrade
    or install a specific version, you can use the macOS terminal as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 的情况下，Python 已经预安装，但如果您需要升级或安装特定版本，可以使用以下 macOS 终端操作：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`venv` is included with python 3.8+. You can run the following command to create
    a virtual environment:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`venv` 包含在 Python 3.8 及更高版本中。您可以使用以下命令创建虚拟环境：'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can now access your virtual environment using the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用以下命令访问您的虚拟环境：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A better option is to install a Python distribution as explained in the next
    subsection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的选择是按照下一小节所述安装 Python 发行版。
- en: A.1.1 Using a Python distribution
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.1 使用 Python 发行版
- en: 'Python distributions, such as Anaconda or Miniconda, come with a package manager
    called `conda` that allows you to install a wide range of Python packages and
    manage different Python environments. Install `conda` for your OS using the guide
    found here: [https://conda.io/projects/conda/en/latest/user-guide/install/index.html](https://conda.io/projects/conda/en/latest/user-guide/install/index.html).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python 发行版，如 Anaconda 或 Miniconda，包含一个名为 `conda` 的包管理器，允许您安装广泛的 Python 包并管理不同的
    Python 环境。使用以下指南为您操作系统安装 `conda`：[https://conda.io/projects/conda/en/latest/user-guide/install/index.html](https://conda.io/projects/conda/en/latest/user-guide/install/index.html)。
- en: 'Conda environments are used to manage multiple installations of different versions
    of Python packages and their dependencies. You can create a `conda` environment
    with this command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Conda 环境用于管理不同版本的 Python 包及其依赖项的多个安装。您可以使用以下命令创建一个 `conda` 环境：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Access the newly created environment like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式访问新创建的环境：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This command allows you to switch or move between environments.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令允许您在环境之间切换或移动。
- en: A.1.2 Installing Jupyter Notebook and JupyterLab
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.2 安装 Jupyter Notebook 和 JupyterLab
- en: Jupyter is a multi-language, open-source web-based platform for interactive
    programming ([https://jupyter.org/](https://jupyter.org/)). The name “Jupyter”
    is a loose acronym meaning Julia, Python, and R. All of the code in this book
    is stored in Jupyter notebooks (.ipynb files), which can be opened and edited
    using JupyterLab or Jupyter Notebook. Jupyter Notebook feels more standalone,
    but JupyterLab feels more like an IDE.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter 是一个多语言、开源的基于网络的交互式编程平台 ([https://jupyter.org/](https://jupyter.org/))。名称“Jupyter”是一个松散的首字母缩略词，代表
    Julia、Python 和 R。本书中的所有代码都存储在 Jupyter 笔记本 (.ipynb 文件) 中，可以使用 JupyterLab 或 Jupyter
    Notebook 打开和编辑。Jupyter Notebook 感觉更独立，而 JupyterLab 则更像是一个集成开发环境 (IDE)。
- en: 'You can install JupyterLab using `pip` as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `pip` 按照以下方式安装 JupyterLab：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or using `conda` as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或者按照以下方式使用 `conda`：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can install the Python ipywidgets package to automatically configure classic
    Jupyter Notebook and JupyterLab 3.0 to display ipywidgets using `pip` or `conda`
    as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `pip` 按照以下方式安装 Python ipywidgets 软件包，以自动配置经典 Jupyter Notebook 和 JupyterLab
    3.0 以显示 ipywidgets：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you have an old version of Jupyter Notebook installed, you may need to manually
    enable the ipywidgets notebook extension with these commands:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您安装了旧版本的 Jupyter Notebook，您可能需要手动使用以下命令启用 ipywidgets 笔记本扩展：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Google Colaboratory (Colab) can also be used. This cloud-based tool allows
    you to write, execute, and share Python code through the browser. It also provides
    free access to GPU and TPU for increased computational power. You can access Colab
    here: [https://colab.research.google.com/](https://colab.research.google.com/).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Google Colaboratory (Colab) 也可以使用。这个基于云的工具允许您通过浏览器编写、执行和分享 Python 代码。它还提供免费访问
    GPU 和 TPU 以增强计算能力。您可以通过以下链接访问 Colab：[https://colab.research.google.com/](https://colab.research.google.com/).
- en: A.1.3 Cloning the book’s repository
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.3 克隆书籍的仓库
- en: 'You can clone this book’s code repository as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下步骤克隆此书籍的代码仓库：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Many of the operations in this book are long and burdensome to code from scratch.
    Often, they’re highly standardized and can benefit from having a helper function
    take care of the various intricacies. `optalgotools` is a Python package developed
    for this purpose.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多操作都很长且难以从头编写代码。通常，它们高度标准化，并可以从具有辅助函数处理各种复杂性的情况下受益。`optalgotools` 是为此目的开发的
    Python 软件包。
- en: 'You can use these supporting tools locally without installing this package.
    To do so, you will need to download `optalgotools` in a local folder and add this
    folder to the system path. If you’re using Jupyter notebook or Jupyter lab, you
    can do so as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在不安装此软件包的情况下本地使用这些支持工具。为此，您需要将 `optalgotools` 下载到本地文件夹，并将此文件夹添加到系统路径中。如果您使用
    Jupyter notebook 或 Jupyter lab，可以按照以下步骤操作：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you’re using Colab, you can mount your Google Drive with these commands:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Colab，可以使用以下命令将您的 Google Drive 挂载：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then copy the `optalgotools` folder to your Google Drive.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 `optalgotools` 文件夹复制到您的 Google Drive。
- en: 'This package is also available on the Python Package Index (PyPI) repository
    here: [https://pypi.org/project/optalgotools/](https://pypi.org/project/optalgotools/).
    You can install it as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此软件包也可在 Python 包索引 (PyPI) 仓库中找到：[https://pypi.org/project/optalgotools/](https://pypi.org/project/optalgotools/).
    您可以按照以下步骤进行安装：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can then use the `import` command to use these tools. Here is an example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用 `import` 命令来使用这些工具。以下是一个示例：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first line imports the `TSP` instance from the `problems` module, and the
    second line imports a simulated annealing solver from the `algorithms` module.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行从 `problems` 模块导入 `TSP` 实例，第二行从 `algorithms` 模块导入模拟退火求解器。
- en: A.2 Mathematical programming solvers
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 数学规划求解器
- en: '*Mathematical programming*, also known as *mathematical optimization*, is the
    process of finding the best solution to a problem that can be represented in mathematical
    terms. It involves formulating a mathematical model of a problem, determining
    the parameters of the model, and using mathematical and computational techniques
    to find a solution that maximizes or minimizes a particular objective function
    or set of objective functions subject to a set of constraints. Linear programming
    (LP), mixed-integer linear programming (MILP), and nonlinear programming (NLP)
    are examples of mathematical optimization problems. Several Python libraries can
    be used for solving mathematical optimization problems.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**数学规划**，也称为**数学优化**，是寻找可以用数学术语表示的问题的最佳解决方案的过程。它涉及制定问题的数学模型，确定模型的参数，并使用数学和计算技术找到解决方案，该解决方案在满足一系列约束条件下最大化或最小化特定的目标函数或一组目标函数。线性规划（LP）、混合整数线性规划（MILP）和非线性规划（NLP）是数学优化问题的例子。可以使用几个Python库来解决数学优化问题。'
- en: Let’s consider the following production planning example from Guerte el al.’s
    *Linear Programming* [1]. A small woodworking shop produces two sizes of boxwood
    chess sets. Crafting the smaller set involves 3 hours of lathe machining, while
    the larger set requires 2 hours. With four skilled operators each working a 40-hour
    week, the shop has a total of 160 lathe-hours available weekly. The smaller chess
    set consumes 1 kg of boxwood, while the larger set requires 3 kg. However, due
    to scarcity, only 200 kg of boxwood can be obtained per week. Upon sale, each
    large chess set generates a profit of $12, while each small set yields $5 in profit.
    The objective is to determine the optimal weekly production quantities for each
    set to maximize profit.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑Guerte等人《线性规划》[1]中的以下生产计划示例。一个小型木工车间生产两种尺寸的黄杨木棋套装。制作较小的套装需要3小时的车削加工，而较大的套装则需要2小时。有四个熟练的操作员，每人每周工作40小时，车间每周有总共160小时的车削时间可用。较小的棋套装消耗1公斤黄杨木，而较大的套装则需要3公斤。然而，由于稀缺，每周只能获得200公斤黄杨木。出售时，每个大型棋套装产生12美元的利润，而每个小型套装产生5美元的利润。目标是确定每个套装的最佳每周生产数量以最大化利润。
- en: 'Let’s assume that *x*[1] and *x*[2] are decision variables that represent the
    number of small and large chess sets respectively to make. The total profit is
    the sum of the individual profits from making and selling the *x*[1] small sets
    and the *x*[2] large sets: profit = 5*x*[1] + 12*x*[2]. However, this profit is
    subject to the following constraints:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *x*[1] 和 *x*[2] 是决策变量，分别代表要制作的中小型棋套装的数量。总利润是制作和销售 *x*[1] 套小型棋套装和 *x*[2] 套大型棋套装的个体利润之和：利润
    = 5*x*[1] + 12*x*[2]。然而，这种利润受到以下约束：
- en: The total number of hours of machine time we will use is 3*x*[1] + 2*x*[2].
    This time shouldn’t exceed the maximum of 160 hours of machine time available
    per week. This means that 3*x*[1] + 2*x*[2] ≤ 160 (lathe-hours).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用机器的总小时数为 3*x*[1] + 2*x*[2]。这个时间不应超过每周可用的最大160小时机器时间。这意味着 3*x*[1] + 2*x*[2]
    ≤ 160 (车削小时)。
- en: Only 200 kg of boxwood is available each week. Since small sets use 1 kg for
    every set made, against 3 kg needed to make a large set, *x*[1] + 3*x*[2] ≤ 200
    (kg of boxwood).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周只有200公斤的黄杨木可用。由于小套装每套需要1公斤，而大套装则需要3公斤，因此 *x*[1] + 3*x*[2] ≤ 200 (公斤黄杨木)。
- en: 'The joinery cannot produce a negative number of chess sets, so we have two
    further non-negativity constraints: *x*[1] and *x*[2] >= 0.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 木工车间不能生产负数的棋套装，因此我们有两个额外的非负约束：*x*[1] 和 *x*[2] >= 0。
- en: This linear programming problem can be summarized as follows. Find *x*[1] and
    *x*[2] that maximize 5*x*[1] + 12*x*[2], subject to
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个线性规划问题可以总结如下。找到 *x*[1] 和 *x*[2]，使得 5*x*[1] + 12*x*[2] 最大化，同时满足
- en: 'Machining time constraint: 3*x*[1] + 2*x*[2] ≤ 160'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加工时间约束：3*x*[1] + 2*x*[2] ≤ 160
- en: 'Weight constraint: *x*[1] + 3*x*[2] ≤ 200'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重量约束：*x*[1] + 3*x*[2] ≤ 200
- en: 'Non-negativity constraints: *x*[1] and *x*[2] ≥ 0'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非负约束：*x*[1] 和 *x*[2] >= 0
- en: Let’s see how we can solve this linear programming problem using different solvers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用不同的求解器来解决这个线性规划问题。
- en: A.2.1 SciPy
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.1 SciPy
- en: '[SciPy](https://scipy.org/) is an open source scientific computing Python library
    that provides tools for optimization, linear algebra, and statistics. SciPy optimize
    is a submodule of the SciPy library, which includes solvers for nonlinear problems
    (with support for both local and global optimization algorithms), linear programing,
    constrained and nonlinear least-squares, root finding, and curve fitting.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[SciPy](https://scipy.org/) 是一个开源的科学计算Python库，提供了优化、线性代数和统计的工具。SciPy optimize是SciPy库的一个子模块，包括非线性问题的求解器（支持局部和全局优化算法）、线性规划、约束和非线性最小二乘、根查找和曲线拟合。'
- en: 'To use SciPy, you will need to install it and its dependencies. You can install
    SciPy using the pip package manager:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用SciPy，您需要安装它及其依赖项。您可以使用pip包管理器安装SciPy：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Alternatively, you can use a Python distribution, such as Anaconda or Miniconda,
    that comes with SciPy and other scientific libraries pre-installed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用预装了SciPy和其他科学库的Python发行版，如Anaconda或Miniconda。
- en: Listing A.1 shows the steps to solve the car manufacturing problem using SciPy.
    The code defines the coefficient vector `c` and the left-hand side (`lhs`) and
    right-hand side (`rhs`) of the constraint equations. The objective function represents
    the profit to be maximized. Since many optimization algorithms in SciPy are designed
    for minimization, the problem of profit maximization is typically converted into
    a minimization problem by minimizing the negative of the profit function. Moreover,
    constraints using the greater-than-or-equal-to sign cannot be defined directly.
    Less-than-or-equal-to must be used instead.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.1展示了使用SciPy解决汽车制造问题的步骤。代码定义了系数向量`c`和约束方程的左侧（`lhs`）和右侧（`rhs`）。目标函数代表要最大化的利润。由于SciPy中的许多优化算法是为最小化设计的，因此利润最大化问题通常通过最小化利润函数的负值来转换为最小化问题。此外，使用大于或等于符号的约束不能直接定义。必须使用小于或等于代替。
- en: Listing A.1 Solving the chess set problem using SciPy
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.1 使用SciPy解决棋盘问题
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Declare coefficients of the objective function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ① 声明目标函数的系数。
- en: ② Left-hand side of the machining time constraint
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ② 加工时间约束的左侧
- en: ③ Left-hand side of the weight constraint
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 权重约束的左侧
- en: ④ Right-hand side of the machining time constraint
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 加工时间约束的右侧
- en: ⑤ Right-hand side of the weight constraint
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 权重约束的右侧
- en: ⑥ Bounds of the decision variables
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 决策变量的界限
- en: ⑦ Solve the linear programming problem.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 解决线性规划问题。
- en: ⑧ Print the solution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 打印解决方案。
- en: 'Running this code gives the following results:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将得到以下结果：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `linprog()` function used in the preceding code returns a data structure
    with several attributes such as `x` (the current solution vector), `fun` (the
    current value of the objective function), and `success` (`true` when the algorithm
    has completed successfully).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中使用的`linprog()`函数返回一个包含多个属性的数据结构，例如`x`（当前解向量）、`fun`（目标函数的当前值）和`success`（当算法成功完成时为`true`）。
- en: A.2.2 PuLP
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.2 PuLP
- en: '[PuLP](https://coin-or.github.io/pulp/) is a linear programming library in
    Python that allows you to define and solve linear optimization problems. There
    are two main classes in PuLP: `LpProblem` and `LpVariable`. PuLP variables can
    be declared individually or as “dictionaries” (variables indexed on another set).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[PuLP](https://coin-or.github.io/pulp/) 是一个Python线性规划库，允许您定义和解决线性优化问题。PuLP中有两个主要类：`LpProblem`和`LpVariable`。PuLP变量可以单独声明或作为“字典”（在另一个集合上索引的变量）。'
- en: 'You can install PuLP using pip as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下pip命令安装PuLP：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following code (a continuation of listing A.1) shows how to use PuLP to
    solve the chess set problem:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码（列表A.1的延续）展示了如何使用PuLP解决棋盘问题：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① Define the model.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义模型。
- en: ② Define the decision variables.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义决策变量。
- en: ③ Add constraints.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 添加约束。
- en: ④ Set the profit as the objective function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将利润设置为目标函数。
- en: ⑤ Solve the optimization problem.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 解决优化问题。
- en: ⑥ Print the solution.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 打印解决方案。
- en: PuLP implements several algorithms for solving linear programming (LP) and mixed-integer
    linear programming (MILP) problems. Examples include COIN-OR (computational infrastructure
    for operations research), CLP (COIN-OR linear programming), Cbc (COIN-OR branch
    and cut), CPLEX (Cplex), GLPK (GNU linear programming lit), SCIP (solving constraint
    integer programs), HiGHS (highly scalable global solver), Gurobi LP/MIP solver,
    Mosek optimizer, and the XPRESS LP solver.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: PuLP实现了多种算法来解决线性规划（LP）和混合整数线性规划（MILP）问题。例如包括COIN-OR（运筹学研究计算基础设施）、CLP（COIN-OR线性规划）、Cbc（COIN-OR分支和切割）、CPLEX（Cplex）、GLPK（GNU线性规划库）、SCIP（解决约束整数规划）、HiGHS（高度可扩展的全局求解器）、Gurobi
    LP/MIP求解器、Mosek优化器以及XPRESS LP求解器。
- en: A.2.3 Other mathematical programming solvers
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.3 其他数学编程求解器
- en: 'There are several other libraries in Python for solving mathematical optimization
    problems. This is a non-exhaustive list of other available libraries:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Python中还有几个用于解决数学优化问题的库。以下是一个不完整的其他可用库列表：
- en: '[OR-Tools](https://developers.google.com/optimization)—This is an open source
    software suite for optimization and constraint programming developed by Google.
    It includes a variety of algorithms and tools for solving problems in areas such
    as operations research, transportation, scheduling, and logistics. OR-Tools can
    be used to model and solve linear and integer programming problems, as well as
    constraint programming problems. Examples of OR-Tools solvers include GLOP (Google
    linear programming), Cbc (COIN-OR branch and cut), CP-SAT (constraint programming-satisfiability)
    solver, max flow and min cost flow solvers, the shortest path solver, and the
    BOP (binary optimization problem) solver. It is written in C++ and includes interfaces
    for several programming languages, including Python, C#, and Java. See section
    A.4.5 for more details and an example.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[OR-Tools](https://developers.google.com/optimization)—这是一个由Google开发的用于优化和约束编程的开源软件套件。它包括解决运筹学、运输、调度和物流等领域问题的各种算法和工具。OR-Tools可用于建模和解决线性规划、整数规划以及约束编程问题。OR-Tools求解器的例子包括GLOP（Google线性规划）、Cbc（COIN-OR分支和切割）、CP-SAT（约束编程-可满足性）求解器、最大流和最小成本流求解器、最短路径求解器以及BOP（二进制优化问题）求解器。它用C++编写，并为包括Python、C#和Java在内的多种编程语言提供了接口。有关更多详细信息及示例，请参阅A.4.5节。'
- en: '[Gurobi](https://www.gurobi.com/documentation/)—This is commercial optimization
    software that offers state-of-the-art solvers for linear programming, quadratic
    programming, and mixed integer programming. It has a Python interface that can
    be used to define and solve optimization problems.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Gurobi](https://www.gurobi.com/documentation/)—这是一款商业优化软件，提供线性规划、二次规划和混合整数规划的尖端求解器。它提供了一个Python接口，可用于定义和解决优化问题。'
- en: '[CasADi](https://web.casadi.org/)—This is an open source tool for nonlinear
    optimization and algorithmic differentiation.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CasADi](https://web.casadi.org/)—这是一个用于非线性优化和算法微分的开源工具。'
- en: '[Python-MIP](https://www.python-mip.com/)—This is a Python library for solving
    mixed-integer programming problems. It is built on top of the Cbc open source
    optimization library and allows users to express optimization models in a high-level,
    mathematical programming language.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python-MIP](https://www.python-mip.com/)—这是一个用于解决混合整数规划问题的Python库。它建立在Cbc开源优化库之上，并允许用户使用高级、数学化的编程语言表达优化模型。'
- en: '[Pyomo](http://www.pyomo.org/)—This is an open source optimization modeling
    language that can be used to define and solve mathematical optimization problems
    in Python. It supports a wide range of optimization solvers, including for linear
    programming, mixed integer programming, and nonlinear optimization.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Pyomo](http://www.pyomo.org/)—这是一个开源的优化建模语言，可用于在Python中定义和解决数学优化问题。它支持广泛的优化求解器，包括线性规划、混合整数规划和非线性优化。'
- en: '[GEKKO](https://gekko.readthedocs.io/en/latest/)—This is a Python package for
    machine learning and the optimization of mixed-integer and differential algebraic
    equations.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GEKKO](https://gekko.readthedocs.io/en/latest/)—这是一个用于机器学习和混合整数及微分代数方程优化的Python包。'
- en: '[CVXPY](https://www.cvxpy.org/)—This is an open source Python-embedded modeling
    language for convex optimization problems. It lets you express your problem in
    a natural way that follows the math, rather than in the restrictive standard form
    required by solvers.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CVXPY](https://www.cvxpy.org/)—这是一个用于凸优化问题的开源Python嵌入式建模语言。它允许您以遵循数学的方式自然地表达问题，而不是遵循求解器要求的限制性标准形式。'
- en: '[PyMathProg](https://pymprog.sourceforge.net/)—This is a mathematical programming
    environment for Python that allows for modeling, solving, analyzing, modifying,
    and manipulating linear programming problems.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PyMathProg](https://pymprog.sourceforge.net/)—这是一个为Python设计的数学编程环境，允许建模、求解、分析、修改和操作线性规划问题。'
- en: '[Optlang](https://optlang.readthedocs.io/en/latest/)—This is a Python library
    for modeling and solving mathematical optimization problems. It provides a common
    interface to a series of optimization tools so that different solver backends
    can be changed in a transparent way. It is compatible with most of the popular
    optimization solvers like Gurobi, Cplex, and Ipopt (interior point optimizer).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Optlang](https://optlang.readthedocs.io/en/latest/)—这是一个用于建模和求解数学优化问题的 Python
    库。它提供了一系列优化工具的通用接口，以便可以以透明的方式更改不同的求解器后端。它与大多数流行的优化求解器兼容，如 Gurobi、Cplex 和 Ipopt（内点优化器）。'
- en: '[Python interface to conic optimization solvers (PICOS)](https://picos-api.gitlab.io/picos/)—This
    is a Python library for modeling and solving optimization problems. It can handle
    complex problems with multiple objectives, and it supports both local and global
    optimization methods. PICOS has interfaces to different solvers such as Gurobi,
    CPLEX, SCS (splitting conic solver), ECOS (embedded cone solver), and MOSEK.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python 接口到锥优化求解器 (PICOS)](https://picos-api.gitlab.io/picos/)—这是一个用于建模和求解优化问题的
    Python 库。它可以处理具有多个目标的复杂问题，并支持局部和全局优化方法。PICOS 具有与不同求解器（如 Gurobi、CPLEX、SCS（分割锥求解器）、ECOS（嵌入式锥求解器）和
    MOSEK）的接口。'
- en: '[CyLP](https://github.com/coin-or/cylp)—This is a Python interface to COIN-OR’s
    linear and mixed-integer program solvers (CLP, Cbc, and CGL). COIN-OR (computational
    infrastructure for operations research) is a collection of open source software
    packages for operations research and computational optimization. It includes libraries
    for linear and integer programming, constraint programming, and other optimization
    techniques.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CyLP](https://github.com/coin-or/cylp)—这是一个到 COIN-OR 的线性混合整数规划求解器（CLP、Cbc
    和 CGL）的 Python 接口。COIN-OR（运筹学计算基础设施）是运筹学和计算优化开源软件包的集合。它包括线性规划和整数规划、约束规划以及其他优化技术的库。'
- en: '[SymPy](https://www.sympy.org/en/index.html)—This is a Python library for symbolic
    mathematics. It can be used to solve equations, handle combinatorics, plot in
    2D/3D, or work on polynomials, calculus, discrete math, matrices, geometry, parsing,
    physics, statistics, and cryptography.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SymPy](https://www.sympy.org/en/index.html)—这是一个用于符号数学的 Python 库。它可以用来解方程、处理组合数学、在
    2D/3D 中绘图，或者处理多项式、微积分、离散数学、矩阵、几何、解析、物理、统计学和密码学。'
- en: '*Other libraries*—These include but are not limited to, [MOSEK](https://docs.mosek.com/latest/pythonapi/index.html),
    [CVXOPT](https://cvxopt.org/), ,, , , and .'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*其他库*—这些包括但不限于[MOSEK](https://docs.mosek.com/latest/pythonapi/index.html)、[CVXOPT](https://cvxopt.org/)、，
    ， ，和。'
- en: Jupyter notebook “Listing A.1_Mathematical_programming_solvers.ipynb,” included
    in the GitHub repo for the book shows how to use some of these solvers to solve
    the chess set problem.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍的 GitHub 仓库中包含的 Jupyter 笔记本“Listing A.1_Mathematical_programming_solvers.ipynb”展示了如何使用这些求解器解决棋盘问题。
- en: A.3 Graph and mapping libraries
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 图和映射库
- en: The following Python libraries are used in this book to process and visualize
    graphs, networks, and geospatial data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用以下 Python 库来处理和可视化图、网络和地理空间数据。
- en: A.3.1 NetworkX
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.1 NetworkX
- en: '[NetworkX](https://networkx.org/) is a library for working with graphs and
    networks in Python. It provides tools for creating, manipulating, and analyzing
    graph data, as well as for visualizing graph structures. NetworkX also contains
    approximations of graph properties and heuristic methods for optimization. You
    can install NetworkX as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[NetworkX](https://networkx.org/) 是一个用于在Python中处理图和网络库。它提供了创建、操作和分析图数据以及可视化图结构的工具。NetworkX
    还包含图属性的近似和优化问题的启发式方法。你可以按照以下方式安装 NetworkX：'
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let’s consider the traveling salesman problem (TSP). Listing A.2 shows the steps
    for creating a random undirected graph for this problem. Each randomly scattered
    node represents a city to be visited by the salesman, and the weight of each edge
    connecting the cities is calculated based on the Euclidian distance between the
    nodes using the `hypot` function, which calculates the square root of the sum
    of the squares. Christofides algorithm is used to solve this TSP instance—this
    algorithm provides a 3/2-approximation of TSP. This means that its solutions will
    be within a factor of 1.5 of the optimal solution length.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑旅行商问题（TSP）。列表A.2显示了为该问题创建随机无向图的步骤。每个随机散布的节点代表销售员要访问的城市，连接城市的每条边的权重是基于节点之间的欧几里得距离使用`hypot`函数计算的，该函数计算平方和的平方根。使用Christofides算法解决此TSP实例——此算法提供TSP的3/2近似。这意味着其解决方案将在最优解长度的1.5倍以内。
- en: Listing A.2 Solving TSP using NetworkX
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.2 使用NetworkX解决TSP
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① Create a random geometric graph with 20 nodes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个包含20个节点的随机几何图。
- en: ② Set (0,0) as the home city/depot.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将(0,0)设置为家乡城市/仓库。
- en: ③ Create an independent shallow copy of the graph and attributes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建一个独立的浅拷贝的图和属性。
- en: ④ Calculate the distances between the nodes as the edge's weight.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将节点之间的距离作为边的权重计算。
- en: ⑤ Solve TSP using Christofides algorithm.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 使用Christofides算法解决TSP。
- en: ⑥ Highlight the closest edges on each node only.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 仅在每个节点上突出显示最近的边。
- en: ⑦ Draw the route.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 绘制路线。
- en: ⑧ Print the route.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 打印路线。
- en: Figure A.1 shows the solution for this TSP.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.1显示了此TSP的解决方案。
- en: '![](../Images/APPA_F01_Khamis.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPA_F01_Khamis.jpg)'
- en: Figure A.1 Solving TSP using Christofides algorithm implemented in NetworkX.
    The found route is 0, 10, 7, 2, 6, 1, 15, 14, 5, 17, 4, 9, 12, 18, 3, 19, 16,
    8, 11, 13, 0.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.1 使用NetworkX中实现的Christofides算法解决TSP。找到的路线是0, 10, 7, 2, 6, 1, 15, 14, 5, 17,
    4, 9, 12, 18, 3, 19, 16, 8, 11, 13, 0。
- en: NetworkX supports a variety of graph search algorithms and can perform network
    analyses using packages within the geospatial Python ecosystem.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX支持多种图搜索算法，并可以使用地理空间Python生态系统中的包执行网络分析。
- en: A.3.2 OSMnx
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.2 OSMnx
- en: '[OSMnx](https://osmnx.readthedocs.io/en/stable/) is a Python library developed
    to ease the process of retrieving and manipulating data from [OpenStreetMap](https://www.openstreetmap.org)
    (OSM). It offers the ability to download the data (filtered) from OSM and returns
    the network as a NetworkX graph data structure. It is a free and open source geographic
    data for the world.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[OSMnx](https://osmnx.readthedocs.io/en/stable/) 是一个Python库，旨在简化从 [OpenStreetMap](https://www.openstreetmap.org)
    (OSM) 获取和操作数据的过程。它提供了从OSM下载数据（过滤后）并返回作为NetworkX图数据结构网络的能力。它是全球免费开源的地理数据。'
- en: 'You can install OSMnx with `conda`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`conda`安装OSMnx：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: OSMnx can be used to convert a text descriptor of a place into a NetworkX graph.
    Let’s use Times Square in New York City as an example in the following continuation
    of listing A.2.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: OSMnx 可以将地点的文本描述符转换为 NetworkX 图。以下列表A.2的后续内容中，我们将以纽约市的时报广场为例。
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① Name of the place or point of interest
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ① 地点名称或兴趣点
- en: ② NetworkX graph of the named place
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ② 命名地点的NetworkX图
- en: ③ Plot the graph.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 绘制图。
- en: Figure A.2 shows the graph of Times Square based on driving mode.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.2显示了基于驾驶模式的时报广场图。
- en: '![](../Images/APPA_F02_Khamis.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPA_F02_Khamis.jpg)'
- en: Figure A.2 Times Square graph with drivable streets
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.2 可行驶街道的时报广场图
- en: '`network_type` allows you to select the type of street network based on the
    mobility mode: `all_private`, `all`, `bike`, `drive`, `drive_service`, or `walk`.
    You can highlight all the one-way edges in the Times Square street network using
    these two lines of code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`network_type` 允许您根据移动模式选择街道网络类型：`all_private`、`all`、`bike`、`drive`、`drive_service`或`walk`。您可以使用这两行代码突出显示时报广场街道网络中的所有单行边：'
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Various properties of the graph can be examined, such as the graph type, edge
    (road) types, CRS projection, etc. For example, you can print the graph type using
    `type(graph)` and extract the nodes and edges of the graph as separate structures
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可以检查图的各种属性，例如图类型、边（道路）类型、CRS投影等。例如，您可以使用`type(graph)`打印图类型，并如下提取图的节点和边作为单独的结构：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can further drill down to examine each individual node or edge.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步深入到每个单独的节点或边进行考察。
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can also retrieve the street types for the graph:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以检索图的街道类型：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Running the preceding code line gives the following statistics about the Times
    Square road network:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码行给出了以下关于时报广场道路网络的统计数据：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: More statistics can be generated using `osmnx.basic_stats(graph)`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`osmnx.basic_stats(graph)`生成更多统计信息。
- en: 'GeoDataFrames can be easily converted to MultiDiGraphs by using `osmnx.graph_from_gdfs`
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`osmnx.graph_from_gdfs`可以将GeoDataFrames轻松转换为MultiDiGraphs，如下所示：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This results in the same road network shown in figure A.2\. You can also save
    the street network in different formats as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了与图A.2中显示相同的道路网络。您还可以按以下方式将街道网络保存为不同的格式：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ① Save the street network as a PNG.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将街道网络保存为PNG。
- en: ② Save the street network as an SVG.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将街道网络保存为SVG。
- en: ③ Save the graph to disk as an .osm XML file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将图形保存为磁盘上的.osm XML文件。
- en: ④ Save the street network as a GeoPackage file for GIS
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将街道网络保存为GeoPackage文件用于GIS
- en: ⑤ Save the street network as a GraphML file for OSMnx, NetworkX, or Gephi.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将街道网络保存为OSMnx、NetworkX或Gephi的GraphML文件。
- en: ⑥ Save the graph as a shapefile.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 将图形保存为shapefile。
- en: A.3.3 GeoPandas
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.3 GeoPandas
- en: '[GeoPandas](https://geopandas.org/en/stable/index.html) is an extension to
    Pandas that handles geospatial data by extending the datatypes of Pandas and the
    ability to query and manipulate spatial data. It provides tools for reading, writing,
    and manipulating geospatial data, as well as for visualizing and mapping data
    on a map. You can install GeoPandas using pip or conda as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[GeoPandas](https://geopandas.org/en/stable/index.html) 是Pandas的一个扩展，通过扩展Pandas的数据类型和查询、操作空间数据的能力来处理地理空间数据。它提供了读取、写入和操作地理空间数据的工具，以及可视化并在地图上绘制数据的工具。您可以使用pip或conda安装GeoPandas，如下所示：'
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'GeoPandas can handle different geospatial data formats such as shapefiles (.shp),
    CSV (comma separated values), GeoJSON, ESRI JSON, GeoPackage (.gpkg), GML, GPX
    (GPS exchange format), and KML (Keyhole Markup Language). For example, let’s assume
    we want to read Ontario’s health region data based on a shapefile that can be
    downloaded from the Ontario data catalogue included in the book’s GitHub repo
    (in the appendix B data folder). A shapefile is a popular geospatial data format
    for storing vector data (such as points, lines, and polygons). It is a widely
    used format for storing GIS data, and it’s supported by many GIS software packages,
    including ArcGIS and QGIS. A shapefile is actually a collection of several files
    with different extensions, including the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: GeoPandas可以处理不同的地理空间数据格式，如shapefiles (.shp)、CSV（逗号分隔值）、GeoJSON、ESRI JSON、GeoPackage
    (.gpkg)、GML、GPX（GPS交换格式）和KML（Keyhole标记语言）。例如，假设我们想根据书中GitHub仓库（附录B数据文件夹中）包含的安大略省数据目录中的shapefile读取安大略省的健康区域数据。shapefile是一种流行的地理空间数据格式，用于存储矢量数据（如点、线和多边形）。它是存储GIS数据广泛使用的格式，并且被许多GIS软件包支持，包括ArcGIS和QGIS。实际上，shapefile是一组具有不同扩展名的文件集合，包括以下内容：
- en: '*.shp*—The main file, which contains the geospatial data (points, lines, or
    polygons)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.shp*—主文件，包含地理空间数据（点、线或多边形）'
- en: '*.shx*—The index file, which allows for faster access to the data in the .shp
    file'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.shx*—索引文件，允许更快地访问.shp文件中的数据'
- en: '*.dbf*—The attribute file, which contains the attribute data (non-geographic
    information) for each feature in the .shp file'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.dbf*—属性文件，包含.shp文件中每个特征的属性数据（非地理信息）'
- en: '*.prj*—The projection file, which defines the coordinate system and projection
    information for the data in the .shp file'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.prj*—投影文件，定义.shp文件中数据的坐标系和投影信息'
- en: '*.sbx*—A spatial index of the features'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.sbx*—特征的空间索引'
- en: 'The following continuation of listing A.2 shows how to read this geospatial
    data from [https://data.ontario.ca/dataset/ontario-s-health-region-geographic-data](https://data.ontario.ca/dataset/ontario-s-health-region-geographic-data),
    which is stored in the book’s GitHub repo:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.2的以下续集显示了如何从[https://data.ontario.ca/dataset/ontario-s-health-region-geographic-data](https://data.ontario.ca/dataset/ontario-s-health-region-geographic-data)读取此地理空间数据，该数据存储在本书的GitHub仓库中：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ① Define the base URL for the raw files.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义原始文件的基URL。
- en: ② Files associated with the shapefile.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ② 与shapefile相关的文件。
- en: ③ Temporarily download the files from the specified URL.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 从指定的URL临时下载文件。
- en: ④ Read the shapefile with geopandas.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用geopandas读取shapefile。
- en: ⑤ Cleanup/remove the downloaded files.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 清理/删除下载的文件。
- en: ⑥ Print the first n rows.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 打印前n行。
- en: The complete version of [listing A.2](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.2_Graph_libraries.ipynb)
    is available in the book’s GitHub repo.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表A.2的完整版本](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.2_Graph_libraries.ipynb)可在本书的GitHub仓库中找到。'
- en: A.3.4 contextily
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.4 上下文相关
- en: '[contextily](https://contextily.readthedocs.io/en/latest/) is a Python library
    for adding contextual basemaps to plots created with libraries such as Matplotlib,
    Plotly, and others. For example, contextily can be used to add context when we
    render the Ontario health region data, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[contextily](https://contextily.readthedocs.io/en/latest/) 是一个Python库，用于向使用Matplotlib、Plotly等库创建的图表添加上下文底图。例如，contextily可以用于在渲染安大略省卫生区域数据时添加上下文，如下所示：'
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'contextily supports several different sources for basemaps, including the following
    commonly used sources:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: contextily支持多个不同的底图源，包括以下常用源：
- en: '*OpenStreetMap (OSM)*—This is the default source for contextily. It is a free
    and open source map service that provides a variety of different styles, including
    the default Mapnik style and others such as Humanitarian and Cycle.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OpenStreetMap (OSM)*—这是contextily的默认源。它是一个免费的开源地图服务，提供多种不同的样式，包括默认的Mapnik样式以及其他如人道主义和自行车样式。'
- en: '*Stamen*—This source provides a variety of different map styles, including
    Toner, Terrain, and Watercolor.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Stamen*—本源提供多种不同的地图样式，包括Toner、地形和水彩。'
- en: '*Mapbox*—This source provides a variety of different map styles, including
    Streets, Outdoors, and Satellite. It requires an API key to use.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Mapbox*—本源提供多种不同的地图样式，包括街道、户外和卫星图。使用时需要API密钥。'
- en: '*MapQuest*—This source provides a variety of different map styles, including
    OSM and Aerial. It requires an API key to use.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MapQuest*—本源提供多种不同的地图样式，包括OSM和航空图。使用时需要API密钥。'
- en: '*Here*—This source provides a variety of different map styles, including Normal
    Day and Normal Night. It requires an API key to use.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*这里*—本源提供多种不同的地图样式，包括正常日和正常夜。使用时需要API密钥。'
- en: '*Google Maps*—This source provides a variety of different map styles, including
    Roadmap, Satellite, and Terrain. It requires an API key to use.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google Maps*—本源提供多种不同的地图样式，包括路线图、卫星图和地形图。使用时需要API密钥。'
- en: A.3.5 Folium
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.5 Folium
- en: '[Folium](https://python-visualization.github.io/folium/) is a library for creating
    interactive maps in Python using the Leaflet.js library. It provides tools for
    reading, writing, and manipulating geospatial data, as well as for visualizing
    and mapping data on a map. Folium can be used to create static or dynamic maps,
    as well as to customize the appearance and behavior of the map. The following
    continuation of listing A.2 shows how to use Folium to visualize Ontario Health
    regions on a map:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[Folium](https://python-visualization.github.io/folium/) 是一个用于在Python中使用Leaflet.js库创建交互式地图的库。它提供了读取、写入和操作地理空间数据、以及可视化并在地图上绘制数据的工具。Folium可以用来创建静态或动态地图，还可以自定义地图的外观和行为。以下A.2列表的延续展示了如何使用Folium在地图上可视化安大略省卫生区域：'
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ① Transform geometries to a new coordinate reference system (CRS).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将几何形状转换为新的坐标参考系统（CRS）。
- en: ② Set starting location, initial zoom, and base layer source.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置起始位置、初始缩放和底图源。
- en: ③ Simplify each region's polygon, as intricate details are unnecessary.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 简化每个区域的 polygon，因为复杂的细节是不必要的。
- en: ④ Render the map.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 渲染地图。
- en: The “[Listing A.2_Graph_libraries.ipynb](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.2_Graph_libraries.ipynb)”
    notebook available in the book’s GitHub repo provides examples of different ways
    of visualizing geospatial data, such as chloropleth map, cartogram map, bubble
    map, hexagonal binning, heat map, and cluster map.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍GitHub仓库中可用的“[附录A.2_图形库.ipynb](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.2_Graph_libraries.ipynb)”笔记本提供了不同方式可视化地理空间数据的示例，例如渐变地图、人口分布地图、气泡地图、六边形分箱、热图和聚类地图。
- en: A.3.6 Other libraries and tools
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.6 其他库和工具
- en: 'The following is a non-exhaustive list of other useful libraries and tools
    for working on geospatial data, graphs, and networks:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是非详尽的列表，列出了其他用于处理地理空间数据、图形和网络的有用库和工具：
- en: '[Pyrosm](https://pyrosm.readthedocs.io/en/latest/)—This is another Python library
    for reading OpenStreetMap from Protocolbuffer Binary Format files (*.osm.pbf).
    It can be used to download and read OpenStreetMap data, extract features such
    as roads, buildings, and points of interest, and analyze and visualize the data.
    The main difference between Pyrosm and OSMnx is that OSMnx reads the data using
    an OverPass API, whereas Pyrosm reads the data from local OSM data dumps that
    are downloaded from the Protocolbuffer Binary Format file (*.osm.pbf) data providers
    (Geofabrik, BBBike) and converts it into GeoPandas GeoDataFrames. This makes it
    possible to parse OSM data faster and makes it more feasible to extract data covering
    large regions.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Pyrosm](https://pyrosm.readthedocs.io/en/latest/)—这是另一个用于从Protocolbuffer Binary
    Format文件 (*.osm.pbf) 读取OpenStreetMap的Python库。它可以用于下载和读取OpenStreetMap数据，提取诸如道路、建筑和兴趣点等特征，并分析和可视化数据。Pyrosm与OSMnx的主要区别在于，OSMnx使用OverPass
    API读取数据，而Pyrosm从本地从Protocolbuffer Binary Format文件 (*.osm.pbf) 数据提供者（Geofabrik、BBBike）下载的OSM数据转储中读取数据，并将其转换为GeoPandas
    GeoDataFrames。这使得解析OSM数据更快，并使得提取覆盖大范围的数据更加可行。'
- en: '[Pandana](https://udst.github.io/pandana/)—This is a Python library for network
    analysis that uses contraction hierarchies to calculate super-fast travel accessibility
    metrics and shortest paths.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Pandana](https://udst.github.io/pandana/)—这是一个使用收缩层次结构来计算超级快速旅行可达性指标和最短路径的Python网络分析库。'
- en: '[GeoPy](https://geopy.readthedocs.io/en/stable/)—This is a Python client for
    several popular geocoding web services.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GeoPy](https://geopy.readthedocs.io/en/stable/)—这是一个用于几个流行的地理编码Web服务的Python客户端。'
- en: '[Graphviz](https://graphviz.org/)—This is a library for creating visualizations
    of graphs and tree structures in Python. It provides tools for defining the structure
    of a graph, as well as for rendering the graph in various formats, such as PNG,
    PDF, and SVG. Graphviz is a useful tool for visualizing algorithms that operate
    on graphs, such as graph search algorithms and graph traversal algorithms.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Graphviz](https://graphviz.org/)—这是一个用于在Python中创建图和树结构可视化的库。它提供了定义图结构以及以各种格式（如PNG、PDF和SVG）渲染图的工具。Graphviz是可视化在图上操作的算法（如图搜索算法和图遍历算法）的有用工具。'
- en: '[Gephi](https://gephi.org/)—This is a tool for visualizing and analyzing graphs
    and networks. It provides a graphical user interface for defining and customizing
    the appearance of graphs and diagrams, as well as for visualizing algorithms and
    data structures. Gephi can be used to visualize algorithms that operate on graph
    data, such as graph search algorithms and shortest path algorithms.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Gephi](https://gephi.org/)—这是一个用于可视化和分析图和网络的工具。它提供了一个图形用户界面来定义和自定义图形和图表的外观，以及可视化算法和数据结构。Gephi可以用于可视化在图数据上操作的算法，例如图搜索算法和最短路径算法。'
- en: '[Cytoscape](https://cytoscape.org/)—This is an open-source software platform
    for visualizing complex networks and integrating these with any type of attribute
    data.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Cytoscape](https://cytoscape.org/)—这是一个用于可视化复杂网络并将其与任何类型的属性数据集成的开源软件平台。'
- en: '[ipyleaflet](https://github.com/jupyter-widgets/ipyleaflet)—This is an interactive
    widgets library that is based on ipywidgets. ipywidgets, also known as jupyter-widgets
    or simply widgets, are interactive HTML widgets for Jupyter notebooks and the
    IPython kernel. Ipyleaflet brings mapping capabilities to the notebook and JupyterLab.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ipyleaflet](https://github.com/jupyter-widgets/ipyleaflet)—这是一个基于ipywidgets的交互式小部件库。ipywidgets，也称为jupyter-widgets或简称为widgets，是Jupyter笔记本和IPython内核的交互式HTML小部件。Ipyleaflet将地图功能带到了笔记本和JupyterLab中。'
- en: '[hvPlot](https://hvplot.holoviz.org/)— This is a Python library that provides
    a high-level plotting API built on top of the HoloViews library. It can be used
    with GeoPandas to create interactive visualizations of geospatial data.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[hvPlot](https://hvplot.holoviz.org/)—这是一个基于HoloViews库构建的Python库，提供高级绘图API。它可以与GeoPandas一起使用，创建地理空间数据的交互式可视化。'
- en: '[mplleaflet](https://github.com/jwass/mplleaflet)—This is another `leaflet`-based
    library, but it plays nicely with `matplotlib`.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[mplleaflet](https://github.com/jwass/mplleaflet)—这是一个基于`leaflet`的库，但它与`matplotlib`配合得很好。'
- en: '[Cartopy](https://scitools.org.uk/cartopy/docs/latest/)—Cartopy is a library
    for creating maps and geospatial plots in Python.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Cartopy](https://scitools.org.uk/cartopy/docs/latest/)—Cartopy是一个用于在Python中创建地图和地理空间绘图的库。'
- en: '[geoplotlib](https://github.com/andrea-cuttone/geoplotlib)—geoplotlib is a
    library for creating maps and visualizations in Python. It provides tools for
    styling and customizing map elements, as well as for overlaying data on top of
    maps. geoplotlib can be used to create static or interactive maps and supports
    a variety of map projections and coordinate systems.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[geoplotlib](https://github.com/andrea-cuttone/geoplotlib)—geoplotlib 是一个用于在
    Python 中创建地图和可视化的库。它提供了样式化和定制地图元素的工具，以及将数据叠加到地图上的工具。geoplotlib 可以用于创建静态或交互式地图，并支持多种地图投影和坐标系。'
- en: '[Shapely](https://shapely.readthedocs.io/en/stable/)—This is an open source
    Python library for performing geometric operations on objects in the Cartesian
    plane.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Shapely](https://shapely.readthedocs.io/en/stable/)—这是一个用于在笛卡尔平面上对对象执行几何操作的
    Python 开源库。'
- en: '[deck.gl](https://deck.gl/)—This is an open source JavaScript library for WebGL-powered
    large dataset visualization.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[deck.gl](https://deck.gl/)—这是一个用于 WebGL 驱动的开放式 JavaScript 库，用于大规模数据集的可视化。'
- en: '[kepler.gl](https://kepler.gl/)—This is a powerful open source geospatial analysis
    tool for large-scale data sets.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[kepler.gl](https://kepler.gl/)—这是一个强大的开源地理空间分析工具，用于大规模数据集。'
- en: A.4 Metaheuristics optimization libraries
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.4 元启发式优化库
- en: There are several libraries in Python that provide implementations of different
    metaheuristic optimization algorithms. The following subsections cover some commonly
    used libraries.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中有几个库提供了不同元启发式优化算法的实现。以下小节涵盖了某些常用库。
- en: A.4.1 PySwarms
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.1 PySwarms
- en: '[PySwarms](https://pyswarms.readthedocs.io/en/latest/index.html) is a library
    for implementing swarm intelligence algorithms in Python. It provides tools for
    defining, training, and evaluating swarm intelligence models, as well as for visualizing
    the optimization process. PySwarms supports a variety of swarm intelligence algorithms,
    including particle swarm optimization (PSO) and ant colony optimization (ACO).
    The next listing shows the steps for solving a function optimization problem using
    PSO implemented in PySwarms.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[PySwarms](https://pyswarms.readthedocs.io/en/latest/index.html) 是一个用于在 Python
    中实现群体智能算法的库。它提供了定义、训练和评估群体智能模型以及可视化优化过程的工具。PySwarms 支持多种群体智能算法，包括粒子群优化（PSO）和蚁群优化（ACO）。下面的列表显示了使用
    PySwarms 实现的 PSO 解决函数优化问题的步骤。'
- en: Listing A.3 Solving function optimization using PSO implemented in PySwarms
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.3 使用 PySwarms 实现的 PSO 解决函数优化问题
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ① Import the Image class to enable the display of images within the notebook
    environment.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入 Image 类以在笔记本环境中显示图像。
- en: ② Set up PSO as an optimizer with 50 particles and predefined parameters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置 PSO 作为具有 50 个粒子和预定义参数的优化器。
- en: ③ Solve the function optimization problem using PSO.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用 PSO 解决函数优化问题。
- en: ④ Set up the sphere unimodal function to be optimized using PSO, and set up
    the number of iterations.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置使用 PSO 优化的单峰球面函数，并设置迭代次数。
- en: ⑤ Plot the cost.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 绘制成本。
- en: ⑥ Plot the sphere function's mesh for better plots.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 绘制球面函数的网格以获得更好的图形。
- en: ⑦ Adjust the figure limits.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 调整图形限制。
- en: ⑧ Generate animation for the solution history on a contour.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 在等高线上生成解的历史动画。
- en: ⑨ Render the animation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 渲染动画。
- en: A.4.2 Scikit-opt
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.2 Scikit-opt
- en: '[Scikit-opt](https://scikit-opt.github.io/) is an optimization library that
    provides a simple and flexible interface for defining and running optimization
    problems with various metaheuristics, such as genetic algorithms, particle swarm
    optimization, simulated annealing, ant colony algorithm, immune algorithm, and
    artificial fish swarm algorithm. Scikit-opt can be used to solve both continuous
    and discrete problems. The following continuation of listing A.3 shows the steps
    for solving a function optimization problem using scikit-opt:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[Scikit-opt](https://scikit-opt.github.io/) 是一个优化库，它提供了一个简单灵活的接口来定义和运行使用各种元启发式（如遗传算法、粒子群优化、模拟退火、蚁群算法、免疫算法和人工鱼群算法）的优化问题。Scikit-opt
    可以用于解决连续和离散问题。以下列表 A.3 的延续显示了使用 scikit-opt 解决函数优化问题的步骤：'
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ① Define a multimodal function.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义一个多模态函数。
- en: ② Solve the problem using simulated annealing (SA).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用模拟退火（SA）解决问题。
- en: ③ Print the result.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 打印结果。
- en: Let’s consider the TSP instance shown in figure A.3\. In this TSP, a travelling
    salesman must visit 20 major US cities starting from a specific city.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑图 A.3 中显示的 TSP 实例。在这个 TSP 中，一位旅行推销员必须从一个特定的城市开始访问 20 个主要的美国城市。
- en: '![](../Images/APPA_F03_Khamis.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPA_F03_Khamis.jpg)'
- en: Figure A.3 Travelling salesman problem (TSP) for 20 major US cities
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.3 20个主要美国城市的旅行商问题（TSP）
- en: 'The following continuation of listing A.3 shows the steps for solving this
    problem using scikit-opt:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表A.3的后续部分展示了使用scikit-opt解决此问题的步骤。
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① Define the TSP problem.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义TSP问题。
- en: ② Calculate the total distance.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ② 计算总距离。
- en: ③ Solve the problem using PSO.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用PSO（粒子群优化）解决问题。
- en: ④ Print the solution.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 打印解决方案。
- en: A.4.3 NetworkX
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.3 NetworkX
- en: 'NetworkX, introduced in the previous section, provides approximations of graph
    properties and heuristic methods for optimization. An example of these heuristics
    algorithms is simulated annealing. The following continuation of listing A.3 shows
    the steps for solving TSP using simulated annealing implemented in NetworkX:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中介绍的NetworkX提供了图属性的近似和优化启发式方法。这些启发式算法的例子包括模拟退火。以下列表A.3的后续部分展示了使用NetworkX中实现的模拟退火解决TSP的步骤。
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ① Create a graph.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个图。
- en: ② Add weighted edges to the graph, and remove selfloop edges.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ② 向图中添加加权边，并移除自环边。
- en: ③ Define pos as a dictionary of positions using the Fruchterman-Reingold force-directed
    algorithm.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用Fruchterman-Reingold力导向算法定义位置为位置的字典。
- en: ④ Solve TSP using simulated annealing.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用模拟退火解决TSP。
- en: ⑤ Print the route and the cost.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 打印路线和成本。
- en: A.4.4 Distributed evolutionary algorithms in Python (DEAP)
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.4 Python中的分布式进化算法（DEAP）
- en: '[DEAP](https://github.com/deap/deap) is a library for implementing genetic
    algorithms in Python. It provides tools for defining, training, and evaluating
    genetic algorithm models, as well as for visualizing the optimization process.
    DEAP supports a variety of genetic algorithm techniques, including selection,
    crossover, and mutation. The following continuation of listing A.3 shows the steps
    for solving TSP using simulated annealing implemented in DEAP:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[DEAP](https://github.com/deap/deap)是一个用于在Python中实现遗传算法的库。它提供了定义、训练和评估遗传算法模型以及可视化优化过程的工具。DEAP支持多种遗传算法技术，包括选择、交叉和变异。以下列表A.3的后续部分展示了使用DEAP中实现的模拟退火解决TSP的步骤：'
- en: '[PRE41]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ① Create a fitness function that minimizes the total distance
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个最小化总距离的适应度函数。
- en: ② Create the genetic operator functions.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建遗传算子函数。
- en: ③ Calculate the route length.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 计算路线长度。
- en: ④ Set the evaluation function.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置评估函数。
- en: ⑤ Set an ordered crossover.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 设置有序交叉。
- en: ⑥ Set the shuffle mutation with probability 0.05.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 设置以0.05的概率进行洗牌变异。
- en: ⑦ Select the best individual among three randomly chosen individuals.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 在三个随机选择的个体中选出最佳个体。
- en: ⑧ Set the population size.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 设置种群大小。
- en: ⑨ Set the hall of fame to select the best individual that ever lived in the
    population during the evolution.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 设置名人堂以选择在进化过程中种群中曾经存活过的最佳个体。
- en: ⑩ Solve the problem using a simple evolutionary algorithm.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 使用简单的进化算法解决问题。
- en: ⑪ Print the solution.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 打印解决方案。
- en: DEAP includes several built-in algorithms such as genetic algorithm (GA), evolutionary
    strategy (ES), genetic programming (GA), estimation of distribution algorithms
    (EDA), and particle swarm optimization (PSO).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: DEAP包含几个内置算法，如遗传算法（GA）、进化策略（ES）、遗传编程（GA）、估计分布算法（EDA）和粒子群优化（PSO）。
- en: A.4.5 OR-Tools
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.5 OR-Tools
- en: 'As previously mentioned, [OR-Tools](https://developers.google.com/optimization)
    (Operations Research Tools) is an open source library for optimization and constraint
    programming developed by Google. The following continuation of listing A.3 shows
    the steps for solving TSP using tabu search implemented in OR-Tools:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，[OR-Tools](https://developers.google.com/optimization)（运筹学工具）是由Google开发的开源优化和约束编程库。以下列表A.3的后续部分展示了使用OR-Tools中实现的禁忌搜索解决TSP的步骤：
- en: '[PRE42]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ① Convert a float array into an integer array for OR_Tools.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将浮点数组转换为整数数组以供OR_Tools使用。
- en: ② Define the problem data.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义问题数据。
- en: ③ Define a constraint programming solver.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义约束规划求解器。
- en: ④ Get the distance between the cities.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 获取城市之间的距离。
- en: ⑤ Set up tabu search as a local search metaheuristic.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 设置禁忌搜索作为局部搜索元启发式算法。
- en: ⑥ Print the solution.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 打印解决方案。
- en: The OR-Tools library also implements some metaheuristics but not as many as
    dedicated metaheuristics frameworks like DEAP. Examples include simulated annealing
    (SA), tabu search (TS), and guided local search (GLS).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: OR-Tools库也实现了某些元启发式算法，但不如DEAP等专门的元启发式框架多。例如，包括模拟退火（SA）、禁忌搜索（TS）和引导局部搜索（GLS）。
- en: A.4.6 Other libraries
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.6 其他库
- en: 'The following non-exhaustive list identifies other useful libraries and tools
    for solving optimization problems using metaheuristics:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是非详尽的列表，列出了使用元启发式方法解决优化问题的其他有用库和工具：
- en: '[simanneal](https://github.com/perrygeo/simanneal)—This is an open source Python
    module for simulated annealing. Listing A.3 shows the steps for solving TSP using
    simulated annealing implemented in simanneal.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[simanneal](https://github.com/perrygeo/simanneal)—这是一个开源的Python模块，用于模拟退火。附录A.3展示了使用simanneal中实现的模拟退火解决TSP问题的步骤。'
- en: '[Non-dominated Sorting Genetic Algorithm (NSGA-II)](https://pymoo.org/algorithms/moo/nsga2.html)—This
    is a solid multi-objective algorithm, widely used in many real-world applications.
    The algorithm is designed to find a set of solutions, called the Pareto front,
    which represents the trade-off between multiple conflicting objectives. NSGA-II
    implementations are available in pymoo and DEAP.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[非支配排序遗传算法 (NSGA-II)](https://pymoo.org/algorithms/moo/nsga2.html)—这是一个稳健的多目标算法，广泛应用于许多现实世界的应用。该算法旨在找到一组解决方案，称为帕累托前沿，它代表了多个冲突目标之间的权衡。NSGA-II在pymoo和DEAP中都有实现。'
- en: '[Python genetic algorithm (PyGAD)](https://pygad.readthedocs.io/en/latest/)—This
    is a library for implementing genetic algorithms and differential evolution in
    Python. It provides tools for defining, training, and evaluating genetic algorithm
    models, as well as for visualizing the optimization process. PyGAD supports a
    variety of genetic algorithm techniques, including selection, crossover, and mutation.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python遗传算法 (PyGAD)](https://pygad.readthedocs.io/en/latest/)—这是一个用于在Python中实现遗传算法和差分演化的库。它提供了定义、训练和评估遗传算法模型以及可视化优化过程的工具。PyGAD支持多种遗传算法技术，包括选择、交叉和变异。'
- en: '[Library for Evolutionary Algorithms in Python (LEAP)](https://leap-gmu.readthedocs.io/en/latest/index.html)—This
    is a general-purpose evolutionary algorithm (EA) package that is simple and easy
    to use. It provides a high-level abstraction for defining and running EAs.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python进化算法库 (LEAP)](https://leap-gmu.readthedocs.io/en/latest/index.html)—这是一个简单易用的通用进化算法（EA）包。它为定义和运行EA提供了高级抽象。'
- en: '[Pyevolve](https://pyevolve.sourceforge.net/index.html)—This is a Python library
    that provides a simple and flexible API for implementing and running genetic algorithms.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Pyevolve](https://pyevolve.sourceforge.net/index.html)—这是一个提供简单且灵活API的Python库，用于实现和运行遗传算法。'
- en: '[Genetic algorithms made easy (EasyGA)](https://github.com/danielwilczak101/EasyGA)—This
    is another Python library for genetic algorithms with several built-in genetic
    operators, such as selection, crossover, and mutation. EasyGA and Pyevolve are
    simple libraries with less functionality and fewer predefined problems than other
    libraries such as DEAP and Pymoo.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[遗传算法变得简单 (EasyGA)](https://github.com/danielwilczak101/EasyGA)—这是另一个具有几个内置遗传算子的Python遗传算法库，如选择、交叉和变异。EasyGA和Pyevolve是功能较少、预定义问题较少的简单库，与DEAP和Pymoo等其他库相比。'
- en: '[MEAPLY](https://mealpy.readthedocs.io/en/latest/index.html)—This is a Python
    library for population metaheuristic algorithms.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MEAPLY](https://mealpy.readthedocs.io/en/latest/index.html)—这是一个用于种群元启发式算法的Python库。'
- en: '[swarmlib](https://pypi.org/project/swarmlib/)—This library implements several
    swarm optimization algorithms and visualizes their (intermediate) solutions.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[swarmlib](https://pypi.org/project/swarmlib/)—这个库实现了几个群优化算法，并可视化它们的（中间）解决方案。'
- en: '[Hive](https://rwuilbercq.github.io/Hive/)—This is a swarm-based optimization
    algorithm based on the intelligent foraging behavior of honeybees. Hive implements
    the artificial bee colony (ABC) algorithm.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Hive](https://rwuilbercq.github.io/Hive/)—这是一个基于蜜蜂智能觅食行为的群优化算法。Hive实现了人工蜂群（ABC）算法。'
- en: '[Pants](https://aco-pants.readthedocs.io/en/latest/)—This is a Python3 implementation
    of the ant colony optimization (ACO) metaheuristics.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Pants](https://aco-pants.readthedocs.io/en/latest/)—这是一个Python3实现的蚁群优化（ACO）元启发式方法。'
- en: '[mlrose](https://mlrose.readthedocs.io/en/stable/index.html)—This library provides
    implementations of hill climb, random hill climb, simulated annealing, and genetic
    algorithm.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[mlrose](https://mlrose.readthedocs.io/en/stable/index.html)—这个库提供了爬山法、随机爬山法、模拟退火和遗传算法的实现。'
- en: Mixed integer distributed ant colony optimization ([MIDACO](http://www.midaco-solver.com/index.php/about))—This
    is a numerical high-performance library based on ACO for solving single- and multi-objective
    optimization problems.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合整数分布式蚁群优化 ([MIDACO](http://www.midaco-solver.com/index.php/about))—这是一个基于蚁群算法的数值高性能库，用于解决单目标和多目标优化问题。
- en: '[cuOpt](https://www.nvidia.com/en-us/ai-data-science/products/cuopt/): This
    is a Python SDK and cloud service provided by NVIDIA that provides access to GPU-accelerated
    logistics solvers relying on metaheuristics to calculate complex vehicle routing
    problems with a wide range of constraints.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[cuOpt](https://www.nvidia.com/en-us/ai-data-science/products/cuopt/)：这是由NVIDIA提供的Python
    SDK和云服务，它提供了访问基于元启发式计算复杂车辆路径问题的GPU加速物流求解器的权限，这些问题具有广泛的约束条件。'
- en: “[Listing A.3_Metaheuristics_libraries.ipynb](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.3_Metaheuristics_libraries.ipynb),”
    included in the book’s GitHub repo, shows how to use some of these metaheuristics
    libraries.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: “[列表A.3_Metaheuristics_libraries.ipynb](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.3_Metaheuristics_libraries.ipynb)”
    包含在本书的GitHub存储库中，展示了如何使用这些元启发式库的一些方法。
- en: A.5 Machine learning libraries
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.5 机器学习库
- en: Machine learning can be used to solve discrete optimization problems where an
    ML model is trained to output solutions directly from the input, usually represented
    as a graph. To train the model, the problem graph needs to be turned first into
    a feature vector using graph embedding/representation learning methods. Several
    Python libraries can be used for graph embedding and for solving optimization
    problems. The following subsections shed some light on the commonly used libraries.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习可以用于解决离散优化问题，其中ML模型被训练以直接从输入输出解决方案，通常表示为图。为了训练模型，问题图需要首先使用图嵌入/表示学习方法转换为特征向量。可以用于图嵌入和解决优化问题的Python库有多个。以下小节将介绍一些常用的库。
- en: A.5.1 node2vec
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.5.1 node2vec
- en: '[node2vec](https://snap.stanford.edu/node2vec/) is an algorithmic framework
    for learning low-dimensional representations of nodes in a graph. Given any graph,
    it can learn continuous feature representations for the nodes, which can then
    be used for various downstream ML tasks.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[node2vec](https://snap.stanford.edu/node2vec/) 是一个用于学习图节点低维表示的算法框架。对于任何图，它都可以学习节点的连续特征表示，这些表示可以用于各种下游ML任务。'
- en: 'To install node2vec, use the following command:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装node2vec，请使用以下命令：
- en: '[PRE43]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Alternatively, you can install node2vec by cloning the repository from GitHub
    and running the setup.py file:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过从GitHub克隆存储库并运行setup.py文件来安装node2vec：
- en: '[PRE44]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The following code illustrates how to use node2vec to learn low-dimensional
    representations of nodes in a graph based on Zachary’s karate club dataset. This
    is a graph-based dataset commonly used in network analysis and graph-based machine
    learning algorithms. It represents a social network that contains information
    about the relationships between 34 individuals in a karate club. It was created
    and first described by Wayne W. Zachary in his paper “An Information Flow Model
    for Conflict and Fission in Small Groups” in 1977, and it has since become a popular
    benchmark dataset for evaluating graph-based machine learning algorithms.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何使用node2vec根据Zachary的空手道俱乐部数据集学习图节点的低维表示。这是一个在网络安全分析和基于图的机器学习算法中常用的基于图的数据库。它代表了一个包含34个空手道俱乐部成员之间关系信息的社会网络。它由Wayne
    W. Zachary在1977年撰写的论文“An Information Flow Model for Conflict and Fission in Small
    Groups”中创建并首次描述，并自那时起成为评估基于图的机器学习算法的流行基准数据集。
- en: Listing A.4 A node2vec example
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.4 node2vec示例
- en: '[PRE45]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ① Create a sample graph
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个示例图
- en: ② Create an instance of the Node2Vec class.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建Node2Vec类的实例。
- en: ③ Learn the representations.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 学习表示。
- en: ④ Get the representations of all nodes.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 获取所有节点的表示。
- en: ⑤ Get the representations of a specific node.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 获取特定节点的表示。
- en: ⑥ Print the representations of a specific node.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 打印特定节点的表示。
- en: 'You can visualize the generated low-dimensional representations using a dimensionality
    reduction technique such as t-SNE to project the representations onto a 2D or
    3D space, and then use a visualization library such as Matplotlib to plot the
    nodes in this space. t-distributed stochastic neighbor embedding (t-SNE) is a
    statistical method for visualizing high-dimensional data by giving each data point
    a location in a 2D or 3D map. Here is an example:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用t-SNE等降维技术将生成的低维表示可视化，将表示投影到2D或3D空间，然后使用Matplotlib等可视化库来绘制该空间中的节点。t-distributed
    stochastic neighbor embedding (t-SNE) 是一种统计方法，通过在2D或3D地图中为每个数据点指定一个位置来可视化高维数据。以下是一个示例：
- en: '[PRE46]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ① Import the required libraries.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入所需的库。
- en: ② Perform t-SNE dimensionality reduction.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ② 执行t-SNE降维。
- en: ③ Plot the nodes.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 绘制节点。
- en: Running this code gives the visualization in figure A.4.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/APPA_F04_Khamis.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: Figure A.4 t-SNE-based visualization for the low-dimensional representations
    generated by node2vec
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: A.5.2 DeepWalk
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DeepWalk is a random walk-based method for graph embedding based on representation
    learning. For this example, we’ll use a DeepWalk module provided by the [Karate
    Club](https://karateclub.readthedocs.io/en/latest/) library. This library is an
    unsupervised machine learning extension for NetworkX. To use DeepWalk, you can
    install Karate Club as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following continuation of listing A.4 illustrates how to use DeepWalk:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ① Import DeepWalk. node2vec is also available.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: ② Import principal component analysis (PCA).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: ③ Create the Karate Club graph.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: ④ Define the DeepWalk mode, and fit the graph.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Graph embedding.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Retrieve the club membership attribute of each node.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Define the DeepWalk mode, and fit the graph.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Visualize the embedding.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: A.5.3 PyG
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PyG](https://www.pyg.org/) (PyTorch Geometric) is a library for implementing
    graph neural networks in Python using the PyTorch deep learning framework. It
    provides tools for defining, training, and evaluating graph neural network (GNN)
    models, as well as for visualizing the optimization process. PyG supports a variety
    of GNN architectures, including graph convolutional network (GCN) and graph attention
    networks (GATs).'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install PyG as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following continuation of listing A.4 shows how you can use PyG to generate
    Karate Club graph embedding using GCN:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ① Use the Karate Club dataset.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: ② Graph Convolutional Network class
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: ③ Apply a final (linear) classifier.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: ④ Final GNN embedding space
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: ⑤ Define the model.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: ⑥ Define the loss criterion.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: ⑦ Define an optimizer and clear gradient.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: ⑧ Perform a single forward pass.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: ⑨ Compute the loss solely based on the training nodes.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: ⑩ Derive the gradients.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: ⑪ Update the parameters based on the gradients.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: ⑫ Convert 'h' from tenser format to the numpy format for visualizing.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: ⑬ Visualize the embedding.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: PyG is a well-supported library that provides several features, such as common
    benchmark datasets (e.g., KarateClub, CoraFull, Amazon, Reddit, Actor), data handling
    of graphs, mini-batches, data transforms, and learning methods on graphs (e.g.,
    node2vec, MLP, GCN, GAT, GraphSAGE, GraphUNet, DeepGCNLayer, GroupAddRev, and
    MetaLayer).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: A.5.4 OpenAI Gym
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[OpenAI Gym](https://github.com/openai/gym) is a toolkit for developing and
    comparing reinforcement learning algorithms. It gives you access to variety of
    environments, such as'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '*Classic control*—A variety of classic control tasks'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Box2d*—A 2D physics engine'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MuJoCo*—A physics engine that can do detailed, efficient simulations with
    contacts'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Algorithmic*—A variety of algorithmic tasks, such as learning to copy a sequence'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Atari*—A variety of Atari video games'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*gym-maze*—A simple 2D maze environment where an agent finds its way from the
    start position to the goal'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Gymnasium](https://gymnasium.farama.org/) is a maintained fork of OpenAI’s
    Gym library. The following continuation of listing A.4 illustrates how to use
    OpenAI Gym:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[Gymnasium](https://gymnasium.farama.org/) 是 OpenAI 的 Gym 库的维护分支。以下列表 A.4 的延续说明了如何使用
    OpenAI Gym：'
- en: '[PRE51]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ① Install all included environments.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ① 安装所有包含的环境。
- en: ② Create an environment.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个环境。
- en: In this simple example, `MountainCar-v0` has discrete actions. You can also
    use `MountainCarCoutinous``-V0`, which has continuous actions corresponding to
    the force with which the car is pushed. The complete code listing is available
    in the book’s GitHub repo, in “[Listing A.4_ML_libraries.ipynb](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.4_ML_libraries.ipynb)”.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，`MountainCar-v0` 有离散的动作。你也可以使用 `MountainCarCoutinous-V0`，它具有与汽车被推的力相对应的连续动作。完整的代码列表可在本书的
    GitHub 仓库中找到，在 “[列表 A.4_ML_libraries.ipynb](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.4_ML_libraries.ipynb)”。
- en: A.5.5 Flow
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.5.5 流
- en: '[Flow](https://flow-project.github.io/) is a deep reinforcement learning framework
    for mixed autonomy traffic. It allows you to run deep RL-based control experiments
    for traffic microsimulation.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '[Flow](https://flow-project.github.io/) 是一个用于混合自主交通的深度强化学习框架。它允许你运行基于深度强化学习的交通微观模拟控制实验。'
- en: 'You can install Flow as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下步骤安装 Flow：
- en: '[PRE52]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Install Flow within the environment:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在环境中安装 Flow：
- en: '[PRE53]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Flow enables studying complex, large-scale, and realistic multirobot control
    scenarios. It can be used to develop controllers that optimize the system-level
    velocity or other objectives in the presence of different types of vehicles, model
    noise, and road networks such as single-lane circular tracks, multi-lane circular
    tracks, figure-eight networks, loops with merge networks, and intersections.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Flow 可以用于研究复杂、大规模和现实的多机器人控制场景。它可以用来开发在不同类型的车辆、模型噪声和道路网络（如单车道环形轨道、多车道环形轨道、八字形网络、合并网络和交叉路口）存在的情况下优化系统级速度或其他目标的控制器。
- en: A.5.6 Other libraries
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.5.6 其他库
- en: 'The following is a non-exhaustive list of other useful ML libraries:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是非详尽的其它有用机器学习库列表：
- en: '[Deep Graph Library (DGL)](https://www.dgl.ai/)—A library for implementing
    graph neural networks in Python. It provides tools for defining, training, and
    evaluating GNN models, as well as for visualizing the optimization process. DGL
    supports a variety of GNN architectures, including GCN and GAT.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[深度图库 (DGL)](https://www.dgl.ai/)—一个用于在 Python 中实现图神经网络的库。它提供了定义、训练和评估 GNN
    模型以及可视化优化过程的工具。DGL 支持多种 GNN 架构，包括 GCN 和 GAT。'
- en: '[Stanford Network Analysis Platform (SNAP)](https://github.com/snap-stanford/snap)—A
    general-purpose, high-performance system for the analysis and manipulation of
    large, complex networks. SNAP includes a number of algorithms for network analysis,
    such as centrality measures, community detection, and graph generation. It is
    particularly well-suited for large-scale network analysis and is used in a variety
    of fields, including computer science, physics, biology, and social science.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[斯坦福网络分析平台 (SNAP)](https://github.com/snap-stanford/snap)—一个用于分析和操作大型、复杂网络的通用、高性能系统。SNAP
    包含了网络分析的一系列算法，如中心性度量、社区检测和图生成。它特别适合大规模网络分析，并在计算机科学、物理学、生物学和社会科学等多个领域得到应用。'
- en: '[Spektral](https://graphneural.network/)—An open-source Python library for
    graph neural networks (GNNs) built on top of TensorFlow and Keras. It is designed
    to make it easy to implement GNNs in research and production. It provides a high-level,
    user-friendly API for building GNNs, as well as a number of prebuilt layers and
    models for common tasks in graph deep learning. The library also includes utilities
    for loading and preprocessing graph data and for visualizing and evaluating the
    performance of GNNs.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Spektral](https://graphneural.network/)—一个基于 TensorFlow 和 Keras 的开源 Python
    库，用于构建图神经网络 (GNNs)。它旨在使在研究和生产中实现 GNNs 变得容易。它提供了一个高级、用户友好的 API 用于构建 GNNs，以及用于图深度学习常见任务的预构建层和模型。该库还包括用于加载和预处理图数据以及可视化评估
    GNNs 性能的实用工具。'
- en: '[Jraph](https://github.com/deepmind/jraph) (pronounced “giraffe”)—A lightweight
    library for working with graph neural networks that also provides lightweight
    data structure for working with graphs. You can easily work with this library
    to construct and visualize your graph.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Jraph](https://github.com/deepmind/jraph)（发音为“giraffe”）—一个用于处理图神经网络的轻量级库，同时也提供了用于处理图的轻量级数据结构。你可以轻松地使用这个库来构建和可视化你的图。'
- en: '[GraphNets](https://github.com/deepmind/graph_nets)—A library for implementing
    GNNs in Python. It provides tools for defining, training, and evaluating GNN models,
    as well as for visualizing the optimization process. GraphNets supports a variety
    of GNN architectures, including GCN and GAT.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GraphNets](https://github.com/deepmind/graph_nets)—一个用于在Python中实现图神经网络（GNN）的库。它提供了定义、训练和评估GNN模型以及可视化优化过程的工具。GraphNets支持多种GNN架构，包括GCN和GAT。'
- en: '[Stable-Baselines3 (SB3)](https://stable-baselines3.readthedocs.io/en/master/)—A
    set of reliable implementations of reinforcement learning algorithms in PyTorch.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stable-Baselines3 (SB3)](https://stable-baselines3.readthedocs.io/en/master/)—PyTorch中强化学习算法的一组可靠实现。'
- en: '[Vowpal Wabbit (VW)](https://vowpalwabbit.org/index.html)—An open source ML
    library specifically designed for large-scale online learning. Developed originally
    at Yahoo Research, and currently at Microsoft Research, it is widely used for
    solving reductions and contextual bandits problems.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Vowpal Wabbit (VW)](https://vowpalwabbit.org/index.html)—一个专门为大规模在线学习设计的开源机器学习库。最初由Yahoo
    Research开发，目前由Microsoft Research开发，广泛用于解决减少和上下文赌博问题。'
- en: '[Ray RLlib](https://docs.ray.io/en/latest/rllib/index.html)—An open source
    library for RL, offering support for production-level, highly distributed multi-agent
    RL workloads while maintaining unified and simple APIs for a large variety of
    industry applications.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ray RLlib](https://docs.ray.io/en/latest/rllib/index.html)—一个开源的强化学习库，为生产级、高度分布式的多智能体强化学习工作负载提供支持，同时为各种行业应用保持统一和简单的API。'
- en: '[TF-Agents](https://www.tensorflow.org/agents)—A library for developing RL
    algorithms in TensorFlow, which includes a collection of environments, algorithms,
    and tools for training RL agents.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TF-Agents](https://www.tensorflow.org/agents)—一个用于在TensorFlow中开发强化学习算法的库，其中包括一系列环境、算法和用于训练强化学习智能体的工具。'
- en: '[Keras-RL](https://github.com/keras-rl/keras-rl)—A deep reinforcement learning
    library built on top of Keras. It provides an easy-to-use interface for developing
    and testing RL algorithms. Keras-RL supports a variety of RL algorithms such as
    deep Q-networks (DQN) and actor-critic methods. There are also built-in environments
    for testing RL algorithms.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Keras-RL](https://github.com/keras-rl/keras-rl)—一个基于Keras构建的深度强化学习库。它提供了一个易于使用的接口来开发和测试强化学习算法。Keras-RL支持多种强化学习算法，如深度Q网络（DQN）和演员-评论家方法。还包括用于测试强化学习算法的内置环境。'
- en: '[pyqlearning](https://github.com/accel-brain/accel-brain-code/tree/master/Reinforcement-Learning)—A
    Python library to implement reinforcement learning and deep reinforcement learning,
    especially for Q-learning, deep Q-network, and multi-agent deep Q-network, which
    can be optimized by annealing models such as simulated annealing, adaptive simulated
    annealing, and quantum Monte Carlo method.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pyqlearning](https://github.com/accel-brain/accel-brain-code/tree/master/Reinforcement-Learning)—一个Python库，用于实现强化学习和深度强化学习，特别是针对Q学习、深度Q网络和多智能体深度Q网络，可以通过退火模型如模拟退火、自适应模拟退火和量子蒙特卡洛方法进行优化。'
- en: '[Python Optimal Transport (POT)](https://pythonot.github.io/)—An open source
    Python library providing several solvers for optimization problems related to
    optimal transport for signals, image processing, and machine learning.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python Optimal Transport (POT)](https://pythonot.github.io/)—一个开源的Python库，提供了解决与信号、图像处理和机器学习相关的最优传输优化问题的多个求解器。'
- en: The “[Listing A.4_ML_libraries.ipynb](https://github.com/Optimization-Algorithms-Book/Code-Listings/blob/main/Appendix%20A/Listing%20A.4_ML_libraries.ipynb)”
    notebook available in the book’s GitHub repo provides examples of how to install
    and use some of these libraries.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍GitHub仓库中可用的“A.6 项目”笔记本提供了如何安装和使用这些库的一些示例。
- en: A.6 Projects
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.6 项目
- en: 'My course “ECE1724H: Bio-inspired Algorithms for Smart Mobility,” at the University
    of Toronto, features a collection of exemplary projects available in the “AI for
    Smart Mobility (AI4SM)” publication hub ([https://medium.com/ai4sm](https://medium.com/ai4sm))
    with Python code implementations. These projects encompass a broad spectrum of
    optimization algorithms covered in this book and their practical applications
    in the smart mobility domain. Among the topics tackled are'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我在多伦多大学的课程“ECE1724H：智能移动的生物启发算法”，在“AI for Smart Mobility (AI4SM)”出版中心提供了大量示例项目（[https://medium.com/ai4sm](https://medium.com/ai4sm)），其中包含Python代码实现。这些项目涵盖了本书中涉及的各种优化算法及其在智能移动领域的实际应用。其中涉及的主题包括
- en: Employing large language models for reinforcement learning in intelligent driving
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在智能驾驶中采用大型语言模型进行强化学习
- en: Forecasting traffic flows
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测交通流量
- en: Strategizing the placement of EV charging stations
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定电动汽车充电站布局策略
- en: Optimizing food delivery services
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化食品配送服务
- en: Predicting estimated times of arrival
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测预计到达时间
- en: Improving the deployment of traffic sensors
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进交通传感器的部署
- en: Customizing cycling routes
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制骑行路线
- en: Reorganizing urban fire districts
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重组城市消防区域
- en: Pricing strategies for ride-sharing
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享出行定价策略
- en: Refining school bus routes
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精细学校巴士路线
- en: Availability predictions for bikes
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自行车可用性预测
- en: Districting for efficient waste collection
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为高效垃圾收集划区
- en: Enhancing bus stop layouts
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升公交车站布局
- en: Implementing dynamic pricing for public transportation
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施公共交通动态定价
- en: Optimizing student transportation and boarding
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化学生交通和住宿
- en: Integrating hotel recommendations with route planning
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将酒店推荐与路线规划整合
- en: Determining ideal locations for public parcel lockers
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定公共包裹柜的理想位置
- en: Predictive responses and accessibility scoring for healthcare facilities
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 医疗设施的健康响应和可达性评分预测
