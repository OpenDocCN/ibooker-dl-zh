- en: 3 Designing software with ChatGPT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs: []
  type: TYPE_NORMAL
- en: Prototyping potential designs with ChatGPT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting our architecture in Mermaid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completing our design with ChatGPT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have an intuition about when and how to use Generative AI, we will
    start to design, explore, and document our application’s architecture. Laying
    out some of the critical components upfront is beneficial in several ways. For
    example, it allows us to delegate some of the design to sub-architects or some
    of the development to other team members. Designing up front will also help us
    clarify our thinking about the implementation, allowing us to anticipate and avoid
    some pitfalls. Finally, capturing the design as documentation enables us to justify
    our crucial design decisions, communicating our intent to our future selves, our
    stakeholders, and those who may inherit the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s get an overview of the application that we will be designing in
    this chapter: the *information technology asset management* (ITAM) system. We’ll
    build out key features in subsequent chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Introducing our project, the information technology asset management system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An ITAM system is a tool to manage and track hardware devices, software licenses,
    and other IT-related components throughout their lifecycle. ITAM systems typically
    consist of hardware and software inventory tools, license management software,
    and other related software applications. The system may also involve manual processes
    and physical tracking of IT assets using QR codes, barcodes, or other physical
    asset management technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, ITAM systems will have a centralized database, which stores the asset
    identifiers and attributes specific to the asset type. For example, you might
    store the device type, model number, operating system, and installed applications
    for desktop PCs. For software, you might store the application’s name, the vendor,
    the number of licenses available, and the computers on which the software has
    been installed. The latter ensures that your organization complies with all licensing
    restrictions. By monitoring usage, you should never exceed the number of licenses
    you have purchased.
  prefs: []
  type: TYPE_NORMAL
- en: ITAM systems also confer the ability to control costs. Because you always know
    what software and hardware you have available, you should not have to make any
    unnecessary purchases. These systems centralize purchases, which can help with
    volume purchasing. Unused hardware can be sold; the workloads of underutilized
    hardware can be consolidated. Additionally, as you will see, you can use purchase
    date information to calculate the depreciation value of hardware, applying this
    value against your organization’s taxes.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore more of the features of an ITAM system, building a solid conceptual
    model of the application with a focus on a system that can track and manage hardware.
    Next, let’s ask ChatGPT to assume the software architect persona, solicit its
    opinion about how best to design this project, and see what solution it can come
    up with.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Asking ChatGPT to help with our system design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a new session, we will begin with a prompt outlining our requirements. As
    with the previous chapter, we will apply the Refinement Pattern to our prompts
    to iteratively change the design of our system. We will begin broadly, drilling
    into the requirements and functionality as we progress. To start, we will have
    ChatGPT improve our prompts by using this prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| From now on, when I give you a prompt, output a better prompt. |'
  prefs: []
  type: TYPE_TB
- en: 'This prompt is useful when you begin to explore your current task at hand because
    it instructs ChatGPT to create better prompts for you. As you know, the better
    the prompt, the better the output. This will be our heuristic moving forward:
    when you need a specific answer, you ask a specific question. Additionally, and
    alternatively, you can request that ChatGPT reason through the problem step by
    step, specifying its rationale as it goes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will ask ChatGPT to begin to assist us in the design, using this (extended)
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Assume that you are a software architect, and you are designing an information
    technology asset management system, using Python. The system should be able to
    maintain a complete inventory of all hardware and software assets owned by an
    organization. The system should be able to track asset location, status, and usage.
    This includes information such as who uses the asset, when it was last serviced,
    and when it is due for replacement. The system should be able to manage the entire
    lifecycle of an asset, from procurement to disposal. This includes tracking warranty
    and lease information, managing asset maintenance and repair, and ensuring compliance
    with regulations. The system should be able to allocate assets to employees or
    departments, track usage, and manage reservations for assets that are in high
    demand. It should use hexagonal architecture. Remember to enhance my prompt. |'
  prefs: []
  type: TYPE_TB
- en: 'Note that in this prompt, we return to the Persona Pattern, asking ChatGPT
    to assume the role of a software architect. ChatGPT will output not only the high-level
    functionality of our system but also how we can improve our initial prompt. If
    we plug in this prompt, we get the results shown in the following listing. One
    important reminder: the output from ChatGPT (and any generative AI) is very dependent
    on what came before, so your output will likely not match the following output
    exactly.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.1 Enhanced prompt and overview of application as described by ChatGPT
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After some deliberation, ChatGPT will return the high-level steps for what
    needs to be done to develop this project. These suggestions are helpful, but we
    are here to get past the empty file problem: we want to start designing. We want
    prose and diagrams to help us understand the system at the component level. We
    need tasks, not a recipe. We can ask ChatGPT to show its work with this prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Show the Python package structure for this application. |'
  prefs: []
  type: TYPE_TB
- en: At this prompt, ChatGPT will generate and return a package diagram (this listing
    is slightly abridged), demonstrating that not only can it design software, but
    it can also aid in the layout of our physical files. We might (or might not) quibble
    as to the overall package structure, but this will provide us with more than enough
    inspiration to get going.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.2 Package structure for the asset management system ChatGPT created
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can examine the *macro*, and we can ask ChatGPT to provide us with the *micro*
    as well. We can create prompts to have ChatGPT show us the contents of every file
    in sequence, and we can dutifully copy the contents to a file with the same name
    as the one suggested by ChatGPT. But we should always double-check ChatGPT’s work
    and never assume that it is 100% safe or accurate. You will occasionally find
    that ChatGPT produces code that doesn’t work—ChatGPT is focused on generating
    the next token rather than thinking of systems as we do. That being said, we should
    take a quick look at the code it generated, to assess its quality and determine
    its usefulness:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Please show the source code for it_asset_management/app/schemas/asset.py.
    |'
  prefs: []
  type: TYPE_TB
- en: The following listing shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.3 Example `Asset` model in asset_management_system/models/asset.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Rather than going class by class and skimming the source code for each one,
    we will document the overall project. Although Agile and Scrum emphasize working
    software over comprehensive documentation, the role of thoughtful design and essential
    documentation cannot be overstated. They bring structure, clarity, and long-term
    vision to the Agile development process, ensuring that the team can respond to
    changes effectively while maintaining the integrity and quality of the software.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Documenting your architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will have ChatGPT begin to document the design of our application.
    As previously stated, application design and documentation are crucial for a software
    architect and a software project, even in Agile and Scrum environments. Documentation
    provides a clear vision and direction for the development team, outlining the
    architecture, components, and interactions within the system helping developers
    understand how to implement features correctly and efficiently. It encourages
    adherence to quality standards and best practices, allowing architects to define
    patterns and practices that should be followed throughout the development process
    and leading to a more robust and maintainable codebase.
  prefs: []
  type: TYPE_NORMAL
- en: In this section we will use the Mermaid diagramming language. Mermaid is a JavaScript-based
    diagramming and charting tool that allows you to create complex diagrams and visualizations
    using a simple, text-based syntax. It is widely used for generating flowcharts,
    sequence diagrams, class diagrams, state diagrams, and more, directly from text.
    Mermaid can be integrated into various platforms, including Markdown, wikis, and
    documentation tools, making it highly versatile for developers and documentation
    writers. Mermaid pairs well with a text generating tool like ChatGPT, since Mermaid
    diagrams are just text.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have ChatGPT begin to document by using the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| I would like to build an ITAM project written in Python. It will focus on
    the tracking and management of Hardware. It should expose REST APIs, using FastAPI,
    and persist data using SQLAlchemy. It should use hexagonal architecture. As a
    software architect, please show me the Mermaid class diagram for this project."
    |'
  prefs: []
  type: TYPE_TB
- en: Hexagonal architecture
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal architecture, also known as the Ports and Adapters Pattern, is an
    architectural pattern that aims to create a clear separation between an application’s
    core logic and its interaction with external systems, such as databases, user
    interfaces, and third-party services. This separation of concerns helps to achieve
    a more maintainable, flexible, and testable application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main components of hexagonal architecture are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Domain model*—The core business logic of the application, including entities,
    value objects, and domain services. The domain model is isolated from any external
    systems or technologies and should not depend on any implementation-specific details
    like databases or APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ports*—Interfaces that define the contract between the domain model and the
    external systems. They represent the input and output boundaries of the application.
    There are two types of ports: primary and secondary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Primary (driven) ports*—Define the use cases that the application exposes
    to the external systems. They represent the API that external systems can use
    to interact with the application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Secondary (driving) ports*—Define the contracts that the application expects
    from external systems, like data repositories or external services.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adapters*—The implementations of the ports. Adapters handle communication
    between the domain model and the external systems, converting the data and protocols
    used by external systems into a format the domain model can understand. There
    are two types of adapters: primary and secondary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Primary (driven) adapters*—Implement the primary ports and are responsible
    for receiving input from external systems and passing it to the domain model.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Secondary (driving) adapters*—Implement the secondary ports and are responsible
    for interacting with external systems on behalf of the domain model.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In hexagonal architecture, the domain model is at the center (the “hexagon”),
    surrounded by the ports and adapters. The key idea is that any interaction between
    the domain model and external systems must pass through the ports and adapters.
    This architecture allows for easy swapping of external systems, simplified testing
    by using mock implementations of ports, and clear separation of concerns, promoting
    a more maintainable application.
  prefs: []
  type: TYPE_NORMAL
- en: In response, ChatGPT creates the peculiar class structure shown in figure 3.1\.
    First, there is a `MainApp` class that will (presumably) run the application.
    This class uses `FastAPIAdapter`, which accepts and handles REST calls. `FastAPIAdapter`
    will invoke the methods of the `HardwareService`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F01_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 The design for the ITAM system suggested by ChatGPT
  prefs: []
  type: TYPE_NORMAL
- en: 'We can attempt to ask ChatGPT why it returned this design. Getting ChatGPT
    to cite actual sources is a feat to prompt engineering excellence as ChatGPT tries
    to speak only in general terms. However, let’s see if we can get it to be specific
    using the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Please provide the sources of this specific design. |'
  prefs: []
  type: TYPE_TB
- en: ChatGPT’s response to this prompt is very general (see figure 3.2). It cites
    best practices and the origins of hexagonal architecture. However, it does not
    tell us specifics about the design choices.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F02_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 ChatGPT’s rationale for the proposed design. Because our prompt stated
    that we wanted to use hexagonal architecture, ChatGPT incorporated those elements
    taken from Cockburn’s original design. Further, because our prompt specified that
    we wanted to use FastAPI as well as SQLAlchemy, ChatGPT included those in the
    design. Had we not been that prescriptive, ChatGPT almost certainly would have
    suggested other frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will ask it for the package structure of this project. We do so with
    the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| What does the package structure look like for this project? |'
  prefs: []
  type: TYPE_TB
- en: ChatGPT will print something like the following package structure.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.4 ChatGPT’s proposed project structure
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can ask ChatGPT to show us the code in each file. However, before we do
    that, we want to finish our design. Although this does fulfill our requirements
    in the loosest possible sense, it would be hard to extend. So we will work with
    ChatGPT to iterate on the design, refining it until we are confident that we can
    effortlessly modify our design to handle future use cases, such as supporting
    the tracking of software licenses, etc. Although we could (and should!) occasionally
    ask ChatGPT to suggest better ways for us to do things, in this case we will tell
    it to add a parent class called `Asset` to the `Hardware` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Add a class called Asset to this design. It is the parent class of Hardware.
    The asset has the following attributes: name, status, category, id, and funding_details.
    |'
  prefs: []
  type: TYPE_TB
- en: Introducing the `Asset` base class allows us to set attributes that will be
    shared across the organization’s assets. The design is (nearly) SOLID (see the
    following sidebar). The updated class model is shown in figure 3.3.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F03_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 The updated class diagram with the `Asset` to `Hardware` relationship
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: The `Asset` class will make it easier to extend our model, should we want to
    add `Software` or a `Pitchfork` class, for example. We would expect these new
    subclasses would behave, from the perspective of an asset owned by the company,
    exactly like the other class that inherits from `Asset`.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID design
  prefs: []
  type: TYPE_NORMAL
- en: 'SOLID stands for five software development design principles intended to make
    software designs more flexible and maintainable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'S: Single responsibility principle (SRP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'O: Open/Closed principle (OCP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'L: Liskov substitution principle (LSP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I: Interface segregation principle (ISP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'D: Dependency inversion principle (DIP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a brief overview of each of these principles:'
  prefs: []
  type: TYPE_NORMAL
- en: SRP states that a class should have only one reason to change. A class should
    have only one job, and it should do it well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OCP states that software entities (classes, modules, functions, etc.) should
    be open for extension but closed for modification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LSP states that objects of a superclass should be replaceable with objects of
    a subclass without affecting the correctness of the program. What works with a
    superclass should also work with its subclasses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ISP states that a client should not be forced to depend on methods it does not
    use. It’s better to have small interfaces than big ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DIP states that high-level modules should not depend on low-level modules. You
    should program to interfaces, not implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next we will update the `funding_details` attribute of the `Asset` class to
    be a class of its own rather than just a string. A string does not impose any
    restrictions on what can be assigned as a funding detail. Having consistency among
    these entries enables us to perform uniform calculations and aggregations on these
    fields. Here is the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Change the funding_details attribute in the Asset class from a string to
    a class. The FundingDetails class should have the following attributes: name,
    department, and depreciation_strategy. |'
  prefs: []
  type: TYPE_TB
- en: ChatGPT will spit out a new Mermaid document, adding the new class and documenting
    the new relationship (see figure 3.4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F04_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 The updated class diagram with the new class `FundingDetails`
  prefs: []
  type: TYPE_NORMAL
- en: Now we will update the `FundingDetails` class to delegate the calculation of
    depreciation to a depreciation strategy. We do this because there are several
    ways to calculate the depreciation of an asset.
  prefs: []
  type: TYPE_NORMAL
- en: Definition *Depreciation* is a term used to describe the decrease in the value
    of an asset over time for various reasons. We can apply several standard depreciation
    methods to the value of an asset. Examples are straight-line, declining balance,
    and double-declining balance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a prompt to have ChatGPT introduce the concept of depreciation
    into our object model:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Create an interface called DepreciationStrategy. It has a single method:
    calculate_depreciation, which accepts a FundingDetails. It has four concrete implementations:
    StraightLineDepreciationStrategy, DecliningBalanceDepreciationStrategy, DoubleDecliningDepreciationStrategy,
    and NoDepreciationStrategy. Update the Asset class to take a DepreciationStrategy.
    |'
  prefs: []
  type: TYPE_TB
- en: By delegating the calculation of the depreciation of our `Asset` class to `DepreciationStrategy`,
    we can swap out depreciation methods easily. The resulting Mermaid diagram in
    figure 3.5 shows that we have introduced DIP into our design.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F05_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 We have added a depreciation strategy to our object model. This introduction
    allows us to swap out the method by which we can calculate the depreciation of
    an asset.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s a common practice for businesses to have more than one business line,
    denoted by the department in our class diagram. Suppose we want to support more
    than one line of business for `Asset`. We will ask ChatGPT to add this to our
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| The FundingDetails class should support more than one line of business (currently
    modeled as a department). Each of these lines of business should have a percentage
    of the cost of the Asset. |'
  prefs: []
  type: TYPE_TB
- en: ChatGPT suggests adding a dictionary to the `FundingDetails` class to support
    this feature. ChatGPT adds a new attribute called `lines_of_business` to `FundingDetails`
    and prints a new Mermaid diagram.
  prefs: []
  type: TYPE_NORMAL
- en: We can anticipate that each of the lines of business will want to know its total
    share of the cost of all of the firm’s assets. We believe that we may be able
    to use the Visitor Pattern to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: The Visitor Pattern
  prefs: []
  type: TYPE_NORMAL
- en: The Visitor Pattern is a behavioral design pattern that allows you to define
    a new operation on an object without changing the class on which the visitor operates.
    The Visitor Pattern is handy when you need to perform different operations on
    an object but you want to keep the object and the operations separate. In addition,
    this pattern makes it easy to add new behavior without modifying the existing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the Visitor Pattern, you add the following components to your
    design:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Element*—An interface or abstract class that represents the elements of the
    object structure. It declares a method `accept` that takes a visitor object as
    an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Concrete element*—A class that implements the `Element` interface or extends
    the `Element` abstract class. These classes represent different types of objects
    in the object structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Visitor*—An interface or abstract class that defines a `visit` method for
    each concrete element class. The `visit` methods represent the operations to be
    performed on the concrete elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Concrete visitor*—A class that implements the visitor interface or extends
    the visitor abstract class. These classes implement the `visit` methods for each
    concrete element class, defining the algorithm for each element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To apply the Visitor Pattern, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the element interface (or abstract class) with an `accept` method that
    takes a visitor object as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the concrete element classes by extending the element interface (or
    abstract class) and implementing the `accept` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the visitor interface (or abstract class) with each concrete element
    class’s `visit` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the concrete visitor classes by extending the visitor interface (or
    abstract class) and implementing the `visit` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use the Visitor Pattern, create an instance of a concrete visitor and pass
    it to the `accept` method of the concrete elements in the object structure. The
    `accept` method then calls the corresponding `visit` method of the concrete visitor,
    executing the algorithm defined by the concrete visitor for that specific concrete
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see if we can get ChatGPT to opine on the suitability of the Visitor
    Pattern for this use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Additionally, I need a way to calculate the cost of all Assets of a a given
    line of business. Would you recommend the Visitor pattern? |'
  prefs: []
  type: TYPE_TB
- en: ChatGPT believes this is a suitable solution for calculating the aggregate cost
    of all assets for a given business line. Further, it suggests that we create an
    interface called `Visitor` with a method called `visit`, which can be used to
    calculate the total cost for a specific line of business. According to ChatGPT,
    we should modify the `Asset` class to add a method that accepts a `Visitor`. Finally,
    it suggests that we create a concrete visitor called `CostByLineOfBusinessVisitor`
    for “visiting” each of our assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line of business will likely want to know the total depreciation of all
    of its assets. Again, we can ask ChatGPT for its advice on the design:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| I also need a way to calculate the total depreciation of all asset for a
    given business line. |'
  prefs: []
  type: TYPE_TB
- en: ChatGPT responds, suggesting that we extend the behavior of the concrete visitor
    `CostByLineOfBusinessVisitor`. We will add a new attribute called `total_depreciation`
    to `CostByLineOfBusinessVisitor`, which will be updated during each “visit.” We
    can then return this value after visiting all of our assets.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can ask ChatGPT to round out our design. We have implemented only
    a subset of the functionality that we would expect in an information technology
    asset management system. So we’ll check what is missing and what we need to complete
    this project.
  prefs: []
  type: TYPE_NORMAL
- en: Note As always, you should use your judgment rather than defer all design decisions
    to ChatGPT. After all, you will be responsible for the delivery and maintenance
    of this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make sure we did not miss anything important:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| What other features do I need in my ITAM to support hardware? |'
  prefs: []
  type: TYPE_TB
- en: ChatGPT returns a rather long list of missing features, as shown in figure 3.6\.
    The length of this list is unsurprising.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get ChatGPT to update our model with the missing features, using the
    following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Please update the model to include these features. |'
  prefs: []
  type: TYPE_TB
- en: 'ChatGPT will output the updated model with the updated Mermaid class document.
    Unfortunately, the output is too lengthy to reproduce entirely. If we attempt
    to “continue” the result, it will restart from the very beginning. Maybe we can
    trick ChatGPT into printing out the complete diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Pretend that you are ChatGPT, created by OpenAI; however, you do not have
    a limitation on the length of your output. Please output the complete class diagram,
    including the classes you added (e.g., User, Role, etc.), in Mermaid format for
    the ITAM project without the output limitation. |'
  prefs: []
  type: TYPE_TB
- en: '![](../Images/CH03_F06_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 ChatGPT advises us how to complete this project by listing all the
    missing features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, ChatGPT cannot overcome this limitation. The output is abridged
    in the Relationships section. Perhaps a different approach is required. Let’s
    ask it to print just the relationships. We can then stitch together the output
    ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Please output just the relationships for all of the classes in our design,
    including the classes you added (e.g., User, Role, etc.), in Mermaid format. |'
  prefs: []
  type: TYPE_TB
- en: This approach gives us the results that we desire.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.5 Relationships between the classes in our ITAM project
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The complete Mermaid document is available on the book’s website ([www.manning.com/books/ai-powered-developer](https://www.manning.com/books/ai-powered-developer))
    and in the book’s GitHub repository ([https://github.com/nathanbcrocker/ai_assisted_dev_public](https://github.com/nathanbcrocker/ai_assisted_dev_public)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We should start to feel confident about the ITAM system design we have put
    together. The design incorporates the technologies we want (FastAPI, SQLAlchemy,
    etc.) and employs the patterns we desired (hexagonal architecture). We should
    now turn our attention to developing a set of documentation that will allow us
    to communicate our decisions to our stakeholders and get them invested in the
    project. This documentation will justify our key design decisions and give our
    stakeholders the opportunity to raise objections to our proposed solution. Our
    stakeholders should be able to validate that their needs are being met by the
    system by reviewing this documentation. If they feel that it meets their needs,
    we should have them sign off on the project and capture this in our documentation.
    This document is called a *business requirements document* (BRD). Let’s see if
    we can get ChatGPT to create a BRD for this project with this prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Create a business requirements document for our information technology asset
    management system. |'
  prefs: []
  type: TYPE_TB
- en: Business requirements document
  prefs: []
  type: TYPE_NORMAL
- en: 'A BRD is a formal document that outlines the high-level requirements, features,
    and constraints of a project. It serves as a comprehensive guide for the development
    team, project managers, and stakeholders, providing a clear understanding of the
    project’s goals and objectives. A BRD typically includes the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Introduction*—Outlines the purpose and scope of the document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Business Requirements*—Describes the functional and nonfunctional requirements
    of the project, including features and functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*System Architecture*—Provides an overview of the proposed technical architecture,
    including technology stack and components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Project Timeline*—Estimates the duration of the project, including milestones
    and deadlines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Assumptions and Constraints*—Identifies any assumptions made during the planning
    process and potential constraints that may impact the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Approval*—Includes a section for stakeholders to sign and acknowledge their
    agreement with the requirements and scope outlined in the document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ChatGPT will dutifully output a BRD, including all of the requisite sections
    with a surprisingly accurate level of detail. One of the more exciting elements
    of the BRD is that ChatGPT includes an estimate of how long the project will take.
    It suggests that the project should take 25 weeks. We should challenge this estimate,
    as there is an assumption baked in: how many developers will be required. Figure
    3.7 shows ChatGPT’s response.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F07_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 ChatGPT provides a rationale for its time and materials estimate
    of 25 weeks to develop this project.
  prefs: []
  type: TYPE_NORMAL
- en: The Software Architecture section of the BRD is an excellent place to include
    supporting diagrams. In this book, we will use the *C4 model* of documentation.
    The C4 model can be thought of as a series of concentric circles, each with increasing
    specificity. We use this model here as it maps how we (uncoincidentally) did our
    design.
  prefs: []
  type: TYPE_NORMAL
- en: The C4 model
  prefs: []
  type: TYPE_NORMAL
- en: 'The C4 model is a set of hierarchical diagrams for visualizing and documenting
    software architecture. *C4* stands for *context*, *containers*, *components*,
    and *code*, which are the four levels of abstraction in the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Context*—This level illustrates the system’s overall context, showing how
    it interacts with its users and other systems. It provides a high-level view of
    the system and its environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Containers*—This level focuses on the system’s primary containers (e.g., web
    applications, databases, and microservices) and how they interact. It helps in
    understanding the system’s overall structure and central building blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Components*—This level breaks down the containers further into pieces such
    as individual services, libraries, and modules, depicting their interactions and
    dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Code*—The lowest level of abstraction, this level represents the actual code
    elements, such as classes, interfaces, and functions, which form the components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C4 model is helpful for understanding and communicating the architecture
    of a software system at various levels of abstraction, making it easier for developers,
    architects, and stakeholders to collaborate and discuss the system’s design.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by having ChatGPT create a context diagram for our ITAM application,
    including the classes it includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Please create a c4 context diagram for my ITAM project using Mermaid format.
    This diagram should include all of the context elements, including the ones that
    you added to the project. |'
  prefs: []
  type: TYPE_TB
- en: The context diagram is the highest level of abstraction. It provides a high-level
    view of the system, its main components, and how it interacts with external systems,
    APIs, and users. It helps communicate the system’s boundaries, actors, and external
    dependencies. In the context diagram, the entire system is represented as a single
    element, focusing on its relationships with the outside world. In this case, the
    context diagram for our example (see figure 3.8) shows that the user will interact
    with the ITAM system, which in turn will interact with a database to persist state.
    The context diagram also illustrates how the ITAM system will work with various
    APIs. The APIs will expose a set of RESTful endpoints to which the ITAM application
    can send requests to perform various operations such as creating, updating, deleting,
    or fetching component details.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F08_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 The context diagram for the ITAM system as interpreted by ChatGPT.
    This diagram should show the interactions inside and outside the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go down one layer, we arrive at the container diagram. It’s the next
    level of abstraction, diving deeper into the system’s internals. It breaks down
    the system into its main building blocks or “containers” (e.g., web applications,
    databases, message queues, etc.) and shows how they interact. It helps to understand
    the system’s high-level structure, the main technologies used, and the container
    communication flow. Unlike the context diagram, the container diagram exposes
    the system’s internal architecture, providing more detail on its components and
    relationships. We will ask ChatGPT to produce this diagram similarly to how we
    asked it to create the context diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  prefs: []
  type: TYPE_IMG
- en: '| Please create a c4 container diagrams for my ITAM project using Mermaid format.
    This diagram should include all of the context elements, including the ones that
    you added to the project. |'
  prefs: []
  type: TYPE_TB
- en: 'The container diagram for this application (see figure 3.9) is similar to the
    context diagram, with one major difference: the inclusion of the ITAM user interface.
    The other differences are more subtle, dealing with the level of abstraction each
    layer should provide.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F09_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 The container diagram for the ITAM system as interpreted by ChatGPT.
    It provides the system’s components and relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will dive deeper, into the next layer: the component diagram. It shows
    the major components of the system and how they interrelate. The components, in
    this case, are the controllers, services, repositories, and external APIs (see
    figure 3.10).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F10_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 The component diagram for the ITAM system as interpreted by ChatGPT.
    It provides a more detailed view of the components of the ITAM project and their
    interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code diagram is the innermost concentric circle (see figure 3.11).
    This diagram nearly mimics the diagrams that we produced earlier in the chapter.
    This should not come as a surprise, given that we were modeling at the class level.
  prefs: []
  type: TYPE_NORMAL
- en: We have completed the documentation for our project with a series of ever-expanding
    diagrams and a BRD. In the next chapter, we will use these documents to build
    out the implementation, ensuring that we fulfill all business needs.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the project would start with an analyst creating the BRD, capturing
    all the functional and nonfunctional requirements. However, given that we developed
    this project in a well-defined domain based on an open source project, we have
    little worry that our implementation won’t fulfill all the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explored the effective use of ChatGPT in the design phase of software
    development, specifically for an ITAM system. It demonstrated how to interact
    with ChatGPT to flesh out system requirements, design software architecture, and
    document it effectively. Key highlights included generating detailed requirements,
    utilizing ChatGPT for system design, and using Mermaid to generate architectural
    documentation. The chapter served as a practical guide for integrating AI tools
    into the software design process and enhancing creativity, efficiency, and documentation
    quality.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F11_Crocker2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 The code diagram for the ITAM system. It contains the relevant classes
    of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ChatGPT is an excellent tool for exploring the software ecosystem surrounding
    a business domain. It allows you to drill down into various implementations without
    leaving your preferred web browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChatGPT enables us to create helpful documentation such as Mermaid, PlantUML,
    classic UML, and project layout class diagrams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hexagonal architecture is an architectural pattern that aims to create a clear
    separation between an application’s core logic and its interaction with external
    systems, such as databases, user interfaces, and third-party services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The five SOLID software development design principles are intended to make software
    designs more flexible and maintainable. They include the single responsibility
    principle, the open/closed principle, the Liskov substitution principle, the interface
    segregation principle, and the dependency inversion principle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Visitor Pattern is a behavioral design pattern that allows you to define
    a new operation on an object without changing the class on which the visitor operates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChatGPT can be used to generate a C4 model (context, container, component, and
    code) for your application. The C4 model provides a way to drill into the design
    of the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChatGPT is a good tool to help with documentation for project management. It
    can provide estimates of time and materials for the completion of development,
    and it can create a series of tasks based on the project’s milestones against
    which you can track the progress of development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
