- en: 3 Designing software with ChatGPT
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 设计与ChatGPT的软件
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Prototyping potential designs with ChatGPT
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ChatGPT原型设计潜在的设计
- en: Documenting our architecture in Mermaid
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mermaid记录我们的架构
- en: Completing our design with ChatGPT
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ChatGPT完成我们的设计
- en: Now that we have an intuition about when and how to use Generative AI, we will
    start to design, explore, and document our application’s architecture. Laying
    out some of the critical components upfront is beneficial in several ways. For
    example, it allows us to delegate some of the design to sub-architects or some
    of the development to other team members. Designing up front will also help us
    clarify our thinking about the implementation, allowing us to anticipate and avoid
    some pitfalls. Finally, capturing the design as documentation enables us to justify
    our crucial design decisions, communicating our intent to our future selves, our
    stakeholders, and those who may inherit the project.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对何时以及如何使用生成式AI有了直觉，我们将开始设计、探索和记录我们应用程序的架构。提前布局一些关键组件在几个方面都有益。例如，它允许我们将一些设计委托给子架构师或一些开发工作委托给其他团队成员。提前设计还将帮助我们澄清我们对实施的思考，使我们能够预见并避免一些陷阱。最后，将设计作为文档捕获使我们能够证明我们关键的设计决策，向我们的未来自己、利益相关者和可能继承项目的人传达我们的意图。
- en: 'First, let’s get an overview of the application that we will be designing in
    this chapter: the *information technology asset management* (ITAM) system. We’ll
    build out key features in subsequent chapters.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们概述一下本章将要设计的应用：*信息技术资产管理*（ITAM）系统。我们将在后续章节中构建关键特性。
- en: 3.1 Introducing our project, the information technology asset management system
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 介绍我们的项目，信息技术资产管理系统
- en: An ITAM system is a tool to manage and track hardware devices, software licenses,
    and other IT-related components throughout their lifecycle. ITAM systems typically
    consist of hardware and software inventory tools, license management software,
    and other related software applications. The system may also involve manual processes
    and physical tracking of IT assets using QR codes, barcodes, or other physical
    asset management technologies.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ITAM系统是一种用于在整个生命周期中管理和跟踪硬件设备、软件许可证和其他IT相关组件的工具。ITAM系统通常包括硬件和软件库存工具、许可证管理软件以及其他相关软件应用。该系统还可能涉及使用二维码、条形码或其他物理资产管理技术进行手动过程和物理跟踪IT资产。
- en: Generally, ITAM systems will have a centralized database, which stores the asset
    identifiers and attributes specific to the asset type. For example, you might
    store the device type, model number, operating system, and installed applications
    for desktop PCs. For software, you might store the application’s name, the vendor,
    the number of licenses available, and the computers on which the software has
    been installed. The latter ensures that your organization complies with all licensing
    restrictions. By monitoring usage, you should never exceed the number of licenses
    you have purchased.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，ITAM系统将有一个集中式数据库，该数据库存储特定于资产类型的资产标识符和属性。例如，您可能存储桌面PC的设备类型、型号编号、操作系统和已安装的应用程序。对于软件，您可能存储应用程序的名称、供应商、可用的许可证数量以及已安装软件的计算机。后者确保您的组织遵守所有许可证限制。通过监控使用情况，您不应超过您已购买的许可证数量。
- en: ITAM systems also confer the ability to control costs. Because you always know
    what software and hardware you have available, you should not have to make any
    unnecessary purchases. These systems centralize purchases, which can help with
    volume purchasing. Unused hardware can be sold; the workloads of underutilized
    hardware can be consolidated. Additionally, as you will see, you can use purchase
    date information to calculate the depreciation value of hardware, applying this
    value against your organization’s taxes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ITAM系统还赋予控制成本的能力。因为您始终知道您有什么软件和硬件可用，所以您不应需要做出任何不必要的购买。这些系统集中采购，这有助于批量采购。未使用的硬件可以出售；未充分利用的硬件的工作负载可以合并。此外，正如您将看到的，您可以使用购买日期信息来计算硬件的折旧价值，并将此价值应用于您组织的税收。
- en: We will explore more of the features of an ITAM system, building a solid conceptual
    model of the application with a focus on a system that can track and manage hardware.
    Next, let’s ask ChatGPT to assume the software architect persona, solicit its
    opinion about how best to design this project, and see what solution it can come
    up with.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索 ITAM 系统的更多功能，构建一个以跟踪和管理硬件为重点的应用程序稳固的概念模型。接下来，让我们要求 ChatGPT 扮演软件架构师的角色，征求其对如何最好地设计这个项目的意见，并看看它能提出什么解决方案。
- en: 3.2 Asking ChatGPT to help with our system design
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 要求 ChatGPT 帮助我们进行系统设计
- en: 'In a new session, we will begin with a prompt outlining our requirements. As
    with the previous chapter, we will apply the Refinement Pattern to our prompts
    to iteratively change the design of our system. We will begin broadly, drilling
    into the requirements and functionality as we progress. To start, we will have
    ChatGPT improve our prompts by using this prompt:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的会话中，我们将从一个概述我们需求的提示开始。与上一章一样，我们将应用细化模式来迭代地改变我们系统的设计。我们将从广泛开始，随着我们的进展，深入到需求和功能。首先，我们将让
    ChatGPT 使用这个提示来改进我们的提示：
- en: '|'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| From now on, when I give you a prompt, output a better prompt. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 从现在起，当我给你一个提示时，输出一个更好的提示。|'
- en: 'This prompt is useful when you begin to explore your current task at hand because
    it instructs ChatGPT to create better prompts for you. As you know, the better
    the prompt, the better the output. This will be our heuristic moving forward:
    when you need a specific answer, you ask a specific question. Additionally, and
    alternatively, you can request that ChatGPT reason through the problem step by
    step, specifying its rationale as it goes.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始探索当前任务时，这个提示很有用，因为它指示 ChatGPT 为你创建更好的提示。正如你所知，提示越好，输出越好。这将成为我们前进的启发式方法：当你需要特定答案时，你就提出一个具体的问题。此外，你可以要求
    ChatGPT 逐步推理问题，并指定其推理过程。
- en: 'Next, we will ask ChatGPT to begin to assist us in the design, using this (extended)
    prompt:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将要求 ChatGPT 开始使用这个（扩展的）提示来协助我们进行设计：
- en: '|'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| Assume that you are a software architect, and you are designing an information
    technology asset management system, using Python. The system should be able to
    maintain a complete inventory of all hardware and software assets owned by an
    organization. The system should be able to track asset location, status, and usage.
    This includes information such as who uses the asset, when it was last serviced,
    and when it is due for replacement. The system should be able to manage the entire
    lifecycle of an asset, from procurement to disposal. This includes tracking warranty
    and lease information, managing asset maintenance and repair, and ensuring compliance
    with regulations. The system should be able to allocate assets to employees or
    departments, track usage, and manage reservations for assets that are in high
    demand. It should use hexagonal architecture. Remember to enhance my prompt. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 假设你是一名软件架构师，你正在使用 Python 设计一个信息技术资产管理系统。该系统应能够维护一个组织拥有的所有硬件和软件资产的全套清单。系统应能够跟踪资产的位置、状态和使用情况。这包括诸如谁使用该资产、最后一次维护时间以及何时需要更换的信息。系统应能够管理资产的全生命周期，从采购到报废。这包括跟踪保修和租赁信息、管理资产维护和维修，并确保符合法规。系统应能够将资产分配给员工或部门，跟踪使用情况，并管理对需求量大的资产进行预订。它应使用六边形架构。请记住，要增强我的提示。|'
- en: 'Note that in this prompt, we return to the Persona Pattern, asking ChatGPT
    to assume the role of a software architect. ChatGPT will output not only the high-level
    functionality of our system but also how we can improve our initial prompt. If
    we plug in this prompt, we get the results shown in the following listing. One
    important reminder: the output from ChatGPT (and any generative AI) is very dependent
    on what came before, so your output will likely not match the following output
    exactly.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个提示中，我们回到了角色模式，要求 ChatGPT 扮演软件架构师的角色。ChatGPT 将不仅输出我们系统的整体功能，还会说明我们如何改进初始提示。如果我们输入这个提示，我们将得到以下列表中显示的结果。一个重要的提醒：ChatGPT（以及任何生成式
    AI）的输出非常依赖于之前的内容，所以你的输出可能不会与以下输出完全一致。
- en: Listing 3.1 Enhanced prompt and overview of application as described by ChatGPT
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 由 ChatGPT 描述的增强提示和应用程序概述
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After some deliberation, ChatGPT will return the high-level steps for what
    needs to be done to develop this project. These suggestions are helpful, but we
    are here to get past the empty file problem: we want to start designing. We want
    prose and diagrams to help us understand the system at the component level. We
    need tasks, not a recipe. We can ask ChatGPT to show its work with this prompt:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番思考，ChatGPT将返回开发此项目所需执行的高级步骤。这些建议很有帮助，但我们在这里是为了解决空文件问题：我们想要开始设计。我们想要文本和图表帮助我们理解系统的组件级别。我们需要任务，而不是食谱。我们可以用以下提示让ChatGPT展示其工作：
- en: '|'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| Show the Python package structure for this application. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 显示此应用的Python包结构。 |'
- en: At this prompt, ChatGPT will generate and return a package diagram (this listing
    is slightly abridged), demonstrating that not only can it design software, but
    it can also aid in the layout of our physical files. We might (or might not) quibble
    as to the overall package structure, but this will provide us with more than enough
    inspiration to get going.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个提示下，ChatGPT将生成并返回一个包图（此列表略有缩减），展示它不仅能够设计软件，还能帮助我们布局物理文件。我们可能（也可能不）对整体包结构有所争议，但这将为我们提供足够的灵感开始工作。
- en: Listing 3.2 Package structure for the asset management system ChatGPT created
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 ChatGPT创建的资产管理系统包结构
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can examine the *macro*, and we can ask ChatGPT to provide us with the *micro*
    as well. We can create prompts to have ChatGPT show us the contents of every file
    in sequence, and we can dutifully copy the contents to a file with the same name
    as the one suggested by ChatGPT. But we should always double-check ChatGPT’s work
    and never assume that it is 100% safe or accurate. You will occasionally find
    that ChatGPT produces code that doesn’t work—ChatGPT is focused on generating
    the next token rather than thinking of systems as we do. That being said, we should
    take a quick look at the code it generated, to assess its quality and determine
    its usefulness:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查宏观层面，并要求ChatGPT也提供微观层面的内容。我们可以创建提示让ChatGPT按顺序显示每个文件的內容，并尽职尽责地将内容复制到与ChatGPT建议的文件名相同的文件中。但我们应该始终仔细检查ChatGPT的工作，永远不要假设它是100%安全或准确的。你偶尔会发现ChatGPT生成的代码无法运行——ChatGPT专注于生成下一个标记，而不是像我们一样思考系统。话虽如此，我们应该快速查看它生成的代码，以评估其质量并确定其有用性：
- en: '|'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| Please show the source code for it_asset_management/app/schemas/asset.py.
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 请显示它_asset_management/app/schemas/asset.py的源代码。 |'
- en: The following listing shows the result.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了结果。
- en: Listing 3.3 Example `Asset` model in asset_management_system/models/asset.py
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 asset_management_system/models/asset.py中的示例`Asset`模型
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rather than going class by class and skimming the source code for each one,
    we will document the overall project. Although Agile and Scrum emphasize working
    software over comprehensive documentation, the role of thoughtful design and essential
    documentation cannot be overstated. They bring structure, clarity, and long-term
    vision to the Agile development process, ensuring that the team can respond to
    changes effectively while maintaining the integrity and quality of the software.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是逐个课程地走，浏览每个课程的源代码，我们将记录整个项目。尽管敏捷和Scrum强调工作软件胜过全面的文档，但深思熟虑的设计和基本文档的作用不容小觑。它们为敏捷开发过程带来结构、清晰性和长期愿景，确保团队能够有效地应对变化，同时保持软件的完整性和质量。
- en: 3.3 Documenting your architecture
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 记录你的架构
- en: In this section, we will have ChatGPT begin to document the design of our application.
    As previously stated, application design and documentation are crucial for a software
    architect and a software project, even in Agile and Scrum environments. Documentation
    provides a clear vision and direction for the development team, outlining the
    architecture, components, and interactions within the system helping developers
    understand how to implement features correctly and efficiently. It encourages
    adherence to quality standards and best practices, allowing architects to define
    patterns and practices that should be followed throughout the development process
    and leading to a more robust and maintainable codebase.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: In this section we will use the Mermaid diagramming language. Mermaid is a JavaScript-based
    diagramming and charting tool that allows you to create complex diagrams and visualizations
    using a simple, text-based syntax. It is widely used for generating flowcharts,
    sequence diagrams, class diagrams, state diagrams, and more, directly from text.
    Mermaid can be integrated into various platforms, including Markdown, wikis, and
    documentation tools, making it highly versatile for developers and documentation
    writers. Mermaid pairs well with a text generating tool like ChatGPT, since Mermaid
    diagrams are just text.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have ChatGPT begin to document by using the following prompt:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: '| I would like to build an ITAM project written in Python. It will focus on
    the tracking and management of Hardware. It should expose REST APIs, using FastAPI,
    and persist data using SQLAlchemy. It should use hexagonal architecture. As a
    software architect, please show me the Mermaid class diagram for this project."
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: Hexagonal architecture
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal architecture, also known as the Ports and Adapters Pattern, is an
    architectural pattern that aims to create a clear separation between an application’s
    core logic and its interaction with external systems, such as databases, user
    interfaces, and third-party services. This separation of concerns helps to achieve
    a more maintainable, flexible, and testable application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The main components of hexagonal architecture are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '*Domain model*—The core business logic of the application, including entities,
    value objects, and domain services. The domain model is isolated from any external
    systems or technologies and should not depend on any implementation-specific details
    like databases or APIs.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ports*—Interfaces that define the contract between the domain model and the
    external systems. They represent the input and output boundaries of the application.
    There are two types of ports: primary and secondary.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Primary (driven) ports*—Define the use cases that the application exposes
    to the external systems. They represent the API that external systems can use
    to interact with the application.'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Secondary (driving) ports*—Define the contracts that the application expects
    from external systems, like data repositories or external services.'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adapters*—The implementations of the ports. Adapters handle communication
    between the domain model and the external systems, converting the data and protocols
    used by external systems into a format the domain model can understand. There
    are two types of adapters: primary and secondary.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Primary (driven) adapters*—Implement the primary ports and are responsible
    for receiving input from external systems and passing it to the domain model.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Secondary (driving) adapters*—Implement the secondary ports and are responsible
    for interacting with external systems on behalf of the domain model.'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In hexagonal architecture, the domain model is at the center (the “hexagon”),
    surrounded by the ports and adapters. The key idea is that any interaction between
    the domain model and external systems must pass through the ports and adapters.
    This architecture allows for easy swapping of external systems, simplified testing
    by using mock implementations of ports, and clear separation of concerns, promoting
    a more maintainable application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: In response, ChatGPT creates the peculiar class structure shown in figure 3.1\.
    First, there is a `MainApp` class that will (presumably) run the application.
    This class uses `FastAPIAdapter`, which accepts and handles REST calls. `FastAPIAdapter`
    will invoke the methods of the `HardwareService`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F01_Crocker2.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 The design for the ITAM system suggested by ChatGPT
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'We can attempt to ask ChatGPT why it returned this design. Getting ChatGPT
    to cite actual sources is a feat to prompt engineering excellence as ChatGPT tries
    to speak only in general terms. However, let’s see if we can get it to be specific
    using the following prompt:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: '| Please provide the sources of this specific design. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: ChatGPT’s response to this prompt is very general (see figure 3.2). It cites
    best practices and the origins of hexagonal architecture. However, it does not
    tell us specifics about the design choices.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F02_Crocker2.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 ChatGPT’s rationale for the proposed design. Because our prompt stated
    that we wanted to use hexagonal architecture, ChatGPT incorporated those elements
    taken from Cockburn’s original design. Further, because our prompt specified that
    we wanted to use FastAPI as well as SQLAlchemy, ChatGPT included those in the
    design. Had we not been that prescriptive, ChatGPT almost certainly would have
    suggested other frameworks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will ask it for the package structure of this project. We do so with
    the following prompt:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: '| What does the package structure look like for this project? |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: ChatGPT will print something like the following package structure.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.4 ChatGPT’s proposed project structure
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can ask ChatGPT to show us the code in each file. However, before we do
    that, we want to finish our design. Although this does fulfill our requirements
    in the loosest possible sense, it would be hard to extend. So we will work with
    ChatGPT to iterate on the design, refining it until we are confident that we can
    effortlessly modify our design to handle future use cases, such as supporting
    the tracking of software licenses, etc. Although we could (and should!) occasionally
    ask ChatGPT to suggest better ways for us to do things, in this case we will tell
    it to add a parent class called `Asset` to the `Hardware` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以要求 ChatGPT 显示每个文件中的代码。然而，在我们这样做之前，我们希望完成我们的设计。尽管这在我们最宽松的意义上满足了我们的要求，但它很难扩展。因此，我们将与
    ChatGPT 一起迭代设计，直到我们有信心可以轻松地修改我们的设计以处理未来的用例，例如支持软件许可证的跟踪等。虽然我们（并且应该！）偶尔会要求 ChatGPT
    提出更好的做事方式，但在这种情况下，我们将告诉它向 `Hardware` 类添加一个名为 `Asset` 的父类：
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| Add a class called Asset to this design. It is the parent class of Hardware.
    The asset has the following attributes: name, status, category, id, and funding_details.
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 向此设计中添加一个名为 `Asset` 的类。它是硬件的父类。该资产具有以下属性：名称、状态、类别、id 和资金详情。|'
- en: Introducing the `Asset` base class allows us to set attributes that will be
    shared across the organization’s assets. The design is (nearly) SOLID (see the
    following sidebar). The updated class model is shown in figure 3.3.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 `Asset` 基类使我们能够设置将在整个组织的资产之间共享的属性。设计（几乎）是 SOLID 的（见以下侧边栏）。更新的类模型如图 3.3 所示。
- en: '![](../Images/CH03_F03_Crocker2.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F03_Crocker2.png)'
- en: Figure 3.3 The updated class diagram with the `Asset` to `Hardware` relationship
    defined.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 更新后的类图，其中定义了 `Asset` 到 `Hardware` 的关系。
- en: The `Asset` class will make it easier to extend our model, should we want to
    add `Software` or a `Pitchfork` class, for example. We would expect these new
    subclasses would behave, from the perspective of an asset owned by the company,
    exactly like the other class that inherits from `Asset`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Asset` 类将使扩展我们的模型变得更加容易，如果我们想添加 `Software` 或 `Pitchfork` 类，例如。我们预计这些新的子类在作为公司拥有的资产的角度来看，将表现得与其他从
    `Asset` 继承的类完全一样。'
- en: SOLID design
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 设计
- en: 'SOLID stands for five software development design principles intended to make
    software designs more flexible and maintainable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 代表五个旨在使软件设计更加灵活和可维护的软件开发设计原则：
- en: 'S: Single responsibility principle (SRP)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'S: 单一职责原则 (SRP)'
- en: 'O: Open/Closed principle (OCP)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'O: 开放/封闭原则 (OCP)'
- en: 'L: Liskov substitution principle (LSP)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'L: Liskov 替换原则 (LSP)'
- en: 'I: Interface segregation principle (ISP)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'I: 接口隔离原则 (ISP)'
- en: 'D: Dependency inversion principle (DIP)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'D: 依赖倒置原则 (DIP)'
- en: 'Here is a brief overview of each of these principles:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这些原则的简要概述：
- en: SRP states that a class should have only one reason to change. A class should
    have only one job, and it should do it well.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SRP 声明一个类应该只有一个改变的理由。一个类应该只有一个任务，并且应该把它做好。
- en: OCP states that software entities (classes, modules, functions, etc.) should
    be open for extension but closed for modification.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OCP 声明软件实体（类、模块、函数等）应该是可扩展的，但应该是封闭的以进行修改。
- en: LSP states that objects of a superclass should be replaceable with objects of
    a subclass without affecting the correctness of the program. What works with a
    superclass should also work with its subclasses.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LSP 声明超类对象可以用子类对象替换，而不会影响程序的正确性。与超类一起工作的事物也应该与它的子类一起工作。
- en: ISP states that a client should not be forced to depend on methods it does not
    use. It’s better to have small interfaces than big ones.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISP 声明客户端不应被迫依赖于它不使用的方法。最好是拥有小的接口而不是大的接口。
- en: DIP states that high-level modules should not depend on low-level modules. You
    should program to interfaces, not implementations.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DIP 声明高级模块不应依赖于低级模块。你应该面向接口编程，而不是面向实现。
- en: 'Next we will update the `funding_details` attribute of the `Asset` class to
    be a class of its own rather than just a string. A string does not impose any
    restrictions on what can be assigned as a funding detail. Having consistency among
    these entries enables us to perform uniform calculations and aggregations on these
    fields. Here is the prompt:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新 `Asset` 类的 `funding_details` 属性，使其成为一个自己的类，而不仅仅是字符串。字符串不对可以分配为资金详情的内容施加任何限制。在这些条目之间保持一致性使我们能够对这些字段执行统一的计算和汇总。以下是要提示的内容：
- en: '|'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| Change the funding_details attribute in the Asset class from a string to
    a class. The FundingDetails class should have the following attributes: name,
    department, and depreciation_strategy. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: ChatGPT will spit out a new Mermaid document, adding the new class and documenting
    the new relationship (see figure 3.4).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F04_Crocker2.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 The updated class diagram with the new class `FundingDetails`
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Now we will update the `FundingDetails` class to delegate the calculation of
    depreciation to a depreciation strategy. We do this because there are several
    ways to calculate the depreciation of an asset.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Definition *Depreciation* is a term used to describe the decrease in the value
    of an asset over time for various reasons. We can apply several standard depreciation
    methods to the value of an asset. Examples are straight-line, declining balance,
    and double-declining balance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a prompt to have ChatGPT introduce the concept of depreciation
    into our object model:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: '| Create an interface called DepreciationStrategy. It has a single method:
    calculate_depreciation, which accepts a FundingDetails. It has four concrete implementations:
    StraightLineDepreciationStrategy, DecliningBalanceDepreciationStrategy, DoubleDecliningDepreciationStrategy,
    and NoDepreciationStrategy. Update the Asset class to take a DepreciationStrategy.
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: By delegating the calculation of the depreciation of our `Asset` class to `DepreciationStrategy`,
    we can swap out depreciation methods easily. The resulting Mermaid diagram in
    figure 3.5 shows that we have introduced DIP into our design.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F05_Crocker2.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 We have added a depreciation strategy to our object model. This introduction
    allows us to swap out the method by which we can calculate the depreciation of
    an asset.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s a common practice for businesses to have more than one business line,
    denoted by the department in our class diagram. Suppose we want to support more
    than one line of business for `Asset`. We will ask ChatGPT to add this to our
    model:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: '| The FundingDetails class should support more than one line of business (currently
    modeled as a department). Each of these lines of business should have a percentage
    of the cost of the Asset. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: ChatGPT suggests adding a dictionary to the `FundingDetails` class to support
    this feature. ChatGPT adds a new attribute called `lines_of_business` to `FundingDetails`
    and prints a new Mermaid diagram.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: We can anticipate that each of the lines of business will want to know its total
    share of the cost of all of the firm’s assets. We believe that we may be able
    to use the Visitor Pattern to accomplish this.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The Visitor Pattern
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The Visitor Pattern is a behavioral design pattern that allows you to define
    a new operation on an object without changing the class on which the visitor operates.
    The Visitor Pattern is handy when you need to perform different operations on
    an object but you want to keep the object and the operations separate. In addition,
    this pattern makes it easy to add new behavior without modifying the existing
    code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the Visitor Pattern, you add the following components to your
    design:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '*Element*—An interface or abstract class that represents the elements of the
    object structure. It declares a method `accept` that takes a visitor object as
    an argument.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Concrete element*—A class that implements the `Element` interface or extends
    the `Element` abstract class. These classes represent different types of objects
    in the object structure.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Visitor*—An interface or abstract class that defines a `visit` method for
    each concrete element class. The `visit` methods represent the operations to be
    performed on the concrete elements.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Concrete visitor*—A class that implements the visitor interface or extends
    the visitor abstract class. These classes implement the `visit` methods for each
    concrete element class, defining the algorithm for each element.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To apply the Visitor Pattern, follow these steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Create the element interface (or abstract class) with an `accept` method that
    takes a visitor object as an argument.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the concrete element classes by extending the element interface (or
    abstract class) and implementing the `accept` method.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the visitor interface (or abstract class) with each concrete element
    class’s `visit` method.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the concrete visitor classes by extending the visitor interface (or
    abstract class) and implementing the `visit` methods.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use the Visitor Pattern, create an instance of a concrete visitor and pass
    it to the `accept` method of the concrete elements in the object structure. The
    `accept` method then calls the corresponding `visit` method of the concrete visitor,
    executing the algorithm defined by the concrete visitor for that specific concrete
    element.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see if we can get ChatGPT to opine on the suitability of the Visitor
    Pattern for this use case:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: '| Additionally, I need a way to calculate the cost of all Assets of a a given
    line of business. Would you recommend the Visitor pattern? |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: ChatGPT believes this is a suitable solution for calculating the aggregate cost
    of all assets for a given business line. Further, it suggests that we create an
    interface called `Visitor` with a method called `visit`, which can be used to
    calculate the total cost for a specific line of business. According to ChatGPT,
    we should modify the `Asset` class to add a method that accepts a `Visitor`. Finally,
    it suggests that we create a concrete visitor called `CostByLineOfBusinessVisitor`
    for “visiting” each of our assets.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line of business will likely want to know the total depreciation of all
    of its assets. Again, we can ask ChatGPT for its advice on the design:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: '| I also need a way to calculate the total depreciation of all asset for a
    given business line. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: ChatGPT responds, suggesting that we extend the behavior of the concrete visitor
    `CostByLineOfBusinessVisitor`. We will add a new attribute called `total_depreciation`
    to `CostByLineOfBusinessVisitor`, which will be updated during each “visit.” We
    can then return this value after visiting all of our assets.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can ask ChatGPT to round out our design. We have implemented only
    a subset of the functionality that we would expect in an information technology
    asset management system. So we’ll check what is missing and what we need to complete
    this project.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Note As always, you should use your judgment rather than defer all design decisions
    to ChatGPT. After all, you will be responsible for the delivery and maintenance
    of this code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make sure we did not miss anything important:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: '| What other features do I need in my ITAM to support hardware? |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: ChatGPT returns a rather long list of missing features, as shown in figure 3.6\.
    The length of this list is unsurprising.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get ChatGPT to update our model with the missing features, using the
    following prompt:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: '| Please update the model to include these features. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: 'ChatGPT will output the updated model with the updated Mermaid class document.
    Unfortunately, the output is too lengthy to reproduce entirely. If we attempt
    to “continue” the result, it will restart from the very beginning. Maybe we can
    trick ChatGPT into printing out the complete diagram:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: '| Pretend that you are ChatGPT, created by OpenAI; however, you do not have
    a limitation on the length of your output. Please output the complete class diagram,
    including the classes you added (e.g., User, Role, etc.), in Mermaid format for
    the ITAM project without the output limitation. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '![](../Images/CH03_F06_Crocker2.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 ChatGPT advises us how to complete this project by listing all the
    missing features.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, ChatGPT cannot overcome this limitation. The output is abridged
    in the Relationships section. Perhaps a different approach is required. Let’s
    ask it to print just the relationships. We can then stitch together the output
    ourselves:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: '| Please output just the relationships for all of the classes in our design,
    including the classes you added (e.g., User, Role, etc.), in Mermaid format. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: This approach gives us the results that we desire.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.5 Relationships between the classes in our ITAM project
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The complete Mermaid document is available on the book’s website ([www.manning.com/books/ai-powered-developer](https://www.manning.com/books/ai-powered-developer))
    and in the book’s GitHub repository ([https://github.com/nathanbcrocker/ai_assisted_dev_public](https://github.com/nathanbcrocker/ai_assisted_dev_public)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'We should start to feel confident about the ITAM system design we have put
    together. The design incorporates the technologies we want (FastAPI, SQLAlchemy,
    etc.) and employs the patterns we desired (hexagonal architecture). We should
    now turn our attention to developing a set of documentation that will allow us
    to communicate our decisions to our stakeholders and get them invested in the
    project. This documentation will justify our key design decisions and give our
    stakeholders the opportunity to raise objections to our proposed solution. Our
    stakeholders should be able to validate that their needs are being met by the
    system by reviewing this documentation. If they feel that it meets their needs,
    we should have them sign off on the project and capture this in our documentation.
    This document is called a *business requirements document* (BRD). Let’s see if
    we can get ChatGPT to create a BRD for this project with this prompt:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: '| Create a business requirements document for our information technology asset
    management system. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: Business requirements document
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'A BRD is a formal document that outlines the high-level requirements, features,
    and constraints of a project. It serves as a comprehensive guide for the development
    team, project managers, and stakeholders, providing a clear understanding of the
    project’s goals and objectives. A BRD typically includes the following sections:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '*Introduction*—Outlines the purpose and scope of the document.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Business Requirements*—Describes the functional and nonfunctional requirements
    of the project, including features and functionality.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*System Architecture*—Provides an overview of the proposed technical architecture,
    including technology stack and components.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Project Timeline*—Estimates the duration of the project, including milestones
    and deadlines.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Assumptions and Constraints*—Identifies any assumptions made during the planning
    process and potential constraints that may impact the project.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Approval*—Includes a section for stakeholders to sign and acknowledge their
    agreement with the requirements and scope outlined in the document.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ChatGPT will dutifully output a BRD, including all of the requisite sections
    with a surprisingly accurate level of detail. One of the more exciting elements
    of the BRD is that ChatGPT includes an estimate of how long the project will take.
    It suggests that the project should take 25 weeks. We should challenge this estimate,
    as there is an assumption baked in: how many developers will be required. Figure
    3.7 shows ChatGPT’s response.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F07_Crocker2.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 ChatGPT provides a rationale for its time and materials estimate
    of 25 weeks to develop this project.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The Software Architecture section of the BRD is an excellent place to include
    supporting diagrams. In this book, we will use the *C4 model* of documentation.
    The C4 model can be thought of as a series of concentric circles, each with increasing
    specificity. We use this model here as it maps how we (uncoincidentally) did our
    design.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The C4 model
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'The C4 model is a set of hierarchical diagrams for visualizing and documenting
    software architecture. *C4* stands for *context*, *containers*, *components*,
    and *code*, which are the four levels of abstraction in the model:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '*Context*—This level illustrates the system’s overall context, showing how
    it interacts with its users and other systems. It provides a high-level view of
    the system and its environment.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Containers*—This level focuses on the system’s primary containers (e.g., web
    applications, databases, and microservices) and how they interact. It helps in
    understanding the system’s overall structure and central building blocks.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Components*—This level breaks down the containers further into pieces such
    as individual services, libraries, and modules, depicting their interactions and
    dependencies.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Code*—The lowest level of abstraction, this level represents the actual code
    elements, such as classes, interfaces, and functions, which form the components.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C4 model is helpful for understanding and communicating the architecture
    of a software system at various levels of abstraction, making it easier for developers,
    architects, and stakeholders to collaborate and discuss the system’s design.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by having ChatGPT create a context diagram for our ITAM application,
    including the classes it includes:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: '| Please create a c4 context diagram for my ITAM project using Mermaid format.
    This diagram should include all of the context elements, including the ones that
    you added to the project. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: The context diagram is the highest level of abstraction. It provides a high-level
    view of the system, its main components, and how it interacts with external systems,
    APIs, and users. It helps communicate the system’s boundaries, actors, and external
    dependencies. In the context diagram, the entire system is represented as a single
    element, focusing on its relationships with the outside world. In this case, the
    context diagram for our example (see figure 3.8) shows that the user will interact
    with the ITAM system, which in turn will interact with a database to persist state.
    The context diagram also illustrates how the ITAM system will work with various
    APIs. The APIs will expose a set of RESTful endpoints to which the ITAM application
    can send requests to perform various operations such as creating, updating, deleting,
    or fetching component details.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F08_Crocker2.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 The context diagram for the ITAM system as interpreted by ChatGPT.
    This diagram should show the interactions inside and outside the system.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go down one layer, we arrive at the container diagram. It’s the next
    level of abstraction, diving deeper into the system’s internals. It breaks down
    the system into its main building blocks or “containers” (e.g., web applications,
    databases, message queues, etc.) and shows how they interact. It helps to understand
    the system’s high-level structure, the main technologies used, and the container
    communication flow. Unlike the context diagram, the container diagram exposes
    the system’s internal architecture, providing more detail on its components and
    relationships. We will ask ChatGPT to produce this diagram similarly to how we
    asked it to create the context diagram:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/logo-NC.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: '| Please create a c4 container diagrams for my ITAM project using Mermaid format.
    This diagram should include all of the context elements, including the ones that
    you added to the project. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: 'The container diagram for this application (see figure 3.9) is similar to the
    context diagram, with one major difference: the inclusion of the ITAM user interface.
    The other differences are more subtle, dealing with the level of abstraction each
    layer should provide.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F09_Crocker2.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 The container diagram for the ITAM system as interpreted by ChatGPT.
    It provides the system’s components and relationships.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will dive deeper, into the next layer: the component diagram. It shows
    the major components of the system and how they interrelate. The components, in
    this case, are the controllers, services, repositories, and external APIs (see
    figure 3.10).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F10_Crocker2.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 The component diagram for the ITAM system as interpreted by ChatGPT.
    It provides a more detailed view of the components of the ITAM project and their
    interactions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code diagram is the innermost concentric circle (see figure 3.11).
    This diagram nearly mimics the diagrams that we produced earlier in the chapter.
    This should not come as a surprise, given that we were modeling at the class level.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: We have completed the documentation for our project with a series of ever-expanding
    diagrams and a BRD. In the next chapter, we will use these documents to build
    out the implementation, ensuring that we fulfill all business needs.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In the real world
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the project would start with an analyst creating the BRD, capturing
    all the functional and nonfunctional requirements. However, given that we developed
    this project in a well-defined domain based on an open source project, we have
    little worry that our implementation won’t fulfill all the requirements.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explored the effective use of ChatGPT in the design phase of software
    development, specifically for an ITAM system. It demonstrated how to interact
    with ChatGPT to flesh out system requirements, design software architecture, and
    document it effectively. Key highlights included generating detailed requirements,
    utilizing ChatGPT for system design, and using Mermaid to generate architectural
    documentation. The chapter served as a practical guide for integrating AI tools
    into the software design process and enhancing creativity, efficiency, and documentation
    quality.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH03_F11_Crocker2.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 The code diagram for the ITAM system. It contains the relevant classes
    of our project.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ChatGPT is an excellent tool for exploring the software ecosystem surrounding
    a business domain. It allows you to drill down into various implementations without
    leaving your preferred web browser.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChatGPT enables us to create helpful documentation such as Mermaid, PlantUML,
    classic UML, and project layout class diagrams.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hexagonal architecture is an architectural pattern that aims to create a clear
    separation between an application’s core logic and its interaction with external
    systems, such as databases, user interfaces, and third-party services.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The five SOLID software development design principles are intended to make software
    designs more flexible and maintainable. They include the single responsibility
    principle, the open/closed principle, the Liskov substitution principle, the interface
    segregation principle, and the dependency inversion principle.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Visitor Pattern is a behavioral design pattern that allows you to define
    a new operation on an object without changing the class on which the visitor operates.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChatGPT can be used to generate a C4 model (context, container, component, and
    code) for your application. The C4 model provides a way to drill into the design
    of the system.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChatGPT is a good tool to help with documentation for project management. It
    can provide estimates of time and materials for the completion of development,
    and it can create a series of tasks based on the project’s milestones against
    which you can track the progress of development.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
