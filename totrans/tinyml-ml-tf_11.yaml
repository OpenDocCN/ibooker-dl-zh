- en: 'Chapter 11\. Magic Wand: Building an Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our example applications have worked with data that human beings can
    easily comprehend. We have entire areas of our brain devoted to understanding
    speech and vision, so it’s not difficult for us to interpret visual or audio data
    and form an idea of what’s going on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: A lot of data, however, is not so easily understood. Machines and their sensors
    generate huge streams of information that don’t map easily onto our human senses.
    Even when represented visually, it can be difficult for our brains to grasp the
    trends and patterns within the data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: For example, the two graphs presented in [Figure 11-1](#jogging) and [Figure 11-2](#walking_downstairs)
    show sensor data captured by mobile phones placed in the front pockets of people
    doing exercise. The sensor in question is an *accelerometer*, which measures acceleration
    in three dimensions (we’ll talk more about these later). The graph in [Figure 11-1](#jogging)
    shows accelerometer data for a person who is jogging, whereas the graph in [Figure 11-2](#walking_downstairs)
    shows data for the same person walking down stairs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it’s tough to distinguish between the two activities, even though
    the data represents a simple and relatable activity. Imagine trying to distinguish
    between the operating states of a complex industrial machine, which might have
    hundreds of sensors measuring all sorts of obscure properties.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: It’s often possible to write handcrafted algorithms that can make sense of this
    type of data. For example, an expert in human gait might recognize the telltale
    signs of walking up stairs, and be able to express this knowledge as a function
    in code. This type of function is called a *heuristic*, and it’s commonly used
    in all sorts of applications, from industrial automation to medical devices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph of accelerometer data from someone jogging](Images/timl_1101.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. Graph showing data for a person who is jogging [(MotionSense dataset)](https://oreil.ly/ZUPV5)
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![A graph of accelerometer data from someone walking upstairs](Images/timl_1102.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2\. Graph showing data for a person who is walking down stairs [(MotionSense
    dataset)](https://oreil.ly/ZUPV5)
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To create a heuristic, you need two things. The first is domain knowledge. A
    heuristic algorithm expresses human knowledge and understanding, so to write one,
    you need to already understand what the data means. To understand this, imagine
    a heuristic that determines whether a person has a fever based on their body temperature.
    Whoever created it must have had knowledge of the temperature changes that indicate
    a fever.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The second requirement for building a heuristic is programming and mathematical
    expertise. Although it’s fairly easy to determine whether someone’s temperature
    is too high, other problems can be far more complex. Discerning a system’s state
    based on complex patterns in multiple streams of data might require knowledge
    of some advanced techniques, like statistical analysis or signal processing. For
    example, imagine creating a heuristic to distinguish between walking and running
    based on accelerometer data. To build this, you might need to know how to mathematically
    filter the accelerometer data to get an estimate of step frequency.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Heuristics can be extremely useful, but the fact that they require domain knowledge
    and programming expertise means that they can be a challenge to build. First,
    domain knowledge is not always available. For example, a small company might not
    have the resources to conduct the basic research necessary to know what indicates
    one state versus another. Similarly, even given domain knowledge, not everyone
    has the expertise required to design and implement the heuristic algorithm in
    code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning gives us an opportunity to shortcut these requirements. A model
    trained on labeled data can learn to recognize the signals that indicate one class
    or another, meaning there’s less need for deep domain knowledge. For example,
    a model can learn the human temperature fluctuations that indicate a fever without
    ever being told which specific temperatures are important—all it needs is temperature
    data labelled with “fever” or “nonfever.” In addition, the engineering skills
    required to work with machine learning are arguably easier to acquire than those
    that might be required to implement a sophisticated heuristic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习为我们提供了一种捷径，一个在标记数据上训练的模型可以学会识别指示一个类别或另一个类别的信号，这意味着不需要深入的领域知识。例如，一个模型可以学会识别表明发烧的人体温度波动，而无需告诉它哪些具体温度是重要的——它只需要带有“发烧”或“非发烧”标签的温度数据。此外，与可能需要实现复杂启发式算法所需的工程技能相比，学习机器学习可能更容易获得。
- en: Instead of having to design a heuristic algorithm from scratch, a machine learning
    developer can find a suitable model architecture, collect and label a dataset,
    and iteratively create a model through training and evaluation. Domain knowledge
    is still extremely helpful, but it might no longer be a prerequisite to getting
    something working. And in some cases, the resulting model can actually be more
    accurate than the best handcoded algorithms.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习开发人员不再需要从头设计启发式算法，而是可以找到合适的模型架构，收集和标记数据集，并通过训练和评估迭代地创建模型。领域知识仍然非常有帮助，但可能不再是使某些东西运作的先决条件。在某些情况下，最终的模型实际上可能比最佳的手工编码算法更准确。
- en: In fact, a recent paper^([1](ch11.xhtml#idm46473555451544)) showed how a simple
    convolutional neural network is able to detect congestive heart failure in a patient
    from a single heartbeat *with 100% accuracy*. This is better performance than
    any previous diagnostic technique. The paper is a fascinating read, even if you
    don’t understand every detail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，最近的一篇论文显示，一个简单的卷积神经网络能够从单个心跳中以100%的准确率检测出患者的充血性心力衰竭。这比任何先前的诊断技术表现都要好。即使你不理解每个细节，这篇论文也是一篇引人入胜的阅读。
- en: 'By training a deep learning model to understand complex data and embedding
    it in a microcontroller program, we can create smart sensors that are able to
    understand the complexities of their environments and tell us, at a high level,
    what is going on. This has huge implications across dozens of fields. Here are
    just a few potential applications:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过训练一个深度学习模型来理解复杂数据并将其嵌入微控制器程序中，我们可以创建智能传感器，能够理解其环境的复杂性并告诉我们，高层次上正在发生什么。这对数十个领域都有巨大的影响。以下只是一些潜在的应用：
- en: Environmental monitoring in remote places with poor connectivity
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络连接质量差的偏远地区进行环境监测
- en: Automated industrial processes that adjust to problems in real time
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动调整以实时解决问题的工业流程
- en: Robots that react to complex external stimuli
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对复杂外部刺激做出反应的机器人
- en: Disease diagnosis without the need for medical professionals
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需医疗专业人员进行疾病诊断
- en: Computer interfaces that understand physical movement
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解物理运动的计算机界面
- en: 'In this chapter, we build a project in the final category: a digital “magic
    wand,” which can be waved by its owner to cast a variety of spells. As its input,
    it takes complex, multidimensional sensor data that would be inscrutable to a
    human. Its output will be a simple classification that alerts us if one of several
    classes of movements has recently occurred. We’ll look at how deep learning can
    transform strange numerical data into meaningful information—to magical effect.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个属于最终类别的项目：一个数字“魔杖”，其所有者可以挥舞以施放各种咒语。作为其输入，它接收复杂的、多维的传感器数据，这对人类来说是难以理解的。其输出将是一个简单的分类，提醒我们最近是否发生了几种运动类别中的一种。我们将看看深度学习如何将奇怪的数字数据转化为有意义的信息——产生魔法效果。
- en: What We’re Building
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们正在构建的东西
- en: Our “magic wand” can be used to cast several types of spells. To do so, the
    wielder need only wave the wand in one of three gestures, named “wing,” “ring,”
    and “slope,” as shown in [Figure 11-3](#gesture_spells).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“魔杖”可以用来施放几种类型的咒语。持有者只需挥动魔杖进行三种手势中的一种，即“翅膀”、“环”和“斜坡”，如[图11-3](#gesture_spells)所示。
- en: '![Diagrams of the three magic wand gestures](Images/timl_1103.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![三个魔杖手势的图示](Images/timl_1103.png)'
- en: Figure 11-3\. The three magic wand gestures
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-3。三个魔杖手势
- en: The wand will react to each spell by lighting an LED. In case the magic of electric
    light is not sufficiently exciting, it will also output information to its serial
    port, which can be used to control an attached computer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 魔杖将通过点亮LED来对每个咒语做出反应。如果电灯的魔法不够令人兴奋，它还将输出信息到其串行端口，该信息可用于控制连接的计算机。
- en: To understand physical gestures, the magic wand application uses a device’s
    accelerometer to collect information about its motion through space. An accelerometer
    measures the degree of acceleration that it is currently experiencing. For example,
    imagine that we’ve attached an accelerometer to a car that has stopped at a red
    light and is about to drive away.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解物理手势，魔杖应用程序使用设备的加速度计收集有关其在空间中运动的信息。加速度计测量当前正在经历的加速度的程度。例如，想象一下，我们已经将一个加速度计连接到一辆停在红灯前准备启动的汽车上。
- en: When the light turns green, the car starts moving forward, increasing in speed
    until it reaches the speed limit. During this period, the accelerometer will output
    a value that indicates the car’s rate of acceleration. After the car has reached
    a steady speed, it is no longer accelerating, so the accelerometer will output
    zero.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当灯变绿时，汽车开始向前移动，速度逐渐增加直到达到速度限制。在此期间，加速度计将输出一个值，指示汽车的加速度。汽车达到稳定速度后，它不再加速，因此加速度计将输出零。
- en: The SparkFun Edge and Arduino Nano 33 BLE Sense boards are both equipped with
    three-axis accelerometers contained within components that are soldered to each
    board. These measure acceleration in three directions, which means they can be
    used to track the motion of the device in 3D space. To construct our magic wand,
    we’ll attach the microcontroller board to the end of a stick so it can be waved
    in a sorcerous manner. We’ll then feed the accelerometer’s output into a deep
    learning model, which will perform classification to tell us whether a known gesture
    was made.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SparkFun Edge和Arduino Nano 33 BLE Sense板都配备有三轴加速度计，这些加速度计包含在焊接到每个板上的组件中。它们在三个方向上测量加速度，这意味着它们可以用来跟踪设备在3D空间中的运动。为了制作我们的魔杖，我们将把微控制器板固定在一根棍子的末端，这样就可以以巫术般的方式挥动它。然后，我们将加速度计的输出输入到一个深度学习模型中，该模型将执行分类，告诉我们是否进行了已知手势。
- en: 'We provide instructions on deploying this application to the following microcontroller
    platforms:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了将此应用程序部署到以下微控制器平台的说明：
- en: '[Arduino Nano 33 BLE Sense](https://oreil.ly/6qlMD)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Arduino Nano 33 BLE Sense](https://oreil.ly/6qlMD)'
- en: '[SparkFun Edge](https://oreil.ly/-hoL-)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SparkFun Edge](https://oreil.ly/-hoL-)'
- en: Because the [ST Microelectronics STM32F746G Discovery kit](https://oreil.ly/SSsVJ)
    doesn’t include an accelerometer (and is too big to attach to the end of a magic
    wand), we won’t be featuring it here.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因为[ST Microelectronics STM32F746G Discovery kit](https://oreil.ly/SSsVJ)不包括加速度计（并且太大无法附在魔杖的末端），我们不会在这里展示它。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: TensorFlow Lite regularly adds support for new devices, so if the device you’d
    like to use isn’t listed here, it’s worth checking the example’s [*README.md*](https://oreil.ly/dkZfA).
    You can also check there for updated deployment instructions if you run into trouble.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow Lite定期为新设备添加支持，因此，如果您想使用的设备没有在这里列出，值得检查示例的[*README.md*](https://oreil.ly/dkZfA)。如果遇到问题，您也可以在那里查看更新的部署说明。
- en: In the next section, we’ll look at the structure of our application and learn
    more about how its model works.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下我们应用程序的结构，并了解更多关于它的模型是如何工作的。
- en: Application Architecture
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序架构
- en: Our application will again follow the now-familiar pattern of obtaining input,
    running inference, processing the output, and using the resulting information
    to make things happen.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将再次遵循现在熟悉的模式，获取输入，运行推断，处理输出，并使用生成的信息来实现一些操作。
- en: A three-axis accelerometer outputs three values representing the amount of acceleration
    on the device’s x, y, and z-axes. The accelerometer on the SparkFun Edge board
    can do this 25 times per second (a rate of 25 Hz). Our model takes these values
    directly as its input, meaning we won’t need to do any preprocessing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 三轴加速度计输出三个值，表示设备的x、y和z轴上的加速度量。SparkFun Edge板上的加速度计每秒可以做到这一点25次（25 Hz的速率）。我们的模型直接将这些值作为输入，这意味着我们不需要进行任何预处理。
- en: After data has been captured and inference has been run, our application will
    determine whether a valid gesture was detected, print some output to the terminal,
    and light an LED.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据被捕获并推断运行之后，我们的应用程序将确定是否检测到了有效的手势，向终端打印一些输出，并点亮LED。
- en: Introducing Our Model
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍我们的模型
- en: Our gesture-detecting model is a convolutional neural network, weighing in at
    around 20 KB, that accepts raw accelerometer values as its input. It takes in
    128 sets of *x*, *y*, and *z* values at once, which at a rate of 25 Hz adds up
    to a little more than five seconds’ worth of data. Each value is a 32-bit floating-point
    number that indicates the amount of acceleration in that direction.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的手势检测模型是一个卷积神经网络，大小约为20 KB，它接受原始加速度计值作为输入。它一次接收128组*x*、*y*和*z*值，以25 Hz的速率计算，相当于超过五秒钟的数据。每个值是一个32位浮点数，表示该方向上的加速度量。
- en: 'The model was trained on four gestures performed by numerous people. It outputs
    probability scores for four classes: one representing each gesture (“wing,” “ring,”
    and “slope”), and one representing no recognized gesture. The probability scores
    sum to 1, with a score above 0.8 being considered confident.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型是在许多人执行的四个手势上进行训练的。它为四个类别输出概率分数：分别代表每个手势（“翅膀”、“戒指”和“斜坡”），以及代表未识别手势的一个。概率分数总和为1，得分高于0.8被认为是有信心的。
- en: Because we’ll be running multiple inferences per second, we’ll need to make
    sure a single errant inference while a gesture is performed doesn’t skew our results.
    Our mechanism for doing this will be to consider a gesture as being detected only
    after it has been confirmed by a certain number of inferences. Given that each
    gesture takes a different amount of time to perform, the number of required inferences
    is different for each gesture, with the optimal numbers being determined through
    experimentation. Likewise, inference runs at varying rates on different devices,
    so these thresholds are also set per device.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将每秒运行多次推断，我们需要确保在执行手势时单个错误的推断不会使结果产生偏差。我们的机制是只有在经过一定数量的推断确认后才认为检测到了手势。鉴于每个手势执行所需的时间不同，对于每个手势，所需的推断次数也不同，最佳数量是通过实验确定的。同样，不同设备上推断的运行速率也不同，因此这些阈值也是根据设备设置的。
- en: In [Chapter 12](ch12.xhtml#chapter_magic_wand_training), we’ll explore how to
    train a model on our own gesture data and dig deeper into how the model works.
    Until then, let’s continue walking through our application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](ch12.xhtml#chapter_magic_wand_training)中，我们将探讨如何在我们自己的手势数据上训练模型，并深入了解模型的工作原理。在那之前，让我们继续走过我们的应用程序。
- en: All the Moving Parts
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有的移动部件
- en: '[Figure 11-4](#gesture_application_architecture) shows the structure of our
    magic wand application.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-4](#gesture_application_architecture)显示了我们魔杖应用程序的结构。'
- en: As you can see, it’s almost as simple as our person detection application. Our
    model accepts raw accelerometer data, meaning we don’t need to do any preprocessing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这几乎和我们的人体检测应用程序一样简单。我们的模型接受原始加速度计数据，这意味着我们不需要进行任何预处理。
- en: 'The code’s six main parts follow a similar structure as in our person detection
    example. Let’s walk through them in turn:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的六个主要部分遵循与我们的人员检测示例相似的结构。让我们依次浏览它们：
- en: Main loop
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环
- en: Our application runs in a continuous loop. Since its model is small and simple
    and there’s no preprocessing required, we’ll be able to run multiple inferences
    per second.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序在一个连续循环中运行。由于其模型小而简单，且不需要预处理，我们可以每秒运行多个推理。
- en: Accelerometer handler
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计处理程序
- en: This component captures data from the accelerometer and writes it to the model’s
    input tensor. It uses a buffer to hold data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件从加速度计捕获数据并将其写入模型的输入张量。它使用缓冲区来保存数据。
- en: TF Lite interpreter
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: TF Lite解释器
- en: The interpreter runs the TensorFlow Lite model, as in our earlier examples.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器运行TensorFlow Lite模型，就像我们之前的示例一样。
- en: Model
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 模型
- en: The model is included as a data array and run by the interpreter. It’s nice
    and small, weighing in at only 19.5 KB.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型作为数据数组包含在内，并由解释器运行。它很小，仅19.5 KB。
- en: Gesture predictor
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 手势预测器
- en: This component takes the model’s output and decides whether a gesture has been
    detected, based on thresholds for both probability and the number of consecutive
    positive predictions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件获取模型的输出，并根据概率和连续正预测的数量的阈值决定是否检测到手势。
- en: Output handler
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出处理程序
- en: The output handler lights LEDs and prints output to the serial port depending
    on which gesture was recognized.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出处理程序点亮LED并根据识别到的手势在串行端口上打印输出。
- en: '![Diagram of the components of our magic wand application](Images/timl_1104.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![我们魔杖应用程序组件的图示](Images/timl_1104.png)'
- en: Figure 11-4\. The components of our magic wand application
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-4。我们魔杖应用程序的组件
- en: Walking Through the Tests
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览测试
- en: 'You can find the application’s tests in the [GitHub repository](https://oreil.ly/h4iYb):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[GitHub存储库](https://oreil.ly/h4iYb)中找到应用程序的测试：
- en: '[*magic_wand_test.cc*](https://oreil.ly/X0AJP)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[*magic_wand_test.cc*](https://oreil.ly/X0AJP)'
- en: Shows how to run inference on a sample of accelerometer data
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何对加速度计数据样本运行推理
- en: '[*accelerometer_handler_test.cc*](https://oreil.ly/MwM7g)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[*accelerometer_handler_test.cc*](https://oreil.ly/MwM7g)'
- en: Shows how to use the accelerometer handler to obtain fresh data
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何使用加速度计处理程序获取新鲜数据
- en: '[*gesture_predictor_test.cc*](https://oreil.ly/cGbim)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[*gesture_predictor_test.cc*](https://oreil.ly/cGbim)'
- en: Shows how to use the gesture predictor to interpret the results of inference
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何使用手势预测器解释推理结果
- en: '[*output_handler_test.cc*](https://oreil.ly/MYwUW)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[*output_handler_test.cc*](https://oreil.ly/MYwUW)'
- en: Shows how to use the output handler to show results of inference
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何使用输出处理程序显示推理结果
- en: Let’s begin by walking through *magic_wand_test.cc*, which will show us the
    end-to-end process of inference with our model.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从*magic_wand_test.cc*开始，这将向我们展示使用我们的模型进行推理的端到端过程。
- en: The Basic Flow
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本流程
- en: We step through the basic flow in *magic_wand_test.cc*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*magic_wand_test.cc*中逐步进行基本流程。
- en: 'First, we list the ops our model will need:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们列出模型将需要的操作：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The test itself begins (as usual) by setting up everything required for inference
    and grabbing a pointer to the model’s input tensor:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 测试本身（通常）通过设置推理所需的所有内容并获取模型输入张量的指针开始：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We then inspect the input tensor to ensure that it’s the expected shape:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查输入张量以确保其预期形状：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our input’s shape is `(1, 128, 3, 1)`. The first dimension is just a wrapper
    around the second, which holds 128 three-axis accelerometer readings. Each reading
    has three values, one for each axis, and each value is wrapped within a single-element
    tensor. The inputs are all 32-bit floating-point values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输入形状是`(1, 128, 3, 1)`。第一个维度只是第二个维度的包装器，其中包含128个三轴加速度计读数。每个读数有三个值，分别对应每个轴，每个值都包含在一个单元素张量中。输入都是32位浮点值。
- en: 'After we’ve confirmed the input shape, we write some data to the input tensor:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们确认输入形状后，我们向输入张量写入一些数据：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The constant `g_circle_micro_f9643d42_nohash_4_data` is defined in *circle_micro_features_data.cc*;
    it contains an array of floating-point values representing one person’s attempt
    at performing a circle gesture. In the `for` loop, we step through this data and
    write each value into the input. We write only as many `float` values as the input
    tensor can hold.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 常量`g_circle_micro_f9643d42_nohash_4_data`在*circle_micro_features_data.cc*中定义；它包含一个浮点值数组，表示一个人尝试执行圆形手势的数据。在`for`循环中，我们遍历这些数据，并将每个值写入输入。我们只写入与输入张量容量相符的`float`值。
- en: 'Next, we run inference in the familiar manner:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们以熟悉的方式运行推理：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Afterward, we investigate our output tensor to ensure that it’s the shape we
    expect:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们调查输出张量以确保它的形状符合我们的预期：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It should have two dimensions: a single-element wrapper, and a set of four
    values that indicate our four probabilities (“wing,” “ring,” “slope,” and unknown).
    Each of these will be a 32-bit floating-point number.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该具有两个维度：一个单元素包装器和一组四个值，表示我们的四个概率（“翅膀”，“环”，“斜坡”和未知）。每个值都是32位浮点数。
- en: 'We can then test our data to make sure the inference result is what we expect.
    We passed in data for a circle gesture, so we expect the “ring” score to be the
    highest:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以测试我们的数据，以确保推理结果符合我们的预期。我们传入了圆形手势的数据，因此我们期望“环”得分最高：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then repeat this entire process for the “slope” gesture:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为“斜坡”手势重复整个过程：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And that’s it! We’ve seen how we can run inference on raw accelerometer data.
    Like the previous example, the fact that we can avoid preprocessing keeps things
    nice and simple.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们已经看到了如何对原始加速度计数据运行推理。与之前的示例一样，我们可以避免预处理，使事情变得简单明了。
- en: 'To run this test, use the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此测试，请使用以下命令：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Accelerometer Handler
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加速度计处理程序
- en: Our next test shows the interface for the accelerometer handler. This component’s
    task is to populate the input tensor with accelerometer data for each inference.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个测试展示了加速度计处理程序的接口。该组件的任务是为每次推理填充输入张量的加速度计数据。
- en: Because both of these things depend on how the device’s accelerometer works,
    a different accelerometer handler implementation is provided for each individual
    device. We’ll walk through these implementations later on, but for now, the tests
    located in [*accelerometer_handler_test.cc*](https://oreil.ly/MwM7g) will show
    us how the handler should be called.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个因素取决于设备的加速计工作方式，因此为每个单独的设备提供了不同的加速计处理程序实现。我们稍后将介绍这些实现，但现在，位于[*accelerometer_handler_test.cc*](https://oreil.ly/MwM7g)中的测试将展示我们应该如何调用处理程序。
- en: 'The first test is very simple:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试非常简单：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `SetupAccelerometer()` function performs the one-time setup that needs to
    happen in order to obtain values from the accelerometer. The test shows how the
    function should be called (with a pointer to an `ErrorReporter`) and that it returns
    a `TfLiteStatus` indicating that setup was successful.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupAccelerometer()`函数执行一次性设置，以便从加速计获取值。测试展示了如何调用该函数（带有指向`ErrorReporter`的指针），以及它返回一个指示设置成功的`TfLiteStatus`。'
- en: 'The next test shows how the accelerometer handler is used to fill the input
    tensor with data:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试展示了如何使用加速计处理程序填充输入张量的数据：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we prepare a `float` array named `input` to simulate the model’s input
    tensor. Because there are 128 three-axis readings, it has a total size of 384
    bytes (128 * 3). We initialize every value in the array to `0.0`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们准备一个名为`input`的`float`数组来模拟模型的输入张量。因为有128个三轴读数，所以总大小为384字节（128 * 3）。我们将数组中的每个值初始化为`0.0`。
- en: We then call `ReadAccelerometer()`. We provide an `ErrorReporter` instance,
    the array to which we want data to be written (`input`), and the total amount
    of data that we want to obtain (384 bytes). The final argument is a Boolean flag
    that instructs `ReadAccelerometer()` whether to clear the buffer before reading
    more data, which needs to be done after a gesture has been successfully recognized.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`ReadAccelerometer()`。我们提供一个`ErrorReporter`实例，我们希望数据写入的数组（`input`），以及我们想要获取的数据总量（384字节）。最后一个参数是一个布尔标志，指示`ReadAccelerometer()`在读取更多数据之前是否清除缓冲区，这需要在成功识别手势后执行。
- en: When called, the `ReadAccelerometer()` function attempts to write 384 bytes
    of data to the array passed to it. If the accelerometer has only just started
    collecting data, the full 384 bytes might not yet be available. In this case,
    the function will do nothing and return a value of `false`. We can use this to
    avoid running inference if no data is available.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`ReadAccelerometer()`函数时，会尝试将384字节的数据写入传递给它的数组。如果加速计刚开始收集数据，可能还没有完整的384字节可用。在这种情况下，函数将不执行任何操作，并返回一个值`false`。我们可以利用这一点，避免在没有数据可用时运行推理。
- en: The dummy implementation of the accelerometer handler, located in [*accelerometer_handler.cc*](https://oreil.ly/MwM7g),
    simulates another reading being available every time it is called. By calling
    it 127 additional times we ensure it will have accrued enough data to start returning
    `true`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 位于[*accelerometer_handler.cc*](https://oreil.ly/MwM7g)中的加速计处理程序的虚拟实现模拟每次调用时都有另一个读数可用。通过调用它额外127次，我们确保它将累积足够的数据开始返回`true`。
- en: 'To run these tests, use the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些测试，请使用以下命令：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Gesture Predictor
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手势预测器
- en: After inference has occurred, our output tensor will be filled with probabilities
    that indicate to us which gesture, if any, was made. However, because machine
    learning is not an exact science, there’s a chance that any single inference might
    result in a false positive.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 推理完成后，我们的输出张量将填充概率，告诉我们哪种手势（如果有的话）被执行。然而，由于机器学习并非精确科学，任何单个推理都有可能导致误报。
- en: To reduce the impact of false positives, we can stipulate that for a gesture
    to be recognized, it must have been detected in at least a certain number of consecutive
    inferences. Given that we run inference multiple times per second, we can quickly
    determine whether a result is valid. This is the job of the gesture predictor.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少误报的影响，我们可以规定要识别手势，必须在至少一定数量的连续推理中检测到。鉴于我们每秒运行多次推理，我们可以快速确定结果是否有效。这是手势预测器的工作。
- en: 'It defines a single function, `PredictGesture()`, which takes the model’s output
    tensor as its input. To determine whether a gesture has been detected, the function
    does two things:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了一个名为`PredictGesture()`的函数，以模型的输出张量作为输入。为了确定是否检测到手势，该函数执行两项操作：
- en: Checks whether the gesture’s probability meets a minimum threshold
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查手势的概率是否达到最小阈值
- en: Checks whether the gesture has been consistently detected over a certain number
    of inferences
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查手势是否在一定数量的推理中被一致地检测到
- en: 'The minimum number of inferences required varies per gesture because some take
    longer to perform than others. It also varies per device, given that faster devices
    are able to run inference more frequently. The default values, tuned for the SparkFun
    Edge board, are located in [*constants.cc*](https://oreil.ly/ktGgw):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的最小推理次数因手势而异，因为有些手势执行时间较长。它还因设备而异，因为更快的设备能够更频繁地运行推理。为SparkFun Edge开发板调整的默认值位于[*constants.cc*](https://oreil.ly/ktGgw)中：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The values are defined in the same order as the gestures appear in the model’s
    output tensor. Other platforms, such as Arduino, have device-specific versions
    of this file that contain values tuned to their own performance.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值的定义顺序与模型输出张量中手势出现的顺序相同。其他平台，如Arduino，有包含针对其性能调整的设备特定版本的文件。
- en: Let’s walk through the code in [*gesture_predictor.cc*](https://oreil.ly/f3I6U)
    to see how these are used.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们浏览一下[*gesture_predictor.cc*](https://oreil.ly/f3I6U)中的代码，看看这些是如何使用的。
- en: 'First, we define some variables that are used to keep track of the last gesture
    seen and how many of the same gesture have been recorded in a row:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一些变量，用于跟踪上次看到的手势以及连续记录的相同手势数量：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we define the `PredictGesture()` function and determine whether any of
    the gesture categories had a probability of greater than 0.8 in the most recent
    inference:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`PredictGesture()`函数，并确定最近推断中是否有任何手势类别的概率大于0.8：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We use `this_predict` to store the index of the gesture that was predicted.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`this_predict`来存储预测到的手势的索引。
- en: 'The variable `continuous_count` is used to track how many times the most recently
    spotted gesture has been predicted in a row. If none of the gesture categories
    meet the probability threshold of 0.8, we reset any ongoing detection process
    by setting `continuous_count` to `0`, and `last_predict` to `3` (the index of
    the “unknown” category), indicating that the most recent result was no known gesture:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`continuous_count`用于跟踪最近发现的手势连续预测的次数。如果没有手势类别满足0.8的概率阈值，我们通过将`continuous_count`设置为`0`和`last_predict`设置为`3`（“未知”类别的索引）来重置任何正在进行的检测过程，表示最近的结果不是已知手势：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, if the most recent prediction aligns with the previous one, we increment
    `continuous_count`. Otherwise, we reset it to `0`. We also store the most recent
    prediction in `last_predict`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果最近的预测与之前的预测一致，我们增加`continuous_count`。否则，我们将其重置为`0`。我们还将最近的预测存储在`last_predict`中：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the next section of `PredictGesture()`, we use `should_continuous_count`
    to check whether the current gesture has met its threshold yet. If it hasn’t,
    we return a `3`, indicating an unknown gesture:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PredictGesture()`的下一部分中，我们使用`should_continuous_count`来检查当前手势是否已经达到其阈值。如果没有，我们返回一个`3`，表示一个未知手势：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we get past this point, it means that we’ve confirmed a valid gesture. In
    this case, we reset all of our variables:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过了这一点，这意味着我们确认了一个有效的手势。在这种情况下，我们重置所有变量：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The function ends by returning the current prediction. This will be passed by
    our main loop into the output handler, which displays the result to the user.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通过返回当前预测结束。这将由我们的主循环传递给输出处理程序，显示结果给用户。
- en: 'The gesture predictor’s tests are located in [*gesture_predictor_test.cc*](https://oreil.ly/5BZzt).
    The first test demonstrates a successful prediction:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 手势预测器的测试位于[*gesture_predictor_test.cc*](https://oreil.ly/5BZzt)中。第一个测试展示了一个成功的预测：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `PredictGesture()` function is fed a set of probabilities that strongly
    indicate that the first category should be matched. However, until it has been
    called with these probabilities `threshold` number of times, it returns a `3`,
    signifying an “unknown” result. After it has been called `threshold` number of
    times, it returns a positive prediction for category `0`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`PredictGesture()`函数被提供了一组概率，强烈表明第一个类别应该匹配。然而，在它被调用`threshold`次数之前，它返回一个`3`，表示一个“未知”结果。在它被调用`threshold`次数之后，它为类别`0`返回一个正面预测。'
- en: 'The next test shows what happens if a consecutive run of high probabilities
    for one category is interrupted by a high probability for a different category:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的测试展示了如果一个类别的连续高概率运行被另一个类别的高概率中断会发生什么：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, we feed in a set of consecutive high probabilities for category
    `0`, but not a sufficient number to meet the threshold. We then change the probabilities
    so that category `2` is the highest, which results in a category `3` prediction,
    signifying an “unknown” gesture.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们输入了一组连续的类别`0`高概率，但不足以满足阈值。然后我们改变概率，使类别`2`最高，这导致类别`3`的预测，表示一个“未知”手势。
- en: 'The final test shows how `PredictGesture()` ignores probabilities that are
    below its threshold. In a loop, we feed in exactly the correct number of predictions
    to meet category `0`’s threshold. However, although category `0` has the highest
    probability, its value is 0.7, which is below `PredictGesture()`’s internal threshold
    of 0.8\. This results in a category `3` “unknown” prediction:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的测试展示了`PredictGesture()`如何忽略低于其阈值的概率。在循环中，我们输入了恰好正确数量的预测以满足类别`0`的阈值。然而，尽管类别`0`的概率最高，但其值为0.7，低于`PredictGesture()`的内部阈值0.8。这导致类别`3`的“未知”预测：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To run these tests, use the following command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些测试，请使用以下命令：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The Output Handler
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出处理程序
- en: 'The output handler is very simple; it just takes the class index returned by
    `PredictGesture()` and displays the results to the user. Its test, in [*output_handler_test.cc*](https://oreil.ly/QWkeL),
    shows its interface:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 输出处理程序非常简单；它只是获取`PredictGesture()`返回的类索引，并将结果显示给用户。在[*output_handler_test.cc*](https://oreil.ly/QWkeL)中展示了它的接口：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To run this test, use the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此测试，请使用以下命令：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Detecting Gestures
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测手势
- en: 'All of these components come together in [*main_functions.cc*](https://oreil.ly/ggNtD),
    which contains the core logic of our program. First it sets up the usual variables,
    along with some extras:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些组件都在[*main_functions.cc*](https://oreil.ly/ggNtD)中汇聚，其中包含我们程序的核心逻辑。首先设置通常的变量，以及一些额外的变量：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `input_length` variable stores the length of the model’s input tensor, and
    the `should_clear_buffer` variable is a flag that indicates whether the accelerometer
    handler’s buffer should be cleared the next time it runs. Clearing the buffer
    is done after a successful detection result in order to provide a clean slate
    for subsequent inferences.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`input_length`变量存储模型输入张量的长度，`should_clear_buffer`变量是一个标志，指示加速度计处理程序的缓冲区在下次运行时是否应该被清除。在成功检测结果之后清除缓冲区，以便为后续推断提供一个干净的基础。'
- en: 'Next, the `setup()` function does all of the usual housekeeping so that we’re
    ready to run inference:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`setup()`函数执行所有通常的清理工作，以便我们准备好运行推断：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The more interesting stuff happens in the `loop()` function, which is still
    very simple:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的事情发生在`loop()`函数中，这仍然非常简单：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, we attempt to read some values from the accelerometer. After the attempt,
    we set `should_clear_buffer` to `false` to ensure that we stop trying to clear
    it for the time being.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们尝试从加速度计中读取一些值。尝试之后，我们将`should_clear_buffer`设置为`false`，以确保暂时停止尝试清除它。
- en: If obtaining new data was unsuccessful, `ReadAccelerometer()` will return a
    `false` value, and we’ll return from the `loop()` function so that we can try
    again the next time it is called.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果获取新数据失败，`ReadAccelerometer()` 将返回一个 `false` 值，然后我们将从 `loop()` 函数返回，以便下次调用时再次尝试。
- en: If the value returned by `ReadAccelerometer()` is `true`, we’ll run inference
    on our freshly populated input tensor. We pass the result into `PredictGesture()`,
    which gives us the index of which gesture was detected. If the index is less than
    `3`, the gesture was valid, so we set the `should_clear_buffer` flag in order
    to clear the buffer next time `ReadAccelerometer()` is called. We then call `HandleOutput()`
    to report any results to the user.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `ReadAccelerometer()` 返回的值是 `true`，我们将在我们新填充的输入张量上运行推断。我们将结果传递给 `PredictGesture()`，它会给出检测到的手势的索引。如果索引小于
    `3`，则手势有效，因此我们设置 `should_clear_buffer` 标志，以便在下次调用 `ReadAccelerometer()` 时清除缓冲区。然后我们调用
    `HandleOutput()` 报告任何结果给用户。
- en: 'Over in *main.cc*, the `main()` function kicks off our program, runs `setup()`,
    and calls the `loop()` function in a loop:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *main.cc* 中，`main()` 函数启动我们的程序，运行 `setup()`，并在循环中调用 `loop()` 函数：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And that’s it! To build the program on your development computer, use the following
    command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！要在开发计算机上构建程序，请使用以下命令：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, to run the program, enter the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要运行程序，请输入以下内容：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The program won’t produce any output, because there isn’t any accelerometer
    data available, but you can confirm that it builds and runs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序不会产生任何输出，因为没有可用的加速度计数据，但您可以确认它构建并运行。
- en: Next, we walk through the code for each platform that captures accelerometer
    data and produces an output. We also show how to deploy and run the application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将逐个平台的代码，该代码捕获加速度计数据并生成输出。我们还展示如何部署和运行应用程序。
- en: Deploying to Microcontrollers
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到微控制器
- en: 'In this section, we’ll deploy our code to two devices:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将将代码部署到两个设备：
- en: '[Arduino Nano 33 BLE Sense](https://oreil.ly/6qlMD)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Arduino Nano 33 BLE Sense](https://oreil.ly/6qlMD)'
- en: '[SparkFun Edge](https://oreil.ly/-hoL-)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SparkFun Edge](https://oreil.ly/-hoL-)'
- en: Let’s begin with the Arduino implementation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Arduino 实现开始。
- en: Arduino
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino
- en: The Arduino Nano 33 BLE Sense has a three-axis accelerometer as well as Bluetooth
    support, and is small and lightweight—ideal for building a magic wand.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino Nano 33 BLE Sense 具有三轴加速度计以及蓝牙支持，体积小巧轻便，非常适合制作魔杖。
- en: Let’s walk through the Arduino-specific implementations of some of the application’s
    key files.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解一些应用程序关键文件的 Arduino 特定实现。
- en: Arduino constants
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Arduino 常量
- en: 'The constant `kConsecutiveInferenceThresholds` is redefined in the file [*arduino/constants.cc*](https://oreil.ly/5bBt0):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 常量 `kConsecutiveInferenceThresholds` 在文件 [*arduino/constants.cc*](https://oreil.ly/5bBt0)
    中重新定义：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As mentioned earlier in the chapter, this constant stores the number of consecutive
    positive inferences required for each gesture to be considered detected. The number
    depends on how many inferences are run per second, which varies per device. Because
    the default numbers were calibrated for the SparkFun Edge, the Arduino implementation
    needs its own set of numbers. You can modify these thresholds to make inference
    more difficult or easier to trigger, but setting them too low will result in false
    positives.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面提到的，此常量存储了每个手势被视为检测到所需的连续正推断数量。该数字取决于每秒运行多少次推断，这取决于设备。因为默认数字是为 SparkFun
    Edge 校准的，Arduino 实现需要自己的一组数字。您可以修改这些阈值，使推断更难或更容易触发，但将它们设置得太低将导致误报。
- en: Capturing accelerometer data on Arduino
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Arduino 上捕获加速度计数据
- en: The Arduino accelerometer handler is located in [*arduino/accelerometer_handler.cc*](https://oreil.ly/jV_Qm).
    It has the task of capturing data from the accelerometer and writing it to the
    model’s input buffer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 加速度计处理程序位于 [*arduino/accelerometer_handler.cc*](https://oreil.ly/jV_Qm)。它的任务是从加速度计捕获数据并将其写入模型的输入缓冲区。
- en: The model we are using was trained using data from the SparkFun Edge board.
    The Edge’s accelerometer provides a set of readings at a rate of 25 Hz, or 25
    times per second. To work correctly, it needs to be fed data that is captured
    at the same rate. As it turns out, the accelerometer on the Arduino Nano 33 BLE
    Sense board returns measurements at a rate of 119 Hz. This means that in addition
    to capturing data, we need to *downsample* it to suit our model.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的模型是使用 SparkFun Edge 板的数据进行训练的。Edge 的加速度计以每秒 25 次的速率提供一组读数。为了正常工作，它需要提供以相同速率捕获的数据。事实证明，Arduino
    Nano 33 BLE Sense 板上的加速度计以每秒 119 次的速率返回测量值。这意味着除了捕获数据外，我们还需要对其进行 *下采样* 以适应我们的模型。
- en: Although it sounds very technical, downsampling is actually pretty easy. To
    reduce the sample rate of a signal, we can just throw away some of the data. We
    look at how this works in the following code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管听起来非常技术化，但下采样实际上非常简单。为了降低信号的采样率，我们可以丢弃一些数据。我们将在以下代码中看到这是如何工作的。
- en: 'First the implementation includes its own header file, along with some others:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，实现包括自己的头文件，以及一些其他文件：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The file *Arduino.h* provides access to some basic features of the Arduino platform.
    The file *Arduino_LSM9DS1.h* is part of the [Arduino_LSM9DS1](https://oreil.ly/eb3Zs)
    library, which we’ll be using to communicate with the board’s accelerometer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *Arduino.h* 提供对 Arduino 平台一些基本功能的访问。文件 *Arduino_LSM9DS1.h* 是 [Arduino_LSM9DS1](https://oreil.ly/eb3Zs)
    库的一部分，我们将使用它与板的加速度计通信。
- en: 'Next, we set up some variables:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置一些变量：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These include a buffer we’ll be filling with our data, `save_data`, along with
    some variables for tracking our current position in the buffer and whether we
    have enough data to start running inference. The most interesting two variables,
    `sample_every_n` and `sample_skip_counter`, are used in the downsampling process.
    We’ll look at this more closely in a moment.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包括我们将用数据填充的缓冲区 `save_data`，以及一些用于跟踪缓冲区中当前位置和是否有足够数据开始运行推断的变量。最有趣的两个变量 `sample_every_n`
    和 `sample_skip_counter` 用于下采样过程。我们稍后将更仔细地看一下这个。
- en: 'Next in the file, the `SetupAccelerometer()` function is called by the program’s
    main loop to get the board ready to capture data:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来在文件中，程序的主循环调用`SetupAccelerometer()`函数，准备好捕获数据的板：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Because we’ll be outputting a message to indicate that everything is ready to
    go, the first thing it does is make sure that the device’s serial port is ready.
    It then switches on the *inertial measurement unit* (IMU), which is the electronic
    component that contains the accelerometer. The `IMU` object comes from the Arduino_LSM9DS1
    library.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将输出一条消息来指示一切都准备就绪，它首先确保设备的串行端口准备就绪。然后打开*惯性测量单元*（IMU），这是包含加速度计的电子组件。`IMU`对象来自Arduino_LSM9DS1库。
- en: 'The next step is to start thinking about downsampling. We first query the IMU
    library to determine the board’s sample rate. When we have that number, we divide
    it by our target sample rate, which is defined in `kTargetHz` as part of [*constants.h*](https://oreil.ly/rQaSw):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是开始考虑降采样。我们首先查询IMU库以确定板的采样率。当我们得到这个数字后，我们将其除以我们的目标采样率，该目标采样率在[*constants.h*](https://oreil.ly/rQaSw)中的`kTargetHz`中定义：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our target rate is 25 Hz, and the board’s sample rate is 119 Hz; thus, the
    result of our division is 4.76\. This lets us know how many of the 119 Hz samples
    we need to keep in order to attain the target sample rate of 25 Hz: 1 sample in
    every 4.76.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标速率是25 Hz，板的采样率是119 Hz；因此，我们的除法结果是4.76。这让我们知道我们需要保留多少个119 Hz样本，以达到25 Hz的目标采样率：每4.76个样本中的1个。
- en: Because keeping a fractional number of samples is difficult, we use the `roundf()`
    function to round to the nearest number, 5\. To downsample our signal, then, we
    need to keep one in every five measurements. This will result in an effective
    sample rate of 23.8 Hz, which is a close enough approximation that our model should
    work well. We store this value in the `sample_every_n` variable for use later.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因为保留一个分数个样本很困难，我们使用`roundf()`函数四舍五入到最近的数字5。因此，为了降采样我们的信号，我们需要保留每五个测量值中的一个。这将导致一个有效的采样率为23.8
    Hz，这是一个足够接近的近似值，使我们的模型应该能够很好地工作。我们将这个值存储在`sample_every_n`变量中以供以后使用。
- en: 'Now that we’ve established the parameters of our downsampling, we give the
    user a message to inform them that the application is ready to go and then return
    from the `SetupAccelerometer()` function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了降采样的参数，我们向用户发送一条消息，告诉他们应用程序已经准备好了，然后从`SetupAccelerometer()`函数返回：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next up, we define `ReadAccelerometer()`. This function is tasked with capturing
    new data and writing it to the model’s output tensor. It begins with some code
    that is used to clear its internal buffer after a gesture has been successfully
    recognized, cleaning the slate for any subsequent gestures:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`ReadAccelerometer()`。这个函数的任务是捕获新数据并将其写入模型的输出张量。它从一些代码开始，用于在成功识别手势后清除其内部缓冲区，为任何后续手势做好准备：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we use the IMU library to check for available data in a loop. If there’s
    data available, we read it:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用IMU库在循环中检查是否有可用数据。如果有数据可用，我们读取它：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The accelerometer on the Arduino Nano 33 BLE Sense board is equipped with something
    called a [*FIFO buffer*](https://oreil.ly/kFEa0). This is a special memory buffer,
    located on the accelerometer itself, which holds the most recent 32 measurements.
    Because it’s part of the accelerometer hardware, the FIFO buffer continues to
    accrue measurements even while our application code is running. If it weren’t
    for the FIFO buffer, we might lose a lot of data, meaning we wouldn’t have an
    accurate record of the gestures being made.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino Nano 33 BLE Sense板上的加速度计配备有一个称为[*FIFO缓冲区*](https://oreil.ly/kFEa0)的东西。这是一个特殊的内存缓冲区，位于加速度计本身上，保存最近的32个测量值。由于它是加速度计硬件的一部分，FIFO缓冲区在我们的应用程序代码运行时继续积累测量值。如果没有FIFO缓冲区，我们可能会丢失很多数据，这意味着我们将无法准确记录所做手势。
- en: When we call `IMU.accelerationAvailable()`, we are querying the accelerometer
    to see whether new data is available in its FIFO buffer. Using our loop, we continue
    to read all the data from the buffer until there is none remaining.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`IMU.accelerationAvailable()`时，我们正在查询加速度计，看看其FIFO缓冲区中是否有新数据可用。使用我们的循环，我们继续从缓冲区中读取所有数据，直到没有剩余数据为止。
- en: 'Next up, we implement our super-simple downsampling algorithm:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现我们超级简单的降采样算法：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Our approach is to keep one in every *n* samples, where *n* is the number stored
    in `sample_every_n`. To do this, we maintain a counter, `sample_skip_counter`,
    which lets us know how many samples have been read since the last one we kept.
    For every measurement we read, we check whether it is the *n*th. If it isn’t,
    we `continue` the loop without writing the data anywhere, effectively throwing
    it away. This simple process leads to our data being downsampled.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法是保留每*n*个样本中的一个，其中*n*存储在`sample_every_n`中。为了做到这一点，我们维护一个计数器，`sample_skip_counter`，它让我们知道自上次保留的样本以来已经读取了多少个样本。对于我们读取的每个测量值，我们检查它是否是第*n*个。如果不是，我们将`continue`循环，而不将数据写入任何地方，有效地将其丢弃。这个简单的过程导致我们的数据被降采样。
- en: 'If execution gets further than this point, we’re planning on keeping the data.
    To do this, we write it to consecutive positions in our `save_data` buffer:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行超过这一点，我们计划保留数据。为了做到这一点，我们将数据写入我们的`save_data`缓冲区中的连续位置：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Our model accepts accelerometer measurements in the order *x*, *y*, *z*. You’ll
    notice here that we’re writing the *y* value to the buffer before the *x*. This
    is because our model was trained on data captured on the SparkFun Edge board,
    whose accelerometer has its axes pointing in different physical directions to
    the one on the Arduino. This difference means that the SparkFun Edge’s x-axis
    is equivalent to the Arduino’s y-axis, and vice versa. By swapping these axes’
    data in our code, we can make sure our model is being fed data that it can understand.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型按顺序接受加速度计测量值 *x*、*y*、*z*。您会注意到这里我们在将 *x* 值写入缓冲区之前将 *y* 值写入。这是因为我们的模型是在
    SparkFun Edge 板上捕获的数据进行训练的，其加速度计的轴指向的物理方向与 Arduino 上的不同。这种差异意味着 SparkFun Edge
    的 x 轴等同于 Arduino 的 y 轴，反之亦然。通过在我们的代码中交换这些轴的数据，我们可以确保我们的模型正在接收可以理解的数据。
- en: 'The final few lines of our loop do some housework, setting some state variables
    that are used in our loop:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们循环的最后几行做一些家务，设置一些在我们循环中使用的状态变量：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We reset our downsampling counter, make sure we don’t run off the end of our
    sample buffer, and set a flag to indicate that new data has been saved.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重置我们的降采样计数器，确保我们不会超出样本缓冲区的末尾，并设置一个标志以指示已保存新数据。
- en: 'After grabbing this new data, we do some more checks. This time, we’re making
    sure that we have sufficient data to perform an inference. If not, or if new data
    was not captured this time around, we return from the function without doing anything:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 获取这些新数据后，我们进行更多的检查。这次，我们确保我们有足够的数据来执行推理。如果没有，或者这次没有捕获到新数据，我们将在不执行任何操作的情况下从函数中返回：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: By returning `false` when there’s no new data, we make sure the calling function
    knows not to bother running inference.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有新数据时返回`false`，我们确保调用函数知道不要运行推理。
- en: 'If we got this far, we’ve obtained some new data. We copy the appropriate amount
    of data, including our new samples, to the input tensor:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们走到这一步，我们已经获得了一些新数据。我们复制适当数量的数据，包括我们的新样本，到输入张量中：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: And that’s it! We’ve populated the input tensor and are ready to run inference.
    After inference has been run, the results are passed into the gesture predictor,
    which determines whether a valid gesture has been spotted. The result is passed
    into the output handler, which we walk through next.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们已经填充了输入张量，并准备运行推理。推理运行后，结果被传递到手势预测器，该预测器确定是否已经发现了有效手势。结果被传递到输出处理程序，接下来我们将详细介绍。
- en: Responding to gestures on Arduino
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Arduino 上响应手势
- en: 'The output handler is defined in [*arduino/output_handler.cc*](https://oreil.ly/kdVLW).
    It’s nice and simple: all it does is log information to the serial port depending
    on which gesture was detected, and toggle the board’s LED each time inference
    is run.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 输出处理程序在[*arduino/output_handler.cc*](https://oreil.ly/kdVLW)中定义。它非常简单：根据检测到的手势记录信息到串行端口，并在每次运行推理时切换板上的
    LED。
- en: 'The first time the function runs, the LED is configured for output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 函数第一次运行时，LED被配置为输出：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, the LED is toggled on and off with each inference:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，LED 在每次推理时切换开关：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, we print some beautiful ASCII art depending on which gesture was matched:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们根据匹配的手势打印一些漂亮的 ASCII 艺术：
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It’s difficult to read now, but you’ll be rewarded with the output’s full glory
    when you deploy the application to your board.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很难阅读，但当您将应用程序部署到您的板上时，您将获得完整的输出荣耀。
- en: Running the example
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'To deploy this example, here’s what we’ll need:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署此示例，我们需要以下内容：
- en: An Arduino Nano 33 BLE Sense board
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Arduino Nano 33 BLE Sense 板
- en: A micro-USB cable
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 micro-USB 电缆
- en: The Arduino IDE
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino IDE
- en: Tip
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: There’s always a chance that the build process might have changed since this
    book was written, so check [*README.md*](https://oreil.ly/Zkd3x) for the latest
    instructions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 建议检查[*README.md*](https://oreil.ly/Zkd3x)以获取最新说明，因为构建过程可能会在本书编写后发生变化。
- en: The projects in this book are available as example code in the TensorFlow Lite
    Arduino library. If you haven’t already installed the library, open the Arduino
    IDE and select Manage Libraries from the Tools menu. In the window that appears,
    search for and install the library named TensorFlowLite. You should be able to
    use the latest version, but if you run into issues, the version that was tested
    with this book is 1.14-ALPHA.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的项目作为 TensorFlow Lite Arduino 库中的示例代码可用。如果您尚未安装该库，请打开 Arduino IDE 并从工具菜单中选择管理库。在出现的窗口中，搜索并安装名为
    TensorFlowLite 的库。您应该能够使用最新版本，但如果遇到问题，本书测试的版本是 1.14-ALPHA。
- en: Note
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can also install the library from a *.zip* file, which you can either [download](https://oreil.ly/blgB8)
    from the TensorFlow Lite team or generate yourself using the TensorFlow Lite for
    Microcontrollers Makefile. If you’d prefer to do the latter, see [Appendix A](app01.xhtml#appendix_arduino_library_zip).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从 *.zip* 文件安装库，您可以从 TensorFlow Lite 团队[下载](https://oreil.ly/blgB8)或使用 TensorFlow
    Lite for Microcontrollers Makefile 生成自己的 *.zip* 文件。如果您更喜欢后者，请参阅[附录 A](app01.xhtml#appendix_arduino_library_zip)。
- en: After you’ve installed the library, the `magic_wand` example will show up in
    the File menu under Examples→Arduino_TensorFlowLite, as shown in [Figure 11-5](#arduino_examples_magic_wand).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完库后，“magic_wand”示例将显示在文件菜单下的 Examples→Arduino_TensorFlowLite 中，如[图 11-5](#arduino_examples_magic_wand)所示。
- en: Click “magic_wand” to load the example. It will appear as a new window, with
    a tab for each of the source files. The file in the first tab, *magic_wand*, is
    equivalent to the *main_functions.cc* we walked through earlier.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“magic_wand”加载示例。它将显示为一个新窗口，每个源文件都有一个选项卡。第一个选项卡中的文件 *magic_wand* 相当于我们之前介绍的
    *main_functions.cc*。
- en: Note
  id: totrans-245
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[“Running the Example”](ch06.xhtml#hello_world_running_the_example) already
    explained the structure of the Arduino example, so we won’t cover it again here.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[“运行示例”](ch06.xhtml#hello_world_running_the_example)已经解释了 Arduino 示例的结构，所以我们不会在这里再次介绍。'
- en: '![Screenshot of the ''Examples'' menu](Images/timl_0604.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![“示例”菜单的屏幕截图](Images/timl_0604.png)'
- en: Figure 11-5\. The Examples menu
  id: totrans-248
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-5\. 示例菜单
- en: In addition to the TensorFlow library, we also need to install and patch the
    Arduino_LSM9DS1 library. By default, the library doesn’t enable the FIFO buffer
    that is required by the example, so we have to make some modifications to its
    code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 除了TensorFlow库，我们还需要安装和修补Arduino_LSM9DS1库。默认情况下，该库不启用示例所需的FIFO缓冲区，因此我们需要对其代码进行一些修改。
- en: In the Arduino IDE, select Tools→Manage Libraries and then search for Arduino_LSM9DS1\.
    To ensure the following instructions work, you must install version 1.0.0 of the
    driver.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arduino IDE中，选择Tools→Manage Libraries，然后搜索Arduino_LSM9DS1。为了确保以下说明有效，你必须安装驱动程序的1.0.0版本。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It’s possible that the driver might have been fixed by the time you are reading
    this chapter. You can find the latest deployment instructions in [*README.md*](https://oreil.ly/pk61J).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 可能在你阅读本章时，驱动程序已经修复。你可以在[*README.md*](https://oreil.ly/pk61J)中找到最新的部署说明。
- en: The driver will be installed to your *Arduino/libraries* directory, in the subdirectory
    *Arduino_LSM9DS1*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序将安装到*Arduino/libraries*目录中，子目录为*Arduino_LSM9DS1*。
- en: 'Open the *Arduino_LSM9DS1/src/LSM9DS1.cpp* driver source file and then go to
    the function named `LSM9DS1Class::begin()`. Insert the following lines at the
    end of the function, immediately before the `return 1` statement:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*Arduino_LSM9DS1/src/LSM9DS1.cpp*驱动源文件，然后转到名为`LSM9DS1Class::begin()`的函数。在函数末尾插入以下行，即在`return
    1`语句之前立即插入：
- en: '[PRE47]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, locate the function named `LSM9DS1Class::accelerationAvailable()`. You
    will see the following lines:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，找到名为`LSM9DS1Class::accelerationAvailable()`的函数。你会看到以下几行：
- en: '[PRE48]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Comment out those lines and then replace them with the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注释掉那些行，然后用以下内容替换它们：
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Save the file. Patching is now complete!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件。补丁现在已经完成！
- en: To run the example, plug in your Arduino device via USB. On the Tools menu,
    make sure that the correct device type is selected from the Board drop-down list,
    as shown in [Figure 11-6](#arduino_board_dropdown_3).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，请通过USB插入Arduino设备。在工具菜单中，确保从Board下拉列表中选择正确的设备类型，如[图11-6](#arduino_board_dropdown_3)所示。
- en: If your device’s name doesn’t appear in the list, you’ll need to install its
    support package. To do this, click Boards Manager and then, in the window that
    appears, search for your device and install the latest version of the corresponding
    support package.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的设备名称不在列表中，你需要安装支持包。要做到这一点，点击Boards Manager，然后在弹出的窗口中搜索你的设备并安装相应支持包的最新版本。
- en: Next, make sure the device’s port is selected in the Port drop-down, also in
    the Tools menu, as demonstrated in [Figure 11-7](#arduino_port_dropdown_3).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确保设备的端口在Port下拉列表中被选中，也在Tools菜单中，如[图11-7](#arduino_port_dropdown_3)所示。
- en: '![Screenshot of the ''Board'' dropdown](Images/timl_0605.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![“Board”下拉列表的截图](Images/timl_0605.png)'
- en: Figure 11-6\. The Board drop-down list
  id: totrans-265
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-6\. Board下拉列表
- en: '![Screenshot of the ''Port'' dropdown](Images/timl_0606.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![“端口”下拉列表的截图](Images/timl_0606.png)'
- en: Figure 11-7\. The Port drop-down list
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-7\. 端口下拉列表
- en: Finally, click the upload button in the Arduino window (highlighted in white
    in [Figure 11-8](#arduino_upload_button_3)) to compile and upload the code to
    your Arduino device.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Arduino窗口中点击上传按钮（在[图11-8](#arduino_upload_button_3)中用白色标出）来编译并上传代码到你的Arduino设备。
- en: '![Screenshot of the upload button](Images/timl_0607.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![上传按钮的截图](Images/timl_0607.png)'
- en: Figure 11-8\. The upload button
  id: totrans-270
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-8\. 上传按钮
- en: After the upload has successfully completed, you should see the LED on your
    Arduino board begin to flash.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 上传成功后，你应该看到Arduino板上的LED开始闪烁。
- en: 'To try some gestures, select Serial Monitor in the Tools menu. You should initially
    see the following output:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试一些手势，请在Tools菜单中选择Serial Monitor。最初你应该看到以下输出：
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can now try to make some gestures. Hold the board up with one hand, with
    the components facing up and the USB adapter facing toward the left, as shown
    in [Figure 11-9](#gesture_holding_arduino).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以尝试做一些手势。用一只手举起板，组件朝上，USB适配器朝向左边，如[图11-9](#gesture_holding_arduino)所示。
- en: '![Photo of a hand holding an Arduino Nano 33 BLE Sense board](Images/timl_1109.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![一只手拿着Arduino Nano 33 BLE Sense板的照片](Images/timl_1109.png)'
- en: Figure 11-9\. How to hold the board while performing gestures
  id: totrans-276
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-9\. 手势执行时如何握住板
- en: '[Figure 11-10](#gesture_spells_2) presents a diagram showing how to perform
    each gesture. Because the model was trained on data collected when the board was
    attached to a wand, you might need a few tries to get them to work.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-10](#gesture_spells_2)展示了如何执行每个手势的图表。因为该模型是在连接到魔杖时收集数据进行训练的，你可能需要几次尝试才能使它们起作用。'
- en: '![Diagrams of the three magic wand gestures](Images/timl_1103.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![三个魔杖手势的图表](Images/timl_1103.png)'
- en: Figure 11-10\. The three magic wand gestures
  id: totrans-279
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-10\. 三个魔杖手势
- en: 'The easiest one to start with is “wing.” You should move your hand quickly
    enough that it takes around one second to perform the gesture. If you’re successful,
    you should see the following output, and the red LED should illuminate:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易开始的是“wing”。你应该快速移动手，大约需要一秒钟来执行手势。如果成功了，你应该看到以下输出，红色LED应该点亮：
- en: '[PRE51]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Congratulations, you’ve cast your first magic spell using the Arduino!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，你已经使用Arduino施展了你的第一个魔法咒语！
- en: Note
  id: totrans-283
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: At this point, you might choose to be creative and attach the board to the tip
    of a magic wand, at the point furthest from your hand. Any stick, ruler, or other
    household item with a length of around a foot (30 cm) should work well.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可以选择创意地将板连接到魔杖的尖端，离手最远的地方。任何长度约一英尺（30厘米）的棍子、尺子或其他家用物品都应该很好用。
- en: Make sure the device is attached firmly, and in the same orientation, with the
    components facing up and the USB adapter facing toward the left. And pick a rigid
    wand, not a flexible one; any wobbling will affect the accelerometer readings.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 确保设备牢固连接，并且朝向相同，组件朝上，USB适配器朝向左边。选择一个坚固的魔杖，而不是一个灵活的；任何摇晃都会影响加速度计读数。
- en: 'Next, try the “ring” gesture, by tracing a clockwise circle with your hand
    (or the tip of your wand). Again, aim to take around a second to perform the gesture.
    You should see the following appear, as if by magic:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试“环”手势，用手（或魔杖的尖端）画一个顺时针圆圈。再次，尽量花费一秒钟执行手势。您应该看到以下内容如同魔术般出现：
- en: '[PRE52]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For the final gesture, trace the corner of a triangle in the air. It’s best
    described by its ASCII art demonstration, shown here:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: SparkFun Edge
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Like any good magic spells, you might have to practice these a bit before you
    can perform them perfectly each time. You can see video demonstrations of the
    gestures in [*README.md*](https://oreil.ly/O1LqD).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何好的魔法咒语一样，您可能需要练习一下才能每次都完美地执行它们。您可以在[*README.md*](https://oreil.ly/O1LqD)中看到手势的视频演示。
- en: Making your own changes
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制作您自己的更改
- en: Now that you deployed the basic application, try playing around and making some
    changes to the code. Just edit the files in the Arduino IDE and save them, and
    then repeat the previous instructions to deploy your modified code to the device.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经部署了基本应用程序，请尝试玩耍并对代码进行一些更改。只需在Arduino IDE中编辑文件并保存，然后重复之前的说明以将修改后的代码部署到设备上。
- en: 'Here are a few things you could try:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以尝试的一些事情：
- en: Experiment with the threshold values in [*arduino/constants.cc*](https://oreil.ly/H49iS)
    to make the gestures easier or more difficult to perform (at the cost of more
    false positives or negatives).
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在[*arduino/constants.cc*](https://oreil.ly/H49iS)中调整阈值值，以使手势更容易或更难执行（以增加误报或漏报的代价）。
- en: Write a program on your computer that lets you perform tasks using physical
    gestures.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的计算机上编写一个程序，让您可以使用物理手势执行任务。
- en: Extend the program to transmit detection results via Bluetooth. There are examples
    showing how to do this included with the [ArduinoBLE library](https://oreil.ly/xW4SN),
    which you can download via the Arduino IDE.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展程序以通过蓝牙传输检测结果。有一些示例显示如何做到这一点，这些示例包含在[ArduinoBLE库](https://oreil.ly/xW4SN)中，您可以通过Arduino
    IDE下载。
- en: SparkFun Edge
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[*sparkfun_edge/accelerometer_handler.cc*](https://oreil.ly/yZi0v)中包含捕获加速度计数据的代码。其中很多是特定于设备的，但我们将跳过实现细节，专注于重要的内容。'
- en: The SparkFun Edge features a three-axis accelerometer, a battery mount, and
    Bluetooth support. This makes it perfect for a magic wand because it can operate
    wirelessly.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个手势，在空中画一个三角形的角。最好通过ASCII艺术演示来描述，如下所示：
- en: Capturing accelerometer data on SparkFun Edge
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 您会注意到调用一个名为`initAccelerometer()`的函数。这在[SparkFun Edge BSP的加速度计示例](https://oreil.ly/JC0b6)中定义，当我们的项目构建时，它作为依赖项被下载下来。它执行各种任务来打开和配置板载加速度计。
- en: The code that captures accelerometer data is located in [*sparkfun_edge/accelerometer_handler.cc*](https://oreil.ly/yZi0v).
    A lot of it is device-specific, but we’ll skip over the implementation details
    and focus on the important stuff.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获SparkFun Edge上的加速度计数据
- en: 'The first step involved with capturing accelerometer data is configuring the
    hardware. The `SetupAccelerometer()` function kicks this off by setting various
    low-level parameters required by the accelerometer:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获加速度计数据的第一步是配置硬件。`SetupAccelerometer()`函数通过设置加速度计所需的各种低级参数来启动这个过程：
- en: '[PRE54]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You’ll notice a call to a function named `initAccelerometer()`. This is defined
    in the [SparkFun Edge BSP’s accelerometer example](https://oreil.ly/JC0b6), which
    is pulled down as a dependency when our project is built. It performs various
    tasks to switch on and configure the board’s accelerometer.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: SparkFun Edge配有三轴加速度计、电池支架和蓝牙支持。这使它非常适合用作魔杖，因为它可以无线操作。
- en: 'After the accelerometer is running, we enable its [FIFO buffer](https://oreil.ly/kFEa0).
    This is a special memory buffer, located on the accelerometer itself, which holds
    the last 32 datapoints. By enabling it, we’re able to continue collecting accelerometer
    measurements even while our application code is busy running inference. The remainder
    of the function sets up the buffer and logs errors if anything goes wrong:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计运行后，我们启用其[FIFO缓冲区](https://oreil.ly/kFEa0)。这是一个特殊的内存缓冲区，位于加速度计本身上，可以保存最后32个数据点。通过启用它，我们能够在我们的应用程序代码忙于运行推断时继续收集加速度计测量数据。函数的其余部分设置缓冲区并在出现问题时记录错误：
- en: '[PRE55]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When we’re done with initialization, we can call the `ReadAccelerometer()` function
    to get the latest data. This will happen between every inference.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化完成后，我们可以调用`ReadAccelerometer()`函数来获取最新数据。这将发生在每次推断之间。
- en: 'First, if the `reset_buffer` argument is `true`, `ReadAccelerometer()` performs
    a reset of its data buffer. This is done after a valid gesture has been detected
    in order to provide a clean slate for further gestures. As part of this process,
    we use `am_util_delay_ms()` to make our code wait for 10 ms. Without this delay,
    the code often hangs when reading new data (as of this writing, the cause was
    unclear, but the TensorFlow open source project welcomes pull requests if you
    determine a better fix):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果`reset_buffer`参数为`true`，`ReadAccelerometer()`会对其数据缓冲区进行重置。在检测到有效手势后执行此操作，以便为进一步手势提供一个干净的基础。作为这个过程的一部分，我们使用`am_util_delay_ms()`让我们的代码等待10毫秒。没有这个延迟，当读取新数据时代码经常会挂起（截至目前为止，原因尚不清楚，但如果您确定有更好的修复方法，TensorFlow开源项目欢迎拉取请求）：
- en: '[PRE56]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After resetting the main buffer, `ReadAccelerometer()` checks whether there
    is any new data available in the accelerometer’s FIFO buffer. If there’s nothing
    available yet, we just return from the function:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 重置主缓冲区后，`ReadAccelerometer()`会检查加速度计的FIFO缓冲区中是否有任何新数据可用。如果还没有可用的数据，我们就从函数中返回：
- en: '[PRE57]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Our application’s main loop will continue calling, meaning as soon as there’s
    data available, we can move past this point.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序的主循环将继续调用，这意味着一旦有数据可用，我们就可以继续执行。
- en: 'The next part of the function loops through the new data and stores it in another,
    larger buffer. First we set up a special struct of type `axis3bit16_t`, designed
    to hold accelerometer data. We then call `lis2dh12_acceleration_raw_get()` to
    fill it with the next available measurement. This function will return zero if
    it fails, at which point we display an error:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的下一部分循环遍历新数据并将其存储在另一个更大的缓冲区中。首先，我们设置一个特殊类型为`axis3bit16_t`的结构体，用于保存加速度计数据。然后我们调用`lis2dh12_acceleration_raw_get()`来填充下一个可用的测量值。如果此函数失败，将返回零，此时我们会显示错误：
- en: '[PRE58]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If the measurement was obtained successfully, we convert it into milli-Gs,
    the unit of measurement expected by the model, and then write it into `save_data[]`,
    which is an array we’re using as a buffer to store values that we’ll use for inference.
    The values for each axis of the accelerometer are stored consecutively:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功获取了测量值，我们将其转换为毫G，这是模型期望的测量单位，然后将其写入`save_data[]`，这是一个我们用作缓冲区以存储将用于推理的值的数组。加速度计每个轴的值是连续存储的：
- en: '[PRE59]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Our `save_data[]` array can store 200 sets of three-axis values, so we set our
    `begin_index` counter back to 0 when it reaches 600.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`save_data[]`数组可以存储200组三轴值，因此当达到600时，我们将`begin_index`计数器设置回0。
- en: 'We’ve now incorporated all of the new data into our `save_data[]` buffer. Next,
    we check whether we have enough data to make a prediction. When testing the model,
    it was discovered that around a third of our total buffer size is the bare minimum
    amount of data that results in a reliable prediction; therefore, if we have at
    least this much data, we set the `pending_initial_data` flag to `false` (it defaults
    to `true`):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将所有新数据合并到我们的`save_data[]`缓冲区中。接下来，我们检查是否有足够的数据进行预测。在测试模型时，发现我们总缓冲区大小的三分之一是可靠预测所需的最少数据量；因此，如果我们至少有这么多数据，我们将`pending_initial_data`标志设置为`false`（默认为`true`）：
- en: '[PRE60]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, if there is still insufficient data to run an inference, we return `false`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果仍然没有足够的数据来运行推理，我们将返回`false`：
- en: '[PRE61]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If we got this far, there’s sufficient data in the buffer to run an inference.
    The final part of the function copies the requested data from the buffer into
    the `input` argument, which is a pointer to the model’s input tensor:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们走到这一步，缓冲区中有足够的数据来运行推理。函数的最后部分将请求的数据从缓冲区复制到`input`参数中，该参数是指向模型输入张量的指针：
- en: '[PRE62]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The variable `length` is an argument passed into `ReadAccelerometer()` that
    determines how much data should be copied. Because our model takes 128 three-axis
    readings as its input, the code in *main_functions.cc* calls `ReadAccelerometer()`
    with a `length` of 384 (128 * 3).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`length`是传递给`ReadAccelerometer()`的参数，用于确定应复制多少数据。因为我们的模型以128个三轴读数作为输入，所以*main_functions.cc*中的代码调用`ReadAccelerometer()`，长度为384（128
    * 3）。
- en: At this point, our input tensor is filled with fresh accelerometer data. Inference
    will be run, the results will be interpreted by the gesture predictor, and the
    result will be passed to the output handler to display to the user.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的输入张量已填充新的加速度计数据。将运行推理，手势预测器将解释结果，并将结果传递给输出处理程序显示给用户。
- en: Responding to gestures on SparkFun Edge
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应SparkFun Edge上的手势
- en: 'The output handler, located in [*sparkfun_edge/output_handler.cc*](https://oreil.ly/ix1o1),
    is very simple. The first time it runs, we configure the LEDs for output:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 输出处理程序位于[*sparkfun_edge/output_handler.cc*](https://oreil.ly/ix1o1)，非常简单。第一次运行时，我们为LED配置输出：
- en: '[PRE63]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, we toggle the yellow LED with each inference:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们每次推理时切换黄色LED：
- en: '[PRE64]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'After that, we check which gesture was detected. For each individual gesture,
    we light an LED, clear all the others, and output some beautiful ASCII art via
    the serial port. Here’s the code that handles the “wing” gesture:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们检查检测到了哪个手势。对于每个单独的手势，我们点亮一个LED，清除所有其他LED，并通过串行端口输出一些漂亮的ASCII艺术。以下是处理“翼”手势的代码：
- en: '[PRE65]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'On a serial port monitor, the output will look like this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在串行端口监视器上，输出将如下所示：
- en: '[PRE66]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: A different serial output and LED are used for each gesture.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 每个手势使用不同的串行输出和LED。
- en: Running the example
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行示例
- en: We’ve now seen how the SparkFun Edge code works. Next, let’s get it running
    on our hardware.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了SparkFun Edge代码的工作原理。接下来，让我们在我们的硬件上运行它。
- en: Tip
  id: totrans-337
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: There’s always a chance that the build process might have changed since this
    book was written, so check [*README.md*](https://oreil.ly/Ts6MT) for the latest
    instructions.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 建议检查[*README.md*](https://oreil.ly/Ts6MT)以获取最新指令，因为构建过程可能会有变化。
- en: 'To build and deploy our code, we’ll need the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和部署我们的代码，我们需要以下内容：
- en: A SparkFun Edge board with the [Himax HM01B0 breakout](https://oreil.ly/f23oa)
    attached
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有[Himax HM01B0 breakout](https://oreil.ly/f23oa)的SparkFun Edge板
- en: A USB programmer (we recommend the SparkFun Serial Basic Breakout, which is
    available in [micro-B USB](https://oreil.ly/KKfyI) and [USB-C](https://oreil.ly/ztUrB)
    variants)
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个USB编程器（我们推荐SparkFun Serial Basic Breakout，可在[micro-B USB](https://oreil.ly/KKfyI)和[USB-C](https://oreil.ly/ztUrB)变体中获得）
- en: A matching USB cable
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配的USB电缆
- en: Python 3 and some dependencies
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3和一些依赖项
- en: Note
  id: totrans-344
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re unsure whether you have the correct version of Python installed, [“Running
    the Example”](ch06.xhtml#running_hello_world_sparkfun_edge) has instructions on
    how to check.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定是否安装了正确版本的Python，[“运行示例”](ch06.xhtml#running_hello_world_sparkfun_edge)中有检查方法的说明。
- en: 'Open a terminal window, clone the TensorFlow repository, and then change into
    its directory:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，克隆TensorFlow存储库，然后切换到其目录：
- en: '[PRE67]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Next, we’re going to build the binary and run some commands that get it ready
    for downloading to the device. To avoid some typing, you can copy and paste these
    commands from [*README.md*](https://oreil.ly/MQmWw).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建二进制文件，并运行一些命令，使其准备好下载到设备中。为了避免一些打字，您可以从[*README.md*](https://oreil.ly/MQmWw)中复制并粘贴这些命令。
- en: Build the binary
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建二进制文件
- en: 'The following command downloads all the required dependencies and then compiles
    a binary for the SparkFun Edge:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令下载所有必需的依赖项，然后为SparkFun Edge编译一个二进制文件：
- en: '[PRE68]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The binary will be created as a *.bin* file, in the following location:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件将被创建为一个*.bin*文件，位于以下位置：
- en: '[PRE69]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To check that the file exists, you can use the following command:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查文件是否存在，您可以使用以下命令：
- en: '[PRE70]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If you run that command, you should see `Binary was successfully created` printed
    to the console.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行该命令，您应该看到`二进制文件已成功创建`打印到控制台。
- en: If you see `Binary is missing`, there was a problem with the build process.
    If so, it’s likely that there are some clues to what went wrong in the output
    of the `make` command.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果看到`二进制文件丢失`，则构建过程中出现问题。如果是这样，很可能在`make`命令的输出中有一些关于出错原因的线索。
- en: Sign the binary
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对二进制文件进行签名
- en: The binary must be signed with cryptographic keys to be deployed to the device.
    Let’s run some commands that will sign the binary so that it can be flashed to
    the SparkFun Edge. The scripts used here come from the Ambiq SDK, which is downloaded
    when the Makefile is run.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件必须使用加密密钥进行签名才能部署到设备上。让我们运行一些命令来对二进制文件进行签名，以便可以将其刷入SparkFun Edge。此处使用的脚本来自Ambiq
    SDK，在运行Makefile时下载。
- en: 'Enter the following command to set up some dummy cryptographic keys you can
    use for development:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令设置一些虚拟加密密钥，供开发使用：
- en: '[PRE71]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, run the following command to create a signed binary. Substitute `python3`
    with `python` if necessary:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令以创建一个已签名的二进制文件。如果需要，将`python3`替换为`python`：
- en: '[PRE72]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This creates the file *main_nonsecure_ota.bin*. Now, run this command to create
    a final version of the file that you can use to flash your device with the script
    you will use in the next step:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建文件*main_nonsecure_ota.bin*。现在，运行此命令创建文件的最终版本，您可以使用该文件刷写设备，使用下一步中将使用的脚本：
- en: '[PRE73]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You should now have a file called *main_nonsecure_wire.bin* in the directory
    where you ran the commands. This is the file you’ll be flashing to the device.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该在运行命令的目录中有一个名为*main_nonsecure_wire.bin*的文件。这是您将要刷写到设备的文件。
- en: Flash the binary
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 刷写二进制文件
- en: The SparkFun Edge stores the program it is currently running in its 1 megabyte
    of flash memory. If you want the board to run a new program, you need to send
    it to the board, which will store it in flash memory, overwriting any program
    that was previously saved. This process is called flashing.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: SparkFun Edge将当前运行的程序存储在其1兆字节的闪存中。如果您希望板运行一个新程序，您需要将其发送到板上，该程序将存储在闪存中，覆盖以前保存的任何程序。这个过程称为刷写。
- en: Attach the programmer to the board
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将编程器连接到板上
- en: To download new programs to the board, you’ll use the SparkFun USB-C Serial
    Basic serial programmer. This device allows your computer to communicate with
    the microcontroller via USB.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载新程序到板上，您将使用SparkFun USB-C串行基本串行编程器。该设备允许您的计算机通过USB与微控制器通信。
- en: 'To attach this device to your board, perform the following steps:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此设备连接到您的板上，请执行以下步骤：
- en: On the side of the SparkFun Edge, locate the six-pin header.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SparkFun Edge的一侧，找到六针排针。
- en: Plug the SparkFun USB-C Serial Basic into these pins, ensuring that the pins
    labeled BLK and GRN on each device are lined up correctly.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将SparkFun USB-C串行基本插入这些引脚，确保每个设备上标记为BLK和GRN的引脚正确对齐。
- en: You can see the correct arrangement in [Figure 11-11](#sparkfun_edge_serial_basic_4).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[图11-11](#sparkfun_edge_serial_basic_4)中看到正确的排列方式。
- en: '![A photo showing how the SparkFun Edge and USB-C Serial Basic should be connected](Images/timl_0613.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![显示SparkFun Edge和USB-C串行基本如何连接的照片](Images/timl_0613.png)'
- en: Figure 11-11\. Connecting the SparkFun Edge and USB-C Serial Basic (image courtesy
    of SparkFun)
  id: totrans-376
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-11\. 连接SparkFun Edge和USB-C串行基本（图片由SparkFun提供）
- en: Attach the programmer to your computer
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将编程器连接到计算机
- en: Next, connect the board to your computer via USB. To program the board, you
    need to determine the name that your computer gives the device. The best way of
    doing this is to list all the computer’s devices before and after attaching it
    and then look to see which device is new.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过USB将板连接到计算机。要对板进行编程，您需要确定计算机给设备的名称。最好的方法是在连接设备之前和之后列出所有计算机的设备，然后查看哪个设备是新的。
- en: Warning
  id: totrans-379
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Some people have reported issues with their operating system’s default drivers
    for the programmer, so we strongly recommend installing the [driver](https://oreil.ly/vLavS)
    before you continue.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人报告了他们的操作系统默认驱动程序与编程器存在问题，因此我们强烈建议在继续之前安装[驱动程序](https://oreil.ly/vLavS)。
- en: 'Before attaching the device via USB, run the following command:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过USB连接设备之前，请运行以下命令：
- en: '[PRE74]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This should output a list of attached devices that looks something like the
    following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出一个附加设备列表，看起来类似于以下内容：
- en: '[PRE75]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, connect the programmer to your computer’s USB port and run the command
    again:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将编程器连接到计算机的USB端口，并再次运行命令：
- en: '[PRE76]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You should see an extra item in the output, as in the example that follows.
    Your new item might have a different name. This new item is the name of the device:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在输出中看到一个额外的项目，就像以下示例一样。您的新项目可能有不同的名称。这个新项目是设备的名称：
- en: '[PRE77]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This name will be used to refer to the device. However, it can change depending
    on which USB port the programmer is attached to, so if you disconnect the board
    from your computer and then reattach it you might need to look up its name again.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名称将用于引用设备。但是，它可能会根据编程器连接到哪个USB端口而改变，因此如果您从计算机断开板然后重新连接，您可能需要再次查找其名称。
- en: Tip
  id: totrans-390
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Some users have reported two devices appearing in the list. If you see two devices,
    the correct one to use begins with the letters “wch”; for example, “/dev/wchusbserial-14410.”
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 一些用户报告列表中出现了两个设备。如果看到两个设备，则正确的设备名称以“wch”开头；例如，“/dev/wchusbserial-14410”。
- en: 'After you’ve identified the device name, put it in a shell variable for later
    use:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 确定设备名称后，将其放入一个shell变量以供以后使用：
- en: '[PRE78]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This is a variable that you can use when running commands that require the device
    name, later in the process.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在后续过程中运行需要设备名称的命令时可以使用的变量。
- en: Run the script to flash your board
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行脚本刷写您的板
- en: To flash the board, you need to put it into a special “bootloader” state that
    prepares it to receive the new binary. You can then run a script to send the binary
    to the board.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 要刷写板子，您需要将其置于特殊的“引导加载程序”状态，以准备接收新的二进制文件。然后您可以运行一个脚本将二进制文件发送到板子上。
- en: 'First create an environment variable to specify the baud rate, which is the
    speed at which data will be sent to the device:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个环境变量来指定波特率，即数据发送到设备的速度：
- en: '[PRE79]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now paste the command that follows into your terminal—but *do not press Enter
    yet*!. The `${DEVICENAME}` and `${BAUD_RATE}` in the command will be replaced
    with the values you set in the previous sections. Remember to substitute `python3`
    with `python` if necessary:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将以下命令粘贴到您的终端中，但*不要按Enter*！命令中的`${DEVICENAME}`和`${BAUD_RATE}`将替换为您在前几节中设置的值。如有必要，请将`python3`替换为`python`：
- en: '[PRE80]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Next you’ll reset the board into its bootloader state and flash the board.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来您将重置板子到引导加载程序状态并刷写板子。
- en: On the board, locate the buttons marked `RST` and `14`, as shown in [Figure 11-12](#sparkfun_edge_buttons_4).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在板子上，找到标记为`RST`和`14`的按钮，如[图11-12](#sparkfun_edge_buttons_4)所示。
- en: '![A photo showing the SparkFun Edge''s buttons](Images/timl_0614.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![显示SparkFun Edge按钮的照片](Images/timl_0614.png)'
- en: Figure 11-12\. The SparkFun Edge’s buttons
  id: totrans-404
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-12\. SparkFun Edge的按钮
- en: 'Perform the following steps:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Ensure that your board is connected to the programmer, and the entire thing
    is connected to your computer via USB.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的板子连接到编程器，并且整个设备通过USB连接到计算机。
- en: On the board, press and hold the button marked `14`. *Continue holding it.*
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在板子上，按住标记为`14`的按钮。*继续按住。*
- en: While still holding the button marked `14`, press the button marked `RST` to
    reset the board.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然按住标记为`14`的按钮的同时，按下标记为`RST`的按钮重置板子。
- en: Press Enter on your computer to run the script. *Continue holding button `14`.*
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算机上按Enter键运行脚本。*继续按住按钮`14`。*
- en: 'You should now see something like the following appearing on your screen:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该会看到类似以下内容出现在屏幕上：
- en: '[PRE81]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Keep holding button `14` until you see `Sending Data Packet of length 8180`.
    You can release the button after seeing this (but it’s okay if you keep holding
    it).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 继续按住按钮`14`，直到看到`Sending Data Packet of length 8180`。在看到这个后可以释放按钮（但如果您继续按住也没关系）。
- en: 'The program will continue to print lines on the terminal. Eventually, you’ll
    see something like the following:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将继续在终端上打印行。最终，您会看到类似以下内容：
- en: '[PRE82]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This indicates a successful flashing.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示刷写成功。
- en: Tip
  id: totrans-416
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If the program output ends with an error, check whether `Sending Reset Command.`
    was printed. If so, flashing was likely successful despite the error. Otherwise,
    flashing might have failed. Try running through these steps again (you can skip
    over setting the environment variables).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序输出以错误结束，请检查是否打印了`Sending Reset Command.`。如果是，则尽管有错误，刷写很可能成功。否则，刷写可能失败。尝试再次运行这些步骤（您可以跳过设置环境变量）。
- en: Testing the Program
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试程序
- en: Start by pressing the `RST` button to make sure the program is running. When
    the program is running, the yellow LED will toggle on and off, once for each inference.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 首先按下`RST`按钮确保程序正在运行。当程序运行时，黄色LED灯会每次推断时闪烁一次。
- en: 'Next, use the following command to start printing the serial output of the
    device:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令开始打印设备的串行输出：
- en: '[PRE83]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You should initially see the following output:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 最初您应该会看到以下输出：
- en: '[PRE84]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: You can now try to make some gestures. Hold the board up with one hand, with
    the components facing up and the USB adapter facing toward the left, as shown
    in [Figure 11-13](#gesture_holding_edge).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以尝试做一些手势。用一只手举起板子，组件朝上，USB适配器朝向左侧，如[图11-13](#gesture_holding_edge)所示。
- en: '![Photo of a hand holding a SparkFun edge board](Images/timl_1113.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![一只手拿着SparkFun Edge板子的照片](Images/timl_1113.png)'
- en: Figure 11-13\. How to hold the board while performing gestures
  id: totrans-426
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-13\. 手势执行时如何握住板子
- en: '[Figure 11-14](#gesture_spells_3) presents a diagram showing how to perform
    each gesture. Because the model was trained on data collected when the board was
    attached to a wand, you might need a few tries to get them to work.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-14](#gesture_spells_3)展示了如何执行每个手势的图表。由于模型是在板子连接到魔杖时收集的数据上进行训练的，您可能需要尝试几次才能使它们正常工作。'
- en: '![Diagrams of the three magic wand gestures](Images/timl_1103.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![三个魔杖手势的图表](Images/timl_1103.png)'
- en: Figure 11-14\. The three magic wand gestures
  id: totrans-429
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-14\. 三个魔杖手势
- en: 'The easiest one to start with is “wing.” You should move your hand quickly
    enough that it takes around one second to perform the gesture. If you’re successful,
    the red LED should illuminate, and you should see the following output:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易开始的是“翅膀”。您应该将手移动得足够快，以便大约一秒钟完成手势。如果成功，红色LED灯应该会亮起，并且您应该会看到以下输出：
- en: '[PRE85]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Congratulations, you’ve cast your first magic spell using the SparkFun Edge!
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您已经使用SparkFun Edge施展了您的第一个魔法咒语！
- en: Note
  id: totrans-433
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: At this point, you might choose to be creative and attach the board to the tip
    of a magic wand, at the point furthest from your hand. Any stick, ruler, or other
    household item with a length of around a foot (30 cm) should work well.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可以选择发挥创造力，将板子连接到魔杖的尖端，距离手最远的地方。任何棍子、尺子或其他长度约为一英尺（30厘米）的家用物品都应该很好用。
- en: Make sure the device is attached firmly, and in the same orientation, with the
    components facing up and the USB adapter facing toward the left. And pick a rigid
    wand, not a flexible one because any wobbling will affect the accelerometer readings.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 确保设备牢固连接，并且朝向相同，组件朝上，USB适配器朝向左侧。选择一个坚固的魔杖，而不是一个灵活的魔杖，因为任何摇晃都会影响加速度计读数。
- en: 'Next try the “ring” gesture, by tracing a clockwise circle with your hand (or
    the tip of your wand). Again, aim to take around a second to perform the gesture.
    You should see the following appear, as if by magic:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来尝试“环”手势，用手（或魔杖的尖端）顺时针画一个圆圈。再次，尽量花大约一秒钟来执行手势。您应该会看到以下内容，仿佛是魔法般出现的：
- en: '[PRE86]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'For the final gesture, trace the corner of a triangle in the air. It’s best
    described by its ASCII art demonstration, shown here:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个手势，在空中画一个三角形的角。最好通过ASCII艺术演示来描述，如下所示：
- en: '[PRE87]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Like any good magic spells, you might have to practice these a bit before you
    can perform them perfectly each time. You can see video demonstrations of the
    gestures in [*README.md*](https://oreil.ly/ilGJY).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何好的魔法咒语一样，您可能需要练习一下，才能每次都完美地执行它们。您可以在[*README.md*](https://oreil.ly/ilGJY)中看到手势的视频演示。
- en: Making your own changes
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进行您自己的更改
- en: Now that you’ve deployed the basic application, try playing around and making
    some changes. You can find the application’s code in the *tensorflow/lite/micro/examples/magic_wand*
    folder. Just edit and save, and then repeat the previous instructions to deploy
    your modified code to the device.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经部署了基本应用程序，请尝试玩耍并进行一些更改。您可以在*tensorflow/lite/micro/examples/magic_wand*文件夹中找到应用程序的代码。只需编辑并保存，然后重复之前的说明以将修改后的代码部署到设备上。
- en: 'Here are a few things you could try:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以尝试的一些事项：
- en: Experiment with the threshold values in [*constants.cc*](https://oreil.ly/s5bdg)
    to make the gestures easier or more difficult to perform (at the cost of more
    false positives or negatives).
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在[*constants.cc*](https://oreil.ly/s5bdg)中调整阈值，使手势更容易或更难执行（以更多的误报或漏报为代价）。
- en: Write a program on your computer that lets you perform tasks using physical
    gestures.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的计算机上编写一个程序，让您可以使用物理手势执行任务。
- en: Extend the program to transmit detection results via Bluetooth. There’s an example
    of how to do this in the [Ambiq SDK](https://oreil.ly/Bci3a), in *AmbiqSuite-Rel2.0.0/boards/apollo3_evb/examples/uart_ble_bridge*.
    When the magic wand application is built, the SDK is downloaded to *tensorflow/tensorflow/lite/micro/tools/make/downloads/AmbiqSuite-Rel2.0.0*.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展程序以通过蓝牙传输检测结果。在[Ambiq SDK](https://oreil.ly/Bci3a)中有一个如何做到这一点的示例，在*AmbiqSuite-Rel2.0.0/boards/apollo3_evb/examples/uart_ble_bridge*中。构建魔法棒应用程序时，SDK将下载到*tensorflow/tensorflow/lite/micro/tools/make/downloads/AmbiqSuite-Rel2.0.0*中。
- en: Wrapping Up
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you saw a fun example of how obscure sensor data can be interpreted
    by an embedded machine learning application into a much more useful form. By seeing
    the patterns in noise, embedded machine learning models allow devices to understand
    the world around them and alert us to events, even when the raw data might be
    difficult for a human to digest.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您看到了一个有趣的例子，即嵌入式机器学习应用程序如何将模糊的传感器数据解释为更有用的形式。通过观察噪声中的模式，嵌入式机器学习模型使设备能够理解周围的世界并警示我们事件，即使原始数据对人类来说可能很难消化。
- en: In [Chapter 12](ch12.xhtml#chapter_magic_wand_training), we explore how our
    magic wand model works and learn how to collect data and train our own magic spells.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](ch12.xhtml#chapter_magic_wand_training)中，我们探讨了我们的魔法棒模型是如何工作的，并学习如何收集数据并训练我们自己的魔法咒语。
- en: ^([1](ch11.xhtml#idm46473555451544-marker)) Mihaela Porumb et al., “A convolutional
    neural network approach to detect congestive heart failure.” *Biomedical Signal
    Processing and Control* (Jan 2020). [*https://oreil.ly/4HBFt*](https://oreil.ly/4HBFt)
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.xhtml#idm46473555451544-marker)) Mihaela Porumb等人，“一种卷积神经网络方法来检测充血性心力衰竭。”*生物医学信号处理和控制*（2020年1月）。[*https://oreil.ly/4HBFt*](https://oreil.ly/4HBFt)
