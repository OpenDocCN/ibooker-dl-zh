- en: 2 Working with text data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Preparing text for large language model training
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting text into word and subword tokens
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Byte pair encoding as a more advanced way of tokenizing text
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sampling training examples with a sliding window approach
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting tokens into vectors that feed into a large language model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we’ve covered the general structure of large language models (LLMs)
    and learned that they are pretrained on vast amounts of text. Specifically, our
    focus was on decoder-only LLMs based on the transformer architecture, which underlies
    the models used in ChatGPT and other popular GPT-like LLMs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: During the pretraining stage, LLMs process text, one word at a time. Training
    LLMs with millions to billions of parameters using a next-word prediction task
    yields models with impressive capabilities. These models can then be further finetuned
    to follow general instructions or perform specific target tasks. But before we
    can implement and train LLMs, we need to prepare the training dataset, as illustrated
    in figure 2.1.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-1.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1 The three main stages of coding an LLM. This chapter focuses on
    step 1 of stage 1: implementing the data sample pipeline.'
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You’ll learn how to prepare input text for training LLMs. This involves splitting
    text into individual word and subword tokens, which can then be encoded into vector
    representations for the LLM. You’ll also learn about advanced tokenization schemes
    like byte pair encoding, which is utilized in popular LLMs like GPT. Lastly, we’ll
    implement a sampling and data-loading strategy to produce the input-output pairs
    necessary for training LLMs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Understanding word embeddings
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deep neural network models, including LLMs, cannot process raw text directly.
    Since text is categorical, it isn’t compatible with the mathematical operations
    used to implement and train neural networks. Therefore, we need a way to represent
    words as continuous-valued vectors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Note  Readers unfamiliar with vectors and tensors in a computational context
    can learn more in appendix A, section A.2.2.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The concept of converting data into a vector format is often referred to as
    *embedding*. Using a specific neural network layer or another pretrained neural
    network model, we can embed different data types—for example, video, audio, and
    text, as illustrated in figure 2.2\. However, it’s important to note that different
    data formats require distinct embedding models. For example, an embedding model
    designed for text would not be suitable for embedding audio or video data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-2.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 Deep learning models cannot process data formats like video, audio,
    and text in their raw form. Thus, we use an embedding model to transform this
    raw data into a dense vector representation that deep learning architectures can
    easily understand and process. Specifically, this figure illustrates the process
    of converting raw data into a three-dimensional numerical vector.
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At its core, an embedding is a mapping from discrete objects, such as words,
    images, or even entire documents, to points in a continuous vector space—the primary
    purpose of embeddings is to convert nonnumeric data into a format that neural
    networks can process.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，嵌入是将离散对象（如单词、图像甚至整个文档）映射到连续向量空间中的点的映射——嵌入的主要目的是将非数值数据转换为神经网络可以处理的形式。
- en: While word embeddings are the most common form of text embedding, there are
    also embeddings for sentences, paragraphs, or whole documents. Sentence or paragraph
    embeddings are popular choices for *retrieval-augmented generation.* Retrieval-augmented
    generation combines generation (like producing text) with retrieval (like searching
    an external knowledge base) to pull relevant information when generating text,
    which is a technique that is beyond the scope of this book. Since our goal is
    to train GPT-like LLMs, which learn to generate text one word at a time, we will
    focus on word embeddings.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然词嵌入是文本嵌入最常见的形式，但也有句子、段落或整个文档的嵌入。句子或段落嵌入是*检索增强生成*的流行选择。检索增强生成结合了生成（如产生文本）和检索（如搜索外部知识库）来在生成文本时提取相关信息，这是一种超出本书范围的技术。由于我们的目标是训练类似于GPT的LLMs，这些LLMs一次学习生成一个单词，因此我们将专注于词嵌入。
- en: Several algorithms and frameworks have been developed to generate word embeddings.
    One of the earlier and most popular examples is the *Word2Vec* approach. Word2Vec
    trained neural network architecture to generate word embeddings by predicting
    the context of a word given the target word or vice versa. The main idea behind
    Word2Vec is that words that appear in similar contexts tend to have similar meanings.
    Consequently, when projected into two-dimensional word embeddings for visualization
    purposes, similar terms are clustered together, as shown in figure 2.3.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 已经开发出多种算法和框架来生成词嵌入。其中一个较早且最受欢迎的例子是*Word2Vec*方法。Word2Vec通过预测目标词或反之的上下文来训练神经网络架构以生成词嵌入。Word2Vec背后的主要思想是，在相似上下文中出现的单词往往具有相似的含义。因此，当为了可视化目的投影到二维词嵌入时，相似术语通常会聚集在一起，如图2.3所示。
- en: '![figure](../Images/2-3.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/2-3.png)'
- en: Figure 2.3 If word embeddings are two-dimensional, we can plot them in a two-dimensional
    scatterplot for visualization purposes as shown here. When using word embedding
    techniques, such as Word2Vec, words corresponding to similar concepts often appear
    close to each other in the embedding space. For instance, different types of birds
    appear closer to each other in the embedding space than in countries and cities.
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3 如果词嵌入是二维的，我们可以将其绘制在二维散点图中进行可视化，如图所示。当使用Word2Vec等词嵌入技术时，对应于相似概念的单词在嵌入空间中通常彼此靠近。例如，不同类型的鸟在嵌入空间中的距离比在国家和城市中的距离更近。
- en: Word embeddings can have varying dimensions, from one to thousands. A higher
    dimensionality might capture more nuanced relationships but at the cost of computational
    efficiency.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 词嵌入可以有不同维度，从一到数千。更高的维度可能能够捕捉更细微的关系，但会以计算效率为代价。
- en: While we can use pretrained models such as Word2Vec to generate embeddings for
    machine learning models, LLMs commonly produce their own embeddings that are part
    of the input layer and are updated during training. The advantage of optimizing
    the embeddings as part of the LLM training instead of using Word2Vec is that the
    embeddings are optimized to the specific task and data at hand. We will implement
    such embedding layers later in this chapter. (LLMs can also create contextualized
    output embeddings, as we discuss in chapter 3.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用预训练模型如Word2Vec为机器学习模型生成嵌入时，LLMs通常会产生自己的嵌入，这些嵌入是输入层的一部分，并在训练过程中更新。将嵌入作为LLM训练的一部分进行优化，而不是使用Word2Vec的优势在于，嵌入被优化以适应特定任务和现有数据。我们将在本章后面实现这样的嵌入层。（LLMs还可以创建上下文化的输出嵌入，如我们在第3章中讨论的。）
- en: Unfortunately, high-dimensional embeddings present a challenge for visualization
    because our sensory perception and common graphical representations are inherently
    limited to three dimensions or fewer, which is why figure 2.3 shows two-dimensional
    embeddings in a two-dimensional scatterplot. However, when working with LLMs,
    we typically use embeddings with a much higher dimensionality. For both GPT-2
    and GPT-3, the embedding size (often referred to as the dimensionality of the
    model’s hidden states) varies based on the specific model variant and size. It
    is a tradeoff between performance and efficiency. The smallest GPT-2 models (117M
    and 125M parameters) use an embedding size of 768 dimensions to provide concrete
    examples. The largest GPT-3 model (175B parameters) uses an embedding size of
    12,288 dimensions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will walk through the required steps for preparing the embeddings used
    by an LLM, which include splitting text into words, converting words into tokens,
    and turning tokens into embedding vectors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Tokenizing text
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s discuss how we split input text into individual tokens, a required preprocessing
    step for creating embeddings for an LLM. These tokens are either individual words
    or special characters, including punctuation characters, as shown in figure 2.4.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-4.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 A view of the text processing steps in the context of an LLM. Here,
    we split an input text into individual tokens, which are either words or special
    characters, such as punctuation characters.
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The text we will tokenize for LLM training is “The Verdict,” a short story by
    Edith Wharton, which has been released into the public domain and is thus permitted
    to be used for LLM training tasks. The text is available on Wikisource at [https://en.wikisource.org/wiki/The_Verdict](https://en.wikisource.org/wiki/The_Verdict),
    and you can copy and paste it into a text file, which I copied into a text file
    `"the-verdict.txt".`
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can find this `"the-verdict.txt"` file in this book’s GitHub
    repository at [https://mng.bz/Adng](https://mng.bz/Adng). You can download the
    file with the following Python code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we can load the `the-verdict.txt` file using Python’s standard file reading
    utilities.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.1 Reading in a short story as text sample into Python
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The print command prints the total number of characters followed by the first
    99 characters of this file for illustration purposes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our goal is to tokenize this 20,479-character short story into individual words
    and special characters that we can then turn into embeddings for LLM training.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Note  It’s common to process millions of articles and hundreds of thousands
    of books—many gigabytes of text—when working with LLMs. However, for educational
    purposes, it’s sufficient to work with smaller text samples like a single book
    to illustrate the main ideas behind the text processing steps and to make it possible
    to run it in a reasonable time on consumer hardware.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: How can we best split this text to obtain a list of tokens? For this, we go
    on a small excursion and use Python’s regular expression library `re` for illustration
    purposes. (You don’t have to learn or memorize any regular expression syntax since
    we will later transition to a prebuilt tokenizer.)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Using some simple example text, we can use the `re.split` command with the
    following syntax to split a text on whitespace characters:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result is a list of individual words, whitespaces, and punctuation characters:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This simple tokenization scheme mostly works for separating the example text
    into individual words; however, some words are still connected to punctuation
    characters that we want to have as separate list entries. We also refrain from
    making all text lowercase because capitalization helps LLMs distinguish between
    proper nouns and common nouns, understand sentence structure, and learn to generate
    text with proper capitalization.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the regular expression splits on whitespaces (`\s`), commas, and
    periods (`[,.]`):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see that the words and punctuation characters are now separate list
    entries just as we wanted:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A small remaining problem is that the list still includes whitespace characters.
    Optionally, we can remove these redundant characters safely as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The resulting whitespace-free output looks like as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note  When developing a simple tokenizer, whether we should encode whitespaces
    as separate characters or just remove them depends on our application and its
    requirements. Removing whitespaces reduces the memory and computing requirements.
    However, keeping whitespaces can be useful if we train models that are sensitive
    to the exact structure of the text (for example, Python code, which is sensitive
    to indentation and spacing). Here, we remove whitespaces for simplicity and brevity
    of the tokenized outputs. Later, we will switch to a tokenization scheme that
    includes whitespaces.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'The tokenization scheme we devised here works well on the simple sample text.
    Let’s modify it a bit further so that it can also handle other types of punctuation,
    such as question marks, quotation marks, and the double-dashes we have seen earlier
    in the first 100 characters of Edith Wharton’s short story, along with additional
    special characters:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The resulting output is:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see based on the results summarized in figure 2.5, our tokenization
    scheme can now handle the various special characters in the text successfully.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-5.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 The tokenization scheme we implemented so far splits text into individual
    words and punctuation characters. In this specific example, the sample text gets
    split into 10 individual tokens.
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now that we have a basic tokenizer working, let’s apply it to Edith Wharton’s
    entire short story:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This print statement outputs `4690`, which is the number of tokens in this
    text (without whitespaces). Let’s print the first 30 tokens for a quick visual
    check:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The resulting output shows that our tokenizer appears to be handling the text
    well since all words and special characters are neatly separated:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 2.3 Converting tokens into token IDs
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, let’s convert these tokens from a Python string to an integer representation
    to produce the token IDs. This conversion is an intermediate step before converting
    the token IDs into embedding vectors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: To map the previously generated tokens into token IDs, we have to build a vocabulary
    first. This vocabulary defines how we map each unique word and special character
    to a unique integer, as shown in figure 2.6.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-6.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 We build a vocabulary by tokenizing the entire text in a training
    dataset into individual tokens. These individual tokens are then sorted alphabetically,
    and duplicate tokens are removed. The unique tokens are then aggregated into a
    vocabulary that defines a mapping from each unique token to a unique integer value.
    The depicted vocabulary is purposely small and contains no punctuation or special
    characters for simplicity.
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now that we have tokenized Edith Wharton’s short story and assigned it to a
    Python variable called `preprocessed`, let’s create a list of all unique tokens
    and sort them alphabetically to determine the vocabulary size:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After determining that the vocabulary size is 1,130 via this code, we create
    the vocabulary and print its first 51 entries for illustration purposes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.2 Creating a vocabulary
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output is
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see, the dictionary contains individual tokens associated with unique
    integer labels. Our next goal is to apply this vocabulary to convert new text
    into token IDs (figure 2.7).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-7.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 Starting with a new text sample, we tokenize the text and use the
    vocabulary to convert the text tokens into token IDs. The vocabulary is built
    from the entire training set and can be applied to the training set itself and
    any new text samples. The depicted vocabulary contains no punctuation or special
    characters for simplicity.
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When we want to convert the outputs of an LLM from numbers back into text, we
    need a way to turn token IDs into text. For this, we can create an inverse version
    of the vocabulary that maps token IDs back to the corresponding text tokens.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a complete tokenizer class in Python with an `encode` method
    that splits text into tokens and carries out the string-to-integer mapping to
    produce token IDs via the vocabulary. In addition, we’ll implement a `decode`
    method that carries out the reverse integer-to-string mapping to convert the token
    IDs back into text. The following listing shows the code for this tokenizer implementation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.3 Implementing a simple text tokenizer
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#1 Stores the vocabulary as a class attribute for access in the encode and
    decode methods'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Creates an inverse vocabulary that maps token IDs back to the original text
    tokens'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Processes input text into token IDs'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Converts token IDs back into text'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Removes spaces before the specified punctuation'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Using the `SimpleTokenizerV1` Python class, we can now instantiate new tokenizer
    objects via an existing vocabulary, which we can then use to encode and decode
    text, as illustrated in figure 2.8.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-8.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8 Tokenizer implementations share two common methods: an encode method
    and a decode method. The encode method takes in the sample text, splits it into
    individual tokens, and converts the tokens into token IDs via the vocabulary.
    The decode method takes in token IDs, converts them back into text tokens, and
    concatenates the text tokens into natural text.'
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s instantiate a new tokenizer object from the `SimpleTokenizerV1` class
    and tokenize a passage from Edith Wharton’s short story to try it out in practice:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code prints the following token IDs:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, let’s see whether we can turn these token IDs back into text using the
    decode method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This outputs:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Based on this output, we can see that the decode method successfully converted
    the token IDs back into the original text.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good. We implemented a tokenizer capable of tokenizing and detokenizing
    text based on a snippet from the training set. Let’s now apply it to a new text
    sample not contained in the training set:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Executing this code will result in the following error:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The problem is that the word “Hello” was not used in the “The Verdict” short
    story. Hence, it is not contained in the vocabulary. This highlights the need
    to consider large and diverse training sets to extend the vocabulary when working
    on LLMs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will test the tokenizer further on text that contains unknown words
    and discuss additional special tokens that can be used to provide further context
    for an LLM during training.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Adding special context tokens
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to modify the tokenizer to handle unknown words. We also need to address
    the usage and addition of special context tokens that can enhance a model’s understanding
    of context or other relevant information in the text. These special tokens can
    include markers for unknown words and document boundaries, for example. In particular,
    we will modify the vocabulary and tokenizer, `SimpleTokenizerV2`, to support two
    new tokens, `<|unk|>` and `<|endoftext|>`, as illustrated in figure 2.9.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-9.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 We add special tokens to a vocabulary to deal with certain contexts.
    For instance, we add an `<|unk|>` token to represent new and unknown words that
    were not part of the training data and thus not part of the existing vocabulary.
    Furthermore, we add an `<|endoftext|>` token that we can use to separate two unrelated
    text sources.
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can modify the tokenizer to use an `<|unk|>` token if it encounters a word
    that is not part of the vocabulary. Furthermore, we add a token between unrelated
    texts. For example, when training GPT-like LLMs on multiple independent documents
    or books, it is common to insert a token before each document or book that follows
    a previous text source, as illustrated in figure 2.10\. This helps the LLM understand
    that although these text sources are concatenated for training, they are, in fact,
    unrelated.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-10.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 When working with multiple independent text source, we add `<|endoftext|>`
    tokens between these texts. These `<|endoftext|>` tokens act as markers, signaling
    the start or end of a particular segment, allowing for more effective processing
    and understanding by the LLM.
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s now modify the vocabulary to include these two special tokens, `<unk>`
    and `<|endoftext|>`, by adding them to our list of all unique words:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Based on the output of this print statement, the new vocabulary size is 1,132
    (the previous vocabulary size was 1,130).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'As an additional quick check, let’s print the last five entries of the updated
    vocabulary:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code prints
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Based on the code output, we can confirm that the two new special tokens were
    indeed successfully incorporated into the vocabulary. Next, we adjust the tokenizer
    from code listing 2.3 accordingly as shown in the following listing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.4 A simple text tokenizer that handles unknown words
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '#1 Replaces unknown words by <|unk|> tokens'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Replaces spaces before the specified punctuations'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the `SimpleTokenizerV1` we implemented in listing 2.3, the new `SimpleTokenizerV2`
    replaces unknown words with `<|unk|>` tokens.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now try this new tokenizer out in practice. For this, we will use a simple
    text sample that we concatenate from two independent and unrelated sentences:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The output is
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, let’s tokenize the sample text using the `SimpleTokenizerV2` on the vocab
    we previously created in listing 2.2:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This prints the following token IDs:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can see that the list of token IDs contains `1130` for the `<|endoftext|>`
    separator token as well as two `1131` tokens, which are used for unknown words.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s detokenize the text for a quick sanity check:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The output is
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Based on comparing this detokenized text with the original input text, we know
    that the training dataset, Edith Wharton’s short story “The Verdict,” does not
    contain the words “Hello” and “palace.”
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the LLM, some researchers also consider additional special tokens
    such as the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '`[BOS]` *(beginning of sequence) *—This token marks the start of a text. It
    signifies to the LLM where a piece of content begins.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[EOS]` *(end of sequence) *—This token is positioned at the end of a text
    and is especially useful when concatenating multiple unrelated texts, similar
    to `<|endoftext|>`. For instance, when combining two different Wikipedia articles
    or books, the `[EOS]` token indicates where one ends and the next begins.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[PAD]` *(padding) *—When training LLMs with batch sizes larger than one, the
    batch might contain texts of varying lengths. To ensure all texts have the same
    length, the shorter texts are extended or “padded” using the `[PAD]` token, up
    to the length of the longest text in the batch.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tokenizer used for GPT models does not need any of these tokens; it only
    uses an `<|endoftext|>` token for simplicity. `<|endoftext|>` is analogous to
    the `[EOS]` token. `<|endoftext|>` is also used for padding. However, as we’ll
    explore in subsequent chapters, when training on batched inputs, we typically
    use a mask, meaning we don’t attend to padded tokens. Thus, the specific token
    chosen for padding becomes inconsequential.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the tokenizer used for GPT models also doesn’t use an `<|unk|>` token
    for out-of-vocabulary words. Instead, GPT models use a *byte pair encoding* tokenizer,
    which breaks words down into subword units, which we will discuss next.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Byte pair encoding
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at a more sophisticated tokenization scheme based on a concept called
    byte pair encoding (BPE). The BPE tokenizer was used to train LLMs such as GPT-2,
    GPT-3, and the original model used in ChatGPT.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Since implementing BPE can be relatively complicated, we will use an existing
    Python open source library called *tiktoken* ([https://github.com/openai/tiktoken](https://github.com/openai/tiktoken)),
    which implements the BPE algorithm very efficiently based on source code in Rust.
    Similar to other Python libraries, we can install the tiktoken library via Python’s
    `pip` installer from the terminal:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The code we will use is based on tiktoken 0.7.0\. You can use the following
    code to check the version you currently have installed:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once installed, we can instantiate the BPE tokenizer from tiktoken as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The usage of this tokenizer is similar to the `SimpleTokenizerV2` we implemented
    previously via an `encode` method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The code prints the following token IDs:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can then convert the token IDs back into text using the decode method, similar
    to our `SimpleTokenizerV2`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The code prints
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can make two noteworthy observations based on the token IDs and decoded text.
    First, the `<|endoftext|>` token is assigned a relatively large token ID, namely,
    `50256`. In fact, the BPE tokenizer, which was used to train models such as GPT-2,
    GPT-3, and the original model used in ChatGPT, has a total vocabulary size of
    50,257, with `<|endoftext|>` being assigned the largest token ID.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Second, the BPE tokenizer encodes and decodes unknown words, such as `someunknownPlace`,
    correctly. The BPE tokenizer can handle any unknown word. How does it achieve
    this without using `<|unk|>` tokens?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm underlying BPE breaks down words that aren’t in its predefined
    vocabulary into smaller subword units or even individual characters, enabling
    it to handle out-of-vocabulary words. So, thanks to the BPE algorithm, if the
    tokenizer encounters an unfamiliar word during tokenization, it can represent
    it as a sequence of subword tokens or characters, as illustrated in figure 2.11.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-11.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 BPE tokenizers break down unknown words into subwords and individual
    characters. This way, a BPE tokenizer can parse any word and doesn’t need to replace
    unknown words with special tokens, such as `<|unk|>`.
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ability to break down unknown words into individual characters ensures that
    the tokenizer and, consequently, the LLM that is trained with it can process any
    text, even if it contains words that were not present in its training data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.1 Byte pair encoding of unknown words
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Try the BPE tokenizer from the tiktoken library on the unknown words “Akwirw
    ier” and print the individual token IDs. Then, call the `decode` function on each
    of the resulting integers in this list to reproduce the mapping shown in figure
    2.11\. Lastly, call the decode method on the token IDs to check whether it can
    reconstruct the original input, “Akwirw ier.”
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: A detailed discussion and implementation of BPE is out of the scope of this
    book, but in short, it builds its vocabulary by iteratively merging frequent characters
    into subwords and frequent subwords into words. For example, BPE starts with adding
    all individual single characters to its vocabulary (“a,” “b,” etc.). In the next
    stage, it merges character combinations that frequently occur together into subwords.
    For example, “d” and “e” may be merged into the subword “de,” which is common
    in many English words like “define,” “depend,” “made,” and “hidden.” The merges
    are determined by a frequency cutoff.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Data sampling with a sliding window
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step in creating the embeddings for the LLM is to generate the input–target
    pairs required for training an LLM. What do these input–target pairs look like?
    As we already learned, LLMs are pretrained by predicting the next word in a text,
    as depicted in figure 2.12.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-12.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 Given a text sample, extract input blocks as subsamples that serve
    as input to the LLM, and the LLM’s prediction task during training is to predict
    the next word that follows the input block. During training, we mask out all words
    that are past the target. Note that the text shown in this figure must undergo
    tokenization before the LLM can process it; however, this figure omits the tokenization
    step for clarity.
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s implement a data loader that fetches the input–target pairs in figure
    2.12 from the training dataset using a sliding window approach. To get started,
    we will tokenize the whole “The Verdict” short story using the BPE tokenizer:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Executing this code will return `5145`, the total number of tokens in the training
    set, after applying the BPE tokenizer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we remove the first 50 tokens from the dataset for demonstration purposes,
    as it results in a slightly more interesting text passage in the next steps:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'One of the easiest and most intuitive ways to create the input–target pairs
    for the next-word prediction task is to create two variables, `x` and `y`, where
    `x` contains the input tokens and `y` contains the targets, which are the inputs
    shifted by 1:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '#1 The context size determines how many tokens are included in the input.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the previous code prints the following output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By processing the inputs along with the targets, which are the inputs shifted
    by one position, we can create the next-word prediction tasks (see figure 2.12),
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The code prints
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Everything left of the arrow (`---->`) refers to the input an LLM would receive,
    and the token ID on the right side of the arrow represents the target token ID
    that the LLM is supposed to predict. Let’s repeat the previous code but convert
    the token IDs into text:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following outputs show how the input and outputs look in text format:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We’ve now created the input–target pairs that we can use for LLM training.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s only one more task before we can turn the tokens into embeddings: implementing
    an efficient data loader that iterates over the input dataset and returns the
    inputs and targets as PyTorch tensors, which can be thought of as multidimensional
    arrays. In particular, we are interested in returning two tensors: an input tensor
    containing the text that the LLM sees and a target tensor that includes the targets
    for the LLM to predict, as depicted in figure 2.13\. While the figure shows the
    tokens in string format for illustration purposes, the code implementation will
    operate on token IDs directly since the `encode` method of the BPE tokenizer performs
    both tokenization and conversion into token IDs as a single step.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-13.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 To implement efficient data loaders, we collect the inputs in a
    tensor, `x`, where each row represents one input context. A second tensor, `y`,
    contains the corresponding prediction targets (next words), which are created
    by shifting the input by one position.
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Note  For the efficient data loader implementation, we will use PyTorch’s built-in
    `Dataset` and `DataLoader` classes. For additional information and guidance on
    installing PyTorch, please see section A.2.1.3 in appendix A.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The code for the dataset class is shown in the following listing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.5 A dataset for batched inputs and targets
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '#1 Tokenizes the entire text'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses a sliding window to chunk the book into overlapping sequences of max_length'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Returns the total number of rows in the dataset'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Returns a single row from the dataset'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The `GPTDatasetV1` class is based on the PyTorch `Dataset` class and defines
    how individual rows are fetched from the dataset, where each row consists of a
    number of token IDs (based on a `max_length`) assigned to an `input_chunk` tensor.
    The `target_ chunk` tensor contains the corresponding targets. I recommend reading
    on to see what the data returned from this dataset looks like when we combine
    the dataset with a PyTorch `DataLoader`—this will bring additional intuition and
    clarity.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Note  If you are new to the structure of PyTorch `Dataset` classes, such as
    shown in listing 2.5, refer to section A.6 in appendix A, which explains the general
    structure and usage of PyTorch `Dataset` and `DataLoader` classes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The following code uses the `GPTDatasetV1` to load the inputs in batches via
    a PyTorch `DataLoader`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Listing 2.6 A data loader to generate batches with input-with pairs
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '#1 Initializes the tokenizer'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Creates dataset'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '#3 drop_last=True drops the last batch if it is shorter than the specified
    batch_size to prevent loss spikes during training.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '#4 The number of CPU processes to use for preprocessing'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test the `dataloader` with a batch size of 1 for an LLM with a context
    size of 4 to develop an intuition of how the `GPTDatasetV1` class from listing
    2.5 and the `create_ dataloader_v1` function from listing 2.6 work together:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '#1 Converts dataloader into a Python iterator to fetch the next entry via Python’s
    built-in next() function'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the preceding code prints the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `first_batch` variable contains two tensors: the first tensor stores the
    input token IDs, and the second tensor stores the target token IDs. Since the
    `max_length` is set to 4, each of the two tensors contains four token IDs. Note
    that an input size of 4 is quite small and only chosen for simplicity. It is common
    to train LLMs with input sizes of at least 256.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the meaning of `stride=1`, let’s fetch another batch from this
    dataset:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The second batch has the following contents:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If we compare the first and second batches, we can see that the second batch’s
    token IDs are shifted by one position (for example, the second ID in the first
    batch’s input is 367, which is the first ID of the second batch’s input). The
    `stride` setting dictates the number of positions the inputs shift across batches,
    emulating a sliding window approach, as demonstrated in figure 2.14.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-14.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 When creating multiple batches from the input dataset, we slide
    an input window across the text. If the stride is set to 1, we shift the input
    window by one position when creating the next batch. If we set the stride equal
    to the input window size, we can prevent overlaps between the batches.
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Exercise 2.2 Data loaders with different strides and context sizes
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To develop more intuition for how the data loader works, try to run it with
    different settings such as `max_length=2` and `stride=2,` and `max_length=8` and
    `stride=2`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Batch sizes of 1, such as we have sampled from the data loader so far, are useful
    for illustration purposes. If you have previous experience with deep learning,
    you may know that small batch sizes require less memory during training but lead
    to more noisy model updates. Just like in regular deep learning, the batch size
    is a tradeoff and a hyperparameter to experiment with when training LLMs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look briefly at how we can use the data loader to sample with a batch
    size greater than 1:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This prints
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that we increase the stride to 4 to utilize the data set fully (we don’t
    skip a single word). This avoids any overlap between the batches since more overlap
    could lead to increased overfitting.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 2.7 Creating token embeddings
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step in preparing the input text for LLM training is to convert the
    token IDs into embedding vectors, as shown in figure 2.15. As a preliminary step,
    we must initialize these embedding weights with random values. This initialization
    serves as the starting point for the LLM’s learning process. In chapter 5, we
    will optimize the embedding weights as part of the LLM training.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-15.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 Preparation involves tokenizing text, converting text tokens to
    token IDs, and converting token IDs into embedding vectors. Here, we consider
    the previously created token IDs to create the token embedding vectors.
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A continuous vector representation, or embedding, is necessary since GPT-like
    LLMs are deep neural networks trained with the backpropagation algorithm.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Note  If you are unfamiliar with how neural networks are trained with backpropagation,
    please read section A.4 in appendix A.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the token ID to embedding vector conversion works with a hands-on
    example. Suppose we have the following four input tokens with IDs 2, 3, 5, and
    1:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'For the sake of simplicity, suppose we have a small vocabulary of only 6 words
    (instead of the 50,257 words in the BPE tokenizer vocabulary), and we want to
    create embeddings of size 3 (in GPT-3, the embedding size is 12,288 dimensions):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Using the `vocab_size` and `output_dim`, we can instantiate an embedding layer
    in PyTorch, setting the random seed to `123` for reproducibility purposes:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The print statement prints the embedding layer’s underlying weight matrix:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The weight matrix of the embedding layer contains small, random values. These
    values are optimized during LLM training as part of the LLM optimization itself.
    Moreover, we can see that the weight matrix has six rows and three columns. There
    is one row for each of the six possible tokens in the vocabulary, and there is
    one column for each of the three embedding dimensions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s apply it to a token ID to obtain the embedding vector:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The returned embedding vector is
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If we compare the embedding vector for token ID 3 to the previous embedding
    matrix, we see that it is identical to the fourth row (Python starts with a zero
    index, so it’s the row corresponding to index 3). In other words, the embedding
    layer is essentially a lookup operation that retrieves rows from the embedding
    layer’s weight matrix via a token ID.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Note  For those who are familiar with one-hot encoding, the embedding layer
    approach described here is essentially just a more efficient way of implementing
    one-hot encoding followed by matrix multiplication in a fully connected layer,
    which is illustrated in the supplementary code on GitHub at [https://mng.bz/ZEB5](https://mng.bz/ZEB5).
    Because the embedding layer is just a more efficient implementation equivalent
    to the one-hot encoding and matrix-multiplication approach, it can be seen as
    a neural network layer that can be optimized via backpropagation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve seen how to convert a single token ID into a three-dimensional embedding
    vector. Let’s now apply that to all four input IDs (`torch.tensor([2,` `3,` `5,`
    `1])`):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The print output reveals that this results in a 4 × 3 matrix:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Each row in this output matrix is obtained via a lookup operation from the embedding
    weight matrix, as illustrated in figure 2.16.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-16.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 Embedding layers perform a lookup operation, retrieving the embedding
    vector corresponding to the token ID from the embedding layer’s weight matrix.
    For instance, the embedding vector of the token ID 5 is the sixth row of the embedding
    layer weight matrix (it is the sixth instead of the fifth row because Python starts
    counting at 0). We assume that the token IDs were produced by the small vocabulary
    from section 2.3.
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Having now created embedding vectors from token IDs, next we’ll add a small
    modification to these embedding vectors to encode positional information about
    a token within a text.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 2.8 Encoding word positions
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In principle, token embeddings are a suitable input for an LLM. However, a minor
    shortcoming of LLMs is that their self-attention mechanism (see chapter 3) doesn’t
    have a notion of position or order for the tokens within a sequence. The way the
    previously introduced embedding layer works is that the same token ID always gets
    mapped to the same vector representation, regardless of where the token ID is
    positioned in the input sequence, as shown in figure 2.17.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-17.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 The embedding layer converts a token ID into the same vector representation
    regardless of where it is located in the input sequence. For example, the token
    ID 5, whether it’s in the first or fourth position in the token ID input vector,
    will result in the same embedding vector.
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In principle, the deterministic, position-independent embedding of the token
    ID is good for reproducibility purposes. However, since the self-attention mechanism
    of LLMs itself is also position-agnostic, it is helpful to inject additional position
    information into the LLM.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we can use two broad categories of position-aware embeddings:
    relative positional embeddings and absolute positional embeddings. Absolute positional
    embeddings are directly associated with specific positions in a sequence. For
    each position in the input sequence, a unique embedding is added to the token’s
    embedding to convey its exact location. For instance, the first token will have
    a specific positional embedding, the second token another distinct embedding,
    and so on, as illustrated in figure 2.18.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-18.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 Positional embeddings are added to the token embedding vector to
    create the input embeddings for an LLM. The positional vectors have the same dimension
    as the original token embeddings. The token embeddings are shown with value 1
    for simplicity.
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Instead of focusing on the absolute position of a token, the emphasis of relative
    positional embeddings is on the relative position or distance between tokens.
    This means the model learns the relationships in terms of “how far apart” rather
    than “at which exact position.” The advantage here is that the model can generalize
    better to sequences of varying lengths, even if it hasn’t seen such lengths during
    training.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Both types of positional embeddings aim to augment the capacity of LLMs to understand
    the order and relationships between tokens, ensuring more accurate and context-aware
    predictions. The choice between them often depends on the specific application
    and the nature of the data being processed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: OpenAI’s GPT models use absolute positional embeddings that are optimized during
    the training process rather than being fixed or predefined like the positional
    encodings in the original transformer model. This optimization process is part
    of the model training itself. For now, let’s create the initial positional embeddings
    to create the LLM inputs.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we focused on very small embedding sizes for simplicity. Now, let’s
    consider more realistic and useful embedding sizes and encode the input tokens
    into a 256-dimensional vector representation, which is smaller than what the original
    GPT-3 model used (in GPT-3, the embedding size is 12,288 dimensions) but still
    reasonable for experimentation. Furthermore, we assume that the token IDs were
    created by the BPE tokenizer we implemented earlier, which has a vocabulary size
    of 50,257:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Using the previous `token_embedding_layer`, if we sample data from the data
    loader, we embed each token in each batch into a 256-dimensional vector. If we
    have a batch size of 8 with four tokens each, the result will be an 8 × 4 × 256
    tensor.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s instantiate the data loader (see section 2.6) first:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This code prints
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As we can see, the token ID tensor is 8 × 4 dimensional, meaning that the data
    batch consists of eight text samples with four tokens each.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now use the embedding layer to embed these token IDs into 256-dimensional
    vectors:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The print function call returns
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The 8 × 4 × 256–dimensional tensor output shows that each token ID is now embedded
    as a 256-dimensional vector.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'For a GPT model’s absolute embedding approach, we just need to create another
    embedding layer that has the same embedding dimension as the `token_embedding_
    layer`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The input to the `pos_embeddings` is usually a placeholder vector `torch.arange(context_length)`,
    which contains a sequence of numbers 0, 1, ..., up to the maximum input length
    –1\. The `context_length` is a variable that represents the supported input size
    of the LLM. Here, we choose it similar to the maximum length of the input text.
    In practice, input text can be longer than the supported context length, in which
    case we have to truncate the text.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The output of the print statement is
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'As we can see, the positional embedding tensor consists of four 256-dimensional
    vectors. We can now add these directly to the token embeddings, where PyTorch
    will add the 4 × 256–dimensional `pos_embeddings` tensor to each 4 × 256–dimensional
    token embedding tensor in each of the eight batches:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The print output is
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `input_embeddings` we created, as summarized in figure 2.19, are the embedded
    input examples that can now be processed by the main LLM modules, which we will
    begin implementing in the next chapter.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-19.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 As part of the input processing pipeline, input text is first broken
    up into individual tokens. These tokens are then converted into token IDs using
    a vocabulary. The token IDs are converted into embedding vectors to which positional
    embeddings of a similar size are added, resulting in input embeddings that are
    used as input for the main LLM layers.
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LLMs require textual data to be converted into numerical vectors, known as embeddings,
    since they can’t process raw text. Embeddings transform discrete data (like words
    or images) into continuous vector spaces, making them compatible with neural network
    operations.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the first step, raw text is broken into tokens, which can be words or characters.
    Then, the tokens are converted into integer representations, termed token IDs.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special tokens, such as `<|unk|>` and `<|endoftext|>`, can be added to enhance
    the model’s understanding and handle various contexts, such as unknown words or
    marking the boundary between unrelated texts.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The byte pair encoding (BPE) tokenizer used for LLMs like GPT-2 and GPT-3 can
    efficiently handle unknown words by breaking them down into subword units or individual
    characters.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use a sliding window approach on tokenized data to generate input–target
    pairs for LLM training.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding layers in PyTorch function as a lookup operation, retrieving vectors
    corresponding to token IDs. The resulting embedding vectors provide continuous
    representations of tokens, which is crucial for training deep learning models
    like LLMs.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While token embeddings provide consistent vector representations for each token,
    they lack a sense of the token’s position in a sequence. To rectify this, two
    main types of positional embeddings exist: absolute and relative. OpenAI’s GPT
    models utilize absolute positional embeddings, which are added to the token embedding
    vectors and are optimized during the model training.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
