- en: 6 Taking the next step with Next.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using Next.js to build a dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Material UI components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using WireMock to help stub our API calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Until this point, we have worked through research spikes to explore creating
    and parsing an ACH file, creating a database, and generating APIs to access our
    data. In this final research spike, we’ll start working on our application dashboard.
    A dashboard is the user interface (UI) from which it is possible to upload and
    view files, view records, and obtain any other useful information. While there
    are plenty of options available for creating a UI, we have decided to go with
    Next.js as it is built on React, which is also very popular. However, since everything
    is powered by APIs, the UI could be swapped with Remix, Vue, Angular, or any other
    technology used in our company.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 showed us how to take an API-driven design approach. While we have
    not built all our APIs by switching to the UI yet, we will begin to see what data
    we want (or need) to be returned as part of our APIs. By stubbing out the data
    fields, we can ensure our UI is making exactly the same calls required for the
    real APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Getting started with Next.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting started with Next.js is very easy, and we chose it partly because it
    is easy to get an application up and running, but also because it can grow to
    support any application we care to create. Next.js is a full stack React framework.
    React itself is a library used for building web interfaces. Although it is simple
    to learn, it does require a basic understanding of some common web technologies
    such as
  prefs: []
  type: TYPE_NORMAL
- en: '*Hypertext Markup Language (HTML**)*—The standard markup language for building
    web pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cascading Style Sheets (CSS**)*—A way to describe how HTML elements should
    be displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Document Object Model (DOM**)*—Defines properties, methods, and events for
    HTML elements and allows languages such as JavaScript to add/change/remove HTML
    elements and attributes, as well as react to HTML events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React builds and improves on the listed web technologies by providing additional
    concepts to facilitate UI development. Some key concepts of React are
  prefs: []
  type: TYPE_NORMAL
- en: '*Component**s*—Reusable and self-contained pieces of code that render parts
    of the UI. They are the building blocks of our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Stat**e*—Holds dynamic information within a component, which can be used to
    change its behavior and trigger rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hook**s*—Help manage the state and lifecycle of components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of this may seem like a lot to digest, especially if you are new to UI development.
    The truth is that you should still be able to walk through this research spike
    and gain a basic understanding of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does Next.js fit into all of this? The React web site ([https://react.dev](https://react.dev))
    recommends using Next.js (or Remix) because it is a full-featured production-grade
    React framework. That means that Next.js comes with a lot of powerful features,
    such as
  prefs: []
  type: TYPE_NORMAL
- en: File-system-based routing that supports multiple layouts, nested routing, and
    error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side rendering (CSR) and server-side rendering (SSR), depending on the
    needs of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data fetching with `async`/`await`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for multiple styling methods such as CSS Modules, Tailwind CSS, and
    CSS-in-JS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization for images, fonts, and scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get started, we have to ensure that we have Node.js installed ([https://nodejs.org/en](https://nodejs.org/en))
    because we need access to its tools, beginning with the `npx` command. `npx` is
    a command line tool that helps simplify the running of `npm` (Node Package Manager)
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: We can execute `npx` `create-next-app@latest` to answer a few questions and
    then start the project with `npm` `run` `dev`. We should be able now to log in
    to http://localhost:3000 and see whether the default page comes up. Of course,
    the default page is a test to make sure we have our setup correctly. We want to
    develop a UI that allows a user to easily load files and review associated data.
    Usually, the business already has a design in mind that is based on existing standards.
    As we are not required to follow any particular design, a good option is to start
    using a sample template. There are plenty of options out there, but a great way
    to get started is by using the dashboard template provided by Material UI at [https://mng.bz/Xx66](https://mng.bz/Xx66).
    We pulled the template for MUI 5.x, which can be viewed at [https://mng.bz/yWnq](https://mng.bz/yWnq).
    As previously mentioned, we are not limited to this particular template, but it
    does provide us with a basic layout that we can quickly customize to create our
    final project.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend grabbing the TypeScript versions of the template as we will be
    using TypeScript throughout the project. TypeScript is a superset of JavaScript,
    which means that your existing JavaScript skills can be employed when using TypeScript.
    The benefit of TypeScript is that it adds explicit types to JavaScript (among
    other things). We believe that the explicit types help with the maintainability
    of the code over the long term by helping catch errors earlier during development.
    The long-term maintainability of the code is very important, especially when we
    consider how long our code may be out in the field, and given FinTech, that can
    be a long time! While we will get the basics of TypeScripts within this project,
    *Essential TypeScript 5* (2023, Manning) by Adam Freeman is a great resource,
    or you can check out the TypeScript tutorial available at [https://www.typescripttutorial.net/](https://www.typescripttutorial.net/).
  prefs: []
  type: TYPE_NORMAL
- en: Before we can get the project started with the sample template, we need to ensure
    the dependencies are installed, which can be done with the command line in the
    next listing. This command installs a few requirements for Material UI, as well
    as for `recharts` (for our visualization needs) and `axios` (for making API calls).
    These packages were chosen because we have seen them in use in FinTech, and they
    have solid documentation to help us if we get stuck.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.1  Installing dependencies for our dashboard
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Installs all the components needed for our dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: With that complete, the project should be up and running. Now we only need to
    customize the dashboard and add additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: One of the ways we like to begin with new code is to dive right into it and
    start adding additional functionality or refactoring existing code. Let’s jump
    right in!
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 Creating an upload page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To help you get started, Next.js has extensive documentation and a great tutorial
    ([https://nextjs.org/learn](https://nextjs.org/learn)) if you are completely new
    to React and web development. We begin with Next.js routing as we find it straightforward
    and just need to create a simple structure on our filesystem. We can easily create
    a page that will handle our ACH file uploads, as shown in the next listing. The
    page.tsx is key to having our web page displayed. TSX is a syntax extension for
    TypeScript that lets us write HTML-like markup inside the Typescript file. You
    may also see JSX pages in various tutorials, which are just the JavaScript equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.2  Our directory structure for the upload page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '#1 This file-based routing will cause Next.js to display page.tsx when we navigate
    to /uploads.'
  prefs: []
  type: TYPE_NORMAL
- en: We want to create a simple page that allows us to drag and drop files onto the
    page to be uploaded. We will stay away from the actual file uploading for now
    to focus on some of the design first. Given the structure from listing 6.2, we
    want to be able to navigate to http://localhost:3000/uploads, so we put a placeholder
    in page.tsx to ensure we can confirm things are working.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.3  Placeholder upload page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We export a default function named Uploads.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Typography is a component from MUI that allows us to create text; here,
    we are using a variant of h1, which will give us a very long text, just like the
    HTML h1 tag would.'
  prefs: []
  type: TYPE_NORMAL
- en: With that in place, you should be able to navigate to the upload endpoint and
    see “Hello, Uploads!”
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.1 Testing our upload page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though we have not created a substantial page, let’s take a moment to see
    how we may test our pages in React. We will use Jest, a popular option for testing
    React apps. First, we need to install the required dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.4  Jest dependencies
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Additional libraries to help support testing efforts'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we generate a basic configuration with `npm init jest@latest`. Then, we
    create a directory structure where we keep our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.5  Test directory structure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As shown in listing 6.5, the standard procedure is to create a high-level `__tests__`
    directory as the subdirectories do not matter then (you only want them to make
    sense). The uploads.test.tsx will store our actual test code. For now, we only
    want to ensure that our “Hello, Uploads!” text is displayed when the upload component
    is rendered. To accomplish that, the following listing shows the sample test.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.6  Simple Jest test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The needed import statements for our test'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The describe keyword allows us to group tests, which will be displayed under
    the title “Upload Page.”'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 The it keyword starts our test, along with the header of ''renders a heading’.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Renders our component'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Retrieves the h 1 tag using the ARIA role. The level parameter corresponds
    to the size of the header: h 1 , h2, and h3 would use levels 1 , 2, and 3, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Ensures the variable is defined'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Uses a regular expression to ensure the text matches our expected text'
  prefs: []
  type: TYPE_NORMAL
- en: The unit test defined in listing 6.6 should look somewhat familiar, given the
    test scripts we created in Python with `pytest`. Of course, the syntax may differ
    slightly, but the approach is the same. It would be interesting to revisit the
    `getByRole` method used to get our header tag and its contents. This method uses
    the role defined by the Accessible Rich Internet Applications (ARIA) standard.
    By creating our unit tests using `getByRole`, we take an accessibility-first approach
    to our web page design. Assistive technologies will be interacting with our web
    UI through ARIA tags.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer program  Description automatically generated](../Images/CH06_F01_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1  Output from running our Jest test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you are developing within an IDE such as JetBrains, WebStorm, or VS Code,
    you may be able to run these tests directly from within the IDE. Or, you could
    execute the command `npm` `run` `test` from the command line. Executing from the
    command line helps illustrate the importance of the `describe` and `it` keywords.
    As shown in listing 6.6, the `Upload` `Page` heading is pulled from the `describe`
    keyword. Each test defined by the `it` keywords is also represented, As shown
    in figure 6.1, these keywords keep our tests organized and the output readable.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, unit testing is not just important for our backend Python code,
    but for the UI as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you have directly browsed the uploads page, you can see that we have lost
    our navigation bars for the page. The next section shows how to add them back.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3 Refactoring our navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with any code we did not write ourselves, we need to poke around to get a
    feel for the layout and structure. Since we will be customizing the dashboard
    for our own needs, we need to understand how the dashboard navigates between components.
    This may take some detective work, but it’s worth it. After some digging, we find
    that the navigation for our pages is controlled by two components that we can
    see in our Dashboard.tsx—the `AppBar` and the `Drawer`. We can start by refactoring
    them into their own components. After we perform the refactoring, we can decide
    how to include them on subsequent pages.
  prefs: []
  type: TYPE_NORMAL
- en: The first order of the business is to extract the `AppBar` tag from Dashboard.tsx
    and move it to its own component in `src/app/components/navigation/TopMenuBar.tsx`.
    The directory structure and naming conventions can be anything within reason.
    The component then contains the existing `AppBar` logic with a few updates to
    handle, regardless of whether the drawer is open or closed.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.7  Navigation menu bar
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines an interface for the TopMenuBar that takes a function to execute
    when the button is clicked and a boolean to determine whether the drawer is open'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Maintains the state in the component'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 When the parameter drawerOpen changes, updates the state accordingly'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 The AppBar’s open parameter is our internal state.'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 When the icon is clicked, the toggleDrawer function that was passed in is
    executed.'
  prefs: []
  type: TYPE_NORMAL
- en: We also want to do something similar for the sidebar navigation, so we refactor
    the `Drawer` tag from Dashboard.tsx, moving it to its own component.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.8  Sidebar navigation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines an interface for the SideBarNavProps that takes a function to execute
    when the button is clicked and a boolean to determine whether the drawer is open'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Unpacks the SideBarNavProps as part of the function call'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Maintains the state in the component'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 When the parameter drawerOpen changes, updates the state accordingly'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Our open state is used to determine the Drawer state.'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 When the icon is clicked, the toggleDrawer function that was passed in is
    executed.'
  prefs: []
  type: TYPE_NORMAL
- en: We can then use these components in the Dashboard.tsx as shown in the next listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.9  Updated Dashboard.tsx
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Stores the state of the drawer'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Creates an arrow function named toggleDrawer we call to set the open state'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Uses our refactored components which accept a function to show/hide the
    drawer and the current state of the drawer'
  prefs: []
  type: TYPE_NORMAL
- en: Working through this refactoring exercise introduced us to Material UI and Next.js.
    In addition, we are now obviously able to include these components in our upload
    page, which was our original goal. While we have refactored the code, there is
    some noticeable duplication handling regarding whether the drawer is open. With
    the way we have it at the moment, we will need to duplicate the `open` state and
    `toggleDrawer` function in each component we choose to use them in, which is less
    than ideal since they will always need to be used together.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation component challenge
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: While there may be the occasional need to duplicate code, we probably do not
    need or want to do it in this case. There are a few ways we may want to handle
    this (maybe we do not want to break out the `AppBar` and `Drawer` elements). If
    we refactor them into a single component, we would only have to import that single
    component. Or perhaps, since we have them broken apart already, can we just wrap
    them into a single component? The goal of this exercise is to eliminate the need
    to duplicate the `open` state and `toggleDrawer` function in every component.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 Converting recent order to recent ACH uploads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we dipped our toes into some Next.js, let’s take a look at reworking
    the `Recent` `Order` component to list our recent ACH uploads instead. As always,
    we are looking to work in short development cycles. This means we first use the
    hardcoded data that is part of the template and update it to fit our needs. Then,
    we replace the hardcoded data with a mocked API call. The template has a function
    to create the rows of data, as shown in the next listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.10  `createData` function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The existing parameters we need to update'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The existing return statement we need to update'
  prefs: []
  type: TYPE_NORMAL
- en: We repurpose this code to include fields that we want to see when viewing loaded
    files for the day. For now, we can imagine that we would like to see the date
    the file was loaded (possibly the time as well), the name of the file, and both
    the credit/debit amounts for the file. The required updates are shown in the next
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.11 Updated  `createData` function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Updates parameters for createData. We do not necessarily need to worry about
    the data types at this point. We just use the standard types of number and string.
    We could define the date as a Date type but that is unnecessary at this point.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Updated return statement'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create our rows of data with the new amounts. Note that we have two
    amount fields, and whenever we have amounts, we want to include a variety of them
    to ensure the data will display as desired (determined by the stakeholders in
    the project). Depending on the API and datatype we use, there could be some look
    and feel problems with the UI when displaying amounts. Therefore, listing 6.12
    shows data we are passing, and we want to be sure we hit some of the edge cases
    such as
  prefs: []
  type: TYPE_NORMAL
- en: Trailing zero, which will likely be thrown out when using a numeric datatype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dollar amounts greater than $999 to see a separator (such as a comma) for the
    amount
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing 6.12  Sample data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Returns a date; this may come through from the API as a timestamp we’ll
    need to handle.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Ensures our numeric values cover some of the use cases we outlined'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the API, you may be receiving a formatted amount, in which case,
    you obviously do not need to worry about the mentioned problems. However, when
    we design APIs, we usually try to keep the formatting to a minimum and not enforce
    formatting/locale specifics unless necessary. So, we favor returning `1000.0`
    for $1,000.00 because, depending on the location, we may use a space and/or decimal
    to separate numbers. Of course, use cases differ from one company to another and
    one project to another. In our situation, we are in the unique position of having
    control over both the UI and the backend, which means we could return our amount
    exactly how we want it displayed and just put it directly onto the page.
  prefs: []
  type: TYPE_NORMAL
- en: Although unlikely to be a problem with this application, localization (L10n)
    may be a concern to us since ACH deals with US-based financial institutions, which
    is why we favor the unformatted amounts being returned from the API. Perhaps we
    plan for our dashboard to be abstract enough to be easily adapted to SEPA or BECS,
    so we need to ensure flexibility in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we update the table to display the updated rows. We take the data stored
    in `rows` and use the `map` function to take each row and create our table rows.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.13  Updated table
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The updated table headers'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 We use map to create a new array of <TableRow> tags for each element.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Each table row contains a key property.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Using our row data for date and name'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 We display the amount fields as-is to see how they look.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if we view our web page, we should notice that we are experiencing
    the problems we mentioned—truncating the trailing zero and missing a thousands
    separator, as shown in figure 6.2.
  prefs: []
  type: TYPE_NORMAL
- en: We could accomplish some basic formatting by using `toFixed` and a hardcoded
    dollar sign, as in listing 6.14.
  prefs: []
  type: TYPE_NORMAL
- en: '![A white background with black lines  Description automatically generated](../Images/CH06_F02_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2  Unformatted credit and debit totals
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Listing 6.14  Basic formatting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Performs some initial formatting on the amounts, forcing the use of the
    dollar sign and ensuring we see two decimal places by using toFixed(2)'
  prefs: []
  type: TYPE_NORMAL
- en: This code gets us basic formatting with only the thousands separator. Instead
    of having to remember to format currency everywhere, which can lead to inconsistencies
    and lock us into a locale, let’s define a function we can call whenever we want
    to format a currency. Not only will this provide consistency in our presentation
    of currencies, but it should also allow us to find places where we are displaying
    currencies in our code (should we ever need to).
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, we will be using `Intl.NumberFormat,` which not only can
    format currencies for different locations but also for other units of measurements
    such as mph/kh and liter/gallon. The following listing shows our simple exported
    function that wraps `Intl.NumberFormat`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.15  Wrapper for `Intl.NumberFormat`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The function takes in a number.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Different currencies can be passed in but default to USD.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Locale can be controlled as well, defaulting to en-US.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 The actual work is done by Intl.NumberFormat that we style as currency.'
  prefs: []
  type: TYPE_NORMAL
- en: We can also create some Jest tests to ensure we understand how this code functions,
    as well as confirm that we are seeing the expected formatting. The following listing
    shows example Jest tests we may want to use to confirm formatting is taking place.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.16  Jest tests for our `formatCurrency` routine
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Imports the necessary functions'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses describe to group the tests together'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Ensures the trailing zeroes are not dropped'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Ensures the defaults are taken'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Checks that a comma is included'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Checks that multiple commas are added'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Tests out German formatting in euros. The \u00A0 is a Unicode notation for
    no-break space.'
  prefs: []
  type: TYPE_NORMAL
- en: After confirming our tests run successfully, we can replace our table cells
    that called `toFixed(2)` with a call to our new `formatCurrency` routine.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.17  Using the new `formatCurrency` function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Replaces the manual formatting with a call to our new function'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 shows our amounts formatted exactly the way we wanted it, with commas
    and two significant digits after the decimal.
  prefs: []
  type: TYPE_NORMAL
- en: '![A white background with black lines  Description automatically generated](../Images/CH06_F03_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3  Formatted credit and debit totals
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is often easier to use an existing component as a starting point and customize
    it to meet our needs. After our customizations, we have a working component capable
    of displaying our uploaded ACH files to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 Mocking our ACH uploads data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we customized our component to fit our particular use
    case of viewing recent ACH file uploads. However, we used hardcoded values, and
    while that helped us get a feel for the fields we need, it is not very useful
    for anything other than mocking up the UI. We have a database that we will want
    to retrieve this data from, but we are not quite there yet in terms of building
    APIs. As an intermediate step, let’s add the API call but have it retrieve mocked
    data instead of actually hitting the endpoint. Mocking data not only lets us get
    started quickly, but also has a variety of other uses such as for testing edge
    cases, simulating bad data, and other scenarios. So, learning about mocking data
    will have long-lasting benefits beyond this example.
  prefs: []
  type: TYPE_NORMAL
- en: Why would we choose to do something like this? The reality is that projects
    can span multiple people, teams, departments, and even companies. It is entirely
    possible that we may be assigned to work on the UI, while the APIs and backend
    code are being developed in parallel. This type of parallel development is often
    going on when we are trying to bring our product to market as fast as possible,
    and we cannot wait for the APIs and backend to be finished before we start working
    on the frontend. Or perhaps, we need to call a third-party API, but contract negotiations
    are still ongoing, and we do not have access to the API.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, a tool such as WireMock can allow our code to make the same
    API call but return a predefined response. We could also use this tool to obtain
    error responses or edge case data that we may not have readily available, which
    can help us test our code.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.1 Adding WireMock to Docker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We add WireMock to our project in the same manner—by creating a Dockerfile first
    and then referencing it in our docker-compose.yml, as shown in the following two
    listings. The needed Dockerfile does not have much in it and could be contained
    in the docker-compose.yml, but we prefer to keep the docker-compose.yml as short
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.18  Dockerfile for WireMock
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in listing 6.19, we have introduced volumes to our WireMock service
    definition. These volumes exist on the local file system and are made available
    by mapping them to a directory in the container. Similar to the way ports are
    mapped, we specify the host directory first and then the directory it should map
    to in the container. WireMock allows us to specify stub mappings and file definition
    stubs (more on this later). Using volumes will allow us to make changes to the
    mappings without the need to build repeatedly. While a Dockerfile allows the `VOLUME`
    keyword where we could specify volumes, the recommended approach is to use the
    docker-compose.yml file because it allows for a separation of duties between building
    (Dockerfile) and runtime (docker-compose.yml).
  prefs: []
  type: TYPE_NORMAL
- en: How about using `COPY` commands in the Dockerfile to move our mappings to the
    container? That would be another option to use if we were interested in building
    an image containing mappings that we would then distribute to our team. However,
    in this case, we are only interested in working with these mappings locally, and
    we do not need to rebuild our container whenever we want to utilize an updated
    mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.19  Updates to docker-compose.yml
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Map locations on our filesystem to our container'
  prefs: []
  type: TYPE_NORMAL
- en: With that complete, we can start our Docker containers again and navigate over
    to http://localhost:8081/__admin/, where we should receive a response similar
    to the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.20  WireMock admin response
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This code confirms that we indeed have WireMock up and running. Perhaps not
    unsurprisingly, we do not have any mappings defined yet. So, let’s tackle that
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.2 Setting up mappings in WireMock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WireMock is a powerful tool, and we only scratch the surface in this section.
    However, it should be enough to get us started, and we can always investigate
    its additional features as we need more functionality (remember our YAGNI principle
    from chapter 3). We are primarily interested in stubbing out mock responses so
    that when our UI makes an API call, we are returning some meaningful data. We
    start by creating a simple stub in the `./wiremock/mappings` directory named hello_world.json.
    The name is not extremely important at this point. The next listing shows the
    contents of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.21  Our first stub
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If we try to access http://localhost:8081/api/v1/hello/world, we receive a response
    such as `No` `response` `could` `be` `served` `as` `there` `are` `no` `stub` `mappings`
    `in` `this` `WireMock` `instance`. What gives? We need to make an empty `POST`
    call to http://localhost:8081/__admin/mappings/reset for WireMock to be able to
    pick up our changes. There are some Postman samples associated with this text
    that can get you started. After that call, you should be able to access the endpoint
    again and see “Hello, World!” Furthermore, if you request the mappings from http://localhost:8081/__admin/,
    you will see something similar to the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.22  WireMock admin response with our new stub
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That should be painless. Now, let’s look at how we might want to mock our response
    to obtain the information for uploaded ACH files. We should already have a good
    idea of the fields we want to return because we have already used hardcoded data
    when building the UI. So, we will use that data and create ach_files_response.json
    in the `__files` directory this time. By defining responses in the `__files` directory,
    it will save us from complicating our mappings and allow other APIs to reuse responses
    as necessary. A response sample is shown in the next listing, and we can use as
    much or as little data as we want.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.23  Sample ACH response body
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Sample JSON that contains our test data'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the contents of the response defined, we need to define a mapping
    for it. The mapping is similar to what we have already seen, except that we now
    specify the `bodyFileName` in the response with the filename of ach_files_response.json
    we defined before.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.24  ACH response mapping
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The request will only execute on a GET.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Further refines the mapping with the URL'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 The response will be a status code 200.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Defines any headers that are needed'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Uses bodyFileName and specifies a name in the __files directory to return'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that defined, we just need to refresh our mappings for the changes to
    take effect. We can use multiple methods, and they are listed in the order of
    their impact on the overall environment (from least to most impactful):'
  prefs: []
  type: TYPE_NORMAL
- en: The Admin API can be restarted to reload the mappings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart our Docker compose instance completely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the mappings have been refreshed, navigating to http://localhost:8081/api/v1/files
    will show the response. Figure 6.4 illustrates the response using Postman, which
    provides some highlighting/formatting of the output and allows us to check returned
    headers easily.
  prefs: []
  type: TYPE_NORMAL
- en: WireMock is a powerful tool, and we only scratched its surface. For now, it
    is enough to get us going with building the UI. Next, we look at how to make requests
    to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.3 Accessing endpoints with axios
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do, if not done already, is ensure axios is installed
    with `npm` `install` `axios`. After that, we can import it into our components
    as needed and get to work!
  prefs: []
  type: TYPE_NORMAL
- en: Now we can open the RecentAchUploads.tsx, remove the `createData` function,
    and clear out our test data since we will be retrieving our data from the WireMock
    instance. Instead of hardcoded data, we will define our rows to be an array of
    `AchUploads` (listing 6.25).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH06_F04_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4  Response from our `/api/v1/files` endpoint as viewed in Postman
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Listing 6.25  Preparing our component to receive data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a structure for our data so we can type it appropriately'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Our rows data will be stored in an array of type ACHUpload.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can make our request to populate data.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.26  Making an API call with axios
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '#1 useEffect is a perfect React function for making API calls.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses axios to get our files listing'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Handles the returned Promise by displaying the data and setting rows to
    the returned data'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Logs any problems to the console'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 The empty array [] tells React to execute this only once.'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we recommend that these API calls are offloaded and called from a single
    location instead of being embedded in the components, but for now, it is okay
    to have them inside the component. For instance, we often create `api` folder
    or equivalent where these functions can be imported from. This allows the API
    calls to be easily accessed from multiple locations.
  prefs: []
  type: TYPE_NORMAL
- en: However, our more immediate concern is that we have a hardcoded URL pointed
    to the localhost (http://localhost:8081), which will certainly change when we
    deploy the Dashboard to Docker. So for the time being, let’s take advantage of
    Next.js to store our variables, and then, we’ll be able to configure them for
    Docker easily. Thus, we create an .env.local file.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.27  Our .env.local file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can now update our code to use the environment variable in our URL.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.28  Updated API call
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Returns the environment variable or sets it to the empty string when undefined'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Updates the axios call to use the new apiUrl'
  prefs: []
  type: TYPE_NORMAL
- en: With this code, we can test our API and still see the sample files we are returning
    from WireMock. We are now able to change the URL our APIs hit when we are building
    our Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6 Expanding the UI with an ACH batch view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you understand these pieces, let’s take a look at combining Next.js,
    Recharts, Axios, and WireMock to create a view of ACH batches. On the dashboard,
    we would like to be able to click one of the file names presented to view the
    batches for that file. The view will display a scatterplot and provide the ability
    to display more details about the batches for each company in the ACH file, as
    shown in figure 6.5\. Providing information on the characteristics of the batches
    (in this case their size based on their amount and number of entries) can help
    us start putting controls in place for tasks such as fraud detection and risk
    management in the future as we expand the application. The scatterplot allows
    us to easily spot batches with larger dollar amounts or with higher item counts.
    Eventually, if we were to mix in historical data, we could then analyze patterns
    for these companies and highlight unusual activity patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/CH06_F05_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5  An ACH batch view
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 6.6.1 Defining our WireMock data for the ACH batch view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our JSON data will essentially be an array of arrays. We also know that there
    can be multiple batches in an ACH file. Each batch has an associated company,
    and the company may have multiple batches in a file. We want to have the batches
    returned and grouped by the company. So, something like the following listing
    should work.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.29  Sample ACH batch data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We return an array of all batches in a file grouped by company.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The company name of each batch is present.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 An array of all batches for a company called companyBatches'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Multiple JSON objects containing our batch data'
  prefs: []
  type: TYPE_NORMAL
- en: We define some batches we are going to associate with the stubbed data we used
    for the file. Specifically, we want to return this data when someone queries an
    API endpoint such as `/api/v1/files/{fileId}/batches`. As we saw in WireMock,
    we could define hardcoded paths for all the `fileId`s we were interested in. However,
    that would result in a lot of mappings. Instead, we can dynamically match these
    fields using templating and return specific responses for each. We define ach_files_batches.json
    in the following listing. Note that we use `urlPathTemplate` and specify `{fileId}`.
    Then we also use `{{request.path.fileId}}` in the `bodyFileName` of the response,
    which allows us to extract the dynamic UUID we expect to receive and use it in
    a response we would then define in the `__files` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.30  WireMock templating example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Uses urlPathTemplate to allow the use of parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The request.path.fileId references the variable defined in the urlPathTemplate.'
  prefs: []
  type: TYPE_NORMAL
- en: With all said, we would have the ability to define specific responses to API
    calls. Figure 6.6 illustrates this concept better. Note that we are not actually
    saving anything into WireMock. We are using canned responses we have prepopulated
    in the WireMock `__files` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a diagram  Description automatically generated](../Images/CH06_F06_Kardell.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6  WireMock sequence
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we are able to return data, we can define a component that can display
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6.2 Updating the dashboard to take us to the batches screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We update the RecentAchUploads.tsx so that the filename becomes a link.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.31  Updated `RecentAchUploads`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Updates the text to be a link that will use the file ID'
  prefs: []
  type: TYPE_NORMAL
- en: The `fileDetails` screen takes the UUID of the file, which will help drive the
    resulting queries. Next.js uses file-based routing that lets us define the URL
    using a simple folder structure. In this case, including the UUID as part of the
    URL is denoted by a directory in square brackets. The following listing is the
    folder structure we need to create.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.32  Folder structure for the file details page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The square brackets denote a parameter on the URL we can access.'
  prefs: []
  type: TYPE_NORMAL
- en: The `[id]` is a dynamic parameter in our URL. For example, with this structure,
    we should be able to navigate to URLs such as `/fileDetails/0854b018-c5ce-4e00-8a4f-d268a1a85aa2`
    or `/fileDetails/d11fb49c-4a07-4b96-88cc-db1fc7277bfa`, assuming those were valid
    UUIDs for our ACH files.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6.3 Displaying batch details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The page.tsx will contain the logic to retrieve the batch information and display
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.33  Batch details
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines our JSON structure so that we can strongly type the response'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Allows the URL parameters to be accessed'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 References the URL parameter by the same name we defined in square brackets'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Stores the batches with useState like we did in other components'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Uses useEffect to gather the data from the API'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Maps the returned batches to display the UI elements'
  prefs: []
  type: TYPE_NORMAL
- en: This component presents the accordion view showed earlier in the chapter as
    part of figure 6.5 for the companies in the ACH file. An important takeaway from
    this component is seeing how we can dynamically create layout elements on our
    page. In other components, we will use DataGrid views that provide a table structure
    for viewing dynamic data. However, it is helpful to know that we can create layouts
    with dynamic data manually, as well when the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: 6.7 Creating a ScatterPlot component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we want to add a scatterplot to the page that shows the items in the
    batch versus the total amount of debits and credits. The following listing shows
    the directory structure we will be creating. You may create another subdirectory
    to store specific scatterplot-related files. Since we have not reached the point
    where this directory contains a lot of files, we will leave this as is for the
    time being.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.34  Directory structure for our charts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 6.7.1 Scatterplot component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A scatterplot is useful for showing the possible correlation between variables.
    In our case, we may not necessarily be interested in the analytic aspect. However,
    the scatterplot also provides a way to identify batches with a high number of
    items or with a large dollar amount, which may be interesting to our users. Certainly,
    there may also be an opportunity for us to display trends in the batches for a
    particular company, which may also help our users perform analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, this component provides an opportunity to explore using colors,
    custom tooltips, and custom ticks on the axis. These features are discussed in
    subsequent sections. The initial code for the scatterplot is shown in listing
    6.35, with the actual component rendering shown in listing 6.36.
  prefs: []
  type: TYPE_NORMAL
- en: The component defines an interface called `AchBatchesScatterPlotProps` so that
    it can set the types properly. In addition, it is important that this component
    accepts the batches as a read-only parameter rather than making any API calls
    inside the component. We could have just as easily made the API calls inside the
    component. However, if we had multiple components that wanted to make use of this
    data, we would end up with repeated API calls to gather the same data. We also
    marked the data as read-only to help enforce the concept of the component only
    utilizing the data and not introducing unintended consequences by being used.
    However, note that `Readonly` is a compile-time feature for TypeScript, and the
    resulting JavaScript will not have it. Finally, since we are interested in the
    total dollar amount of the batch, we add the credit and debit amounts together
    and store them into `totalCreditAndDebits`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.35  Scatterplot component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines an interface for the component properties, so we can strongly type
    them'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Accepts the properties as Readonly so we do not modify them'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Spreads the contents of the companyBatch object'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Adds a new property to the object named totalCreditAndDebits'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Spreads the content of the batch object'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Replaces the existing companyBatches with the new batches containing the
    totalCreditAndDebits'
  prefs: []
  type: TYPE_NORMAL
- en: In the following listing, we have the component that renders the actual scatterplot.
    Here we take advantage of the flexibility of recharts by defining custom tooltip
    content by passing a component called `AchBatchesScatterTooltip` and by defining
    a custom tick mark component for the `YAxis` called `CurrencyTick`. Furthermore,
    we assign a different color to each company when placing the point on the plot
    (more about these custom components in the following sections).
  prefs: []
  type: TYPE_NORMAL
- en: Lisitng 6.36  Scatterplot render
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Custom component for the ticks on the Y-axis'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Custom tooltip when hovering over a data point'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Custom color depending on the company'
  prefs: []
  type: TYPE_NORMAL
- en: 6.7.2 Scatterplot custom tooltip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After defining our custom tooltip component in the next listing, we can customize
    the displayed tooltip. We kept it simple by using the components available in
    Material UI. We can also reuse the `formatCurrency` method that we had defined
    to ensure the correct display of data in the tooltip.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.37  Custom tooltip for scatterplot
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Reuses our formatCurrency routine to ensure consistency in displaying amounts'
  prefs: []
  type: TYPE_NORMAL
- en: 6.7.3 Scatterplot custom ticks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to customize charts in recharts is by defining a custom tick. Here
    we want our ticks to be formatted as currency instead of leaving them unformatted
    and adding a label to say “in dollars” or something similar. We define an interface
    that contains the passed data and then again use our `formatCurrency` utility
    (listing 6.38).
  prefs: []
  type: TYPE_NORMAL
- en: This component uses both `Readonly` (to ensure that the component does not modify
    any parameters) and `Partial`. The `Partial` type is used because `recharts` is
    in control of the parameters passed. Furthermore, rather than marking each parameter
    as optional by using `?`, we can mark all parameters in `CurrencyTickProps` as
    optional by using `Partial<CurrencyTickProps>`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.38  Custom currency tick
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines our properties so that they are strongly typed'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Properties are marked as Readonly and Partial.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 If the payload does not exist, substitute 0.0.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Uses our handy formatCurrency function'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the ability to customize our charts further using custom ticks is
    a powerful tool. Even if we chose to use the standard ticks, it is helpful to
    keep this type of customization in our back pocket for when the business makes
    a more specific request. In the next section, we will look at customizing colors
    for our charts.
  prefs: []
  type: TYPE_NORMAL
- en: 6.7.4 Using colors for the chart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Colors are a very important part of any visualization. In our case, we do not
    limit the number of points in the scatterplot, so we do not necessarily know the
    number of companies that will have to be identified. We could always limit the
    visualization by saying it is a scatterplot of the “Top 10 companies” or the “Top
    10 batches” so that we do not have to enumerate additional colors to handle an
    undetermined number of companies.
  prefs: []
  type: TYPE_NORMAL
- en: The next listing shows how we may enumerate the colors and then the code will
    loop through these colors and reuse them as necessary as we are doing `COLORS[index`
    `% COLORS.length]`. This approach will work but also has the problem of repeating
    colors when there are more companies than colors defined, and that will obviously
    make the visualization difficult to understand from a user’s perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.39  Enumerating colors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Another option we went with was computing the colors based on the company name,
    which provided us with a better opportunity to handle many companies in our visualization
    (although there will be a threshold where it is no longer valuable). However,
    as it stands, this approach also does not allow us to use names that may hash
    to the same value, nor does it necessarily give us the best colors in a visualization.
    Later, we may decide that showing the top 10 companies is the best way to handle
    the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.40 shows the code used to compute a hex color code from the company
    name (or any string). In this case, the implementation details on how we create
    a color code from a string are not so important. Rather, we want to understand
    different ways we may use when approaching a problem and try to understand the
    potential tradeoffs in each approach. In this case, we have lost control over
    the exact colors being used, which also means the colors may be indistinguishable
    or conflict with the rest of the visualization. However, this approach allows
    us to show many companies, also providing consistency in color for the company.
    So, the color could be consistent in other visualizations or just change every
    day.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.40  Using the company name to determine the color
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How we display data is not only a matter of preference—our choice of layout,
    formatting, and colors can influence data interpretation. For instance,
  prefs: []
  type: TYPE_NORMAL
- en: Using a red/green color scheme makes it harder for individuals with color blindness
    to distinguish the colors in different categories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D bar charts can be visually appealing but can lead to inaccurate interpretations
    of the data because the perspective can make bars appear larger/smaller than they
    are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In cherry-picked timeframes, data that does not fit a specific narrative is
    hidden or minimized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For additional information on this topic, see *Everyday Data Visualization*
    (2024, Manning) by Desireé Abbott, especially if you want to take your visualizations
    to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: 6.8 Deploying the dashboard in Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a final step, we want to deploy our code in Docker to tie all the pieces
    of our system together. The next chapter will focus on implementing the needed
    APIs, making sure components can communicate, and general housekeeping. For now,
    we only want to ensure the container is built correctly and can communicate with
    our WireMock instance.
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall, our API calls use the `NEXT_PUBLIC_API_URL`, which allows
    us to configure the base URL needed to communicate with the backend. Listing 6.41
    shows the service implementation for our docker-compose.yml. We now introduce
    the use of the `args` parameter to pass in arguments to our build process. We
    have set the URL to the same endpoint that we had in our `.env.local` project
    setup. This is because the code will be running on the client side in the browser,
    which means we will need to use `localhost:8081` and not the internal reference
    to `wiremock:8080`, as you may initially imagine.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.41  Adding the dashboard to Docker
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines variables to pass to the build'
  prefs: []
  type: TYPE_NORMAL
- en: In the following listing, we have the Dockerfile referenced in listing 6.41\.
    This code takes care of setting our environment variable, and building and running
    the application. In this Dockerfile, we utilize the `NEXT_PUBLIC_API_URL` by showing
    how we may set a default value, as well as how to set it in the container.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.42  The Dockerfile for the dashboard
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines an argument that can be used or defaulted'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Sets an environment variable that will contain our API URL'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should be able to build the containers and start them with
    `docker-compose` `down;` `docker-compose` `up` `--build` like before. Then, after
    navigating to http://localhost:4000, we should see our dashboard come up, displaying
    our WireMock data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dashboard serves as the user interface for file uploads and data views,
    powered by APIs, and it can be developed using various technologies, with a current
    preference for Next.js.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next.js supports building interactive web applications with React by using HTML,
    CSS, and DOM principles and offering file-based routing, CSR, SSR, and multiple
    styling methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with Next.js involves setting up `Node.js`, creating a project using
    npx, and running a default application to verify setup correctness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dashboard can be initialized using templates such as Material UI, and dependencies
    should be installed to support components and API calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporating TypeScript enhances maintainability by adding explicit types and
    catching errors during development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jest is used for unit testing the UI, ensuring page functionality and accessibility
    through ARIA roles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring of navigation components warrants better code organization and inclusion
    in the upload page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardcoded data is initially used for UI development and then replaced with mocked
    API calls using tools such as WireMock for parallel development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking APIs with WireMock involves setting up Docker, configuring stubs, and
    refreshing for changes to take effect, facilitating UI testing without complete
    backend availability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment of the dashboard in Docker involves configuring environment variables
    and ensuring communication with mocked APIs for dynamic data display.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
