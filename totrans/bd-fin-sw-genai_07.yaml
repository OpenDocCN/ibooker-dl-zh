- en: 6 Taking the next step with Next.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 使用Next.js迈出下一步
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Using Next.js to build a dashboard
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Next.js构建仪表板
- en: Using Material UI components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Material UI组件
- en: Using WireMock to help stub our API calls
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WireMock帮助我们模拟API调用
- en: Until this point, we have worked through research spikes to explore creating
    and parsing an ACH file, creating a database, and generating APIs to access our
    data. In this final research spike, we’ll start working on our application dashboard.
    A dashboard is the user interface (UI) from which it is possible to upload and
    view files, view records, and obtain any other useful information. While there
    are plenty of options available for creating a UI, we have decided to go with
    Next.js as it is built on React, which is also very popular. However, since everything
    is powered by APIs, the UI could be swapped with Remix, Vue, Angular, or any other
    technology used in our company.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过研究激增来探索创建和解析ACH文件、创建数据库以及生成访问我们数据的API。在这个最终的研究激增中，我们将开始着手我们的应用程序仪表板。仪表板是一个用户界面（UI），用户可以通过它上传和查看文件、查看记录以及获取任何其他有用的信息。虽然有许多可用的创建UI的选项，但我们决定选择Next.js，因为它建立在React之上，React也非常受欢迎。然而，由于一切都是由API驱动的，UI可以与Remix、Vue、Angular或我们公司使用的任何其他技术交换。
- en: Chapter 4 showed us how to take an API-driven design approach. While we have
    not built all our APIs by switching to the UI yet, we will begin to see what data
    we want (or need) to be returned as part of our APIs. By stubbing out the data
    fields, we can ensure our UI is making exactly the same calls required for the
    real APIs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第四章向我们展示了如何采用以API驱动的设计方法。虽然我们还没有通过切换到UI来构建所有我们的API，但我们将开始看到我们希望（或需要）作为我们API一部分返回的数据。通过模拟数据字段，我们可以确保我们的UI正在调用与真实API完全相同的调用。
- en: 6.1 Getting started with Next.js
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 Next.js入门
- en: Getting started with Next.js is very easy, and we chose it partly because it
    is easy to get an application up and running, but also because it can grow to
    support any application we care to create. Next.js is a full stack React framework.
    React itself is a library used for building web interfaces. Although it is simple
    to learn, it does require a basic understanding of some common web technologies
    such as
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js入门非常简单，我们选择它部分是因为它很容易让应用程序启动和运行，但也因为它可以扩展以支持我们想要创建的任何应用程序。Next.js是一个全栈React框架。React本身是一个用于构建网络界面的库。尽管它很容易学习，但它确实需要了解一些常见网络技术的基础，例如
- en: '*Hypertext Markup Language (HTML**)*—The standard markup language for building
    web pages'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*超文本标记语言 (HTML)*——构建网页的标准标记语言'
- en: '*Cascading Style Sheets (CSS**)*—A way to describe how HTML elements should
    be displayed'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*层叠样式表 (CSS)*——描述HTML元素应该如何显示的一种方式'
- en: '*Document Object Model (DOM**)*—Defines properties, methods, and events for
    HTML elements and allows languages such as JavaScript to add/change/remove HTML
    elements and attributes, as well as react to HTML events'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文档对象模型 (DOM)*——定义了HTML元素的属性、方法和事件，允许如JavaScript这样的语言添加/更改/删除HTML元素和属性，以及响应HTML事件'
- en: React builds and improves on the listed web technologies by providing additional
    concepts to facilitate UI development. Some key concepts of React are
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: React通过提供额外的概念来构建和改进列出的网络技术，以促进UI开发。React的一些关键概念包括
- en: '*Component**s*—Reusable and self-contained pieces of code that render parts
    of the UI. They are the building blocks of our application.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组件*——可重用且自包含的代码块，用于渲染UI的各个部分。它们是我们应用程序的构建块。'
- en: '*Stat**e*—Holds dynamic information within a component, which can be used to
    change its behavior and trigger rendering.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*状态*——在组件内持有动态信息，可用于改变其行为并触发渲染。'
- en: '*Hook**s*—Help manage the state and lifecycle of components.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*钩子*——帮助管理组件的状态和生命周期。'
- en: All of this may seem like a lot to digest, especially if you are new to UI development.
    The truth is that you should still be able to walk through this research spike
    and gain a basic understanding of these concepts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些可能看起来很多，尤其是如果你是UI开发的初学者。事实是，你应该仍然能够走遍这个研究激增，并对这些概念有一个基本的理解。
- en: So, how does Next.js fit into all of this? The React web site ([https://react.dev](https://react.dev))
    recommends using Next.js (or Remix) because it is a full-featured production-grade
    React framework. That means that Next.js comes with a lot of powerful features,
    such as
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Next.js是如何融入所有这些的？React网站([https://react.dev](https://react.dev))建议使用Next.js（或Remix），因为它是一个功能齐全的生产级React框架。这意味着Next.js附带了许多强大的功能，例如
- en: File-system-based routing that supports multiple layouts, nested routing, and
    error handling
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于文件系统的路由，支持多种布局、嵌套路由和错误处理
- en: Client-side rendering (CSR) and server-side rendering (SSR), depending on the
    needs of the application
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据应用需求，进行客户端渲染（CSR）和服务器端渲染（SSR）
- en: Data fetching with `async`/`await`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`async`/`await`进行数据获取
- en: Support for multiple styling methods such as CSS Modules, Tailwind CSS, and
    CSS-in-JS
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多种样式方法，如CSS Modules、Tailwind CSS和CSS-in-JS
- en: Optimization for images, fonts, and scripts
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对图像、字体和脚本的优化
- en: To get started, we have to ensure that we have Node.js installed ([https://nodejs.org/en](https://nodejs.org/en))
    because we need access to its tools, beginning with the `npx` command. `npx` is
    a command line tool that helps simplify the running of `npm` (Node Package Manager)
    commands.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们必须确保已经安装了Node.js（[https://nodejs.org/en](https://nodejs.org/en)），因为我们需要访问其工具，从`npx`命令开始。`npx`是一个命令行工具，有助于简化`npm`（Node包管理器）命令的运行。
- en: We can execute `npx` `create-next-app@latest` to answer a few questions and
    then start the project with `npm` `run` `dev`. We should be able now to log in
    to http://localhost:3000 and see whether the default page comes up. Of course,
    the default page is a test to make sure we have our setup correctly. We want to
    develop a UI that allows a user to easily load files and review associated data.
    Usually, the business already has a design in mind that is based on existing standards.
    As we are not required to follow any particular design, a good option is to start
    using a sample template. There are plenty of options out there, but a great way
    to get started is by using the dashboard template provided by Material UI at [https://mng.bz/Xx66](https://mng.bz/Xx66).
    We pulled the template for MUI 5.x, which can be viewed at [https://mng.bz/yWnq](https://mng.bz/yWnq).
    As previously mentioned, we are not limited to this particular template, but it
    does provide us with a basic layout that we can quickly customize to create our
    final project.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行`npx create-next-app@latest`来回答几个问题，然后使用`npm run dev`启动项目。现在我们应该能够登录到http://localhost:3000，看看默认页面是否出现。当然，默认页面是一个测试，以确保我们的设置正确。我们希望开发一个用户可以轻松加载文件并查看相关数据的UI。通常，业务已经有一个基于现有标准的设计。由于我们不需要遵循任何特定的设计，一个好的选择是开始使用一个示例模板。市面上有很多选择，但一个很好的开始方法是使用Material
    UI提供的仪表板模板，[https://mng.bz/Xx66](https://mng.bz/Xx66)。我们拉取了MUI 5.x的模板，可以在[https://mng.bz/yWnq](https://mng.bz/yWnq)查看。如前所述，我们不仅限于这个特定的模板，但它确实为我们提供了一个可以快速定制的基布局，以便我们创建最终项目。
- en: We recommend grabbing the TypeScript versions of the template as we will be
    using TypeScript throughout the project. TypeScript is a superset of JavaScript,
    which means that your existing JavaScript skills can be employed when using TypeScript.
    The benefit of TypeScript is that it adds explicit types to JavaScript (among
    other things). We believe that the explicit types help with the maintainability
    of the code over the long term by helping catch errors earlier during development.
    The long-term maintainability of the code is very important, especially when we
    consider how long our code may be out in the field, and given FinTech, that can
    be a long time! While we will get the basics of TypeScripts within this project,
    *Essential TypeScript 5* (2023, Manning) by Adam Freeman is a great resource,
    or you can check out the TypeScript tutorial available at [https://www.typescripttutorial.net/](https://www.typescripttutorial.net/).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议获取模板的TypeScript版本，因为我们将在整个项目中使用TypeScript。TypeScript是JavaScript的超集，这意味着当使用TypeScript时，你可以使用现有的JavaScript技能。TypeScript的好处是它为JavaScript添加了显式类型（以及其他功能）。我们相信，显式类型有助于长期内代码的可维护性，因为它有助于在开发早期捕获错误。代码的长期可维护性非常重要，尤其是当我们考虑到我们的代码可能在野外存在很长时间时，考虑到FinTech，这可能是一个很长的时间！虽然我们将在本项目中了解TypeScript的基础知识，但Adam
    Freeman的《Essential TypeScript 5》（2023年，Manning）是一本很好的资源，或者你可以查看[https://www.typescripttutorial.net/](https://www.typescripttutorial.net/)上可用的TypeScript教程。
- en: Before we can get the project started with the sample template, we need to ensure
    the dependencies are installed, which can be done with the command line in the
    next listing. This command installs a few requirements for Material UI, as well
    as for `recharts` (for our visualization needs) and `axios` (for making API calls).
    These packages were chosen because we have seen them in use in FinTech, and they
    have solid documentation to help us if we get stuck.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用示例模板开始项目之前，我们需要确保已安装依赖项，这可以通过下一列表中的命令行来完成。此命令安装了 Material UI 的一些要求，以及
    `recharts`（用于我们的可视化需求）和 `axios`（用于进行 API 调用）。这些包被选中是因为我们在 FinTech 中看到了它们的使用，并且它们有良好的文档，可以帮助我们在遇到困难时。
- en: Listing 6.1  Installing dependencies for our dashboard
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.1  安装仪表板的依赖项
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#1 Installs all the components needed for our dashboard'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 安装我们仪表板所需的所有组件'
- en: With that complete, the project should be up and running. Now we only need to
    customize the dashboard and add additional functionality.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，项目应该已经启动并运行。现在我们只需要自定义仪表板并添加额外的功能。
- en: One of the ways we like to begin with new code is to dive right into it and
    start adding additional functionality or refactoring existing code. Let’s jump
    right in!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢开始新代码的方式之一是直接深入其中，并开始添加额外的功能或重构现有代码。让我们直接开始吧！
- en: 6.2 Creating an upload page
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 创建上传页面
- en: To help you get started, Next.js has extensive documentation and a great tutorial
    ([https://nextjs.org/learn](https://nextjs.org/learn)) if you are completely new
    to React and web development. We begin with Next.js routing as we find it straightforward
    and just need to create a simple structure on our filesystem. We can easily create
    a page that will handle our ACH file uploads, as shown in the next listing. The
    page.tsx is key to having our web page displayed. TSX is a syntax extension for
    TypeScript that lets us write HTML-like markup inside the Typescript file. You
    may also see JSX pages in various tutorials, which are just the JavaScript equivalents.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您开始，Next.js 有广泛的文档和优秀的教程（[https://nextjs.org/learn](https://nextjs.org/learn)），如果您对
    React 和 Web 开发完全陌生。我们以 Next.js 路由开始，因为我们认为它很简单，只需要在我们的文件系统中创建一个简单的结构。我们可以轻松创建一个页面来处理我们的
    ACH 文件上传，如下一列表所示。page.tsx 是显示我们的网页的关键。TSX 是 TypeScript 的语法扩展，允许我们在 TypeScript
    文件中编写类似 HTML 的标记。您也可能在各种教程中看到 JSX 页面，它们只是 JavaScript 的等效物。
- en: Listing 6.2  Our directory structure for the upload page
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2  我们上传页面的目录结构
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#1 This file-based routing will cause Next.js to display page.tsx when we navigate
    to /uploads.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这种基于文件的路由会导致 Next.js 在我们导航到 /uploads 时显示 page.tsx。'
- en: We want to create a simple page that allows us to drag and drop files onto the
    page to be uploaded. We will stay away from the actual file uploading for now
    to focus on some of the design first. Given the structure from listing 6.2, we
    want to be able to navigate to http://localhost:3000/uploads, so we put a placeholder
    in page.tsx to ensure we can confirm things are working.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建一个简单的页面，允许我们将文件拖放到页面上进行上传。现在我们将暂时避开实际的文件上传，先专注于一些设计。根据列表 6.2 的结构，我们想要能够导航到
    http://localhost:3000/uploads，所以我们将在 page.tsx 中放置一个占位符，以确保我们可以确认一切正常工作。
- en: Listing 6.3  Placeholder upload page
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.3  占位符上传页面
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#1 We export a default function named Uploads.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们导出了一个名为 Uploads 的默认函数。'
- en: '#2 Typography is a component from MUI that allows us to create text; here,
    we are using a variant of h1, which will give us a very long text, just like the
    HTML h1 tag would.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 字体排版是 MUI 的一个组件，允许我们创建文本；在这里，我们使用 h1 的一个变体，这将给我们一个非常长的文本，就像 HTML 的 h1 标签一样。'
- en: With that in place, you should be able to navigate to the upload endpoint and
    see “Hello, Uploads!”
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 安装好这些后，您应该能够导航到上传端点并看到“Hello, Uploads！”
- en: 6.2.1 Testing our upload page
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 测试我们的上传页面
- en: Even though we have not created a substantial page, let’s take a moment to see
    how we may test our pages in React. We will use Jest, a popular option for testing
    React apps. First, we need to install the required dependencies.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有创建一个实质性的页面，但让我们花点时间看看我们如何在 React 中测试我们的页面。我们将使用 Jest，这是测试 React 应用程序的一个流行选择。首先，我们需要安装所需的依赖项。
- en: Listing 6.4  Jest dependencies
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.4  Jest 依赖项
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 Additional libraries to help support testing efforts'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 额外的库以帮助支持测试工作'
- en: Next, we generate a basic configuration with `npm init jest@latest`. Then, we
    create a directory structure where we keep our tests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `npm init jest@latest` 生成一个基本的配置。然后，我们创建一个目录结构，用于存放我们的测试。
- en: Listing 6.5  Test directory structure
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5  测试目录结构
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As shown in listing 6.5, the standard procedure is to create a high-level `__tests__`
    directory as the subdirectories do not matter then (you only want them to make
    sense). The uploads.test.tsx will store our actual test code. For now, we only
    want to ensure that our “Hello, Uploads!” text is displayed when the upload component
    is rendered. To accomplish that, the following listing shows the sample test.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 6.5 所示，标准流程是创建一个高级的 `__tests__` 目录，因为子目录并不重要（你只希望它们有意义）。`uploads.test.tsx`
    将存储我们的实际测试代码。目前，我们只想确保当上传组件渲染时，显示“Hello, Uploads!”文本。为了实现这一点，以下列表展示了示例测试。
- en: Listing 6.6  Simple Jest test
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.6 简单 Jest 测试
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '#1 The needed import statements for our test'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们测试所需的导入语句'
- en: '#2 The describe keyword allows us to group tests, which will be displayed under
    the title “Upload Page.”'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 `describe` 关键字允许我们将测试分组，这些测试将显示在“Upload Page”标题下。'
- en: '#3 The it keyword starts our test, along with the header of ''renders a heading’.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 `it` 关键字开始我们的测试，并带有标题“渲染标题”。'
- en: '#4 Renders our component'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 渲染我们的组件'
- en: '#5 Retrieves the h 1 tag using the ARIA role. The level parameter corresponds
    to the size of the header: h 1 , h2, and h3 would use levels 1 , 2, and 3, respectively.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 使用 ARIA 角色检索 h 1 标签。级别参数对应于标题的大小：h 1、h2 和 h3 分别使用级别 1、2 和 3。'
- en: '#6 Ensures the variable is defined'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 确保变量已定义'
- en: '#7 Uses a regular expression to ensure the text matches our expected text'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 使用正则表达式确保文本匹配我们期望的文本'
- en: The unit test defined in listing 6.6 should look somewhat familiar, given the
    test scripts we created in Python with `pytest`. Of course, the syntax may differ
    slightly, but the approach is the same. It would be interesting to revisit the
    `getByRole` method used to get our header tag and its contents. This method uses
    the role defined by the Accessible Rich Internet Applications (ARIA) standard.
    By creating our unit tests using `getByRole`, we take an accessibility-first approach
    to our web page design. Assistive technologies will be interacting with our web
    UI through ARIA tags.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 中定义的单元测试应该看起来有些熟悉，考虑到我们用 `pytest` 在 Python 中创建的测试脚本。当然，语法可能略有不同，但方法相同。回顾用于获取我们的标题标签及其内容的
    `getByRole` 方法将很有趣。此方法使用可访问性丰富互联网应用程序（ARIA）标准中定义的角色。通过使用 `getByRole` 创建我们的单元测试，我们采取了以可访问性为首要考虑的网页设计方法。辅助技术将通过
    ARIA 标签与我们的 Web UI 交互。
- en: '![A screenshot of a computer program  Description automatically generated](../Images/CH06_F01_Kardell.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图  自动生成的描述](../Images/CH06_F01_Kardell.png)'
- en: Figure 6.1  Output from running our Jest test
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1 运行我们的 Jest 测试的输出
- en: If you are developing within an IDE such as JetBrains, WebStorm, or VS Code,
    you may be able to run these tests directly from within the IDE. Or, you could
    execute the command `npm` `run` `test` from the command line. Executing from the
    command line helps illustrate the importance of the `describe` and `it` keywords.
    As shown in listing 6.6, the `Upload` `Page` heading is pulled from the `describe`
    keyword. Each test defined by the `it` keywords is also represented, As shown
    in figure 6.1, these keywords keep our tests organized and the output readable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个像 JetBrains、WebStorm 或 VS Code 这样的 IDE 中开发，你可能可以直接在 IDE 中运行这些测试。或者，你也可以从命令行执行
    `npm run test` 命令。从命令行执行有助于说明 `describe` 和 `it` 关键字的重要性。如列表 6.6 所示，`Upload` `Page`
    标题是从 `describe` 关键字中提取的。每个由 `it` 关键字定义的测试也被表示出来，如图 6.1 所示，这些关键字使我们的测试保持组织性，输出可读性。
- en: As we can see, unit testing is not just important for our backend Python code,
    but for the UI as well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，单元测试不仅对我们后端的 Python 代码很重要，对 UI 也同样重要。
- en: If you have directly browsed the uploads page, you can see that we have lost
    our navigation bars for the page. The next section shows how to add them back.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接浏览了上传页面，你可以看到我们丢失了页面的导航栏。下一节将展示如何将它们添加回来。
- en: 6.3 Refactoring our navigation
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 重构我们的导航
- en: As with any code we did not write ourselves, we need to poke around to get a
    feel for the layout and structure. Since we will be customizing the dashboard
    for our own needs, we need to understand how the dashboard navigates between components.
    This may take some detective work, but it’s worth it. After some digging, we find
    that the navigation for our pages is controlled by two components that we can
    see in our Dashboard.tsx—the `AppBar` and the `Drawer`. We can start by refactoring
    them into their own components. After we perform the refactoring, we can decide
    how to include them on subsequent pages.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何我们没有编写的代码一样，我们需要探索以了解布局和结构。由于我们将根据我们的需求自定义仪表板，我们需要了解仪表板如何在组件之间导航。这可能需要一些侦探工作，但这是值得的。经过一番挖掘，我们发现我们页面的导航由我们可以在
    Dashboard.tsx 中看到的两个组件控制——`AppBar` 和 `Drawer`。我们可以从将它们重构为各自的组件开始。在重构完成后，我们可以决定如何在后续页面上包含它们。
- en: The first order of the business is to extract the `AppBar` tag from Dashboard.tsx
    and move it to its own component in `src/app/components/navigation/TopMenuBar.tsx`.
    The directory structure and naming conventions can be anything within reason.
    The component then contains the existing `AppBar` logic with a few updates to
    handle, regardless of whether the drawer is open or closed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当务之急是从 Dashboard.tsx 中提取 `AppBar` 标签，并将其移动到 `src/app/components/navigation/TopMenuBar.tsx`
    中的自己的组件。目录结构和命名规范可以在合理范围内自由选择。该组件包含现有的 `AppBar` 逻辑，并进行了一些更新以处理，无论抽屉是打开还是关闭。
- en: Listing 6.7  Navigation menu bar
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.7  导航菜单栏
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '#1 Defines an interface for the TopMenuBar that takes a function to execute
    when the button is clicked and a boolean to determine whether the drawer is open'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义了一个接口用于 TopMenuBar，它接受一个在按钮被点击时执行的函数和一个布尔值来确定抽屉是否打开'
- en: '#2 Maintains the state in the component'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 在组件中维护状态'
- en: '#3 When the parameter drawerOpen changes, updates the state accordingly'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 当参数 drawerOpen 发生变化时，相应地更新状态'
- en: '#4 The AppBar’s open parameter is our internal state.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 AppBar 的 open 参数是我们的内部状态。'
- en: '#5 When the icon is clicked, the toggleDrawer function that was passed in is
    executed.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 当图标被点击时，执行传递进来的 toggleDrawer 函数。'
- en: We also want to do something similar for the sidebar navigation, so we refactor
    the `Drawer` tag from Dashboard.tsx, moving it to its own component.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望对侧边导航做类似的事情，因此我们将 Dashboard.tsx 中的 `Drawer` 标签重构，将其移动到自己的组件中。
- en: Listing 6.8  Sidebar navigation
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.8  侧边导航
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 Defines an interface for the SideBarNavProps that takes a function to execute
    when the button is clicked and a boolean to determine whether the drawer is open'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义了一个接口用于 SideBarNavProps，它接受一个在按钮被点击时执行的函数和一个布尔值来确定抽屉是否打开'
- en: '#2 Unpacks the SideBarNavProps as part of the function call'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 在函数调用过程中解包了 SideBarNavProps'
- en: '#3 Maintains the state in the component'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 在组件中维护状态'
- en: '#4 When the parameter drawerOpen changes, updates the state accordingly'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 当参数 drawerOpen 发生变化时，相应地更新状态'
- en: '#5 Our open state is used to determine the Drawer state.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 我们的开启状态用于确定抽屉状态。'
- en: '#6 When the icon is clicked, the toggleDrawer function that was passed in is
    executed.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 当图标被点击时，执行传递进来的 toggleDrawer 函数。'
- en: We can then use these components in the Dashboard.tsx as shown in the next listing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像下一个列表中所示的那样，在 Dashboard.tsx 中使用这些组件。
- en: Listing 6.9  Updated Dashboard.tsx
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.9  更新的 Dashboard.tsx
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 Stores the state of the drawer'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 存储抽屉的状态'
- en: '#2 Creates an arrow function named toggleDrawer we call to set the open state'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 创建了一个名为 toggleDrawer 的箭头函数，我们调用它来设置打开状态'
- en: '#3 Uses our refactored components which accept a function to show/hide the
    drawer and the current state of the drawer'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 使用我们重构的组件，这些组件接受一个函数来显示/隐藏抽屉和抽屉的当前状态'
- en: Working through this refactoring exercise introduced us to Material UI and Next.js.
    In addition, we are now obviously able to include these components in our upload
    page, which was our original goal. While we have refactored the code, there is
    some noticeable duplication handling regarding whether the drawer is open. With
    the way we have it at the moment, we will need to duplicate the `open` state and
    `toggleDrawer` function in each component we choose to use them in, which is less
    than ideal since they will always need to be used together.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个重构练习，我们了解了 Material UI 和 Next.js。此外，我们现在显然能够将这些组件包含在我们的上传页面中，这是我们最初的目标。虽然我们已经重构了代码，但在处理抽屉是否打开的问题上，有一些明显的重复处理。按照我们目前的方式，我们需要在每个我们选择使用它们的组件中重复
    `open` 状态和 `toggleDrawer` 函数，这并不理想，因为它们总是需要一起使用。
- en: Navigation component challenge
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 导航组件挑战
- en: While there may be the occasional need to duplicate code, we probably do not
    need or want to do it in this case. There are a few ways we may want to handle
    this (maybe we do not want to break out the `AppBar` and `Drawer` elements). If
    we refactor them into a single component, we would only have to import that single
    component. Or perhaps, since we have them broken apart already, can we just wrap
    them into a single component? The goal of this exercise is to eliminate the need
    to duplicate the `open` state and `toggleDrawer` function in every component.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然偶尔可能需要复制代码，但我们可能不需要或想要在这种情况下这样做。我们可能有几种处理方式（也许我们不想将`AppBar`和`Drawer`元素分离出来）。如果我们将它们重构为单个组件，我们只需要导入该单个组件。或者，既然我们已经将它们分开，我们能否将它们包装成一个单独的组件？这个练习的目的是消除在每个组件中重复`open`状态和`toggleDrawer`函数的需要。
- en: 6.4 Converting recent order to recent ACH uploads
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 将最近订单转换为最近的ACH上传
- en: Now that we dipped our toes into some Next.js, let’s take a look at reworking
    the `Recent` `Order` component to list our recent ACH uploads instead. As always,
    we are looking to work in short development cycles. This means we first use the
    hardcoded data that is part of the template and update it to fit our needs. Then,
    we replace the hardcoded data with a mocked API call. The template has a function
    to create the rows of data, as shown in the next listing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经尝试了一些Next.js，让我们来看看重新设计`Recent` `Order`组件以列出我们的最近ACH上传。一如既往，我们希望进行短周期的开发。这意味着我们首先使用模板中作为一部分的硬编码数据，并更新它以适应我们的需求。然后，我们将硬编码的数据替换为模拟的API调用。模板有一个函数用于创建数据行，如下一列表所示。
- en: Listing 6.10  `createData` function
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.10  `createData`函数
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '#1 The existing parameters we need to update'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 需要更新的现有参数'
- en: '#2 The existing return statement we need to update'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 需要更新的现有返回语句'
- en: We repurpose this code to include fields that we want to see when viewing loaded
    files for the day. For now, we can imagine that we would like to see the date
    the file was loaded (possibly the time as well), the name of the file, and both
    the credit/debit amounts for the file. The required updates are shown in the next
    listing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重新使用这段代码来包含我们希望在查看当天加载的文件时看到的字段。目前，我们可以想象我们希望看到文件加载的日期（可能还有时间），文件的名称以及文件的信用/借记金额。所需的更新在下一列表中显示。
- en: Listing 6.11 Updated  `createData` function
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.11 更新的`createData`函数
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#1 Updates parameters for createData. We do not necessarily need to worry about
    the data types at this point. We just use the standard types of number and string.
    We could define the date as a Date type but that is unnecessary at this point.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 更新`createData`的参数。我们在此处不一定需要担心数据类型。我们只使用标准的数字和字符串类型。我们可以将日期定义为日期类型，但在此阶段这是不必要的。'
- en: '#2 Updated return statement'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 更新的返回语句'
- en: Next, we create our rows of data with the new amounts. Note that we have two
    amount fields, and whenever we have amounts, we want to include a variety of them
    to ensure the data will display as desired (determined by the stakeholders in
    the project). Depending on the API and datatype we use, there could be some look
    and feel problems with the UI when displaying amounts. Therefore, listing 6.12
    shows data we are passing, and we want to be sure we hit some of the edge cases
    such as
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用新的金额创建数据行。请注意，我们有两个金额字段，并且每次我们有金额时，我们希望包含各种金额以确保数据按预期显示（由项目中的利益相关者决定）。根据我们使用的API和数据类型，在显示金额时可能会出现一些外观和感觉问题。因此，列表6.12显示了我们要传递的数据，并且我们想要确保我们处理了一些边缘情况，例如
- en: Trailing zero, which will likely be thrown out when using a numeric datatype
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾随零，在使用数值数据类型时可能会被丢弃
- en: Dollar amounts greater than $999 to see a separator (such as a comma) for the
    amount
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金额大于$999时，金额将显示分隔符（如逗号）
- en: Listing 6.12  Sample data
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.12  样本数据
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 Returns a date; this may come through from the API as a timestamp we’ll
    need to handle.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 返回一个日期；这个日期可能通过API作为时间戳返回，我们需要处理它。'
- en: '#2 Ensures our numeric values cover some of the use cases we outlined'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 确保我们的数值值覆盖了我们概述的一些用例'
- en: Depending on the API, you may be receiving a formatted amount, in which case,
    you obviously do not need to worry about the mentioned problems. However, when
    we design APIs, we usually try to keep the formatting to a minimum and not enforce
    formatting/locale specifics unless necessary. So, we favor returning `1000.0`
    for $1,000.00 because, depending on the location, we may use a space and/or decimal
    to separate numbers. Of course, use cases differ from one company to another and
    one project to another. In our situation, we are in the unique position of having
    control over both the UI and the backend, which means we could return our amount
    exactly how we want it displayed and just put it directly onto the page.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根据API，你可能正在接收一个格式化的金额，在这种情况下，你显然不需要担心提到的那些问题。然而，当我们设计API时，我们通常尽量将格式化保持在最低限度，除非必要，否则不强制执行格式化/区域特定性。因此，我们更喜欢返回`1000.0`代表$1,000.00，因为根据位置的不同，我们可能使用空格和/或小数来分隔数字。当然，用例因公司而异，因项目而异。在我们的情况下，我们处于一个独特的位置，可以控制UI和后端，这意味着我们可以按照我们想要的显示方式返回金额，并将其直接放置在页面上。
- en: Although unlikely to be a problem with this application, localization (L10n)
    may be a concern to us since ACH deals with US-based financial institutions, which
    is why we favor the unformatted amounts being returned from the API. Perhaps we
    plan for our dashboard to be abstract enough to be easily adapted to SEPA or BECS,
    so we need to ensure flexibility in our application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个应用程序中不太可能成为问题，但本地化（L10n）可能对我们来说是个问题，因为ACH处理的是美国金融机构，这就是为什么我们更喜欢API返回未格式化的金额。也许我们计划让我们的仪表板足够抽象，以便容易适应SEPA或BECS，因此我们需要确保我们的应用程序具有灵活性。
- en: Next, we update the table to display the updated rows. We take the data stored
    in `rows` and use the `map` function to take each row and create our table rows.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新表格以显示更新的行。我们使用`map`函数从`rows`中获取数据，并为每个元素创建表格行。
- en: Listing 6.13  Updated table
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.13  更新的表格
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#1 The updated table headers'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 更新的表头'
- en: '#2 We use map to create a new array of <TableRow> tags for each element.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们使用map创建一个包含<TableRow>标签的新数组。'
- en: '#3 Each table row contains a key property.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 每个表格行包含一个键属性。'
- en: '#4 Using our row data for date and name'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 使用我们的行数据用于日期和名称'
- en: '#5 We display the amount fields as-is to see how they look.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 我们以原样显示金额字段以查看其外观。'
- en: At this point, if we view our web page, we should notice that we are experiencing
    the problems we mentioned—truncating the trailing zero and missing a thousands
    separator, as shown in figure 6.2.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果我们查看我们的网页，我们应该注意到我们正在遇到我们提到的那些问题——截断末尾的零和缺少千位分隔符，如图6.2所示。
- en: We could accomplish some basic formatting by using `toFixed` and a hardcoded
    dollar sign, as in listing 6.14.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`toFixed`和硬编码的美元符号来执行一些基本格式化，如列表6.14所示。
- en: '![A white background with black lines  Description automatically generated](../Images/CH06_F02_Kardell.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色线条的白色背景，描述自动生成](../Images/CH06_F02_Kardell.png)'
- en: Figure 6.2  Unformatted credit and debit totals
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2  未格式化的信用和借记总额
- en: Listing 6.14  Basic formatting
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.14  基本格式化
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#1 Performs some initial formatting on the amounts, forcing the use of the
    dollar sign and ensuring we see two decimal places by using toFixed(2)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 对金额进行一些初始格式化，强制使用美元符号，并通过使用toFixed(2)确保我们看到两位小数'
- en: This code gets us basic formatting with only the thousands separator. Instead
    of having to remember to format currency everywhere, which can lead to inconsistencies
    and lock us into a locale, let’s define a function we can call whenever we want
    to format a currency. Not only will this provide consistency in our presentation
    of currencies, but it should also allow us to find places where we are displaying
    currencies in our code (should we ever need to).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只使用千位分隔符进行基本格式化。我们不必记住在所有地方格式化货币，这可能导致不一致并使我们陷入一个区域，让我们定义一个函数，我们可以在需要格式化货币时调用它。这不仅会在我们展示货币方面提供一致性，而且还应该允许我们找到我们在代码中显示货币的地方（如果我们需要的话）。
- en: To accomplish this, we will be using `Intl.NumberFormat,` which not only can
    format currencies for different locations but also for other units of measurements
    such as mph/kh and liter/gallon. The following listing shows our simple exported
    function that wraps `Intl.NumberFormat`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用`Intl.NumberFormat`，它不仅可以为不同位置格式化货币，还可以为其他度量单位，如mph/kh和liter/gallon。以下列表显示了我们的简单导出函数，它包装了`Intl.NumberFormat`。
- en: Listing 6.15  Wrapper for `Intl.NumberFormat`
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.15  `Intl.NumberFormat`包装器
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#1 The function takes in a number.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 函数接收一个数字。'
- en: '#2 Different currencies can be passed in but default to USD.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 可以传递不同的货币，但默认为USD。'
- en: '#3 Locale can be controlled as well, defaulting to en-US.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 可以控制区域设置，默认为en-US。'
- en: '#4 The actual work is done by Intl.NumberFormat that we style as currency.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 实际的工作是由Intl.NumberFormat完成的，我们将其格式化为货币。'
- en: We can also create some Jest tests to ensure we understand how this code functions,
    as well as confirm that we are seeing the expected formatting. The following listing
    shows example Jest tests we may want to use to confirm formatting is taking place.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一些Jest测试来确保我们理解这段代码的工作方式，以及确认我们看到了预期的格式。以下列表显示了我们可以用来确认格式化正在进行的示例Jest测试。
- en: Listing 6.16  Jest tests for our `formatCurrency` routine
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.16  对我们的`formatCurrency`例程的Jest测试
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#1 Imports the necessary functions'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 导入必要的函数'
- en: '#2 Uses describe to group the tests together'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用describe来组合测试'
- en: '#3 Ensures the trailing zeroes are not dropped'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 确保不删除尾随零'
- en: '#4 Ensures the defaults are taken'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 确保使用默认值'
- en: '#5 Checks that a comma is included'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 检查是否包含逗号'
- en: '#6 Checks that multiple commas are added'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 检查是否添加了多个逗号'
- en: '#7 Tests out German formatting in euros. The \u00A0 is a Unicode notation for
    no-break space.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 测试欧元格式的德语。`\u00A0`是表示不间断空格的Unicode表示法。'
- en: After confirming our tests run successfully, we can replace our table cells
    that called `toFixed(2)` with a call to our new `formatCurrency` routine.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认我们的测试运行成功后，我们可以用对新的`formatCurrency`例程的调用替换调用`toFixed(2)`的表格单元格。
- en: Listing 6.17  Using the new `formatCurrency` function
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.17  使用新的`formatCurrency`函数
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '#1 Replaces the manual formatting with a call to our new function'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 用对新的函数的调用替换手动格式化'
- en: Figure 6.3 shows our amounts formatted exactly the way we wanted it, with commas
    and two significant digits after the decimal.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 显示了我们的金额格式化得正好是我们想要的，有小数点后的逗号和两位有效数字。
- en: '![A white background with black lines  Description automatically generated](../Images/CH06_F03_Kardell.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![白色背景，黑色线条，自动生成描述](../Images/CH06_F03_Kardell.png)'
- en: Figure 6.3  Formatted credit and debit totals
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3  格式化后的信用和借记总额
- en: It is often easier to use an existing component as a starting point and customize
    it to meet our needs. After our customizations, we have a working component capable
    of displaying our uploaded ACH files to the user.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用现有的组件作为起点并定制它以满足我们的需求更容易。在我们的定制之后，我们有一个能够向用户显示上传的ACH文件的运行组件。
- en: 6.5 Mocking our ACH uploads data
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 模拟我们的ACH上传数据
- en: In the previous section, we customized our component to fit our particular use
    case of viewing recent ACH file uploads. However, we used hardcoded values, and
    while that helped us get a feel for the fields we need, it is not very useful
    for anything other than mocking up the UI. We have a database that we will want
    to retrieve this data from, but we are not quite there yet in terms of building
    APIs. As an intermediate step, let’s add the API call but have it retrieve mocked
    data instead of actually hitting the endpoint. Mocking data not only lets us get
    started quickly, but also has a variety of other uses such as for testing edge
    cases, simulating bad data, and other scenarios. So, learning about mocking data
    will have long-lasting benefits beyond this example.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们定制了我们的组件以适应我们查看最近ACH文件上传的特定用例。然而，我们使用了硬编码的值，虽然这有助于我们了解所需的字段，但对于除了模拟UI之外的其他用途并不太有用。我们有一个数据库，我们希望从该数据库中检索这些数据，但在构建API方面我们还没有完全准备好。作为一个中间步骤，让我们添加API调用，但让它检索模拟数据而不是实际击中端点。模拟数据不仅让我们能快速开始，而且还有各种其他用途，如测试边缘情况、模拟不良数据和其他场景。因此，了解模拟数据将带来超越这个示例的长期利益。
- en: Why would we choose to do something like this? The reality is that projects
    can span multiple people, teams, departments, and even companies. It is entirely
    possible that we may be assigned to work on the UI, while the APIs and backend
    code are being developed in parallel. This type of parallel development is often
    going on when we are trying to bring our product to market as fast as possible,
    and we cannot wait for the APIs and backend to be finished before we start working
    on the frontend. Or perhaps, we need to call a third-party API, but contract negotiations
    are still ongoing, and we do not have access to the API.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么会选择这样做呢？现实情况是，项目可能涉及多个人、团队、部门，甚至公司。我们完全可能被分配去工作在 UI 上，而 API 和后端代码则并行开发。当我们试图尽可能快地将产品推向市场时，这种并行开发通常在进行，我们无法等待
    API 和后端完成后再开始前端工作。或者，我们可能需要调用第三方 API，但合同谈判仍在进行中，我们无法访问该 API。
- en: In these cases, a tool such as WireMock can allow our code to make the same
    API call but return a predefined response. We could also use this tool to obtain
    error responses or edge case data that we may not have readily available, which
    can help us test our code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，像 WireMock 这样的工具可以让我们的代码执行相同的 API 调用，但返回预定义的响应。我们还可以使用这个工具来获取错误响应或边缘情况数据，这些数据我们可能没有
    readily available，这有助于我们测试我们的代码。
- en: 6.5.1 Adding WireMock to Docker
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 将 WireMock 添加到 Docker
- en: We add WireMock to our project in the same manner—by creating a Dockerfile first
    and then referencing it in our docker-compose.yml, as shown in the following two
    listings. The needed Dockerfile does not have much in it and could be contained
    in the docker-compose.yml, but we prefer to keep the docker-compose.yml as short
    as possible.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以相同的方式将 WireMock 添加到我们的项目中——首先创建一个 Dockerfile，然后在 docker-compose.yml 中引用它，如下面的两个列表所示。所需的
    Dockerfile 内容不多，可以包含在 docker-compose.yml 中，但我们更喜欢尽可能保持 docker-compose.yml 的简洁。
- en: Listing 6.18  Dockerfile for WireMock
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.18  WireMock 的 Dockerfile
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that in listing 6.19, we have introduced volumes to our WireMock service
    definition. These volumes exist on the local file system and are made available
    by mapping them to a directory in the container. Similar to the way ports are
    mapped, we specify the host directory first and then the directory it should map
    to in the container. WireMock allows us to specify stub mappings and file definition
    stubs (more on this later). Using volumes will allow us to make changes to the
    mappings without the need to build repeatedly. While a Dockerfile allows the `VOLUME`
    keyword where we could specify volumes, the recommended approach is to use the
    docker-compose.yml file because it allows for a separation of duties between building
    (Dockerfile) and runtime (docker-compose.yml).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第 6.19 列表中，我们已经向 WireMock 服务定义中引入了卷。这些卷存在于本地文件系统中，并通过将它们映射到容器中的目录来提供。类似于端口映射的方式，我们首先指定主机目录，然后指定它应该映射到容器中的目录。WireMock
    允许我们指定存根映射和文件定义存根（稍后详细介绍）。使用卷将允许我们更改映射，而无需反复构建。虽然 Dockerfile 允许使用 `VOLUME` 关键字来指定卷，但推荐的方法是使用
    docker-compose.yml 文件，因为它允许在构建（Dockerfile）和运行时（docker-compose.yml）之间分离职责。
- en: How about using `COPY` commands in the Dockerfile to move our mappings to the
    container? That would be another option to use if we were interested in building
    an image containing mappings that we would then distribute to our team. However,
    in this case, we are only interested in working with these mappings locally, and
    we do not need to rebuild our container whenever we want to utilize an updated
    mapping.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否可以在 Dockerfile 中使用 `COPY` 命令将我们的映射移动到容器中？如果我们要构建一个包含映射的镜像并将其分发给团队，这将是一个备选方案。然而，在这种情况下，我们只对在本地使用这些映射感兴趣，并且我们不需要每次想要使用更新的映射时都重新构建我们的容器。
- en: Listing 6.19  Updates to docker-compose.yml
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.19  docker-compose.yml 的更新
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '#1 Map locations on our filesystem to our container'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将我们的文件系统上的位置映射到容器'
- en: With that complete, we can start our Docker containers again and navigate over
    to http://localhost:8081/__admin/, where we should receive a response similar
    to the following listing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以再次启动 Docker 容器，导航到 http://localhost:8081/__admin/，在那里我们应该收到类似于以下列表的响应。
- en: Listing 6.20  WireMock admin response
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.20  WireMock 管理员响应
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code confirms that we indeed have WireMock up and running. Perhaps not
    unsurprisingly, we do not have any mappings defined yet. So, let’s tackle that
    in the next section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码确认我们确实已经启动了 WireMock。也许不出所料，我们还没有定义任何映射。那么，让我们在下一节中解决这个问题。
- en: 6.5.2 Setting up mappings in WireMock
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 在 WireMock 中设置映射
- en: WireMock is a powerful tool, and we only scratch the surface in this section.
    However, it should be enough to get us started, and we can always investigate
    its additional features as we need more functionality (remember our YAGNI principle
    from chapter 3). We are primarily interested in stubbing out mock responses so
    that when our UI makes an API call, we are returning some meaningful data. We
    start by creating a simple stub in the `./wiremock/mappings` directory named hello_world.json.
    The name is not extremely important at this point. The next listing shows the
    contents of the file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: WireMock 是一个强大的工具，我们在这个部分只是触及了表面。然而，这应该足以让我们开始，并且我们可以根据需要的功能来调查其附加功能（记住我们第 3
    章的 YAGNI 原则）。我们主要感兴趣的是模拟响应，以便当我们的 UI 进行 API 调用时，我们返回一些有意义的数据。我们首先在 `./wiremock/mappings`
    目录中创建一个简单的存根，命名为 hello_world.json。在这个阶段，名称并不非常重要。下一个列表显示了文件的内容。
- en: Listing 6.21  Our first stub
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.21  我们的第一个存根
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If we try to access http://localhost:8081/api/v1/hello/world, we receive a response
    such as `No` `response` `could` `be` `served` `as` `there` `are` `no` `stub` `mappings`
    `in` `this` `WireMock` `instance`. What gives? We need to make an empty `POST`
    call to http://localhost:8081/__admin/mappings/reset for WireMock to be able to
    pick up our changes. There are some Postman samples associated with this text
    that can get you started. After that call, you should be able to access the endpoint
    again and see “Hello, World!” Furthermore, if you request the mappings from http://localhost:8081/__admin/,
    you will see something similar to the following listing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试访问 http://localhost:8081/api/v1/hello/world，我们会收到如下响应：“没有响应可以提供，因为在这个
    WireMock 实例中没有存根映射。”这是怎么回事？我们需要向 http://localhost:8081/__admin/mappings/reset
    发送一个空的 `POST` 请求，这样 WireMock 才能拾取我们的更改。有一些与这段文本相关的 Postman 示例可以帮助你开始。在这次调用之后，你应该能够再次访问端点并看到“Hello,
    World!” 此外，如果你从 http://localhost:8081/__admin/ 请求映射，你会看到以下类似的列表。
- en: Listing 6.22  WireMock admin response with our new stub
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.22  使用我们新存根的 WireMock 管理员响应
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That should be painless. Now, let’s look at how we might want to mock our response
    to obtain the information for uploaded ACH files. We should already have a good
    idea of the fields we want to return because we have already used hardcoded data
    when building the UI. So, we will use that data and create ach_files_response.json
    in the `__files` directory this time. By defining responses in the `__files` directory,
    it will save us from complicating our mappings and allow other APIs to reuse responses
    as necessary. A response sample is shown in the next listing, and we can use as
    much or as little data as we want.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该不会很痛苦。现在，让我们看看我们如何模拟我们的响应以获取上传的 ACH 文件的信息。我们应该已经对想要返回的字段有了很好的了解，因为我们已经在构建
    UI 时使用了硬编码的数据。所以，我们将使用这些数据，并在这次在 `__files` 目录中创建 ach_files_response.json。通过在 `__files`
    目录中定义响应，这将使我们避免复杂化映射，并允许其他 API 根据需要重用响应。下一个列表显示了响应样本，我们可以使用我们想要的数据量。
- en: Listing 6.23  Sample ACH response body
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.23  示例 ACH 响应体
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 Sample JSON that contains our test data'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 示例 JSON 包含我们的测试数据'
- en: Now that we have the contents of the response defined, we need to define a mapping
    for it. The mapping is similar to what we have already seen, except that we now
    specify the `bodyFileName` in the response with the filename of ach_files_response.json
    we defined before.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了响应的内容，我们需要为它定义一个映射。这个映射与我们之前看到的类似，只是我们现在在响应中指定了 `bodyFileName`，使用之前定义的
    ach_files_response.json 文件名。
- en: Listing 6.24  ACH response mapping
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.24  ACH 响应映射
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 The request will only execute on a GET.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 请求只会在 GET 上执行。'
- en: '#2 Further refines the mapping with the URL'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用 URL 进一步细化映射'
- en: '#3 The response will be a status code 200.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 响应将是一个状态码 200。'
- en: '#4 Defines any headers that are needed'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 定义任何需要的头信息'
- en: '#5 Uses bodyFileName and specifies a name in the __files directory to return'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 使用 bodyFileName 并指定 __files 目录中的一个名称来返回'
- en: 'With that defined, we just need to refresh our mappings for the changes to
    take effect. We can use multiple methods, and they are listed in the order of
    their impact on the overall environment (from least to most impactful):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好之后，我们只需要刷新我们的映射，以便更改生效。我们可以使用多种方法，并且它们按照对整体环境的影响顺序列出（从最小到最大影响）：
- en: The Admin API can be restarted to reload the mappings.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理员 API 可以重新启动以重新加载映射。
- en: Restart the container.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动容器。
- en: Restart our Docker compose instance completely.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全重新启动我们的 Docker Compose 实例。
- en: Once the mappings have been refreshed, navigating to http://localhost:8081/api/v1/files
    will show the response. Figure 6.4 illustrates the response using Postman, which
    provides some highlighting/formatting of the output and allows us to check returned
    headers easily.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦映射被刷新，导航到 http://localhost:8081/api/v1/files 将显示响应。图 6.4 使用 Postman 展示了响应，它提供了输出的一些突出显示/格式化，并允许我们轻松检查返回的标题。
- en: WireMock is a powerful tool, and we only scratched its surface. For now, it
    is enough to get us going with building the UI. Next, we look at how to make requests
    to the backend.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: WireMock 是一个强大的工具，我们只是触及了它的表面。目前，这足以帮助我们开始构建 UI。接下来，我们将探讨如何向后端发送请求。
- en: 6.5.3 Accessing endpoints with axios
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.3 使用 axios 访问端点
- en: The first thing we need to do, if not done already, is ensure axios is installed
    with `npm` `install` `axios`. After that, we can import it into our components
    as needed and get to work!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未完成，我们首先需要确保 axios 已经通过 `npm install axios` 安装。之后，我们可以根据需要将其导入到我们的组件中并开始工作！
- en: Now we can open the RecentAchUploads.tsx, remove the `createData` function,
    and clear out our test data since we will be retrieving our data from the WireMock
    instance. Instead of hardcoded data, we will define our rows to be an array of
    `AchUploads` (listing 6.25).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以打开 RecentAchUploads.tsx，移除 `createData` 函数，并清除我们的测试数据，因为我们将从 WireMock
    实例中检索数据。我们将定义我们的行为一个 `AchUploads` 数组（列表 6.25），而不是硬编码的数据。
- en: '![A screenshot of a computer  Description automatically generated](../Images/CH06_F04_Kardell.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](../Images/CH06_F04_Kardell.png)'
- en: Figure 6.4  Response from our `/api/v1/files` endpoint as viewed in Postman
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.4  在 Postman 中查看的 `/api/v1/files` 端点的响应
- en: Listing 6.25  Preparing our component to receive data
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.25  准备我们的组件接收数据
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 Defines a structure for our data so we can type it appropriately'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义我们的数据结构，以便我们可以适当地为其添加类型'
- en: '#2 Our rows data will be stored in an array of type ACHUpload.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们的数据行将存储在类型为 ACHUpload 的数组中。'
- en: Now, we can make our request to populate data.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以发出请求以填充数据。
- en: Listing 6.26  Making an API call with axios
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.26  使用 axios 进行 API 调用
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '#1 useEffect is a perfect React function for making API calls.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 useEffect 是一个完美的 React 函数，用于进行 API 调用。'
- en: '#2 Uses axios to get our files listing'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用 axios 获取我们的文件列表'
- en: '#3 Handles the returned Promise by displaying the data and setting rows to
    the returned data'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 处理返回的 Promise，显示数据并将行设置为返回的数据'
- en: '#4 Logs any problems to the console'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 将任何问题记录到控制台'
- en: '#5 The empty array [] tells React to execute this only once.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 空数组 [] 告诉 React 只执行一次。'
- en: Usually, we recommend that these API calls are offloaded and called from a single
    location instead of being embedded in the components, but for now, it is okay
    to have them inside the component. For instance, we often create `api` folder
    or equivalent where these functions can be imported from. This allows the API
    calls to be easily accessed from multiple locations.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们建议这些 API 调用应该从单个位置调用，而不是嵌入到组件中，但就目前而言，将它们放在组件内部是可以的。例如，我们经常创建一个 `api` 文件夹或类似的地方，以便可以从那里导入这些函数。这使得
    API 调用可以从多个位置轻松访问。
- en: However, our more immediate concern is that we have a hardcoded URL pointed
    to the localhost (http://localhost:8081), which will certainly change when we
    deploy the Dashboard to Docker. So for the time being, let’s take advantage of
    Next.js to store our variables, and then, we’ll be able to configure them for
    Docker easily. Thus, we create an .env.local file.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们更紧迫的问题是，我们有一个指向 localhost（http://localhost:8081）的硬编码 URL，当我们将仪表板部署到 Docker
    时，这肯定会改变。所以，为了目前，让我们利用 Next.js 存储我们的变量，然后，我们将能够轻松地为 Docker 配置它们。因此，我们创建一个 .env.local
    文件。
- en: Listing 6.27  Our .env.local file
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.27  我们的 .env.local 文件
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can now update our code to use the environment variable in our URL.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新我们的代码，以在 URL 中使用环境变量。
- en: Listing 6.28  Updated API call
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.28  更新的 API 调用
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '#1 Returns the environment variable or sets it to the empty string when undefined'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 当环境变量未定义时，返回环境变量或将其设置为空字符串'
- en: '#2 Updates the axios call to use the new apiUrl'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 更新 axios 调用以使用新的 apiUrl'
- en: With this code, we can test our API and still see the sample files we are returning
    from WireMock. We are now able to change the URL our APIs hit when we are building
    our Docker containers.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，我们可以测试我们的 API，并且仍然可以看到我们从 WireMock 返回的示例文件。我们现在能够更改构建 Docker 容器时我们的 API
    所触发的 URL。
- en: 6.6 Expanding the UI with an ACH batch view
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 使用 ACH 批量视图扩展 UI
- en: Now that you understand these pieces, let’s take a look at combining Next.js,
    Recharts, Axios, and WireMock to create a view of ACH batches. On the dashboard,
    we would like to be able to click one of the file names presented to view the
    batches for that file. The view will display a scatterplot and provide the ability
    to display more details about the batches for each company in the ACH file, as
    shown in figure 6.5\. Providing information on the characteristics of the batches
    (in this case their size based on their amount and number of entries) can help
    us start putting controls in place for tasks such as fraud detection and risk
    management in the future as we expand the application. The scatterplot allows
    us to easily spot batches with larger dollar amounts or with higher item counts.
    Eventually, if we were to mix in historical data, we could then analyze patterns
    for these companies and highlight unusual activity patterns.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了这些部分，让我们看看如何结合Next.js、Recharts、Axios和WireMock来创建ACH批次的视图。在仪表板上，我们希望能够点击显示的文件名之一来查看该文件的批次。视图将显示散点图，并提供显示ACH文件中每个公司批次更多详细信息的功能，如图6.5所示。提供关于批次特征（在这种情况下基于它们的金额和条目数量）的信息可以帮助我们在未来扩展应用程序时开始实施欺诈检测和风险管理等任务的控制。散点图使我们能够轻松地发现金额较大或项目计数较高的批次。最终，如果我们混合历史数据，我们就可以分析这些公司的模式，并突出不寻常的活动模式。
- en: '![](../Images/CH06_F05_Kardell.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F05_Kardell.png)'
- en: Figure 6.5  An ACH batch view
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5  ACH批处理视图
- en: 6.6.1 Defining our WireMock data for the ACH batch view
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.1 定义ACH批处理视图的WireMock数据
- en: Our JSON data will essentially be an array of arrays. We also know that there
    can be multiple batches in an ACH file. Each batch has an associated company,
    and the company may have multiple batches in a file. We want to have the batches
    returned and grouped by the company. So, something like the following listing
    should work.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的JSON数据本质上是一个数组的数组。我们也知道在一个ACH文件中可以有多个批次。每个批次都关联一个公司，而公司可能在文件中有多个批次。我们希望返回并按公司分组批次。所以，以下列表应该可以工作。
- en: Listing 6.29  Sample ACH batch data
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.29  ACH批处理数据示例
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '#1 We return an array of all batches in a file grouped by company.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们返回一个按公司分组在文件中的所有批次的数组。'
- en: '#2 The company name of each batch is present.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 每个批次的公司名称都存在。'
- en: '#3 An array of all batches for a company called companyBatches'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 包含公司名为companyBatches的所有批次的数组'
- en: '#4 Multiple JSON objects containing our batch data'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 包含我们批处理数据的多个JSON对象'
- en: We define some batches we are going to associate with the stubbed data we used
    for the file. Specifically, we want to return this data when someone queries an
    API endpoint such as `/api/v1/files/{fileId}/batches`. As we saw in WireMock,
    we could define hardcoded paths for all the `fileId`s we were interested in. However,
    that would result in a lot of mappings. Instead, we can dynamically match these
    fields using templating and return specific responses for each. We define ach_files_batches.json
    in the following listing. Note that we use `urlPathTemplate` and specify `{fileId}`.
    Then we also use `{{request.path.fileId}}` in the `bodyFileName` of the response,
    which allows us to extract the dynamic UUID we expect to receive and use it in
    a response we would then define in the `__files` directory.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一些我们将与用于文件的模拟数据关联的批次。具体来说，当有人查询API端点，如`/api/v1/files/{fileId}/batches`时，我们希望返回这些数据。正如我们在WireMock中看到的，我们可以为所有我们感兴趣的`fileId`定义硬编码的路径。然而，这将导致大量的映射。相反，我们可以使用模板动态匹配这些字段，并为每个返回特定的响应。我们在以下列表中定义了ach_files_batches.json。请注意，我们使用`urlPathTemplate`并指定`{fileId}`。然后我们还在响应的`bodyFileName`中使用`{{request.path.fileId}}`，这允许我们提取我们期望接收的动态UUID，并在`__files`目录中定义的响应中使用它。
- en: Listing 6.30  WireMock templating example
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.30  WireMock模板示例
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '#1 Uses urlPathTemplate to allow the use of parameters'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用urlPathTemplate允许使用参数'
- en: '#2 The request.path.fileId references the variable defined in the urlPathTemplate.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 request.path.fileId引用在urlPathTemplate中定义的变量。'
- en: With all said, we would have the ability to define specific responses to API
    calls. Figure 6.6 illustrates this concept better. Note that we are not actually
    saving anything into WireMock. We are using canned responses we have prepopulated
    in the WireMock `__files` directory.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的这些，我们将能够定义对API调用的特定响应。图6.6更好地说明了这个概念。请注意，我们实际上并没有将任何东西保存到WireMock中。我们正在使用预先填充在WireMock
    `__files` 目录中的预定义响应。
- en: '![A screenshot of a diagram  Description automatically generated](../Images/CH06_F06_Kardell.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![一个图表的截图  自动生成的描述](../Images/CH06_F06_Kardell.png)'
- en: Figure 6.6  WireMock sequence
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.6  WireMock 序列
- en: Now that we are able to return data, we can define a component that can display
    it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够返回数据，我们可以定义一个可以显示数据的组件。
- en: 6.6.2 Updating the dashboard to take us to the batches screen
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.2 更新仪表板以跳转到批次屏幕
- en: We update the RecentAchUploads.tsx so that the filename becomes a link.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新了 RecentAchUploads.tsx，使文件名成为一个链接。
- en: Listing 6.31  Updated `RecentAchUploads`
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.31  更新的 `RecentAchUploads`
- en: '[PRE30]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '#1 Updates the text to be a link that will use the file ID'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将文本更新为使用文件 ID 的链接'
- en: The `fileDetails` screen takes the UUID of the file, which will help drive the
    resulting queries. Next.js uses file-based routing that lets us define the URL
    using a simple folder structure. In this case, including the UUID as part of the
    URL is denoted by a directory in square brackets. The following listing is the
    folder structure we need to create.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`fileDetails` 屏幕接受文件的 UUID，这将有助于驱动生成的查询。Next.js 使用基于文件的路由，允许我们使用简单的文件夹结构定义
    URL。在这种情况下，将 UUID 作为 URL 的一部分表示为方括号中的目录。以下列表是我们需要创建的文件夹结构。'
- en: Listing 6.32  Folder structure for the file details page
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.32  文件详情页面的文件夹结构
- en: '[PRE31]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '#1 The square brackets denote a parameter on the URL we can access.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 方括号表示我们可以访问的 URL 参数。'
- en: The `[id]` is a dynamic parameter in our URL. For example, with this structure,
    we should be able to navigate to URLs such as `/fileDetails/0854b018-c5ce-4e00-8a4f-d268a1a85aa2`
    or `/fileDetails/d11fb49c-4a07-4b96-88cc-db1fc7277bfa`, assuming those were valid
    UUIDs for our ACH files.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`[id]` 是我们 URL 中的一个动态参数。例如，使用这种结构，我们应该能够导航到类似于 `/fileDetails/0854b018-c5ce-4e00-8a4f-d268a1a85aa2`
    或 `/fileDetails/d11fb49c-4a07-4b96-88cc-db1fc7277bfa` 的 URL，假设这些是我们 ACH 文件的有效
    UUID。'
- en: 6.6.3 Displaying batch details
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.3 显示批次详情
- en: The page.tsx will contain the logic to retrieve the batch information and display
    it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: page.tsx 将包含检索批次信息并显示它的逻辑。
- en: Listing 6.33  Batch details
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.33  批次详情
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '#1 Defines our JSON structure so that we can strongly type the response'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义我们的 JSON 结构，以便我们可以对响应进行强类型化'
- en: '#4 Allows the URL parameters to be accessed'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 允许访问 URL 参数'
- en: '#5 References the URL parameter by the same name we defined in square brackets'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 通过与我们在方括号中定义的相同名称引用 URL 参数'
- en: '#6 Stores the batches with useState like we did in other components'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 使用 useState 类似我们在其他组件中做的那样存储批次'
- en: '#7 Uses useEffect to gather the data from the API'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 使用 useEffect 从 API 获取数据'
- en: '#8 Maps the returned batches to display the UI elements'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 将返回的批次映射到显示 UI 元素'
- en: This component presents the accordion view showed earlier in the chapter as
    part of figure 6.5 for the companies in the ACH file. An important takeaway from
    this component is seeing how we can dynamically create layout elements on our
    page. In other components, we will use DataGrid views that provide a table structure
    for viewing dynamic data. However, it is helpful to know that we can create layouts
    with dynamic data manually, as well when the need arises.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件展示了本章前面提到的作为 6.5 图的一部分的折叠视图，用于 ACH 文件中的公司。从这个组件中我们可以得到的一个重要启示是看到我们如何可以在页面上动态创建布局元素。在其他组件中，我们将使用提供表格结构以查看动态数据的
    DataGrid 视图。然而，了解我们可以在需要时手动创建具有动态数据的布局也是有帮助的。
- en: 6.7 Creating a ScatterPlot component
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 创建散点图组件
- en: Finally, we want to add a scatterplot to the page that shows the items in the
    batch versus the total amount of debits and credits. The following listing shows
    the directory structure we will be creating. You may create another subdirectory
    to store specific scatterplot-related files. Since we have not reached the point
    where this directory contains a lot of files, we will leave this as is for the
    time being.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想在页面上添加一个散点图，显示批次中的项目与借方和贷方总额的关系。以下列表显示了我们将要创建的目录结构。您可能需要创建另一个子目录来存储特定的散点图相关文件。由于我们尚未达到这个目录包含大量文件的程度，我们将暂时保持原样。
- en: Listing 6.34  Directory structure for our charts
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.34  我们图表的目录结构
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 6.7.1 Scatterplot component
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.1 散点图组件
- en: A scatterplot is useful for showing the possible correlation between variables.
    In our case, we may not necessarily be interested in the analytic aspect. However,
    the scatterplot also provides a way to identify batches with a high number of
    items or with a large dollar amount, which may be interesting to our users. Certainly,
    there may also be an opportunity for us to display trends in the batches for a
    particular company, which may also help our users perform analysis.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图有助于展示变量之间可能的相关性。在我们的案例中，我们可能并不一定对分析方面感兴趣。然而，散点图也提供了一种识别具有大量项目或大量金额的批次的途径，这可能会对我们的用户很有趣。当然，我们也许还有机会展示特定公司的批次趋势，这也许有助于我们的用户进行数据分析。
- en: In the meantime, this component provides an opportunity to explore using colors,
    custom tooltips, and custom ticks on the axis. These features are discussed in
    subsequent sections. The initial code for the scatterplot is shown in listing
    6.35, with the actual component rendering shown in listing 6.36.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，这个组件提供了探索使用颜色、自定义提示和自定义轴刻度的机会。这些特性将在后续章节中讨论。散点图的初始代码显示在列表 6.35 中，实际组件渲染显示在列表
    6.36 中。
- en: The component defines an interface called `AchBatchesScatterPlotProps` so that
    it can set the types properly. In addition, it is important that this component
    accepts the batches as a read-only parameter rather than making any API calls
    inside the component. We could have just as easily made the API calls inside the
    component. However, if we had multiple components that wanted to make use of this
    data, we would end up with repeated API calls to gather the same data. We also
    marked the data as read-only to help enforce the concept of the component only
    utilizing the data and not introducing unintended consequences by being used.
    However, note that `Readonly` is a compile-time feature for TypeScript, and the
    resulting JavaScript will not have it. Finally, since we are interested in the
    total dollar amount of the batch, we add the credit and debit amounts together
    and store them into `totalCreditAndDebits`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 组件定义了一个名为 `AchBatchesScatterPlotProps` 的接口，以便它可以正确设置类型。此外，这个组件接受批处理作为只读参数，而不是在组件内部进行任何
    API 调用。我们本可以在组件内部进行 API 调用。然而，如果我们有多个组件想要使用这些数据，我们最终会进行重复的 API 调用来收集相同的数据。我们还标记数据为只读，以帮助强制执行组件仅利用数据的概念，并通过使用不引入意外后果。然而，请注意
    `Readonly` 是 TypeScript 的编译时特性，生成的 JavaScript 不会有这个特性。最后，由于我们感兴趣的是批次的总金额，我们将信用和借记金额相加，并将它们存储到
    `totalCreditAndDebits` 中。
- en: Listing 6.35  Scatterplot component
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.35  散点图组件
- en: '[PRE34]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '#1 Defines an interface for the component properties, so we can strongly type
    them'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义组件属性的接口，以便我们可以进行强类型化'
- en: '#2 Accepts the properties as Readonly so we do not modify them'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 作为只读属性接受属性，所以我们不会修改它们'
- en: '#3 Spreads the contents of the companyBatch object'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 将 companyBatch 对象的内容展开'
- en: '#4 Adds a new property to the object named totalCreditAndDebits'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 向对象添加一个名为 totalCreditAndDebits 的新属性'
- en: '#5 Spreads the content of the batch object'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 将批处理对象的内容展开'
- en: '#6 Replaces the existing companyBatches with the new batches containing the
    totalCreditAndDebits'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 用包含 totalCreditAndDebits 的新批处理替换现有的 companyBatches'
- en: In the following listing, we have the component that renders the actual scatterplot.
    Here we take advantage of the flexibility of recharts by defining custom tooltip
    content by passing a component called `AchBatchesScatterTooltip` and by defining
    a custom tick mark component for the `YAxis` called `CurrencyTick`. Furthermore,
    we assign a different color to each company when placing the point on the plot
    (more about these custom components in the following sections).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，我们有渲染实际散点图的组件。我们利用 recharts 的灵活性，通过传递一个名为 `AchBatchesScatterTooltip`
    的组件来定义自定义提示内容，并定义一个用于 `YAxis` 的自定义刻度标记组件，称为 `CurrencyTick`。此外，我们在图上放置点时为每个公司分配不同的颜色（关于这些自定义组件的更多内容将在后续章节中介绍）。
- en: Lisitng 6.36  Scatterplot render
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.36  散点图渲染
- en: '[PRE35]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '#1 Custom component for the ticks on the Y-axis'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 用于 Y 轴刻度的自定义组件'
- en: '#2 Custom tooltip when hovering over a data point'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 当悬停在数据点上时自定义提示'
- en: '#3 Custom color depending on the company'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 根据公司自定义颜色'
- en: 6.7.2 Scatterplot custom tooltip
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.2 散点图自定义提示
- en: After defining our custom tooltip component in the next listing, we can customize
    the displayed tooltip. We kept it simple by using the components available in
    Material UI. We can also reuse the `formatCurrency` method that we had defined
    to ensure the correct display of data in the tooltip.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中定义我们的自定义提示组件后，我们可以自定义显示的提示。我们通过使用Material UI中可用的组件保持了简单性。我们还可以重用之前定义的`formatCurrency`方法，以确保在提示中正确显示数据。
- en: Listing 6.37  Custom tooltip for scatterplot
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.37  散点图的自定义提示
- en: '[PRE36]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '#1 Reuses our formatCurrency routine to ensure consistency in displaying amounts'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 重新使用我们的formatCurrency函数以确保显示金额的一致性'
- en: 6.7.3 Scatterplot custom ticks
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.3 散点图自定义刻度
- en: Another way to customize charts in recharts is by defining a custom tick. Here
    we want our ticks to be formatted as currency instead of leaving them unformatted
    and adding a label to say “in dollars” or something similar. We define an interface
    that contains the passed data and then again use our `formatCurrency` utility
    (listing 6.38).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在recharts中自定义图表的另一种方法是定义自定义刻度。我们希望我们的刻度格式化为货币形式，而不是未格式化并添加一个标签来说明“美元”或类似的内容。我们定义了一个包含传递数据的接口，然后再次使用我们的`formatCurrency`实用工具（列表6.38）。
- en: This component uses both `Readonly` (to ensure that the component does not modify
    any parameters) and `Partial`. The `Partial` type is used because `recharts` is
    in control of the parameters passed. Furthermore, rather than marking each parameter
    as optional by using `?`, we can mark all parameters in `CurrencyTickProps` as
    optional by using `Partial<CurrencyTickProps>`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件同时使用`Readonly`（以确保组件不修改任何参数）和`Partial`。使用`Partial`类型是因为`recharts`控制传递的参数。此外，我们不需要使用`?`标记每个参数为可选，而是可以使用`Partial<CurrencyTickProps>`将`CurrencyTickProps`中的所有参数标记为可选。
- en: Listing 6.38  Custom currency tick
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.38  自定义货币刻度
- en: '[PRE37]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '#1 Defines our properties so that they are strongly typed'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义我们的属性，以确保它们是强类型的'
- en: '#2 Properties are marked as Readonly and Partial.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 属性被标记为Readonly和Partial。'
- en: '#3 If the payload does not exist, substitute 0.0.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 如果有效载荷不存在，则替换为0.0。'
- en: '#4 Uses our handy formatCurrency function'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 使用我们方便的formatCurrency函数'
- en: Obviously, the ability to customize our charts further using custom ticks is
    a powerful tool. Even if we chose to use the standard ticks, it is helpful to
    keep this type of customization in our back pocket for when the business makes
    a more specific request. In the next section, we will look at customizing colors
    for our charts.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用自定义刻度进一步自定义我们的图表是一个强大的工具。即使我们选择使用标准刻度，保留这种类型的自定义以备业务提出更具体的要求也是有帮助的。在下一节中，我们将探讨如何为我们的图表自定义颜色。
- en: 6.7.4 Using colors for the chart
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.4 使用颜色为图表着色
- en: Colors are a very important part of any visualization. In our case, we do not
    limit the number of points in the scatterplot, so we do not necessarily know the
    number of companies that will have to be identified. We could always limit the
    visualization by saying it is a scatterplot of the “Top 10 companies” or the “Top
    10 batches” so that we do not have to enumerate additional colors to handle an
    undetermined number of companies.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色是任何可视化的一个非常重要的部分。在我们的情况下，我们不限制散点图中点的数量，因此我们不一定知道需要识别的公司数量。我们总是可以通过说这是一个“前10家公司”或“前10批”的散点图来限制可视化，这样我们就不需要枚举额外的颜色来处理不确定数量的公司。
- en: The next listing shows how we may enumerate the colors and then the code will
    loop through these colors and reuse them as necessary as we are doing `COLORS[index`
    `% COLORS.length]`. This approach will work but also has the problem of repeating
    colors when there are more companies than colors defined, and that will obviously
    make the visualization difficult to understand from a user’s perspective.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了如何枚举颜色，然后代码将循环遍历这些颜色，并在需要时重复使用它们，就像我们正在做`COLORS[index % COLORS.length]`。这种方法虽然可行，但也会在定义的颜色数量少于公司数量时重复颜色，这显然会使用户难以理解可视化。
- en: Listing 6.39  Enumerating colors
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.39  列举颜色
- en: '[PRE38]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Another option we went with was computing the colors based on the company name,
    which provided us with a better opportunity to handle many companies in our visualization
    (although there will be a threshold where it is no longer valuable). However,
    as it stands, this approach also does not allow us to use names that may hash
    to the same value, nor does it necessarily give us the best colors in a visualization.
    Later, we may decide that showing the top 10 companies is the best way to handle
    the visualization.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采取的另一项选择是基于公司名称计算颜色，这为我们处理可视化中的许多公司提供了更好的机会（尽管当它不再有价值时会有一个阈值）。然而，目前这种方法也不允许我们使用可能散列到相同值的名称，也不一定能在可视化中给出最佳的颜色。稍后，我们可能会决定显示前
    10 家公司是处理可视化的最佳方式。
- en: Listing 6.40 shows the code used to compute a hex color code from the company
    name (or any string). In this case, the implementation details on how we create
    a color code from a string are not so important. Rather, we want to understand
    different ways we may use when approaching a problem and try to understand the
    potential tradeoffs in each approach. In this case, we have lost control over
    the exact colors being used, which also means the colors may be indistinguishable
    or conflict with the rest of the visualization. However, this approach allows
    us to show many companies, also providing consistency in color for the company.
    So, the color could be consistent in other visualizations or just change every
    day.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.40 展示了用于从公司名称（或任何字符串）计算十六进制颜色代码的代码。在这种情况下，如何从字符串创建颜色代码的实现细节并不那么重要。相反，我们想了解在解决问题时可能使用的方法，并尝试理解每种方法的潜在权衡。在这种情况下，我们失去了对所使用颜色的精确控制，这也意味着颜色可能无法区分或与整个可视化冲突。然而，这种方法允许我们展示许多公司，同时也为公司提供了颜色的统一性。因此，颜色可以在其他可视化中保持一致，或者每天改变。
- en: Listing 6.40  Using the company name to determine the color
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.40 使用公司名称来确定颜色
- en: '[PRE39]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How we display data is not only a matter of preference—our choice of layout,
    formatting, and colors can influence data interpretation. For instance,
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何展示数据不仅是一个偏好问题——我们选择的布局、格式和颜色可能会影响数据解读。例如，
- en: Using a red/green color scheme makes it harder for individuals with color blindness
    to distinguish the colors in different categories.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用红/绿色调会使色盲人士难以区分不同类别的颜色。
- en: 3D bar charts can be visually appealing but can lead to inaccurate interpretations
    of the data because the perspective can make bars appear larger/smaller than they
    are.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D 条形图可能具有视觉吸引力，但可能导致对数据的错误解读，因为视角可以使条形看起来比实际更大/更小。
- en: In cherry-picked timeframes, data that does not fit a specific narrative is
    hidden or minimized.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在精选的时间段内，不符合特定叙述的数据被隐藏或最小化。
- en: For additional information on this topic, see *Everyday Data Visualization*
    (2024, Manning) by Desireé Abbott, especially if you want to take your visualizations
    to the next level.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解此主题的更多信息，请参阅 Desireé Abbott 所著的 *《日常数据可视化》*（2024年，Manning出版社），特别是如果您想将您的可视化提升到下一个层次。
- en: 6.8 Deploying the dashboard in Docker
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 在 Docker 中部署仪表板
- en: As a final step, we want to deploy our code in Docker to tie all the pieces
    of our system together. The next chapter will focus on implementing the needed
    APIs, making sure components can communicate, and general housekeeping. For now,
    we only want to ensure the container is built correctly and can communicate with
    our WireMock instance.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们希望将我们的代码部署到 Docker 中，以便将我们系统的各个部分连接起来。下一章将重点介绍实现所需的 API，确保组件可以通信，并进行一般性维护。目前，我们只想确保容器构建正确，并且可以与我们的
    WireMock 实例通信。
- en: As you may recall, our API calls use the `NEXT_PUBLIC_API_URL`, which allows
    us to configure the base URL needed to communicate with the backend. Listing 6.41
    shows the service implementation for our docker-compose.yml. We now introduce
    the use of the `args` parameter to pass in arguments to our build process. We
    have set the URL to the same endpoint that we had in our `.env.local` project
    setup. This is because the code will be running on the client side in the browser,
    which means we will need to use `localhost:8081` and not the internal reference
    to `wiremock:8080`, as you may initially imagine.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所忆，我们的API调用使用`NEXT_PUBLIC_API_URL`，这允许我们配置与后端通信所需的基URL。列表6.41显示了docker-compose.yml的服务实现。我们现在引入了使用`args`参数向构建过程传递参数。我们将URL设置为与我们的`.env.local`项目设置中相同的端点。这是因为代码将在客户端的浏览器中运行，这意味着我们需要使用`localhost:8081`而不是您最初可能想象的内部引用`wiremock:8080`。
- en: Listing 6.41  Adding the dashboard to Docker
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.41  将仪表板添加到Docker
- en: '[PRE40]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '#1 Defines variables to pass to the build'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义传递给构建的变量'
- en: In the following listing, we have the Dockerfile referenced in listing 6.41\.
    This code takes care of setting our environment variable, and building and running
    the application. In this Dockerfile, we utilize the `NEXT_PUBLIC_API_URL` by showing
    how we may set a default value, as well as how to set it in the container.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们有列表6.41中引用的Dockerfile。此代码负责设置我们的环境变量，并构建和运行应用程序。在此Dockerfile中，我们通过展示如何设置默认值以及如何在容器中设置它，利用了`NEXT_PUBLIC_API_URL`。
- en: Listing 6.42  The Dockerfile for the dashboard
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.42  仪表板的Dockerfile
- en: '[PRE41]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '#1 Defines an argument that can be used or defaulted'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 定义一个可使用或默认的参数'
- en: '#2 Sets an environment variable that will contain our API URL'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 设置一个将包含我们的API URL的环境变量'
- en: At this point, we should be able to build the containers and start them with
    `docker-compose` `down;` `docker-compose` `up` `--build` like before. Then, after
    navigating to http://localhost:4000, we should see our dashboard come up, displaying
    our WireMock data.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该能够构建容器，并使用`docker-compose` `down;` `docker-compose` `up` `--build`像以前一样启动它们。然后，导航到http://localhost:4000后，我们应该看到我们的仪表板启动，显示我们的WireMock数据。
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The dashboard serves as the user interface for file uploads and data views,
    powered by APIs, and it can be developed using various technologies, with a current
    preference for Next.js.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板作为文件上传和数据视图的用户界面，由API提供支持，可以使用各种技术进行开发，目前首选Next.js。
- en: Next.js supports building interactive web applications with React by using HTML,
    CSS, and DOM principles and offering file-based routing, CSR, SSR, and multiple
    styling methods.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js通过使用HTML、CSS和DOM原则以及提供基于文件的路由、CSR、SSR和多种样式方法，支持使用React构建交互式Web应用程序。
- en: Starting with Next.js involves setting up `Node.js`, creating a project using
    npx, and running a default application to verify setup correctness.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Next.js开始涉及设置`Node.js`，使用npx创建项目，并运行默认应用程序以验证设置的正确性。
- en: The dashboard can be initialized using templates such as Material UI, and dependencies
    should be installed to support components and API calls.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板可以使用Material UI等模板进行初始化，并且应该安装依赖项以支持组件和API调用。
- en: Incorporating TypeScript enhances maintainability by adding explicit types and
    catching errors during development.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加显式类型并在开发过程中捕获错误，引入TypeScript增强了可维护性。
- en: Jest is used for unit testing the UI, ensuring page functionality and accessibility
    through ARIA roles.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest用于对UI进行单元测试，确保通过ARIA角色实现页面功能和无障碍性。
- en: Refactoring of navigation components warrants better code organization and inclusion
    in the upload page.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对导航组件进行重构需要更好的代码组织和将其包含在上传页面中。
- en: Hardcoded data is initially used for UI development and then replaced with mocked
    API calls using tools such as WireMock for parallel development.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬编码的数据最初用于UI开发，然后使用WireMock等工具进行并行开发时，用模拟的API调用替换。
- en: Mocking APIs with WireMock involves setting up Docker, configuring stubs, and
    refreshing for changes to take effect, facilitating UI testing without complete
    backend availability.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WireMock模拟API涉及设置Docker、配置存根和刷新以使更改生效，从而在不完全可用后端的情况下促进UI测试。
- en: Deployment of the dashboard in Docker involves configuring environment variables
    and ensuring communication with mocked APIs for dynamic data display.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中部署仪表板涉及配置环境变量并确保与模拟API的通信以实现动态数据显示。
