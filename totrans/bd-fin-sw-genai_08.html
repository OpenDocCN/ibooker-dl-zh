<html><head></head><body>
<div id="sbo-rt-content"><div class="readable-text" id="p1">
<h1 class="readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">7</span> </span><span class="chapter-title-text">Our minimum viable product</span></h1>
</div>
<div class="introduction-summary">
<h3 class="introduction-header"><span class="CharOverride-1">This chapter covers</span><span class="CharOverride-1"/></h3>
<ul>
<li class="readable-text" id="p2"><span class="CharOverride-2">The purpose of minimum viable product (MVP)</span></li>
<li class="readable-text" id="p3"><span class="CharOverride-2">Putting everything together into an MVP</span></li>
<li class="readable-text" id="p4"><span class="CharOverride-2">Security concerns</span></li>
<li class="readable-text" id="p5"><span class="CharOverride-2">Testing with Playwright</span></li>
</ul>
</div>
<div class="readable-text" id="p6">
<p>Over the previous sprints, we worked on spike stories examining our project’s various components. You were introduced to generative AI and different tools that can expedite software development. We also reviewed specific technologies, such as Python/FastAPI, Postgres, Docker, and Next.js. Now, the line of business would like to see the fruit of our labor. This chapter focuses on putting everything together into a minimum viable product (MVP), which allows a user to</p>
</div>
<ul>
<li class="readable-text" id="p7">Upload an ACH file</li>
<li class="readable-text" id="p8">Parse an ACH file and store it in the database</li>
<li class="readable-text" id="p9">Visualize the results in our dashboard </li>
</ul>
<div class="readable-text" id="p10">
<p>The functionality will not expand significantly from what was developed in the previous sprints. Instead, we want to ensure those individual components are now integrated seamlessly. Along the way, we will explore what happens in the system demo and validate our MVP using Playwright. Having the MVP will allow us to release something to our customers and gather feedback, which we’ll use to enhance our project in the coming chapters.</p>
</div>
<div class="readable-text" id="p11">
<h2 class="readable-text-h2"><span class="num-string">7.1</span> Which minimum are we talking about?</h2>
</div>
<div class="readable-text" id="p12">
<p>During your career, you have probably heard about at least a few different minimums, such as</p>
</div>
<ul>
<li class="readable-text" id="p13"><em>Minimum lovable product (MLP</em><em>)</em>—Similar to an MVP but focuses on delivering something that customers love from the start</li>
<li class="readable-text" id="p14"><em>Minimum marketable product (MMP</em><em>)</em>—Focuses on delivering the smallest amount of functionality that can be sold to our customers</li>
<li class="readable-text" id="p15"><em>Minimum marketable feature (MMF</em><em>)</em>—Focuses on delivering software features that are of value to our customers</li>
</ul>
<div class="readable-text" id="p16">
<p>The MVP concept was first introduced by Frank Robinson and popularized by Eric Ries in his book <em>The Lean Startup</em>. Ries defines MVP as “that version of a new product which allows a team to collect the maximum amount of validated learning about customers with the least effort.”</p>
</div>
<div class="readable-text intended-text" id="p17">
<p>Let’s take a moment to break this statement down. Obviously, our new product represents our modernization of the ACH dashboard, but what about “validated learning”? With validated learning, we are gaining knowledge about just how close we are to progressing toward a product that satisfies our customers. Validated learning should be evidence based and actionable, giving us something that we can use to improve our product in the next iteration. The “least effort” part does not mean producing something subpar but rather something achievable in the short term and with minimal investment.</p>
</div>
<div class="readable-text intended-text" id="p18">
<p>Our goal with the MVP of the ACH dashboard is to provide our customers with a product that begins to address their concerns about the existing dashboard but ultimately helps us learn about the final product. This approach lets us transform the product from something that may have been developed in relative isolation to something usable by the customer (in larger companies, customer requests may have been filtered down to us through multiple layers, with each request putting the company’s preferences on the product specs). Once our customers have the product in hand, we can use their feedback to help drive the direction of the product and provide the required features quickly. Compare this to other approaches where the entire product may be developed and delivered without meaningful feedback from the client base. We may end up with a product that is disliked because it is missing a feature customers may deem important, or it may not even be usable in a customer’s environment due to their unique needs. Indeed, we have seen fully developed products that had to be shelved because basic concerns about the problem at hand were not addressed or the environment in which they were needed to run was not considered. Table 7.1 provides a quick breakdown of key concepts regarding MVP, MLP, MMP, and MMF.</p>
</div>
<div class="browsable-container browsable-table-container" id="p19">
<h5 class="browsable-container-h5">Table 7.1 MVP, MLP, MMP, and MMF key concepts</h5>
<table class="No-Table-Style _idGenTablePara-1" id="table001">
<colgroup>
<col class="_idGenTableRowColumn-1"/>
<col class="_idGenTableRowColumn-2"/>
<col class="_idGenTableRowColumn-2"/>
<col class="_idGenTableRowColumn-2"/>
<col class="_idGenTableRowColumn-2"/>
</colgroup>
<tbody>
<tr class="No-Table-Style _idGenTableRowColumn-3">
<td class="No-Table-Style CellOverride-1"> </td>
<td class="No-Table-Style CellOverride-2"> <p class="_TableHead"><span class="CharOverride-3">MVP</span></p> </td>
<td class="No-Table-Style CellOverride-2"> <p class="_TableHead"><span class="CharOverride-3">MMP</span></p> </td>
<td class="No-Table-Style CellOverride-2"> <p class="_TableHead"><span class="CharOverride-3">MLP</span></p> </td>
<td class="No-Table-Style CellOverride-3"> <p class="_TableHead"><span class="CharOverride-3">MMF</span></p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-4">
<td class="No-Table-Style CellOverride-4"> <p class="_TableBody"><span class="CharOverride-4">Purpose</span></p> </td>
<td class="No-Table-Style CellOverride-5"> <p class="_TableBody">Tests and validates core assumptions</p> </td>
<td class="No-Table-Style CellOverride-5"> <p class="_TableBody">Creates a sellable version of the product</p> </td>
<td class="No-Table-Style CellOverride-5"> <p class="_TableBody">Delivers a product customers can connect with and love</p> </td>
<td class="No-Table-Style CellOverride-6"> <p class="_TableBody">Provides features that add value and can be marketed separately</p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-4">
<td class="No-Table-Style CellOverride-7"> <p class="_TableBody ParaOverride-7"><span class="CharOverride-4">Development</span></p> <p class="_TableBody ParaOverride-7"><span class="CharOverride-4">approach</span></p> </td>
<td class="No-Table-Style CellOverride-8"> <p class="_TableBody">Prioritizes testing and learning</p> </td>
<td class="No-Table-Style CellOverride-8"> <p class="_TableBody">Balances functionality with market needs</p> </td>
<td class="No-Table-Style CellOverride-8"> <p class="_TableBody">Focuses on design and emotional engagement</p> </td>
<td class="No-Table-Style CellOverride-9"> <p class="_TableBody">Focuses on a single effective feature</p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-4">
<td class="No-Table-Style CellOverride-7"> <p class="_TableBody ParaOverride-7"><span class="CharOverride-4">Customer </span></p> <p class="_TableBody ParaOverride-7"><span class="CharOverride-4">value</span></p> </td>
<td class="No-Table-Style CellOverride-8"> <p class="_TableBody">Provides core value to early adopters</p> </td>
<td class="No-Table-Style CellOverride-8"> <p class="_TableBody">Provides a complete solution to target market needs</p> </td>
<td class="No-Table-Style CellOverride-8"> <p class="_TableBody">Creates an emotional connection and stands out in the market</p> </td>
<td class="No-Table-Style CellOverride-9"> <p class="_TableBody">Provides incremental improvement to the existing product</p> </td>
</tr>
<tr class="No-Table-Style _idGenTableRowColumn-5">
<td class="No-Table-Style CellOverride-10"> <p class="_TableBody ParaOverride-7"><span class="CharOverride-4">Successful outcome</span></p> </td>
<td class="No-Table-Style CellOverride-11"> <p class="_TableBody">Validation of core assumptions</p> </td>
<td class="No-Table-Style CellOverride-11"> <p class="_TableBody">Sales and market acceptance</p> </td>
<td class="No-Table-Style CellOverride-11"> <p class="_TableBody">Customer love and brand loyalty</p> </td>
<td class="No-Table-Style CellOverride-12"> <p class="_TableBody">Adoption rate and user engagement </p> </td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p20">
<h2 class="readable-text-h2"><span class="num-string">7.2</span> Preparing for the MVP</h2>
</div>
<div class="readable-text" id="p21">
<p>In the following sections, we ensure that all our previous work is integrated into the MVP. But before embarking on that journey, we review the individual pieces and parts that will make up our MVP—ACH parsing, database design, and UI—which were discussed in previous chapters. Figure 7.1 shows the components necessary for this part of the project.</p>
</div>
<div class="browsable-container figure-container" id="p22">
<img alt="A diagram of a product  Description automatically generated" height="307" src="../Images/CH07_F01_Kardell.png" style="width: 100%; max-width: max-content;" width="483"/>
<h5 class="figure-container-h5"><span class="">Figure 7.1</span><span class=""> </span><span class="">The pieces and parts fed into the MVP</span></h5>
</div>
<div class="readable-text" id="p23">
<p>If our initial work is done properly, the building of the MVP should be relatively straightforward. After all, we’ve done a fair amount of upfront work to get various components to this point. Remember, our previous research spikes built out the following components:</p>
</div>
<ul>
<li class="readable-text" id="p24">An ACH parser in Python</li>
<li class="readable-text" id="p25">APIs written in Python using FastAPI that generated OpenAPI documentation</li>
<li class="readable-text" id="p26">Design of a Postgres database to store the ACH data</li>
<li class="readable-text" id="p27">UI written in Next.js </li>
</ul>
<div class="readable-text" id="p28">
<p>In the worst-case scenario, we may come across the proverbial “square peg into a round hole” type of situation where we did not quite document (or adhere to documented functionality), which may require some rework to get those pieces to fit correctly. We also have the opportunity to include some final touches such as using Playwright for integration/system testing, which will allow us to ensure the product functions from an end-user’s perspective. Finally, we explore some additional security we may want to include in the project.</p>
</div>
<div class="readable-text" id="p29">
<h2 class="readable-text-h2"><span class="num-string">7.3</span> Building out the /files APIs</h2>
</div>
<div class="readable-text" id="p30">
<p>In chapter 4, you learned how to build APIs in Python using FastAPI. Then, we used Next.js and WireMock to create mock API responses that could be returned to the UI with the needed data. At this point, we want to verify that the backend and the APIs align properly.</p>
</div>
<div class="readable-text intended-text" id="p31">
<p>First, we bring up the different components through our JetBrains IDE (PyCharm), which allows us to start our current database in Docker, API, and the Dashboard UI. By navigating to http://localhost:8000/docs (OpenAPI documentation), we can take advantage of the <code>POST</code> request we had built during our research (it may not be perfect but should load the file). Figure 7.2 shows the sample <code>POST</code> request that will also let us choose our sample.ach file.</p>
</div>
<div class="browsable-container figure-container" id="p32">
<img alt="A white and green striped background  Description automatically generated with medium confidence" height="225" src="../Images/CH07_F02_Kardell.png" style="width: 100%; max-width: max-content;" width="788"/>
<h5 class="figure-container-h5"><span class="">Figure 7.2</span><span class=""> </span><span class="">The sample </span><span class=""><code>POST</code></span><span class=""> request</span><span class=""/></h5>
</div>
<div class="readable-text" id="p33">
<p>If we refresh our page, the Recent ACH Uploads shows NaN (not a number) for many fields (see figure 7.3). There could be several reasons for getting NaN:</p>
</div>
<ul>
<li class="readable-text" id="p34"><em>Parsing error</em><em>s</em>—Parsing non-numeric data such as <code>parseInt("abcd")</code><code/></li>
<li class="readable-text" id="p35"><em>Undefined or null value</em><em>s</em>—Using a field from the API that does not exist</li>
<li class="readable-text" id="p36"><em>Arithmetic error</em><em>s</em>—Dividing by zero</li>
</ul>
<div class="readable-text" id="p37">
<p>Let’s see if we can pinpoint this particular “square peg into a round hole” problem.</p>
</div>
<div class="browsable-container figure-container" id="p38">
<img alt="" height="123" src="../Images/CH07_F03_Kardell.png" style="width: 100%; max-width: max-content;" width="867"/>
<h5 class="figure-container-h5"><span class="">Figure 7.3</span><span class=""> </span><span class="">Data being returned but displayed incorrectly</span></h5>
</div>
<div class="readable-text" id="p39">
<p>We can explore the data returned by the <code>/files</code> API by using the OpenAPI documentation page (or a tool such as Postman). The following listing shows the data being returned from the API.</p>
</div>
<div class="browsable-container listing-container" id="p40">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.1<span class="CharOverride-7"> </span>Data being returned from <code>/files</code> endpoint</h5>
<div class="code-area-container">
<pre class="code-area"><span>[</span>
<span>  {</span>
<span>    "ach_files_id": "dcb8e6a4-79e9-4cf7-a138-491e58c1ebb8",</span>
<span>    </span>"file_name": "sample.ach",
    "file_hash": "application/octet-stream",
    "created_at": "2024-02-18T01:05:37.513025"
  }
]</pre>
</div>
</div>
<div class="readable-text" id="p41">
<p>If we compare this code to the interface for <code>AchUpload</code> from RecentAchUploads.tsx, we can see the differences. Not only are we missing fields such as <code>creditTotal</code> and <code>debitTotal</code>, but we also need to map some of the field names.</p>
</div>
<div class="browsable-container listing-container" id="p42">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.2<span class="CharOverride-7"> </span>The <code>AchUpload </code>interface</h5>
<div class="code-area-container">
<pre class="code-area">interface AchUpload {
    id: number;
    date: string;
    filename: string;
    creditTotal: number;
    debitTotal: number;
}</pre>
</div>
</div>
<div class="readable-text" id="p43">
<p>We should also review how the database is configured and change the amount fields from the file control record (type 9) to be <code>NUMERIC</code> instead of <code>VARCHAR</code>. This is a somewhat personal choice as arguments may be made to have a more flexible character value since the fields themselves can be formatted improperly. Making this type of change can be beneficial because the database will now enforce the data to be numeric. However, we may run into errors with existing functionality that worked before. Why? It’s because we could have unknowingly been putting spaces or other non-numeric data into that field. Of course, hopefully, our unit tests would have prevented this or, at the very least, would have quickly pointed out possible adjustments. </p>
</div>
<div class="readable-text intended-text" id="p44">
<p>In our case, we have tried to create a database structure that handles both unparsed records (for those times when the records are simply not parsable) and more detailed parsed records. The following listing shows the updated constraint for the numeric field. Note that the fields are 12 characters long, with a precision of 2.</p>
</div>
<div class="browsable-container listing-container" id="p45">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.3<span class="CharOverride-7"> </span>ACH table for the file control record</h5>
<div class="code-area-container">
<pre class="code-area">total_debit_entry_dollar_amount NUMERIC(12, 2) NOT NULL,
total_credit_entry_dollar_amount NUMERIC(12, 2) NOT NULL,</pre>
</div>
</div>
<div class="readable-text" id="p46">
<p>The parsing program needs to be updated as well (see listing 7.4). We use the <code>Decimal</code> datatype since it is a bit safer than using a floating point (<a href="https://docs.python.org/3/library/decimal.xhtml"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/docs.python.org/3/library/decimal.xhtml</span></a>). Note that we pass the fields as a string to <code>Decimal</code> instead of converting it to an <code>int</code>/<code>float</code> to avoid accidental conversion. For instance, the results of <code>Decimal('0.1')</code> and <code>Decimal(0.1)</code> are <code>Decimal('0.1')</code> and <code>Decimal('0.1000000000000000055511151231257827021181583404541015625')</code>, respectively, so we still have to be careful.</p>
</div>
<div class="browsable-container listing-container" id="p47">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.4<span class="CharOverride-7"> </span>Converting the string to a number that includes a decimal point</h5>
<div class="code-area-container">
<pre class="code-area">total_debit_entry_dollar_amount= #1
   Decimal(f"{record[31:41]}.{record[41:43]}"),  #1
total_credit_entry_dollar_amount=  #1
   Decimal(f"{record[43:53]}.{record[53:55]}"),  #1</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Parses the fields using a Decimal object and f-strings</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p48">
<p>Having to update our database to convert from storing a string to numeric where appropriate adds extra work. We could have cut down some of the work had we tackled it in our previous research spikes when working on the database. In addition, we may be asking ourselves whether it is worth the effort to convert these fields to numeric for an MVP. That is a valid question. While at the very least we get the benefit of the database enforcing the formatting of our data, the tradeoff is increased development time. </p>
</div>
<div class="readable-text intended-text" id="p49">
<p>Unfortunately, there is no right answer. Depending on the project, requirements, and timeframe, you may not have the extra time to convert the fields and may choose to do it later. In this case, we convert the fields since we need to update the API to return these fields anyway. We can make the changes, and based on the interface defined in the UI (listing 7.2), we know that a numeric was expected. </p>
</div>
<div class="readable-text intended-text" id="p50">
<p>Now that we have the data stored correctly, we need to return the fields as part of the query. That brings us to another area that has to be refactored. We created schemas and used them in both the database and to represent the data being returned from our APIs. We would like to keep the models separate because this separation of concerns provides us with more flexibility, better security, and data integrity. We refactor our schemas directory to have folders for <code>api</code> and <code>database</code>, and we move all existing schemas to the database folder, which results in the structure presented in the following listing (note that not all files are shown). </p>
</div>
<div class="browsable-container listing-container" id="p51">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.5<span class="CharOverride-7"> </span>New schemas directory structure</h5>
<div class="code-area-container">
<pre class="code-area">schemas/
├─ api/
├─ database/
│  ├─ ach_record/
│  │  ├─ ach_record_base_schema.py
│  │  ├─ ...
│  ├─ ach_file_schema.py
│  ├─ ...</pre>
</div>
</div>
<div class="readable-text" id="p52">
<p>With the updated structure, we are free to add our API responses. We can now continue with updating the API as we wanted. If you remember, we wanted to return a response with the file totals. Therefore, we created ach_files_response.py that contains the <code>AchFilesResponse</code>, as shown in the following listing. We also take the time to use more of Pydantic by providing documentation to the fields.</p>
</div>
<div class="browsable-container listing-container" id="p53">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.6<span class="CharOverride-7"> </span>The <code>AchFilesResponse</code> class</h5>
<div class="code-area-container">
<pre class="code-area">from decimal import Decimal
from datetime import datetime
from pydantic import BaseModel, UUID4, Field


class AchFilesResponse(BaseModel):
    id: UUID4 = Field(...,  #1
        description="Unique identifier for the ACH file", #2
        title="ID")  #3
    date: datetime = Field(...,
        description="The date and time the ACH file was uploaded.", 
        title="Date")
    filename: str = Field(...,
        title="Filename",
        description="The name of the file the ACH file was loaded from.",
        max_length=255, #4
    )
    credit_total: Decimal = Field(
        ...,
        description="The total amount of credit
<span class="CharOverride-10">➥</span> transactions in the ACH file.",
        ge=0, #5
        title="Credit Total",
    )
    debit_total: Decimal = Field(
        ...,
        description="The total amount of debit 
<span class="CharOverride-10">➥</span>transactions in the ACH file.",
        ge=0,
        title="Debit Total",
    )

    class Config:                              
        json_schema_extra = {                  
            "example": {                       
                "id": "123e4567-e89b-12d3-a456-426614174000", 
                "date": "2024-01-01T12:00:00",  
                "filename": "ACH_20240101_123.ach", 
                "creditTotal": "1000.00",
                "debitTotal": "5000.23",
            }
        }</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">By using Field from Pydantic, we can specify both constraints and documentation.</span>
<br/>#2 
     <span class="CharOverride-9">A description of our field shown as part of the API doc</span>
<br/>#3 
     <span class="CharOverride-9">A title for the field shown in our API doc</span>
<br/>#4 
     <span class="CharOverride-9">A constraint on the field; strings longer than max_length will cause validation errors.</span>
<br/>#5 
     <span class="CharOverride-9">Constrains the field to be ≥0</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p54">
<p>We have previously defined a simple query to return all the fields from the <code>ach_files</code> table, but now that we want to include the credit and debit totals in the response, we need to pull them from the parsed type 9 record. To work out the query, we can use CloudBeaver to run queries against our database and ensure the results are correct. Once we start pulling the required data, we can create a new method to return the data retrieved.</p>
</div>
<div class="browsable-container listing-container" id="p55">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.7<span class="CharOverride-7"> </span>Updating SQL query</h5>
<div class="code-area-container">
<pre class="code-area">def get_files_response(
    self, limit: Optional[int] = None, offset: Optional[int] = None
) -&gt; list[AchFilesResponse]:
    with get_db_connection(row_factory=dict_row) as conn:
        result = conn.execute(
            """
            SELECT af.ach_files_id AS id, #1
                   af.file_name AS filename,  #1
                   af.created_at AS date,  #1
                   afcr.total_debit_entry_dollar_amount AS debit_total,  #1
                   afcr.total_credit_entry_dollar_amount AS credit_total #1
            FROM ach_files AS af
            INNER JOIN ach_records_type_1 AS art1 USING (ach_files_id) #2
            INNER JOIN ach_records_type_9 AS art9 
               USING (ach_records_type_1_id)
            INNER JOIN ach_file_control_records AS afcr 
               USING (ach_records_type_9_id)
            ORDER BY af.created_at DESC  #3
            LIMIT %s  #4
            OFFSET %s   
            """,
            [limit, offset],
        )
        return result.fetchall()</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Fields are renamed to match the AchFilesResponse.</span>
<br/>#2 
     <span class="CharOverride-9">When joining tables on columns that are named the same in both tables, we can employ USING.</span>
<br/>#3 
     <span class="CharOverride-9">Sorts our results by the created_at date in descending order</span>
<br/>#4 
     <span class="CharOverride-9">Although not used at the moment, we can limit the results and allow for paging through them when we have large amounts of data.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p56">
<p>Finally, we update our route not only to call our new <code>get_files_response</code> but also to provide more documentation for our end-user, as shown in the following listing. This documentation step is important because it makes the API more accessible to nontechnical stakeholders, such as the QA department, who may be helping us with testing the APIs, or technical writers, who may be helping us with documentation. Furthermore, this change can benefit the API consumers who do not have the advantage of viewing the underlying code.</p>
</div>
<div class="browsable-container listing-container" id="p57">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.8<span class="CharOverride-7"> </span>Updated API route</h5>
<div class="code-area-container">
<pre class="code-area">@router.get( #1
    "",  #1
    response_model=list[AchFilesResponse],  #1
    summary="Retrieve Uploaded ACH Files",  #1
    description="Retrieve the details of an ACH #1
<span class="CharOverride-10">➥</span> file including credit/debit totals.",  #1
    response_description="The details of the #1
<span class="CharOverride-10">➥</span> requested ACH file.",  #1
)
async def read_files() -&gt; list[AchFilesResponse]:
    return AchFileSql().get_files_response()</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">We can use Pydantic again </span>
<span class="CharOverride-9">to document our fields.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p58">
<p>With this completed, we have a usable API with documentation. Figure 7.4 shows the results of some of the documentation we obtained using Pydantic. So, in addition to being able to assist us with data validation, parsing, and type safety, Pydantic also provides these documentation benefits.</p>
</div>
<div class="browsable-container figure-container" id="p59">
<img alt="A screenshot of a computer  Description automatically generated" height="245" src="../Images/CH07_F04_Kardell.png" style="width: 100%; max-width: max-content;" width="753"/>
<h5 class="figure-container-h5"><span class="">Figure 7.4</span><span class=""> </span><span class="">Our API now has documented fields and examples</span></h5>
</div>
<div class="readable-text" id="p60">
<p>We are almost there—just a few finishing touches on the UI side, and everything will be hooked together. </p>
</div>
<div class="readable-text intended-text" id="p61">
<p>In the RecentAchUploads.tsx, we named our interface <code>AchUploads</code>. We would prefer to name that something closer to what the API is returning. We also have a mapping problem where we have fields defined as <code>creditTotal</code>, but they are being returned as <code>credit_total</code> from the API. While Python uses <code>snake_case</code> for variable names, TypeScript prefers <code>camelCase</code>. So, we rename <code>AchUploads</code> to <code>AchFiles</code> and leave the fields as is. Then, we create a new interface—<code>AchFilesResponse</code>.</p>
</div>
<div class="browsable-container listing-container" id="p62">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.9<span class="CharOverride-7"> </span>The <code>AchFilesResponse </code>interface</h5>
<div class="code-area-container">
<pre class="code-area">interface AchFilesResponse {
    id: number;
    date: string;
    filename: string;
    credit_total: number;
    debit_total: number;
}</pre>
</div>
</div>
<div class="readable-text" id="p63">
<p>Next, we update the call to the <code>/files</code> endpoint in the component to transform the response from <code>AchFilesResponse</code> to <code>AchFiles</code>. We do so to maintain consistent naming standards for the language we are using. However, this can also yield another benefit—providing a level of abstraction between the UI and API. This benefit can be valuable if we change the vendor of our API (not likely in this case), or something unexpectedly changes within the API (where the API did not maintain backward compatibility, or unannounced changes were made). The following listing shows the updated <code>axios</code> call.</p>
</div>
<div class="browsable-container listing-container" id="p64">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.10<span class="CharOverride-7"> </span>Updated <code>axios</code> call</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">axios.get&lt;<strong>AchFilesResponse[]</strong>&gt;(`${apiUrl}/files`)
   .then(response =&gt; {
      console.log(`Response data
<span class="CharOverride-10">➥</span> ${JSON.stringify(response.data)}`); #1
      <strong>const transformedData: AchFiles[] =</strong>
<span class="CharOverride-10">➥</span><strong> response.data.map((row: AchFilesResponse) =&gt; ({  </strong>#2
<strong>         id: row.id,     </strong> #2
<strong>         date: row.date,  </strong> #2
<strong>         filename: row.filename, </strong> #2
<strong>         creditTotal: row.credit_total, </strong> #2
<strong>         debitTotal: row.debit_total</strong> #2
<strong>      }));</strong>
      setRows(transformedData);  #3
   })</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">A simple debug message to see the data coming back</span>
<br/>#2 
     <span class="CharOverride-9">For each object returned, maps the fields to their new names</span>
<br/>#3 
     <span class="CharOverride-9">Saves the response </span>
<span class="CharOverride-9">so we can use it</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p65">
<p>We should now have a valid response from the API and no longer see NaN for our fields when viewing the page (figure 7.5).</p>
</div>
<div class="browsable-container figure-container" id="p66">
<img alt="" height="136" src="../Images/CH07_F05_Kardell.png" style="width: 100%; max-width: max-content;" width="867"/>
<h5 class="figure-container-h5"><span class="">Figure 7.5</span><span class=""> </span><span class="">Updated component for Recent ACH Uploads</span></h5>
</div>
<div class="readable-text" id="p67">
<p>When securing the ability to upload files, we worked through a few problems and did some manual testing to ensure the data was being returned as expected. We also took an opportunity to ensure our APIs were expanded with documentation and constraints where appropriate. In the next section, we take some time to explore supplementing our manual testing with some additional automated testing.</p>
</div>
<div class="readable-text" id="p68">
<h3 class="readable-text-h3"><span class="num-string">7.3.1</span> Testing the API</h3>
</div>
<div class="readable-text" id="p69">
<p>Since at this point our API is working already, let’s take a look at how to incorporate some behavior-driven development (BDD) testing. Remember, this type of testing works best when the business, QA, and development all work together to create the testing scenarios. In our case, we are interested in creating a few scenarios that other groups may be able to use in their testing. We can create our features and scenarios as shown in listing 7.11. </p>
</div>
<div class="readable-text intended-text" id="p70">
<p>The benefit of these types of tests is that other departments can plug in file names, along with credit and debit amounts, to test a variety of files. We would treat these tests as first-class citizens, meaning they take the same priority as the production code. Therefore, requests to expand the testing functionality are handled the same as production bugs and enhancement requests. For example, the tests employed here only assess a small fraction of required scenarios. We should expect to see requests to get the total number of records processed or the number of batches, check for exceptions, and so on.</p>
</div>
<div class="browsable-container listing-container" id="p71">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.11<span class="CharOverride-7"> </span>BDD-style scenarios</h5>
<div class="code-area-container">
<pre class="code-area">Feature: The /files endpoint
  Test the functionality of the /files endpoint

  Scenario: I want to get a list that contains a single file
    Given that I have a clean database
    And that I have posted the file "sample.ach"
    When I request a list of files
    Then I should have a single file named "sample.ach"
    And it should have a total credit amount of "1146114.80"
    And it should have a total debit amount of "78.25"
    And there should be no exceptions

  Scenario: I want to get a list of files
    Given that I have a clean database
    And that I have posted the file "sample.ach"
    And that I have posted the file "sample1.ach"
    When I request a list of files
    Then I should have a file that includes the file "sample.ach"
    And I should have a file that includes the file "sample1.ach"
    And there should be no exceptions</pre>
</div>
</div>
<div class="readable-text" id="p72">
<p>For now, let’s see how to power these examples in Python code. Listing 7.12 shows some setups for these scenarios. We use the scenarios method to pull features we want to test (obviously, they should be making use of the grammar we have created). We define an instance of the <code>AchFileProcessor</code> because we are going to use it directly when parsing the file. We could have possibly gained some more functionality from using <code>POST</code> on the file, but since we are testing a single API, we did not necessarily want to muddy the water by relying on another API to work and parse the file. Note that even though we used <code>And</code> in the previous feature (e.g., <code>And</code> <code>that</code> <code>I</code> <code>have</code> <code>posted</code> <code>the</code> <code>file</code>), we use <code>Given</code> when annotating the method. This is because the <code>And</code> acts as syntactic sugar and will pick up the previous <code>Given/When/Then</code> clause. You will see that in play again when we look at the <code>Then</code> clauses.</p>
</div>
<div class="browsable-container listing-container" id="p73">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.12<span class="CharOverride-7"> </span>Python code for BDD</h5>
<div class="code-area-container">
<pre class="code-area">…
client = TestClient(app) #1

scenarios("../features/ach_files_endpoint.feature") #2

@pytest.fixture   #3
def ach_file_processor() -&gt; AchFileProcessor:  #3
    return AchFileProcessor() 

@pytest.fixture    #4
def api_response():  #4
    return {} 

<span>@given("that I have a clean database")  </span>#5
<span>def truncate_database():   </span> #5
<span>    </span>SqlUtils.truncate_all() 

@given(parsers.re(r'that I have posted the file#6
<span class="CharOverride-10">➥</span> "(?P&lt;ach_file&gt;.*)"'))  #6
def parse_the_given_file(ach_file):  #6
    dir_path = os.path.dirname(os.path.realpath #6
<span class="CharOverride-10">➥</span>(__file__))  #6
    file_path = os.path.join(dir_path, "../data", #6
<span class="CharOverride-10">➥</span> ach_file)  #6
    parser = AchFileProcessor()  #6
    ach_files_id = SqlUtils.create_ach_file_record(ach_file,
<span class="CharOverride-10">➥</span> str(randint(1, 99999999))) #7
    parser.parse(ach_files_id, file_path) 
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Imported from starlette.testclient, the TestClient is needed for making HTTP requests.</span>
<br/>#2 
     <span class="CharOverride-9">Loads scenarios associated with these step definitions</span>
<br/>#3 
     <span class="CharOverride-9">Creates the AchFileProcessor as a pytest.fixture; we can use it as needed.</span>
<br/>#4 
     <span class="CharOverride-9">api_response provides a </span>
<span class="CharOverride-9">way for us to store our results between steps.</span>
<br/>#5 
     <span class="CharOverride-9">This @given statement employs our SQL utility to clear all tables.</span>
<br/>#6 
     <span class="CharOverride-9">Here we take the desired filename from disk and parse it.</span>
<br/>#7 
     <span class="CharOverride-9">To maintain our database integrity, we need to create an ach_file_record and use it as a reference in the parse routine.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p74">
<p>In the following listing, we execute the API and save the response. The response will be needed later when checking it against the conditions we defined with <code>Then</code>.</p>
</div>
<div class="browsable-container listing-container" id="p75">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.13<span class="CharOverride-7"> </span><code>When</code> BDD code</h5>
<div class="code-area-container">
<pre class="code-area">…
@when("I request a list of files") #1
<span>def request_files(api_response):  </span>#2
<span>    response = client.get(</span><span>"</span><span>/api/v1/files") </span>#3
<span>    assert response.status_code == 200, response.text </span>#4
<span>    </span>print(response.json()) #5
    api_response["response"] = response.json() #6
…</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">No need to do anything special for hardcoded strings</span>
<br/>#2 
     <span class="CharOverride-9">We include the </span>
<span class="CharOverride-9">api_response fixture to store our results.</span>
<br/>#3 
     <span class="CharOverride-9">The client is used</span>
<span class="CharOverride-9">to retrieve the data </span>
<span class="CharOverride-9">from the endpoint.</span>
<br/>#4 
     <span class="CharOverride-9">We assert that we received a normal response code.</span>
<br/>#5 
     <span class="CharOverride-9">Prints the JSON response just for a sanity check</span>
<br/>#6 
     <span class="CharOverride-9">Stores the response to be used when we evaluate our @then statements</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p76">
<p>Finally, we can see our defined <code>Then</code> conditions, which validates our testing. We use a mixture of parsers depending on the situation. For the amounts, it is possible to use the <code>parsers.parse</code>. For more complicated tasks (such as parsing the filename), we can use <code>parsers.re</code>, which supports regular expressions. However, we generally recommend keeping things simple. </p>
</div>
<div class="readable-text intended-text" id="p77">
<p>All of these methods use simple <code>assert</code> statements to accomplish the needed validation. The following listing shows how to confirm the filename was returned by looking at all the fields in the API response to find a field named <code>filename</code> and then ensure (<code>assert</code>) it matches the <code>filename</code> specified in the BDD test.</p>
</div>
<div class="browsable-container listing-container" id="p78">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.14<span class="CharOverride-7"> </span><code>Then</code> BDD code</h5>
<div class="code-area-container">
<pre class="code-area">@then(parsers.re('I should have a file that
<span class="CharOverride-10">➥</span> includes the file "(?P&lt;filename&gt;.*)"')) #1
def then_file_check(filename, api_response): #2
    assert any( 
        response["filename"] == filename for response  #3
            in api_response["response"]  #3
    ), (f"Expected {filename} in"  #3
<span class="CharOverride-10">➥</span>f" {api_response['response']}")  #3
 #3
@then(parsers.parse('it should have a total credit
<span class="CharOverride-10">➥</span> amount of "{credit_amount}"')) #4
def then_total_credit(credit_amount, api_response): #5
    response = api_response["response"][0]
<span class="CharOverride-10">➥</span>["credit_total"] #6
    assert credit_amount == response, f"Expected
<span class="CharOverride-10">➥</span> {credit_amount} in {response}" #7</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Using a regular expression to extract the filename</span>
<br/>#2 
     <span class="CharOverride-9">The filename we extracted and the pytest fixture are parameters.</span>
<br/>#3 
     <span class="CharOverride-9">Checks whether the desired filename is in the array</span>
<br/>#4 
     <span class="CharOverride-9">An example of using parse to get the credit_amount</span>
<br/>#5 
     <span class="CharOverride-9">The credit_amount and pytest fixture are parameters.</span>
<br/>#6 
     <span class="CharOverride-9">Gets credit_total for the first and only file in the response</span>
<br/>#7 
     <span class="CharOverride-9">Ensures the credit total from the response matches the expected amount</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p79">
<p>You should now have a better idea of how to incorporate this type of testing into your projects. Giving everyone the ability to contribute to testing will not necessarily make it more fun, but it will certainly help improve the robustness of our test suite. It takes little knowledge about the inner workings of testing and allows testers to focus on creating tests in a natural way.</p>
</div>
<div class="readable-text intended-text" id="p80">
<p>At this point, the<code> /files </code>APIs for the MVP are completed, and we move on to building other required APIs in the next section.</p>
</div>
<div class="readable-text" id="p81">
<h2 class="readable-text-h2"><span class="num-string">7.4</span> ACH batches APIs</h2>
</div>
<div class="readable-text" id="p82">
<p>When we built the UI, we also created an API to retrieve batch information for a particular file. However, that endpoint was not something we created during our initial research on FastAPI. Instead, we found a need for it when performing our UI research and building the data with WireMock. This is something that we find in projects often—we need multiple perspectives to obtain a successful result. From subject matter experts to developers completing the work, everyone has different priorities and perspectives on how to complete a project. At this point, we want to investigate how to build an API to retrieve that data.</p>
</div>
<div class="readable-text" id="p83">
<h3 class="readable-text-h3"><span class="num-string">7.4.1</span> Adding the /files/id/batches API</h3>
</div>
<div class="readable-text" id="p84">
<p>With our <code>/files</code> API, we took an opportunity to revisit the BDD-type syntax for testing our API because the API has already been built. Here, we start with some tests to illustrate the TDD approach (albeit, a somewhat loose approach). First, we build a simple test class.</p>
</div>
<div class="browsable-container listing-container" id="p85">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.15<span class="CharOverride-7"> </span>Test class for the <code>/files/id/batches</code></h5>
<div class="code-area-container">
<pre class="code-area">class TestAchBatchesApi:
    client: TestClient = TestClient(app) #1
    ach_files_id: Optional[str] = None

    def setup_method(self, method: Callable) -&gt; None:
        ach_file = "../data/sample.ach" #2
        SqlUtils.truncate_all()  #2
        self.ach_files_id = SqlUtils.create_ach_file_record(  #2
            ach_file, str(randint(1, 99999999))  #2
        )  #2
        AchFileProcessor().parse(self.ach_files_id, #2
<span class="CharOverride-10">➥</span> "data/sample.ach")  #2

    def test_get_batches_api(self):  #3
        response =   self.client.get("/api/v1/files/{self. #3
<span class="CharOverride-10">➥</span>ach_files_id}/batches")  #3
        <span>assert response.status_code == 200,</span> #3
<span class="CharOverride-10">➥</span><span> response.text</span> #3

<span>    </span>def teardown_method(self, method: Callable)#4
<span class="CharOverride-10">➥</span> -&gt; None:  #4
        print(f"\nTeardown for {method.__name__} #4
<span class="CharOverride-10">➥</span> test method execution") </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Defines the test client and a variable to hold the file_id</span>
<br/>#2 
     <span class="CharOverride-9">This setup method parses the given ACH file, and the database should be ready.</span>
<br/>#3 
     <span class="CharOverride-9">At this point, we are simply looking to ensure we get a valid response from the API.</span>
<br/>#4 
     <span class="CharOverride-9">For completeness’ sake, this method executes after the test is run.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p86">
<p>Can you guess what the status code will be? The answer is a <code>404</code>, because we have not built the API yet. Running into <code>404</code> <code>errors</code> is typical during a development cycle where we may not have endpoints defined (as is the case here), or systems are in flux (perhaps another team changed their endpoint, or the machine is temporarily offline). The point is that during development, <code>404</code> <code>errors</code> are somewhat innocuous but are a lot more concerning in production, when something that was supposed to be there is not.</p>
</div>
<div class="readable-text intended-text" id="p87">
<p>In our case, it should be simple to define the endpoint in our files.py and return a hardcoded string. The following listing shows the results of that minimal code.</p>
</div>
<div class="browsable-container listing-container" id="p88">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.16<span class="CharOverride-7"> </span>Defining the <code>/files/id/batches</code> endpoint </h5>
<div class="code-area-container">
<pre class="code-area">@router.get("/{file_id}/batches")
async def read_batches_from_file(file_id: UUID) -&gt; str:  #1
    return f"File {file_id} batches"  </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">A simple method to return a string confirming we received the file_id</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p89">
<p>With that, we can rerun our test and should be receiving a <code>200</code>-response code. We can now venture on and build the rest of the code. Since the other endpoints make use of our <code>AchFileSql</code> class, we can add another method called <code>get_batches</code>, as shown in the following listing. Adding another method helps keep our code focused on the task at hand, which provides better maintainability and scalability going forward. Compare this to an approach where maybe we have one massive SQL query to gather all the data we could ever want about our SQL file every time, even though we only needed a tiny fragment of the data.</p>
</div>
<div class="browsable-container listing-container" id="p90">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.17<span class="CharOverride-7"> </span>Updating our endpoint to call <code>get_batches</code></h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">@router.get("/{file_id}/batches")
async def read_batches_from_file(file_id: UUID) -&gt; <strong>list[AchBatchesResponse]</strong>:  #1
    return <strong>AchFileSql().get_batches(file_id)</strong> #2</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Updates the return </span>
<span class="CharOverride-9">from a string to an AchBatchesResponse (which we have not created yet)</span>
<br/>#2 
     <span class="CharOverride-9">Calls the method to get batches based on our file_id</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p91">
<p>Next, we create the <code>AchBatchesResponse</code>. When we create this layout, we will also need to review the database tables associated with this data. Namely, the ACH catch control record (type 5). When building this response, we can take a look at the ACH batch control record layout and see how a correct file should be formatted. This obviously affects how we build the <code>AchBatchesResponse</code> class.</p>
</div>
<div class="browsable-container listing-container" id="p92">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.18<span class="CharOverride-7"> </span>The <code>AchBatchesResponse</code></h5>
<div class="code-area-container">
<pre class="code-area">from decimal import Decimal
from pydantic import BaseModel, UUID4, Field


class AchBatchesResponse(BaseModel): #1
    id: UUID4 = Field(
        ..., 
        description="Unique identifier for the ACH batch",
        title="ID"
    )
    company_name: str = Field(
        None, 
        description="The name of the company.",
        title="Company Name"
    )
    batch_number: int = Field( #2
        ...,  #2
        title="Batch Number",  #2
        description="The number associated with the batch.",  #2
        ge=0,  #2
    )  #2
    credit_total: Decimal = Field( #3
        ...,  #3
        description="The total amount of credit #3
<span class="CharOverride-10">➥</span> transactions in the ACH batch.",  #3
        title="Credit Total",  #3
    )  #3
    debit_total: Decimal = Field(
        ...,
        description="The total amount of debit
<span class="CharOverride-10">➥</span> transactions in the ACH batch.",
        title="Debit Total",
    )
    entry_addenda_count: int = Field(
        ...,
        description="The number of addenda records in the ACH batch.",
        title="Entry Addenda Count",
        ge=0,
    )

    class Config:
        json_schema_extra = {
            "example": {
                "id": "123e4567-e89b-12d3-a456-426614174000",
                "company_name": "Company Name",
                "batch_number": 1, #4
                "credit_total": "100.00",  #4
                "debit_total": "100.00",  #4
                "entry_addenda_count": 2,  #4
            }
        }</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Creates a class inheriting from the BaseModel provided by Pydantic</span>
<br/>#2 
     <span class="CharOverride-9">Creates fields as necessary using integers where appropriate</span>
<br/>#3 
     <span class="CharOverride-9">Creates decimal fields for monetary values</span>
<br/>#4 
     <span class="CharOverride-9">Updates our example accordingly; notice the monetary values are maintained as strings to avoid floating point errors.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p93">
<p>As shown in the following listing, there is a need to update the record description to better align with both the <code>AchBatchesResponse</code> from listing 7.18 and with the ACH record layout in general.</p>
</div>
<div class="browsable-container listing-container" id="p94">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.19<span class="CharOverride-7"> </span>Updated batch control SQL table </h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">CREATE TABLE ach_batch_control_records (
    ach_records_type_8_id UUID UNIQUE NOT
<span class="CharOverride-10">➥</span> NULL REFERENCES ach_records_type_8(ach_records_type_8_id)
<span class="CharOverride-10">➥</span> ON DELETE CASCADE ON UPDATE CASCADE,
    record_type_code VARCHAR(1) NOT NULL,
    service_class_code NUMERIC(3) NOT NULL,
<strong>    entry_addenda_count NUMERIC(6) NOT NULL,</strong> #1
<strong>    entry_hash NUMERIC(10) NOT NULL, </strong> #1
<strong>    total_debit_entry_dollar_amount NUMERIC(12,2) NOT NULL, </strong> #1
<strong>    total_credit_entry_dollar_amount NUMERIC(12,2) NOT NULL, </strong> #1
    company_identification VARCHAR(10) NOT NULL,
    message_authentication_code VARCHAR(19) NOT NULL,
    reserved VARCHAR(6) NOT NULL,
    originating_dfi_identification VARCHAR(8) NOT NULL,
<strong>    batch_number NUMERIC(7) NOT NULL</strong> #A
<strong>);</strong></pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Updates the table to support </span>
<span class="CharOverride-9">the numeric values</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p95">
<p>Figure 7.6 shows a trimmed-down version of the OpenAPI documentation reflecting these updates.</p>
</div>
<div class="browsable-container figure-container" id="p96">
<img alt="A screenshot of a computer  Description automatically generated" height="357" src="../Images/CH07_F06_Kardell.png" style="width: 100%; max-width: max-content;" width="803"/>
<h5 class="figure-container-h5"><span class="">Figure 7.6</span><span class=""> </span><span class="">OpenAPI documentation for retrieving ACH batches</span></h5>
</div>
<div class="readable-text" id="p97">
<p>Remember, this page not only provides a great way to document our APIs but also to test and validate them. We can use this web page to <code>POST</code> an ACH file, <code>GET</code> the list of files, and then <code>GET</code> the batches. While we have already implemented unit tests to validate the APIs, this is a great way to do some more integration and manual testing of our APIs. After loading our standard sample.ach file, we should see data being returned, as in the following listing. It is worth noting again that having sample data as defined in our sample.ach file is beneficial for many reasons. Sample data can help us test edge cases and allows more robust test scenarios. Another important benefit is that it is <em>test</em> data—we are not worried about exposing nonpublic information (NPI) or personally identifiable information (PII). </p>
</div>
<div class="browsable-container listing-container" id="p98">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.20<span class="CharOverride-7"> </span>Sample batch data being returned</h5>
<div class="code-area-container">
<pre class="code-area">[
  {
    "id": "e89511cc-9791-4318-b3b7-76406c191442",
    "company_name": "",
    "batch_number": 4,
    "credit_total": "114609873.00",
    "debit_total": "0.00",
    "entry_addenda_count": 32
  },
  {
    "id": "92ece8a1-e9b8-4bf6-b3df-416d7efa2909",
    "company_name": "CCD coname",
    "batch_number": 2,
    "credit_total": "201.00",
    "debit_total": "404.00",
    "entry_addenda_count": 6
  },
…</pre>
</div>
</div>
<div class="readable-text" id="p99">
<p>It is important to note that the changes to the database allow us to rely on the database (which is our source of truth) and not necessarily the business rules we defined in Python with Pydantic. We will find this helpful as our project grows, and the carefully laid out business rules that we have in one module are bypassed when another project chooses to use its own path. Both code and technical reviews are needed to ensure that, for example, the requirement that all code must access the database through a particular module will be met.</p>
</div>
<div class="readable-text intended-text" id="p100">
<p>Tools such as <code>pylint</code> allow us to build a plugin that can be used to detect these situations. While perhaps a bit beyond the scope of the book, we would like to refer you to listing 7.21, which provides the basics of a plugin that looks for imports with <code>psycopg</code>. While this is not comprehensive detection, hopefully, it will fire our imagination and give us something to dive into and research further uses of this type of technique. While code and technical reviews are extremely useful, it is nice to have guardrails that can keep us on track before we get to a final code review, only to find out we need to rework something. For more information on creating a <code>pylint</code> plugin, visit <a href="https://mng.bz/MDjn"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/mng.bz/MDjn</span></a>. </p>
</div>
<div class="browsable-container listing-container" id="p101">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.21<span class="CharOverride-7"> </span>A simple <code>pylint</code> plugin to detect <code>psycopg</code> use</h5>
<div class="code-area-container">
<pre class="code-area">import os #1
from typing import TYPE_CHECKING #1
import pdb #1
from pylint.checkers import BaseChecker #1

ALLOWED_MODULES = ["ach_file_sql"] #2
ALLOWED_DIRECTORIES = ["ach_processor/database"] 

if TYPE_CHECKING:
    from pylint.lint import PyLinter

class PsycopgImportChecker(BaseChecker):

    name = "psycopg-import-checker" #3
    msgs = {  #3
        "E9999": ( #3
            "psycopg usage only allowed in specific modules",  #3
            "psycopg-disallowed-import",  #3
            "Used when psycopg is imported outside #3
<span class="CharOverride-10">➥</span> designated modules.",  #3
        ),  #3
    }  #3
    options = () #3

    def visit_import(self, node): #4
        if any(modname == "psycopg" for #4
<span class="CharOverride-10">➥</span> modname, _ in node.names):  #4
            self._check_psycopg_usage(node)  #4
        elif any(modname.startswith("psycopg") #4
<span class="CharOverride-10">➥</span> for modname, _ in node.names):  #4
            self._check_psycopg_usage(node)  #4
 #4
    def visit_importfrom(self, node):  #4
        if node.modname.startswith("psycopg"):  #4
            self._check_psycopg_usage(node)  #4
 #4
    def _check_psycopg_usage(self, node): #5
        module_name = node.root().name #5
        module_file = node.root().file #5
        if module_name in ALLOWED_MODULES:  #5
            return  # Allow usage in specific modules #5
 #5
        for allowed_dir in ALLOWED_DIRECTORIES:  #5
            # Ensure paths are absolute or relative to #5
<span class="CharOverride-10">➥</span> the project root #5
            allowed_path = os.path.normpath(allowed_dir)  #5
            module_path = os.path.normpath(module_file)  #5
            if allowed_path in module_path:  #5
                return #5
 #5
        self.add_message("psycopg-disallowed-import",
<span class="CharOverride-10">➥</span> node=node) #6

<span>def register(linter): </span>#7
<span>    linter.register_checker</span> #7
<span class="CharOverride-10">➥</span>(PsycopgImportChecker(linter))   #7</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">The necessary </span>
<span class="CharOverride-9">imports for our plugin</span>
<br/>#2 
     <span class="CharOverride-9">Defines either modules that we allow psycopg to be referenced from or entire directories</span>
<br/>#3 
     <span class="CharOverride-9">Defines the pylint error that we will produce</span>
<br/>#4 
     <span class="CharOverride-9">Methods executed when “import” and “import from” statements are encountered; here, they call our _check_psycopg_usage method.</span>
<br/>#5 
     <span class="CharOverride-9">A method that gets the name and file we are working in and checks whether it has been whitelisted (found in ALLOWED_MODULES or ALLOWED_DIRECTORIES)</span>
<br/>#6 
     <span class="CharOverride-9">Adds the error message If the method is not found</span>
<br/>#7 
     <span class="CharOverride-9">Registers our module</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p102">
<p>While not strictly necessary for our project, a mantra of “Hey, I can automate that” can help your growth as a developer. Integrating this check with <code>pylint</code> ensures we can prevent the misuse of the module (in terms of where it is imported) throughout our code base.</p>
</div>
<div class="readable-text intended-text" id="p103">
<p>With that, we are ready to switch gears and move over to the UI side to ensure we can access our endpoint.</p>
</div>
<div class="readable-text" id="p104">
<h3 class="readable-text-h3"><span class="num-string">7.4.2</span> Supporting ACH batches in the dashboard</h3>
</div>
<div class="readable-text" id="p105">
<p>Now that we have an API capable of returning ACH batches, we can integrate it into our UI. Remember, when mocking out the API, we created a data structure similar to what is presented in the following listing. However, now that we actually have the data being returned, we need to update the UI to accommodate the new format. Note that if you were to start the UI, upload a file, and try to drill down into it, because of these format changes, you would receive an error message similar to <code>TypeError:</code> <code>Cannot</code> <code>read</code> <code>properties</code> <code>of</code> <code>undefined</code> <code>(reading</code> <code>'map')</code> on the <code>batches.map</code> statement. We will resolve that problem in this section.</p>
</div>
<div class="browsable-container listing-container" id="p106">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.22<span class="CharOverride-7"> </span>Format for batch information</h5>
<div class="code-area-container">
<pre class="code-area">{
   "batches" : [
       {
          "companyName": "example name",
          "companyBatches": [
             {
                "batchId": "value"
                "batchNumber": "value"
                "recordCount": "value"
                "totalDebitAmount": "value"
                "totalCreditAmount": "value"
             }
          ] 
        }
}</pre>
</div>
</div>
<div class="readable-text" id="p107">
<p>While we could have returned the data the same way we mocked it up, it may make our lives easier to return a simpler structure from our API that could then be manipulated with the results. This is all part of putting an MVP together. We have not invested too much into the solution, and it is not too late to adjust the game plan. A bit of rework early on can ensure we stay on the right path and prevent headaches down the road. </p>
</div>
<div class="readable-text intended-text" id="p108">
<p>Our choice of SQL, Python, or TypeScript will likely not matter to the end-user. For now, we opt for the simple SQL query, and format the data on the UI side. We update our interfaces to have one dedicated to the API response, and we use the rest throughout the code.</p>
</div>
<div class="browsable-container listing-container" id="p109">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.23<span class="CharOverride-7"> </span>Updating interfaces for ACH batches</h5>
<div class="code-area-container">
<pre class="code-area">export interface AchCompanyBatchInfo { #1
    companyName: string; 
    companyBatches: AchBatchInfo[]; 
} 

export interface AchBatchInfo { 
    id: string; 
    batchNumber: number; 
    debitTotal: Decimal; #2
    creditTotal: Decimal; 
    recordCount: number; 
} 

export interface AchBatchInfoResponse { #3
    id: string;  #3
    company_name: string;  #3
    batch_number: number;  #3
    debit_total: string;  #3
    credit_total: string;  #3
    entry_addenda_count: number;  #3
}  #3</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">The ACH batch info interface that we will use throughout the UI</span>
<br/>#2 
     <span class="CharOverride-9">The ACH batch info interface that we will use throughout the UI</span>
<br/>#3 
     <span class="CharOverride-9">The response from the API that we will rework</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p110">
<p>We also need to add the code that will condense the response into the <code>AchCompanyBatchInfo</code>, which mimics our original structure. As shown in the following listing, we organize our records by company name, creating an array of batches for each company.</p>
</div>
<div class="browsable-container listing-container" id="p111">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.24<span class="CharOverride-7"> </span>Transforming the code into the desired structure</h5>
<div class="code-area-container">
<pre class="code-area">function createAchCompanyBatchInfoRecords
<span class="CharOverride-10">➥</span>(response: AchBatchInfoResponse[]): AchCompanyBatchInfo[] {
    const condensedRecords: Record&lt;string,
<span class="CharOverride-10">➥</span> AchCompanyBatchInfo&gt; = {}; #1

    response.forEach((record: AchBatchInfoResponse) =&gt; {
        if (!condensedRecords[record.company_id]) { #2
            condensedRecords[record.company_id] = {  #2
                companyId: record.company_id,  #2
                companyBatches: []  #2
            };  #2
        }  #2

        condensedRecords[record.company_name]
<span class="CharOverride-10">➥</span>.companyBatches.push({ #3
            id: record.id,  #3
        companyId: record.company_id,  #3
            companyName: record.company_name,  #3
            batchNumber: record.batch_number,  #3
            debitTotal: new Decimal(record.debit_total),  #3
            creditTotal: new Decimal(record.credit_total),  #3
            recordCount: record.entry_addenda_count,  #3
        });  #3
    });

    return Object.values(condensedRecords);</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Defines a simple Record object to hold our condensed records by </span>
<span class="CharOverride-9">Company ID</span>
<br/>#2 
     <span class="CharOverride-9">Checks whether we have </span>
<span class="CharOverride-9">an entry with the key of company_id; if not, it creates one with an empty array for companyBatches.</span>
<br/>#3 
     <span class="CharOverride-9">Adds the batch information for the company</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p112">
<p>Our logic for the scatterplot we created remains largely the same with just an update to the names of the interfaces and a couple of minor tweaks. Preserving consistency in naming helps with code maintenance and readability, especially as other developers may make enhancements. The most important change we need to keep in mind is that now that we are using <code>Decimal</code>, we have to update the way in which we create our field <code>totalCreditAndDebits</code>. As shown in the following listing, we need to call the <code>add</code> method instead of using the standard <code>+</code> (plus) operator.</p>
</div>
<div class="browsable-container listing-container" id="p113">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.25<span class="CharOverride-7"> </span>Updating the computation for <code>totalCreditAndDebits</code></h5>
<div class="code-area-container">
<pre class="code-area">totalCreditAndDebits: companyBatch.creditTotal.add(companyBatch.debitTotal)</pre>
</div>
</div>
<div class="readable-text" id="p114">
<h3 class="readable-text-h3"><span class="num-string">7.4.3</span> Uploading files</h3>
</div>
<div class="readable-text" id="p115">
<p>So far, we have been using our API documentation to upload files. The final functionality that we want to look at is being able to upload from our dashboard. We have already built the UI capable of dragging a file into the browser and obtaining the file name. We also had a button that did not do anything when clicked. Now we will provide code that opens a window where the user can select a file to upload.</p>
</div>
<div class="readable-text intended-text" id="p116">
<p>We know there will be at least two paths to uploading a file—dropping a file into the browser and clicking the upload button—which means we need to create a function to handle the uploads. If we can centralize the function, it will prevent duplicating code and maintenance in the future</p>
</div>
<div class="browsable-container listing-container" id="p117">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.26<span class="CharOverride-7"> </span>The<code> uploadFile</code> function</h5>
<div class="code-area-container">
<pre class="code-area">…
    const [isLoading, setIsLoading] = 
<span class="CharOverride-10">➥</span>useState&lt;boolean&gt;(false); #1
…
    const uploadFile = (file: File) =&gt; {
        const formData = new FormData(); #2
        formData.append('file', file); 

        const apiUrl = process.env.NEXT_PUBLIC_API_URL ?? ''; #3
        setIsLoading(true); #4
        axios.post(`${apiUrl}/files`, formData, { #5
            headers: {  #6
                'Content-Type': 'multipart/form-data',  #6
            },  #6
        })  #6
            .then((response) =&gt; { 
                console.log('File uploaded successfully', response); 
            }) 
            .catch((error) =&gt; { 
                console.error('Error uploading file', error); 
            }).finally(() =&gt; { #8
            setIsLoading(false);  #9
            route.replace('/');  #9
        });
    }</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Defines a state to track whether the file is loading</span>
<br/>#2 
     <span class="CharOverride-9">Gets the file from the form</span>
<br/>#3 
     <span class="CharOverride-9">Uses our URL</span>
<br/>#4 
     <span class="CharOverride-9">Sets loading to true so that we can update the page to display an activity indicator</span>
<br/>#5 
     <span class="CharOverride-9"> Sends a post request with our file to the endpoint</span>
<br/>#8 
     <span class="CharOverride-9">When the file is uploaded, sets loading back to false and immediately goes back to the dashboard</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p118">
<p>This feature allows us to easily update the previous code we had for <code>handleDrop</code> when a user drops in the file. As soon as the file is dropped, we call <code>uploadFile</code> with the file, and when the file is uploaded, we will route the user back to the dashboard. In this simple case, the dashboard will be automatically updated with the new file. However, we have the following limitations:</p>
</div>
<ul>
<li class="readable-text" id="p119">We only upload one file, although a user could conceivably pick more.</li>
<li class="readable-text" id="p120">We assume the file was loaded successfully. </li>
</ul>
<div class="readable-text" id="p121">
<p>Either way, we do not necessarily provide any feedback to our users. We won’t focus on these problems because we are working on an MVP, and we do not need to have all the bells and whistles, except in a finished production-ready product. While it may be tempting to add this functionality, we want to avoid scope creep (when our project goes beyond the original requirements), which can cause delays in rolling out the product. For now, let’s add the call to our <code>handleDrop</code> function.</p>
</div>
<div class="browsable-container listing-container" id="p122">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.27<span class="CharOverride-7"> </span>The <code>handleDrop</code> function</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">    const handleDrop = useCallback((event:
<span class="CharOverride-10">➥</span> DragEvent&lt;HTMLDivElement&gt;) =&gt; {
…
        if (files.length &gt; 0 &amp;&amp; files[0].name !== <span>'') {</span>
<span>            console.log(files);</span>
<span>            setFileInfo(files[0]);</span>
<strong>            </strong><strong>uploadFile(files[0]); </strong>#1
        }

    }, []);</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Updates the handleDrop code to call our routine to upload the file</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p123">
<p>We also call this code from the button click as well, which takes a little more work.</p>
</div>
<div class="browsable-container listing-container" id="p124">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.28<span class="CharOverride-7"> </span>Uploading files with our button</h5>
<div class="code-area-container">
<pre class="code-area">…
    const fileInputRef = useRef&lt;HTMLInputElement&gt;
<span class="CharOverride-10">➥</span>(null); #1
…
const handleFileChange = (event: 
<span class="CharOverride-10">➥</span>ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
        if (event.target.files &amp;&amp; 
<span class="CharOverride-10">➥</span>event.target.files.length &gt; 0) { #2
            const file = event.target.files[0];  #2
            console.log(file);  #2
            uploadFile(file);  #2
        }
    };
…
    const handleButtonClick = () =&gt; {
        fileInputRef.current?.click(); #3
    };
…
         {isLoading ? &lt;CircularProgress/&gt; : &lt;Typography
             variant="h6"&gt;
                {fileInfo?.name ? 
<span class="CharOverride-10">➥</span>fileInfo.name : 'Drag and drop files here'} 
             &lt;/Typography&gt;}
…
    &lt;Button onClick={handleButtonClick}
            startIcon={&lt;CloudUpload/&gt;}&gt;
       Upload
    &lt;/Button&gt;
    &lt;input
       type="file"
       ref={fileInputRef}
       onChange={handleFileChange} #4
       style={{display: 'none'}}
    /&gt;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Defines a reference to an HTMLInputElement, which allows us to interact with the element in our code</span>
<br/>#2 
     <span class="CharOverride-9">Handling of the </span>
<span class="CharOverride-9">file changing</span>
<br/>#3 
     <span class="CharOverride-9">Executes the click event, which implements a click on </span>
<span class="CharOverride-9">the “input” HTML element, making the File Chooser open</span>
<br/>#4 
     <span class="CharOverride-9">Specifies our handleFileChange method when the input changes</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p125">
<p>With this code, we can now upload files through our dashboard.</p>
</div>
<div class="readable-text" id="p126">
<h2 class="readable-text-h2"><span class="num-string">7.5</span> Putting the puzzle together</h2>
</div>
<div class="readable-text" id="p127">
<p>We now have the MVP up and running in our IDE environment. The final step is to move everything into the Docker environment and ensure things work.</p>
</div>
<div class="readable-text intended-text" id="p128">
<p>From our previous preparations, we already know that all the pieces have been operating in Docker. This means we can use our previous Docker configuration with just a few tweaks, and we should be good to go.</p>
</div>
<div class="readable-text intended-text" id="p129">
<p>Figure 7.7 shows the Docker layout, with containers and ports labeled to give us the basic idea of our layout. CloudBeaver is not necessary in our MVP—we only include it in the setup so we can work with queries and explore the database. With our configuration, we can start Docker as usual, with <code>docker-compose</code> <code>down;</code> <code>docker-compose</code> <code>up --build</code>.</p>
</div>
<div class="readable-text" id="p130">
<h3 class="readable-text-h3"><span class="num-string">7.5.1</span> Cleaning up the configuration files</h3>
</div>
<div class="readable-text" id="p131">
<p>When we begin getting our code ready for a production environment (or Docker), some additional housekeeping will be required. First, we can take a look at main.py in the <code>app</code> folder. Here, we specified some CORS settings. The allowed origins are likely going to be the biggest problem, and we want to ensure that requests are coming from where we expect them (in this case, <code>localhost:4000</code>). We also limit our methods to those expected (<code>GET</code> and <code>POST</code>). We should not need to allow <code>OPTIONS</code>, which is sent by the browser as part of a Preflight CORS request, but keep in mind that different frameworks/versions may require it. </p>
</div>
<div class="browsable-container listing-container" id="p132">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.29<span class="CharOverride-7"> </span>Updates for CORS</h5>
<div class="code-area-container">
<pre class="code-area">origins = [
    "http://localhost:4000",  # For local development
    # "*" # Allow all, but not recommended for production
]
…
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["GET", "POST"],
    allow_headers=["*"],
)
…</pre>
</div>
</div>
<div class="browsable-container figure-container" id="p133">
<img alt="A diagram of a computer  Description automatically generated" height="664" src="../Images/CH07_F07_Kardell.png" style="width: 100%; max-width: max-content;" width="850"/>
<h5 class="figure-container-h5"><span class="">Figure 7.7</span><span class=""> </span><span class="">Docker setup for the ACH dashboard MVP</span></h5>
</div>
<div class="readable-text" id="p134">
<p>Another part of the Python configuration we may want to clean up is the requirements.txt. We have dependencies that are specific to our development, such as <code>pytest</code> and <code>pytest-bdd</code>. In our production code, there should be no reason to include these. Attackers cannot exploit dependencies that are not present, so it is important to keep unnecessary or unused requirements out of production. We create a dev-requirements<br/>.txt, which we can use for development environments as needed, and try to leave a requirements.txt that is production ready. If your IDE (or other tooling) maintains a requirements.txt, you may find it easier to do the reverse and keep a prod-requirements<br/>.txt. This way, you can move any requirements you install over there immediately and do not necessarily need to guess. The following listing shows an example of a dev<br/>-requirements.txt.</p>
</div>
<div class="browsable-container listing-container" id="p135">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.30<span class="CharOverride-7"> </span>A sample dev-requirements.txt file</h5>
<div class="code-area-container">
<pre class="code-area">-r requirements.txt
pytest==8.0.1
pytest-bdd==7.0.1
iniconfig==2.0.0
pluggy==1.4.0</pre>
</div>
</div>
<div class="readable-text" id="p136">
<p>We clean up the UI configuration files similarly by splitting tsconfig.json into tsconfig.dev.json and tsconfig.prod.json. This is because we do not need references to Jest and other development options such as <code>sourceMap</code> set in our production environment. The following listing shows how the tsconfig.prod.json has been updated to remove entries for Jest and expand to exclude any tests from the production build. We would not expect any tests to make it to the packaging steps, so excluding the *.test.ts and *.spec.ts files is mostly precautionary.</p>
</div>
<div class="browsable-container listing-container" id="p137">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.31<span class="CharOverride-7"> </span>Updating the tsconfig.prod.json file</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">{
  "compilerOptions": {
…
    "sourceMap": false,
    "types": [],
…
  "exclude": [<strong>"**/*.test.ts"</strong>,<strong> "**/*.spec.ts"</strong>, "node_modules"]
}</pre>
</div>
</div>
<div class="readable-text" id="p138">
<p>In addition to configuration files for the components, we also want to take a minute to ensure that the <code>NEXT_PUBLIC_API_URL</code> is pointing to the correct location. The following listing shows the configuration for the dashboard service from docker-compose.yml.</p>
</div>
<div class="browsable-container listing-container" id="p139">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.32<span class="CharOverride-7"> </span>Configuration for the dashboard service from docker-compose.yml</h5>
<div class="code-area-container code-area-with-html">
<pre class="code-area">  dashboard:
    build: 
      context: ./dashboard
      dockerfile: Dockerfile
      args:
<strong>        - NEXT_PUBLIC_API_URL=http://localhost:8000/api/v1</strong>
    ports:
      - 4000:3000</pre>
</div>
</div>
<div class="readable-text" id="p140">
<p>With that, we should be able to bring our project up in Docker.</p>
</div>
<div class="readable-text" id="p141">
<h3 class="readable-text-h3"><span class="num-string">7.5.2</span> Ensuring APIs are accessible</h3>
</div>
<div class="readable-text" id="p142">
<p>We can run the general check of our containers with <code>docker</code> <code>ps</code> <code>--format</code> <code>"table {{.Names}}\t{{.Status}}"</code> (we use the format option just for clarity; <code>docker-compose ps</code> will work as well, and it is shorter) and see that our containers are up and running.</p>
</div>
<div class="browsable-container listing-container" id="p143">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.33<span class="CharOverride-7"> </span>Containers up and running</h5>
<div class="code-area-container">
<pre class="code-area">NAMES                     STATUS
dockermvp-dashboard-1     Up 58 minutes#1
dockermvp-api-1           Up 58 minutes #1
dockermvp-cloudbeaver-1   Up 58 minutes #1
dockermvp-postgres-1      Up 58 minutes (healthy)  #1</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">The postgres container is the only showing as healthy because it is the only container we implemented a health check for.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p144">
<p>Now that everything is working, note that we only have a health check defined for Postgres, so we see that it is healthy, but the other containers have no health checks, so we do not see the <code>(healthy)</code> text. Since all our containers appear to be up and running, the next thing we do is navigate to http://localhost:8000/docs and verify our APIs are available (see figure 7.8).</p>
</div>
<div class="browsable-container figure-container" id="p145">
<img alt="A screenshot of a computer  Description automatically generated" height="414" src="../Images/CH07_F08_Kardell.png" style="width: 100%; max-width: max-content;" width="736"/>
<h5 class="figure-container-h5"><span class="">Figure 7.8</span><span class=""> </span><span class="">Our list of defined APIs</span></h5>
</div>
<div class="readable-text" id="p146">
<h3 class="readable-text-h3"><span class="num-string">7.5.3</span> Programming challenges</h3>
</div>
<div class="readable-text" id="p147">
<p>The process itself should hopefully be clear by now—we identify desired functionality, create an API to support it, backend code to enable it, and frontend code to consume and display it (figure 7.9)</p>
</div>
<div class="browsable-container figure-container" id="p148">
<img alt="A diagram of a data flow  Description automatically generated" height="169" src="../Images/CH07_F09_Kardell.png" style="width: 100%; max-width: max-content;" width="383"/>
<h5 class="figure-container-h5"><span class="">Figure 7.9</span><span class=""> </span><span class="">Process of adding functionality <br/>to our MVP</span></h5>
</div>
<div class="readable-text intended-text" id="p149">
<p>We still have several items to discuss in this chapter, but now is a good time to put out some challenges you could work on:</p>
</div>
<ul>
<li class="readable-text" id="p150"><em>Top files toda</em><em>y</em>—Provide a visualization of the largest files loaded today.</li>
<li class="readable-text" id="p151"><em>Today’s total</em><em>s</em>—Provide a component showing credit/debit totals for today.</li>
<li class="readable-text" id="p152"><em>Drill dow</em><em>n</em>—Allow the user to click a file, view batch information, and drill into the batch to see entries.</li>
<li class="readable-text" id="p153"><em>Transaction code breakdow</em><em>n</em>—When viewing the entries, provide a visualization of the breakdown of transaction codes (debits, credits, etc.) used.</li>
</ul>
<div class="readable-text" id="p154">
<h3 class="readable-text-h3"><span class="num-string">7.5.4</span> Exploring the dashboard</h3>
</div>
<div class="readable-text" id="p155">
<p>At this point, we should have all the components up and running in Docker, and we can navigate to the dashboard. This would be the time to click everything to ensure it functions as intended. Load some ACH files, and make sure you can view the files, batches, and the charts are working. Then take a minute to congratulate yourself—the MVP is just the start of our journey, but we put some effort into getting to this point. The pace of development and the timeline for projects is often frantic. It is important that we take the time to recognize our achievements, as well as those of our team.</p>
</div>
<div class="readable-text" id="p156">
<h2 class="readable-text-h2"><span class="num-string">7.6</span> Gotta have more files</h2>
</div>
<div class="readable-text" id="p157">
<p>During development, there will come a time when we get to a point where the ACH files provided by the business are inadequate for our testing. This may be because we have specific scenarios we want to test, or we need to slim down files so we can test simple scenarios to ensure our data is working. Since ACH files are just text files, nothing is stopping us from simply copying and opening them to make the necessary updates. Fortunately (or unfortunately), we are programmers, and we cannot bother with editing files manually (except in rare cases). We can use BDD-style testing to develop syntax and create files.</p>
</div>
<div class="readable-text intended-text" id="p158">
<p>Using Python and <code>pytest-bdd</code> to create our ACH files gives us not only a chance to work on our Python skills but also a chance to dive into ACH files and some of the requirements. By creating files programmatically and then turning around to load them into our dashboard, we are back to working in short development cycles. As we create and load files, we may find problems with the generation, loading/parsing, APIs, and UI. We can create an <code>ach_file_creation.feature</code> and generate a syntax for ACH file creation. The following listing shows a sample of the first test. Remember that chapters 2 and 5 reviewed some of the characteristics of ACH files. If you need additional information on required fields and other important information, refer to the ACH File Overview at <a href="https://achdevguide.nacha.org/ach-file-overview"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/achdevguide.nacha.org/ach-file-overview</span></a>.</p>
</div>
<div class="browsable-container listing-container" id="p159">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.34<span class="CharOverride-7"> </span>BDD-style ACH file creation</h5>
<div class="code-area-container">
<pre class="code-area">  Scenario: Create an ACH file with a single batch and a single debit
    Given I want to create an ACH file named "ppd-single-debit.ach"
    And I want to have an immediate destination of "123456789"
    And I want to have an immediate origin of "987654321"
    And I want to have 1 batch with ACH debits only
<span class="CharOverride-10">➥</span> and a standard entry class code of "PPD"
    And I want 1 entries per batch with random amounts between 100 and 100
    And I want to use individual names of "John Doe"
    And I want to have company name "My Company" and
<span class="CharOverride-10">➥</span> company id "1234567890"
    When my ACH is created
    Then I should have a file named "ppd-single-debit.ach"
    And there should be 1 batch in the file
    And there should be 1 entries in the file</pre>
</div>
</div>
<div class="readable-text" id="p160">
<p>This code gives us some flexibility in the number of batches and entries a file will contain, as well as amounts used. It does not necessarily reflect/enforce the correct business rules for producing ACH files. We simply took an existing file and began working backward to replace fields as we needed some flexibility in our file creation. The file exists as a “test” within our tests folder for our project, but it could very well be split out into its own project to become its own utility others will use. We’ll come back to this topic and work on it further as we continue with the project and find additional requirements.</p>
</div>
<div class="readable-text intended-text" id="p161">
<p>Most of the code for supporting the grammar is centered around collecting the necessary information. In listing 7.35, we set it so that we are only expecting debits, and therefore, we can also set the appropriate service class and transaction codes. We could have also allowed users to specify transaction codes and then determined which service class code to use or vice versa. We can always approach problems differently and need to weigh the tradeoffs. Keeping in mind that nontechnical users may want to use this feature, abstracting the details of a correct service class and transaction code seems to be a good choice. Of course, later, we may want to introduce files produced with an error condition to create various scenarios and therefore need to introduce finer-grained control.</p>
</div>
<div class="browsable-container listing-container" id="p162">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.35<span class="CharOverride-7"> </span>Sample for creating files</h5>
<div class="code-area-container">
<pre class="code-area">@given(
    parsers.re(
        r'I want to have (?P&lt;batch_count&gt;\d+)
<span class="CharOverride-10">➥</span> batch with ACH debits only and a standard entry
 class code of "(?P&lt;standard_entry_class&gt;.*)"'
    )
)
def set_number_of_debit_batches_to_create(
    setup_info, batch_count, standard_entry_class
):
    setup_info["batch_count"] = int(batch_count) #1
    setup_info["service_class_code"] = "225" #2
    setup_info["transaction_code"] = ["27"] 
    setup_info["standard_entry_class"] = standard_entry_class #3</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Gets the batch count, converts it to an integer, and stores it for later</span>
<br/>#2 
     <span class="CharOverride-9">We are working with debits only, so we set the fields accordingly.</span>
<br/>#3 
     <span class="CharOverride-9">Gets the standard_entry_class and saves it for later</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p163">
<p>Similarly, the validation routine is straightforward. In this case, we know that we have a set number of records, and therefore, we want to simply count the records that are type 6. We perform a similar check for the number of batches. Opening, reading the entire file, and closing the file each time may not be the most efficient way to do things but is certainly sufficient for now.</p>
</div>
<div class="browsable-container listing-container" id="p164">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.36<span class="CharOverride-7"> </span>Validating our entries</h5>
<div class="code-area-container">
<pre class="code-area">@then(parsers.parse("there should be
<span class="CharOverride-10">➥</span> {expected_entry_count:d} entries in the file"))
def validate_entry_count(setup_info, expected_entry_count):
    count = 0
    with open(f"../output/{setup_info['filename']}",
<span class="CharOverride-10">➥</span> "r", encoding="utf8") as f: #1
        for line in f: #2
            if line.startswith("6"):  #2
                count += 1
    assert (
        count == expected_entry_count
    ), f"Expected {expected_entry_count}, but got {count}" #3</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Opens the file for reading</span>
<br/>#2 
     <span class="CharOverride-9">Counts lines that </span>
<span class="CharOverride-9">are a type 6 record</span>
<br/>#3 
     <span class="CharOverride-9">Asserts that the count is correct by comparing it to what was expected</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p165">
<p>Finally, we show some of the work needed to create a record in the file. In the following listing, we format amounts and pad them as necessary before finally plugging them into the returned string.</p>
</div>
<div class="browsable-container listing-container" id="p166">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.37<span class="CharOverride-7"> </span>Creating a file</h5>
<div class="code-area-container">
<pre class="code-area">def create_file_control(setup_info, total_debits_in_file,
<span class="CharOverride-10">➥</span> total_credits_in_file):
    total_credits_in_file =
<span class="CharOverride-10">➥</span> str(total_credits_in_file).rjust(12, "0") #1
    total_debits_in_file = #1
<span class="CharOverride-10">➥</span> str(total_debits_in_file).rjust(12, "0")  #1
    batch_count = #1
<span class="CharOverride-10">➥</span> str(setup_info["batch_count"]).rjust(6, "0")  #1
    entry_count =
<span class="CharOverride-10">➥</span> str(setup_info["entry_count"] * 
<span class="CharOverride-10">➥</span>setup_info["batch_count"]).rjust(
        8, "0"
    )
    return return f"9{batch_count}000010{entry_count}0198019800
<span class="CharOverride-10">➥</span>{total_debits_in_file}{total_credits_in_file}".ljust(94," ")</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Fields are right justified with a max length and padded with zeroes.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p167">
<p>We may have invested more time in putting all this together, but we still believe these examples can improve our development skills and streamline our work later.</p>
</div>
<div class="readable-text" id="p168">
<h2 class="readable-text-h2"><span class="num-string">7.7</span> Adding a basic login page</h2>
</div>
<div class="readable-text" id="p169">
<p>The dashboard is a great way to get us accustomed to loading and visualizing ACH files. However, we do not want anyone to have access to the upload page. Whether the dashboard is available as a web interface to the outside world or is for internal use only, we still want to limit users who can work with files. Later, this may facilitate functionality such as alerts when a file is successfully loaded or rejected. In addition, an audit trail of someone who loaded a file or performed some meaningful activity to the file (such as deleting batches and their associated transactions) is important in case we have disgruntled or malicious users. </p>
</div>
<div class="readable-text intended-text" id="p170">
<p>Thus, this section covers adding a basic login page using NextAuth.js, which is an open source authentication solution for Next.js. While we will have hardcoded values, you can extend the solution to use other providers such as Auth0, Apple, and Google, to name just a few.</p>
</div>
<div class="readable-text intended-text" id="p171">
<p>We can set up the NextAuth.js with a few files and supporting code. We create <code>middleware.ts</code>, <code>auth.ts</code>, and <code>auth.config.ts</code>, which support the authentication.</p>
</div>
<div class="browsable-container listing-container" id="p172">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.38<span class="CharOverride-7"> </span>Setting up our middleware</h5>
<div class="code-area-container">
<pre class="code-area">export default NextAuth(authConfig).auth;

export const config = {
    matcher: ['/uploads'],
};</pre>
</div>
</div>
<div class="readable-text" id="p173">
<p>We provide basic configuration that supports callbacks for checking whether a user is authorized and redirecting them as necessary. </p>
</div>
<div class="browsable-container listing-container" id="p174">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.39<span class="CharOverride-7"> </span><code>Auth</code> callbacks</h5>
<div class="code-area-container">
<pre class="code-area">import type { NextAuthConfig } from 'next-auth';

export const authConfig = {
    debug: true,                         #1
    <span>pages: {                             </span>#2
<span>        signIn: '/login',                </span> #2
<span>    </span>},                                   
    callbacks: {
        authorized({ auth, request: { nextUrl } }) {
            const isLoggedIn = !!auth?.user;
            const isOnDashboard = 
               nextUrl.pathname.startsWith('/uploads'); #3
            if (isOnDashboard) {
                return isLoggedIn;
            } else if (isLoggedIn) {
                return Response.redirect(new URL('/login', nextUrl));
            }
            return true;
        },
        async redirect({ url, baseUrl }) {
            const queryParams = new URL(url).searchParams;  #4
            const callbackUrl = queryParams.get('callbackUrl');  #4
            if (callbackUrl) {  #4
                return callbackUrl;  #4
            } else {  #4
                return url.startsWith(baseUrl) ? url : baseUrl;  #4
            }  #4
        }
    },
    providers: [], #5
} satisfies NextAuthConfig;</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">We set debug to true while </span>
<span class="CharOverride-9">in development to view additional log messages.</span>
<br/>#2 
     <span class="CharOverride-9">Sets a custom sign-in page to override the unbranded default page; other pages that can be set are signOut, error, verifyRequest, and newUser.</span>
<br/>#3 
     <span class="CharOverride-9">Checks whether the path starts with /uploads</span>
<br/>#4 
     <span class="CharOverride-9">Redirects to the desired page if available</span>
<br/>#5 
     <span class="CharOverride-9">Providers are services that can be used to sign in a user.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p175">
<p>To power our login page, we use the credential provider in which we hardcode a couple of different users. The following listing shows how we parse the given credentials and compare them against our known values. Note that hardcoding the values for our username/passwords is never a good idea, but this example only shows the concept of adding authentication to the project.</p>
</div>
<div class="browsable-container listing-container" id="p176">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.40<span class="CharOverride-11"> </span><code>Auth</code> credentials configuration</h5>
<div class="code-area-container">
<pre class="code-area">import NextAuth from 'next-auth';
import Credentials from 'next-auth/providers/credentials';
import { z } from 'zod';
import { authConfig } from './auth.config';

const validUsers = [ #1
    { email: 'admin@futuristicfintech.com', password: 'password'},  #2
    { email: 'user@futuristicfintech.com', password: 'password'}  #2
    ]  #2

export const { auth, signIn, signOut } = NextAuth({
    ...authConfig,  #2
    providers: [
        Credentials({
            async authorize(credentials) {
                const parsedCredentials = z.object({  #3
                    email: z.string(),   #3
                    password: z.string(),  #3
                }).safeParse(credentials);  #3

                if (!parsedCredentials.success) {  #4
                    return null;    #4
                <span>}  </span>

<span>                const { email, password } = parsedCredentials.data; </span>#5

<span>                </span>const user = validUsers.find(user =&gt; user.email
<span class="CharOverride-10">➥</span> === email &amp;&amp; user.password === password); #6

                if (!user) { #7
                    return null;  #7
                }   #7

                return { email: user.email }; #8
            },
        }),
    ],
});</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Defines an array of emails and passwords to use</span>
<br/>#2 
     <span class="CharOverride-9">An existing configuration is included.</span>
<br/>#3 
     <span class="CharOverride-9">Parses the email and password</span>
<br/>#4 
     <span class="CharOverride-9">Checks for a successful parse</span>
<br/>#5 
     <span class="CharOverride-9">Retrieves the </span>
<span class="CharOverride-9">parsed data</span>
<br/>#6 
     <span class="CharOverride-9">Finds a valid user</span>
<br/>#7 
     <span class="CharOverride-9">If there is no valid user, returns null</span>
<br/>#8 
     <span class="CharOverride-9">Returns the email </span>
<span class="CharOverride-9">for the user</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p177">
<p>The login page will be displayed with the dashboard. We also asked ChatGPT to create a logo for our company. Interestingly, we made several attempts, and while the graphics always looked pretty good, ChatGPT could never quite get the spelling right (figure 7.10)!</p>
</div>
<div class="browsable-container figure-container" id="p178">
<img alt="A screenshot of a login page  Description automatically generated" height="347" src="../Images/CH07_F10_Kardell.jpg" style="width: 100%; max-width: max-content;" width="438"/>
<h5 class="figure-container-h5">Figure 7.10 Login sample page</h5>
</div>
<div class="readable-text" id="p179">
<p>The login page is a standard form, and much of the code is in support of the layout, tooltips, and button clicks.</p>
</div>
<div class="browsable-container listing-container" id="p180">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.41<span class="CharOverride-7"> </span>A login form showing NextAuth.js incorporated into our login page</h5>
<div class="code-area-container">
<pre class="code-area">…
    const [errorMessage, dispatch] = useFormState(authenticate, undefined);
    const [showErrorDialog, setShowErrorDialog] = useState&lt;boolean&gt;(false);
    const route = useRouter();
…
    const handleSubmit = async (event:
<span class="CharOverride-10">➥</span> React.FormEvent&lt;HTMLFormElement&gt;) =&gt; {

        event.preventDefault();
        const formData = new FormData(event.currentTarget);

        dispatch(formData);
    };

    useLayoutEffect(() =&gt; {
        if (errorMessage &amp;&amp; errorMessage !== 'success') {
            setShowErrorDialog(true);
        } else if (errorMessage === 'success') {
            route.push('/uploads');
            setShowErrorDialog(false);
        }
    }, [errorMessage, route]);

    return (
…
                    {showErrorDialog &amp;&amp; &lt;AlertMessage
                        open={showErrorDialog}
                        setOpen={() =&gt; setShowErrorDialog(false)}
                        title={"Error Signing In"}
                        message={"Either your email or
<span class="CharOverride-10">➥</span> password is incorrect. Please try again."}
                    /&gt;}
…
    &lt;Box
                    component={"img"}
…
                    alt="Company Logo"
                    src="/images/logo-light.png"
  …
                    &lt;Box component="form" onSubmit={handleSubmit}
<span class="CharOverride-10">➥</span> noValidate sx={{ mt: 1 }}&gt;</pre>
</div>
</div>
<div class="readable-text" id="p181">
<p>These changes prevent access to the upload page. However, we have not done anything to prevent access to the actual API behind the UI that powers the processing. For that, we need to incorporate access tokens and ensure these are being passed and validated on the server side as well. When we are ready to take that step to ensure the APIs are secure, our UI would have to make a <code>POST</code> request and include an <code>Authorization</code> header in it.</p>
</div>
<div class="browsable-container listing-container" id="p182">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.42<span class="CharOverride-7"> </span>Including the <code>Authorization</code> header in a <code>POST</code> request</h5>
<div class="code-area-container">
<pre class="code-area">        axios.post(`${apiUrl}/files`, formData, {
            headers: {
                'Content-Type': 'multipart/form-data',
                'Authorization': `Bearer <br/>token_string_that_is_assigned_after_login`,
            },
        })</pre>
</div>
</div>
<div class="readable-text" id="p183">
<p>Checking would be done similarly on the server with FastAPI.</p>
</div>
<div class="browsable-container listing-container" id="p184">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.43<span class="CharOverride-7"> </span>Creating a function to validate the token</h5>
<div class="code-area-container">
<pre class="code-area">async def verify_token(Authorization: str = Header(...)):
    if Authorization != "Bearer secret_token":
        raise HTTPException(status_code=400, detail="Invalid token")
    return Authorization</pre>
</div>
</div>
<div class="browsable-container listing-container" id="p185">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.44<span class="CharOverride-7"> </span>Adding the dependency</h5>
<div class="code-area-container">
<pre class="code-area">@router.post("", status_code=status.HTTP_201_CREATED,
<span class="CharOverride-10">➥</span> tags=["ACH Files"], dependencies=[Depends(verify_token)])</pre>
</div>
</div>
<div class="readable-text" id="p186">
<p>With all of that in place, when navigating to http://localhost:8000/docs, you will see a new Authorize button that will allow you to specify a token to be passed (figure 7.11). This approach provides a simple way to test our application via the OpenAPI documentation.</p>
</div>
<div class="browsable-container figure-container" id="p187">
<img alt="" height="368" src="../Images/CH07_F11_Kardell.png" style="width: 100%; max-width: max-content;" width="475"/>
<h5 class="figure-container-h5">Figure 7.11 Showing the Authorize button and popup</h5>
</div>
<div class="readable-text" id="p188">
<p>Here, we have simply used a hardcoded value, but it is possible to use a more robust authentication flow. To learn more about authentication flows such as OpenID Connect, check out their site at <a href="https://openid.net/"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/openid.net/</span></a>.</p>
</div>
<div class="readable-text" id="p189">
<h2 class="readable-text-h2"><span class="num-string">7.8</span> Adding TLS to our dashboard</h2>
</div>
<div class="readable-text" id="p190">
<p>The previous section covered how to secure our dashboard’s UI and APIs. However, there is another layer of security that we want you to be aware of—the communication or network layer. As we have seen throughout the book, our URLs have been using HTTP and not HTTPS. While this is not a problem for a development environment, we explore some of the steps involved in securing the network layer. Depending on the size of the company we work for (and of course our role), we may never need to worry about this. However, understanding some of the processes in setting this up can be helpful. It can be especially beneficial when having to work through any problems we may encounter as we gain valuable troubleshooting knowledge.</p>
</div>
<div class="readable-text intended-text" id="p191">
<p>We will keep this relatively simple by just adding an <code>nginx</code> instance to our Docker configuration that we can use. We will not worry about removing access to the existing HTTP ports from the outside as that is not necessary for our development environment. We simply want to see how to use Docker to understand how this process works.</p>
</div>
<div class="readable-text intended-text" id="p192">
<p>The following listing shows how to add a simple service to our existing docker-compose.yml file. We define the build information and ports. We expose both the standard HTTPS <code>port</code> <code>443</code> and HTTP <code>port</code> <code>80</code> because we will be redirecting any HTTP traffic to HTTPS. If we do not expose the port, the users will receive an error when trying to connect to the web site.</p>
</div>
<div class="browsable-container listing-container" id="p193">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.45<span class="CharOverride-7"> </span>The <code>nginx</code> endpoint for Docker to support TLS</h5>
<div class="code-area-container">
<pre class="code-area">  nginx:
    build:
      context: ./nginx
      dockerfile: Dockerfile #1
    ports:
      - 443:443 #2
      - 80:80   </pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">A Dockerfile </span>
<span class="CharOverride-9">to build from</span>
<br/>#2 
     <span class="CharOverride-9">We expose both the HTTPS 443 and HTTP 80 ports for this container.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p194">
<p>Next, as shown in the following listing, we specify the Dockerfile that needs to be in place. We are using the latest image from Nginx, ensuring packages are up to date and then installing OpenSSL because we will be using a self-signed certificate. Another option is using certbot (<a href="https://certbot.eff.org/"><span class="Hyperlink">https:</span><span class="Hyperlink">/</span><span class="Hyperlink">/certbot.eff.org/</span></a>), but a self-signed certificate will be enough for our needs. In a production environment, we would have to obtain the certificate from a trusted certificate authority (CA). We use the <code>/etc/ssl</code> directories to store our certificates, but that may differ depending on the OS.</p>
</div>
<div class="browsable-container listing-container" id="p195">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.46<span class="CharOverride-7"> </span>Dockerfile to build the container</h5>
<div class="code-area-container">
<pre class="code-area">FROM nginx:latest  #1

WORKDIR /etc/nginx #2

RUN apt-get update &amp;&amp; \
    apt-get install -y openssl #3

RUN mkdir -p /etc/ssl/certs  #4
RUN mkdir -p /etc/ssl/private  #4
RUN chmod 700 /etc/ssl/private  #4

RUN openssl req -x509 -nodes -days 365 -newkey rsa:2048 \#5
    <span>-keyout /etc/ssl/private/localhost.key -out</span> #5
<span class="CharOverride-10">➥</span><span> /etc/ssl/certs/localhost.crt \ </span> #5
<span>    </span>-subj <span class="CharOverride-10">➥</span> #5
"/C=US/ST=YourState/L=YourCity/ #5
<span class="CharOverride-10">➥</span>O=YourOrganization/OU=YourUnit/CN=localhost"  #5

COPY ./dashboard.conf /etc/nginx/conf.d/default.conf #6

CMD ["nginx", "-g", "daemon off;"]</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Uses the latest Nginx </span>
<span class="CharOverride-9"/>
<br/>#2 
     <span class="CharOverride-9">Sets the work directory to </span>
<span class="CharOverride-9">/etc/nginx (not strictly necessary)</span>
<br/>#3 
     <span class="CharOverride-9">Updates and then installs OpenSSL</span>
<span class="CharOverride-9"/>
<br/>#4 
     <span class="CharOverride-9">Preps directories to store certificates and keys in</span>
<span class="CharOverride-9"/>
<br/>#5 
     <span class="CharOverride-9">OpenSSL command creating our certificate; </span>
<span class="CharOverride-9">we make use of the directories we just </span>
<span class="CharOverride-9">created to store certificates.</span>
<span class="CharOverride-9"/>
<br/>#6 
     <span class="CharOverride-9">Copies our server configuration over </span>
<span class="CharOverride-9">to the container</span>
<span class="CharOverride-9"/>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p196">
<p>The Dockerfile copies a dashboard.conf to default.conf. Let’s look at what that configuration should look like. </p>
</div>
<div class="browsable-container listing-container" id="p197">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.47<span class="CharOverride-7"> </span>The dashboard.conf</h5>
<div class="code-area-container">
<pre class="code-area">server {
    listen 443 ssl; #1
    server_name localhost 127.0.0.1;  #2

    ssl_certificate /etc/ssl/certs/localhost.crt; #3
    ssl_certificate_key /etc/ssl/private/localhost.key; 

    location / {   #4
        proxy_pass http://dashboard:3000;  #4
        proxy_set_header Host $host;  #4
        proxy_set_header X-Real-IP $remote_addr;  #4
        proxy_set_header X-Forwarded-For #4
<span class="CharOverride-10">➥</span> $proxy_add_x_forwarded_for;  #4
        proxy_set_header X-Forwarded-Proto $scheme;  #4
    }  #4
}

server {
    listen 80; #5
    server_name localhost 127.0.0.1; #6

    location / { #7
        return 301 https://localhost:443$request_uri;  #7
    }  #7
}</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Defines the port we are listening on; 443 is a standard SSL port, but we still must include the ssl parameter to enable SSL.</span>
<span class="CharOverride-9"/>
<br/>#2 
     <span class="CharOverride-9">The name of the server; we are mapping localhost and </span>
<span class="CharOverride-12">1</span>
<span class="CharOverride-9">27.0.0.</span>
<span class="CharOverride-12">1</span>
<span class="CharOverride-9">.</span>
<span class="CharOverride-9"/>
<br/>#3 
     <span class="CharOverride-9">Specifies the cert </span>
<span class="CharOverride-9">and key for SSL</span>
<span class="CharOverride-9"/>
<br/>#4 
     <span class="CharOverride-9">Any traffic coming to this server is redirected to the dashboard on port 3000. We also set additional headers to provide information to the receiving server, which helps indicate where this forwarded request came from.</span>
<span class="CharOverride-9"/>
<br/>#5 
     <span class="CharOverride-9">Sets up port 80</span>
<span class="CharOverride-9"/>
<br/>#6 
     <span class="CharOverride-9">Again, we specify </span>
<span class="CharOverride-9">the localhost.</span>
<span class="CharOverride-9"/>
<br/>#7 
     <span class="CharOverride-9">We redirect the browser to the SSL port.</span>
<span class="CharOverride-9"/>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p198">
<p>We have now secured the dashboard using TLS. While doing so is required for production environments, it is not strictly necessary for our development. However, having a bit of knowledge about some of the basic setup can help you troubleshoot problems when environments are migrated or otherwise changed, and your application breaks. For instance, in the previous listing, headers such as <code>X-Real-IP</code> were set. If the application depends on these to be present but someone removes them from the configuration, we could end up with a troublesome bug. While uncommon, running into similar bugs is possible.</p>
</div>
<div class="readable-text" id="p199">
<h2 class="readable-text-h2"><span class="num-string">7.9</span> Testing with Playwright</h2>
</div>
<div class="readable-text" id="p200">
<p>You are now familiar with a few approaches to testing our software, specifically TDD and BDD. We have also looked at building tests with <code>pytest</code>, when working in Python, and Jest, when using TypeScript. With those tools, we have focused mostly on smaller unit testing. Because our MVP is completed, we are going to use end-to-end testing now to validate our work before it gets shipped off. For that, we use a tool called Playwright. Playwright is a cross-browser, cross-platform, and cross-language testing tool. So, regardless of our environment, chances are we can use Playwright. We chose Playwright with Python because we are currently using this combination for our APIs and file parsing.</p>
</div>
<div class="readable-text intended-text" id="p201">
<p>Getting started with Playwright is simply a matter of installing <code>pytest-playwright</code> with <code>pip</code> <code>install</code> <code>pytest-playwright</code> and then running <code>playwright</code> <code>install</code> to ensure browser extensions are installed as well. Once that is complete, we can start scripting. A powerful feature of Playwright is using the interactive mode from a Python console. After launching a browser with <code>headless=False</code>, we can see the results of our commands in real-time. </p>
</div>
<div class="browsable-container listing-container" id="p202">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.48<span class="CharOverride-7"> </span>Simple interactive Playwright</h5>
<div class="code-area-container">
<pre class="code-area">from playwright.sync_api import sync_playwright
playwright = sync_playwright().start()
browser = playwright.chromium.launch(headless=False) #1
page = browser.new_page() #2</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Specifies headless=False, which allows us to view and interact with the browser</span>
<br/>#2 
     <span class="CharOverride-9">We will not see the browser window </span>
<span class="CharOverride-9">until we call the new_page() method.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p203">
<p>When we have a handle on using Playwright to navigate to URLs and select elements, we can begin writing tests. The following tests show that we rely heavily on the <code>get_by_role</code> method when selecting elements. The <code>get_by_role</code> method follows the W3C specifications for ARIA (Accessible Rich Internet Applications), which can aid in developing pages that help conform to standards used by assistive technology (e.g., screen readers).</p>
</div>
<div class="browsable-container listing-container" id="p204">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.49<span class="CharOverride-7"> </span>Test to populate the login form</h5>
<div class="code-area-container">
<pre class="code-area">def test_login_screen(page: Page):
    page.goto("http://localhost:3000/uploads")
    email = page.get_by_role("textbox", name="Email") #1
    expect(email).to_have_id("email")
    email.fill("admin@futuristicfintech.com") #2
    password = page.get_by_role("textbox", name="Password")
    expect(password).to_have_id("password")
    password.fill("password")
    page.screenshot(path="screenshots/login_screen.png") #3</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Uses get_by_role to help ensure ARIA is supported</span>
<br/>#2 
     <span class="CharOverride-9">Uses the fill method </span>
<span class="CharOverride-9">to populate text</span>
<br/>#3 
     <span class="CharOverride-9">Creating screenshots </span>
<span class="CharOverride-9">is easy.</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p205">
<p>As we saw, populating fields is straightforward, and clicking buttons is just as easy. Let’s see whether we can cause a login exception by not populating any fields and clicking the button to sign us in. Notice how we use the <code>wait_for_selector</code> to ensure the alert is visible. If we do not use this, our error message may be translucent as it may not have finished rendering correctly.</p>
</div>
<div class="browsable-container listing-container" id="p206">
<h5 class="listing-container-h5 browsable-container-h5">Listing 7.50<span class="CharOverride-7"> </span>Capturing the exception message</h5>
<div class="code-area-container">
<pre class="code-area">def test_login_exception_message(page: Page):
    page.goto("http://localhost:3000/uploads") #1
    page.expect_navigation(wait_until="load")  #1
    expect(page).to_have_url(re.compile #1
<span class="CharOverride-10">➥</span>("http://localhost:3000/login.*"))  #1
    signin_button = page.get_by_role("button", name="Sign In")
    expect(signin_button).to_have_id("signin")
    signin_button.click() #2
    alert = page.get_by_role("heading") #3
    expect(alert).to_have_id("alert-message")  #3
    expect(alert).to_have_text("Error Signing In") 
    page.wait_for_selector("#alert-message",
<span class="CharOverride-10">➥</span> state="visible") #4
    page.screenshot(path= #4
<span class="CharOverride-10">➥</span>"screenshots/login_exception.png")  #4</pre>
<div class="code-annotations-overlay-container">
     #1 
     <span class="CharOverride-9">Verifies that we were redirected to the login page when we initially go to /uploads</span>
<br/>#2 
     <span class="CharOverride-9">Clicking buttons is simple.</span>
<br/>#3 
     <span class="CharOverride-9">Gets the alert message that should appear and verifies the text</span>
<br/>#4 
     <span class="CharOverride-9">Uses the wait_for_selector </span>
<span class="CharOverride-9">before taking a screenshot</span>
<br/>
</div>
</div>
</div>
<div class="readable-text" id="p207">
<p>If <code>wait_for_selector</code> is not used, we may end up with an error message that is not completely rendered, as shown in figure 7.12 on the left. This can be a common challenge in automated UI testing—the speed at which tests execute can lead to this scenario. Often, as we step through the code to verify the test is working, we won’t encounter this situation. It is generally possible only when the test is run as part of our automation or build pipeline.</p>
</div>
<div class="browsable-container figure-container" id="p208">
<img alt="" height="159" src="../Images/CH07_F12_Kardell.png" style="width: 100%; max-width: max-content;" width="861"/>
<h5 class="figure-container-h5"><span class="">Figure 7.12</span><span class=""> </span><span class="">Screen not rendered completely when we do not wait</span></h5>
</div>
<div class="readable-text" id="p209">
<p>Here, we have only touched on some basics of using Playwright to perform end-to-end testing on our dashboard by automating a browser instance. You should be able to see the benefits of running these types of tests on a variety of browsers. Our listings showed capturing a screenshot as part of the test, but that was mostly for validation purposes since we are running in a headless (no browser window) mode, and we do not actually see it running. In practice, we may only capture a screenshot of an exception coding for further troubleshooting and research. Maybe we could even combine Playwright with our BDD-style syntax to create browser automation tools for our QA department to use! Combining these into a CI/CD pipeline along with our current unit tests can further ensure our software is ready to ship.</p>
</div>
<div class="readable-text" id="p210">
<h2 class="readable-text-h2"><span class="num-string">7.10</span> MVP wrap-up</h2>
</div>
<div class="readable-text" id="p211">
<p>At this point, the MVP of our dashboard is complete. We have built the necessary remaining APIs using manual, unit, and integration testing to make sure the dashboard will work flawlessly once delivered. We also worked on improving the security of our application by using TLS and user authentication. </p>
</div>
<div class="readable-text intended-text" id="p212">
<p>Certainly, there are tweaks we could make to the UI and additional functionality. Make notes of those items as they are great to work on when you are capable of accepting more story points during a future sprint. As mentioned before, we must balance the functionality of the app with a delivery timeframe. Thus, it is important not to get caught up in adding all these bells and whistles. </p>
</div>
<div class="readable-text intended-text" id="p213">
<p>We covered a lot of ground in this chapter. Hopefully, our previous research spikes provided us with enough background to help us stay on target. The next section addresses some of the problems we may run into when putting the MVP together.</p>
</div>
<div class="readable-text" id="p214">
<h3 class="readable-text-h3"><span class="num-string">7.10.1</span> Troubleshooting the MVP</h3>
</div>
<div class="readable-text" id="p215">
<p>Inevitably, we run into problems as we work through our projects. While these can be frustrating, being able to resolve them is a necessity not limited to software development.</p>
</div>
<div class="readable-text intended-text" id="p216">
<p>One of the most common problems that we run into is a CORS error that usually says something like <code>Access</code> <code>to</code> <code>XMLHttpRequest</code> <code>at</code> <code>some_location</code> <code>from</code> <code>origin</code> <code>some_server_name</code> <code>has</code> <code>been</code> <code>blocked</code> <code>by</code> <code>CORS</code> <code>policy:</code> <code>No</code> <code>'Access-Control-Allow-Origin' header</code> <code>is</code> <code>present</code> <code>on</code> <code>the</code> <code>requested</code> <code>resource</code>. It can be triggered by a number of problems, such as</p>
</div>
<ul>
<li class="readable-text" id="p217">Request went to an unexpected location. In one instance, our Docker container had not shut down as intended and was still attempting to handle requests without our CORS changes in place.</li>
<li class="readable-text" id="p218">Pydantic was throwing an error because we had specified a required field named <code>account_number_last_4</code> but had mislabeled it as <code>account_number</code> in the SQL query. This was not too difficult to track down because Pydantic provided us with a nice error that looked similar to <code>{'type':</code> <code>'missing',</code> <code>'loc':</code> <code>('response', 0,</code> <code>'account_number_last_4'),</code> <code>'msg':</code> <code>'Field</code> <code>required',</code> <code>'input':</code> <code>{'id': UUID('29159e96-c2b3-452e-be1b-b4258c5e77aa'),</code> <code>'transaction_code': '22',</code> <code>'amount':</code> <code>'0000000201',</code> <code>'account_number':</code> <code>'*************0034', 'addenda_count':</code> <code>1},</code> <code>'url':</code> <code>'https://errors.pydantic.dev/2.6/v/missing'}</code>. Pydantic has specified the type as missing and provided our object with both fields and values. Sure enough, we do not see the missing field but the <code>account_number</code> instead.</li>
</ul>
<div class="readable-text" id="p219">
<p>Other errors that we ran into were also Pydantic related because we failed to update the field definitions as we were going through the code. So, a message such as <code>1</code> <code>validation</code> <code>error</code> <code>for</code> <code>AchEntryPpdDetailsSchema</code> also showed <code>[type=string_type, input_value=Decimal('1.00'),</code> <code>input_type=Decimal]</code>, which was a simple fix to ensure that all our data types were matching.</p>
</div>
<div class="readable-text intended-text" id="p220">
<p>Another data-type-related problem was the mix-up between strings and numerics because we were inconsistent or forgetting to update the parsing program to handle the cents when converting from a string to a numeric. So, $1.00 was showing incorrectly as $100.00. Interestingly, when reworking the code to go from strings to numerics, Copilot was not very helpful. It kept assuming that we wanted the next two positions in the string instead of breaking the current field up. </p>
</div>
<div class="readable-text intended-text" id="p221">
<p>We also ran into problems with SQL when we specified <code>INNER</code> <code>JOIN</code> instead of <code>LEFT</code> <code>JOIN</code>. We wanted to capture the addenda counts for a particular entry. <code>INNER</code> <code>JOIN</code> worked great when there were addenda records, but without them, the row was dropped, and that was not what we wanted.</p>
</div>
<div class="readable-text intended-text" id="p222">
<p>When testing with Playwright, we needed to ensure that names/IDs were included in our elements. Playwright also has great error messages. When running in strict mode, and there are multiple matches, it enumerates the possibilities and provides appropriate examples such as <code>get_by_role("banner").get_by_role("button")</code>, <code>locator("button").nth(2)</code>, and <code>get_by_role("button",</code> <code>name="Dashboard")</code>.</p>
</div>
<div class="readable-text intended-text" id="p223">
<p>Our final problem came from Docker, where we accidentally deleted a Dockerfile when updating our code. This resulted in the message <code>failed</code> <code>to</code> <code>solve:</code> <code>failed</code> <code>to read</code> <code>dockerfile:</code> <code>open</code> <code>/var/lib/docker/tmp/buildkit-mount39300809/Dockerfile:</code> <code>no</code> <code>such</code> <code>file</code> <code>or</code> <code>directory</code>. In another case, when updating the code for Docker, we simply copy/pasted existing code without clearing out the existing files in Docker, which triggered a problem in Next.js because we had different parameter names (slugs) for the same dynamic path. The error was clear enough: <code>Error:</code> <code>You</code> <code>cannot</code> <code>use</code> <code>different</code> <code>slug</code> <code>names</code> <code>for</code> <code>the</code> <code>same</code> <code>dynamic</code> <code>path</code> <code>('fileId'</code> <code>!==</code> <code>'id')</code>. However, it was also confusing because it was not a code problem but rather a directory structure problem (and procedural as well). Next, we had several dependency problems due to mismanagement on our part. These only appeared when we tried to build the solution in our Docker container. We ended up with errors such as <code>Starlette</code> <code>was</code> <code>listed</code> <code>in</code> <code>the requirements.txt</code>. The conflict was caused by</p>
</div>
<div class="browsable-container listing-container" id="p224">
<div class="code-area-container">
<pre class="code-area">     The user requested starlette==0.37.1
     fastapi 0.110.0 depends on starlette&lt;0.37.0 and &gt;=0.36.3</pre>
</div>
</div>
<div class="readable-text" id="p225">
<p>Finally, because we did not expose <code>port</code> <code>443</code> in <code>docker-compose</code>, the connection was refused when trying to access the HTTPS endpoint. That error looked similar to<code> Error:</code> <code>connect</code> <code>ECONNREFUSED</code> <code>127.0.0.1:443</code>.</p>
</div>
<div class="readable-text intended-text" id="p226">
<p>As we’ve experienced, being a full stack developer means we also get to see errors from many different areas, which makes our lives exciting!</p>
</div>
<div class="readable-text" id="p227">
<h2 class="readable-text-h2">Summary</h2>
</div>
<ul>
<li class="readable-text" id="p228">Previous sprints explored using generative AI and technologies such as Python/FastAPI, Postgres, Docker, and Next.js to expedite software development for our ACH dashboard MVP.</li>
<li class="readable-text" id="p229">The MVP allows users to upload and parse ACH files, store them in a database, and visualize the results on a dashboard.</li>
<li class="readable-text" id="p230">Different minimum concepts include MVP, MLP, MMP, and MMF, each serving unique purposes—from testing assumptions to delivering features.</li>
<li class="readable-text" id="p231">Preparing for an MVP involves integrating components such as the ACH parser, APIs, database design, and UI to function cohesively.</li>
<li class="readable-text" id="p232">Developing the <code>/files</code> APIs ensures alignment between the backend and UI, focusing on data accuracy and seamless functionality.</li>
<li class="readable-text" id="p233">BDD and TDD approaches help integrate APIs with the UI, ensuring accurate data responses and interactions.</li>
<li class="readable-text" id="p234">Refactoring interfaces and schemas improves code maintainability, readability, and flexibility when consuming APIs.</li>
<li class="readable-text" id="p235">Supporting the API integration of ACH batches into the dashboard requires updating data structures and transforming responses to match UI needs.</li>
<li class="readable-text" id="p236">The upload functionality from the dashboard simplifies user interaction but highlights development considerations, such as code duplication and user feedback upon file upload.</li>
<li class="readable-text" id="p237">Deployment in Docker involves cleaning up configurations for production readiness, ensuring seamless communication between containers, and addressing common troubleshooting problems.</li>
</ul>
</div></body></html>