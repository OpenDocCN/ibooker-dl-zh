["```py\nimport numpy as np\n\ndef third_order_polynomial(x, a, b, c, d):\n    return a * x**3 + b * x**2 + c * x + d\n\na, b, c, d = 2, -3, 4, 1                     ①\n\nx = np.linspace(0, 5, 5)                     ②\n\ny = third_order_polynomial(x, a, b, c, d)    ③\n\ndata_samples = np.column_stack((x, y))       ④\n```", "```py\nimport numpy as np\nfrom pymoo.algorithms.soo.nonconvex.ga import GA                  ①\nfrom pymoo.operators.crossover.sbx import SBX                     ②\nfrom pymoo.operators.mutation.pm import PolynomialMutation        ③\nfrom pymoo.operators.repair.rounding import RoundingRepair        ④\nfrom pymoo.operators.sampling.rnd import FloatRandomSampling      ⑤\nfrom pymoo.core.problem import Problem                            ⑥\nfrom pymoo.optimize import minimize                               ⑦\n\nclass CurveFittingProblem(Problem):                               ⑧\n\n    def __init__(self):                                           ⑨\n        super().__init__(n_var=4,\n                         n_obj=1,\n                         n_constr=0,\n                         xl=-10.0,\n                         xu=10.0, vtype=float)    \n\n    def _evaluate(self, X, out, *args, **kwargs):                 ⑩\n        Y = np.zeros((X.shape[0], 1))\n        for i, coeffs in enumerate(X):\n            y_pred = np.polyval(coeffs, x)\n            mse = np.mean((y - y_pred)**2)\n            Y[i] = mse\n        out[\"F\"] = Y\n```", "```py\nproblem = CurveFittingProblem()                                           ①\n\nalgorithm = GA(\n    pop_size=50,\n    sampling=FloatRandomSampling(),\n    crossover= SBX(prob=0.8),\n    mutation = PolynomialMutation(prob=0.3, repair=RoundingRepair()),\n    eliminate_duplicates=True\n)                                                                         ②\n\nres = minimize(problem, algorithm, ('n_gen', 100), seed=1, verbose=True)  ③\n```", "```py\nbest_coeffs = res.X\nprint(\"Coefficients of the best-fit third-order polynomial:\")\nprint(\"a =\", best_coeffs[0])\nprint(\"b =\", best_coeffs[1])\nprint(\"c =\", best_coeffs[2])\nprint(\"d =\", best_coeffs[3])\n```", "```py\nCoefficients of the best-fit third-order polynomial:\na = 2, b = -3, c = 4, d = 1\n```", "```py\nInput: two parents P1 and P2\nOutput: two children C1 and C2\n1\\. Initialize: Choose two random crossover points and copy the segment between these two points from parent P1 to child C1 and from the second parent P2 to the second child C2.\n2\\. For each element in the copied segment of C1:\n3\\.   Find the corresponding element in P2's segment. \n4\\.   If the corresponding element is not already in C1:\n5\\.      Replace the element in C1 at the same position as in P2 with the \n        corresponding element from P2.\n6\\. Fill the remaining positions in the offspring with the elements from the other parent, ensuring that no duplicates are introduced.\n7\\. Repeat steps 2-6 for the second offspring, using P1's segment as the reference.\n8\\. Return C1 and C2.\n```", "```py\nimport random\n\ndef partially_mapped_crossover(parent1, parent2):\n\n    n = len(parent1)\n\n    point1, point2 = sorted(random.sample(range(n), 2))     ①\n\n    child1 = [None] * n                                     ②\n    child2 = [None] * n                                     ②\n    child1[point1:point2+1] = parent1[point1:point2+1]      ②\n    child2[point1:point2+1] = parent2[point1:point2+1]      ②\n\n    for i in range(n):                                      ③\n        if child1[i] is None:                               ③\n            value = parent2[i]                              ③\n            while value in child1:                          ③\n                value = parent2[parent1.index(value)]       ③\n            child1[i] = value                               ③\n\n        if child2[i] is None:\n            value = parent1[i]\n            while value in child2:\n                value = parent1[parent2.index(value)]\n            child2[i] = value\n\n    return child1, child2                                   ④\n```", "```py\nInput: two parent P1 and P2\nOutput: offspring C\n1\\. Construct an edge table.\n2\\. Start by selecting an arbitrary element from one of the parents as the starting point for the offspring.\n3\\. For the current element in the offspring, compare its edges.\n4\\. If an edge is common in both parents, choose that as the next element in the offspring.\n5\\. If there is no common edge or the common edge is already in the offspring, choose the next element from the parent with the shortest edge list.\n6\\. Repeat until the offspring is complete.\n7\\. Return C\n```", "```py\nInput: two parents P1 and P2\nOutput: offspring C1 and C2\n1\\. Choose two random crossover points within the chromosomes and copy the segment between the crossover points from P1 to C1 and from P2 to C2.\n2\\. Starting from the second crossover point, go through the remaining elements in P2.\n3\\. If an element is not already present in C1, append it to the end in the same order as it appears in P2.\n4\\. Wrap around P2 and continue appending the elements until C1 is complete.\nRepeat steps 2-4 for C2, using P1 as the reference.\n5\\. Return C1 and C2\n```", "```py\nInput: two parents P1 and P2\nOutput: offspring C1 and C2\n1\\. Identify cycles between the two parents. A cycle of elements from a parent P1 is created following these steps:\n    a) Begin with the starting element of P1.\n    b) Look at the element at the corresponding position in P2.\n    c) Move to the position with the same element in P1.\n    d) Include this element in the cycle.\n    e) Iterate through steps b to d until you reach the starting element of P1.\n2\\. Create offspring by placing the elements of the identified cycles, preserving their positions from the corresponding parents.\n3\\. Fill in the remaining positions in C1 with elements from P2 and the remaining positions of C2 with elements from P1 that were not included in the identified cycles. Maintain the order of the elements as they appear in the parents.\n4\\. Return C1 and C2.\n```", "```py\ndef inversion_mutation(individual, mutation_rate):\n    n = len(individual)\n    mutated_individual = individual.copy()\n\n    if random.random() < mutation_rate:\n        i, j = sorted(random.sample(range(n), 2))\n        mutated_individual[i:j+1] = reversed(mutated_individual[i:j+1])\n\n    return mutated_individual\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom pymoo.core.problem import ElementwiseProblem               ①\n\nclass ManufacturingProblem(ElementwiseProblem):\n\n    def __init__(self):\n        super().__init__(n_var=4,\n                         n_obj=2,\n                         n_ieq_constr=2,\n                         xl=np.array([0,0,0,0]),\n                         xu=np.array([100,100,500,500]))        ②\n\n    def _evaluate(self, x, out, *args, **kwargs):\n        f1 = 100*x[0] + 150*x[1] + 200*x[2] + 50*x[3]           ③\n        f2 = np.abs((2*x[0] + 4*x[2]) - (3*x[1] + x[3]))        ④\n\n        g1 = -x[0] - x[1] + 80                                  ⑤\n        g2 = -x[2] - x[3] + 300                                 ⑤\n\n        out[\"F\"] = [f1, f2]\n        out[\"G\"] = [g1, g2]\n\nproblem = ManufacturingProblem()\n```", "```py\nfrom pymoo.algorithms.moo.nsga2 import NSGA2                       ①\nfrom pymoo.operators.crossover.sbx import SBX                      ②\nfrom pymoo.operators.mutation.pm import PM                         ③\nfrom pymoo.operators.sampling.rnd import FloatRandomSampling       ④\n\nalgorithm = NSGA2(\n    pop_size=40,\n    n_offsprings=10,\n    sampling=FloatRandomSampling(),\n    crossover=SBX(prob=0.9, eta=15),\n    mutation=PM(eta=20),\n    eliminate_duplicates=True\n)                                                                  ⑤\n```", "```py\nfrom pymoo.termination import get_termination\ntermination = get_termination(\"n_gen\", 40)\n```", "```py\nfrom pymoo.optimize import minimize\n\nres = minimize(problem,\n               algorithm,\n               termination,\n               seed=1,\n               save_history=True,\n               verbose=True)\nX = res.X\nF = res.F\n```", "```py\nprint(\"Solutions found: \")\nprint(\"Number of units of product P1 produced on machines M1 and M2\\n and \n➥ Number of units of product P2 produced on machines M1 and M2 are:\\n\",\n➥ np.asarray(X, dtype = 'int'))\nnp.set_printoptions(suppress=True, precision=3)\nprint(\"The total production costs and \\n difference in production times\n➥ between the two machines are:\\n\",F)\n```", "```py\nSolutions found: \nNumber of units of product P1 produced on machines M1 and M2\nand Number of units of product P2 produced on machines M1 and M2 are:\n[[ 90  18  39 300]\n[ 91  19  39 297]\n[ 91  16  12 300]\n[ 90  12  30 310]\n[ 90  14  21 300]\n[ 90  14  47 328]\n[ 34  48   1 305]\n[ 87  13   3 299]\n[ 91  11   7 297]\n[ 30  51   0 300]]\nThe total production costs and \ndifference in production times between the two machines are:\n[[34757.953    16.105]\n[34935.538    13.813]\n[29235.912   114.763]\n[32498.687    43.463]\n[30481.316    79.233]\n[37228.051     0.652]\n[26307.998   378.004]\n[26388.316   150.968]\n[27199.394   118.385]\n[25980.561   392.176]]\n```", "```py\napprox_ideal = F.min(axis=0)\napprox_nadir = F.max(axis=0)\nnF = (F - approx_ideal) / (approx_nadir - approx_ideal)\n```", "```py\nweights = np.array([0.2, 0.8])      ①\n```", "```py\nfrom pymoo.decomposition.asf import ASF\ndecomp = ASF()\n```", "```py\ni = decomp.do(nF, 1/weights).argmin()\n\nprint(\"Best regarding ASF: Point \\ni = %s\\nF = %s\" % (i, F[i]))\n\nplt.figure(figsize=(7, 5))\nplt.scatter(F[:, 0], F[:, 1], s=30, facecolors='none', edgecolors='blue')\nplt.scatter(F[i, 0], F[i, 1], marker=\"x\", color=\"red\", s=200)\nplt.title(\"Objective Space\")\nplt.xlabel(\"Total production costs\")\nplt.ylabel(\"Difference in production times\")\nplt.show()\n```", "```py\nThe best solution found: \nNumber of units of product P1 produced on machines M1 and M2 are 90 and 12 respectively\nNumber of units of product P2 produced on machines M1 and M2 are 30 and 310 respectively\nThe total production costs are 32498.69\nThe difference in production times between the two machines is 43\n```", "```py\nimport numpy as np\nimport pandas as pd\nimport networkx as nx\nfrom collections import defaultdict\nfrom haversine import haversine\nimport matplotlib.pyplot as plt\nfrom pymoo.core.problem import ElementwiseProblem\nfrom pymoo.core.repair import Repair\nfrom pymoo.algorithms.soo.nonconvex.ga import GA\nfrom pymoo.optimize import minimize\nfrom pymoo.operators.sampling.rnd import PermutationRandomSampling\nfrom pymoo.operators.crossover.ox import OrderCrossover\nfrom pymoo.operators.mutation.inversion import InversionMutation\nfrom pymoo.termination.default import DefaultSingleObjectiveTermination\nfrom pymoo.optimize import minimize\n\ncities = {\n    'New York City': (40.72, -74.00),\n    'Philadelphia': (39.95, -75.17),       \n    'Baltimore': (39.28, -76.62),\n    'Charlotte': (35.23, -80.85),\n    'Memphis': (35.12, -89.97),\n    'Jacksonville': (30.32, -81.70),\n    'Houston': (29.77, -95.38),\n    'Austin': (30.27, -97.77),\n    'San Antonio': (29.53, -98.47),\n    'Fort Worth': (32.75, -97.33),\n    'Dallas': (32.78, -96.80),\n    'San Diego': (32.78, -117.15),\n    'Los Angeles': (34.05, -118.25),\n    'San Jose': (37.30, -121.87),\n    'San Francisco': (37.78, -122.42),    \n    'Indianapolis': (39.78, -86.15),\n    'Phoenix': (33.45, -112.07),       \n    'Columbus': (39.98, -82.98), \n    'Chicago': (41.88, -87.63),\n    'Detroit': (42.33, -83.05)\n}                                                                      ①\n\ndistance_matrix = defaultdict(dict)                                    ②\nfor ka, va in cities.items():\n    for kb, vb in cities.items():\n        distance_matrix[ka][kb] = 0.0 if kb == ka else haversine((va[0], va[1]),\n➥ (vb[0], vb[1]))                                                     ②\n\ndistances = pd.DataFrame(distance_matrix)                              ③\ncity_names=list(distances.columns)                                     ③\ndistances=distances.values                                             ③\n\nG=nx.Graph()                                                           ④\nfor ka, va in cities.items():                                          ④\n    for kb, vb in cities.items():                                      ④\n        G.add_weighted_edges_from({(ka,kb, distance_matrix[ka][kb])})  ④\n        G.remove_edges_from(nx.selfloop_edges(G))                      ④\n```", "```py\nclass TravelingSalesman(ElementwiseProblem):\n\n    def __init__(self, cities, distances, **kwargs):\n        self.cities = cities\n        n_cities = len(cities)\n        self.distances = distances\n\n        super().__init__(\n            n_var=n_cities,\n            n_obj=1,\n            xl=0,\n            xu=n_cities,\n            vtype=int,\n            **kwargs\n        )\n\n    def _evaluate(self, x, out, *args, **kwargs):\n        f = 0\n        for i in range(len(x) - 1):\n            f += distances[x[i], x[i + 1]]\n        f += distances[x[-1], x[0]]\n        out[\"F\"] = f\n```", "```py\nclass StartFromZeroRepair(Repair):\n\n    def _do(self, problem, X, **kwargs):\n        I = np.where(X == 0)[1]\n\n        for k in range(len(X)):\n            i = I[k]\n            X[k] = np.concatenate([X[k, i:], X[k, :i]])\n\n        return X\n```", "```py\nproblem = TravelingSalesman(cities,distance_matrix)                          ①\n\nalgorithm = GA(\n    pop_size=20,\n    sampling=PermutationRandomSampling(),\n    mutation=InversionMutation(),\n    crossover=OrderCrossover(),\n    repair=StartFromZeroRepair(),\n    eliminate_duplicates=True\n)                                                                             ②\n\ntermination = DefaultSingleObjectiveTermination(period=300, n_max_gen=np.inf) ③\n\nres = minimize(\n    problem,\n    algorithm,\n    termination,\n    seed=1,\n    verbose=False\n)                                                                              ④ \n```", "```py\nOrder = res.X\nRoute = [city_names[i] for i in Order]\narrow_route = ' → '.join(Route)\nprint(\"Route:\", arrow_route)\nprint(\"Route length:\", np.round(res.F[0], 3))\nprint(\"Function Evaluations:\", res.algorithm.evaluator.n_eval)\n```", "```py\nRoute: New York City → Detroit → Columbus → Indianapolis → Chicago → San Francisco → San Jose → Los Angeles → San Diego → Phoenix → San Antonio → Austin → Houston → Fort Worth → Dallas → Memphis → Jacksonville → Charlotte → Baltimore → Philadelphia\nRoute length: 10934.796\nFunction Evaluations: 6020\n```", "```py\nfig, ax = plt.subplots(figsize=(15,10))\n\nH = G.copy()                                                               ①\n\nreversed_dict = {key: value[::-1] for key, value in cities.items()}        ②\n\nkeys_list = list(cities.keys())                                            ③\n\nincluded_cities = {keys_list[index]: cities[keys_list[index]] for index in ④\n➥ list(res.X)}                                                            ④\nincluded_cities_keys=list(included_cities.keys())                          ④\n\nedge_list =list(nx.utils.pairwise(included_cities_keys))                   ⑤\n\nnx.draw_networkx_edges(H, pos=reversed_dict, edge_color=\"gray\", width=0.5) ⑥\n\nax=nx.draw_networkx(\n    H,\n    pos=reversed_dict,\n    with_labels=True,\n    edgelist=edge_list,\n    edge_color=\"red\",\n    node_size=200,\n    width=3,\n)                                                                          ⑦\nplt.show()                                                                 ⑦\n```", "```py\nimport numpy as np\nimport control                                         ①\nimport math\nimport matplotlib.pyplot as plt\nfrom pymoo.algorithms.soo.nonconvex.ga import GA \nfrom pymoo.operators.crossover.pntx import PointCrossover\nfrom pymoo.operators.mutation.pm import PolynomialMutation\nfrom pymoo.operators.repair.rounding import RoundingRepair\nfrom pymoo.operators.sampling.rnd import FloatRandomSampling\nfrom pymoo.core.problem import Problem\nfrom pymoo.optimize import minimize\n\ndef transfer_function(Kp,Ki,Kd):                       ②\n    num = np.array([Kd,Kp,Ki])                         ③\n    den = np.array([1,(Kd+10),(Kp+20),Ki])             ④\n    T = control.tf(num, den)                           ⑤\n    t, y = control.step_response(T)                    ⑥\n    return T, t, y\n#A Import the control module.\n```", "```py\ndef objective_function(t, error, Kp,Ki,Kd, criterion):\n\n    if criterion == 1:\n        ITAE = np.trapz(t, t*error)                                    ①\n        objfnc= ITAE\n    elif criterion == 2:\n        ITSE = np.trapz(t, t*error**2)                                 ②\n        objfnc= ITSE\n    elif criterion == 3:\n        IAE =  np.trapz(t, error)                                      ③\n        objfnc= IAE\n    elif criterion == 4:\n        ISE = np.trapz(t, error**2)                                    ④\n        objfnc= ISE\n    elif criterion == 5:\n        T, _, _ =transfer_function(Kp,Ki,Kd)\n        info = control.step_info(T)\n        beta = 1\n        Mp = info['Overshoot']\n        tr = info['RiseTime']\n        ts = info['SettlingTime']\n        ess = abs(1-info['SteadyStateValue'])\n        W = ((1-math.exp(-beta))*(Mp+ess))+((math.exp(-beta))*(ts-tr)) ⑤\n        objfnc=W;      \n\n    return objfnc\n```", "```py\nclass PIDProblem(Problem):\n\n    def __init__(self):\n        super().__init__(n_var=3,                     ①\n                         n_obj=1,                     ②\n                         n_constr=0,                  ③\n                         xl=0,                        ④\n                         xu=100,                      ④\n                         vtype=float)    \n\n    def _evaluate(self, X, out, *args, **kwargs):     ⑤\n        f = np.zeros((X.shape[0], 1))   \n        for i, params in enumerate(X):\n            Kp, Ki, Kd = params\n            T, t, y =transfer_function(Kp,Ki,Kd)\n            error = 1 - y\n            f[i]=objective_function(t, np.abs(error), Kp,Ki,Kd, 5)            \n        out[\"F\"] = f \n```", "```py\nproblem = PIDProblem()\n\nalgorithm = GA(\n    pop_size=50,\n    sampling=FloatRandomSampling(),\n    crossover=PointCrossover(prob=0.8, n_points=2),\n    mutation = PolynomialMutation(prob=0.3, repair=RoundingRepair()),\n    eliminate_duplicates=True\n)\n\nres = minimize(problem, algorithm, ('n_gen', 60), seed=1, verbose=True)\n```", "```py\nbest_params = res.X\nprint(\"Optimal PID controller parameters:\")\nprint(\"Kp =\", best_params[0])\nprint(\"Ki =\", best_params[1])\nprint(\"Kd =\", best_params[2])\n```", "```py\nKp = best_params[0]\nKi = best_params[1]\nKd = best_params[2]\n\nT, t, y =transfer_function(Kp,Ki,Kd)\n\nplt.plot(t,y)\nplt.title(\"Step Response\")\nplt.xlabel(\"Time (s)\")\nplt.grid()\n```", "```py\ncontrol.step_info(T)\n```", "```py\n{'RiseTime': 0.353,\n 'SettlingTime': 0.52,\n 'SettlingMin': 0.92,\n 'SettlingMax': 1.0,\n 'Overshoot': 0,\n 'Undershoot': 0,\n 'Peak': 0.99,\n 'PeakTime': 3.62,\n 'SteadyStateValue': 1.0}\n```", "```py\nimport geopandas as gpd\nimport pandas as pd\nimport folium\n\ndata_url=\"https://raw.githubusercontent.com/Optimization-Algorithms-Book/  ①\nCode-Listings/main/Appendix%20B/data/PoliticalDistricting/\" \n\ntoronto = gpd.read_file(data_url+\"toronto.geojson\")                        ②\nneighborhoods = pd.read_csv(data_url+\"Toronto_Neighborhoods.csv\")          ③\n\nrange_limit = 16                                                           ④\ntoronto_sample = toronto.tail(range_limit)                                 ④\nvalues = neighborhoods.tail(range_limit)                                   ④\nvalues = values.join(toronto_sample[\"cartodb_id\"])                         ④\n```", "```py\nimport numpy as np\n\ndef get_population(lst, table):\n    return table[\"population\"].iloc[lst].to_numpy()    ①\n\neval = get_population(range(range_limit), values)      ②\n\ndef get_neighboors(database):                          ③\n    result = []\n    for i in range(database['name'].size):\n        tmp = np.zeros(database['name'].size)\n        geo1 = database.iloc[i]\n        for j in range(database['name'].size):\n            if i != j:\n                geo2 = database.iloc[j]\n                if geo1[\"geometry\"].intersects(geo2[\"geometry\"]):\n                    tmp[j] = 1\n        result.append(tmp)\n    return np.stack(result)\n\nneighbor = get_neighboors(toronto_sample)\n```", "```py\nfrom pymoo.core.problem import Problem\n\nclass PoliticalDistricting(Problem):\n    def __init__(self,\n                 num_dist, \n                 neighbor, \n                 populations, \n                 margin \n                 ):                                         ①\n\n        self.populations = populations                      ②\n        self.average = np.mean(populations)                 ③\n        super().__init__(n_var=len(self.populations), n_obj=1, n_eq_constr=3, \n➥ xl=0, xu=num_dist-1, vtype=int)                          ④\n\n        self.n_var = len(self.populations) \n        self.n_dist = num_dist\n        self.margin = margin\n        self.neighbor = neighbor\n        self.func = self._evaluate                          ⑤\n```", "```py\ndef _gather(self, x, district):\n    return np.where(x==district, 1, 0)\n```", "```py\ndef _get_bounds(self):\n    ub = np.ceil(self.average + self.margin) *\n➥ (len(self.populations)/self.n_dist)\n    lb = np.ceil(self.average - self.margin) * \n➥ (len(self.populations)/self.n_dist)\n    return ub, lb\n```", "```py\ndef _get_result(self, gathered, ub, lb):\n    product = gathered * self.populations\n    summed_product = np.sum(product, axis=1)\n    return np.where((summed_product > ub), 1, 0) + np.where((summed_product <\n➥ lb), 1, 0)\n```", "```py\ndef _get_constraint(self, constraint):\n    constraint = np.stack(constraint)\n    return np.any(constraint==0, axis=0)\n```", "```py\ndef _get_neighbor(self, gathered):\n    singleton = np.sum(gathered, axis=1)\n    singleton = np.where(singleton==1, True, False) \n    tmp_neighbor = np.dot(gathered, self.neighbor)\n    tmp_neighbor = np.where(tmp_neighbor > 0, 1, 0)\n    product = gathered * tmp_neighbor\n    return np.all(np.equal(product, gathered), axis=1) + singleton \n```", "```py\ndef cap_district(self, gathered):\n    result = np.zeros(gathered.shape[0])\n    for i in range(len(gathered)):\n        nonzeros = np.nonzero(gathered[i])[0]\n        if nonzeros.size != 0:\n            mx = np.max(nonzeros)\n            mn = np.min(nonzeros)\n            result[i] = self.neighbor[mx][mn] or (mx == mn)  \n    return result \n```", "```py\n    def _evaluate(self, x, out, *args, **kwargs):\n        x=np.round(x).astype(int) # Ensure X is binary\n        pop_count = []\n        constraint1 = []\n        constraint2 = []\n        constraint3 = []\n        for i in range(self.n_dist):\n            gathered = self._gather(x, i)\n            ub, lb = self._get_bounds()\n            result = self._get_result(gathered, ub, lb)\n            pop_count.append(result)\n            constraint1.append(np.sum(gathered, axis=1))          ①\n            constraint2.append((self._get_neighbor(gathered)))    ②\n            constraint3.append(self.cap_district(gathered))       ③\n\n        holder = np.sum(np.stack(pop_count), axis=0)\n        out[\"F\"] = np.expand_dims(holder, axis=1) \n        out[\"H\"] = [self._get_constraint(constraint1),\n                    self._get_constraint(constraint2), \n                    self._get_constraint(constraint3)] \n\ndef create_districting_problem(number_of_districts, neighborlist, population_\n➥ list, margin, seed=1):\n    np.random.seed(seed)\n    problem = PoliticalDistricting(number_of_districts, neighborlist,\n➥ population_list, margin)\n    return problem\n```", "```py\nfrom pymoo.algorithms.soo.nonconvex.ga import GA\nfrom pymoo.operators.sampling.rnd import FloatRandomSampling\nfrom pymoo.operators.crossover.pntx import PointCrossover\nfrom pymoo.operators.mutation.pm import PolynomialMutation\nfrom pymoo.operators.repair.rounding import RoundingRepair\nfrom pymoo.termination import get_termination\nfrom pymoo.optimize import minimize\n\nnum_districts = 3\nmargin=6000\n\nproblem = create_districting_problem(num_districts, neighbor, eval, margin, seed=1)\n\nalgorithm = GA(\n    pop_size=2000,\n    sampling=FloatRandomSampling(),\n    crossover=PointCrossover(prob=0.8, n_points=2),\n    mutation = PolynomialMutation(prob=0.3, repair=RoundingRepair()),\n    eliminate_duplicates=True\n)\n\ntermination = get_termination(\"n_gen\", 100)\n\nres = minimize(problem,\n               algorithm,\n               termination,\n               seed=1,\n               save_history=True,\n               verbose=True)\n```", "```py\nPolitical District- 1 :  ['Woburn', 'Highland Creek', 'Malvern']\nPolitical District- 2 :  ['Bendale', 'Scarborough Village', 'Guildwood', 'Morningside', 'West Hill', 'Centennial Scarborough', 'Agincourt South-Malvern West']\nPolitical District- 3 :  ['Rouge', 'Hillcrest Village', 'Steeles', \"L'Amoreaux\", 'Milliken', 'Agincourt North']\n```"]