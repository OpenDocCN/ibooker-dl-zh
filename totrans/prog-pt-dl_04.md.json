["```py\nfrom torchvision import models\ntransfer_model = models.ResNet50(pretrained=True)\n```", "```py\nfor name, param in transfer_model.named_parameters():\n    param.requires_grad = False\n```", "```py\nfor name, param in transfer_model.named_parameters():\n    if(\"bn\" not in name):\n        param.requires_grad = False\n```", "```py\ntransfer_model.fc = nn.Sequential(nn.Linear(transfer_model.fc.in_features,500),\nnn.ReLU(),\nnn.Dropout(), nn.Linear(500,2))\n```", "```py\nimport math\ndef find_lr(model, loss_fn, optimizer, init_value=1e-8, final_value=10.0):\n    number_in_epoch = len(train_loader) - 1\n    update_step = (final_value / init_value) ** (1 / number_in_epoch)\n    lr = init_value\n    optimizer.param_groups[0][\"lr\"] = lr\n    best_loss = 0.0\n    batch_num = 0\n    losses = []\n    log_lrs = []\n    for data in train_loader:\n        batch_num += 1\n        inputs, labels = data\n        inputs, labels = inputs, labels\n        optimizer.zero_grad()\n        outputs = model(inputs)\n        loss = loss_fn(outputs, labels)\n\n        # Crash out if loss explodes\n\n        if batch_num > 1 and loss > 4 * best_loss:\n            return log_lrs[10:-5], losses[10:-5]\n\n        # Record the best loss\n\n        if loss < best_loss or batch_num == 1:\n            best_loss = loss\n\n        # Store the values\n\n        losses.append(loss)\n        log_lrs.append(math.log10(lr))\n\n        # Do the backward pass and optimize\n\n        loss.backward()\n        optimizer.step()\n\n        # Update the lr for the next step and store\n\n        lr *= update_step\n        optimizer.param_groups[0][\"lr\"] = lr\n    return log_lrs[10:-5], losses[10:-5]\n```", "```py\nlogs,losses = find_lr()\nplt.plot(logs,losses)\nfound_lr = 1e-2\n```", "```py\noptimizer = optimizer.Adam([\n{ 'params': transfer_model.layer4.parameters(), 'lr': found_lr /3},\n{ 'params': transfer_model.layer3.parameters(), 'lr': found_lr /9},\n], lr=found_lr)\n```", "```py\nunfreeze_layers = [transfer_model.layer3, transfer_model.layer4]\nfor layer in unfreeze_layers:\n    for param in layer.parameters():\n        param.requires_grad = True\n```", "```py\ntransforms = transforms.Compose([\n        transforms.Resize(64),\n        transforms.ToTensor(),\n        transforms.Normalize(mean=[0.485, 0.456, 0.406],\n                     std=[0.229, 0.224, 0.225] )\n        ])\n```", "```py\ntorchvision.transforms.ColorJitter(brightness=0, contrast=0, saturation=0, hue=0)\n```", "```py\ntorchvision.transforms.RandomHorizontalFlip(p=0.5)\ntorchvision.transforms.RandomVerticalFlip(p=0.5)\n```", "```py\ntorchvision.transforms.RandomGrayscale(p=0.1)\n```", "```py\ntorchvision.transforms.RandomCrop(size, padding=None,\npad_if_needed=False, fill=0, padding_mode='constant')\ntorchvision.transforms.RandomResizedCrop(size, scale=(0.08, 1.0),\nratio=(0.75, 1.3333333333333333), interpolation=2)\n```", "```py\ntorchvision.transforms.RandomRotation(degrees, resample=False,expand=False, center=None)\n```", "```py\ntorchvision.transforms.Pad(padding, fill=0, padding_mode=constant)\n```", "```py\ntorchvision.transforms.RandomAffine(degrees, translate=None, scale=None,\nshear=None, resample=False, fillcolor=0)\n```", "```py\ndef _random_colour_space(x):\n    output = x.convert(\"HSV\")\n    return output\n```", "```py\ncolour_transform = transforms.Lambda(lambda x: _random_colour_space(x))\n```", "```py\nrandom_colour_transform = torchvision.transforms.RandomApply([colour_transform])\n```", "```py\nclass Noise():\n    \"\"\"Adds gaussian noise to a tensor.\n\n >>> transforms.Compose([\n >>>     transforms.ToTensor(),\n >>>     Noise(0.1, 0.05)),\n >>> ])\n\n \"\"\"\n    def __init__(self, mean, stddev):\n        self.mean = mean\n        self.stddev = stddev\n\n    def __call__(self, tensor):\n        noise = torch.zeros_like(tensor).normal_(self.mean, self.stddev)\n        return tensor.add_(noise)\n\n    def __repr__(self):\n        repr = f\"{self.__class__.__name__  }(mean={self.mean},\n               stddev={self.stddev})\"\n        return repr\n```", "```py\ntransforms.Compose([Noise(0.1, 0.05))])\n>> Compose(\n    Noise(mean=0.1,sttdev=0.05)\n)\n```", "```py\nresize = transforms.Compose([ transforms.Resize(64),\n \u2026_other augmentation transforms_\u2026\n transforms.ToTensor(),\n transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])\n```", "```py\n# Assuming you have a list of models in models, and input is your input tensor\n\npredictions = [m[i].fit(input) for i in models]\navg_prediction = torch.stack(b).mean(0).argmax()\n```"]