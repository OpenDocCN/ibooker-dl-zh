<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 7. Building Web Applications with AI"><div class="chapter" id="ch07_building_web_applications_with_ai_1752630044184850">
<h1><span class="label">Chapter 7. </span>Building Web Applications with AI</h1>

<p>This chapter shifts the focus from prompting quick prototypes to developing complete web applications using AI assistance. <a contenteditable="false" data-primary="web applications, building with AI" data-type="indexterm" id="ix_webapp"/>Web apps typically involve a frontend (often written in frameworks like React, Angular, or Vue), a backend (APIs, databases, servers), and glue to connect everything.<a contenteditable="false" data-primary="Vue" data-type="indexterm" id="id746"/><a contenteditable="false" data-primary="Angular" data-type="indexterm" id="id747"/><a contenteditable="false" data-primary="React" data-type="indexterm" id="id748"/> Vibe coding can accelerate each of these layers.<a contenteditable="false" data-primary="servers in web application backends" data-type="indexterm" id="id749"/><a contenteditable="false" data-primary="databases" data-secondary="in web application backends" data-secondary-sortas="web" data-type="indexterm" id="id750"/><a contenteditable="false" data-primary="APIs" data-secondary="in web application backends" data-secondary-sortas="web" data-type="indexterm" id="id751"/><a contenteditable="false" data-primary="backends" data-secondary="web application" data-type="indexterm" id="id752"/><a contenteditable="false" data-primary="frontends" data-secondary="web application" data-type="indexterm" id="id753"/></p>

<p>I’ll walk you through an end-to-end workflow for building<a contenteditable="false" data-primary="web applications, building with AI" data-secondary="end-to-end workflow" data-type="indexterm" id="id754"/> a web application with an AI pair programmer, including:</p>

<ul>
	<li>
	<p>Setting up the project and its scaffolding</p>
	</li>
	<li>
	<p>Coding the frontend UI</p>
	</li>
	<li>
	<p>Implementing backend logic</p>
	</li>
	<li>
	<p>Integrating with a database</p>
	</li>
	<li>
	<p>Testing and validating the whole stack</p>
	</li>
</ul>

<p>Along the way, I’ll highlight AI development patterns for frontends (for example, having AI generate React or Vue components from descriptions) and backends (writing routes, business logic, and database queries through natural-language prompts). I’ll also cover how to optimize collaboration between humans and AI in a full stack project, ensuring that each side contributes its strongest work. By the end of this chapter, you should have a clear roadmap for using AI not just for isolated coding tasks but for managing entire web development workflow efficiently and effectively.</p>

<section data-type="sect1" data-pdf-bookmark="Setting Up the Project: Scaffolding with AI"><div class="sect1" id="ch07_setting_up_the_project_scaffolding_with_ai_1752630044185050">
<h1>Setting Up the Project: Scaffolding with AI</h1>

<p>Every web application starts with some <em>scaffolding</em>—the initial setup of build tools, file structure, dependencies, etc. <a contenteditable="false" data-primary="dependencies" data-type="indexterm" id="id755"/><a contenteditable="false" data-primary="web applications, building with AI" data-secondary="setting up the project, scaffolding with AI" data-type="indexterm" id="ix_webappscaff"/><a contenteditable="false" data-primary="scaffolding" data-secondary="web application scaffolding using AI" data-type="indexterm" id="ix_scaff"/>AI can automate the creation of a lot of the boilerplate. Modern web frameworks often come with command-line interface (CLI) tools that can generate a base project, but you might still need to configure certain things or integrate additional libraries. An AI assistant can help by either guiding you through these CLI tools or setting up custom project structures on demand.</p>

<p>For example, suppose you want to start a new application project using React for the frontend and Express for the backend. A pre-AI workflow for this task would probably look something like this:</p>

<ol>
	<li>
	<p>Run a CLI tool or Vite to set up the React project.</p>
	</li>
	<li>
	<p>Initialize an Express app (perhaps with <code>npm init</code> and installing Express).</p>
	</li>
	<li>
	<p>Set up a proxy for development or configure <a href="https://oreil.ly/bgw1V">Cross-Origin Resource Sharing (CORS)</a> so the React frontend can talk to the Express backend.</p>
	</li>
	<li>
	<p>Maybe integrate a database like MongoDB or set up an SQLite file for simple usage.</p>
	</li>
</ol>

<p>Using an AI coding environment like Cursor or Cline, you can instead describe your desired setup in one go:</p>

<blockquote>
<p>Set up a new project with a React frontend (using Vite) and an Express backend. The backend should serve a REST API for a to-do list and use an in-memory array to start. Configure the frontend to proxy API requests to the backend in development.</p>
</blockquote>

<p>An advanced AI IDE can take this instruction and do the following:</p>

<ul>
	<li>
	<p>Create two directories (frontend and backend).</p>
	</li>
	<li>
	<p>Run <code>npm create vite@latest</code> (if it has shell access) or template out a basic React app.</p>
	</li>
	<li>
	<p>Initialize a basic Express server file in the backend, with an endpoint like <em>/api/to-dos</em> (returning some sample data).</p>
	</li>
	<li>
	<p>Include a <em>package.json</em> in each directory with relevant scripts (like <code>start both</code>).</p>
	</li>
	<li>
	<p>Set up communication between frontend and backend by either configuring a proxy in the React development server or providing instructions for implementing CORS headers.</p>
	</li>
</ul>

<p>Within a couple of minutes, you’ll have the skeleton of a full stack web app. Even if the AI doesn’t do everything automatically, it might present you with code and the instructions you need to finalize it (for example, “Add this proxy setting to your React <em>package.json</em> file”). This saves a lot of mindless setup time and allows you to focus immediately on features.</p>

<p>If you aren’t using an AI IDE, you can still use ChatGPT or another assistant step-by-step as you go; for example:</p>

<blockquote>
<p>I want to create a new React app. What commands should I run?</p>
</blockquote>

<p>The AI can guide you through steps or recommend newer alternatives like Vite or Next.js:</p>

<blockquote>
<p>Now set up an Express server with a /api/to-dos route.</p>
</blockquote>

<p>It can generate the code for the Express server, which you copy into a file:</p>

<blockquote>
<p>How do I connect my React app to this API during development?</p>
</blockquote>

<p>It might suggest either a proxy configuration or tell you how to call the API (including the full URL, if not proxying).</p>

<p>This way, even setting up the basic plumbing becomes a conversation rather than a hunt through documentation. As noted in earlier chapters, <em>programming by intent</em> means you tell the AI what outcome you want, and it figures out the steps. Setting up a project is a perfect scenario for that.</p>

<p>At this stage, it’s important to assert your architectural decisions. The AI will follow your lead. Humans are essential for architectural and high-level decisions, so decide on the stack and major patterns yourself: Do you want a monorepo or separate repos for front and back? Will you use REST or GraphQL? Which database?</p>

<p>Once you have these in mind, you can instruct the AI accordingly:</p>

<blockquote>
<p>Also set up a basic Prisma schema for the SQLite database.</p>
</blockquote>

<p>Or:</p>

<blockquote>
<p>Include a GraphQL server instead of REST.</p>
</blockquote>

<p>The AI might not perfectly execute complex setups, but it will get the bulk of the work done, and you can refine from there.</p>

<p>Many experienced developers integrate these steps into project templates or use boilerplate generators, but AI offers a more flexible approach: you can customize on the fly using natural language. This means if your project is slightly unusual (maybe you need three services instead of the usual two tiers, or you want to preconfigure a particular library like Tailwind CSS), just ask the AI to include what you want.<a contenteditable="false" data-primary="web applications, building with AI" data-secondary="setting up the project, scaffolding with AI" data-startref="ix_webappscaff" data-type="indexterm" id="id756"/><a contenteditable="false" data-primary="scaffolding" data-secondary="web application scaffolding using AI" data-startref="ix_scaff" data-type="indexterm" id="id757"/></p>

<section data-type="sect2" data-pdf-bookmark="Frontend Development Patterns with AI"><div class="sect2" id="ch07_frontend_development_patterns_with_ai_1752630044185125">
<h2>Frontend Development Patterns with AI</h2>

<p>Once the scaffolding is ready, developing the frontend of a web app is a major part of the effort.<a contenteditable="false" data-primary="web applications, building with AI" data-secondary="frontend development patterns with AI" data-type="indexterm" id="ix_webappfrnt"/> <a contenteditable="false" data-primary="frontends" data-secondary="web application frontend development patterns with AI" data-type="indexterm" id="ix_frntdevAI"/>This section explores how you can leverage an AI pair programmer for your frontend code.</p>

<section data-type="sect3" data-pdf-bookmark="Implementing components from descriptions"><div class="sect3" id="ch07_implementing_components_from_descriptions_1752630044185183">
<h3>Implementing components from descriptions</h3>

<p>You can ask the AI to create components by describing their functionality and appearance;<a contenteditable="false" data-primary="frontends" data-secondary="web application frontend development patterns with AI" data-tertiary="implementing components from descriptions" data-type="indexterm" id="id758"/> for example:</p>

<blockquote>
<p>Create a React component called TodoList that takes a list of to-do items and displays them. Each item should show its title and a checkbox to mark it complete.</p>
</blockquote>

<p>The AI should produce the code as a functional component, with props and state as needed:</p>

<blockquote>
<p>Create a Vue component for a login form with inputs for username and password, and emit an event with the form data on submit.</p>
</blockquote>

<p>The AI will likely output the <code>&lt;template&gt;</code>, <code>&lt;script&gt;</code>, and <code>&lt;style&gt;</code> sections accordingly. You, as the developer, skip writing boilerplate and directly get the structure you need. It’s then easy to tweak if needed. Often the AI will even include basic validation or state handling, if your prompt implies that they’re needed.</p>

<p>It’s important to ensure consistency at this stage. If you generate multiple components in isolation, you might need to adjust them to work together. For instance, if the <code>TodoList</code> expects items as a certain prop shape, make sure any component that uses <code>TodoList</code> provides that. You can either generate components in one prompt (so the AI is aware of everything) or simply wire them up yourself and ask the AI to fix any mismatches.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Styling and layout"><div class="sect3" id="ch07_styling_and_layout_1752630044185233">
<h3>Styling and layout</h3>

<p>CSS and styling <a contenteditable="false" data-primary="CSS" data-secondary="handling for web application frontend using AI" data-type="indexterm" id="id759"/>can be tedious. Describe<a contenteditable="false" data-primary="styling and layout for web application, using AI for" data-type="indexterm" id="id760"/> the look you want and let the <a contenteditable="false" data-primary="frontends" data-secondary="web application frontend development patterns with AI" data-tertiary="styling and layout" data-type="indexterm" id="id761"/>AI handle the CSS details:</p>

<ul>
	<li>
	<p>Style the to-do list component: use a flex column for the list, add some spacing, and change the text color of completed items to gray and crossed out.</p>
	</li>
	<li>
	<p>For the login form component, center it on the page and make the input fields larger with rounded borders.</p>
	</li>
</ul>

<p>The assistant can output CSS-in-JS, plain CSS, or inline styles, depending on context. If you’re using a framework like Tailwind CSS, you could even ask it to output the appropriate classes (though keep in mind that not all models know Tailwind <span class="keep-together">thoroughly</span>).</p>

<p>The point is: you can iterate on design without manually fiddling with CSS values. This keeps your focus at a higher level of abstraction—specifying <em>what looks good</em> rather than writing every <code>margin</code> and <code>color</code>.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Integrating APIs and state management"><div class="sect3" id="ch07_integrating_apis_and_state_management_1752630044185283">
<h3>Integrating APIs and state management</h3>

<p>Web frontends often need to fetch data from backends and manage state with something like Redux, context, or simple component state.<a contenteditable="false" data-primary="state" data-secondary="managing for web application frontend using AI" data-type="indexterm" id="id762"/><a contenteditable="false" data-primary="frontends" data-secondary="web application frontend development patterns with AI" data-tertiary="integrating APIs and state management" data-type="indexterm" id="id763"/> AI can help write these integration pieces;<a contenteditable="false" data-primary="APIs" data-secondary="integrating in web application frontend using AI" data-type="indexterm" id="id764"/> for example:</p>

<ul>
	<li>
	<p>Add code to fetch the to-do list from /api/to-dos when the <code>TodoList</code> component mounts, and store it in state.</p>
	</li>
	<li>
	<p>Implement a function in the <code>TodoList</code> that, when a checkbox is toggled, sends a <code>POST</code> request to <em>/api/to-dos/{id}/complete</em> and then updates the state accordingly.</p>
	</li>
</ul>

<p>The AI can generate the <code>useEffect</code> hook in React to do the fetch or the <code>mounted()</code> hook in Vue. It can also stub out the HTTP calls (using <code>fetch</code> or Axios, etc.). You’ll want to confirm that the API endpoints and payloads match what your backend expects (if you’ve built the backend or have a spec for it).</p>

<p>If you haven’t built the backend yet, you might simultaneously be using the AI to create it—we’ll get to that soon. But you can work on front and back in parallel with AI assistance, because each can be specified and generated relatively independently, as long as you keep track of the interface between them.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Handling complexity with AI guidance"><div class="sect3" id="ch07_handling_complexity_with_ai_guidance_1752630044185330">
<h3>Handling complexity with AI guidance</h3>

<p>If your frontend has complex logic, such as<a contenteditable="false" data-primary="complexity" data-secondary="handling frontend complex logic with AI guidance" data-type="indexterm" id="id765"/> dynamic <a contenteditable="false" data-primary="frontends" data-secondary="web application frontend development patterns with AI" data-tertiary="handling complexity with AI" data-type="indexterm" id="id766"/>form validation rules, conditional rendering, or intricate user interactions, you can implement these step-by-step with AI. A good practice is to break the problem down:</p>

<blockquote>
<p>Add a feature: when the user checks the “complete” box on a to-do, fade out that list item (CSS transition), then remove it from the list after 1 second.</p>
</blockquote>

<p>The AI might produce the code to add a CSS class on check and use a timeout to remove the item, including the necessary CSS for fading out:</p>

<blockquote>
<p>The form has an optional field for ‘notes’. Only show the notes text area if an ‘Add notes’ checkbox is checked.</p>
</blockquote>

<p>The AI can modify the component state and JSX to conditionally render the notes field.</p>

<p>Each of these can be an iterative prompt. Essentially, you describe the UX behavior and AI writes the code. Always test after each addition to ensure it behaves as expected.</p>
</div></section>

<section class="pagebreak-before" data-type="sect3" data-pdf-bookmark="Framework-specific tips"><div class="sect3" id="ch07_framework_specific_tips_1752630044185377">
<h3 class="less_space">Framework-specific tips</h3>

<p>Different frameworks <a contenteditable="false" data-primary="frontends" data-secondary="web application frontend development patterns with AI" data-tertiary="framework-specific tips" data-type="indexterm" id="id767"/>have different idioms:</p>

<ul>
	<li>
	<p>In React, the<a contenteditable="false" data-primary="hooks in React" data-type="indexterm" id="id768"/> AI might use hooks (like <code>useState</code>, <code>useEffect</code>). Double-check that it’s following best practices (for instance, that the dependencies array in <code>use​Ef⁠fect</code> is correct).<a contenteditable="false" data-primary="dependencies" data-secondary="in React useEffect hook" data-secondary-sortas="React" data-type="indexterm" id="id769"/><a contenteditable="false" data-primary="React" data-secondary="tips on" data-type="indexterm" id="id770"/></p>
	</li>
	<li>
	<p>In Vue, the AI might output Options API style or Composition API style depending on what it has seen.<a contenteditable="false" data-primary="Vue" data-secondary="tips on" data-type="indexterm" id="id771"/> If you prefer one, you should specify that (for instance, “Use Vue 3 Composition API”).</p>
	</li>
	<li>
	<p>In Angular, the AI can generate components, but Angular has a steeper learning curve.<a contenteditable="false" data-primary="Angular" data-secondary="tips on" data-type="indexterm" id="id772"/> The AI might be able to produce a template, a TypeScript class, and basic service injection on request, but you’ll likely need to do more manual work or use Angular CLI for structure, then ask AI to fill in specific parts (like form validation logic).<a contenteditable="false" data-primary="web applications, building with AI" data-secondary="frontend development patterns with AI" data-startref="ix_webappfrnt" data-type="indexterm" id="id773"/><a contenteditable="false" data-primary="frontends" data-secondary="web application frontend development patterns with AI" data-startref="ix_frntdevAI" data-type="indexterm" id="id774"/></p>
	</li>
</ul>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Backend/API Development Patterns with AI"><div class="sect2" id="ch07_backend_api_development_patterns_with_ai_1752630044185445">
<h2>Backend/API Development Patterns with AI</h2>

<p>Now let’s turn to the backend.<a contenteditable="false" data-primary="web applications, building with AI" data-secondary="backend/API development patterns with AI" data-type="indexterm" id="ix_webappbck"/> <a contenteditable="false" data-primary="APIs" data-secondary="backend/API development patterns with AI" data-type="indexterm" id="ix_APIbck"/>Using AI to build the server side of a web application follows a similar paradigm: you describe the endpoints, data models, and logic you want, and the AI produces code. Common backend components include route handlers, business logic, database interactions, and validations. AI can help with all of these.<a contenteditable="false" data-primary="business logic" data-secondary="in backend components of web application" data-secondary-sortas="backend" data-type="indexterm" id="id775"/></p>

<section data-type="sect3" data-pdf-bookmark="Implementing API endpoints"><div class="sect3" id="ch07_implementing_api_endpoints_1752630044185500">
<h3>Implementing API endpoints</h3>

<p>Suppose you’re building a <a contenteditable="false" data-primary="APIs" data-secondary="backend/API development patterns with AI" data-tertiary="implementing endpoints" data-type="indexterm" id="id776"/>RESTful API for <a contenteditable="false" data-primary="RESTful APIs" data-secondary="endpoints" data-type="indexterm" id="id777"/>your to-do list app.<a contenteditable="false" data-primary="backends" data-secondary="backend/API development patterns with AI" data-tertiary="implementing endpoints" data-type="indexterm" id="id778"/> You might have endpoints like <code>GET /to-dos</code>, <code>POST /to-dos</code>, <code>PUT /to-dos/:id</code>, <code>DELETE /to-dos/:id</code>. <a contenteditable="false" data-primary="routing AI endpoints" data-type="indexterm" id="id779"/><a contenteditable="false" data-primary="endpoints" data-secondary="implementing for backend API" data-type="indexterm" id="id780"/> You can go endpoint by endpoint:</p>

<ul>
	<li>
	<p>In the Express app, add a <code>GET /api/to-dos</code> route that returns the list of to-dos (just use an array stored in memory for now).<a contenteditable="false" data-primary="Express routes" data-type="indexterm" id="id781"/></p>
	</li>
	<li>
	<p>Add a <code>POST /api/to-dos</code> route that accepts a JSON body and adds a new to-do to the list. Return the new to-do with an ID.</p>
	</li>
</ul>

<p>The AI will write the Express route handlers accordingly, likely using something like <code>app.get('/api/to-dos', ...)</code>. If you’ve indicated that you’re using Express with JSON, it might include the necessary middleware if it’s not already present:</p>

<pre data-type="programlisting">
app.use(express.json())</pre>

<p>As your backend grows, you can ask the AI to refactor:</p>

<blockquote>
<p>Refactor the Express routes into a separate router module.</p>
</blockquote>

<p>It might split the routes out into a separate file, which is a good practice for maintainability.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Database integration"><div class="sect3" id="ch07_database_integration_1752630044185547">
<h3>Database integration</h3>

<p>You might use <a contenteditable="false" data-primary="backends" data-secondary="backend/API development patterns with AI" data-tertiary="database integration" data-type="indexterm" id="id782"/>in-memory <a contenteditable="false" data-primary="databases" data-secondary="integration in web application backend using AI" data-type="indexterm" id="id783"/>data for a prototype, but for a more complete application, you’ll want a database. <a contenteditable="false" data-primary="PostgreSQL" data-type="indexterm" id="id784"/><a contenteditable="false" data-primary="MongoDB" data-type="indexterm" id="id785"/>Let’s say you choose MongoDB or PostgreSQL. You can prompt:</p>

<blockquote>
<p>Integrate MongoDB into the Express app using Mongoose. Create a to-do model with fields: title (string), completed (boolean). Modify the GET/POST routes to use the database instead of an in-memory array.</p>
</blockquote>

<p>The AI may output the Mongoose model definition and adjust the route handlers to query the database (like <code>Todo.find()</code> for <code>GET</code> and <code>Todo.create()</code> for <code>POST</code>). Similarly, for SQL, you could ask it to set up an <a href="https://oreil.ly/AoWDL"><em>object-relational mapping</em> (ORM)</a> like Prisma or Sequelize.<a contenteditable="false" data-primary="ORMs (object-relational mappers)" data-type="indexterm" id="id786"/> Keep in mind you might need to provide configuration details (like connection strings). The AI might not know your database URI; you’ll have to slot that in. But it will handle the generic code.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Business logic and validation"><div class="sect3" id="ch07_business_logic_and_validation_1752630044185594">
<h3>Business logic and validation</h3>

<p>If your backend <a contenteditable="false" data-primary="business logic" data-secondary="in web application backend" data-secondary-sortas="web" data-type="indexterm" id="id787"/>has<a contenteditable="false" data-primary="backends" data-secondary="backend/API development patterns with AI" data-tertiary="business logic and validation" data-type="indexterm" id="id788"/> specific<a contenteditable="false" data-primary="validation" data-secondary="in backend/API development with AI" data-secondary-sortas="backend" data-type="indexterm" id="id789"/> rules (for example, that users cannot delete a to-do that is marked important or that list titles must be unique), you can encode those via AI:</p>

<blockquote>
<p>Add validation to the <code>POST /api/to-dos</code> route: reject if the title is empty or longer than 100 chars, and return 400 status.</p>
</blockquote>

<p>The AI will include checks and send proper responses.</p>

<blockquote>
<p>Add logic: when a to-do is marked complete (say via <code>PUT /api/to-dos/:id</code>), if all to-dos are complete, log a message ‘All done!’</p>
</blockquote>

<p>It can insert that logic in the <code>PUT</code> handler.</p>

<p>You describe these requirements in plain terms, and the AI modifies the code accordingly. You still need to test that the code does what you expect.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Using frameworks or boilerplates"><div class="sect3" id="ch07_using_frameworks_or_boilerplates_1752630044185643">
<h3>Using frameworks or boilerplates</h3>

<p>Many web backends use <a contenteditable="false" data-primary="backends" data-secondary="backend/API development patterns with AI" data-tertiary="using frameworks or boilerplates" data-type="indexterm" id="id790"/>frameworks <a contenteditable="false" data-primary="frameworks" data-secondary="using in web application backends" data-type="indexterm" id="id791"/>beyond raw Express (like NestJS for Node or Django for Python). <a contenteditable="false" data-primary="Django" data-type="indexterm" id="id792"/>AI can work with those, too, though you may have to break down more involved tasks:</p>

<ul>
	<li>
	<p>For Django (Python), you might prompt:</p>
<blockquote>
<p>Create a Django model for to-do with fields X, and corresponding views for list and create.</p>
</blockquote>
	</li>
	<li>
	<p>The AI might output model code and a generic view or DRF (Django REST Framework) serializer/viewset if it knows that context.</p>
	</li>
	<li>
	<p>For Ruby on Rails, you can get help generating models and controllers. (At that point, you might just use Rails scaffolding, but the AI could supplement by adding validations or adjusting routes).<a contenteditable="false" data-primary="Ruby on Rails" data-type="indexterm" id="id793"/></p>
	</li>
</ul>

<p>AI models demonstrate varying levels of proficiency across different programming languages and technology stacks, largely determined by the prevalence of those technologies in their training data. While models can work with any language they’ve encountered during training, their effectiveness varies significantly. Popular languages like JavaScript, Python, and Java typically receive stronger support due to their abundant representation in open source repositories, documentation, and educational materials that form part of the training corpus.</p>

<p>Determining a model’s proficiency with your chosen stack requires practical evaluation. Start by testing the model with basic tasks in your target language, then progressively increase complexity to gauge its capabilities. Pay attention to whether the model generates idiomatic code that follows language-specific conventions, recognizes common frameworks and libraries without extensive explanation, and suggests appropriate design patterns for that ecosystem. Strong proficiency manifests as contextually appropriate suggestions, while weaker support often results in generic or outdated code patterns.</p>

<p>Many AI providers publish documentation about their models’ capabilities, though these rarely include detailed language-specific benchmarks. The most reliable approach involves running small experiments with your actual technology stack. For instance, if you’re working with Ruby on Rails, test whether the model understands Rails conventions like ActiveRecord patterns or can generate proper RSpec tests. Similarly, for newer frameworks or less common languages, expect more variable results, and be prepared to provide additional context in your prompts to compensate for potential gaps in the model’s training.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Orchestrating multistep operations"><div class="sect3" id="ch07_orchestrating_multistep_operations_1752630044185691">
<h3>Orchestrating multistep operations</h3>

<p>Some endpoints might involve multiple steps, like creating an entry in one table and then another, or calling an external API. <a contenteditable="false" data-primary="endpoints" data-secondary="multistep operations, orchestrating" data-type="indexterm" id="id794"/><a contenteditable="false" data-primary="APIs" data-secondary="backend/API development patterns with AI" data-tertiary="multistep operations at endpoints, orchestrating" data-type="indexterm" id="id795"/>You can outline the sequence and let the AI draft it:</p>

<blockquote>
<p>When a new user signs up (<code>POST /api/users</code>), create a user record and also send a welcome email via SendGrid API.</p>
</blockquote>

<p>The AI can write code to<a contenteditable="false" data-primary="ORMs (object-relational mappers)" data-type="indexterm" id="id796"/> save<a contenteditable="false" data-primary="object-relational mappers" data-see="ORMs" data-type="indexterm" id="id797"/> the user (maybe using an object-relational mapper, or ORM) and then an HTTP<a contenteditable="false" data-primary="transactions, implementing in web application backend" data-type="indexterm" id="id798"/> request to SendGrid’s API with appropriate payload. You’d fill in actual API keys or tweak content, but most of the boilerplate is done:</p>

<blockquote>
<p>Implement a transaction: when transferring money (<code>POST /api/transfer</code>), deduct from account A and add to account B, ensure it’s atomic (all-or-nothing).</p>
</blockquote>

<p>If you’re using an ORM or database that<a contenteditable="false" data-primary="databases" data-secondary="in web application backends" data-secondary-sortas="web" data-tertiary="transactions in" data-type="indexterm" id="id799"/> supports transactions, the AI might use those features (like an SQL transaction block or an ORM’s transaction method). Review such code cautiously for correctness—transaction logic, especially, can be tricky. But the AI might know common pitfalls and include checks. For instance, when prompted to handle a money transfer endpoint, an AI generated the following code structure:</p>

<pre data-code-language="javascript" data-type="programlisting">
<code class="sb">```</code>
<code class="sb">async function transferMoney(fromAccountId, toAccountId, amount) {</code>
<code class="sb">  const session = await db.startSession();</code>
  
<code class="sb">  try {</code>
<code class="sb">    await session.startTransaction();</code>
    
<code class="sb">    // Deduct from source account</code>
<code class="sb">    const sourceAccount = await Account.findByIdAndUpdate(</code>
<code class="sb">      fromAccountId,</code>
<code class="sb">      { $inc: { balance: -amount } },</code>
<code class="sb">      { session, new: true }</code>
<code class="sb">    );</code>
    
<code class="sb">    if (sourceAccount.balance &lt; 0) {</code>
<code class="sb">      throw new Error('Insufficient funds');</code>
<code class="sb">    }</code>
    
<code class="sb">    // Add to destination account</code>
<code class="sb">    await Account.findByIdAndUpdate(</code>
<code class="sb">      toAccountId,</code>
<code class="sb">      { $inc: { balance: amount } },</code>
<code class="sb">      { session }</code>
<code class="sb">    );</code>
    
<code class="sb">    await session.commitTransaction();</code>
<code class="sb">    return { success: true };</code>

<code class="sb">  } catch (error) {</code>
<code class="sb">    await session.abortTransaction();</code>
<code class="sb">    throw error;</code>
<code class="sb">  } finally {</code>
<code class="sb">    session.endSession();</code>
<code class="sb">  }</code>
<code class="sb">}</code>
<code class="sb">```</code></pre>

<p>The AI correctly wrapped both database operations in a transaction, included validation for insufficient funds, and properly handled rollback on any error. While you’d still need to review edge cases and add appropriate logging, the fundamental transaction structure demonstrates understanding of atomic operations.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="API documentation and testing"><div class="sect3" id="ch07_api_documentation_and_testing_1752630044185738">
<h3>API documentation and testing</h3>

<p>When building APIs, you can also have the AI produce documentation. <a contenteditable="false" data-primary="APIs" data-secondary="backend/API development patterns with AI" data-tertiary="API documentation and testing" data-type="indexterm" id="id800"/><a contenteditable="false" data-primary="documentation" data-secondary="produced by AI for web application backend API" data-type="indexterm" id="id801"/>For instance, <em>“Write a brief documentation for the /api/to-dos endpoints.”</em> It may generate something like this:</p>

<pre data-type="programlisting">
GET /api/to-dos - returns list of to-dos.
POST /api/to-dos - create a new to-do. Expects JSON: {title: string}. Returns the created to-do.
...</pre>

<p>This is handy for quick reference and also to share with frontend developers (if you’re working in a team). <a contenteditable="false" data-primary="testing" data-secondary="AI generating tests for web application backend API" data-type="indexterm" id="id802"/>Additionally, you can use AI to write tests for your API endpoints, using a testing framework like Jest or Mocha for Node, or PyTest for a Python API. With a prompt like “Generate tests for the to-dos API (one test for listing, one for creating, one for validation error),” the AI will output test code that you can run and verify.<a contenteditable="false" data-primary="web applications, building with AI" data-secondary="backend/API development patterns with AI" data-startref="ix_webappbck" data-type="indexterm" id="id803"/><a contenteditable="false" data-primary="APIs" data-secondary="backend/API development patterns with AI" data-startref="ix_APIbck" data-type="indexterm" id="id804"/> </p>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Database Design and Integration"><div class="sect1" id="ch07_database_design_and_integration_1752630044185788">
<h1>Database Design and Integration</h1>

<p>Human knowledge of the business <a contenteditable="false" data-primary="databases" data-secondary="design and integration in web application using AI" data-type="indexterm" id="ix_DBdes"/>domain is <a contenteditable="false" data-primary="web applications, building with AI" data-secondary="database design and integration" data-type="indexterm" id="ix_webappDB"/>crucial in designing a database schema, but AI can assist in translating that design into code (like migration scripts or ORM models). Also, if you’re unsure about your schema, you can brainstorm with the AI.</p>

<p>For example, say your app is expanding beyond to-do lists to become a full project-management tool. You need to design several tables: Projects, Tasks, Users, and so on. You could ask, “What data models would I need for a simple project management app with users, projects, and tasks? Include relationships.” The AI might respond with something like this:</p>

<ul>
	<li>
	<p>User (id, name, email, etc.)</p>
	</li>
	<li>
	<p>Project (id, name, owner_id referencing User)</p>
	</li>
	<li>
	<p>Task (id, description, project_id, assigned_to (User), status, etc.)</p>
	</li>
</ul>

<p>It might not be exactly what you want, but it gives you a starting point. You confirm or tweak these design ideas, then implement them.</p>

<section data-type="sect2" data-pdf-bookmark="Using an ORM"><div class="sect2" id="ch07_using_an_orm_1752630044185839">
<h2>Using an ORM</h2>

<p>If you <a contenteditable="false" data-primary="databases" data-secondary="design and integration in web application using AI" data-tertiary="using an ORM" data-type="indexterm" id="id805"/>use an ORM like Prisma, Entity <a contenteditable="false" data-primary="ORMs (object-relational mappers)" data-secondary="AI generating model classes or schemas for web application database" data-type="indexterm" id="id806"/>Framework, or SQLAlchemy, you can have the AI generate model<a contenteditable="false" data-primary="Sequelize" data-type="indexterm" id="id807"/> classes or schema definitions:</p>

<blockquote>
<p>Using Sequelize (for Node), define models for User, Project, Task with associations: One User has many Projects, Project belongs to User; Project has many Tasks, Task belongs to Project; Task can be assigned to a User (many-to-one).</p>
</blockquote>

<p>The AI would then write JS/TS code to define those Sequelize models and associations, which you can then integrate into your codebase. It might also suggest foreign keys or cascade rules if it’s familiar with them.</p>

<p>If you aren’t using an ORM and you’re<a contenteditable="false" data-primary="SQL" data-secondary="AI generating SQL migration scripts" data-type="indexterm" id="id808"/> writing raw SQL migrations, you could even have the AI draft migration scripts:</p>

<blockquote>
<p>Write an SQL script to create tables for users, projects, tasks with appropriate foreign keys.</p>
</blockquote>

<p>It will output an SQL DDL script, which you can review for correctness and run.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Database Queries"><div class="sect2" id="ch07_database_queries_1752630044185894">
<h2>Database Queries</h2>

<p>When integrating the database in your code, you<a contenteditable="false" data-primary="databases" data-secondary="design and integration in web application using AI" data-tertiary="database queries" data-type="indexterm" id="id809"/> might need <a contenteditable="false" data-primary="SQL" data-secondary="database query written using AI" data-type="indexterm" id="id810"/>queries more complex than simple CRUD. Suppose you want to get all projects, along with their tasks and the user assigned to each task—that’s a join across Project, Task, User. You could prompt:</p>

<blockquote>
<p>Write an SQL query to retrieve projects with their tasks and each task’s assigned user name.</p>
</blockquote>

<p>The AI could produce an SQL join query for you.</p>

<p>Or if you’re using an ORM:</p>

<blockquote>
<p>Using Sequelize, fetch all projects with associated tasks and the user for each task.</p>
</blockquote>

<p>You could expect the code to come with something to load related data, like:</p>

<pre data-type="programlisting">
include: [Task, { model: User, as: 'assignedUser' }]</pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Checking AI-Generated Queries"><div class="sect2" id="ch07_checking_ai_generated_queries_1752630044185945">
<h2>Checking AI-Generated Queries</h2>

<p>Database operations require careful verification to ensure <a contenteditable="false" data-primary="databases" data-secondary="design and integration in web application using AI" data-tertiary="checking AI-generated queries" data-type="indexterm" id="id811"/>the AI-generated code aligns with your actual schema and maintains data integrity. The AI cannot automatically know your specific table names, field names, or relationships unless you provide this information explicitly in your prompt. Even when models have conversation memory, you should include schema details in each complex database-related prompt to ensure accuracy. This explicit approach prevents the common issue of AI-generated queries that reference generic field names like <code>user_id</code> when your schema actually uses <code>userId</code> or <code>customer_ref</code>.</p>

<p>Performance considerations often require human oversight. <a contenteditable="false" data-primary="performance" data-secondary="AI-generated database queries" data-type="indexterm" id="id812"/>While AI models understand basic database concepts like primary keys and joins, they may not automatically suggest performance optimizations such as adding indexes on frequently queried fields or considering query execution plans. Review generated queries for efficiency, particularly for operations that will run frequently or against large datasets.</p>

<p>Data consistency rules represent another critical area<a contenteditable="false" data-primary="data consistency rules (database)" data-type="indexterm" id="id813"/> requiring explicit specification. When implementing delete operations, clearly define the cascading behavior you expect. <a contenteditable="false" data-primary="deletes" data-secondary="cascading deletes in databases" data-type="indexterm" id="id814"/><a contenteditable="false" data-primary="cascading deletes in databases" data-type="indexterm" id="id815"/>For example, when deleting a <code>Project</code> record, you must decide whether the database should automatically delete associated <code>Task</code> records through cascading deletes or whether your application logic should handle this cleanup. Communicate these business rules clearly to the AI:</p>

<blockquote>
<p>When a project is deleted, configure the database to cascade delete all related tasks.</p>
</blockquote>

<p>Or alternatively:</p>

<blockquote>
<p>When deleting a project, first check for existing tasks and prevent deletion if any exist.</p>
</blockquote>

<p>The AI can implement either approach effectively when given clear direction. For cascade deletes, it might generate foreign key constraints with <code>ON DELETE CASCADE</code>.  For application-level handling, it could produce code that queries for related records before permitting deletion. The key lies in explicitly stating your data-integrity requirements rather than assuming the AI will infer the appropriate behavior for your specific domain.<a contenteditable="false" data-primary="databases" data-secondary="design and integration in web application using AI" data-startref="ix_DBdes" data-type="indexterm" id="id816"/><a contenteditable="false" data-primary="web applications, building with AI" data-secondary="database design and integration" data-startref="ix_webappDB" data-type="indexterm" id="id817"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Full Stack Integration: Marrying Frontend and Backend"><div class="sect1" id="ch07_full_stack_integration_marrying_frontend_and_back_1752630044186003">
<h1>Full Stack Integration: Marrying Frontend and Backend</h1>

<p>Now that you’ve built both your frontend and backend with AI help, the next challenge is integrating them into a seamless web application.<a contenteditable="false" data-primary="web applications, building with AI" data-secondary="full stack integration" data-type="indexterm" id="ix_webappinteg"/> This involves making sure that the API endpoints are called correctly from the frontend, the data flows properly, and the overall system is coherent.<a contenteditable="false" data-primary="frontends" data-secondary="integrating with backend in web application using AI" data-type="indexterm" id="ix_frntinte"/><a contenteditable="false" data-primary="backends" data-secondary="integrating with frontend in web application using AI" data-type="indexterm" id="ix_bckinte"/></p>

<section data-type="sect2" data-pdf-bookmark="Aligning Frontend and Backend Contracts"><div class="sect2" id="ch07_aligning_frontend_and_backend_contracts_1752630044186058">
<h2>Aligning Frontend and Backend Contracts</h2>

<p>This is crucial: the frontend expects to receive data in a certain shape, so what the backend sends should match that expectation.<a contenteditable="false" data-primary="web applications, building with AI" data-secondary="full stack integration" data-tertiary="aligning frontend and backend contracts" data-type="indexterm" id="id818"/><a contenteditable="false" data-primary="backends" data-secondary="integrating with frontend in web application using AI" data-tertiary="aligning frontend and backend contracts" data-type="indexterm" id="id819"/><a contenteditable="false" data-primary="frontends" data-secondary="integrating with backend in web application using AI" data-tertiary="aligning frontend and backend contracts" data-type="indexterm" id="id820"/> If you let AI work on each end in isolation, small mismatches can occur (maybe the backend returns <code>{ success: true, data: [...] }</code>, but the frontend expects to receive the array directly). To avoid this, you can explicitly instruct the AI on the response format to use when coding both sides. Alternately, once both are done, test an end-to-end call: for instance, open the web app and see if the list loads. If it doesn’t, check the browser console against the server logs.</p>

<p>I often use the AI to adjust one side to match the other:</p>

<ul>
	<li>
	<p>If the backend returns slightly different JSON key names than what the frontend expects and you notice a bug, you can say to the AI (on either side):</p>
<blockquote>
<p>Modify the code to use ‘tasks’ (plural) instead of ‘taskList’ (singular) in the JSON.</p>
</blockquote>
</li>
	<li>
	<p>If the frontend is sending form data as form-encoded but the backend expects JSON, you can ask the AI to convert that, maybe by using <code>JSON.stringify</code> on the frontend or adding <code>body-parser</code> on the backend.</p>
	</li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Real-Time Collaboration with AI"><div class="sect2" id="ch07_real_time_collaboration_with_ai_1752630044186111">
<h2>Real-Time Collaboration with AI</h2>

<p>AI-augmented IDEs that hold the context of the whole project, like Cline or Cursor, can be especially helpful during this integration phase.<a contenteditable="false" data-primary="AI (artificial intelligence)" data-secondary="real-time collaboration with in full stack development" data-type="indexterm" id="ix_AIcollab"/><a contenteditable="false" data-primary="web applications, building with AI" data-secondary="full stack integration" data-tertiary="real-time collaboration with AI" data-type="indexterm" id="ix_webappintegAI"/><a contenteditable="false" data-primary="IDEs (integrated development environments)" data-secondary="AI-augmented, using in full stack development for web application" data-type="indexterm" id="id821"/><a contenteditable="false" data-primary="backends" data-secondary="integrating with frontend in web application using AI" data-tertiary="real-time collaboration with AI" data-type="indexterm" id="ix_bckinteAI"/><a contenteditable="false" data-primary="frontends" data-secondary="integrating with backend in web application using AI" data-tertiary="real-time collaboration with AI" data-type="indexterm" id="ix_frntinteAI"/> You could open the frontend and backend files side by side in your IDE-based tool and prompt:</p>

<blockquote>
<p>Ensure that the frontend fetch from /api/to-dos matches the Express route’s expected request/response. Fix any discrepancies.</p>
</blockquote>

<p>The AI might then harmonize the content (like adding await response.json() in the frontend if it was missing or adjusting the JSON structure).</p>

<section data-type="sect3" data-pdf-bookmark="State management and sync"><div class="sect3" id="ch07_state_management_and_sync_1752630044186167">
<h3>State management and sync</h3>

<p>In a full stack app, consider implementing<a contenteditable="false" data-primary="state" data-secondary="managing using AI in full stack web app" data-type="indexterm" id="id822"/> things like loading states<a contenteditable="false" data-primary="synchronization and state management in full stack web app" data-type="indexterm" id="id823"/> and error handling on the frontend for failed API calls for a professional result.<a contenteditable="false" data-primary="APIs" data-secondary="failed calls, error handling on frontend" data-type="indexterm" id="id824"/> You might use prompts like:</p>

<blockquote>
<p>Add loading indicators: when the React component is fetching tasks, show a ‘Loading...’ text until data is loaded.</p>
</blockquote>

<p>Or:</p>

<blockquote>
<p class="fix_tracking">Handle errors: if the API call fails (non-200 response), show an error message on the UI.</p>
</blockquote>

<p>It will add the <code>isLoading</code> state and conditional rendering or implement a try/catch around <code>fetch</code> to catch errors and display a message. This kind of polish makes your app <em>feel</em> robust.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="WebSockets and advanced integrations"><div class="sect3" id="ch07_websockets_and_advanced_integrations_1752630044186214">
<h3>WebSockets and advanced integrations</h3>

<p>If your <a contenteditable="false" data-primary="WebSockets" data-secondary="setting up using AI in full stack web app" data-type="indexterm" id="id825"/>app requires real-time updates (like using WebSockets or SSE), you might prompt something like this:</p>

<blockquote>
<p>Set up a WebSocket using Socket.io. When a new task is created on the server, broadcast it to all connected clients. Modify the frontend to listen for new tasks and add them to the list in real time.</p>
</blockquote>

<p>This is complex, but an AI might generate the server-side Socket.io setup (like adding <code>io.on('connection', ...)</code> and emitting an event upon creation of a new task), as well as client-side code to connect and listen for that event. You would need to integrate this carefully, but it’s quite astonishing that these descriptions can lead to working real-time code. If it doesn’t work perfectly off the bat, iterative prompting and testing can get it there.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Example: full stack flow with AI"><div class="sect3" id="ch07_example_full_stack_flow_with_ai_1752630044186262">
<h3>Example: full stack flow with AI</h3>

<p>To illustrate, let’s imagine you’re <a contenteditable="false" data-primary="full stack flow with AI (example)" data-type="indexterm" id="id826"/>building a simple contact-manager web app:</p>

<ul>
	<li>
	<p>You scaffold a React frontend and a Node/Express backend, as you did earlier in the chapter.</p>
	</li>
	<li>
	<p>First, for the frontend, prompt for a <code>ContactList</code> and a <code>ContactForm</code> component. Then prompt to add API calls:</p>

<blockquote>
<p>In ContactList, fetch contacts from <em>/api/contacts</em> on mount.</p>

<p>In ContactForm, on submit, send a <code>POST</code> to <em>/api/contacts</em> with the form data, then update the list of contacts on success.</p>
</blockquote>
</li>
	<li>
	<p>For the backend, you may want to use an in-memory array or integrate a database first. Then prompt for Express routes <code>GET /api/contacts</code> (to return a list) and <code>POST /api/contacts</code> (to add a contact to the database or memory).</p>
	</li>
	<li>
	<p>Try adding a contact via the UI. If it shows up in the list, great. If not, debug. Maybe the <code>POST</code> route didn’t return the new contact properly or the form code didn’t refresh the list. Identify the gap and prompt the AI to fix it:</p>

	<blockquote>
	<p>After adding a contact, the backend should return the new contact object in the response, and the frontend should append it to the list without requiring a full reload.</p>
	</blockquote>

	<p>This might lead the AI to adjust the backend response and frontend state logic to push the new contact (maybe using React state update).</p>
	</li>
	<li>
	<p>Implement edit and delete functions similarly, each time letting AI handle the routine parts and focusing your input on <em>what the feature should do</em>.</p>
	</li>
</ul>

<p>Doing all this manually could easily amount to a week or two of work for a junior dev but could be done in a day or two with an AI codeveloper, given that a lot of template code and wiring is automated.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Optimizing AI-human collaboration in full stack development"><div class="sect3" id="optimizingaich7sub">
<h3>Optimizing AI-human collaboration in full stack development</h3>

<p>When working through an entire stack, it’s useful to establish a productive rhythm with your AI assistant.<a contenteditable="false" data-primary="human contribution, maximizing" data-secondary="AI-human collaboration in full stack development" data-type="indexterm" id="id827"/><a contenteditable="false" data-primary="AI-human collaboration, optimizing in full stack development" data-type="indexterm" id="id828"/> Here are some strategies to optimize your collaboration:</p>

<dl>
	<dt>Use the AI for boilerplate; write any custom logic yourself</dt>
	<dd>
	<p>Identify which parts of the code are mundane and which are the unique core logic. Let the AI generate a CRUD API or a standard component—but if there’s a particularly tricky piece of logic, maybe a proprietary algorithm or a specific business rule that is easier to implement directly, do that part manually, then ask the AI to review or test it. Think of it as delegating repetitive tasks to the AI, while you handle the novel ones.</p>
	</dd>
	<dt>Use AI to tackle your to-do list one item at a time</dt>
	<dd>
	<p>As you develop, keep track of tasks (like features to add and bugs to fix). Then explain each task to the AI, one by one, and let it propose a solution. For example, let’s say you have a note that reads “Implement password hashing on user registration.” Try a prompt like this:</p>
	</dd>
	<dd>
	<blockquote>
	<p>Add password hashing using bcrypt in the <code>POST /api/register</code> route before saving the user.</p>
	</blockquote>
	</dd>
	<dd>
	<p>This targeted, systematic approach helps ensure you don’t forget anything.</p>
	</dd>
	<dt>Prompt AI to improve code quality as you go</dt>
	<dd>
	<p>After achieving functionality, you might prompt, “Refactor this code for better readability” or “Optimize this function.” The AI can often make the code cleaner or suggest performance improvements, like an assistant doing a second pass for polish under your supervision. Be sure to verify that any changes still pass your tests.</p>
	</dd>
	<dt>Use AI for cross-checking</dt>
	<dd>
	<p>If you’re uncertain about your design approach, ask the AI:</p>
	</dd>
	<dd>
	<blockquote>
	<p>Is using an array to store contacts in memory fine or should I use a database? What are the pros and cons?</p>
	</blockquote>
	</dd>
	<dd>
	<p>While you likely know the answer (use a database for persistence), it’s like bouncing ideas off a colleague. Sometimes the AI might mention a consideration you hadn’t thought of:</p>
	</dd>
	<dd>
	<blockquote>
	<p>If there are multiple server instances, an in-memory store won’t sync across them.</p>
	</blockquote>
	</dd>
	<dt>Use AI to coordinate with your team</dt>
	<dd>
	<p>If you’re working in a team, not everyone may be using the AI directly. In that case, make sure to ask the AI to document what you did. Also, it’s good to communicate your approach to the team: “I used an AI to generate these controllers quickly. I’ve checked them, but keep an eye out for any unconventional patterns.” Encourage a code-review culture in which everyone reviews AI-written code just like they would any other code to catch any quirks.</p>
	</dd>
</dl>

<p>Real-world teams that adopt AI (like those at <a href="https://oreil.ly/8Dmn7">Snyk</a>) report that it can boost productivity, but they also stress keeping a human in the loop for validation. In one <a href="https://oreil.ly/oivAx">2024 survey by GitHub</a>, 97% of developers reported using AI coding tools at work in some capacity.<a contenteditable="false" data-primary="AI (artificial intelligence)" data-secondary="real-time collaboration with in full stack development" data-startref="ix_AIcollab" data-type="indexterm" id="id829"/><a contenteditable="false" data-primary="web applications, building with AI" data-secondary="full stack integration" data-startref="ix_webappintegAI" data-tertiary="real-time collaboration with AI" data-type="indexterm" id="id830"/><a contenteditable="false" data-primary="backends" data-secondary="integrating with frontend in web application using AI" data-startref="x_bckinteAI" data-tertiary="real-time collaboration with AI" data-type="indexterm" id="id831"/><a contenteditable="false" data-primary="frontends" data-secondary="integrating with backend in web application using AI" data-startref="ix_frntinteAI" data-tertiary="real-time collaboration with AI" data-type="indexterm" id="id832"/><a contenteditable="false" data-primary="frontends" data-secondary="integrating with backend in web application using AI" data-startref="ix_frntinte" data-type="indexterm" id="id833"/><a contenteditable="false" data-primary="backends" data-secondary="integrating with frontend in web application using AI" data-startref="ix_bckinte" data-type="indexterm" id="id834"/><a contenteditable="false" data-primary="web applications, building with AI" data-secondary="full stack integration" data-startref="ix_webappinteg" data-type="indexterm" id="id835"/></p>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Testing and Validation for AI-Generated Web Applications"><div class="sect1" id="ch07_testing_and_validation_for_ai_generated_web_applic_1752630044186317">
<h1>Testing and Validation for AI-Generated Web Applications</h1>

<p>After building your web app with AI help, test <a contenteditable="false" data-primary="web applications, building with AI" data-secondary="testing and validation" data-type="indexterm" id="ix_webappAItst"/>thoroughly <a contenteditable="false" data-primary="testing" data-secondary="for AI-generated web applications" data-secondary-sortas="AI-generated" data-type="indexterm" id="ix_tstAIwa"/>to ensur<a contenteditable="false" data-primary="validation" data-secondary="for AI-generated web applications" data-secondary-sortas="AI-generated" data-type="indexterm" id="ix_valAIwebapp"/>e everything works as intended and to catch issues that you or the AI might have introduced. Here’s how you can approach testing in this AI-assisted context:</p>

<dl>
	<dt>Unit tests</dt>
	<dd>
	<p>For backend logic, write unit tests for critical functions (like a function that calculates something or validates input). <a contenteditable="false" data-primary="unit tests" data-secondary="for AI-generated web applications" data-secondary-sortas="AI-generated" data-type="indexterm" id="id836"/>If the AI wrote the function, writing a test for it can reveal any hidden bugs. You can even have the AI generate these tests, as mentioned. Be cautious, though: AI-generated tests are sometimes trivial or assume an implementation, so you may need to guide it to test edge cases:</p>
	</dd>
	<dd>
	<blockquote>
	<p>Write tests for the password strength function, including edge cases like empty password, very long password, password with special chars, etc.</p>
	</blockquote>
	</dd>
	<dt>Integration tests</dt>
	<dd>
	<p>Test the API endpoints with <a contenteditable="false" data-primary="integration tests" data-secondary="for AI-generated web applications" data-secondary-sortas="AI-generated" data-type="indexterm" id="id837"/>something like Supertest (for Node) or direct HTTP calls. Check that each endpoint returns the expected results. AI can help you scaffold these:</p>
	</dd>
	<dd>
	<blockquote>
	<p>Write integration tests for the /api/to-dos endpoints using Jest and Supertest.</p>
	</blockquote>
	</dd>
	<dd>
	<p class="fix_tracking">It might produce tests that start the app, hit the endpoints, and assert on responses.</p>
	</dd>
	<dt>Frontend tests</dt>
	<dd>
	<p>Web UI testing can be done <a contenteditable="false" data-primary="frontends" data-secondary="testing for AI-generated web applications" data-type="indexterm" id="id838"/>with tools like Jest (for component logic) and Cypress or Playwright for end-to-end UI tests. You can certainly ask AI to generate a Cypress test scenario:</p>
	</dd>
	<dd>
	<blockquote>
	<p>Write a Cypress test that loads the app, adds a new to-do via the form, and checks that it appears in the list.</p>
	</blockquote>
	</dd>
	<dd>
	<p>You’ll get a test script, which you can run. This is quite powerful—you quickly get end-to-end test coverage by leveraging the AI to script user interactions.</p>
	</dd>
	<dt>Manual tests</dt>
	<dd>
	<p>Whatever automated tests you run, always do some manual exploratory testing, too. Click around the web app yourself (or have QA do it, if you’re working in a team). The AI might not anticipate every real-world scenario: for example, maybe using the browser Back button breaks some state, or a particular sequence of actions causes a glitch. As you find bugs, fix them or ask the AI to help fix them. Manual testing is also important for UI/UX judgment—does the app feel good to use? Are there any awkward flows? The AI won’t know how to judge these subjective UX issues, so human feedback is key.</p>
	</dd>
	<dt>Code review</dt>
	<dd>
	<p>If you’re working with others, have <a contenteditable="false" data-primary="code reviews" data-secondary="for AI-generated web applications" data-secondary-sortas="AI-generated" data-type="indexterm" id="id839"/>them review the AI-generated code. Fresh eyes can catch things you might have glossed over—they might spot a security oversight or simply suggest a more idiomatic way to write something. Teams using AI often maintain normal code-review processes, just with <a href="https://oreil.ly/O5Dbj">more focus</a> on reviewing for subtle bugs or security issues that an AI might inadvertently introduce.<a contenteditable="false" data-primary="audits" data-secondary="security" data-seealso="security" data-type="indexterm" id="id840"/><a contenteditable="false" data-primary="security" data-secondary="audit for AI-generated web applications" data-type="indexterm" id="id841"/></p>
	</dd>
	<dt>Security audit</dt>
	<dd>
	<p><a data-type="xref" href="ch08.html#ch08_security_maintainability_and_reliability_1752630044621528">Chapter 8</a> will dive into security, but even at development time, it’s worth scanning your code for known vulnerability patterns.  There are automated tools you can run, like linters and <a href="https://oreil.ly/T531z">Static Application Security Testing</a> (SAST) tools, or you can prompt the AI:</p>
	</dd>
	<dd>
	<blockquote>
	<p>Review the Express app code and list any potential security vulnerabilities or best practice violations.</p>
	</blockquote>
	</dd>
	<dd>
	<p>The AI might flag some surprising things, like “You are not sanitizing user input here” or “You should set up CORS properly.” Use that as a checklist for hardening the app.</p>
	</dd>
</dl>

<p>One interesting effect of using AI is that you may write tests you wouldn’t have otherwise, because the AI makes it so easy to create them. This can actually lead to <em>more</em> robust code in the end. If you adopt a practice of generating tests immediately after generating features (essentially AI-assisted test-driven development, or at least post hoc tests), you ensure that the rapid development doesn’t compromise quality. Think of it like this: since the AI saved you time writing code, invest some of that saved time into writing and running tests.</p>

<p>AI can suggest insecure code if the user isn’t careful. For example, earlier AI versions might generate SQL queries that are vulnerable to injection attacks if not specifically prompted to avoid that. By testing and reviewing, you catch these issues. <a href="https://oreil.ly/U3b8H">One study</a> found that developers using AI assistance tended to be overconfident in their code’s security, even when it was worse than it would’ve been if written manually.</p>

<p>Never skip validation just because an AI wrote the code. Assume it can have bugs, just like any human-written code.<a contenteditable="false" data-primary="validation" data-secondary="for AI-generated web applications" data-secondary-sortas="AI-generated" data-startref="ix_valAIwebapp" data-type="indexterm" id="id842"/><a contenteditable="false" data-primary="testing" data-secondary="for AI-generated web applications" data-secondary-sortas="AI-generated" data-startref="ix_tstAIwa" data-type="indexterm" id="id843"/><a contenteditable="false" data-primary="web applications, building with AI" data-secondary="testing and validation" data-startref="ix_webappAItst" data-type="indexterm" id="id844"/></p>
</div></section>

<section class="pagebreak-before" data-type="sect1" data-pdf-bookmark="Examples of Successful AI-Built Web Projects"><div class="sect1" id="ch07_examples_of_successful_ai_built_web_projects_1752630044186366">
<h1 class="less_space">Examples of Successful AI-Built Web Projects</h1>

<p>Let’s highlight a couple of examples (composites drawn from various reports) where AI assistance played a significant role in delivering real web applications.<a contenteditable="false" data-primary="web applications, building with AI" data-secondary="examples of successful projects" data-type="indexterm" id="ix_webappAIex"/></p>

<dl>
	<dt>Ecommerce site by a solo developer</dt>
	<dd>
	<p>A solo developer wanted to create a small ecommerce web app to sell custom T-shirts but had limited time.<a contenteditable="false" data-primary="ecommerce site by solo developer, built using AI" data-type="indexterm" id="id845"/> He used GPT, through an IDE extension, to build the entire stack. He prompted the AI to generate a React frontend with product listings, a cart, and checkout pages, as well as a Node.js backend with endpoints for products and orders. He used Stripe for payments, integrating it by asking the AI to help with Stripe’s API. After working on it in the evenings for two weeks, he had a functioning site.</p>
	</dd>
	<dd>
	<p>This developer reported that AI had done probably 70% of the coding, especially the repetitive UI parts and form handling, while he focused on configuring Stripe correctly and fine-tuning the UI for branding. In the end, customers could browse products, add them to the cart, and purchase them—all in a system built largely via vibe coding. It also highlights that external service integration (like Stripe) is feasible with AI guidance, as long as documentation is available for the model to draw from or you provide it.</p>
	</dd>
	<dt>Internal company dashboard</dt>
	<dd>
	<p>A product manager with some coding skills used an AI pair programmer to create an internal analytics dashboard for her team. <a contenteditable="false" data-primary="dashboards" data-secondary="internal company dashboard built using AI" data-type="indexterm" id="id846"/><a contenteditable="false" data-primary="company dashboard (internal), built using AI" data-type="indexterm" id="id847"/>Normally, she would have had to wait for engineering resources, but using a tool like Replit’s Ghostwriter or GitHub Copilot in a web project, she managed to build a basic web app herself. The AI helped with setting up a simple Flask backend to query their database (with safe read-only credentials) and a Vue.js frontend to display graphs (using a charting library). She described what each chart should show (“total sign-ups over time,” “active users by region”), and the AI wrote the SQL queries and chart code.</p>
	</dd>
	<dd>
	<p>The whole process took a couple of weeks of tinkering and testing, but eventually she delivered a working dashboard. The code quality wasn’t enterprise grade, but since it was internal, it was fine. More importantly, she empowered her team with a tool in a fraction of the time. This example illustrates how AI tools can enable nonspecialist programmers to produce useful web apps, unblocking tasks that might otherwise sit in a backlog. It’s an example of the “unbundling of the programmer” that I’ll discuss in <a data-type="xref" href="ch10.html#ch10_autonomous_background_coding_agents_1752630045087844">Chapter 10</a>, which is all about how individuals can create personal or team-specific software more easily now.</p>
	</dd>
	<dt class="pagebreak-before less_space">Startup minimum viable product (MVP)</dt>
	<dd>
	<p>A small startup (just two cofounders: one business, one technical) needed an MVP web application to show to investors.<a contenteditable="false" data-primary="minimum viable product (MVP)" data-secondary="web application MVP" data-type="indexterm" id="id848"/><a contenteditable="false" data-primary="startup minimum viable product web application" data-type="indexterm" id="id849"/> The technical cofounder used vibe coding extensively to build an MVP in record time. <a contenteditable="false" data-primary="MVP" data-see="minimum viable product" data-type="indexterm" id="id850"/>Using an AI assistant, he scaffolded a modern web app using Next.js for the SSR React frontend and a simple Node API. He leveraged AI to implement features like social login (the AI wrote the OAuth flows), image uploads (the AI integrated with a cloud-storage API), and an AI-based feature within the product itself. They even used the AI to help integrate an NLP model from an API. In a few months, one developer achieved what might normally take a small team four to six months. The result was a somewhat hacky but functioning product that they could demo, and they could even onboard beta users onto the platform.</p>
	</dd>
	<dd>
	<p>When the cofounders later hired more devs to polish the product, the new devs found the AI-written code to be mostly understandable, though they did refactor significant portions for scalability. This underlines that AI can get you to the first stage quickly, but you might need to invest in quality as you move to the next stages.</p>
	</dd>
</dl>

<p>These stories, while anecdotal, align with emerging patterns in the industry. In web development specifically, which often involves wiring many components together, the productivity boost is very tangible. <a href="https://oreil.ly/QLunu">Microsoft</a> and <a href="https://oreil.ly/BNVrB">others</a> reported studies finding that developers with AI could complete tasks significantly faster than those without.</p>

<p>However, there have also been cautionary tales. For instance, a developer might deploy an AI-generated web app with a security flaw because they don’t fully understand the code. This risk reinforces why testing and review are crucial.</p>

<p>In conclusion, building web applications with AI assistance is becoming a mainstream approach. It doesn’t remove the need for skilled developers; rather, it augments them. The developers still plan the architecture, ensure correctness, and handle the complex or novel aspects of the code, while the AI handles the repetitive boilerplate code that glues everything together. The end-to-end workflow we walked through—from scaffolding to frontend to backend to testing—demonstrates that practically every step of web development can be accelerated with AI, as long as you apply your human judgment and expertise along the way.<a contenteditable="false" data-primary="web applications, building with AI" data-secondary="examples of successful projects" data-startref="ix_webappAIex" data-type="indexterm" id="id851"/></p>
</div></section>

<section class="pagebreak-before" data-type="sect1" data-pdf-bookmark="Summary and Next Steps"><div class="sect1" id="ch07_summary_and_next_steps_1752630044186414">
<h1 class="less_space">Summary and Next Steps</h1>

<p>In this chapter, you’ve seen how vibe coding extends to full-scale web application development. By treating the AI as an always available pair programmer, you can tackle frontend and backend tasks in parallel, generate components and APIs from natural descriptions, and iteratively refine a prototype application to production quality. The keys to success include clearly communicating your intent (so the AI knows what you want at each step), carefully verifying (to catch issues in the AI output), and leveraging the AI not just to generate code but for things like brainstorming schema designs and writing tests.</p>

<p>This chapter also explored how a developer can effectively be a full stack engineer, augmented by AI bridging gaps in their knowledge by suggesting code in areas they are less familiar with. This greatly reduces development time for common features and democratizes development in some ways, enabling people to create custom web solutions without large teams (a theme I’ll revisit in <a data-type="xref" href="ch10.html#ch10_autonomous_background_coding_agents_1752630045087844">Chapter 10</a>).</p>

<p>AI doesn’t replace understanding the requirements or ensuring quality; it accelerates execution.<a contenteditable="false" data-primary="web applications, building with AI" data-startref="ix_webapp" data-type="indexterm" id="id852"/></p>

<p>Now that your web application is up and running, the next concern is making sure it is secure, reliable, and maintainable. <a data-type="xref" href="ch08.html#ch08_security_maintainability_and_reliability_1752630044621528">Chapter 8</a> dives into the challenges of security and reliability in AI-generated codebases, identifying common vulnerabilities that might slip in, how to audit for and fix them, and best practices (like the ones we’ve started applying here with tests and reviews) to ensure that moving fast with AI doesn’t break things. Essentially, we’ll shift from building to hardening—making sure your vibe-coded software stands up to real-world conditions and threats.</p>
</div></section>
</div></section></div></div></body></html>