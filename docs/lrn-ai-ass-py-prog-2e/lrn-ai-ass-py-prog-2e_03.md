# 第四章：. 阅读 Python 代码：第一部分

### 本章涵盖

+   知道如何阅读代码的重要性

+   如何让 Copilot 解释代码

+   使用函数分解大问题

+   使用变量来保留值

+   使用 if 语句进行决策

+   使用字符串存储和操作文本

+   使用列表收集和操作多个值

在第三章中，我们使用 Copilot 为我们编写了几个函数。它们有什么用？也许我们的`money_made`函数可以是股票交易系统的一部分，我们的`is_strong_password`函数可以用作社交网站的一部分，或者我们的`best_word`函数可以用作某些 Scrabble AI 的一部分。总的来说，我们编写了一些有用的函数，它们可以是更大程序的一部分。而且，我们没有写很多代码，实际上甚至不理解代码的作用。

然而，我们认为你需要从高层次上理解代码的作用。因为这需要一些时间来学习，所以我们把这个讨论分成了两章。在本章中，我们将解释阅读代码的重要性，并介绍一个可以帮助你理解代码的 Copilot 功能。之后，我们将深入探讨你需要识别的前 10 个编程特性，以阅读 Copilot 生成的最基本代码。我们将在这章中介绍前五个，在下一章中介绍剩下的五个。不用担心：你实际上已经非正式地介绍了这 10 个——我们只是要加深你对每个特性的理解。

## 4.1 为什么我们需要阅读代码

当我们谈论阅读代码时，我们的意思是通过查看代码来理解代码的作用。有两种这样的理解层次，它们都很重要。

第一层是能够逐行理解程序将做什么。这通常涉及到在代码运行时追踪变量的值，以确定代码在每一步的具体行为。这很有用，但并不是全部。就像不知道食谱要做什么或其成分如何搭配的情况下，一步一步地跟随烹饪食谱。最后，你可能会有一个蛋糕，但你可能无法理解蛋糕为什么做得这么好，或者你如何能自己想出这样的食谱。你需要理解整个食谱为什么有效。

所以，这是第二层：确定程序的整体目的。也就是说，你需要能够从每一行中抽离出来，从高层次上理解程序在做什么。

在这两章的结尾，我们希望你能开始理解 Copilot 在这两个层面的代码。我们将开始逐行关注这种理解，但在本章的末尾以及本书的其余部分，你将开始能够查看一小段代码并确定其整体目的。

我们可以通过参考第三章中重新打印的`best_word`函数来阐述阅读代码两个层次之间的区别。

##### 列表 4.1 为 Scrabble 的`best_word`函数

```py
def best_word(word_list):
 """
 word_list is a list of words.

 Return the word worth the most points.
 """
    best_word = ""
    best_points = 0
    for word in word_list:
        points = num_points(word)
        if points > best_points:
            best_word = word
            best_points = points
    return best_word
```

*追踪描述*这个程序的功能是描述每一行。例如，我们会说我们定义了一个名为`best_word`的函数，它接受一个名为`word_list`的参数。我们有一个名为`best_word`的变量，我们一开始将其初始化为一个空字符串，即没有字符的字符串。（不幸的是，函数和这个变量都叫`best_word`，这使得指代其中一个或另一个变得复杂，但这是 Copilot 给我们的。）我们还有一个名为`best_points`的变量，我们将其初始化为`0`。然后，我们有一个遍历`word_list`中每个单词的`for`循环。在`for`循环内部，我们调用我们的`num_points`辅助函数，并将它的返回值存储在`points`变量中，等等。（我们将在本章和下一章中解释我们如何知道每一行代码的作用。）

相反，一个*整体目的描述*可能类似于我们的文档字符串描述：“从单词列表中返回具有最高 Scrabble 得分值的单词。”这个描述不是针对每一行，而是指代代码的整体目的，从高层次解释它做什么。

你将通过结合追踪和测试的实践达到整体目的的理解水平，我们希望你在书的结尾能够完全实现这一目标。在追踪层次上工作通常先于在整体目的层次上工作[1]，因此在本章和下一章中，我们将通过理解每一行代码的作用来专注于追踪层次。我们希望你能够阅读代码有三个原因：

1.  *为了帮助确定代码是否正确—*在第三章中，我们练习了如何测试 Copilot 给出的代码。测试是确定代码是否正确执行的一项强大技能，我们将在整本书中继续使用它。但许多程序员，包括我们两个，只有在代码看起来合理正确的情况下才会进行测试。如果我们通过检查就能确定代码是错误的，那么我们就不费心去测试它：我们会先尝试修复代码。同样，我们希望你能识别出代码的错误，而无需花费时间去测试。你能识别出更多错误的代码（通过快速追踪或提高你的整体技能），你就能节省更多测试错误代码的时间。

1.  *为了指导测试—*理解代码逐行执行的内容本身很有用，但它也有助于提升你测试有效性的能力。例如，在下一章中，你将学习到循环——它们可以使代码重复零次、一次、两次或所需次数。你将能够将这一知识与你已经了解的测试知识相结合，帮助你确定重要的测试案例类别。

1.  *为了帮助你编写代码—*我们知道，你希望 Copilot 为你编写所有代码！我们也有同样的愿望。但不可避免的是，Copilot 可能无法正确处理某些代码，无论你如何进行提示工程。或者，也许足够的提示工程最终能够说服 Copilot 编写正确的代码，但自己动手做会更简单、更快。在编写这本书的过程中，我们两个人努力让 Copilot 尽可能多地编写代码。但是，由于我们对 Python 编程的了解，我们经常能够发现错误并直接修复，而无需通过任何繁琐的步骤让 Copilot 为我们修复。从长远来看，我们希望你能获得自主学习的编程能力，而理解 Python 编程则是我们为你提供从这本书到其他资源桥梁的方式。有研究表明，能够追踪和解释代码是能够编写代码的前提条件 [1]。

在我们深入探讨之前，我们需要明确我们追求的深度水平。我们不会教给你每一行代码的每一个细微之处。这样做会让我们回到在 Copilot 等工具出现之前传统的编程教学方式。相反，通过 Copilot 工具和我们的解释相结合，我们将帮助你理解每一行代码的精髓或总体目标。如果你未来打算编写大量程序，你需要的东西将不止于此。我们试图在“这段代码是魔法”和“我确切知道代码的每一行是如何工作的”之间找到最佳平衡点。

## 4.2 请求 Copilot 解释代码

到目前为止，我们使用 Copilot 为我们生成代码。这是它最知名的功能，但并非唯一。现在，我们将向你展示它的另一个最佳功能：解释 Python 代码的功能！

Copilot 扩展总是在变化中。我们这里给出的具体步骤可能会有所不同，在这种情况下，我们鼓励你查阅更通用的 GitHub Copilot 文档。

要尝试解释功能，你需要突出显示一些你希望 Copilot 为你描述的代码。让我们用我们的`best_word`函数（列表 4.1）来试一试。如果你没有从第三章输入这段代码，请现在输入。

![figure](img/4-1.png)

##### 图 4.1 在编辑器中突出显示的`best_word`函数的代码

如图 4.1 所示，高亮显示代码。之后，我们有几个选项。第一个是点击活动栏中的聊天图标（位于 VS Code 的左侧），或者按 Ctrl-Alt-I。这将打开如图 4.2 所示的 Copilot 聊天界面。（还有其他聊天界面，包括你可以通过 Ctrl-Shift-I 打开的快速聊天——使用哪个聊天界面无关紧要。）Copilot 聊天能够不仅用自然语言，还能用代码块、你可以点击以调用命令的按钮/链接等方式来回答你的问题。它还建议你可能想问的问题，当然，也允许你输入任何你喜欢的与代码相关的问题。

![图](img/4-2.png)

##### 图 4.2 VS Code 中的 Copilot 聊天界面

现在，我们将使用 Copilot 聊天来解释代码。在文本框中，输入以下命令：

```py
/explain
```

如果 Copilot 询问，你想要选择@workspace 选项。如果这个选项对你不起作用，你也可以尝试以下命令：

```py
/explain how the selected code works
```

输入一个正斜杠(/)是告诉 Copilot 聊天你正在指定一个命令（Copilot 文档将这些称为斜杠命令），而不是自然语言。在这种情况下，我们正在请求 Copilot 运行`/explain`命令来解释选中的文本。

或者，你可以通过如图 4.1 所示的方式在函数中高亮显示代码来请求 Copilot 解释代码。然后，右键点击函数中的代码，你将看到如图 4.3 所示的菜单。

![图](img/4-3.png)

##### 图 4.3 当你右键点击选中的`best_word`函数时出现的菜单

在这个菜单中，高亮显示 Copilot，你将看到图 4.4 中显示的选项列表。这些选项是使用 Copilot 时常用的功能。

![图](img/4-4.png)

##### 图 4.4 你可以使用 Copilot 的选项列表

最后一步是选择“解释此代码”选项。Copilot 聊天窗口将打开（如图 4.2 中之前所示），你将得到代码的解释。像往常一样，Copilot 是非确定性的，所以你的结果可能与我们的大不相同。事实上，如果解释让你感到困惑，你可能再次尝试使用`/explain`命令，或者编写自己的提示以获得不同的解释。作为教育工作者，这是梦想成真的开始，学习者将能够请求他们需要的任何解释，以完全理解代码是如何工作的。

##### Copilot 的解释可能会出错

与 Copilot 生成的代码一样，Copilot 的解释也可能出错。你可能想，“等等，如果这个工具可以出错，那么理解代码的价值在哪里？！”首先，我们同意这确实可能非常令人沮丧。然而，根据我们的经验，Copilot 的解释通常足够准确，可以非常有帮助，尤其是在理解代码基础知识方面，比如我们在这两章中教授的内容。此外，当学习者对他们的代码感到困惑时，他们通常会向朋友或网站寻求关于代码的帮助，这也可能导致错误。为了帮助减轻错误的可能性，你可以多次请求 Copilot 的解释，因为你在多次尝试中不太可能得到完全错误的答案。

这是第一次请求 Copilot 时它给出的：

提供的 Python 代码定义了一个名为`best_word`的函数，它接受一个单词列表作为参数（`word_list`）。这个函数的目的是确定并返回列表中价值最高的单词。

函数首先初始化两个变量：`best_word`和`best_points`。`best_word`是一个空字符串，最终将包含具有最高点值的单词，而`best_points`被设置为 0，将包含找到的最高点值。

函数随后进入一个循环，遍历`word_list`中的每个单词。对于每个单词，它通过调用`num_points`函数（在提供的代码中未显示）来计算单词的点值。`num_points`函数可能接受一个单词作为参数，并返回其点值。

如果当前单词的点值大于当前的`best_points`，函数将更新`best_word`为当前单词，并将`best_points`更新为当前单词的点值。这样，函数始终跟踪具有最高点值的单词。

在循环遍历完列表中的所有单词后，函数返回`best_word`，此时它应该是列表中具有最高点值的单词。如果列表为空或所有单词的点值都为 0，函数将返回一个空字符串。

对我们来说，这是对代码功能的一个非常好的描述。它首先对代码进行了整体解释，然后逐行进行更详细的说明。然而，请注意，要完全理解它，你需要了解重要的 Python 术语和特性。Copilot 的解释提到了函数、参数、变量、字符串、循环、做出决定（“如果点值为”），以及返回。如果你理解了这些术语，这个解释非常有用，但如果你不理解，那么它的用处就小得多。到这一章和下一章的结尾，你将了解解释 Copilot 典型解释所需的 Python 的主要术语和特性。

##### 请求解释

你从 `/explain` 命令中获得的那种解释可能不符合你的要求。例如，假设你希望 Copilot 明确地给你每一行代码并解释其功能，这样你就可以更容易地将代码与其具体解释联系起来。你可以做到这一点！尝试这个提示：“再次解释那行代码，但逐行解释。给出每一行代码及其功能的解释。”这样做给了我们每一行代码及其解释的非常详细的分解。我们鼓励你如果内置命令没有提供你想要的详细程度，就自己制作提示。

## 4.3 你需要了解的前 10 个编程特性：第一部分

我们将带您快速浏览您在接下来的编程旅程中需要的 10 个 Python 特性，从本章中提到的这五个开始。Python 是一种交互式语言，这使得我们比其他语言更容易进行实验和查看各种功能。我们将利用这一点来探索编程特性。这是我们学习 Python 的方式，也是成千上万的程序员学习 Python 的方式。不要犹豫去尝试！要开始，请按 Ctrl–Shift–P 并输入 `REPL`，然后选择 Python：启动 REPL。这应该会导致图 4.5 中所示的情况。（REPL 代表读取-执行-打印-循环。之所以这样称呼，是因为 Python 会读取你输入的内容，执行/运行它，将结果打印回你，并在循环中反复这样做。）

![图](img/4-5.png)

##### 图 4.5 从 VS Code 启动 REPL

这将把你带回到第三章中相同的 Python 提示符（如图 4.6 所示），但没有任何你的函数被加载。

![图](img/4-6.png)

##### 图 4.6 VS Code 中运行的 REPL

然后，我们可以开始输入 Python 代码。例如，输入

```py
>>> 5 * 4
```

然后按 Enter 键。你会看到 `20` 的响应。我们在这里不会花费时间在简单的数学上，但你是如何与 Python 交互以了解其工作方式的，这与我们之前提到的那 10 个 Python 特性中的第一个完全相同：你输入一些代码，Python 就会响应。现在，让我们深入探讨我们之前提到的 10 个 Python 特性中的前五个。

### 4.3.1 #1. 函数

你在第三章已经学到了所有关于函数的知识，所以让我们只总结一下我们学到了什么。你使用函数将一个大问题分解成更小的部分。回顾一下，我们在第三章写的 `best_word` 函数是一个相当大的任务：它必须确定在一系列单词中哪个单词值得最多的分数。一个单词值多少分？啊——这是一个可以从该函数中分离出来的子任务，我们在之前的 `num_points` 函数中就是这样做的。

我们设计一个函数来接受参数，每个参数对应于函数需要执行其工作所需的数据块或数据集合。在完成它们的工作后，大多数函数使用 `return` 将答案发送回调用它们的代码行。当我们调用一个函数时，我们传递值，称为参数，每个参数一个值，我们通常使用变量来存储那个返回值。

对于我们编写的每个程序，我们可能需要设计几个函数，但 Python 也内置了一些函数，我们可以免费使用。我们可以像调用自己的函数一样调用它们。例如，有一个内置的 `max` 函数，它接受一个或多个参数，并告诉我们最大的值：

```py
>>> max(5, 2, 8, 1)
8
```

还有 `input` 函数，我们在第三章的 `get_strong_password` 函数中使用过。它接受一个参数，该参数成为用户的提示，并返回用户在键盘上输入的内容：

```py
>>> name = input("What is your name? ")
What is your name? Dan
>>> name
'Dan'
```

如果 `input` 是从键盘接收输入的函数，那么有没有一个 `output` 函数可以将消息输出到屏幕？嗯，是的，但它被称为 `print`，而不是 `output`：

```py
>>> print('Hello', name)
Hello Dan
```

### 4.3.2 #2\. 变量

变量是一个指向值的名称。我们在第三章中使用变量来跟踪函数的 `return` 值。我们在这里也使用了一个变量来保存用户的姓名。每次我们需要记住一个值以供以后使用时，我们都会使用变量。

要将值赋给变量，我们使用等号（=）符号，这被称为 *赋值* 符号。它计算出右侧的值，并将其赋给变量：

```py
>>> age = 20 + 4      #1
>>> age
24
```

#1 等号右侧的表达式将被评估，这意味着 20 + 4 被评估为 24。然后，变量 age 被赋予值 24。

##### Python 中的 = 符号与数学中的不同

在 Python 和其他编程语言中，等号（=）用于表示 *赋值*。等号左侧的变量被赋予等号右侧计算得到的值。这不是一个永久的关系，因为变量的值可以改变。对于数学能力强但编程新手的人来说，这可能会令人困惑，但只需记住 Python 中的等号表示赋值，而不是相等。

我们可以在更大的上下文中使用变量，这被称为 *表达式*。变量所指向的值会替换其名称：

```py
>>> age + 3      #1
27
>>> age      #2
24
```

#1 年龄在 Python 提示符中仍然可用，其值为 24。24 + 3 被评估为 27。

#2 表达式 age + 3 并没有改变 age 的值，因为我们没有重新赋值 age。

##### 变量在 Python 提示符中持续存在

我们在之前的代码块中分配了 `age`。为什么我们可以继续引用它？在 Python 提示符的编程会话期间声明的任何变量都会持续存在，直到你退出。这就是程序中变量的工作方式。一旦你为它们赋值，它们就可用。

但请注意，当我们说 `age` `+` `3` 时，变量 `age` 并没有改变！要改变它，我们需要另一个 `=` 赋值语句：

```py
>>> age = age + 5     #1
>>> age
29
```

#1 我们通过赋值（等号 `=` 符号）改变了 age。

让我们看看更多改变变量引用的方法。我们将在代码旁边添加一些注释来解释：

```py
>>> age += 5      #1
>>> age
34
>>> age *= 2      #2
>>> age
68
```

#1 一个加的快捷方式。`age += 5` 等同于 `age = age + 5`。

#2 一个乘以 2 的快捷方式。`age *= 2` 等同于 `age = age * 2`。

### 4.3.3 #3. 条件语句

每当我们的程序需要做出决定时，我们都需要一个条件语句。例如，在第二章中，我们需要决定包含在数据中的球员（我们只想包含四分卫）。为此，我们使用了 `if` 语句。

记得我们在第三章中提到的较大值函数吗？我们在这里的列表中重新实现了它。

##### 列表 4.2 确定两个值中较大值的函数

```py
def larger(num1, num2):
    if num1 > num2:     #1
        return num1           #2
    else:                    #3
        return num2     #4
```

#1 如果 num1 大于 num2，则 num1 &gt; num2 表达式将为 True；如果 num1 小于或等于 num2，则为 False。

#2 当 num1 大于 num2 时执行此行。

#3 `else` 关键字必须与 `if` 关键字配对。当 `if` 不执行（num1 &gt; num2 为 False）时，`else` 将会执行。

#4 当 num1 不大于 num2 时执行此行。

列表 4.2 中的 `if-else` 结构被称为 *条件语句*，它允许我们的程序做出决定。在这里，如果 `num1` 大于 `num2`，则返回 `num1`；否则，返回 `num2`。这就是它返回较大值的方式！

在 `if` 后面，我们放置一个布尔条件（`num1` `>` `num2`）。布尔条件是一个测试条件的表达式，其结果要么是 `True`，要么是 `False`。如果是 `True`，则 `if` 下的代码执行；如果是 `False`，则 `else` 下的代码执行。我们使用比较符号（如 `>=` 表示大于等于，`<` 表示小于，`>` 表示大于，`==` 表示等于，`!=` 表示不等于）来创建布尔表达式。请注意，我们不仅使用缩进来表示函数的代码，还使用缩进来表示 `if` 和 `else` 语句的代码部分。缩进对于代码正确执行是必要的，所以值得注意（我们将在下一章中更多地讨论缩进）。这就是 Python 如何知道哪些代码行属于函数，哪些代码行还属于 `if` 或 `else`。

我们也可以在 Python 提示符中玩转条件语句——我们不需要在函数内部编写代码。以下是一个例子：

```py
>>> age = 40      #1
>>> if age < 40:        #2
...     print("Binging Friends")
... else:                         #3
...     print("What's binging?")
...
What's binging?
```

#1 我们将 40 赋值给 age。

#2 因为 age 是 40，这段代码是在询问 40 < 40 是否成立。它不成立，所以代码的 `if` 部分被跳过。

#3 因为 `if` 条件为 False，所以执行 `else` 部分。

当你在`if`语句中输入时，你会注意到提示符从`>>>`变为`...`。提示符的变化让你知道你正在输入需要完成的代码。当你完成`else`代码后，你需要额外按一次 Enter 键，以退出`...`提示符并回到`>>>`提示符。

我们将年龄变量设置为 40。因为`40` `<` `40`是`False`，所以 else 部分会执行。让我们再试一次，这次让 if 部分执行：

```py
>>> age = 25             #1
>>> if age < 40:           #2
...     print("Binging Friends")
... else:                         #3
...     print("What's binging?")
...
Binging Friends
```

#1 我们将 25 赋值给年龄。

#2 因为年龄是 25，这是在询问 25 是否小于 40。它是，所以 if 部分的代码会执行。

#3 当上面的条件都不成立时，else 部分不会执行（我们已执行了代码的 if 部分）。

你可能会看到一些没有`else`部分的`if`语句，这是可以的：`else`部分是可选的。在这种情况下，如果条件为`False`，则`if`语句不会执行任何操作：

```py
>>> age = 25           #1
>>> if age == 30:            #2
...     print("You are exactly 30!")
...
```

#1 我们将 25 赋值给年龄。

#2 == 检查两个值是否相等。

注意，测试两个值是否相等的方法是使用两个等号（`==`），而不是一个等号。（我们已知一个等号是用来执行赋值语句，将值赋给变量的。）

如果你有多于两种可能的结果怎么办？例如，假设一个人的年龄决定了他们可能会狂热的电视剧，如表 4.1 所示。

##### 表 4.1 按年龄可能的喜欢的电视剧

| Age | Show |
| --- | --- |
| 30–39  | *Friends*  |
| 20–29  | *The Office*  |
| 10–19  | *Pretty Little Liars*  |
| 0–9  | *Chi’s Sweet Home*  |

我们不能仅用`if-else`来捕捉所有这些结果，所以`elif`（即`else-if`）允许我们捕捉多于两个可能结果的条件逻辑，如下面的代码所示。我们在这里不包含 Python 提示符（`>>>`和`...`），因为这会非常繁琐：

```py
if age >= 30 and age <= 39:       #1
    print("Binging Friends")
elif age >= 20 and age <= 29:      #2
    print("Binging The Office")
elif age >= 10 and age <= 19:
    print("Binging Pretty Little Liars")
elif age >= 0 and age <= 9:
    print("Binging Chi's Sweet Home")
else: 
    print("What's binging?")     #3
```

#1 当年龄大于等于 30 且小于等于 39 时，此条件为真；例如，如果年龄是 35。

#2 如果上面的条件为 False，则会检查此条件。

#3 如果上面的所有条件都不成立，则此代码会执行。

我们使用`and`来捕捉一个复杂条件。例如，在第一行，我们希望年龄大于等于 30 且小于等于 39。Python 从上到下工作，当它找到一个成立的条件时，它会运行相应的缩进代码。然后，它停止检查剩余的`elif`或`else`——所以如果两个条件都成立，只有第一个条件的代码会运行。

尝试使用不同的年龄变量值进行实验，以观察在每种情况下正确的代码是否都能运行。实际上，如果我们认真测试这段代码，我们可以使用`if`语句结构来获得我们想要测试的值的良好感觉。这全部都是为了测试值的边界。例如，我们肯定想要测试 30 岁和 39 岁，以确保我们正确地用第一个条件捕捉到了完整的 30-39 岁范围。同样，我们还想测试 20 岁、29 岁、10 岁、19 岁、0 岁、9 岁，以及大于 39 岁的某个值，以测试底部的`else`方式。

如果你使用额外的`if`而不是`elif`，那么它们就变成了独立的`if`语句，而不是单个`if`语句。这很重要，因为 Python 总是独立地检查每个独立的`if`语句，而不管之前的`if`语句中发生了什么。

例如，让我们将我们的年龄代码中的`elif`改为`if`。这将给我们以下结果：

```py
if age >= 30 and age <= 39: 
    print("Binging Friends") 
if age >= 20 and age <= 29:                #1
    print("Binging The Office")   
if age >= 10 and age <= 19:               
    print("Binging Pretty Little Liars") 
if age >= 0 and age <= 9:                 
    print("Binging Chi's Sweet Home") 
else:                          #2
    print("What's binging?")
```

#1 这个条件始终会被检查。

#2 这个`else`与最近的`if`语句相关联。

假设你在上述代码中将`age`设置为`25`并运行它。你认为会发生什么？嗯，第二个`if`条件`age``>=``20``and``age``<=``29`是`True`，所以我们肯定会输出`Binging The Office`。但这并不是全部发生的事情！记住，因为我们在这里使用的是`if`，所以每个剩余的都会被检查。（如果它们是`elif`，我们就完成了。）`age``>=``10``and``age``<=``19`是`False`，所以我们不会输出`Binging Pretty Little Liars`。

最后的`if`条件`age``>=``0``and``age``<=``9`也是`False`，所以我们不会输出`Binging Chi's Sweet Home`。但是这个`if`有一个`else`！所以，我们确实会输出`What's binging?`。我们并没有打算这样做！我们只想为年龄至少为 40 岁的人输出`What's binging?`。这一切都是为了说明`if`和`elif`的行为不同，并且我们需要使用符合我们想要的行为的其中一个（如果我们想要多个代码块可能运行，则使用`if`；如果我们只想运行一个，则使用`elif`）。

### 4.3.4 #4. 字符串

正如我们在第三章中学到的，字符串是我们想要存储文本时使用的类型。文本无处不在——第二章中的统计数据、密码、书籍——所以字符串几乎出现在每个 Python 程序中。

我们使用引号来表示字符串的开始和结束。你会看到 Copilot 使用双引号或单引号。使用哪种引号都无关紧要；只需确保字符串以相同类型的引号开始和结束。

字符串附带了一组强大的方法。*方法*是与特定类型相关联的函数——在本例中是字符串。调用方法的方式与调用函数的方式略有不同。当你调用函数时，你将参数值放在括号内。对于方法，我们仍然将值放在括号内，但我们需要首先将我们要调用方法的价值放在括号外，然后是一个点。我们将在下一个例子中看到这一点！

在第三章中，Copilot 使用了一些字符串方法来实现`is_strong_password`。让我们在这里尝试使用这些方法，以便更好地理解它们是如何工作的：

```py
>>> 'abc'.isupper()     #1
False                  
>>> 'Abc'.isupper()    
False                  
>>> 'ABC'.isupper()    
True                   
>>> 'abc'.isdigit()       #2
False                     #2
>>> '345bc'.isdigit()     #2
False                      #2
>>> '345'.isdigit()       #2
True                      #2

>>> 'abc6'.isalnum()        #3
True                         #3
>>> 'abc def'.isalnum()     #3
False                        #3
>>> 'abcdef#'.isalnum()     #3
False                       #3
```

#1 `isupper`需要所有字符都是大写才能返回 True。

#2 `isdigit`需要所有字符都是数字才能返回 True。

#3 `isalnum`需要所有字符都是字母数字才能返回 True（空格不被视为字母数字）。

还有许多其他的字符串方法。一些帮助你将字符串在大小写之间转换，其他帮助你搜索字符串，还有一些帮助你格式化字符串（例如，居中或右对齐）。

如果你对某个特定的字符串方法不确定，Copilot 的 Explain 功能通常很有帮助。例如，这个函数做什么：

```py
def clean_number(phone_number):
    phone_number = phone_number.replace('(', '')    #1
    phone_number = phone_number.replace(')', '')     #2
    phone_number = phone_number.replace('-', '')    #3
    return phone_number
```

#1 从电话号码中移除所有（字符

#2 从电话号码中移除所有）字符

#3 从电话号码中移除所有–字符

记住，我们可以像在第 4.2 节中演示的那样要求 Copilot 解释代码。这是当我们要求 Copilot 解释这段代码时得到的结果：

提供的 Python 代码定义了一个名为`clean_number`的函数。这个函数旨在接受一个参数，`phone_number`，它预期是一个表示电话号码的字符串。这个函数的目的是从电话号码字符串中移除某些字符，特别是括号“（”和“）”以及连字符“-”。

函数使用了`replace()`方法，这是 Python 中字符串的一个内置方法。`replace()`方法用另一个指定的子串替换指定的子串。它接受两个参数：第一个是需要替换的子串，第二个是替换第一个子串的子串。

在这个函数中，`replace()`方法在`phone_number`上被调用了三次。每次调用`replace()`都用于移除一种类型的字符：首先移除开括号“（”，然后移除闭括号“）”，最后移除连字符“-”。它是通过将这些字符替换为空字符串""来实现的，从而有效地移除了它们。

在所有替换完成后，函数返回清理后的`phone_number`。这将是一个不包含任何括号或连字符的数字字符串。

此函数在需要以一致、无字符的格式处理或存储电话号码的情况下可能很有用。例如，你可能想在数据库中存储电话号码或比较电话号码的相等性时移除这些字符。

这确认了此函数的功能：从电话号码字符串中移除括号和连字符。并且它使用`replace`方法来完成此操作。

等等——`replace`听起来像我们正在将一些字符更改为其他字符（替换它们），而不是移除它们。那么`replace`是如何为我们移除字符的呢？解释说：“它是通过将这些字符替换为空字符串""来实现的，从而有效地移除了它们。”这是了解`replace`如何工作的一个线索，但我们可能还想了解更多。因此，我们接下来使用了提示“replace 方法是如何使用空字符串来移除字符的？”并从 Copilot 那里收到了以下解释：

Python 中的`replace()`方法在其被调用的字符串中替换所有指定的子字符串。

在这种情况下，指定的子字符串是字符“（”，”）”和“-”。方法被调用在`phone_number`字符串上，`replace()`的第二个参数是一个空字符串""。

因此，发生的情况是`phone_number`中指定字符的每个出现都被替换为空字符串。这实际上从字符串中移除了该字符，因为用无替换某物等同于移除它。

这在`clean_number`函数中进行了三次，每次移除一个字符。在所有三个字符都被移除后，清理后的`phone_number`被返回。

如果你想要学习更多，你可以继续向 Copilot 提问或在 Python 提示符下进行自己的测试。例如，你可以验证`replace`会移除所有(, ), 和 - 字符，即使每种字符有多个。你还可以探索使用`replace`来实际替换字符（其典型用例），而不是移除它们。这种探索如果需要区分真相和 Copilot 可能提供的不正确信息片段也是很有帮助的。这就是为什么我们需要自己的 Python 知识基础！

你也会经常看到在字符串上使用看起来像数学运算符的情况。它们与数学符号相同，但在字符串上执行不同的操作。+运算符用于将两个字符串拼接在一起，而*运算符用于将字符串重复特定次数。示例如下：

```py
>>> first = 'This is a '
>>> second = 'sentence.'
>>> sentence = first + second      #1
>>> print(sentence)
This is a sentence.
>>> print('-=' * 5)     #2
-=-=-=-=-=
```

#1 将第一和第二字符串合并并将结果赋值给 sentence

#2 将“-”字符串重复五次

### 4.3.5 #5\. 列表

当我们有一个字符序列时，例如密码或单个 Scrabble 单词，字符串就非常棒。但有时，我们需要存储许多单词或许多数字。为此，我们需要一个列表。我们在第三章使用列表来处理`best_word`函数，因为这个函数需要与单词列表一起工作。

*与我们在字符串的开始和结束处使用引号一样，我们使用开闭方括号来开始和结束列表。至于字符串，列表上有许多可用方法。为了给你一个关于可用列表方法和它们做什么的印象，让我们探索一些这些方法：

```py
>>> books = ['The Invasion', 'The Encounter', 'The Message']     #1
>>> books
['The Invasion', 'The Encounter', 'The Message']
>>> books.append('The Predator')                                 #2
>>> books
['The Invasion', 'The Encounter', 'The Message', 'The Predator']
>>> books.reverse()                                               #3
>>> books
['The Predator', 'The Message', 'The Encounter', 'The Invasion']
```

#1 包含三个字符串值的列表

#2 在列表末尾添加一个新的字符串值

#3 反转列表（现在值是相反的顺序）

许多 Python 类型，包括字符串和列表，允许你使用索引来处理特定的值。当你想要处理字符串或列表的一部分而不是整个字符串或列表时，你需要使用索引。索引只是一个标识元素的数字。索引从 0 开始，对于第一个元素，然后一直增加到但不包括值的数量。第一个值有索引 0（不是索引 1！），第二个有索引 1，第三个有索引 2，依此类推。列表中的最后一个值在索引处，该索引是列表长度减 1。列表的长度可以通过使用`len`函数来确定。例如，如果我们做`len(books)`，我们会得到一个值为`4`（因此有效的索引是从 0 到包括 3）。人们也经常使用负索引，这为每个值提供了另一种索引方式：最右侧的值有索引-1，其左侧的值有索引-2，依此类推。图 4.7 展示了正索引和负索引的示例。

![图](img/4-7.png)

##### 图 4.7 列表元素可以通过正索引或负索引访问。

让我们在当前的书籍列表上练习索引：

```py
>>> books
['The Predator', 'The Message', 'The Encounter', 'The Invasion']
>>> books[0]        #1
'The Predator'
>>> books[1]
'The Message'
>>> books[2]
'The Encounter'
>>> books[3]
'The Invasion'
>>> books[4]                        #2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
>>> books[-1]                   #3
'The Invasion'
>>> books[-2]
'The Encounter'
```

#1 books[0]对应于第一个元素。

#2 错误是因为索引 3 是最后一本书！

#3 books[-1]指向列表中的最后一个元素。

此外，还有一种方法可以从字符串或列表中提取多个值，而不仅仅是单个值。这被称为*切片*。我们指定第一个值的索引，一个冒号，以及值右侧的索引，如下所示：

```py
>>> books[1:3]             #1
['The Message', 'The Encounter']
```

#1 从索引 1 开始，到索引 2 结束（不是 3！）

我们指定了 1:3，所以你可能期望得到包括索引 3 在内的值。但冒号后面的第二个索引（即值之后的索引）不包括在内。这听起来很反直觉，但却是真的！

如果我们省略起始或结束索引，Python 会根据需要使用起始或结束索引：

```py
>>> books[:3]                                      #1
['The Predator', 'The Message', 'The Encounter']
>>> books[1:]                                      #2
['The Message', 'The Encounter', 'The Invasion']
```

#1 与使用书籍[0:3]相同

#2 与使用 books[1:4]相同

我们还可以使用索引来更改列表中的特定值，例如：

```py
>>> books
['The Predator', 'The Message', 'The Encounter', 'The Invasion']
>>> books[0] = 'The Android'      #1
>>> books[0]
'The Android'
>>> books[1] = books[1].upper()      #2
>>> books[1]
'THE MESSAGE'
>>> books
['The Android', 'THE MESSAGE', 'The Encounter', 'The Invasion']
```

#1 将书籍[0]更改为指向字符串值“Android”

#2 将书籍[1]更改为全部大写

如果我们在字符串上尝试这样做，我们会得到一个错误：

```py
>>> title = 'The Invasion'
>>> title[0]              #1
'T'
>>> title[1]
'h'
>>> title[-1]
'n'
>>> title[0] = 't'                   #2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```

#1 查找字符没有问题。

#2 但赋值不会！

字符串被称为*不可变*值，这意味着您不能更改其字符。您只能创建一个全新的字符串。相比之下，列表被称为*可变*值，这意味着您可以更改它。如果您收到有关类型不支持项赋值错误的错误，您很可能是尝试更改无法更改的值。

在本章中，我们向您介绍了 Python 中最常见的五个代码特性。我们将在下一章继续介绍另外五个。我们还向您展示了如何使用 Copilot 解释工具来帮助您理解代码，并提供了验证这些解释真实性的指导。表 4.2 提供了本章所涵盖特性的总结。

##### 表 4.2 本章 Python 代码特性总结

| **代码元素** | 示例 | 简要描述 |
| --- | --- | --- |
| 函数 | `def larger(num1, num2)` | 允许我们管理代码复杂性的代码特性。函数接受输入，处理这些输入，并可能返回一个输出。 |
| 变量 | `age = 25` | 一个可读性高的人名，它指向一个存储的值。可以使用`=`赋值语句进行赋值。 |
| 条件语句 | `if age < 18: print("Can't vote") else: print("Can vote")` | 条件语句允许代码做出决策。在 Python 中，我们有与条件相关的三个关键字：`if`、`elif`和`else`。 |
| 字符串 | `name = 'Dan'` | 字符串存储一系列字符（文本）。有许多强大的方法可用于修改字符串。 |
| 列表 | `list = ['Leo', 'Dan']` | 一个包含任何类型值的序列。有许多强大的方法可用于修改列表。 |

## 4.4 练习

1.  回想一下我们在列表 4.2（第 4.3.3 节）中查看的条件代码。这个程序的行为与原始程序有何不同？

```py
def larger(num1, num2):
    if num1 < num2:
        return num1
    else:
        return num2
```

1.  2. 在以下代码中，如果年龄是 32，会打印什么？如果您将除了第一个之外的所有`if`改为`elif`，会打印什么？

```py
if age >= 30 and age <= 39:
    print("Binging Friends")
if age >= 25 and age <= 34:      
    print("Binging The Office")
if age >= 15 and age <= 24:
    print("Binging Pretty Little Liars")
if age >= 0 and age <= 14:
    print("Binging Chi's Sweet Home")
else:
    print("What's binging?")
```

1.  3. 你会使用什么 Python 数据类型来存储传感器每分钟记录的一系列温度读数？这种数据类型会存储什么？

1.  4. 将以下 Python 代码块排列成程序，以计算提供的列表中所有偶数的总和。

```py
for number in numbers:
total += number
if number % 2 == 0: 
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
total = 0 
print(f"The sum of all even numbers is: {total}")
```

1.  5. （回忆第 4.3.1 节。）考虑以下 Python 函数调用`min(input("Enter a number: "), input("Enter another number: "))`。在运行此代码之前，思考这一行代码的预期功能，然后回答以下问题：

    1.  你期望运行此代码时会发生什么？描述执行过程的每个步骤。

    1.  在这个场景中，Python 是如何处理输入和`min`函数的？

    1.  如果输入的不是数字，而是可以表示数字的字符串（例如，`5`或`2`），Python 的行为会怎样改变，如果有的话？

    1.  如果一个或两个输入不是数字，结果会怎样？通过尝试不同的输入来测试您的假设。

1.  6. 在 4.3.2 节中，我们讨论了变量在 Python 中的持久性。变量的这种属性如何影响你编写代码的方式？考虑一个示例场景，其中在程序的不同部分保持变量状态将是有益的。

1.  7. 我们要求 Copilot 解释以下代码的工作原理：

```py
age = int(input("Enter your age: "))

if age < 13:
    print("You are a child.")
elif age < 20:
    print("You are a teenager.")
elif age < 60:
    print("You are an adult.")
else:
    print("You are a senior.")
```

Copilot 提供了以下解释：

这段 Python 代码是一个简单的程序，它会询问用户的年龄，然后根据用户所属的年龄范围打印出一条消息。

代码的第一行使用了`input()`函数来提示用户输入他们的年龄。`input()`函数从输入中读取一行（通常来自用户的键盘），将其转换为字符串，并返回该字符串。在这种情况下，提示是“Enter your age: ”。然后使用`int()`函数将该字符串转换为整数并存储在变量`age`中。

代码的其余部分是一系列条件语句，用于检查年龄的值并打印出相应的消息。`if`语句检查年龄是否小于 13 岁，如果是，则打印“你是一个孩子。”如果年龄不小于 13 岁，程序将移动到下一个条件，即`elif`（代表`else if`）语句，它检查年龄是否小于 20 岁。如果是，则打印“你是一个青少年。”如果年龄不小于 20 岁，它将移动到下一个`elif`语句，该语句检查年龄是否小于 60 岁。如果是，则打印“你是一个成年人。”

结果表明，Copilot 的解释不完整，因为它没有描述代码对*所有输入*的处理。确定解释中缺少的内容，并将你的答案添加到解释中。

1.  8. 审查提供的 Python 代码和初始提示给 Copilot。返回的解释过于模糊，没有帮助你理解代码中使用的字符串方法。

```py
text = "Hello, World! Programming is fun."
index = text.find("World")
new_text = text[index:].replace("World", "Everyone")

print(new_text)
```

给 Copilot 的提示：

你能解释一下这段代码的作用吗？

Copilot 给出的解释：

代码涉及通过查找特定单词并将其替换为另一个单词来操作存储在文本中的字符串。它使用方法来定位单词的开始位置，然后构建一个新的字符串，其中单词已被替换。最后，它打印出修改后的字符串。

你的任务是执行以下操作：

1.  确定为什么初始提示可能导致模糊或不实用的解释。

1.  改进提示以确保 Copilot 提供更详细和具体的解释。考虑你具体不理解字符串方法以及代码如何使用它们。

1.  将修订后的提示写给 Copilot，并讨论你的更改如何导致更好的解释。

## 摘要

+   我们需要能够阅读代码以确定其正确性，有效地测试它，并在需要时编写自己的代码。

+   Copilot 可以逐行解释代码，以解释代码正在做什么，你可以使用自己的提示来影响你获得的解释类型。

+   Python 有内置函数，如`max`、`input`和`print`，我们可以像调用自己的函数一样调用它们。

+   变量是一个指向值的名称。

+   一个赋值语句使一个变量指向一个特定的值。

+   一个`if`语句用于让我们的程序做出决策，并沿着多条路径中的其中一条继续执行。

+   字符串用于存储和操作文本。

+   方法是与特定类型相关联的函数。

+   列表用于存储和操作一系列通用的值（例如，一系列数字或一系列字符串）。

+   字符串或列表中的每个值都有一个索引；索引从 0 开始，而不是 1。

+   字符串是不可变的（不可更改的）；列表是可变的（可更改的）*。
