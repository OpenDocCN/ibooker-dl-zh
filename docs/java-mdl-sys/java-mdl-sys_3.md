> 附录 A
> 
> 类路径概述
> 
> 一本讨论模块系统的书当然会关注模块路径（见第 3.4 节）。但类路径仍然完全有效；并且由于你可以与模块路径并行使用它，它在增量模块化期间发挥着重要作用。换句话说，了解它是如何工作的仍然是有价值的。
> 
> 使用类路径加载应用程序 JAR 文件
> 
> > 定义：类路径
> > 
> > 类路径是与编译器和虚拟机相关的一个概念。它们用于相同的目的：在列出的 JAR 文件中搜索它们所需的类型，但这些类型不在 JDK 中。（它也可以与类文件一起使用，但为了了解模块系统的目的，你可以忽略这种情况。）
> > 
> 让我们以这本书的示例 ServiceMonitor 应用程序为例。它由多个子项目组成，并有一些依赖项。在这种情况下，除了最后一个项目 monitor 之外的所有子项目都已经构建并存在于`jars`目录中。
> 
> 下面的列表显示了如何使用类路径编译、打包和启动应用程序。除了某些命令行选项的新变体（例如，使用`--classpath`而不是`-classpath`）之外，这些命令与 Java 9 之前完全相同。
> 
> > 列表 A.1 使用类路径编译、打包和启动
> > 
> `javac` `--classpath "jars/*"` `①``-d monitor/target/classes` `②``${java-files}` `③` `jar --create` `--file jars/monitor.jar` `④``-C monitor/target/classes .` `②` `java` `--classpath "jars/*"` `①``monitor.Main` `⑤`
> 
> > ①
> > 
> > 包含依赖项的 JAR 文件文件夹
> > 
> > ②
> > 
> > 编译后的类文件夹
> > 
> > ③
> > 
> > 列出或找到所有源文件，在这种情况下是`monitor/src/main/java/monitor/Main.java`和`monitor/src/main/java/monitor/Monitor.java`
> > 
> > ④
> > 
> > 命名新的 JAR 文件；将其放入 jars
> > 
> > ⑤
> > 
> > 包含应用程序主方法的类
> > 
> 编译器和运行时都会在类路径中搜索它们需要的类型。虽然这些类型可能不同：

+   编译器——编译器需要编译的代码所引用的类型。这些是一个项目的直接依赖项，或者更精确地说，是直接依赖项中从编译的文件中引用的类型。

+   虚拟机——JVM 需要所有执行的字节码所引用的类型。通常，这些是一个项目的直接和间接依赖项；但由于 Java 对类加载的懒惰处理，它可能比这少得多。只有实际运行的代码中引用的类型是必需的，这意味着如果使用它的代码没有执行，则可能缺少依赖项。JVM 还允许代码在 JAR 文件中搜索资源。

> `javac` 和 `java` 都有命令行选项 `-classpath`、`-cp`，以及自 Java 9 以来新增的 `--classpath`。它们通常期望一个文件列表，但可以使用路径和通配符，然后这些会被扩展成相应的列表。
> 
> 自 Java 9 以来，类路径
> 
> > **关于 Java 9（及以后版本）的必要信息**，重要的是要强调类路径不会消失！它的工作方式与早期 Java 版本完全相同，如果在此版本上编译的应用程序没有进行任何有问题的操作（参见第六章和第七章），它们将继续使用相同的命令在 Java 9 及以后的版本上编译。
> > 
> 考虑到向后兼容性，问题仍然存在：模块系统如何处理类路径上的类型。简而言之，它们最终都会进入未命名的模块，模块系统会即时创建这个模块。这是一个常规模块，但它有一些特性，其中之一是它会自动读取所有已解析的模块。这也适用于最终进入类路径的模块——它们将被视为普通的 JAR 文件，并且它们的类型也会进入未命名的模块，忽略模块声明中提到的任何内容。未命名的模块和类路径上的模块是迁移故事的一部分，第 8.2 节详细讲述了这一点。
