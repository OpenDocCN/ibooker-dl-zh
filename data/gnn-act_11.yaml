- en: appendix A Discovering graphs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A 发现图
- en: In this appendix, we explore the theory and implementations of graphs that are
    most pertinent to using the GNNs covered in the rest of the book. The goal is
    to help those of you who are less familiar with graphs learn enough to follow
    the book (if you’re familiar with graphs, you can skip this appendix). We establish
    basic definitions, concepts, and nomenclature, and then survey how the theory
    is realized in real systems. This foundation is not only necessary to follow the
    material in this book but also for building the insights that make architecting
    custom systems and troubleshooting errors easier.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个附录中，我们探讨了与本书中涵盖的GNNs最相关的图理论和实现。目标是帮助那些不太熟悉图的人学习足够的知识来跟随本书（如果你熟悉图，可以跳过这个附录）。我们建立了基本定义、概念和命名法，然后概述了理论如何在现实系统中实现。这个基础不仅对于跟随本书中的材料是必要的，而且对于构建使构建定制系统和错误排除更容易的见解也是必要的。
- en: Additionally, in a rapidly evolving field, the ability to quickly absorb new
    academic and technical literature is crucial for staying up to date with the state
    of the art. We also provide the basic background to pick up the essence of relevant
    published papers. In this appendix, we’ll use a running example of a social networking
    dataset to demonstrate the concepts. This is a dataset of more than 1,900 professionals
    and their industry relationships. Figure A.1 visualizes this graph (generated
    using Graphistry).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在一个快速发展的领域，快速吸收新的学术和技术文献的能力对于跟上最前沿的状态至关重要。我们还提供了基本背景，以便抓住相关已发表论文的精髓。在这个附录中，我们将使用一个社交网络数据集的运行示例来展示这些概念。这是一个包含1900多名专业人士及其行业关系的数据库。图A.1可视化了这个图（使用Graphistry生成）。
- en: '![figure](../Images/A-1.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/A-1.png)'
- en: '**Figure A.1 A stylized visualization of the example social network, consisting
    of industry professionals and their relationships. The nodes (dots) are the professionals,
    and the edges (lines) denote a relationship between people. In this visualization,
    created using Graphistry, the left image shows an edge diverge out of the frame
    (bottom right). The right image is the entire graph, showing the cut-off edges
    and nodes.**'
  id: totrans-4
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**图A.1 示例社交网络的风格化可视化，包括行业专业人士及其关系。节点（点）是专业人士，边（线）表示人与人之间的关系。在这个使用Graphistry创建的可视化中，左图显示一条边从框架中发散出来（右下角）。右图是整个图，显示了截断的边和节点。**'
- en: A.1 Graph fundamentals
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 图的基本概念
- en: Let’s start with some definitions, and then we’ll see how the concepts work.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些定义开始，然后我们将看到这些概念是如何工作的。
- en: Key terms
  id: totrans-7
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关键术语
- en: '*Graph*—A data type consisting of nodes and edges.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图*—由节点和边组成的数据类型。'
- en: '*Node*—Also called a *vertex* or *point*, a node is an endpoint in a graph.
    They are connected by edges.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*节点*—也称为*顶点*或*点*，节点是图中的一个端点。它们通过边连接。'
- en: '*Edge*—Also called a *link* or *relationship*, an edge connects nodes. They
    can be directed or undirected.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*边*—也称为*链接*或*关系*，边连接节点。它们可以是定向的或非定向的。'
- en: '![sidebar figure](../Images/A-unnumb.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![sidebar figure](../Images/A-unnumb.png)'
- en: Loops and three types of edges
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 环和三种类型的边
- en: '*Directed edge*—A directed edge, usually represented by an arrow, denotes a
    one-way relationship or flow from one node to another.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*有向边*—有向边，通常用箭头表示，表示从一个节点到另一个节点的一个方向关系或流动。'
- en: '*Undirected edge*—An undirected edge has no direction. In such an edge, a relationship
    or flow can go in either direction.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*无向边*—无向边没有方向。在这样的边中，关系或流动可以朝两个方向进行。'
- en: '*Adjacent*—The property that two nodes are directly connected via an edge.
    Such nodes are said to be *joined*.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*相邻*—两个节点通过边直接连接的性质。这样的节点被称为*连接*。'
- en: '*Self-loop*—An edge that connects a node to itself. Such edges can be directed
    or undirected.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*自环*—连接到节点的边。这样的边可以是定向的或非定向的。'
- en: '*Parallel edges*—Multiple edges that connect the same two nodes.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*并行边*—连接相同两个节点的多条边。'
- en: '*Weights*—One important attribute of an edge is weight, which is a numerical
    value assigned to an edge. Such an attribute can describe the intensity of the
    connection, or some other real-world value, such as length (if a graph modeled
    cities on a road map).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*权重*—边的一个重要属性是权重，它是一个分配给边的数值。这样的属性可以描述连接的强度，或者某些其他现实世界的值，例如长度（如果图是按照道路地图模拟城市）。'
- en: These concepts give us the tools to create the simplest graphs. With a simple
    graph created from these concepts, we could derive network properties explained
    in the following section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念为我们提供了创建最简单图的工具。通过从这些概念创建简单图，我们可以推导出下节中解释的网络属性。
- en: While real-world graphs are complex, simple graphs can often effectively represent
    them for various purposes. For example, though our social graph data contains
    node features (covered in section A.1.2), to create the visualization in figure
    A.1, we only used node and edge information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现实世界的图很复杂，但简单的图往往可以有效地代表它们，用于各种目的。例如，尽管我们的社交图数据包含节点特征（在 A.1.2 节中介绍），但要创建图
    A.1 中的可视化，我们只使用了节点和边的信息。
- en: A.1.1 Graph properties
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.1 图属性
- en: In the following subsections, we discuss some of the more important properties
    of graphs. Many of the software programs and databases in the graph ecosystem
    (described in section A.3) should have the capability to compute some or all of
    these properties.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将讨论图的一些更重要的属性。图生态系统中的许多软件程序和数据库（在 A.3 节中描述）应该能够计算这些属性的一些或全部。
- en: Size/order
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 大小/阶数
- en: We’re often interested in the overall number of nodes and edges in a graph.
    Formal names for these properties are *size* (the number of edges) and *order*
    (the number of nodes). In our social graph, the number of nodes is 1,933, and
    the number of edges is 12,239.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常对图中节点和边的总数感兴趣。这些属性的正式名称是 *大小*（边的数量）和 *阶数*（节点的数量）。在我们的社交图中，节点的数量是 1,933，边的数量是
    12,239。
- en: Degree distribution
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 度分布
- en: A degree distribution is simply the distribution of the degrees of all the nodes
    in a graph. This can be shown as a histogram, as in figure A.2.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 度分布简单来说就是图中所有节点的度的分布。这可以表示为直方图，如图 A.2 所示。
- en: 'The *degree* of a node is the number of adjacent nodes in an undirected graph.
    For directed graphs, there are two types of degrees a node can have: an *in-degree*
    for edges directed to the node and an *out-degree* for edges directed outward
    from the node. Self-loops often are given a count of 2 when calculating degree.
    If edges are given weights, a *weighted degree* can also account for these weights.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的 *度* 是无向图中相邻节点的数量。对于有向图，一个节点可以有三种类型的度：指向该节点的边的 *入度* 和从节点向外延伸的边的 *出度*。在计算度时，自环通常被计为
    2。如果边有权重，则 *加权度* 也可以考虑这些权重。
- en: '![figure](../Images/A-2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/A-2.png)'
- en: Figure A.2 A histogram showing the degree distribution of our social graph
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 A.2 展示了我们社交图度分布的直方图
- en: Related to the concept of a degree is that of a node’s neighborhood. For a given
    node, its adjacent nodes are also called its *neighbors*. The set of all its neighbors
    is called its *neighborhood*. The number of vertices in a node’s neighborhood
    is equal to that node’s degree.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与度的概念相关的是节点的邻域。对于给定的节点，其相邻节点也称为其 *邻居*。所有邻居的集合称为其 *邻域*。节点邻域中的顶点数等于该节点的度。
- en: Connectedness
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连通性
- en: A graph is a set of nodes and edges. In general, however, there is no condition
    that says for an undirected graph, every node can be reached by any other node
    within the same network. It can happen that within the same graph, sets of nodes
    are utterly separated from one another; that is, no edge links them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图是由节点和边组成的集合。然而，通常没有条件说明对于无向图，同一网络中的每个节点都可以被任何其他节点到达。可能发生的情况是，在同一图中，节点集完全相互分离；也就是说，没有边将它们连接起来。
- en: An undirected graph where any node can reach any other node is called a *connected
    graph*. It may seem obvious that all graphs must be connected, but this is often
    not the case. Graphs that have discontinuities (where a node or set of nodes are
    unlinked to the rest of the graph) are *disconnected graphs*. Another way to think
    about this is that in a connected graph, there is a path or walk whereby every
    node can reach every other node in the graph. For a disconnected graph, each disconnected
    piece is called a *component*. For a directed graph, where it’s not always possible
    to reach any node from any other node, a *strongly connected graph* is one where
    every node can reach every other node.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 任何节点都可以到达任何其他节点的无向图称为 *连通图*。这似乎很明显，所有图都必须是连通的，但这种情况通常并不成立。具有不连续性（节点或节点集未与其他图的其他部分连接）的图称为
    *不连通图*。另一种思考方式是，在连通图中，存在一条路径或行进方式，使得每个节点都可以到达图中的其他节点。对于不连通图，每个不连通的部分称为 *组件*。对于有向图，如果不可能从任何节点到达任何其他节点，则
    *强连通图* 是每个节点都可以到达其他节点的图。
- en: As an example, the human population can be considered a disconnected social
    graph if we consider every individual human as a node and our communication channels
    as edges. While most of the population can be said to be connected by modern communication
    channels, there are hermits who chose to live off the grid and isolated hunter-gatherer
    tribes that reject contact with the rest of the world. In other use cases, there
    are often discontinuities in the network and its data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们把每一个个体人类视为一个节点，把我们的通信渠道视为边，那么人类人口可以被视为一个断开的社交图。虽然大多数人口可以通过现代通信渠道连接起来，但还有一些隐士选择脱离电网生活，以及拒绝与世界其他地区接触的孤立狩猎采集部落。在其他用例中，网络及其数据通常存在不连续性。
- en: Examining our social graph, we see it’s disconnected with a large component
    that contains most of the nodes. Figures A.3 and A.4 show the entire graph, and
    the large connected component. If we focus on the large connected component, we
    find that the number of nodes is 1,698 and the number of edges is 12,222.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的社交图，我们看到它是断开的，有一个包含大多数节点的大的分量。图A.3和A.4显示了整个图和大的连通分量。如果我们专注于大的连通分量，我们会发现节点数是1,698，边数是12,222。
- en: '![figure](../Images/A-3.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/A-3.png)'
- en: Figure A.3 Our entire social graph, which is disconnected. (`NetworkX` was used
    to generate this figure.) We observe a large connected component at the center,
    surrounded by disconnected nodes and small components consisting of two to three
    nodes.
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图A.3 我们整个社交图，它是断开的。（本图使用`NetworkX`生成。）我们观察到中心有一个大的连通分量，周围是断开的节点和由两到三个节点组成的小分量。
- en: '![figure](../Images/A-4.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/A-4.png)'
- en: Figure A.4 The connected component of the social graph. (NetworkX was used to
    generate this figure.) Compare this to figure A.1, which is the same graph visualized
    using Graphistry. Differences in the parameters used in the algorithms, as well
    as visual features, account for the distinctiveness of the two figures.
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图A.4 社交图的连通分量。（本图使用NetworkX生成。）与图A.1进行比较，图A.1是使用Graphistry可视化的相同图。算法中使用的参数以及视觉特征的不同，导致了这两个图的不同之处。
- en: Graph traversals
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图遍历
- en: In a graph, we can imagine traveling from a given node *a* to a second node
    *b*. Such a trip may require passing only one edge or passing several edges and
    nodes. Such a trip is called a *traversal*, or a *walk*, among other names. A
    traversal from one node to another is sometimes called a *hop*. Traversing a series
    of nodes is said to be done in *n* hops. A walk can be *open* or *closed*. Open
    walks have an ending node that is different from the starting node. A closed walk
    starts and ends with the same node.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个图中，我们可以想象从一个给定的节点*a*到第二个节点*b*的旅行。这样的旅行可能只需要通过一条边，或者通过几条边和节点。这样的旅行被称为*遍历*，或者*游走*，还有其他名称。从一个节点到另一个节点的遍历有时被称为*跳跃*。跨越一系列节点被称为*跳数*。一个游走可以是*开放的*或*封闭的*。开放的游走有一个与起始节点不同的结束节点。封闭的游走以相同的节点开始和结束。
- en: A *path* is a walk where no node is encountered more than once. A *cycle* is
    a closed path (with the exception of the starting node, which is also the ending
    node, no node is encountered twice). A *trail* is a walk where no edge is encountered
    more than once, and a *circuit* is a closed trail. Examples of these different
    types of paths are given in figure A.5\. Note how the number of steps (or hops)
    changes between different types of paths.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*路径*是一种没有节点被多次遇到的游走。*环*是一个封闭的路径（除了起始节点也是结束节点，没有节点被遇到两次）。*迹*是一种没有边被多次遇到的游走，而*回路*是一个封闭的迹。这些不同类型路径的例子在图A.5中给出。注意不同类型的路径之间步数（或跳跃数）的变化。'
- en: Imagine that for a given pair of nodes, we could find walks and paths between
    them. Of the paths we could navigate, there will be the shortest one (or maybe
    more than one path will tie for shortest). The length of this path is called the
    *distance* or *shortest path length*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，对于一对给定的节点，我们可以在它们之间找到游走和路径。在我们能导航的路径中，将会有最短的一条（或者可能有超过一条路径长度相同）。这条路径的长度被称为*距离*或*最短路径长度*。
- en: '![figure](../Images/A-5.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/A-5.png)'
- en: Figure A.5 Five types of paths
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图A.5 五种类型的路径
- en: If we zoom out and examine the entire graph and its node pairs, we can list
    all the shortest path lengths. One of these distances will be the longest (or
    more than one may tie for longest). The largest distance is the *diameter* of
    the graph. The diameter is often used to characterize and compare graphs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们放大并检查整个图及其节点对，我们可以列出所有最短路径长度。其中之一将是最长（或者可能多个距离并列最长）。最大的距离是图的*直径*。直径常用于描述和比较图。
- en: If we take our list of distances and average them, we’ll generate the *average
    path length* of the graph. Average path length is another important measure for
    graphs. Both average path length and diameter give an indication of the density
    of the graph. Higher values for these metrics imply more connections, which in
    turn allow a greater variety of paths, both longer and shorter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的距离列表取平均值，我们将生成图的*平均路径长度*。平均路径长度是图的重要度量之一。平均路径长度和直径都给出了图密度的指示。这些度量指标的高值意味着更多的连接，这反过来又允许有更多种类的路径，无论是更长还是更短。
- en: For our social graph, the diameter of our largest component is 10\. The diameter
    is undefined for the entire graph, as it’s unconnected.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的社交图，我们最大组件的直径是10。整个图的直径是未定义的，因为它是不连通的。
- en: Subgraphs
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 子图
- en: Consider a graph of nodes and edges. A *subgraph* is a subset of these nodes
    and edges. Subgraphs are of importance when these neighborhoods in the graph have
    properties that are distinct from other locations in the graph. Subgraphs occur
    in connected and disconnected graphs. A component of a disconnected graph is a
    subgraph.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个由节点和边组成的图。*子图*是这些节点和边的子集。当图中这些邻域具有与其他图中的其他位置不同的属性时，子图就很重要。子图出现在连通图和断开图之中。断开图的组件就是一个子图。
- en: Clustering coefficient
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 聚类系数
- en: A node may have a high degree, but how well connected is its neighborhood? We
    can imagine an apartment building where everyone knows the landlord, but no one
    knows their neighbors (what a sad place!). The landlord would have a clustering
    coefficient of 0\. At the other extreme, we could have an apartment where the
    landlord knows all the tenants, and every tenant knows every other tenant. Then,
    the landlord would have a clustering coefficient of 1 (such a situation, where
    all the nodes in a network are connected to every other node is called a *complete
    graph* or *fully connected graph*). Of course, there will be intermediate cases
    where only some of the tenants know one another, and these situations will have
    coefficients between 0 and 1.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点可能具有高度，但它的邻域连接得有多好呢？我们可以想象一个公寓楼，每个人都知道房东，但没有人知道他们的邻居（多么悲哀的地方啊！）房东的聚类系数将是0。在另一个极端，我们可能有一个公寓，房东知道所有租户，每个租户也知道其他租户。那么，房东的聚类系数将是1（所有网络中的节点都相互连接的情况称为*完全图*或*全连接图*）。当然，也会有中间情况，只有一些租户相互认识，这些情况将具有介于0和1之间的系数。
- en: The dimension of a graph
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图的维度
- en: In machine learning and engineering in general, *dimension* is used in several
    ways. This term can be confusing as a result.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习和工程的一般应用中，*维度*被以几种方式使用。这个术语可能会令人困惑。
- en: 'Even within the topic of graphs, the term is used in a few ways in articles
    and academic literature. However, the term is often not explicitly defined or
    clarified. Thus, in the following list, we attempt to deconstruct the meaning
    of this term:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在图的主题内部，这个术语在文章和学术文献中也有几种用法。然而，这个术语通常并没有明确定义或阐明。因此，在以下列表中，我们试图分解这个术语的含义：
- en: '*Size/shape of datasets*—In this case, dimension refers to the number of features
    in a dataset. Low-dimensional datasets are implied to be small enough to visualize
    (i.e., two or three features) or small enough to be computationally viable.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据集的大小/形状*——在这种情况下，维度指的是数据集中特征的数量。低维数据集意味着足够小，可以可视化（即，两个或三个特征）或足够小，可以计算可行。'
- en: '*Mathematical definitions*—In math, the dimension of a graph has more strict
    definitions. In linear algebra, graphs can be represented in vector spaces, and
    the dimension is an attribute of these vector spaces [1].'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数学定义*——在数学中，图的维度有更严格的定义。在线性代数中，图可以在向量空间中表示，维度是这些向量空间的属性[1]。'
- en: '*Geometric definition*—There is also a geometric definition of a graph’s dimension.
    This definition relates a graph’s dimension to the least number of Euclidean dimensions
    that will allow a graph’s edges to be of unit size 1 [1].'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*几何定义*—也存在图的维度的几何定义。这个定义将图的维度与允许图边为单位大小1的最小欧几里得维度相关联[1]。'
- en: A.1.2 Characteristics of nodes and edges
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.2 节点和边的特征
- en: 'In the most basic type of graph, we have a collection of nodes and edges, without
    parallel edges or self-loops. For this basic graph, we have a geometric structure
    only. While even this basic graph structure is useful, often more complexity is
    desired to properly model a situation for real-world problems and use cases. For
    example, we can do the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的图类型中，我们有一组节点和边，没有并行边或自环。对于这个基本图，我们只有一个几何结构。虽然即使这个基本的图结构也是有用的，但通常还需要更多的复杂性来正确地模拟现实世界问题和用例。例如，我们可以做以下事情：
- en: 'Reduce the geometric restrictions discussed earlier. Explicitly, these restrictions
    are as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少前面讨论的几何限制。具体来说，这些限制如下：
- en: Each edge is incident to two nodes, one on each end of the edge.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条边都与两个节点相关联，一个在边的每一端。
- en: Between two nodes, only one edge can exist.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个节点之间，只能存在一条边。
- en: No self-loops are used.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用自环。
- en: With these restrictions relaxed, we’re able to model more situations at the
    cost of more complex graphs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在放宽这些限制后，我们能够以更复杂的图代价来模拟更多的情况。
- en: 2\. Add *properties* to our graph elements (nodes, edges, the graph itself).
    A property or feature is data tied to a specific element. Depending on the context,
    terms such as *labels*, *attributes*, and *decorators* are used in place of *properties*.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 向我们的图元素（节点、边、图本身）添加*属性*。属性或特征是与特定元素相关的数据。根据上下文，可以使用*标签*、*属性*和*装饰器*等术语来代替*属性*。
- en: In this section and the next, we’ll discuss the characteristics and variants
    of nodes, edges, and entire graphs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节和下一节中，我们将讨论节点、边以及整个图的特征和变体。
- en: Node properties
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 节点属性
- en: 'In the following list, we outline some of the different properties that nodes
    might contain. These become features in many data science or GNN tasks:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们概述了节点可能包含的一些不同属性。这些属性在许多数据科学或GNN任务中成为特征：
- en: '*Names, IDs, and unique identifiers*—A name or an ID is a unique identifier.
    Many graph systems will either assign an identifier such as an index to a node,
    or allow the user to specify an ID. In our social graph, each node has a unique
    alphanumeric ID.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*名称、ID和唯一标识符*—名称或ID是一个唯一标识符。许多图系统要么将索引等标识符分配给节点，要么允许用户指定ID。在我们的社交图中，每个节点都有一个唯一的字母数字ID。'
- en: '*Labels*—Within a graph, nodes may fall within certain classes or groups. For
    example, a graph modeling a social network may group people by their country of
    residence (USA, PRC, Nigeria) or their level of activity within the network (frequent
    user, occasional user). In this way, in contrast to the unique identifiers explained
    earlier, we’d expect several nodes to share the same label.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标签*—在图中，节点可能属于某些类别或组。例如，模拟社交网络的图可能根据居住国（美国、中国、尼日利亚）或网络内的活动水平（频繁用户、偶尔用户）对人们进行分组。这样，与前面解释的唯一标识符不同，我们预计几个节点将共享相同的标签。'
- en: '*Properties/attributes/features*—Properties that aren’t IDs or labels are usually
    called attributes or features. While such properties don’t have to be unique to
    a node, they don’t describe a node class either. Properties can be based on structural
    or nonstructural qualities.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性/属性/特征*—不是ID或标签的属性通常被称为属性或特征。虽然这样的属性不必对节点是唯一的，但它们也不描述节点类。属性可以基于结构或非结构特性。'
- en: '*Structural/topological properties*—Intrinsic characteristics of a node are
    related to the node’s topological properties and the geometrical structure of
    the graph in proximity to the node. Two examples are listed here:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结构/拓扑属性*—节点的内在特性与节点的拓扑属性以及节点附近的图几何结构相关。以下列出了两个例子：'
- en: A node’s degree, which, as we learned, is the number of incident edges it has.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点的度，正如我们所学的，是它拥有的入边数量。
- en: A node’s centrality, which is a measure of how important a node is relative
    to the nodes in its neighborhood.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点的中心性，这是一个衡量节点相对于其邻域中节点重要性的度量。
- en: By employing graph analytical methods (described in section A.4) characteristics
    of nodes, relative to their local environment, can be identified. These can be
    incorporated into certain GNN problems as features. Node embeddings such as those
    generated by transductive methods (chapter 2) are another example of a property
    based on the graph’s local structure.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用图分析方法（在第 A.4 节中描述）可以识别节点相对于其局部环境的特征。这些特征可以作为某些 GNN 问题中的特征。例如，由归纳方法（第 2 章）生成的节点嵌入是基于图局部结构的另一个属性示例。
- en: '*Nonstructural properties*—These are often based on real-world attributes.
    Taking the example of our social graph, we have two categorical properties: a
    person’s job category (e.g., scientist, marketer, administrator) and the type
    of company they work for (e.g., medical, transportation, consulting). These examples
    are categorical attributes. It’s possible to have numerical attributes, such as
    *years of experience* or *average number of direct reports* in all current and
    past roles.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非结构属性*—这些通常基于现实世界的属性。以我们的社交图为例，我们有两个分类属性：一个人的职业类别（例如，科学家、营销人员、管理员）以及他们工作的公司类型（例如，医疗、交通、咨询）。这些示例是分类属性。还可能有数值属性，例如
    *工作经验年数* 或 *平均直接下属人数* 在所有当前和过去的角色中。'
- en: '*Edge properties —*Properties for edges mirror those for nodes. The most often
    used and important edge property is that of the edge weight, described earlier.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*边属性*—边的属性与节点的属性相似。最常用且重要的边属性是边权重，这在前面已经描述过。'
- en: Edge variations
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 边的变化
- en: Unlike nodes, there are a few geometric variants of edges that can be used to
    make a graph model more descriptive.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与节点不同，边有一些几何变体可以用来使图模型更具描述性。
- en: '*Parallel edges*—Meaning more than one edge between two nodes *u* and *v*.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平行边*—指两个节点 *u* 和 *v* 之间有多于一条边。'
- en: '*Directionality*—Edges can have no direction or one direction. Because nodes
    *u* and *v* can have parallel edges connecting them, it’s possible to have two
    edges with opposite directionality or multiple edges with some combination of
    directions or undirectionality.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方向性*—边可以没有方向或一个方向。因为节点 *u* 和 *v* 可以通过平行边连接，所以可能有两个方向相反的边或多个具有某些方向组合或无方向的边。'
- en: '*Bidirectionality*—The case where between two nodes, both directions are represented
    in the respective edges. In practice, this term is used in a few ways:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双向性*—在两个节点之间，两个方向都在各自的边中表示出来。在实践中，这个术语有几种用法：'
- en: To describe nondirected edges, or simple edges.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要描述非定向边，或简单边。
- en: To describe two edges that have opposite directions (shown in figure A.6).
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要描述两个方向相反的边（如图 A.6 所示）。
- en: '![figure](../Images/A-6.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/A-6.png)'
- en: Figure A.6 From top to bottom, between two nodes, an example of an undirected
    edge, a directed edge from left to right, a directed edge from right to left,
    and two directed edges traversing both directions (bidirectionality)
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 A.6 从上到下，两个节点之间，一个无向边、一个从左到右的有向边、一个从右到左的有向边，以及两个双向的有向边（双向性）
- en: To describe an edge that has a direction at each end. This usage, while popular
    in the literature, is fairly rare in practical systems at the time of writing.
  id: totrans-88
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要描述每个端点都有方向的边。这种用法在文献中很流行，但在写作时，在实际系统中相当罕见。
- en: '*Self-loops*—Discussed previously, a self-loop, or loop, is the case where
    both ends of an edge connect to the same node. Where would one encounter a self-loop
    in the real world? For our social graph, let’s keep all the nodes, and consider
    a case where an edge would be an email sent from one professional to another.
    Sometimes, people send emails to themselves (for reminders). For such a scenario,
    an email to oneself could be modeled as a self-loop.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自环*—之前已讨论，自环或环是指边的两端都连接到同一个节点。在现实世界中，在哪里会遇到自环？对于我们的社交图，让我们保留所有节点，并考虑一个边将是一个从一位专业人士发送给另一位专业人士的电子邮件的情况。有时，人们会给自己发送电子邮件（作为提醒）。在这种情况下，给自己发送的电子邮件可以建模为自环。'
- en: A.1.3 Categories of graphs
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.3 图的类别
- en: 'Different categories of graphs depend on the node and edge characteristics
    we’ve just described. Following are the graph categories:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类别的图取决于我们刚刚描述的节点和边特征。以下是一些图类别：
- en: '*Simple graph*—A graph whose edges can’t be parallel edges or self-loops. Simple
    graphs can be connected or disconnected, as well as directed.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简单图*—边的边不能是平行边或自环的图。简单图可以是连通的或断开的，也可以是有向的。'
- en: '*Weighted graph*—A graph that uses weights. Our social graph has no weights;
    another way to express having no weights is to set all weights to 1 or 0\.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加权图*—使用权重的图。我们的社交图没有权重；另一种表达没有权重的说法是将所有权重设置为1或0。'
- en: '*Multigraphs —*A graph that is permitted to have multiple edges between any
    two nodes and multiple self-loops for any one node. A simple graph could be a
    special case of a multigraph if we’re working within a problem where we could
    add more edges and self-loops to it.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多重图*—允许任何两个节点之间有多个边和任何单个节点有多个自环的图。如果我们在一个可以添加更多边和自环的问题中工作，一个简单图可以是多重图的一个特例。'
- en: '*Di-graphs*—Another term for a directed graph.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有向图*—有向图的另一种说法。'
- en: '*K-partite graphs*—In many graphs, we may have a situation where we have two
    or more groups of nodes, where edges are only allowed between groups and not between
    nodes of the same group. “Partite” refers to the partitions of node groups, and
    “k” refers to the number of those partitions.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*K部图*—在许多图中，我们可能有两个或更多节点组的情况，其中边只允许在组之间，而不是在同一组内的节点之间。 “Partite”指的是节点组的分区，“k”指的是这些分区的数量。'
- en: '*Monopartite graph*—A graph in which there is only one group of nodes and one
    group of edges. A monopartite social graph could consist of only “Texan” nodes
    connected with “work colleague” edges. For example, in a social graph, nodes can
    belong to “New Yorkers” or “Texans” groups, and relationships can belong to “friend”
    or “work colleague” groups.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单部图*—只有一个节点组和一条边组的图。一个单部社交图可能只包含“德克萨斯人”节点和“工作同事”边。例如，在社交图中，节点可以属于“纽约人”或“德克萨斯人”组，关系可以属于“朋友”或“工作同事”组。'
- en: '*Bipartite (or bi-graph) graph*—A graph that has two node partitions within
    a graph. Nodes of one group can only connect to nodes of a second type and not
    to nodes within their own group. In our social graph example, nodes can belong
    to “New Yorkers” or “Texans” groups, and relationships can belong to “friend”
    or “work colleague” groups. In this graph, no New Yorkers would be adjacent to
    other New Yorkers, and the same for Texans. This is shown in figure A.7\.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双部图（或双图）*—在图中有两个节点分区的图。一个组的节点只能连接到第二类型的节点，而不能连接到它们自己的组内的节点。在我们的社交图示例中，节点可以属于“纽约人”或“德克萨斯人”组，关系可以属于“朋友”或“工作同事”组。在这个图中，没有纽约人会与另一个纽约人相邻，德克萨斯人也是如此。这如图A.7所示。'
- en: '![figure](../Images/A-7.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/A-7.png)'
- en: Figure A.7 A bipartite graph. There are two types of nodes (upper and lower
    row of circles). In a bipartite graph, nodes can’t be connected to nodes of the
    same type (those in the same row). This is also an example of a heterogeneous
    graph.
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图A.7 双部图。有两种类型的节点（圆圈的上下行）。在双部图中，节点不能连接到同一类型的节点（同一行的节点）。这也是一个异构图的例子。
- en: For more than three partitions, the requirement that adjacent nodes can’t be
    the same type still holds. In practice, *k* can be a large number.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于超过三个分区，相邻节点不能是同一类型的要求仍然成立。在实践中，*k* 可以是一个很大的数。
- en: '*Trees*—A tree is a well-studied data structure in machine learning and is
    a special case of a graph. It’s a connected graph without cycles. Another way
    to describe a graph without cycles is *acyclic*. In the data science and deep
    learning worlds, a well-known example is the directed acyclic graph (DAG), used
    in designing and governing data workflows.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*树*—树是机器学习中研究得很好的数据结构，是图的一个特例。它是一个无环的连通图。另一种描述无环图的方式是*无环的*。在数据科学和深度学习领域，一个著名的例子是用于设计和治理数据工作流的定向无环图（DAG）。'
- en: '*Hypergraphs*—Up to now, our graphs have consisted of edges that connect to
    two nodes or one node (a self-loop). For a hypergraph, an edge can be incident
    to more than two nodes. These data structures have a range of applications, including
    ones that involve the use of GNNs. This is shown in figure A.8\.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*超图*—到目前为止，我们的图由连接两个节点或一个节点（自环）的边组成。对于超图，一条边可以与超过两个节点相关。这些数据结构有各种应用，包括涉及使用GNNs的应用。这如图A.8所示。'
- en: '*Heterogeneous graphs*—A heterogeneous graph has multiple node and edge types,
    while a multirelational graph has multiple edge types.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异构图*—异构图有多个节点和边类型，而多关系图有多个边类型。'
- en: '![figure](../Images/A-8.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/A-8.png)'
- en: Figure A.8 One undirected hypergraph, illustrated in two ways. On the left,
    we have a graph whose edges are represented by shaded areas and marked by letters,
    and whose vertices are dots, marked by numbers. On the right, we have a graph
    whose edge lines (marked by letters) connect up to three nodes (circles marked
    by numbers). Node 8 has no edge. Node 7 has a self-loop.
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图A.8 两种方式展示的一个无向超图。在左边，我们有一个图，其边由阴影区域表示，并用字母标记，其顶点由点表示，并用数字标记。在右边，我们有一个图，其边线（用字母标记）连接最多三个节点（用数字标记的圆圈）。节点8没有边。节点7有一个自环。
- en: A.2 Graph representations
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 图表示
- en: Now that we have a conceptual idea of what graphs are, we move on to how to
    work with them. First, we focus on data structures most relevant to building graph
    algorithms and storing graph data. We’ll see that some of these structures, particularly
    the adjacency matrix, play a prominent role in the GNN algorithms we study in
    the bulk of this book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对图的概念有了基本的了解，我们将继续探讨如何与它们一起工作。首先，我们关注与构建图算法和存储图数据最相关的数据结构。我们将看到，其中一些结构，尤其是邻接矩阵，在我们这本书的大部分内容中研究的GNN算法中起着突出的作用。
- en: Next, we’ll examine a few graph data models. These are important in designing
    and managing how databases and other data systems deal with network data. Lastly,
    we’ll briefly take a look at how graph data is exposed to analysts and engineers
    via APIs and query languages.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将考察几种图数据模型。这些在设计和管理数据库以及其他数据系统如何处理网络数据方面非常重要。最后，我们将简要地看看图数据是如何通过API和查询语言暴露给分析师和工程师的。
- en: A.2.1 Basic graph data structures
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.1 基本图数据结构
- en: 'There are a few important ways to represent graphs that can be ported to a
    computational environment:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种重要的图表示方法可以移植到计算环境中：
- en: '*Adjacency matrix*—A node-to-node matrix.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*邻接矩阵*—节点到节点的矩阵。'
- en: '*Incidence matrix*—An edge-to-node matrix.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关联矩阵*—边到节点的矩阵。'
- en: '*Edge lists*—A list of edges by their nodes.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*边列表*—按节点列出的边列表。'
- en: '*Adjacency lists*—Lists of each node’s adjacent nodes.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*邻接表*—每个节点的相邻节点列表。'
- en: '*Degree matrix*—Node-to-node matrix of degree values.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*度矩阵*—节点到节点的度值矩阵。'
- en: '*Laplacian matrix*—The degree matrix minus the adjacency matrix (**D**-**A**).
    This is useful in spectral theory.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拉普拉斯矩阵*—度矩阵减去邻接矩阵（**D**-**A**）。这在谱理论中很有用。'
- en: These are by no means the only ways to represent a graph, but from a survey
    of the literature, software, storage formats, and libraries, these are the most
    prevalent. In practice, a graph may not be permanently stored as one of these
    structures, but to execute a needed operation, a graph or subgraph may be transformed
    from one representation to another.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绝不是表示图的唯一方式，但从文献、软件、存储格式和库的调查来看，这些是最普遍的。在实践中，图可能不会永久存储为这些结构之一，但为了执行所需的操作，图或子图可能需要从一种表示转换为另一种表示。
- en: 'What representations are used depends on many factors that should be weighed
    in planning. These factors include the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的表示取决于许多应该被考虑在计划中的因素。以下是一些因素：
- en: '*Size of graph*—How many vertices and edges does the graph contain, and how
    much are these expected to scale?'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图的规模*—图包含多少个顶点和边，以及这些预计会扩展到多大？'
- en: '*Density of graph*—Is the graph sparse or dense? We’ll touch on these terms
    in the next subsection.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图的密度*—图是稀疏的还是密集的？我们将在下一小节中涉及这些术语。'
- en: '*Complexity of the graph’s structure*—Is the graph closer to a simple graph,
    or one that uses one or more of the variations discussed previously?'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图结构的复杂性*—图更接近于简单图，还是使用之前讨论的变体之一？'
- en: '*Algorithms to be used*—For a given algorithm, a given data structure may perform
    relatively weakly or strongly compared to others. In the following subsections,
    for each structure, we’ll touch on two simple algorithms to compare.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*要使用的算法*—对于给定的算法，与其它数据结构相比，一个给定的数据结构可能表现相对较弱或较强。在以下小节中，对于每个结构，我们将简要介绍两个简单的算法进行比较。'
- en: '*Costs to do CRUD (create, read, updated, delete) operations*—How will you
    modify your graph (including creating, reading, updating, or deleting nodes, edges,
    and their attributes) over the course of your operations and how frequently will
    you do so?'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*执行 CRUD（创建、读取、更新、删除）操作的成本*—在你的操作过程中，你将如何修改你的图（包括创建、读取、更新或删除节点、边及其属性），以及你将多久进行一次这样的操作？'
- en: In many data projects, transformation from one data structure to another is
    common to accommodate particular operations. So, it’s normal to employ two or
    more of the previously mentioned data structures in a project. In this case, understanding
    the compute effort to execute the transformation is key. For the most popular
    structures, graph libraries allow methods that allow seamless transformations,
    but given the considerations listed previously, executing these transformations
    could take unexpected time or cost.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多数据项目中，从一个数据结构转换到另一个数据结构以适应特定操作是常见的。因此，在项目中使用前面提到的两个或多个数据结构是正常的。在这种情况下，理解执行转换的计算工作量是关键。对于最流行的结构，图库允许进行无缝转换的方法，但考虑到前面列出的因素，执行这些转换可能需要意想不到的时间或成本。
- en: For the following discussion, we’ll talk about how these data structures are
    used to store topological information about graphs. The only attributes we’ll
    consider are node IDs and edge weights. To illustrate these concepts, let’s use
    the weighted graph, consisting of five nodes, as shown in figure A.9\. Circles
    indicate nodes with their IDs; rectangles are the edge weights.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的讨论中，我们将讨论如何使用这些数据结构来存储关于图拓扑信息。我们将考虑的唯一属性是节点ID和边权重。为了说明这些概念，让我们使用包含五个节点的加权图，如图A.9所示。圆圈表示具有其ID的节点；矩形是边权重。
- en: '![figure](../Images/A-9.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/A-9.png)'
- en: Figure A.9 An example graph with different weighted edges and labeled nodes
    from 0 to 4
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图A.9 一个具有不同加权边和标记节点（从0到4）的示例图
- en: Let’s now dive into those six popular ways of representing graphs so they can
    be used computationally.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在深入探讨这六种流行的表示图的方法，以便它们可以在计算中使用。
- en: Adjacency matrix
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 邻接矩阵
- en: For a graph with *n* nodes, an *adjacency matrix* represents the graph as an
    *N* × *N* matrix format, where each row or column describes the edge between two
    nodes. For our example graph, shown previously in figure A.9, we have five columns
    and five rows. These rows and columns are labeled for each node. Cells of the
    matrix denote adjacency.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有*n*个节点的图，一个邻接矩阵以*N* × *N*矩阵格式表示图，其中每一行或每一列描述两个节点之间的边。对于前面在图A.9中显示的示例图，我们有五列和五行。这些行和列为每个节点进行了标记。矩阵的单元格表示相邻性。
- en: Adjacency matrices can be used for simple directed and undirected graphs. They
    can also be used for graphs with self-loops. In an unweighted graph, each cell
    is either 0 (no adjacency) or 1 (adjacency). For a weighted graph, the values
    in the cells are the edge weights. For unweighted parallel edges, the values of
    the cells are the number of edges.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接矩阵可用于简单的有向和无向图。它们也可以用于具有自环的图。在无权图中，每个单元格要么是0（无相邻性）要么是1（相邻性）。对于加权图，单元格中的值是边权重。对于无权并行边，单元格的值是边的数量。
- en: For our example, a weighted, undirected graph, the corresponding adjacency matrix
    is shown in table A.1\. Because our graph is undirected, the adjacency matrix
    is symmetric. For directed graphs, symmetry is possible but not guaranteed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，一个加权无向图，相应的邻接矩阵如表A.1所示。因为我们的图是无向的，所以邻接矩阵是对称的。对于有向图，对称是可能的，但不是保证的。
- en: Table A.1 An adjacency matrix for the graph in figure A.9
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表A.1 图A.9中图的邻接矩阵
- en: '|  | **0** | **1** | **2** | **3** | **4** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|  | **0** | **1** | **2** | **3** | **4** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **0**  | 0  | 0  | 0  | 3  | 5  |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **0**  | 0  | 0  | 0  | 3  | 5  |'
- en: '| **1**  | 0  | 0  | 0  | 1  | 1  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **1**  | 0  | 0  | 0  | 1  | 1  |'
- en: '| **2**  | 0  | 0  | 0  | 3  | 0  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **2**  | 0  | 0  | 0  | 3  | 0  |'
- en: '| **3**  | 3  | 1  | 3  | 0  | 0  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **3**  | 3  | 1  | 3  | 0  | 0  |'
- en: '| **4**  | 5  | 1  | 0  | 0  | 0  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| **4**  | 5  | 1  | 0  | 0  | 0  |'
- en: By inspecting this matrix, we can get a quick visual understanding of the characteristics
    of the matrix. We can see, for example, how many degrees node 1 has and get a
    general idea of the distribution of the degrees. We also see that there are more
    empty spaces (cells with a 0 value) than edges. This ease of using the matrix
    to draw quick insights for small graphs is one advantage of adjacency matrices.
    Even for large graphs, plotting the adjacency matrix can indicate certain subgraph
    structures.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查这个矩阵，我们可以快速直观地了解矩阵的特性。例如，我们可以看到节点1有多少度，并大致了解度的分布。我们还看到空格（值为0的单元格）比边多。使用矩阵为小图绘制快速洞察的这种便利性是邻接矩阵的一个优点。即使对于大型图，绘制邻接矩阵也可以指示某些子图结构。
- en: Adjacency matrices, and matrix representations in general, allow you to analyze
    graphs by using linear algebra. One relevant example is spectral graph theory
    (which underlies a few GNN algorithms).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接矩阵，以及一般的矩阵表示，允许你通过使用线性代数来分析图。一个相关的例子是谱图理论（它是几个GNN算法的基础）。
- en: 'Adjacency matrices are straightforward to implement in Python. The matrix in
    our example can be created using a list of lists, or a NumPy array:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接矩阵在Python中实现起来非常简单。我们示例中的矩阵可以使用列表的列表或NumPy数组来创建：
- en: '[PRE0]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With our adjacency matrix as a NumPy array, let’s explore another property
    of our graph. From our visual inspection of our matrix, we noticed many more zero
    values than nonzero values. This makes it a sparse matrix. *Sparse matrices*,
    that is, matrices with a large proportion of zero values, can take up unnecessary
    storage or memory space and increase calculation times. *Dense matrices*, contrarily,
    contain a large proportion of nonzero matrices. The following determines the sparsity
    of our matrix:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的邻接矩阵作为NumPy数组，让我们来探索我们图的一个另一些特性。从我们对矩阵的视觉检查中，我们注意到零值比非零值多得多。这使得它成为一个稀疏矩阵。*稀疏矩阵*，即具有大量零值的矩阵，可能会占用不必要的存储或内存空间，并增加计算时间。*稠密矩阵*，相反，包含大量非零矩阵。以下确定了我们矩阵的稀疏性：
- en: '[PRE1]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, our matrix has a sparsity of 0.6, meaning 60% of the values in this matrix
    are zeros.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的矩阵稀疏度为0.6，这意味着这个矩阵中有60%的值是零。
- en: Sparsity using node degree
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用节点度数的稀疏性
- en: Another way to think about sparsity is in terms of node degree. Let’s derive
    the sparsity value just shown from the perspective of the node degree.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种从节点度数的角度来考虑稀疏性的方法是，让我们从节点度数的角度推导出刚才显示的稀疏值。
- en: 'For a simple, undirected graph of *n* nodes, each node can make at most *n-1*
    connections, and thus have a maximum degree of *n-1*. The maximum number of edges
    can be calculated using combinatorics: because each edge represents a pair of
    nodes, for a set of *n* nodes, the maximum number of edges is “*n* choose 2”,
    that is, *(n C 2)* or *n*(*n* – 1)/2\. However, for our small matrix, we have
    a directed graph, which is clear because the adjacency matrix isn’t symmetric.
    This means that both directions count separately and need to times by 2\. Hence,
    for our small matrix, the maximum number of possible edges is 5(5 – 1) = 20\.
    The density of a graph is defined as the actual number of edges, *e*,over all
    possible edges, and sparsity can then be defined as 1 – density. In our example,
    this leads to a quantity that disagrees with what was calculated using the matrix
    alone, namely (1 – 10/20) = 0.5, which is not equal to 0.6 in the preceding code
    snippet. This is because we haven’t considered self-loops, which is standard practice
    for graph theory. If we included self-loops, we would have five additional possible
    edges (or 5^2), resulting in (1 – 10/25), or 0.6, matching the value in the earlier
    code. This highlights that care needs to be taken when reporting on the sparsity
    of a graph.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个由*n*个节点组成的简单无向图，每个节点最多可以建立*n-1*个连接，因此具有最大度数*n-1*。边的最大数量可以使用组合数学来计算：因为每条边代表一对节点，对于*n*个节点的集合，边的最大数量是“*n*选2”，即*(n
    C 2)*或*n*(*n* – 1)/2。然而，对于我们的小矩阵，我们有一个有向图，这很清楚，因为邻接矩阵不是对称的。这意味着两个方向都要单独计算，并需要乘以2。因此，对于我们的小矩阵，可能的最大边数是5(5
    – 1) = 20。图的密度定义为实际边数*e*与所有可能边数之比，然后稀疏性可以定义为1 – 密度。在我们的例子中，这导致了一个与仅使用矩阵计算出的值不一致的数量，即(1
    – 10/20) = 0.5，这与前面代码片段中的0.6不相等。这是因为我们没有考虑自环，这在图论中是标准做法。如果我们包括自环，我们就会有五个额外的可能边（或5^2），结果为(1
    – 10/25)，即0.6，与早期代码中的值相匹配。这表明在报告图的稀疏性时需要格外小心。
- en: Now, think of a graph that has not five, but millions or billions of nodes.
    Such graphs exist in the real world, and quite often the sparsity can be orders
    of magnitudes less than 0.6\. For undirected simple graphs, the adjacency matrix
    is symmetric, so only half the storage is needed. Most of the memory or storage
    containing the adjacency matrix would be devoted to zero values. Thus, the high
    sparsity of this data structure leads to memory inefficiencies.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一个有不是五个，而是数百万或数十亿个节点的图。这样的图在现实世界中确实存在，而且稀疏性往往比0.6低几个数量级。对于无向简单图，邻接矩阵是对称的，因此只需要一半的存储空间。大部分包含邻接矩阵的内存或存储空间将用于零值。因此，这种数据结构的高稀疏性导致了内存效率低下。
- en: In terms of complexity, for a simple graph, the space complexity would be **O**(*n*²),
    for undirected simple graphs. For an undirected graph, due to the symmetry, the
    space complexity would be **O**(*n*(*n*–1)/2).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂性方面，对于简单图，空间复杂度为**O**(*n*²)，对于无向简单图。对于无向图，由于对称性，空间复杂度为**O**(*n*(*n*–1)/2)。
- en: 'For time complexity, this of course depends on the task or the algorithm. Let’s
    look at two rudimentary tasks that we’ll also address for adjacency list and edge
    lists:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于时间复杂度，这当然取决于任务或算法。让我们看看两个基本任务，我们也会针对邻接表和边表进行讨论：
- en: Checking the existence of an edge between a particular pair of nodes
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查特定节点对之间是否存在边
- en: Finding the neighbors of a node
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找节点的邻居
- en: For the first task, we simply check the row and column corresponding to those
    nodes. This would take **O**(1) time. For the second, we need to check every item
    in that node’s row; this would take **O**(deg(*n*)) time, where deg(*n*) is the
    degree of the node.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个任务，我们只需检查对应节点的行和列。这将花费**O**(1)时间。对于第二个任务，我们需要检查该节点行中的每个项目；这将花费**O**(deg(*n*))时间，其中deg(*n*)是节点的度。
- en: To summarize, the advantages of adjacency matrices are that they can quickly
    check connections between nodes and are easy to visually interpret. The downsides
    are that they are less space-efficient for sparse matrices. The computational
    tradeoffs depend on your algorithm. They shine in cases where we have small and
    dense graphs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，邻接矩阵的优点是它们可以快速检查节点之间的连接，并且易于视觉解释。缺点是它们对于稀疏矩阵来说空间效率较低。计算权衡取决于你的算法。它们在具有小型和密集图的场景中表现突出。
- en: Incidence matrix
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关联矩阵
- en: While the adjacency matrix has a row and column for every node, an *incidence
    matrix* represents every edge as a column and every node as a row. Using the same
    graph shown earlier in figure A.9, we can construct an incidence matrix, which
    we show in table A.2.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然邻接矩阵为每个节点都有一个行和列，但*关联矩阵*将每条边表示为一列，将每个节点表示为一行。使用之前在图A.9中展示的相同图，我们可以构建一个关联矩阵，如表A.2所示。
- en: Table A.2 Incidence matrix for the example graph in figure A.9
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表A.2 图A.9中示例图的关联矩阵
- en: '|  | **0** | **1** | **2** | **3** | **4** |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|  | **0** | **1** | **2** | **3** | **4** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **0**  | 0  | 3  | 5  | 0  | 0  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **0**  | 0  | 3  | 5  | 0  | 0  |'
- en: '| **1**  | 0  | 0  | 0  | 1  | 1  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **1**  | 0  | 0  | 0  | 1  | 1  |'
- en: '| **2**  | 3  | 0  | 0  | 0  | 0  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **2**  | 3  | 0  | 0  | 0  | 0  |'
- en: '| **3**  | 3  | 3  | 0  | 1  | 0  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **3**  | 3  | 3  | 0  | 1  | 0  |'
- en: '| **4**  | 0  | 0  | 5  | 0  | 1  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **4**  | 0  | 0  | 5  | 0  | 1  |'
- en: An incidence matrix can represent wider variations of graph types than an adjacency
    matrix. Multigraphs and hypergraphs are straightforward to express with this data
    structure.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 关联矩阵可以表示比邻接矩阵更广泛的图类型。使用这种数据结构可以直观地表达多重图和超图。
- en: How does the incidence matrix perform with respect to space and time? To store
    the data of a simple graph, the incidence matrix has a space complexity of **O**(*|E|*
    * *|V|*), where *|V|* is the number of nodes (*V* for vertices), and *|E|* is
    the number of edges. Thus, it’s superior to the adjacency matrix for graphs with
    fewer edges than nodes, including sparse matrices.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 关联矩阵在空间和时间复杂度方面表现如何？为了存储简单图的数据，关联矩阵的空间复杂度为**O**(*|E|* * *|V|*)，其中*|V|*是节点数（*V*表示顶点），*|E|*是边数。因此，对于边数少于节点的图，包括稀疏矩阵，它优于邻接矩阵。
- en: 'To get an idea of time complexity, we turn to our two simple tasks: checking
    for an edge, and finding a node’s neighbors. To check the existence of an edge,
    an incidence matrix has a time complexity of O(*|E|* * *|V|*), far slower than
    the adjacency matrix, which does this in constant time. To find the neighbors
    of a node, an incidence matrix also takes O(*|E|* * *|V|*).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解时间复杂度，我们转向两个简单任务：检查边和查找节点的邻居。要检查边的存在，关联矩阵的时间复杂度为**O**(*|E|* * *|V|*)，远慢于邻接矩阵，后者可以在常数时间内完成这项任务。要查找节点的邻居，关联矩阵也需**O**(*|E|*
    * *|V|*)。
- en: Overall, incidence matrices have space advantages when used with sparse matrices.
    For time performance, they have slow performance on the simple tasks we covered.
    The overall advantage of using incidence matrices is for unambiguously representing
    complex graphs, such as multigraphs and hypergraphs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，当与稀疏矩阵一起使用时，关联矩阵具有空间优势。在时间性能方面，它们在简单任务上的表现较慢。使用关联矩阵的整体优势在于明确表示复杂图，例如多重图和超图。
- en: Adjacency lists
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 邻接表
- en: In an *adjacency list*, the aim is to show which vertices each node is adjacent
    to. So, for *n* nodes, we have *n* lists of neighbors corresponding to each node.
    Depending on what data structures are used for the lists, properties may also
    be included in the summary. For our example, a simple adjacency list is shown
    in figure A.10.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在*邻接表*中，目标是显示每个节点与哪些顶点相邻。因此，对于*n*个节点，我们为每个节点有*n*个邻居列表。根据用于列表的数据结构，摘要中也可能包括属性。在我们的例子中，简单的邻接表如图A.10所示。
- en: '![figure](../Images/A-10.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/A-10.png)'
- en: Figure A.10 Our example graph and its adjacency list
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图A.10 我们的示例图及其邻接表
- en: 'Such an adjacency list can be accomplished in python using a dictionary with
    each node as the keys, and lists of the adjacent nodes as values:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典，其中每个节点作为键，相邻节点的列表作为值，可以在Python中实现这样的邻接表：
- en: '[PRE2]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can improve on the dictionary values to allow for the inclusion of the weights
    of the neighbors:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改进字典值，以便包括邻居的权重：
- en: '[PRE3]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For undirected graphs, the set of nodes doesn’t have to be ordered. Because
    the adjacency list doesn’t devote space to node pairs that aren’t neighbors, we
    see that adjacency lists lack the sparsity problems of adjacency matrices. So,
    to store this data structure, we have a space complexity of **O**(n + v), where
    *n* is the number of nodes, and *v* is the number of edges.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无向图，节点的集合不需要排序。因为邻接表不会为非邻居的节点对分配空间，所以我们看到邻接表没有邻接矩阵的稀疏性问题。因此，为了存储这种数据结构，我们有一个空间复杂度为**O**(n
    + v)，其中*n*是节点的数量，*v*是边的数量。
- en: Going back to the two computational tasks, checking the existence of an edge
    (task 1) would take **O**(deg(node)) time, where deg(node) is the degree of either
    node. For this, we simply check every item in that node’s list, where for the
    worst case, we’d have to check them all. For task 2, finding a node’s neighbors
    would also take **O**(deg(node)) time, because we have to inspect every item in
    that node’s list whose length is the node’s degree.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 回到两个计算任务，检查边的存在（任务1）将需要**O**(deg(node))时间，其中deg(node)是任一节点的度。为此，我们只需检查该节点列表中的每个项目，在最坏的情况下，我们可能需要检查所有项目。对于任务2，找到节点的邻居也需要**O**(deg(node))时间，因为我们必须检查该节点列表中的每个项目，其长度等于节点的度。
- en: Let’s summarize the tradeoffs of an adjacency list. The advantages are that
    they are relatively efficient in terms of storage because only edge relationships
    are stored. This means a sparse matrix would take up less space stored as an adjacency
    list than as an adjacency matrix. Computationally, the tradeoffs depend on the
    algorithm you’re running and the type of graph you’re using as input data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下邻接表的权衡。优点是它们在存储方面相对高效，因为只存储边关系。这意味着稀疏矩阵作为邻接表存储比作为邻接矩阵存储占用的空间更少。在计算上，权衡取决于你运行的算法以及你用作输入数据的图类型。
- en: Edge lists
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 边列表
- en: 'Compared to the preceding two representations, *edge lists* are relatively
    simple. They consist of a set of doubles (two nodes) or triples (two nodes and
    an edge weight). These identify a unique edge thusly:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两种表示相比，*边列表*相对简单。它们由一组双数（两个节点）或三数（两个节点和一个边权重）组成。这些以此方式标识唯一的边：
- en: Node, node (edge weight), for an undirected graph
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点，节点（边权重），对于无向图
- en: Source node, destination node (edge weight), for a directed graph
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源节点，目标节点（边权重），对于有向图
- en: 'Edge lists can represent single, unconnected nodes. For our example graph,
    the edge list would be the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 边列表可以表示单个、未连接的节点。对于我们的示例图，边列表如下：
- en: '[PRE4]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In Python, we can create this as a set of tuples:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以将其创建为一组元组：
- en: '[PRE5]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On performance, for storage, the space complexity of an edge list is O(*e*),
    where *e* is the number of edges. Regarding our two tasks shown previously, to
    establish the existence of a particular edge will have a time complexity of **O**(*e*),
    assuming an unordered edge list. To discover all the neighbors of a node, **O**(*e*)
    is the space complexity. In each case, we have to go through the edges in the
    list one by one to check for the edge or the node’s neighbor. So, from a compute
    performance point of view, edge lists have a disadvantage compared to the other
    two data structures, especially for executing more complex algorithms.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，对于存储，边列表的空间复杂度为O(*e*)，其中*e*是边的数量。关于我们之前显示的两个任务，要建立特定边的存在，假设是无序边列表，其时间复杂度为**O**(*e*)。要发现一个节点的所有邻居，**O**(*e*)是空间复杂度。在每种情况下，我们必须逐个遍历列表中的边来检查边或节点的邻居。因此，从计算性能的角度来看，边列表与其他两种数据结构相比有劣势，尤其是在执行更复杂的算法时。
- en: However, another advantage of edge lists is that they are more compact than
    adjacency lists or adjacency matrices. Additionally, they are simple to both create
    and interpret. For example, we could store an edge list as a text file where each
    line only consists of two identifiers separated by a space. For many systems and
    databases, edge lists in CSV or text files are the default option to serialize
    data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，边列表的另一个优点是它们比邻接列表或邻接矩阵更紧凑。此外，它们易于创建和解释。例如，我们可以将边列表存储为文本文件，其中每行只包含两个由空格分隔的标识符。对于许多系统和数据库，CSV或文本文件中的边列表是序列化数据的默认选项。
- en: The Laplacian matrix
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 拉普拉斯矩阵
- en: One data representation of a graph that is highly valuable in analyzing graphs
    is the Laplacian matrix, as mentioned earlier. This matrix is key to the development
    of graph spectral theory, which is in turn critical to the development of spectral-based
    GNN methods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，图的一种非常有价值的数据表示是拉普拉斯矩阵。这个矩阵是图谱理论发展的关键，而图谱理论又是基于谱的GNN方法发展的关键。
- en: To produce the Laplacian matrix, we subtract the adjacency matrix from the degree
    matrix (D – A). The degree matrix is a node-to-node matrix whose values are the
    degree of a particular node. The degree matrix for our example graph is given
    in the first table and the Laplacian matrix follows.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成拉普拉斯矩阵，我们需要从度矩阵中减去邻接矩阵（D - A）。度矩阵是一个节点到节点的矩阵，其值是特定节点的度。我们示例图的度矩阵在第一张表中给出，拉普拉斯矩阵随后给出。
- en: '![sidebar figure](../Images/table_A-1.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![侧边栏图](../Images/table_A-1.png)'
- en: Degree matrix for our example graph
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 我们示例图的度矩阵
- en: '![sidebar figure](../Images/table_A-2.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![侧边栏图](../Images/table_A-2.png)'
- en: Laplacian matrix for our example graph
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 我们示例图的拉普拉斯矩阵
- en: In practice, Laplacian matrices aren’t used for storage or as a basis for graph
    operations like the other data structures covered in this section. Their advantages
    lie in spectral analysis. We discuss spectral graph analysis in chapter 3.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，拉普拉斯矩阵不像本节中介绍的其他数据结构那样用于存储或作为图操作的依据。它们的优点在于谱分析。我们将在第3章讨论谱图分析。
- en: A.2.2 Relational databases
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.2 关系数据库
- en: We’re steadily marching from theory to implementation. In the previous section,
    we reviewed common data structures used to represent graphs and their tradeoffs.
    Graphs can be implemented in these structures from scratch in your preferred programming
    language and are also implemented in popular graph processing libraries.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正稳步地从理论走向实践。在前一节中，我们回顾了用于表示图及其权衡的常见数据结构。您可以使用首选的编程语言从零开始在这些结构中实现图，并且这些结构也已在流行的图处理库中得到实现。
- en: With the listed data structures, we have a variety of ways to implement the
    structural information in graphs. But graphs and their elements often come with
    useful attributes and metadata.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列出的数据结构，我们有多种方式来实现图中的结构信息。但是，图及其元素通常带有有用的属性和元数据。
- en: A *relational database* is an organized way to represent the structural information,
    attributes, and metadata of a graph. Very much related to this is the notion of
    a *schema*, which is a framework that explicitly defines the elements that make
    up a graph (i.e., varieties of nodes and edges, attributes, etc.), and explicitly
    defines how these elements work together.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*关系数据库*是一种有组织地表示图的结构信息、属性和元数据的方式。这与*模式*的概念密切相关，模式是一个框架，它明确地定义了构成图（即，节点的种类和边，属性等）的元素，并明确地定义了这些元素如何协同工作。'
- en: Data models and schemas are critical parts of the scaffolding used to design
    graph systems such as graph databases and graph processing systems, and they often
    build on the data structures reviewed in the previous section. We’ll review three
    such models and provide examples of real systems where they are used.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型和模式是设计图系统（如图数据库和图处理系统）所使用的脚手架的关键部分，并且它们通常建立在上一节中审查的数据结构之上。我们将审查三种此类模型，并提供它们在实际系统中使用的示例。
- en: Minimalist graph data model
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最简图数据模型
- en: The simplest relational database uses only nodes, edges, and weights. It can
    be used on directed or undirected graphs. If weights are used, they can be retrieved
    using a lookup table.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的关系数据库仅使用节点、边和权重。它可以用于有向图或无向图。如果使用权重，可以使用查找表检索。
- en: Pregel, Google’s graph processing framework, which other popular frameworks
    are based on (including Apache Giraph used by Facebook, and Apache Spark GraphX),
    relies on such a directed graph. There, both edges and nodes have an identifier
    and a single numerical value, which can be interpreted as a weight or attribute.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Pregel，谷歌的图处理框架，其他流行框架（包括Facebook使用的Apache Giraph和Apache Spark GraphX）都基于此有向图。在那里，边和节点都有一个标识符和一个单一的数值，这可以解释为权重或属性。
- en: RDF graph data model
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: RDF图数据模型
- en: Resource Description Framework (RDF; aka Triple Stores) models follow a subject-predicate-object
    pattern, where nodes are subjects and objects, and edges are predicates. Nodes
    and edges have one main attribute, which can be a unique resource identifier (URI)
    or a literal. URIs, in essence, identify the type of node or edge being described.
    Examples of literals can be specific timestamps or dates. Predicates represent
    relationships. Such triples (subject-predicate-object) represent what are called
    *facts* in this context. Usually, facts are directed and flow in the direction
    from subject to object.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 资源描述框架（RDF；又称三元组存储）模型遵循主语-谓语-宾语模式，其中节点是主语和宾语，边是谓语。节点和边有一个主要属性，可以是唯一的资源标识符（URI）或字面量。本质上，URI标识了所描述节点或边的类型。字面量的例子可以是特定的时间戳或日期。谓语代表关系。这样的三元组（主语-谓语-宾语）代表在这个上下文中称为*事实*的内容。通常，事实是有向的，并从主语流向宾语。
- en: Popular graph databases that use the RDF model include Amazon’s Neptune (Neptune
    also allows the use of labeled property graphs [LPGs]), Virtuoso, and Stardog.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RDF模型的流行图数据库包括亚马逊的Neptune（Neptune还允许使用标签属性图[LPGs]），Virtuoso和Stardog。
- en: Property graph data model
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性图数据模型
- en: 'In property graphs (aka LPGs), allowances are made to confer various metadata
    to nodes and edges. Such metadata include the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性图（又称LPGs）中，允许为节点和边赋予各种元数据。此类元数据包括以下内容：
- en: '*Identifiers* —Distinguish individual nodes and edges.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标识符* — 区分单个节点和边。'
- en: '*Labels* —Describe classes (or subsets) of nodes or edges.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标签* — 描述节点或边的类别（或子集）。'
- en: '*Attributes or properties* —Describe individual nodes or edges.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性或属性* — 描述单个节点或边。'
- en: Nodes have an ID and a set of key/value pairs that can be used to supply additional
    attributes (also called properties). Similarly, edges have an ID and a set of
    key/value pairs for attributes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 节点有一个ID和一组键/值对，可以用来提供额外的属性（也称为属性）。同样，边也有一个ID和一组键/值对用于属性。
- en: You can think of the property graph as the minimalist graph extended by adding
    labels and removing the restrictions on the types and number of attributes. Figure
    A.11 provides a look at a property graph and its equivalent RDF graph. Popular
    graph databases that use models based on the property graph include Neo4j, Azure
    Cosmos, and TigerGraph.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将属性图视为通过添加标签并取消对属性类型和数量的限制来扩展的最简图。图A.11提供了查看属性图及其等效的RDF图的机会。使用基于属性图模型的流行图数据库包括Neo4j、Azure
    Cosmos和TigerGraph。
- en: '![figure](../Images/A-11.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/A-11.png)'
- en: Figure A.11 Example of a property graph and its equivalent RDF graph
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图A.11 属性图及其等效的RDF图示例
- en: Nongraph data model
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 非图数据模型
- en: There are a variety of databases and systems that use neither RDF nor LPG. These
    databases and systems store or express nodes, edges, and attributes within other
    storage frameworks, such as document stores, key value stores, and even within
    a relational database framework.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多数据库和系统既不使用RDF也不使用LPG。这些数据库和系统在其他存储框架中存储或表达节点、边和属性，例如文档存储、键值存储，甚至在关系数据库框架内。
- en: Knowledge graphs
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 知识图谱
- en: Although the term is used widely in academic, commercial, and practitioner circles,
    there is no unifying definition of a knowledge graph. Most relevant to GNNs, we
    define a *knowledge graph* as a representation of knowledge discretized into facts,
    as defined earlier. In other words, a knowledge graph is a multigraph set onto
    a specific *subject-relationship-object* schema.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该术语在学术界、商业界和实践者圈子中被广泛使用，但并没有一个统一的定义。对于 GNNs 来说，最相关的是，我们将*知识图谱*定义为将知识离散化为事实的表示，如之前定义的。换句话说，知识图谱是一个多图集，它被映射到一个特定的*主题-关系-对象*模式上。
- en: Knowledge graphs may be represented with RDF schemas, but there are other data
    models and graph models that can accommodate knowledge graphs. GNN methods are
    used to embed the data in the nodes and edges, establish the quality of facts,
    and discover new entities and relations. An example of a knowledge graph is shown
    in figure A.12\.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 知识图谱可以用 RDF 模式表示，但还有其他数据模型和图模型可以容纳知识图谱。GNN 方法用于在节点和边中嵌入数据，建立事实的质量，并发现新的实体和关系。一个知识图谱的例子在图
    A.12 中展示。
- en: '![figure](../Images/A-12.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/A-12.png)'
- en: Figure A.12 An example of a knowledge graph representing an academic research
    network within a university’s physics department. The graph illustrates both hierarchical
    relationships, such as professors and students being members of the department,
    and behavioral relationships, such as professors supervising students and authoring
    papers. Entities such as Prof, Student, Paper, and Topic are connected through
    semantically meaningful relationships (e.g., Supervises, Wrote, and Inspires).
    Entities also have detailed features (e.g., Name, Department, and Type) to provide
    further context. The semantic connections and features enable advanced querying
    and analysis of complex academic interactions.
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 A.12 一个知识图谱示例，表示大学物理系内的学术研究网络。该图展示了层级关系，例如教授和学生是该系的成员，以及行为关系，例如教授指导学生和撰写论文。实体如教授、学生、论文和主题通过语义上有意义的关系（例如，监督、撰写和启发）相连。实体还具有详细特征（例如，姓名、系别和类型），以提供更多上下文。语义连接和特征使得对复杂的学术互动进行高级查询和分析成为可能。
- en: Node and edge types
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 节点和边类型
- en: In graphs that have a schema, including knowledge graphs, the edges and nodes
    can be assigned a *type*. *Types* are part of a defined schema, and as such, govern
    how data elements interact with each other. They also often have a descriptive
    aspect. To distinguish *types* from *properties*, consider that while types help
    define the rules of how data elements work together and how they are interpreted
    by the data system, properties are descriptive only.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有模式（包括知识图谱）的图中，边和节点可以被分配一个*类型*。*类型*是定义模式的一部分，因此，它们决定了数据元素如何相互作用以及它们如何被数据系统解释。它们通常也具有描述性。为了区分*类型*和*属性*，考虑一下，虽然类型有助于定义数据元素如何一起工作以及它们如何被数据系统解释的规则，但属性仅具有描述性。
- en: 'To illustrate types, we can use a road map analogy, where towns are nodes,
    and passages between them are edges. Our edges may include highways, footpaths,
    canals, or bike paths. Each one is a type. Due to geography, towns can be surrounded
    by swamps, sit atop mountain peaks, or have other obstacles and impediments to
    one versus another passage. For towns separated by a desert, passage is only possible
    by a highway. For other towns, passages can be by multiple passage types. In building
    this analogy, we see that our town nodes also have types defined by their proximate
    geography: swamp town, desert town, island town, valley town.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明类型，我们可以使用一个路线图类比，其中城镇是节点，它们之间的通道是边。我们的边可能包括高速公路、小径、运河或自行车道。每一种都是一个类型。由于地理原因，城镇可能被沼泽包围，位于山顶上，或者有其他障碍和阻碍，使得一条通道相对于另一条通道难以通行。对于被沙漠隔开的城镇，通道只能通过高速公路。对于其他城镇，通道可以通过多种通道类型。在这个类比中，我们注意到我们的城镇节点也由它们邻近的地理特征定义了类型：沼泽城镇、沙漠城镇、岛屿城镇、山谷城镇。
- en: A.2.3 How graphs are exposed
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.3 如何展示图
- en: 'We’ve talked about relational data structures and relational databases to understand
    how graphs are constructed and stored. In real life, however, most of us won’t
    build graphs from scratch or from the bottom up. When constructing and analyzing
    graphs, there will be a layer of abstraction between us and the primitive data.
    In what ways, then, is a graph exposed to the data scientist or engineer? Next,
    we’ll briefly explain the following two ways and then discuss the graph ecosystem:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了关系数据结构和关系数据库，以了解图是如何构建和存储的。然而，在现实生活中，我们中的大多数人不会从头开始或从底层构建图。在构建和分析图时，我们和原始数据之间将有一个抽象层。那么，图以何种方式暴露给数据科学家或工程师呢？接下来，我们将简要解释以下两种方式，然后讨论图生态系统：
- en: '*APIs* —Using graph libraries or data processing systems'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*APIs*—使用图库或数据处理系统'
- en: '*Query languages* —Querying graph databases via specialized query languages'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查询语言*—通过专用查询语言查询图数据库'
- en: 'APIs: Graph objects in graph systems'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: APIs：图系统中的图对象
- en: When using a graph library or processing software, usually we want the graph
    we work with to have certain properties and to be able to execute operations on
    the graph. From this lens, it’s helpful to think of graphs as software objects
    that can be operated on by software functions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用图库或处理软件时，我们通常希望我们工作的图具有某些属性并且能够在图上执行操作。从这个角度来看，将图视为可以由软件函数操作的软件对象是有帮助的。
- en: In Python, an effective way to implement these is to have a graph class, with
    some operations implemented as methods of the graph class or as standalone functions.
    Nodes and edges can be attributes of the graph class, or they can have their own
    node and edge classes. Properties of graphs implemented in this way can be attributes
    of the respective classes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，实现这些的一个有效方法是拥有一个图类，其中一些操作作为图类的方法或作为独立的函数实现。节点和边可以是图类的属性，或者它们可以有自己的节点和边类。以这种方式实现的图属性可以是相应类的属性。
- en: An example of this is `NetworkX`, a Python-based graph processing library. `NetworkX`
    implements a graph class. Nodes can be any hashable object; examples of node objects
    are integers, strings, files, and even functions. Edges are tuple objects of their
    respective nodes. Both nodes and edges can have properties implemented as Python
    dictionaries. Following are two short lists of typical methods and attributes
    of graph classes found in libraries and processing systems.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`NetworkX`是一个基于Python的图处理库。`NetworkX`实现了一个图类。节点可以是任何可哈希的对象；节点对象的例子包括整数、字符串、文件，甚至是函数。边是它们各自节点的元组对象。节点和边都可以有作为Python字典实现的属性。以下是在库和系统中找到的图类的典型方法和属性的两个简短列表。
- en: Basic methods of graph objects
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图对象的基本方法
- en: 'In the following list, we outline some of the methods that can be applied to
    graph objects:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们概述了一些可以应用于图对象的方法：
- en: '`Graph_Creation`—A constructor that creates a new graph object'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Graph_Creation`—一个构造函数，用于创建新的图对象'
- en: '`Add_Node`, `Add_Edge`—Adds nodes or edges, and their attributes and labels,
    if any'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add_Node`, `Add_Edge`—添加节点或边，以及它们的属性和标签（如果有）'
- en: '`Get_Node`, `Get_Edge`—Retrieves stored nodes or edges, with specified attributes
    and labels'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get_Node`, `Get_Edge`—检索存储的节点或边，带有指定的属性和标签'
- en: '`Update_Node`, `Updage_Edge`, `Update_Graph`—Updates properties and attributes
    of nodes, edges, and graph objects'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update_Node`, `Updage_Edge`, `Update_Graph`—更新节点、边和图对象的属性和属性'
- en: '`Delete_Node`, `Delete_Edge`—Deletes a specified node or edge'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Delete_Node`, `Delete_Edge`—删除指定的节点或边'
- en: Basic attributes of graph objects
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图对象的基本属性
- en: 'In the following list, we outline some of the attributes for graph objects:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们概述了一些图对象的属性：
- en: '`Number_of_Nodes`, `Number_of_Edges`—A constructor that creates a new graph
    object'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number_of_Nodes`, `Number_of_Edges`—一个构造函数，用于创建新的图对象'
- en: '`Node_Neighbors`—Retrieves the adjacent nodes or incident edges of a node'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Node_Neighbors`—检索节点的相邻节点或相关边'
- en: '`Node_List`, `Edge_List`—Adds nodes or edges and their attributes and labels,
    if any'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Node_List`, `Edge_List`—添加节点或边及其属性和标签（如果有）'
- en: '`Connected_Graph`—Retrieves stored nodes or edges, with specified attributes
    and labels'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Connected_Graph`—检索存储的节点或边，带有指定的属性和标签'
- en: '`Graph_State`—Retrieves global attributes, labels, and properties of the graph'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Graph_State`—检索图的全局属性、标签和属性'
- en: '`Directed_Graph`—Deletes a specified node or edge'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Directed_Graph`—删除指定的节点或边'
- en: Graph query languages
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图查询语言
- en: 'When working with a graph in a graph database, a query language is used. For
    most relational databases, some variant of SQL is used as the standard language.
    In the graph database space, there is no standard query language. Following are
    the languages that currently stand out:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在图数据库中处理图时，使用查询语言。对于大多数关系数据库，SQL的某个变体被用作标准语言。在图数据库领域，没有标准查询语言。以下是当前突出的语言：
- en: '*Gremlin*—A language that can be written declaratively or imperatively, which
    is designed for database or processing system queries. Developed by the Apache
    TinkerPop project, Gremlin is used in several databases (Titan, OrientDB) and
    processing systems (Giraph, Hadoop, Spark).'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Gremlin*——一种可以声明性或命令性编写的语言，专为数据库或处理系统查询设计。由Apache TinkerPop项目开发，Gremlin被用于多个数据库（Titan、OrientDB）和处理系统（Giraph、Hadoop、Spark）。'
- en: '*Cypher*—A declarative language for property graph–based database queries.
    Developed by Neo4j, Cypher is used by Neo4j and several other databases.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Cypher*——一种基于属性图数据库查询的声明性语言。由Neo4j开发，Cypher被Neo4j和其他几个数据库使用。'
- en: '*SPARQL*—A declarative query language for RDF-based database queries. SPARQL
    is used by Amazon Neptune, AllegroGraph, and others.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SPARQL*——一种基于RDF数据库查询的声明性查询语言。SPARQL被Amazon Neptune、AllegroGraph等使用。'
- en: A.3 Graph systems
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 图系统
- en: We’ve covered the basic building blocks that allow us to implement graphs in
    a programming language. In practice, you’ll seldom create a graph from scratch
    because you’ll load data into memory or a database using a library or API. The
    field of graph libraries, databases, and commercial software is broad and growing
    rapidly. A good way to determine what to use is to start with your use case and
    requirements, and then choose your development and deployment architecture from
    there. This section will briefly give an overview of this landscape to help you.
    The taxonomy we develop here is by no means absolute but should serve as a useful
    guideline.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了允许我们在编程语言中实现图的基本构建块。在实践中，你很少从头创建图，因为你将使用库或API将数据加载到内存或数据库中。图库、数据库和商业软件领域广泛且发展迅速。确定要使用什么的一个好方法是先从你的用例和需求开始，然后根据这些选择你的开发和部署架构。本节将简要概述这一领域，以帮助你。我们在这里开发的分类法绝不是绝对的，但应作为有用的指南。
- en: 'At the time of writing, commercial and open source tools for graph analysis,
    machine learning modeling, visualization, and storage are expanding relatively
    rapidly. With a lot of overlap between tools and functions, as well as many hybrid
    tools that don’t neatly fit into any category, there is no clean delineation of
    segments. Given this, we just highlight basic methods and focus on the most popular
    tools in the following segments:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，商业和开源的图分析、机器学习建模、可视化和存储工具正在相对快速地扩展。由于工具和功能之间存在大量重叠，以及许多混合工具无法完美地归入任何类别，因此没有清晰的细分。鉴于此，我们只突出基本方法，并专注于以下各段中最受欢迎的工具：
- en: Graph databases
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据库
- en: Graph compute engines (or graph frameworks)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图计算引擎（或图框架）
- en: Visualization libraries
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化库
- en: GNN libraries
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNN库
- en: A.3.1 Graph databases
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.1 图数据库
- en: Graph databases are the graph analogues of traditional relational databases
    from a functional standpoint. Such databases were devised to handle transactions
    focused on Online Transaction Processing (OLTP). They allow CRUD transactions
    and also tend to follow ACID (atomicity, consistency, isolation, and durability)
    principles regarding the integrity of the data. Graph databases of this type differ
    from relational databases in that they store data using graph data models and
    schemas. At the time of writing, the most popular graph databases are Neo4j, Microsoft
    Cosmos DB, OrientDB, and ArangoDB. Except for Neo4j, these databases support multiple
    models, including property graphs. Neo4j supports property graphs only. The most
    popular databases that support RDF models are Virtuoso and Amazon Neptune.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能角度来看，图数据库是传统关系数据库的图类似物。这类数据库是为了处理以在线事务处理（OLTP）为中心的交易而设计的。它们允许CRUD事务，并且通常遵循ACID（原子性、一致性、隔离性和持久性）原则，以确保数据的完整性。这类图数据库与关系数据库的不同之处在于，它们使用图数据模型和模式来存储数据。在撰写本文时，最受欢迎的图数据库包括Neo4j、Microsoft
    Cosmos DB、OrientDB和ArangoDB。除了Neo4j之外，这些数据库支持多种模型，包括属性图。Neo4j仅支持属性图。支持RDF模型的最受欢迎的数据库是Virtuoso和Amazon
    Neptune。
- en: In addition to property graphs and RDF databases, other types of nongraph databases
    are used to store graph data. Document stores, relational databases, and key-value
    stores are examples. To use such nongraph databases with graph data models, you
    must carefully define how the existing schema maps to the graph elements and their
    attributes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 除了属性图和 RDF 数据库之外，其他类型的非图数据库也用于存储图数据。文档存储、关系数据库和键值存储是例子。要使用此类非图数据库与图数据模型一起使用，必须仔细定义现有模式如何映射到图元素及其属性。
- en: A.3.2 Graph compute engines (or graph frameworks)
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.2 图计算引擎（或图框架）
- en: Graph compute engines are designed to make queries using batches of data. Such
    queries can output aggregate statistics or output graph-specific items, such as
    cluster identification and find shortest paths. These data systems tend to follow
    the Online Application Processing (OLAP) model. It’s not unusual for such systems
    to work closely with a graph database, which serves the input data batches needed
    for the analytic queries. Examples of such systems include Apache Spark’s GraphX,
    Giraph, and Stanford Network Analysis Platform (SNAP).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图计算引擎旨在使用数据批次进行查询。此类查询可以输出汇总统计信息或输出特定于图的项，例如聚类识别和找到最短路径。这些数据系统通常遵循在线应用处理（OLAP）模型。此类系统与图数据库紧密合作，提供用于分析查询所需的数据批次，并不罕见。此类系统的例子包括
    Apache Spark 的 GraphX、Giraph 和斯坦福网络分析平台（SNAP）。
- en: A.3.3 Visualization libraries
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.3 可视化库
- en: Graph visualization tools share characteristics with graph compute engines,
    as they are geared toward analytics versus transactional queries and computations.
    However, such tools are designed to create aesthetic and useful images of the
    networks under analysis. In the best visualization tools, these images are interactive
    and dynamic. Outputs of visualization systems can be optimized for presentation
    on the web, or in printed format with high definition. Examples of such tools
    are Gephi, Cytoscape, and Tulip.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图可视化工具与图计算引擎具有相似的特征，因为它们旨在进行数据分析而非事务性查询和计算。然而，此类工具的设计目的是创建美观且实用的网络分析图像。在最佳可视化工具中，这些图像是交互式和动态的。可视化系统的输出可以优化用于网页展示或以高分辨率打印的格式。此类工具的例子包括
    Gephi、Cytoscape 和 Tulip。
- en: A.3.4 GNN libraries
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.4 GNN 库
- en: The last segment of graph tools is the central subject of this book. Here, we’re
    grouping software tools that create graph embeddings with tools that train the
    models using graph data. At the time of writing, there are many solutions available.
    Graph representation tools range from dedicated, standalone libraries (PyTorch
    BigGraph [PBG]) to graph systems that have embedding as a feature (Neo4j as a
    database and SNAP as a compute framework).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图工具的最后一段是本书的核心主题。在这里，我们将创建图嵌入的软件工具与使用图数据进行模型训练的工具分组。在撰写本文时，有许多解决方案可供选择。图表示工具的范围从专门的独立库（PyTorch
    BigGraph [PBG]）到具有嵌入功能的图系统（Neo4j 作为数据库和 SNAP 作为计算框架）。
- en: GNN libraries come as standalone libraries, and as libraries that use TensorFlow
    or PyTorch as a backend. In this text, the focus will be on PyTorch Geometric
    (PyG). Other popular libraries include Deep Graph Library (DGL; a standalone library)
    and Spektral, which uses Kera and TensorFlow as a backend. The best libraries
    implement not only a range of deep learning layers but also the available benchmark
    datasets.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: GNN 库既可以作为独立的库，也可以作为使用 TensorFlow 或 PyTorch 作为后端的库。在本文中，我们将重点关注 PyTorch Geometric（PyG）。其他流行的库包括
    Deep Graph Library（DGL；一个独立的库）和 Spektral，后者使用 Kera 和 TensorFlow 作为后端。最好的库不仅实现了多种深度学习层，还包括可用的基准数据集。
- en: A.4 Graph algorithms
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.4 图算法
- en: As the field of graphs has been around for a while, the number of different
    graph algorithms is vast. Understanding well-used graph algorithms can provide
    valuable context with which to think about the algorithms used in neural networks.
    Graph algorithms can also serve as sources of node, edge, or graph features for
    GNNs. Finally, as with all machine learning methods, sometimes a statistical model
    isn’t the best solution. Understanding the analytical landscape can help when
    deciding whether or not to use a GNN solution.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图论领域已经存在一段时间了，不同的图算法数量庞大。深入了解常用的图算法可以为思考神经网络中使用的算法提供有价值的背景。图算法还可以作为 GNN 的节点、边或图特征的来源。最后，与所有机器学习方法一样，有时统计模型并不是最佳解决方案。了解分析景观有助于在决定是否使用
    GNN 解决方案时做出选择。
- en: In this section, we review two types of graph algorithms, *search algorithms*
    and *shortest path*. We provide a general description, explaining why they are
    important. For an in-depth treatment on this topic, review the references for
    this appendix at the end of the book, particularly [1–3].
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾两种图算法类型，*搜索算法*和*最短路径*。我们提供了一般描述，解释了为什么它们很重要。对于这个主题的深入探讨，请参阅本书末尾附录的参考文献，特别是[1-3]。
- en: A.4.1 Traversal and search algorithms
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.1 遍历和搜索算法
- en: In section A.1.1, we discussed the concept of a walk and a path. In these fundamental
    concepts, we get from one node in a graph to another by traversing a set of nodes
    and edges between them.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在A.1.1节中，我们讨论了行走的概念和路径的概念。在这些基本概念中，我们通过遍历节点和它们之间的边从图中的一个节点到达另一个节点。
- en: For large graphs with many nonunique walks and paths between node pairs, how
    do we decide which path to take? Similarly, for graphs we haven’t explored and
    don’t have a map of, what is the best way to create that map? Wrapped into these
    questions is the problem of what direction to take when traversing a graph at
    a particular node. For a node of degree 1, this answer is trivial; for a node
    with degree 100, the answer is less so.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有许多非唯一路径和节点对之间路径的大图，我们如何决定选择哪条路径？同样，对于尚未探索且没有地图的图，最好的创建地图的方法是什么？这些问题中包含的问题是在特定节点遍历图时选择哪个方向。对于度为1的节点，这个答案很简单；对于度为100的节点，答案就不那么简单了。
- en: 'Traversal algorithms offer systematic ways to walk a graph. For such algorithms,
    we start at a node, and following a set of rules, we decide on the next node to
    hop to. Often, as we conduct the walk, we keep track of nodes and edges that have
    been encountered. For certain algorithms, if we outline the path taken, we can
    end up with a tree structure. Three well known strategies for traversal are given
    here:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历算法提供了一种系统地遍历图的方法。对于此类算法，我们从节点开始，遵循一组规则，决定跳转到下一个节点。通常，在我们进行遍历时，我们会记录遇到的节点和边。对于某些算法，如果我们概述所采取的路径，我们最终可能会得到一个树结构。这里给出了三种著名的遍历策略：
- en: '*Breadth first* —A breadth-first traversal prefers to explore all of the immediate
    neighbors of a node before going further away. This is also known as breadth-first
    search (BFS).'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*广度优先搜索* — 广度优先遍历倾向于在探索节点的所有直接邻居之后再探索更远的节点。这也被称为广度优先搜索（BFS）。'
- en: '*Depth first* —With depth-first search (DFS), rather than explore every immediate
    neighbor first, we follow each new node without regard to its relationship to
    the current node. This is done in such a way that every node is encountered *at
    least* once, and every edge is encountered *exactly* once.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深度优先搜索* — 使用深度优先搜索（DFS），我们不是首先探索每个直接邻居，而是不考虑当前节点与新的节点之间的关系，跟随每个新节点。这样做的方式是每个节点至少被遇到一次，每条边恰好被遇到一次。'
- en: There are versions of DFS and BFS for directed graphs as well.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有向图也有DFS和BFS的版本。
- en: '*Random* —In random traversals, in contrast to BFS and DFS, where traversal
    is governed by a set of rules, traversal to the next node is done randomly. For
    a starting node of degree 4 in a random traversal with a uniform distribution,
    each neighboring node would have a 25% chance of being chosen. Such methods are
    used in algorithms such as DeepWalk and Node2Vec (covered in chapter 2).'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*随机* — 与BFS和DFS不同，在随机遍历中，遍历受一组规则控制，到下一个节点的遍历是随机的。在一个具有4度起始节点的随机遍历中，每个相邻节点被选中的概率都是25%。这种方法在DeepWalk和Node2Vec等算法（在第2章中介绍）中使用。'
- en: A.4.2 Shortest path
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.2 最短路径
- en: 'An enduring problem highly related to graphs is that of the shortest path.
    Interest in solving this problem has existed for decades (a great survey paper
    of shortest path methods was published as far back as 1969 [4]), with several
    distinct algorithms existing. Modern applications of shortest path methods are
    used in navigation applications, such as finding the fastest route to a destination.
    Variations of such algorithms include the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 与图高度相关的持久性问题之一是最短路径问题。解决这个问题的兴趣已经存在了几十年（早在1969年就发表了一篇关于最短路径方法的优秀综述论文[4]），存在几种不同的算法。现代最短路径方法的应用包括导航应用，如找到到达目的地的最快路线。此类算法的变体包括以下内容：
- en: Shortest path between
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个节点之间的最短路径
- en: Two nodes
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个节点
- en: Two nodes on a path that includes specified nodes
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含指定节点的路径上的两个节点
- en: All nodes
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有节点
- en: One node to all others
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个节点到所有其他节点
- en: Ranked shortest paths (i.e., second shortest path, third shortest, etc.)
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序最短路径（即，第二短路径、第三短路径等）
- en: Such algorithms can also take into account weights in graphs. In these cases,
    shortest path algorithms are also called least-cost algorithms.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法也可以考虑图中的权重。在这些情况下，最短路径算法也被称为最低成本算法。
- en: A highly lauded algorithm for least-cost determination is Dijkstra’s algorithm.
    Given a node, it finds the shortest path to every other node or to a specified
    node. As this algorithm progresses, it traverses the graph while keeping track
    of the distance and connecting nodes (to the start node) of each node it encounters.
    It prioritizes the nodes encountered by their shortest (or least-cost) path to
    the start node. As the algorithm traverses, it prioritizes low-cost paths.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一种备受赞誉的最低成本确定算法是迪杰斯特拉算法。给定一个节点，它找到到每个其他节点或指定节点的最短路径。随着算法的进行，它遍历图，同时跟踪每个遇到的节点（到起始节点）的距离和连接节点。它优先考虑遇到的节点，这些节点通过最短（或最低成本）路径到达起始节点。随着算法的遍历，它优先考虑低成本路径。
- en: A.5 How to read GNN literature
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.5 如何阅读 GNN 文献
- en: GNNs are a rapidly proliferating topic. New methods and techniques have been
    proposed in a short span of time. Though this book focuses on practical and commercial
    applications of graphs, much of the state of the art in this field is disclosed
    in academic journals and conferences. Knowing how to effectively study publications
    from these sources is essential to keep up to speed with the field and to encounter
    valuable ideas that can be implemented in code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: GNNs 是一个快速发展的主题。在很短的时间内提出了新的方法和技术。尽管这本书侧重于图的实际和商业应用，但该领域的许多最先进的技术都披露在学术期刊和会议上。了解如何有效地研究这些来源的出版物对于跟上该领域的发展并遇到可以实施在代码中的有价值的想法至关重要。
- en: 'In this short section, we list some commonly used notations to describe graphs
    in technical publications as well as a few tips on reading academic literature
    for the practitioner. These tips are especially for those interested in using
    the methodology in a paper but are working under time constraints:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们列出了一些常用的符号来描述技术出版物中的图，以及一些针对实践者的阅读学术文献的技巧。这些技巧尤其适用于那些对在论文中使用该方法但受时间限制的人：
- en: To efficiently extract value from a paper, be selective on which sections of
    the publication to focus on. It’s important to clearly understand the problem
    statement and the solution to translate this into code. This might sound obvious,
    but many papers include sections that, for a practitioner, can be distracting
    at best. Mathematical proofs and long historical notes are good examples.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了有效地从论文中提取价值，要选择性地关注出版物中的哪些部分。清楚地理解问题陈述和解决方案对于将其转换为代码至关重要。这听起来可能很显然，但许多论文包括一些对于实践者来说最多只能分散注意力的部分。数学证明和冗长的历史注释是很好的例子。
- en: A positive trend is the increasing inclusion of code and data in research papers
    to enhance reproducibility. However, replicating results may still be challenging
    due to factors like model-specific optimizations or hardware constraints. If you
    encounter difficulties, reaching out to the authors can often provide valuable
    clarification.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个积极的趋势是越来越多的研究论文中包含代码和数据，以增强可重复性。然而，由于模型特定的优化或硬件限制等因素，复制结果可能仍然具有挑战性。如果你遇到困难，联系作者通常可以提供有价值的澄清。
- en: Look closely at indicators of the application scope of the problem and solution.
    An exciting development may not be applicable to your problem, and it may not
    be immediately obvious. Similarly, don’t take all claims for state-of-the-art
    results at face value. The academic world is extremely competitive and claimed
    state-of-the-art results may not hold, especially if a paper isn’t yet peer-reviewed.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细观察问题和解决方案的应用范围指标。一个令人兴奋的发展可能不适用于你的问题，而且可能并不立即明显。同样，不要将所有关于最先进成果的声明都视为理所当然。学术界竞争非常激烈，声称的最先进成果可能并不成立，尤其是如果论文尚未经过同行评审。
- en: A.5.1 Common graph notations
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.5.1 常见图符号
- en: 'In mathematical notation, a graph is described as a set of nodes and edges:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学符号中，图被描述为一组节点和边：
- en: (A.1) *G* = (*V*, *E  *)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: (A.1) *G* = (*V*, *E*)
- en: 'where *V* and *E* are collections or sets of vertices (nodes) and edges, respectively.
    When we want to express the count of elements in these collections, we use *|V|*
    and *|E|*. In the following list, we outline some of the typical nomenclature
    for the mathematics of graphs:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *V* 和 *E* 分别是顶点（节点）和边的集合或集合。当我们想要表达这些集合中元素的数量时，我们使用 *|V|* 和 *|E|*。在以下列表中，我们概述了一些图数学的典型命名法：
- en: For directed graphs, an accented G (*![equation image](../Images/eq-appendix-a-269-1.png)*)
    is sometimes, but not always used.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于有向图，有时但并不总是使用带重音的 G (*![equation image](../Images/eq-appendix-a-269-1.png)*)。
- en: Individual nodes and edges are denoted by lowercase letters, *v* and *e*, respectively.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个节点和边分别用小写字母 *v* 和 *e* 表示。
- en: When referring to a pair of adjacent nodes, we use *u* and *v*. Thus, an edge
    can also be expressed as {*u*, *v*}, or *uv*.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当提到一对相邻节点时，我们使用 *u* 和 *v*。因此，一条边也可以表示为 {*u*, *v*} 或 *uv*。
- en: When dealing with weighted graphs, a weight for a particular edge is expressed
    as *w*(*e*). In terms of an edge’s nodes, we can include the weight as {*u*, *v*,
    *w*}.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理带权图时，特定边的权重表示为 *w*(*e*)。就边的节点而言，我们可以将权重包括在内，表示为 {*u*, *v*, *w*}。
- en: To express the features of a graph or its elements, we use the notation *x*
    or **x** when the features are expressed as a vector or matrix, respectively.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了表达图或其元素的特征，当特征以向量或矩阵的形式表示时，我们使用符号 *x* 或 **x**。
- en: 'For graph representations, because many such representations are matrices,
    bold letters are used to express them: **A** for the adjacency matrix, **L** for
    the Laplacian matrix, and so on.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于图表示，因为许多这样的表示是矩阵，所以使用粗体字母来表示它们：**A** 表示邻接矩阵，**L** 表示拉普拉斯矩阵，等等。
