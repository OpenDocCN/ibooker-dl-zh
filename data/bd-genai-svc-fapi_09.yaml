- en: Capitolo 6\. Comunicazione in tempo realecon i modelli generativi
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 使用生成模型进行实时通信
- en: 'Questo lavoro è stato tradotto utilizzando l''AI. Siamo lieti di ricevere il
    tuo feedback e i tuoi commenti: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这项工作使用了AI进行翻译。我们很高兴收到您的反馈和评论：[translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)
- en: Questo capitolo esplorerà i carichi di lavoro di AI in streaming come i chatbot,
    illustrando l'uso di tecnologie di comunicazione in tempo reale come SSE e WebSocket.
    Imparerai la differenza tra queste tecnologie e come implementare lo streaming
    di modelli costruendo endpoint per interazioni testo-testo in tempo reale.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨流式AI工作负载，如聊天机器人，展示实时通信技术（如SSE和WebSocket）的使用。你将学习这些技术的区别以及如何通过构建实时文本-文本交互端点来实现模型流。
- en: Meccanismi di comunicazione web
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络通信机制
- en: Nel capitolo precedente hai imparato a implementare la concorrenza nei flussi
    di lavoro dell'intelligenza artificiale sfruttando la programmazione asincrona,
    i task in background e il batching continuo. Con la concorrenza, i tuoi servizi
    diventano più resistenti per far fronte all'aumento della domanda quando più utenti
    accedono all'applicazione simultaneamente. La concorrenza risolve il problema
    di consentire agli utenti simultanei di accedere al tuo servizio e aiuta a diminuire
    i tempi di attesa, ma la generazione dei dati dell'intelligenza artificiale rimane
    un'attività che richiede molte risorse e molto tempo.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何利用异步编程、后台任务和持续批处理来实现人工智能工作流的竞争。有了竞争，你的服务在面对更多用户同时访问应用程序时，需求增加时变得更加健壮。竞争解决了允许同时用户访问你的服务的问题，并有助于减少等待时间，但人工智能数据生成仍然是一项需要大量资源和时间的活动。
- en: Fino a questo punto, hai costruito gli endpoint utilizzando la comunicazione
    HTTP convenzionale in cui il client invia una richiesta al server. Il server web
    elabora le richieste in arrivo e risponde tramite messaggi HTTP.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经使用传统的HTTP通信构建了端点，其中客户端向服务器发送请求。Web服务器处理传入的请求并通过HTTP消息进行响应。
- en: La[Figura 6-1](#client_server_architecture) mostra l'architettura client-server.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-1](#client_server_architecture)展示了客户端-服务器架构。'
- en: '![bgai 0601](assets/bgai_0601.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0601](assets/bgai_0601.png)'
- en: 'Figura 6-1\. L''architettura client-server (Fonte: [scaleyourapp.com](https://scaleyourapp.com))'
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1. 客户端-服务器架构（来源：[scaleyourapp.com](https://scaleyourapp.com))
- en: Poiché il protocollo HTTP è stateless, il server tratta ogni richiesta in arrivo
    in modo completamente indipendente e non correlato alle altre richieste. Ciò significa
    che più richieste in arrivo da client diversi non influenzano il modo in cui il
    server risponde a ciascuna di esse. Ad esempio, in un servizio di intelligenza
    artificiale conversazionale che non utilizza un database, ogni richiesta può fornire
    l'intera cronologia della conversazione e ricevere la risposta corretta dal server.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTTP协议是无状态的，服务器以完全独立和不相关的方式处理每个到达的请求。这意味着来自不同客户端的多个请求不会影响服务器对每个请求的响应方式。例如，在一个不使用数据库的人工智能对话服务中，每个请求都可以提供整个会话的历史记录，并从服务器接收正确的响应。
- en: Il modello *HTTP richiesta-risposta* è un modello di progettazione delle API
    ampiamente adottato in tutto il web grazie alla sua semplicità. Tuttavia, questo
    approccio diventa inadeguato non appena il client o il server necessitano di aggiornamenti
    in tempo reale.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*HTTP请求-响应*模型是因其在整个网络中的简单性而被广泛采用的API设计模型。然而，一旦客户端或服务器需要实时更新，这种方法就变得不适用。'
- en: Nel modello standard HTTP richiesta-risposta, i tuoi servizi rispondono alla
    richiesta dell'utente una volta che questa è stata interamente elaborata. Tuttavia,
    se il processo di generazione dei dati è lungo e lento, i tuoi utenti aspetteranno
    a lungo e successivamente saranno inondati da molte informazioni in una volta
    sola. Immagina di chattare con un bot che impiega diversi minuti per rispondere
    e, una volta risposto, ti vengono mostrati blocchi di testo sovrabbondanti.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的HTTP请求-响应模型中，你的服务在完全处理完用户请求后响应。然而，如果数据生成过程漫长且缓慢，你的用户将等待很长时间，随后会一次性接收到大量信息。想象一下与一个需要几分钟才能回复的聊天机器人聊天，一旦回复，你会看到过多的文本块。
- en: In alternativa, se fornisci i dati al cliente mentre vengono generati, invece
    di aspettare che l'intero processo di generazione sia completato, puoi ridurre
    i lunghi ritardi e fornire le informazioni in pezzi digeribili. Questo approccio
    non solo migliora l'esperienza dell'utente, ma mantiene anche il suo coinvolgimento
    durante l'elaborazione della sua richiesta.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你在数据生成时向客户提供数据，而不是等待整个生成过程完成，你可以减少长时间延迟，并以可消化的片段提供信息。这种方法不仅改善了用户体验，而且在处理请求的过程中保持了用户的参与度。
- en: Ci sono casi in cui l'implementazione di funzioni in tempo reale può essere
    eccessiva e aumentare il carico di sviluppo. Ad esempio, alcuni modelli o API
    open source non hanno la capacità di generare in tempo reale. Inoltre, l'aggiunta
    di endpoint per lo streaming dei dati può aumentare la complessità del sistema
    su entrambi i lati, il server e il client. Significa dover gestire le eccezioni
    in modo diverso e gestire le connessioni simultanee agli endpoint di streaming
    per evitare perdite di memoria. Se il client si disconnette durante uno streaming,
    potrebbe verificarsi una perdita di dati o una deriva di stato tra il server e
    il client. Inoltre, potrebbe essere necessario implementare una complessa logica
    di riconnessione e gestione dello stato per gestire i casi in cui la connessione
    cade.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，实现实时功能可能会过度，并增加开发负担。例如，一些开源模型或API没有实时生成的能力。此外，添加数据流端点可能会增加系统两端的复杂性，包括服务器和客户端。这意味着需要以不同的方式处理异常，并管理对数据流端点的并发连接以避免内存损失。如果客户端在流传输过程中断开连接，可能会发生数据丢失或服务器和客户端之间的状态漂移。此外，可能需要实现复杂的重连和状态管理逻辑来处理连接中断的情况。
- en: Mantenere molte connessioni aperte contemporanee può anche gravare sui tuoi
    server e comportare un aumento dei costi di hosting e di infrastruttura.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 维持许多并发打开的连接也可能对你的服务器造成负担，并导致托管和基础设施成本的增加。
- en: Altrettanto importante è considerare la scalabilità della gestione di un gran
    numero di flussi contemporanei, i requisiti di latenza della tua applicazione
    e la compatibilità del browser con il protocollo di streaming scelto.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是考虑管理大量并发流的可扩展性，你的应用对延迟的要求以及浏览器与所选流协议的兼容性。
- en: Nota
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Rispetto alle applicazioni web tradizionali che hanno una qualche forma di latenza
    di I/O o di elaborazione dei dati, le applicazioni di AI hanno anche una latenza
    di inferenza del modello di AI, a seconda del modello utilizzato.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与具有某种形式的I/O或数据处理延迟的传统Web应用相比，AI应用还有AI模型推断的延迟，这取决于所使用的模型。
- en: Poiché questa latenza può essere significativa, i tuoi servizi di intelligenza
    artificiale devono essere in grado di gestire tempi di attesa più lunghi sia dal
    lato del server che da quello del client, compresa la gestione dell'esperienza
    dell'utente.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种延迟可能相当显著，你的AI服务必须在服务器和客户端两方面都能处理更长的等待时间，包括管理用户体验。
- en: 'Se il tuo caso d''uso beneficia di funzionalità in tempo reale, allora hai
    a disposizione alcuni modelli di progettazione architettonica che puoi implementare:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的用例受益于实时功能，那么你可以实施以下一些架构设计模型：
- en: Sondaggio regolare/breve
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期/短周期调查
- en: Sondaggio lungo
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长期调查
- en: SSE
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSE
- en: WS
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WS
- en: La scelta dipende dai tuoi requisiti di esperienza utente, scalabilità, latenza,
    costi di sviluppo e manutenibilità.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 选择取决于你的用户体验、可扩展性、延迟、开发成本和维护性的要求。
- en: Analizziamo ogni opzione in modo più dettagliato.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更详细地分析每个选项。
- en: Sondaggio regolare/breve
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定期/短周期调查
- en: Un metodo per beneficiare degli aggiornamenti in semi-tempo reale è quello di
    utilizzare il *polling regolare/breve*, come mostrato nella [Figura 6-2](#short_polling).
    In questo meccanismo di polling, il client invia periodicamente richieste HTTP
    al server per verificare la presenza di aggiornamenti a intervalli preconfigurati.
    Più brevi sono gli intervalli, più ci si avvicina agli aggiornamenti in tempo
    reale ma anche più alto sarà il traffico da gestire.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一种利用半实时更新的方法是使用*定期/短周期轮询*，如[图6-2](#short_polling)所示。在这种轮询机制中，客户端定期向服务器发送HTTP请求，以检查预配置间隔内的更新。间隔越短，越接近实时更新，但需要处理的数据流量也会更高。
- en: '![bgai 0602](assets/bgai_0602.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0602](assets/bgai_0602.png)'
- en: Figura 6-2\. Polling regolare/breve
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-2\. 定期/短周期轮询
- en: Puoi utilizzare questa tecnica se stai costruendo un servizio per generare dati
    come le immagini in batch. Il client invia semplicemente una richiesta per avviare
    il lavoro in batch e gli viene assegnato un identificativo univoco per il lavoro/la
    richiesta. Poi controlla periodicamente il server per confermare lo stato e i
    risultati del lavoro richiesto. Il server risponde con nuovi dati o fornisce una
    risposta vuota (e forse un aggiornamento dello stato) se i risultati devono ancora
    essere calcolati.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建一个用于批量生成数据（如批量图像）的服务，你可以使用这种技术。客户端只需发送一个请求来启动批量工作，并为工作/请求分配一个唯一的标识符。然后定期检查服务器以确认所需工作的状态和结果。如果结果还需要计算，服务器会以新数据或空响应（可能还有状态更新）进行回复。
- en: Come puoi immaginare con un polling breve, ti ritroverai con un numero eccessivo
    di richieste in entrata a cui il server deve rispondere, anche quando non ci sono
    nuove informazioni. Se hai più utenti contemporanei, questo approccio può rapidamente
    sovraccaricare il server, limitando la scalabilità della tua applicazione. Tuttavia,
    puoi ridurre il carico del server utilizzando le risposte nella cache (cioè eseguendo
    controlli di stato sul backend con una frequenza tollerabile) e implementando
    il rate limiting, che imparerai a conoscere meglio nei Capitoli [9](ch09.html#ch09)
    e [10](ch10.html#ch10).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以想象到的，使用短轮询，你可能会遇到过多的入站请求，服务器必须响应，即使没有新的信息。如果你有多个同时在线的用户，这种方法可能会迅速使服务器过载，限制你应用程序的可扩展性。然而，你可以通过使用缓存中的响应（即以可容忍的频率在后端执行状态检查）和实现速率限制来减少服务器的负载，你将在第[9](ch09.html#ch09)章和第[10](ch10.html#ch10)章中更好地了解这些内容。
- en: Un potenziale caso d'uso del polling breve nei servizi di intelligenza artificiale
    è quando hai dei lavori batch o di inferenza in corso. Puoi esporre degli endpoint
    che permettano ai tuoi clienti di utilizzare il polling breve per tenersi aggiornati
    sullo stato di questi lavori e recuperare i risultati quando sono stati completati.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在人工智能服务中，短轮询的一个潜在用例是当你有正在进行的批量或推理工作。你可以公开一些端点，允许你的客户使用短轮询来更新这些工作的状态，并在它们完成时检索结果。
- en: Un'alternativa è quella di sfruttare i sondaggi lunghi.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是利用长轮询。
- en: Sondaggio lungo
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长轮询
- en: Se vuoi ridurre il carico sul server continuando a sfruttare un meccanismo di
    polling in tempo reale, puoi implementare il *polling lungo* (vedi [Figura 6-3](#long_polling)),
    una versione migliorata del polling regolare/breve.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在继续利用实时轮询机制的同时减少服务器负载，你可以实现*长轮询*（见[图6-3](#long_polling)），这是常规/短轮询的一个改进版本。
- en: '![bgai 0603](assets/bgai_0603.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0603](assets/bgai_0603.png)'
- en: Figura 6-3\. Polling lungo
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-3\. 长轮询
- en: Con il polling lungo, sia il server che il client sono configurati per evitare
    i*timeout* (se possibile) che si verificano quando il client o il server rinunciano
    alla richiesta prolungata.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在长轮询中，服务器和客户端都被配置为避免（如果可能的话）当客户端或服务器放弃长时间请求时发生的超时。
- en: Suggerimento
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 建议
- en: I timeout vengono osservati più spesso in un tipico ciclo di richiesta-risposta
    HTTP quando una richiesta richiede un tempo prolungato per essere risolta o quando
    ci sono problemi di rete.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的HTTP请求-响应循环中，超时情况更常发生在请求需要较长时间才能解决或存在网络问题时。
- en: Per implementare il polling lungo, il server mantiene aperte le richieste in
    arrivo (cioè sospese) fino a quando non ci sono dati disponibili da inviare. Ad
    esempio, questo può essere utile quando si dispone di un LLM con tempi di elaborazione
    imprevedibili. Il client viene istruito ad aspettare per un periodo di tempo prolungato
    ed evita di interrompere e ripetere le richiesteprematuramente.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现长轮询，服务器会保持入站请求（即挂起）直到有数据可以发送。例如，这可能在拥有具有不可预测处理时间的LLM时很有用。客户端被指导等待较长时间，以避免过早地中断和重复请求。
- en: Puoi utilizzare il polling lungo se hai bisogno di un design semplice dell'API
    e di un'architettura dell'applicazione per l'elaborazione di lavori prolungati,
    come ad esempio le inferenze multiple dell'intelligenza artificiale. Questa tecnica
    ti permette di evitare l'implementazione di un gestore di lavori batch per tenere
    traccia dei lavori per la generazione di dati in blocco. Invece, le richieste
    del client rimangono aperte fino a quando non vengono elaborate, evitando il ciclo
    costante di richiesta-risposta con polling breve che può sovraccaricare il server.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个简单的API设计和适用于长时间处理工作的应用程序架构，例如人工智能的多次推理，你可以使用长时间轮询。这项技术允许你避免实现一个批处理工作管理器来跟踪批量生成数据的工作。相反，客户端的请求会保持打开状态，直到它们被处理，从而避免了频繁的请求-响应循环，这可能会给服务器带来过载。
- en: Sebbene il polling lungo sembri simile al tipico modello di richiesta-risposta
    HTTP, si differenzia per il modo in cui il client gestisce le richieste. Nel polling
    lungo, il client riceve tipicamente un singolo messaggio per ogni richiesta. Una
    volta che il server invia una risposta, la connessione viene chiusa. Il client
    apre quindi immediatamente una nuova connessione per attendere il messaggio successivo.
    Questo processo si ripete, consentendo al client di ricevere più messaggi nel
    tempo, ma ogni ciclo di richiesta-risposta HTTP gestisce un solo messaggio.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然长时间轮询看起来与典型的HTTP请求-响应模型相似，但它在客户端处理请求的方式上有所不同。在长时间轮询中，客户端通常为每个请求接收一条单独的消息。一旦服务器发送了响应，连接就会被关闭。然后客户端立即打开一个新的连接以等待下一条消息。这个过程会重复进行，使得客户端能够在一段时间内接收更多的消息，但每个HTTP请求-响应周期只处理一条消息。
- en: Poiché il polling lungo mantiene una connessione aperta fino a quando non è
    disponibile un messaggio, riduce la frequenza delle richieste rispetto al polling
    breve e implementa un meccanismo di comunicazione quasi in tempo reale. Tuttavia,
    il server deve comunque mantenere le richieste non soddisfatte, che consumano
    le risorse del server. Inoltre, se ci sono più richieste aperte da parte dello
    stesso client, l'ordinamento dei messaggi può essere difficile da gestire, portando
    potenzialmente a messaggi fuori ordine.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于长时间轮询在消息可用之前保持连接打开，因此它比短时间轮询减少了请求频率，并实现了一种近乎实时的通信机制。然而，服务器仍然需要保持未满足的请求，这会消耗服务器的资源。此外，如果同一客户端有多个打开的请求，消息排序可能会变得难以管理，可能导致消息顺序混乱。
- en: Se non hai un requisito specifico per l'utilizzo dei meccanismi di polling,
    un'alternativa più moderna ai meccanismi di polling per la comunicazione in tempo
    reale è SSE tramite l'interfaccia Event Source.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有对轮询机制的具体使用要求，实时通信的更现代替代方案是通过Event Source接口的SSE（Server-Sent Events）。
- en: Eventi inviati dal server
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器发送的事件
- en: Gli*eventi inviati dal server* (SSE) sono un meccanismo basato su HTTP per stabilire
    una connessione persistente e unidirezionale tra il server e il client. Mentre
    la connessione è aperta, il server può inviare continuamente aggiornamenti al
    client quando i dati diventanodisponibili.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由服务器发送的*事件*（SSE）是一种基于HTTP的机制，用于在服务器和客户端之间建立持久和单向的连接。当连接打开时，服务器可以在数据变得可用时持续地向客户端发送更新。
- en: Una volta che il client stabilisce la connessione persistente SSE con il server,
    non avrà più bisogno di ristabilirla, a differenza del lungo meccanismo di polling
    in cui il client invia ripetutamente richieste al server per mantenere una connessione
    aperta.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端与服务器建立了持久的SSE连接，它就不再需要重新建立连接，这与长时间轮询机制不同，在长时间轮询中，客户端需要反复向服务器发送请求以保持连接打开。
- en: Se stai servendo modelli GenAI, SSE è un meccanismo di comunicazione in tempo
    reale più adatto rispetto al long polling. SSE è stato progettato specificamente
    per gestire gli eventi in tempo reale ed è più efficiente del polling lungo. A
    causa dell'apertura e della chiusura ripetuta delle connessioni, il polling lungo
    richiede molte risorse e comporta un aumento della latenza e dell'overhead. SSE,
    invece, supporta la riconnessione automatica e gli ID evento per riprendere i
    flussi interrotti, cosa che il polling lungo non ha.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在服务生成人工智能的模型，SSE比长时间轮询更适合作为实时通信机制。SSE被专门设计来处理实时事件，并且比长时间轮询更高效。由于长时间轮询需要频繁地打开和关闭连接，它需要更多的资源，并可能导致延迟和开销的增加。相反，SSE支持自动重连和事件ID，以便恢复中断的流，这是长时间轮询所不具备的。
- en: 'In SSE, il client effettua una richiesta HTTP standard `GET` con un''intestazione
    `Accept:text/event-stream` e il server risponde con un codice di stato `200` e
    un''intestazione `Content-Type: text/event-stream`. Dopo questo scambio, il server
    può inviare eventi al client sulla stessa connessione.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '在SSE中，客户端通过发送一个带有`Accept:text/event-stream`头的标准HTTP `GET`请求来发起操作，服务器则以状态码`200`和`Content-Type:
    text/event-stream`头作为响应。在此交换之后，服务器可以通过相同的连接向客户端发送事件。'
- en: Anche se SSE dovrebbe essere la prima scelta per le applicazioni in tempo reale,
    puoi comunque optare per un meccanismo più semplice di polling lungo quando gli
    aggiornamenti sono poco frequenti o se il tuo ambiente non supporta le connessioni
    persistenti.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 即使SSE应该是实时应用的优先选择，但在更新不频繁或你的环境不支持持久连接的情况下，你也可以选择更简单的轮询机制。
- en: Un ultimo dettaglio importante da notare è che le connessioni SSE sono *unidirezionali*,
    cioè invii una normale richiesta HTTP al server e ricevi la risposta tramite SSE.
    Pertanto, sono adatte solo ad applicazioni che non hanno bisogno di inviare dati
    al server. Potresti aver visto SSE in azione all'interno di feed di notizie, notifiche
    e dashboard in tempo reale come i grafici dei dati azionari.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要细节是，SSE（Server-Sent Events）的连接是**单向的**，也就是说，你向服务器发送一个正常的HTTP请求，并通过SSE接收响应。因此，它们只适用于不需要向服务器发送数据的那些应用。你可能已经在新闻推送、实时通知和实时仪表板（如股票数据图表）中看到过SSE的应用。
- en: Non sorprende che l'SSE sia particolarmente indicato nelle applicazioni di chat,
    quando è necessario trasmettere le risposte dell'LLM durante una conversazione.
    In questo caso, il client può stabilire una connessione persistente separata fino
    a quando il server non trasmette completamente la risposta dell'LLM all'utente.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要将LLM的响应在对话中实时传输的应用中，SSE特别适合。在这种情况下，客户端可以建立一个独立的持久连接，直到服务器完全将LLM的响应传输给用户。
- en: Nota
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: ChatGPT sfrutta SSE sotto il cofano per consentire risposte in tempo reale alle
    query degli utenti.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT在内部使用SSE来允许对用户查询的实时响应。
- en: '[La Figura 6-4](#server_sent_events) mostra il funzionamento del meccanismo
    di comunicazione SSE.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-4](#server_sent_events)展示了SSE通信机制的工作原理。'
- en: '![bgai 0604](assets/bgai_0604.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0604](assets/bgai_0604.png)'
- en: Figura 6-4\. SSE
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-4\. SSE
- en: 'Per approfondire la tua comprensione, in questo capitolo realizzeremo due mini-progetti
    con SSE: uno per lo streaming di dati da un generatore di dati simulato e l''altro
    per lo streaming di risposte LLM.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加深你的理解，在本章中我们将通过两个使用SSE的小型项目来实现：一个用于从模拟数据生成器中流式传输数据，另一个用于流式传输LLM（大型语言模型）的响应。
- en: Scoprirai maggiori dettagli sul meccanismo SSE durante i progetti sopra citati.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在上述项目中了解更多关于SSE机制的具体细节。
- en: In sintesi, SSE è eccellente per stabilire connessioni persistenti unidirezionali,
    ma cosa succede se hai bisogno di inviare e ricevere messaggi durante una connessione
    persistente? In questo caso WebSocket può essere utile.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，SSE非常适合建立单向的持久连接，但如果在持久连接期间需要发送和接收消息，那么WebSocket可能是有用的。
- en: WebSocket
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket
- en: L'ultimo meccanismo di comunicazione in tempo reale da trattare è WebSocket.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要讨论的实时通信机制是WebSocket。
- en: WebSocket è un eccellente meccanismo di comunicazione in tempo reale per stabilire
    *connessioni bidirezionali* persistenti tra il client e il server per le chat
    in tempo reale, nonché per le applicazioni vocali e video con un modello di intelligenza
    artificiale. Una connessione bidirezionale significa che entrambe le parti possono
    inviare e ricevere dati in tempo reale in qualsiasi ordine, purché sia aperta
    una connessione persistente tra il client e il server. È stato progettato per
    funzionare su porte HTTP standard per garantire la compatibilità con le misure
    di sicurezza esistenti. Le applicazioni web che richiedono una comunicazione bidirezionale
    con i server traggono il massimo vantaggio da questo meccanismo in quanto possono
    evitare l'overhead e la complessità delpolling HTTP.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket是一个优秀的实时通信机制，用于在客户端和服务器之间建立持久的**双向连接**，适用于实时聊天、带有人工智能模型的声音和视频应用。双向连接意味着双方可以实时地、无序地发送和接收数据，只要客户端和服务器之间保持一个持久的连接。它被设计为在标准HTTP端口上工作，以确保与现有安全措施的兼容性。需要与服务器进行双向通信的Web应用可以从这种机制中获得最大好处，因为它们可以避免HTTP轮询的开销和复杂性。
- en: Puoi utilizzare WebSocket in una varietà di applicazioni, tra cui feed sociali,
    giochi multiplayer, feed finanziari, aggiornamenti basati sulla posizione, chat
    multimediali, ecc.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在各种应用程序中使用WebSocket，包括社交动态、多人游戏、金融动态、基于位置的更新、多媒体聊天等。
- en: A differenza di tutti gli altri meccanismi di comunicazione discussi finora,
    il protocollo WebSocket non trasferisce i dati su HTTP dopo l'handshake iniziale,
    ma implementa un meccanismo di messaggistica bidirezionale (full-duplex) su una
    singola connessione TCP. Di conseguenza, WebSocket è più veloce nella trasmissione
    dei dati rispetto a HTTP perché ha meno overhead di protocollo e opera a un livello
    inferiore nello stack di protocolli di rete. Questo perché HTTP si trova in cima
    a TCP, quindi il ritorno a TCP sarà più veloce.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与迄今为止讨论的所有其他通信机制不同，WebSocket协议在初始握手之后不在HTTP上传输数据，而是在单个TCP连接上实现双向消息机制（全双工）。因此，WebSocket在数据传输速度上比HTTP更快，因为它具有更少的协议开销，并在网络协议栈的较低级别运行。这是因为HTTP位于TCP之上，因此返回到TCP的速度会更快。
- en: Suggerimento
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 建议
- en: WebSocket mantiene un socket aperto sia sul client che sul server per tutta
    la durata della connessione. Si noti che questo rende anche i server statici,
    il che rende più complicato il ridimensionamento.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket在客户端和服务器上保持一个打开的套接字，直到连接的整个持续时间。请注意，这也使得服务器变得静态，这使得扩展更加复杂。
- en: A questo punto ti starai chiedendo come funziona il protocollo WebSocket.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道WebSocket协议是如何工作的。
- en: Secondo l'RFC 6455, per stabilire una connessione WebSocket, il client invia
    una richiesta HTTP di "aggiornamento" al server, chiedendo di aprire una connessione
    WebSocket.Questo viene definito l'*handshake di apertura*, che dà inizio al ciclo
    di vita della connessione WebSocket nello stato*CONNECTING*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RFC 6455，为了建立WebSocket连接，客户端向服务器发送一个“更新”HTTP请求，请求打开一个WebSocket连接。这被称为*打开握手*，它标志着WebSocket连接生命周期的*CONNECTING*状态的开始。
- en: Avvertenze
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意事项
- en: I tuoi servizi di AI devono essere in grado di gestire più handshake simultanei
    e di autenticarli prima di aprire una connessione. Le nuove connessioni possono
    consumare le risorse del server, quindi devono essere gestite correttamente dal
    tuo server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你的AI服务必须能够处理多个同时握手并验证它们，然后再打开连接。新连接可能会消耗服务器资源，因此必须由你的服务器正确管理。
- en: La richiesta di aggiornamento HTTP deve contenere una serie di intestazioni
    necessarie, come mostrato nell'[Esempio 6-1](#websocket_handshake).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP更新请求必须包含一系列必要的头信息，如[Esempio 6-1](#websocket_handshake)所示。
- en: Esempio 6-1\. Apertura di WebSocket tramite HTTP
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Esempio 6-1\. 通过HTTP打开WebSocket
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO1-1)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)(#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO1-1)'
- en: Effettua una richiesta di aggiornamento HTTP all'endpoint WebSocket. Gli endpoint
    WebSocket iniziano con `ws://` invece del tipico `http://`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 向WebSocket端点发送HTTP更新请求。WebSocket端点以`ws://`开头，而不是典型的`http://`。
- en: '[![2](assets/2.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO1-2)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)(#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO1-2)'
- en: Richiesta di aggiornamento e apertura di una connessione WebSocket.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 更新请求和WebSocket连接的打开。
- en: '[![3](assets/3.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO1-4)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)(#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO1-4)'
- en: Utilizza una stringa casuale di 16 byte codificata in Base64 per assicurarti
    che il server supporti il protocollo WebSocket.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个16字节的随机字符串，并使用Base64进行编码，以确保服务器支持WebSocket协议。
- en: '[![4](assets/4.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO1-5)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)(#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO1-5)'
- en: Usa il sottoprotocollo `html-chat` o `text-chat` se `html-chat` non è disponibile.
    I sottoprotocolli regolano i dati da scambiare.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`html-chat`不可用，则使用子协议`html-chat`或`text-chat`。子协议控制交换的数据。
- en: Avvertenze
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意事项
- en: In produzione, utilizza sempre endpoint WebSocket `wss://` sicuri.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，始终使用安全的WebSocket端点`wss://`。
- en: Il protocollo `wss://`, simile a `https://`, non solo è criptato ma anche più
    affidabile. Questo perché i dati di `ws://` non sono criptati e sono visibili
    a qualsiasi intermediario. I vecchi server proxy non conoscono WebSocket e potrebbero
    vedere intestazioni "strane" e interrompere la connessione.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`wss://`协议，类似于`https://`，不仅加密，而且更可靠。这是因为`ws://`的数据未加密，任何中间代理都可以看到。旧的代理服务器不了解WebSocket，可能会看到“奇怪”的头部并中断连接。'
- en: D'altra parte, `wss://` è la versione sicura di WebSocket, che funziona su Transport
    Layer Security (TLS), che cripta i dati al mittente e li decripta al destinatario.
    Quindi i pacchetti di dati passano criptati attraverso i proxy, che non possono
    vedere cosa contengono e lasciarli passare.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`wss://`是WebSocket的安全版本，它基于传输层安全（TLS）工作，加密发送方的数据并在接收方解密。因此，数据包以加密形式通过代理服务器传输，代理服务器无法看到数据内容并允许其通过。
- en: Una volta stabilita la connessione WebSocket, i messaggi testuali o binari possono
    essere trasmessi in entrambe le direzioni sotto forma di *frame di messaggi*.
    Il ciclo di vita della connessione è ora nello stato *OPEN*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立WebSocket连接，文本或二进制消息可以以*消息帧*的形式在两个方向上传输。现在，连接的生命周期处于*打开*状态。
- en: Puoi vedere il meccanismo di comunicazione WebSocket nella [Figura 6-5](#websockets).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图6-5](#websockets)中看到WebSocket通信机制。
- en: '![bgai 0605](assets/bgai_0605.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0605](assets/bgai_0605.png)'
- en: Figura 6-5\. Comunicazione WS
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-5\. WS通信
- en: 'I*message frame* sono un modo per impacchettare e trasmettere i dati tra il
    client e il server. Non sono un''esclusiva di WebSocket, poiché si applicano a
    tutte le connessioni tramite il protocollo TCP che costituisce la base di HTTP.
    Tuttavia, un message frame di WebSocket è costituito da diversi componenti:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*消息帧*是客户端和服务器之间打包和传输数据的一种方式。它不是WebSocket的专属，因为它适用于所有通过TCP协议（HTTP的基础）建立的连接。然而，WebSocket的消息帧由多个组件组成：'
- en: Intestazione fissa
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 固定头部
- en: Descrive le informazioni di base del messaggio
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 描述消息的基本信息
- en: Lunghezza del carico utile estesa (opzionale)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展负载长度（可选）
- en: Fornisce la lunghezza effettiva del payload quando la lunghezza supera i 125
    byte.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当负载长度超过125字节时，提供实际负载长度。
- en: Chiave di mascheramento
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏键
- en: Maschera i dati del payload nei frame inviati dal client al server, prevenendo
    alcuni tipi di vulnerabilità di sicurezza, in particolare l'*avvelenamento della
    cache*^([1](ch06.html#id893)) e gli attacchi *cross-protocollo*^([2](ch06.html#id894))
    attacchi
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端发送到服务器的帧中隐藏负载数据，防止某些类型的安全漏洞，特别是*缓存中毒*^([1](ch06.html#id893))和*跨协议*^([2](ch06.html#id894))攻击。
- en: Carico utile
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 负载数据
- en: Contiene il contenuto effettivo del messaggio
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 包含消息的实际内容
- en: 'A differenza delle intestazioni verbose delle richieste HTTP, i frame WebSocket
    hanno intestazioni minime che includono quanto segue:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTTP请求的冗长头部不同，WebSocket帧具有最小头部，包括以下内容：
- en: Cornici di testo
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 文本框架
- en: Utilizzato per i dati di testo codificati UTF-8
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 用于UTF-8编码的文本数据
- en: Cornici binarie
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制框架
- en: Utilizzato per i dati binari
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 用于二进制数据
- en: Frammentazione
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 分帧
- en: Utilizzato per frammentare i messaggi in più frame, che vengono riassemblati
    dal destinatario.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 用于将消息分帧为多个帧，这些帧由接收方重新组装。
- en: Il bello del protocollo WebSocket è anche la sua capacità di mantenere una connessione
    persistente attraverso i *frame di controllo*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket协议的优点之一是其通过*控制帧*保持持久连接的能力。
- en: 'I*frame di controllo* sono frame speciali utilizzati per gestire la connessione:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制帧*是用于管理连接的特殊帧：'
- en: Telai per ping/pong
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ping/pong框架
- en: Utilizzato per controllare lo stato della connessione
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 用于控制连接状态
- en: Chiudi la cornice
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭框架
- en: Utilizzato per terminare la connessione con grazia
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 用于优雅地终止连接
- en: Quando è il momento di chiudere la connessione WebSocket, il client o il server
    inviano un frame di chiusura. Il frame di chiusura può specificare facoltativamente
    un codice di stato e/o un motivo per la chiusura della connessione. A questo punto,
    la connessione WebSocket entra nello stato di *CHIUSURA*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要关闭WebSocket连接时，客户端或服务器发送一个关闭帧。关闭帧可以可选地指定状态码和/或关闭连接的原因。此时，WebSocket连接进入*关闭*状态。
- en: Lo stato *CLOSING* termina quando l'altra parte risponde con un altro frame
    di chiusura, concludendo così l'intero ciclo di vita della connessione WebSocket
    nello stato *CLOSED*, come mostrato nella[Figura 6-6](#websocket_connection_lifecycle).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当另一端响应另一个关闭帧时，*CLOSING*状态结束，从而在[图6-6](#websocket_connection_lifecycle)中展示了WebSocket连接的生命周期结束于*CLOSED*状态。
- en: '![bgai 0606](assets/bgai_0606.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0606](assets/bgai_0606.png)'
- en: Figura 6-6\. Ciclo di vita della connessione WebSocket
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-6\. WebSocket连接的生命周期
- en: Come puoi vedere, l'utilizzo del meccanismo di comunicazione WebSocket può essere
    un po' eccessivo per le applicazioni semplici che non richiedono l'overhead. Per
    la maggior parte delle applicazioni GenAI, le connessioni SSE possono essere sufficienti.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，对于不需要额外开销的简单应用，使用WebSocket通信机制可能有些过度。对于大多数GenAI应用来说，SSE连接可能已经足够。
- en: Tuttavia, ci sono casi d'uso GenAI in cui WebSocket può brillare, come le applicazioni
    di chat multimediale e voice-to-voice, le applicazioni GenAI collaborative e i
    servizi di trascrizione in tempo reale basati sulla comunicazione bidirezionale.
    Per fare un po' di esperienza pratica, più avanti in questo capitolo realizzerai
    un'applicazione speech-to-text.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些GenAI用例中，WebSocket可以大放异彩，例如多媒体聊天和语音对语音的应用、GenAI协作应用以及基于双向通信的实时转录服务。为了获得一些实践经验，在本章的后面部分，你将实现一个语音到文本的应用程序。
- en: Ora che hai imparato a conoscere diversi meccanismi di comunicazione web unici
    per le applicazioni in tempo reale, riassumiamo rapidamente il loro confronto.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了针对实时应用的不同Web通信机制，让我们快速总结一下它们的对比。
- en: Meccanismi di comunicazione a confronto
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通信机制对比
- en: La[Figura 6-7](#communication_mechanims_figure)illustra i cinque meccanismi
    di comunicazione utilizzati nello sviluppo web.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-7](#communication_mechanims_figure)展示了在Web开发中使用的五种通信机制。'
- en: '![bgai 0607](assets/bgai_0607.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0607](assets/bgai_0607.png)'
- en: Figura 6-7\. Confronto tra i meccanismi di comunicazione web
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-7\. Web通信机制的对比
- en: Come puoi vedere dalla [Figura 6-7](#communication_mechanims_figure), i modelli
    di messaggistica differiscono in ogni approccio.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图6-7](#communication_mechanims_figure)所示，不同的方法中消息模型各不相同。
- en: La*richiesta-risposta HTTP* è il modello più comune supportato da tutti i client
    e i server web, adatto alle API RESTful e ai servizi che non richiedono aggiornamenti
    in tempo reale.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*HTTP请求-响应*是所有客户端和服务器Web应用中最常见的模型，适用于RESTful API和不需要实时更新的服务。'
- en: Il*polling breve/regolare* prevede che i client verifichino la presenza di dati
    a intervalli prestabiliti, il che è semplice ma può essere dispendioso in termini
    di risorse quando si scalano i servizi. Di solito viene utilizzato nelle applicazioni
    per eseguire aggiornamenti poco frequenti, come ad esempio nei cruscotti analitici.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*短轮询/常规轮询*要求客户端在预定的时间间隔内检查数据的存在，这很简单，但在服务扩展时可能会在资源消耗上变得昂贵。通常用于需要不频繁更新的应用程序，例如分析仪表板。'
- en: Il*polling lungo* è più efficiente per gli aggiornamenti in tempo reale, in
    quanto mantiene aperte le connessioni fino a quando i dati non sono disponibili
    sul server. Tuttavia, può comunque esaurire le risorse del server, il che lo rende
    ideale per le funzioni quasi in tempo reale come le notifiche.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*长轮询*对于实时更新来说更有效率，因为它保持连接开启，直到服务器上有可用数据。然而，它仍然可能耗尽服务器的资源，这使得它对于需要近似实时功能的操作（如通知）来说很理想。'
- en: '*SSE* mantiene una singola connessione persistente solo da server a client,
    utilizzando il protocollo HTTP. È semplice da configurare, sfrutta l''API `EventSource`
    del browser e viene fornito con funzioni integrate come la riconnessione. Questi
    fattori rendono SSE adatto alle applicazioni che richiedono feed live, funzioni
    di chat e dashboard in tempo reale.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务器发送事件（SSE）*仅通过HTTP协议在服务器和客户端之间保持一个持久的单一连接。它易于配置，利用浏览器的`EventSource` API，并提供了如自动重连等集成功能。这些因素使得SSE适用于需要实时流、聊天和实时仪表板功能的应用程序。'
- en: '*WebSocket* offre una comunicazione full-duplex (a doppia faccia) con bassa
    latenza e supporto per i dati binari, ma è complesso da implementare. È ampiamente
    utilizzato nelle applicazioni che richiedono un''elevata interattività e lo scambio
    di dati in tempo reale, come i giochi multiplayer, le applicazioni di chat, gli
    strumenti collaborativi e i servizi di trascrizione in tempo reale.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*WebSocket*提供全双工（双向）通信，低延迟，支持二进制数据，但实现复杂。它广泛应用于需要高交互性和实时数据交换的应用，如多玩家游戏、聊天应用、协作工具和实时转录服务。'
- en: Con l'invenzione di SSE e WebSocket e la loro crescente popolarità, il polling
    breve/regolare e il polling lungo stanno diventando meccanismi in tempo reale
    meno comuni nelle applicazioni web.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 随着SSE和WebSocket的发明及其日益普及，短轮询/常规轮询和长轮询正在成为Web应用中越来越不常见的实时机制。
- en: La[Tabella 6-1](#communication_mechanisms_table) mette a confronto le caratteristiche,
    le sfide e le applicazioni di ciascun meccanismo.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-1\[通信机制表\]比较了每个机制的特点、挑战和应用。
- en: Tabella 6-1\. Confronto tra i meccanismi di comunicazione web
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-1\. Web通信机制对比
- en: '| Meccanismo di comunicazione | Caratteristiche | Sfide | Applicazioni |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 通信机制 | 特点 | 挑战 | 应用 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Richiesta-risposta HTTP | Modello semplice di richiesta e risposta, protocollo
    stateless, supportato da tutti i client e i server web. | Alta latenza per gli
    aggiornamenti in tempo reale, inefficiente per il trasferimento frequente di dati
    da server a client | API RESTful, servizi web in cui gli aggiornamenti in tempo
    reale non sono critici |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 请求-响应HTTP | 简单的请求和响应模型，无状态协议，所有客户端和服务器都支持。 | 实时更新延迟高，频繁数据传输从服务器到客户端效率低 |
    RESTful API，实时更新不是关键的服务Web |'
- en: '| Sondaggi brevi/regolari | Il cliente richiede regolarmente i dati a intervalli,
    facile da implementare | Spreco di risorse quando non ci sono nuovi dati, la latenza
    dipende dagli intervalli di sondaggio | Applicazioni con aggiornamenti poco frequenti,
    semplici dashboard quasi in tempo reale, aggiornamenti sullo stato dei lavori
    inviati |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 短轮询/常规轮询 | 客户定期请求数据，易于实现 | 没有新数据时资源浪费，延迟取决于轮询间隔 | 更新频率较低的应用，几乎实时的简单仪表板，提交工作的状态更新
    |'
- en: '| Sondaggio lungo | Più efficiente del polling breve per gli aggiornamenti
    in tempo reale, mantiene la connessione aperta fino a quando i dati sono disponibili
    | Può richiedere molte risorse al server, è complesso gestire più connessioni.
    | Notifiche in tempo reale, vecchie applicazioni di chat |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 长轮询 | 对于实时更新比短轮询更高效，保持连接打开直到数据可用 | 可能需要服务器大量资源，管理多个连接复杂 | 实时通知，旧版聊天应用 |'
- en: '| Eventi inviati dal server | Singola connessione persistente per gli aggiornamenti,
    riconnessione integrata e supporto dell''ID evento | Comunicazione unidirezionale
    solo dal server al client | Feed in diretta, applicazione di chat, dashboard di
    analisi in tempo reale |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 服务器发送的事件 | 单个持久连接用于更新，集成重连和事件ID支持 | 仅从服务器到客户端的单向通信 | 直播源，聊天应用，实时分析仪表板 |'
- en: '| WebSocket | Comunicazione full-duplex, bassa latenza, supporto dei dati binari
    | Più complesso da implementare e gestire, richiede il supporto di WebSocket sul
    server. | Giochi multiplayer, applicazioni di chat, strumenti di editing collaborativo,
    applicazioni per videoconferenze e webinar, applicazioni per la trascrizione e
    la traduzione in tempo reale. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| WebSocket | 全双工通信，低延迟，支持二进制数据 | 实现和管理更复杂，需要服务器支持WebSocket | 多玩家游戏，聊天应用，协作编辑工具，视频会议和网络研讨会应用，实时转录和翻译应用
    |'
- en: Dopo aver esaminato in dettaglio i meccanismi di comunicazione in tempo reale,
    approfondiamo l'argomento SSE e WebSocket implementando i nostri endpoint di streaming
    utilizzando questi due meccanismi.Nella prossima sezione scoprirai come implementare
    gli endpoint di streaming con entrambe le tecnologie.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细研究了实时通信机制之后，我们将深入探讨SSE和WebSocket，通过使用这两种机制实现我们的流端点。在下一节中，你将了解如何使用这两种技术实现流端点。
- en: Implementare gli endpoint SSE
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现SSE端点
- en: Nel [Capitolo 3](ch03.html#ch03) hai imparato a conoscere gli LLMs, che sono
    modelli *autoregressivi* che prevedono il token successivo in base agli input
    precedenti. Dopo ogni fase di generazione, il token di uscita viene aggiunto agli
    input e passato nuovamente attraverso il modello fino a quando non viene generato
    un token `<stop>` per interrompere il ciclo. Invece di aspettare che il ciclo
    finisca, puoi inoltrare all'utente i token di uscita mentre vengono generati come
    flusso di dati.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html#ch03)中，你学习了关于LLMs的知识，它们是*自回归*模型，根据先前输入预测下一个令牌。在每个生成阶段之后，输出令牌被添加到输入中，并再次通过模型传递，直到生成一个`<stop>`令牌来中断循环。而不是等待循环结束，你可以将生成的令牌作为数据流发送给用户。
- en: I provider di modelli normalmente espongono un'opzione che ti permette di impostare
    la modalità di uscita come flusso di dati utilizzando `stream=True`. Con questa
    opzione, il provider di modelli può restituirti un generatore di dati invece dell'output
    finale, che puoi passare direttamente al tuo server FastAPI per lo streaming.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 模型提供商通常提供一个选项，允许你设置输出模式为数据流，使用`stream=True`。使用此选项，模型提供商可以返回一个数据生成器而不是最终输出，你可以直接将其传递到你的FastAPI服务器进行流式传输。
- en: Per dimostrarlo in azione, fai riferimento all'[Esempio 6-2](#async_azure_openai_client),
    che implementa un generatore di dati asincrono utilizzando la libreria `openai`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示其功能，请参考[Esempio 6-2](#async_azure_openai_client)，它使用`openai`库实现了一个异步数据生成器。
- en: Suggerimento
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 建议
- en: Per eseguire l'[Esempio 6-2](#async_azure_openai_client), dovrai creare un'istanza
    di Azure OpenAI sul portale di Azure e creare un modello di distribuzione. Prendi
    nota dell'endpoint API, della chiave e del nome del modello di distribuzione.
    Per l'[Esempio 6-2](#async_azure_openai_client), puoi utilizzare la versione `2023-05-15`
    api.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行[Esempio 6-2](#async_azure_openai_client)，你需要在Azure门户上创建一个Azure OpenAI实例并创建一个分发模型。注意记录API端点、密钥和分发模型名称。对于[Esempio
    6-2](#async_azure_openai_client)，你可以使用`2023-05-15`版本的api。
- en: Esempio 6-2\. Implementazione del client di chat asincrono di Azure OpenAI per
    lo streaming delle risposte
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-2\. 实现Azure OpenAI异步聊天客户端以进行响应流式传输
- en: '[PRE1]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO2-1)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO2-1]'
- en: Crea un client asincrono `AzureOpenAIChatClient` per interagire con l'API OpenAI
    di Azure. Il client di chat richiede un endpoint API, un nome di distribuzione,
    una chiave e una versione per funzionare.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个异步客户端 `AzureOpenAIChatClient` 以与Azure OpenAI API交互。聊天客户端需要一个API端点、分发名称、密钥和版本才能运行。
- en: '[![2](assets/2.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO2-2)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO2-2]'
- en: Definisce un metodo generatore asincrono `chat_stream` che produce ogni token
    di uscita dall'API.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个异步生成器方法 `chat_stream`，它从API生成每个输出令牌。
- en: '[![3](assets/3.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO2-3)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO2-3]'
- en: Imposta `stream=True` per ricevere un flusso di output dall'API invece della
    risposta completa in una volta sola.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`stream=True`以从API接收输出流而不是一次性接收完整响应。
- en: '[![4](assets/4.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO2-4)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO2-4]'
- en: Esegue un loop sullo stream e restituisce ogni token di output o restituisce
    una stringa vuota se `delta.content` è vuoto. La sottostringa `data:` deve essere
    anteposta a ogni token in modo che i browser possano analizzare correttamente
    il contenuto utilizzando l'API `EventSource`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在流上执行循环，并返回每个输出令牌或如果`delta.content`为空，则返回一个空字符串。每个令牌前必须加上前缀`data:`，以便浏览器可以使用`EventSource`
    API正确分析内容。
- en: '[![5](assets/5.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO2-5)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO2-5]'
- en: Rallenta la velocità di streaming per ridurre la contropressione sui clienti.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 减慢流式传输速度以减少对客户端的冲击。
- en: Nell'[Esempio 6-2](#async_azure_openai_client), crei un'istanza di`AsyncAzureOpenAI`,
    che ti permette di chattare con i modelli Azure OpenAI tramite un'API nel tuo
    ambiente Azure privato.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Esempio 6-2](#async_azure_openai_client)中，你创建了一个`AsyncAzureOpenAI`实例，这允许你通过Azure私有的API环境与Azure
    OpenAI模型进行聊天。
- en: Impostando il prefisso `stream=True`, `AsyncAzureOpenAI` restituisce un flusso
    di dati (una funzione generatrice asincrona) invece della risposta completa del
    modello. Puoi eseguire un loop sul flusso di dati e sui token `yield` con il prefisso
    `data:` per conformarti alle specifiche SSE. In questo modo i browser potranno
    analizzare automaticamente il contenuto del flusso utilizzando l'API web `EventSource`,
    ampiamente disponibile.^([3](ch06.html#id906))
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Impostando il prefisso `stream=True`, `AsyncAzureOpenAI` restituisce un flusso
    di dati (una funzione generatrice asincrona) invece della risposta completa del
    modello. Puoi eseguire un loop sul flusso di dati e sui token `yield` con il prefisso
    `data:` per conformarti alle specifiche SSE. In questo modo i browser potranno
    analizzare automaticamente il contenuto del flusso utilizzando l'API web `EventSource`,
    ampiamente disponibile.^([3](ch06.html#id906))
- en: Avvertenze
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Avvertenze
- en: Quando esponi endpoint di streaming, dovrai considerare la velocità con cui
    i client possono consumare i dati che gli stai inviando. Una buona pratica è quella
    di ridurre la velocità di streaming come hai visto nell'[Esempio 6-2](#async_azure_openai_client)
    per ridurre la pressione sui client. Puoi regolare il throttling testando i tuoi
    servizi con diversi client su vari dispositivi.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Quando esponi endpoint di streaming, dovrai considerare la velocità con cui
    i client possono consumare i dati che gli stai inviando. Una buona pratica è quella
    di ridurre la velocità di streaming come hai visto nell'[Esempio 6-2](#async_azure_openai_client)
    per ridurre la pressione sui client. Puoi regolare il throttling testando i tuoi
    servizi con diversi client su vari dispositivi.
- en: SSE con richiesta GET
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSE con richiesta GET
- en: Ora puoi implementare l'endpoint SSE passando il flusso di chat al sito `StreamingResponse`
    di FastAPI come endpoint `GET`, come mostrato nell'[Esempio 6-3](#sse_endpoint).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Ora puoi implementare l'endpoint SSE passando il flusso di chat al sito `StreamingResponse`
    di FastAPI come endpoint `GET`, come mostrato nell'[Esempio 6-3](#sse_endpoint).
- en: Esempio 6-3\. Implementazione di un endpoint SSE utilizzando la FastAPI `StreamingResponse`
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Esempio 6-3\. Implementazione di un endpoint SSE utilizzando la FastAPI `StreamingResponse`
- en: '[PRE2]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO3-1)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO3-1]'
- en: Implementa un endpoint SSE con il metodo `GET` da utilizzare con l'API `EventSource`
    sul browser.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Implementa un endpoint SSE con il metodo `GET` da utilizzare con l'API `EventSource`
    sul browser.
- en: '[![2](assets/2.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO3-2)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO3-2]'
- en: Passa il generatore di flussi di chat a `StreamingResponse` per inoltrare il
    flusso di output che viene generato al client. Imposta `media_type=text/event-stream`
    come da specifiche SSE in modo che i browser possano gestire correttamente la
    risposta.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Passa il generatore di flussi di chat a `StreamingResponse` per inoltrare il
    flusso di output che viene generato al client. Imposta `media_type=text/event-stream`
    come da specifiche SSE in modo che i browser possano gestire correttamente la
    risposta.
- en: Con l'endpoint `GET` configurato sul server, puoi creare un semplice modulo
    HTML sul client per consumare il flusso SSE tramite l'interfaccia `EventSource`,
    come mostrato nell'[Esempio 6-4](#sse_client).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Con l'endpoint `GET` configurato sul server, puoi creare un semplice modulo
    HTML sul client per consumare il flusso SSE tramite l'interfaccia `EventSource`,
    come mostrato nell'[Esempio 6-4](#sse_client).
- en: Suggerimento
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Suggerimento
- en: L['esempio 6-4](#sse_client) non utilizza alcuna libreria JavaScript o framework
    web, ma esistono librerie che ti aiuteranno a implementare la connessione`EventSource`
    in qualsiasi framework di tua scelta come React, Vue o SvelteKit.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: L['esempio 6-4](#sse_client) non utilizza alcuna libreria JavaScript o framework
    web, ma esistono librerie che ti aiuteranno a implementare la connessione`EventSource`
    in qualsiasi framework di tua scelta come React, Vue o SvelteKit.
- en: Esempio 6-4\. Implementazione di SSE sul client utilizzando l'API del browser
    `EventSource`
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Esempio 6-4\. Implementazione di SSE sul client utilizzando l'API del browser
    `EventSource`
- en: '[PRE3]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO4-1)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO4-1]'
- en: Crea un semplice input e un pulsante HTML per avviare le richieste SSE.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Crea un semplice input e un pulsante HTML per avviare le richieste SSE.
- en: '[![2](assets/2.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO4-2)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO4-2]'
- en: Crea un contenitore vuoto da utilizzare come lavandino per il contenuto dello
    stream.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Crea un contenitore vuoto da utilizzare come lavandino per il contenuto dello
    stream.
- en: '[![3](assets/3.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO4-3)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO4-3]'
- en: Ascolta il pulsante `clicks` ed esegue il callback SSE.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Ascolta il pulsante `clicks` ed esegui il callback SSE.
- en: '[![4](assets/4.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO4-4)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO4-4]'
- en: Ripristina il modulo del contenuto e il contenitore di risposta del contenuto
    precedente.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复之前的内容模块和响应容器。
- en: '[![5](assets/5.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO4-5)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png) (#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO4-5)'
- en: Crea un nuovo oggetto `EventSource` e ascolta i cambiamenti di stato della connessione
    per gestire gli eventi.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`EventSource`对象并监听连接状态的变化以处理事件。
- en: '[![6](assets/6.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO4-6)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png) (#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO4-6)'
- en: Registra nella console quando viene aperta una connessione SSE. Gestisce ogni
    messaggio renderizzando il contenuto del messaggio nel contenitore delle risposte
    fino a quando non viene ricevuto il messaggio `[DONE]`, che segnala che la connessione
    deve essere chiusa. Inoltre, chiude la connessione se si verificano errori e registra
    l'errore nellaconsole del browser.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当SSE连接打开时在控制台进行记录。它通过在响应容器中渲染消息内容来处理每个消息，直到接收到表示连接必须关闭的消息 `[DONE]`。此外，如果发生错误，它将关闭连接并在浏览器控制台中记录错误。
- en: Con il client SSE implementato nell'[Esempio 6-4](#sse_client), puoi ora utilizzarlo
    per testare il tuo endpoint SSE. Tuttavia, devi prima servire l'HTML.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在[Esempio 6-4](#sse_client)中实现的SSE客户端，你现在可以用来测试你的SSE端点。然而，你必须首先提供HTML。
- en: Crea una directory `pages` e inserisci il file HTML al suo interno. Poi *monta*
    la directory sul tuo server FastAPI per servire il suo contenuto come file statico,
    come mostrato nell'[Esempio 6-5](#mounting_static_files). Tramite il montaggio,
    FastAPI si occupa di mappare i percorsi API di ogni file in modo che tu possa
    accedervi con un browser dalla stessa origine del tuo server.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`pages`的目录并将HTML文件放入其中。然后*挂载*该目录到你的FastAPI服务器上，以便将其内容作为静态文件提供服务，如[Esempio
    6-5](#mounting_static_files)所示。通过挂载，FastAPI负责将每个文件的API路径映射，这样你就可以从与你的服务器相同的源通过浏览器访问它们。
- en: Esempio 6-5\. Montare i file HTML sul server come risorse statiche
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Esempio 6-5. 将HTML文件挂载到服务器作为静态资源
- en: '[PRE4]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO5-1)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png) (#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO5-1)'
- en: Monta la cartella `pages` su `/pages` per servire i suoi contenuti come risorse
    statiche. Una volta montata, puoi accedere a ogni file visitando`*<origin>*/pages/*<filename>*`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将`pages`目录挂载到`/pages`以将其内容作为静态资源提供服务。挂载后，你可以通过访问`*<origin>*/pages/*<filename>`来访问每个文件。
- en: Implementando l'[Esempio 6-5](#mounting_static_files), servirai l'HTML dalla
    stessa origine del tuo server API, evitando così di attivare il meccanismo di
    sicurezza CORS del browser, che può bloccare le richieste in uscita che raggiungono
    il tuo server.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现[Esempio 6-5](#mounting_static_files)，你将从与你的API服务器相同的源提供HTML，从而避免触发浏览器的CORS安全机制，这可能会阻止到达你的服务器的出站请求。
- en: Ora puoi accedere alla pagina HTML visitando il sito`http://localhost:8000/pages/sse-client.html`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过访问`http://localhost:8000/pages/sse-client.html`来访问HTML页面。
- en: Condivisione di risorse tra origini diverse
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不同源之间的资源共享
- en: Se provi ad aprire direttamente il file HTML dell'[Esempio 6-4](#sse_client)
    nel tuo browser e clicchi sul pulsante Avvia streaming, noterai che non succede
    nulla. Puoi controllare la scheda di rete del browser per vedere cosa è successo
    alle richieste in uscita.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接在你的浏览器中打开[Esempio 6-4](#sse_client)的HTML文件并点击启动流按钮，你会发现没有任何反应。你可以检查浏览器的网络标签来查看出站请求发生了什么。
- en: Dopo alcune indagini, dovresti notare che il tuo browser ha bloccato le richieste
    in uscita verso il tuo server perché i suoi controlli preliminari di*condivisione
    delle risorse in origine* (CORS) con il tuo server sono falliti.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些调查后，你应该会注意到你的浏览器因为其与你的服务器进行的*跨源资源共享*（CORS）初步检查失败，而阻止了对服务器的出站请求。
- en: CORS è un meccanismo di sicurezza implementato nei browser per controllare il
    modo in cui le risorse di una pagina web possono essere richieste da un altro
    dominio ed è rilevante solo quando si inviano richieste direttamente dal browser
    invece che da un server. I browser utilizzano CORS per verificare se sono autorizzati
    a inviare richieste al server da un'origine (cioè un dominio) diversa da quella
    del server.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: CORS是浏览器中实现的一种安全机制，用于控制网页资源可以被另一个域名请求的方式，并且仅在直接从浏览器发送请求而不是从服务器发送请求时相关。浏览器使用CORS来验证是否被授权从不同的源（即域名）向服务器发送请求。
- en: Ad esempio, se il tuo client è ospitato su `https://example.com` e deve recuperare
    dati da un'API ospitata su `https://api.example.com`, il browser bloccherà la
    richiesta a meno che il server API non abbia abilitato CORS.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的客户端托管在 `https://example.com` 上，并且需要从托管在 `https://api.example.com` 上的
    API 恢复数据，除非 API 服务器启用了 CORS，否则浏览器将阻止该请求。
- en: Per il momento, puoi aggirare questi errori CORS aggiungendo un middleware CORS
    sul tuo server, come puoi vedere nell'[Esempio 6-6](#cors), per consentire qualsiasi
    richiesta in arrivo dai browser.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你可以通过在你的服务器上添加 CORS 中间件来绕过这些 CORS 错误，就像在[Esempio 6-6](#cors)中看到的那样，以允许来自浏览器的任何请求。
- en: Esempio 6-6\. Applicare le impostazioni CORS
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-6\. 应用 CORS 设置
- en: '[PRE5]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO6-1)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO6-1)'
- en: Consente le richieste in arrivo da qualsiasi origine, metodo (`GET`, `POST`,
    ecc.) eintestazione.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 允许来自任何来源、方法（`GET`、`POST`等）和头信息的传入请求。
- en: Streamlit evita di attivare il meccanismo CORS inviando le richieste sul suo
    server interno anche se l'interfaccia utente generata viene eseguita sul browser.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 通过在其内部服务器上发送请求来避免激活 CORS 机制，即使生成的用户界面在浏览器上执行。
- en: D'altra parte, la pagina di documentazione di FastAPI effettua le richieste
    dalla stessa origine del server (cioè `http://localhost:8000`), quindi le richieste
    per impostazione predefinita non attivano ilmeccanismo di sicurezza CORS.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，FastAPI 的文档页面从同一服务器源执行请求（即 `http://localhost:8000`），因此默认情况下不会激活 CORS 安全机制。
- en: Avvertenze
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意事项
- en: Nell'[Esempio 6-6](#cors), configuri il middleware CORS per elaborare qualsiasi
    richiesta in arrivo, aggirando di fatto il meccanismo di sicurezza CORS per facilitare
    lo sviluppo. In produzione, dovresti consentire al tuo server di elaborare solo
    una manciata di origini, metodi e intestazioni.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Esempio 6-6](#cors)中，配置 CORS 中间件以处理任何传入的请求，实际上绕过了 CORS 安全机制以简化开发。在生产环境中，你应该允许你的服务器仅处理少量来源、方法和头信息。
- en: Se hai seguito l'esempio [6-5](#mounting_static_files) o [6-6](#cors), ora dovresti
    essere in grado di visualizzare il flusso in arrivo dal tuo endpoint SSE (vedi
    [Figura 6-8](#sse_results)).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经遵循了[示例 6-5](#mounting_static_files)或[示例 6-6](#cors)，现在你应该能够查看来自你的 SSE 端点的传入流（参见[图
    6-8](#sse_results)）。
- en: '![bgai 0608](assets/bgai_0608.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0608](assets/bgai_0608.png)'
- en: Figura 6-8\. Flusso in entrata dall'endpoint SSE
  id: totrans-213
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-8\. SSE 端点的传入流
- en: Congratulazioni! Ora hai una soluzione perfettamente funzionante in cui le risposte
    del modello vengono trasmesse direttamente al tuo cliente non appena i dati generati
    sono disponibili. Grazie all'implementazione di questa funzione, i tuoi utenti
    avranno un'esperienza più piacevole nell'interazione con il tuo chatbot, poiché
    riceveranno le risposte alle loro query in tempo reale.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在你有一个功能完善的解决方案，其中模型的响应会在数据生成后直接发送到你的客户。通过实现这个功能，你的用户在与你的聊天机器人交互时将获得更愉快的体验，因为他们会实时收到对他们的查询的响应。
- en: La tua soluzione ha anche implementato la concurrency utilizzando un client
    asincrono per interagire con l'API OpenAI di Azure per trasmettere risposte più
    veloci ai tuoi utenti. Puoi provare a utilizzare un client sincrono per confrontare
    le differenze nella velocità di generazione. Con un client asincrono, la velocità
    di generazione può essere così elevata che riceverai un blocco di testo in una
    sola volta anche se in realtà viene trasmesso al browser.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你的解决方案还通过使用异步客户端与 Azure OpenAI 的 API 交互来实现了并发性，以便更快地向你的用户提供响应。你可以尝试使用同步客户端来比较生成速度的差异。使用异步客户端时，生成速度可能非常高，以至于你可能会一次性接收到一个文本块，即使实际上它被传输到浏览器。
- en: Streaming dei risultati LLM dei modelli Hugging Face
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Hugging Face 模型 LLM 的结果流
- en: Ora che hai imparato a implementare gli endpoint SSE con i provider di modelli
    come Azure OpenAI, ti starai chiedendo se puoi trasmettere gli output dei modelli
    open source che hai precedentemente scaricato da Hugging Face.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用 Azure OpenAI 等模型提供商实现 SSE 端点，你可能会想知道是否可以传输你之前从 Hugging Face 下载的开源模型输出。
- en: Sebbene la libreria `transformers` di Hugging Face implementi un componente
    `TextStreamer`che puoi passare alla tua pipeline di modelli, la soluzione più
    semplice è quella di eseguire un server di inferenza separato come HF Inference
    Server per implementare lo streaming dei modelli.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Hugging Face的`transformers`库实现了一个可以传递给模型管道的`TextStreamer`组件，但最简单的解决方案是运行一个独立的推理服务器，如HF
    Inference Server，以实现模型的流式处理。
- en: L['esempio 6-7](#hf_llm_inference_server) mostra come configurare un semplice
    server di inferenza di modelli utilizzando Docker, fornendo un sito `model-id`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[esempio 6-7](#hf_llm_inference_server) 展示了如何使用 Docker 配置简单的模型推理服务器，并提供一个 `model-id`
    网站。'
- en: Esempio 6-7\. Servire i modelli HF LLM tramite il server di inferenza HF
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-7\. 通过 HF 推理服务器提供 HF LLM 模型服务
- en: '[PRE6]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO7-1)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png) (#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO7-1)'
- en: Usa Docker per scaricare ed eseguire il container `vllm/vllm-openai` più recente
    su tutte le GPU NVIDIA disponibili.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 在所有可用的 NVIDIA GPU 上下载并运行最新版本的 `vllm/vllm-openai` 容器。
- en: '[![2](assets/2.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO7-2)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png) (#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO7-2)'
- en: Condividi un volume con il contenitore Docker per evitare di scaricare pesi
    a ogni esecuzione.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与容器共享一个卷以避免每次执行时都下载大量内容。
- en: '[![3](assets/3.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO7-3)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png) (#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO7-3)'
- en: Imposta la variabile d'ambiente secret per accedere a modelli con accesso limitato
    come `mistralai/Mistral-7B-v0.1`.^([4](ch06.html#id909))
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 设置环境变量 secret 以访问受限访问的模型，例如 `mistralai/Mistral-7B-v0.1`。^([4](ch06.html#id909))
- en: '[![4](assets/4.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO7-4)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png) (#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO7-4)'
- en: Esegui il server di inferenza sulla porta localhost `8080` mappando la porta
    dell'host `8080` sulla porta esposta del contenitore Docker `8000`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地主机 `8080` 端口上运行推理服务器，将主机端口的 `8080` 映射到 Docker 容器暴露的端口 `8000`。
- en: '[![5](assets/5.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO7-5)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png) (#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO7-5)'
- en: Abilita la comunicazione inter-processo (IPC) tra il contenitore e l'host per
    consentire al contenitore di accedere alla memoria condivisa dell'host.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 启用容器和主机之间的进程间通信 (IPC)，以便容器可以访问主机的共享内存。
- en: '[![6](assets/6.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO7-7)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png) (#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO7-7)'
- en: Il server di inferenza vLLM utilizza le specifiche API OpenAI per il servizio
    LLM.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: vLLM 推理服务器使用 OpenAI 服务 LLM 的特定 API。
- en: '[![7](assets/7.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO7-8)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![7](assets/7.png) (#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO7-8)'
- en: Scarica e utilizza il sito `mistralai/Mistral-7B-v0.1` di Hugging Face Hub.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并使用 Hugging Face Hub 上的 `mistralai/Mistral-7B-v0.1` 网站。
- en: Con il server del modello in esecuzione, puoi ora utilizzare un sito `AsyncInferenceClient`
    per generare output in formato streaming, come mostrato nell'[Esempio 6-8](#hf_llm_streaming).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型服务器运行时，你现在可以使用 `AsyncInferenceClient` 网站以流式格式生成输出，如 [示例 6-8](#hf_llm_streaming)
    所示。
- en: Esempio 6-8\. Consumo del flusso di output LLM dal flusso di inferenza HF
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-8\. 从 HF 推理流中消费 LLM 输出流
- en: '[PRE7]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Sebbene [l'Esempio 6-8](#hf_llm_streaming) mostri come utilizzare il server
    di inferenza Hugging Face, puoi comunque utilizzare altri framework di model-serving
    come [vLLM](https://oreil.ly/LQAzF) che supportano lo streaming delle risposte
    del modello.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然示例 [l'Esempio 6-8](#hf_llm_streaming) 展示了如何使用 Hugging Face 的推理服务器，但你仍然可以使用其他支持模型流式响应的模型服务框架，例如
    [vLLM](https://oreil.ly/LQAzF)。
- en: Prima di passare a parlare di WebSocket, vediamo come consumare un'altra variante
    di endpoint SSE utilizzando il metodo `POST`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 WebSocket 之前，让我们看看如何使用 `POST` 方法消费另一个 SSE 端点变体。
- en: SSE con richiesta POST
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSE 与 POST 请求
- en: La [specifica`EventSource`](https://oreil.ly/61ovi) prevede che gli endpoint
    di `GET` sul server consumino correttamente il flusso SSE in entrata. Questo rende
    semplice l'implementazione di applicazioni in tempo reale con SSE, poiché l'interfaccia`EventSource`
    è in grado di gestire problemi come la caduta della connessione e la riconnessione
    automatica.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[specifica`EventSource`](https://oreil.ly/61ovi) 规范规定服务器上的 `GET` 端点应正确消费传入的
    SSE 流。这使得使用 SSE 实现实时应用程序变得简单，因为 `EventSource` 接口能够处理诸如连接丢失和自动重连等问题。'
- en: 'Tuttavia, l''utilizzo delle richieste HTTP `GET` comporta delle limitazioni:
    le richieste`GET` sono normalmente meno sicure rispetto agli altri metodi di richiesta
    e più vulnerabili agli attacchi *XSS*.^([5](ch06.html#id912)) Inoltre, poiché
    le richieste `GET` non possono avere un corpo della richiesta, puoi trasferire
    i dati solo come parte dei parametri di query dell''URL al server. Il problema
    è che c''è un limite di lunghezza dell''URL che devi considerare e tutti i parametri
    di query devono essere codificati correttamente nell''URL della richiesta. Pertanto,
    non puoi semplicemente aggiungere l''intera cronologia della conversazione all''URL
    come parametro. Il tuo server deve gestire la cronologia della conversazione e
    tenere traccia del contesto della conversazione con gliendpoint SSE di `GET` .'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 HTTP `GET` 请求有一些限制：与其它请求方法相比，`GET` 请求通常更不安全，更容易受到 *XSS* 攻击。^([5](ch06.html#id912))
    此外，由于 `GET` 请求不能有请求体，你只能将数据作为 URL 查询参数的一部分发送到服务器。问题是 URL 长度有限，你必须考虑这一点，并且所有查询参数都必须正确编码在请求
    URL 中。因此，你不能简单地将整个会话历史添加到 URL 作为参数。你的服务器必须处理会话历史，并使用 `GET` 的 SSE 端点跟踪会话上下文。
- en: Una soluzione comune a questa limitazione consiste nell'implementare un endpoint
    SSE `POST` anche se la specifica SSE non lo supporta. Di conseguenza, l'implementazione
    sarà più complessa.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这种限制的一个常见方法是在即使 SSE 规范不支持的情况下也实现一个 SSE `POST` 端点。因此，实现将更加复杂。
- en: Per prima cosa, implementiamo l'endpoint `POST` sul server nell'[Esempio 6-9](#sse_server_post).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 [示例 6-9](#sse_server_post) 中实现了服务器上的 `POST` 端点。
- en: Esempio 6-9\. Implementazione dell'endpoint SSE sul server
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-9\. 在服务器上实现 SSE 端点
- en: '[PRE8]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Con l'implementazione dell'endpoint `POST` per lo streaming degli output della
    chat, puoi ora sviluppare la logica del client per elaborare lo stream SSE.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现聊天输出流的 `POST` 端点，你现在可以开发客户端逻辑来处理 SSE 流。
- en: Dovrai elaborare manualmente lo streaming in arrivo utilizzando l'interfaccia
    web `fetch` del browser, come mostrato nell'[Esempio 6-10](#sse_client_post).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要手动使用浏览器中的 `fetch` 网页接口处理传入的流，如 [示例 6-10](#sse_client_post) 所示。
- en: Esempio 6-10\. Implementazione di SSE sul client utilizzando l'API del browser
    `EventSource`
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-10\. 使用浏览器 API `EventSource` 在客户端实现 SSE
- en: '[PRE9]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO8-1)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png) (#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO8-1)'
- en: Invia una richiesta `POST` al backend utilizzando l'interfaccia `fetch` del
    browser. Prepara il corpo come stringa JSON come parte della richiesta. Aggiungi
    le intestazioni per specificare il corpo della richiesta inviata e la risposta
    attesa dal server.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器的 `fetch` 接口向后端发送 `POST` 请求。将请求体作为 JSON 字符串包含在请求中。添加头部以指定发送的请求体和期望从服务器收到的响应。
- en: '[![2](assets/2.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO8-2)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png) (#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO8-2)'
- en: Accede a `reader` del flusso dal flusso del corpo della risposta.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 从响应体的流中访问 `reader`。
- en: '[![3](assets/3.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO8-3)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png) (#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO8-3)'
- en: Crea un'istanza di decodificatore di testo per elaborare ogni messaggio.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个用于处理每条消息的文本解码器实例。
- en: '[![4](assets/4.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO8-4)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png) (#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO8-4)'
- en: Esegue un ciclo infinito e legge il messaggio successivo nel flusso utilizzando`reader`.
    Se il flusso è terminato, `done=true`, quindi interrompe il ciclo; altrimenti,
    decodifica il messaggio con il decodificatore di testo e lo aggiunge al contenitore
    delle risposte`textContent` per eseguire il rendering.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 执行一个无限循环，并使用 `reader` 读取流中的下一个消息。如果流已终止，则 `done=true`，因此中断循环；否则，使用文本解码器解码消息并将其添加到
    `textContent` 响应容器中以便进行渲染。
- en: '[![5](assets/5.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO8-5)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)'
- en: Ascolta gli eventi del pulsante `click` per eseguire un callback che ripristina
    lo stato del modulo ed effettua la connessione SSE con l'endpoint del backend
    con un prompt.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 监听按钮的 `click` 事件以执行回调，该回调将恢复模块状态并使用提示与后端端点建立 SSE 连接。
- en: Come si può vedere dall'[Esempio 6-10](#sse_client_post), consumare il flusso
    SSE senza il parametro`EventSource` può diventare complesso.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [示例 6-10](#sse_client_post) 所示，在不使用 `EventSource` 参数的情况下消费 SSE 流可能会变得复杂。
- en: Suggerimento
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 建议
- en: Un'alternativa all'[Esempio 6-10](#sse_client_post) è quella di utilizzare gli
    endpoint SSE di `GET` ma di inviare preventivamente il payload di grandi dimensioni
    al server tramite una richiesta `POST`. Il server memorizza i dati e li utilizza
    quando viene stabilita la connessione SSE.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用 `GET` SSE 端点，但预先通过 `POST` 请求将大型有效载荷发送到服务器。服务器将存储数据并在建立 SSE 连接时使用它们。
- en: SSE supporta anche i cookie, quindi puoi affidarti ai cookie per scambiare payload
    di grandi dimensioni negli endpoint di `GET` SSE.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: SSE 也支持 cookie，因此你可以依赖 cookie 在 `GET` SSE 端点交换大型有效载荷。
- en: Se vuoi utilizzare l'endpoint SSE in produzione, la tua soluzione deve supportare
    anche la funzionalità di retry, la gestione degli errori o addirittura la possibilità
    di interrompere le connessioni.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在生产中使用 SSE 端点，你的解决方案还必须支持重试功能、错误处理，甚至中断连接的可能性。
- en: L['esempio 6-11](#sse_retry) mostra come implementare in JavaScript una funzionalità
    di ritentativo lato client con un *ritardo di backoff esponenziale*.^([6](ch06.html#id914))
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-11](#sse_retry) 展示了如何在 JavaScript 中实现带有指数退避延迟的重试客户端功能。^([6](ch06.html#id914))'
- en: Esempio 6-11\. Implementazione della funzionalità di retry lato client con backoff
    esponenziale
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6-11 示例。客户端实现带指数退避的重试功能
- en: '[PRE10]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO9-1)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)'
- en: Finché `maxRetries` non viene raggiunto, prova a stabilire la connessione SSE.
    Conta ogni tentativo.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在达到 `maxRetries` 之前，尝试建立 SSE 连接。计算每次尝试。
- en: '[![2](assets/2.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO9-2)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)'
- en: Utilizza `try` e `catch` per gestire gli errori di connessione.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `try` 和 `catch` 来处理连接错误。
- en: '[![3](assets/3.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO9-3)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)'
- en: Esce dalla funzione in caso di successo.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时退出函数。
- en: '[![4](assets/4.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO9-4)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)'
- en: Pausa in `delay` millisecondi prima di riprovare.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在重试之前暂停 `delay` 毫秒。
- en: '[![5](assets/5.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO9-5)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)'
- en: Implementa il backoff esponenziale moltiplicando un fattore di backoff al valore
    del ritardo in ogni iterazione.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在每次迭代中将退避因子乘以延迟值来实现指数退避。
- en: '[![6](assets/6.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO9-6)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png)'
- en: Lancia `error` se viene raggiunto `maxRetries`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当达到 `maxRetries` 时抛出 `error`。
- en: Ora dovresti sentirti più a tuo agio nell'implementare i tuoi endpoint SSE per
    lo streaming delle risposte del modello. SSE è il meccanismo di comunicazione
    che applicazioni come ChatGPT utilizzano per le conversazioni in tempo reale con
    il modello. Poiché SSE supporta prevalentemente flussi basati sul testo, è ideale
    per gli scenari di streaming dell'output di LLM.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该更自在地实现你的SSE端点以进行模型响应的流式传输。SSE是ChatGPT等应用程序用于与模型进行实时对话的通信机制。由于SSE主要支持基于文本的流，它非常适合LLM输出流式传输的场景。
- en: Nella prossima sezione, implementeremo la stessa soluzione utilizzando il meccanismo
    WebSocket, in modo da poter confrontare le differenze nei dettagli dell'implementazione.
    Inoltre, imparerai cosa rende WebSocket ideale per gli scenari che richiedono
    una comunicazione duplex in tempo reale, come nei servizi di trascrizione dal
    vivo.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用WebSocket机制实现相同的解决方案，以便比较实现细节的差异。此外，你将了解为什么WebSocket对于需要实时双工通信的场景（如现场转录服务）是理想的。
- en: Implementare gli endpoint WS
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现WS端点
- en: In questa sezione, implementerai un endpoint utilizzando il protocollo WebSocket.
    Con questo endpoint, trasmetterai gli output di LLM al client utilizzando WebSocket
    per confrontarli con la connessione SSE. Alla fine, imparerai le differenze e
    le somiglianze tra SSE e WebSocket nello streaming degli output di LLM in tempo
    reale.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将使用WebSocket协议实现一个端点。通过此端点，你将使用WebSocket将LLM的输出传输给客户端，以便与SSE连接进行比较。最后，你将学习SSE和WebSocket在实时LLM输出流式传输中的异同。
- en: Streaming degli output di LLM con WebSocket
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用WebSocket进行LLM输出流式传输
- en: FastAPI supporta WebSocket attraverso l'uso dell'interfaccia `WebSocket` del
    framework web Starlette. Poiché le connessioni WebSocket devono essere gestite,
    iniziamo con l'implementazione di un gestore di connessioni per tenere traccia
    delle connessioni attive e gestire i loro stati.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI通过使用Starlette框架的`WebSocket`接口支持WebSocket。由于WebSocket连接需要管理，我们首先实现一个连接管理器来跟踪活动连接及其状态。
- en: Puoi implementare un gestore di connessioni WebSocket seguendo l'[Esempio 6-12](#websockets_manager).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照[示例 6-12](#websockets_manager)实现一个WebSocket连接管理器。
- en: Esempio 6-12\. Implementazione di un gestore di connessioni WebSocket
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-12\. WebSocket连接管理器的实现
- en: '[PRE11]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO10-1)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[(#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO10-1)]'
- en: Crea un `WSConnectionManager` per tenere traccia e gestire le connessioni WS
    attive.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`WSConnectionManager`来跟踪和管理活动的WS连接。
- en: '[![2](assets/2.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO10-2)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[(#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO10-2)]'
- en: Apri una connessione WebSocket utilizzando il metodo `accept()`. Aggiungi la
    nuova connessione all'elenco delle connessioni attive.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`accept()`方法打开WebSocket连接。将新连接添加到活动连接列表中。
- en: '[![3](assets/3.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO10-3)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[(#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO10-3)]'
- en: Quando ti disconnetti, chiudi la connessione e rimuovi l'istanza di `websocket`dall'elenco
    delle connessioni attive.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当你断开连接时，关闭连接并从活动连接列表中移除`websocket`实例。
- en: '[![4](assets/4.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO10-4)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[(#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO10-4)]'
- en: Ricevi i messaggi in arrivo come testo durante una connessione aperta.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开的连接期间接收文本形式的传入消息。
- en: '[![5](assets/5.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO10-5)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)[(#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO10-5)]'
- en: Invia i messaggi al client utilizzando il metodo di invio pertinente.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相关发送方法向客户端发送消息。
- en: '[![6](assets/6.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO10-6)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png)[(#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO10-6)]'
- en: Crea una singola istanza di `WSConnectionManager` da riutilizzare in tutta l'applicazione.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可重用于整个应用的`WSConnectionManager`单例。
- en: Puoi anche estendere il gestore delle connessioni dell'[Esempio 6-12](#websockets_manager)
    per *trasmettere* messaggi (ad esempio, avvisi, notifiche o aggiornamenti del
    sistema in tempo reale) a tutti i client connessi. Questo è utile in applicazioni
    come le chat di gruppo o gli strumenti di editing collaborativo di lavagne e documenti.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以扩展[Esempio 6-12](#websockets_manager)中的连接管理器以*传输*消息（例如，警告、通知或实时系统更新）给所有连接的客户端。这在群聊或协作白板和文档编辑工具等应用中非常有用。
- en: Poiché il gestore delle connessioni mantiene un puntatore a ogni client tramite
    l'elenco `active_​con⁠nec⁠tions`, puoi trasmettere messaggi a ogni client, come
    mostrato nell'[Esempio 6-13](#websockets_broadcast).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于连接管理器通过`active_connections`列表维护每个客户端的指针，你可以向每个客户端发送消息，如[Esempio 6-13](#websockets_broadcast)中所示。
- en: Esempio 6-13\. Trasmissione di messaggi ai client connessi utilizzando il gestore
    WebSocket
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-13\. 使用WebSocket管理器向连接的客户端传输消息
- en: '[PRE12]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Con l'implementazione del gestore WebSocket, ora puoi sviluppare un endpoint
    WebSocket per trasmettere le risposte ai client. Tuttavia, prima di implementare
    l'endpoint, segui l'[Esempio 6-14](#chat_stream_ws) per aggiornare il metodo`chat_stream`in
    modo che produca il contenuto dello stream in un formato adatto alle connessioni
    WebSocket.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现WebSocket管理器，现在你可以开发一个WebSocket端点以向客户端传输响应。然而，在实现端点之前，遵循[Esempio 6-14](#chat_stream_ws)以更新`chat_stream`方法，使其产生适合WebSocket连接的流内容。
- en: Esempio 6-14\. Aggiornare il metodo di streaming del client di chat per produrre
    contenuti adatti alle connessioni WebSocket
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-14\. 更新聊天客户端的流式传输方法以生成适合WebSocket连接的内容
- en: '[PRE13]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO11-1)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO11-1)'
- en: Restituisce solo contenuti non vuoti.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 仅返回非空内容。
- en: '[![2](assets/2.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO11-2)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO11-2)'
- en: Restituisce il contenuto del flusso in base al tipo di connessione (SSE o WS).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 根据连接类型（SSE或WS）返回流的内容。
- en: Dopo aver aggiornato il metodo `stream_chat`, puoi concentrarti sull'aggiunta
    di un endpoint WebSocket. Utilizza il metodo `@app.websocket` per decorare una
    funzione del controller che utilizza la classe `WebSocket` di FastAPI, come mostrato
    nell'[esempio 6-15](#websocket_endpoint).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`stream_chat`方法后，你可以专注于添加WebSocket端点。使用`@app.websocket`装饰器装饰控制器中的函数，该函数使用FastAPI的`WebSocket`类，如[esempio
    6-15](#websocket_endpoint)中所示。
- en: Esempio 6-15\. Implementazione di un endpoint WS
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-15\. 实现WS端点
- en: '[PRE14]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-1)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-1)'
- en: Crea un endpoint WebSocket accessibile all'indirizzo`ws://localhost:8000/generate/text/stream`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可访问的WebSocket端点，地址为`ws://localhost:8000/generate/text/stream`。
- en: '[![2](assets/2.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-2)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-2)'
- en: Apri la connessione WebSocket tra il client e il server.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 打开客户端和服务器之间的WebSocket连接。
- en: '[![3](assets/3.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-3)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-3)'
- en: Finché la connessione è aperta, continua a inviare o ricevere messaggi.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 只要连接打开，就继续发送或接收消息。
- en: '[![4](assets/4.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-4)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-4)'
- en: Gestire gli errori e registrare gli eventi importanti all'interno di `websocket_controller`
    per identificare le cause degli errori e gestire le situazioni inaspettate con
    grazia. Interrompere il ciclo infinito quando la connessione viene chiusa dal
    server o dal client.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在`websocket_controller`内部处理错误并记录重要事件，以识别错误原因并以优雅的方式处理意外情况。当服务器或客户端关闭连接时，中断无限循环。
- en: '[![5](assets/5.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-5)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-5)'
- en: Quando viene ricevuto il primo messaggio, passalo come prompt all'API OpenAI.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当收到第一条消息时，将其作为提示传递给OpenAI API。
- en: '[![6](assets/6.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-6)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-6]'
- en: iterare in modo asincrono sul flusso di chat generato e inviare ogni pezzo al
    client.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 异步迭代生成的聊天流，并将每个片段发送到客户端。
- en: '[![7](assets/7.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-7)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![7](assets/7.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-7]'
- en: Attendere un piccolo lasso di tempo prima di inviare il messaggio successivo
    per ridurre i problemi di race condition e consentire al client di avere tempo
    sufficiente per l'elaborazione del flusso.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送下一个消息之前等待一小段时间，以减少竞争条件问题，并允许客户端有足够的时间处理流。
- en: '[![8](assets/8.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-8)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![8](assets/8.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-8]'
- en: Quando il client chiude la connessione WebSocket, viene sollevata l'eccezione
    `WebSocketDisconnect`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端关闭 WebSocket 连接时，会引发 `WebSocketDisconnect` 异常。
- en: '[![9](assets/9.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-9)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '![9](assets/9.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-9]'
- en: Se si verifica un errore sul lato server durante una connessione aperta, registra
    l'errore e identifica il cliente.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在打开连接期间服务器端发生错误，则记录错误并识别客户。
- en: '[![10](assets/10.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-10)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![10](assets/10.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO12-10]'
- en: Interrompe il ciclo infinito e chiude con grazia la connessione WebSocket se
    lo stream è terminato, se c'è un errore interno o se il client ha chiuso la connessione.
    Rimuove la connessione dall'elenco delle connessioni WebSocket attive.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果流已终止、发生内部错误或客户端关闭连接，则中断无限循环并优雅地关闭 WebSocket 连接。从活动的 WebSocket 连接列表中删除连接。
- en: Ora che hai un endpoint WebSocket, sviluppiamo l'HTML del client per testare
    l'endpoint (vedi [Esempio 6-16](#ws_client)).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个 WebSocket 端点，我们来开发客户端的 HTML 以测试该端点（参见 [示例 6-16](#ws_client)）。
- en: Esempio 6-16\. Implementazione di connessioni WebSocket lato client con gestione
    degli errori e funzionalità di backoff retry esponenziale
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-16\. 客户端 WebSocket 连接实现，包括错误处理和指数退避重试功能
- en: '[PRE15]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO13-1)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO13-1]'
- en: Stabilisci una connessione WebSocket con il server FastAPI.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 与 FastAPI 服务器建立 WebSocket 连接。
- en: '[![2](assets/2.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO13-2)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO13-2]'
- en: Aggiungi dei gestori di callback all'istanza di connessione WebSocket per gestire
    gli eventi di apertura, chiusura, messaggio ed errore.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 向 WebSocket 连接实例添加回调处理程序以处理打开、关闭、消息和错误事件。
- en: '[![3](assets/3.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO13-3)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO13-3]'
- en: Gestisce con grazia gli errori di connessione e ristabilisce la connessione
    con una funzionalità di backoff retry esponenziale utilizzando un flag `isError`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `isError` 标志优雅地处理连接错误并使用指数退避重试功能重新建立连接。
- en: '[![4](assets/4.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO13-4)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO13-4]'
- en: Aggiungi un ascoltatore di eventi al pulsante di streaming per inviare il primo
    messaggio al server.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 向流按钮添加事件监听器，以将第一条消息发送到服务器。
- en: '[![5](assets/5.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO13-5)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO13-5]'
- en: Una volta stabilita la connessione, invia il prompt iniziale non vuoto come
    primo messaggio al server.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立连接，将非空提示信息作为第一条消息发送到服务器。
- en: '[![6](assets/6.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO13-6)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png)[#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO13-6]'
- en: Reimposta il modulo prima di stabilire la connessione WebSocket da avviare.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立要启动的 WebSocket 连接之前重置模块。
- en: '[![7](assets/7.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO13-7)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_real_time_communication___span_class__keep_together__with_generative_models__span__CO13-7)'
- en: Aggiungi un ascoltatore di eventi al pulsante di chiusura della connessione
    per chiudere la connessione quando il pulsante viene cliccato.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Aggiungi un ascoltatore di eventi al pulsante di chiusura della connessione
    per chiudere la connessione quando il pulsante viene cliccato.
- en: Ora puoi visitare [*http://localhost:8000/pages/client-ws.html*](http://localhost:8000/pages/client-ws.html)
    per testare il tuo endpoint di streaming WebSocket (vedi [Figura 6-9](#ws_results)).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Ora puoi visitare [*http://localhost:8000/pages/client-ws.html*](http://localhost:8000/pages/client-ws.html)
    per testare il tuo endpoint di streaming WebSocket (vedi [Figura 6-9](#ws_results)).
- en: '![bgai 0609](assets/bgai_0609.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0609](assets/bgai_0609.png)'
- en: Figura 6-9\. Flusso in entrata dall'endpoint WebSocket
  id: totrans-356
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figura 6-9\. Flusso in entrata dall'endpoint WebSocket
- en: Ora dovresti avere un'applicazione di streaming LLM completamente funzionante
    con WebSocket. Ben fatto!
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Ora dovresti avere un'applicazione di streaming LLM completamente funzionante
    con WebSocket. Ben fatto!
- en: 'A questo punto ti starai chiedendo quale sia la soluzione migliore: lo streaming
    con SSE o le connessioni WS. La risposta dipende dai requisiti della tua applicazione.
    SSE è semplice da implementare ed è nativo del protocollo HTTP, quindi la maggior
    parte dei client lo supporta. Se hai bisogno solo di uno streaming unidirezionale
    verso il client, allora ti consiglio di implementare le connessioni SSE per lo
    streaming degli output di LLM.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 'A questo punto ti starai chiedendo quale sia la soluzione migliore: lo streaming
    con SSE o le connessioni WS. La risposta dipende dai requisiti della tua applicazione.
    SSE è semplice da implementare ed è nativo del protocollo HTTP, quindi la maggior
    parte dei client lo supporta. Se hai bisogno solo di uno streaming unidirezionale
    verso il client, allora ti consiglio di implementare le connessioni SSE per lo
    streaming degli output di LLM.'
- en: Le connessioni WebSocket forniscono un maggiore controllo al meccanismo di streaming
    e consentono una comunicazione duplex all'interno della stessa connessione, ad
    esempio nelle applicazioni di chat in tempo reale con più utenti e nei servizi
    LLM, speech-to-text, text-to-speech e speech-to-speech. Tuttavia, l'utilizzo di
    WebSocket richiede l'aggiornamento della connessione da HTTP al protocollo WebSocket,
    che i client legacy e i browser più vecchi potrebbero non supportare. Inoltre,
    dovrai gestire le eccezioni in modo leggermente diverso con gli endpoint WebSocket.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Le connessioni WebSocket forniscono un maggiore controllo al meccanismo di streaming
    e consentono una comunicazione duplex all'interno della stessa connessione, ad
    esempio nelle applicazioni di chat in tempo reale con più utenti e nei servizi
    LLM, speech-to-text, text-to-speech e speech-to-speech. Tuttavia, l'utilizzo di
    WebSocket richiede l'aggiornamento della connessione da HTTP al protocollo WebSocket,
    che i client legacy e i browser più vecchi potrebbero non supportare. Inoltre,
    dovrai gestire le eccezioni in modo leggermente diverso con gli endpoint WebSocket.
- en: Gestire le eccezioni WebSocket
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gestire le eccezioni WebSocket
- en: La gestione delle eccezioni WebSocket è diversa da quella delle connessioni
    HTTP tradizionali. Se fai riferimento all'[Esempio 6-15](#websocket_endpoint),
    noterai che non stai più restituendo al cliente una risposta con codici di stato,
    o `HTTPExceptions`, ma piuttosto stai mantenendo una connessione aperta dopo l'accettazione
    della connessione.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: La gestione delle eccezioni WebSocket è diversa da quella delle connessioni
    HTTP tradizionali. Se fai riferimento all'[Esempio 6-15](#websocket_endpoint),
    noterai che non stai più restituendo al cliente una risposta con codici di stato,
    o `HTTPExceptions`, ma piuttosto stai mantenendo una connessione aperta dopo l'accettazione
    della connessione.
- en: Finché la connessione è aperta, puoi inviare e ricevere messaggi. Tuttavia,
    non appena si verifica un'eccezione, devi gestirla chiudendo con grazia la connessione
    e/o inviando un messaggio di errore al client in sostituzione della risposta `HTTPException`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Finché la connessione è aperta, puoi inviare e ricevere messaggi. Tuttavia,
    non appena si verifica un'eccezione, devi gestirla chiudendo con grazia la connessione
    e/o inviando un messaggio di errore al client in sostituzione della risposta `HTTPException`.
- en: Poiché il protocollo WebSocket non supporta i consueti codici di stato HTTP
    (`4xx` o `5xx`), non puoi usare i codici di stato per notificare ai client i problemi
    del lato server. Al contrario, dovresti inviare messaggi WebSocket ai client per
    notificare loro i problemi prima di chiudere qualsiasi connessione attiva dal
    server.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Poiché il protocollo WebSocket non supporta i consueti codici di stato HTTP
    (`4xx` o `5xx`), non puoi usare i codici di stato per notificare ai client i problemi
    del lato server. Al contrario, dovresti inviare messaggi WebSocket ai client per
    notificare loro i problemi prima di chiudere qualsiasi connessione attiva dal
    server.
- en: Durante la chiusura della connessione, puoi utilizzare diversi codici di stato
    relativi a WebSocket per specificare il motivo della chiusura. Utilizzando questi
    motivi di chiusura, puoi implementare qualsiasi comportamento di chiusura personalizzato
    sul server o sui client.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: Durante la chiusura della connessione, puoi utilizzare diversi codici di stato
    relativi a WebSocket per specificare il motivo della chiusura. Utilizzando questi
    motivi di chiusura, puoi implementare qualsiasi comportamento di chiusura personalizzato
    sul server o sui client.
- en: La[Tabella 6-2](#ws_status_codes) mostra alcuni codici di stato comuni che possono
    essere inviati con un frame `CLOSE`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-2](#ws_status_codes) 展示了一些可以通过 `CLOSE` 帧发送的常见状态码。'
- en: Tabella 6-2\. Codici di stato comuni del protocollo WebSocket
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-2\. WebSocket 协议常见状态码
- en: '| Codice di stato | Descrizione |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 状态码 | 描述 |'
- en: '| --- | --- |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1000 | Chiusura normale |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 正常关闭 |'
- en: '| 1001 | Il cliente si è allontanato o il server è andato giù |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 1001 | 客户端已断开连接或服务器已关闭 |'
- en: '| 1002 | Un endpoint (ad esempio, client o server) ha ricevuto dati che violano
    il protocollo WS (ad esempio, pacchetti non mascherati, lunghezza del payload
    non valida). |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| 1002 | 一个端点（例如，客户端或服务器）接收到了违反 WS 协议的数据（例如，未掩码的包，无效的有效载荷长度）。|'
- en: '| 1003 | Un endpoint ha ricevuto dati non supportati (ad esempio, si aspettava
    un testo e ha ricevuto un file binario). |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 1003 | 一个端点接收到了不支持的数据（例如，期望接收文本却收到了二进制文件）。|'
- en: '| 1007 | Un endpoint ha ricevuto dati codificati in modo incoerente (ad esempio,
    dati non UTF-8 all''interno di un messaggio di testo). |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 1007 | 一个端点接收到了编码不一致的数据（例如，文本消息中的非 UTF-8 数据）。|'
- en: '| 1008 | Un endpoint ha ricevuto un messaggio che viola la sua politica; può
    essere utilizzato per nascondere i dettagli della chiusura per motivi di sicurezza.
    |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 1008 | 一个端点接收到了违反其策略的消息；可以用于隐藏关闭细节以保障安全。|'
- en: '| 1011 | Errore interno del server |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| 1011 | 服务器内部错误 |'
- en: Puoi trovare maggiori informazioni sugli altri codici di stato WebSocket nella[sezione
    7.4](https://oreil.ly/1L_HH) del protocollo WebSocket[RFC 6455.](https://oreil.ly/1L_HH)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 WebSocket 协议的[第 7.4 节](https://oreil.ly/1L_HH)中找到有关其他状态码的更多信息[RFC 6455](https://oreil.ly/1L_HH)。
- en: Progettare API per lo streaming
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计用于流式的 API
- en: Ora che hai acquisito una maggiore familiarità con le implementazioni degli
    endpoint SSE e WebSocket, desidero soffermarmi su un ultimo importante dettaglio
    relativo al loro design architettonico.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对 SSE 和 WebSocket 的实现有了更多的熟悉，我想着重讨论一个关于它们设计架构的最后一个重要细节。
- en: Un'insidia comune nella progettazione di API di streaming è l'esposizione di
    un numero eccessivo di endpoint di streaming. Ad esempio, se stai realizzando
    un'applicazione di chatbot, potresti esporre diversi endpoint di streaming, ognuno
    preconfigurato per gestire diversi messaggi in arrivo in una singola conversazione.
    Utilizzando questo particolare modello di progettazione dell'API, chiedi al cliente
    di passare da un endpoint all'altro, fornendo le informazioni necessarie in ogni
    passaggio e navigando tra le connessioni in streaming durante una singola conversazione.
    Questo modello di progettazione aumenta la complessità delle applicazioni sia
    di backend che di frontend, poiché gli stati della conversazione devono essere
    gestiti da entrambi i lati, evitando condizioni di gara e problemi di rete tra
    i componenti.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计流式 API 时，一个常见的陷阱是暴露过多的流式端点。例如，如果你正在开发一个聊天机器人应用，你可能需要暴露多个流式端点，每个端点预先配置以处理单个会话中的不同消息。使用这种特定的
    API 设计模式，你需要让客户从一个端点切换到另一个端点，在每个步骤中提供必要的信息，并在单个会话中导航流式连接。这种设计模式增加了后端和前端应用程序的复杂性，因为会话状态需要由双方管理，以避免组件之间的竞争条件和网络问题。
- en: Un modello di progettazione dell'API più semplice consiste nel fornire un unico
    punto di ingresso al client per avviare un flusso con i tuoi modelli GenAI e utilizzare
    le intestazioni, il corpo della richiesta o i parametri della query per attivare
    la logica pertinente nel backend. Con questo design, la logica del backend è astratta
    dal client, il che semplifica la gestione dello stato sul frontend, mentre tutte
    le rotte e la logica aziendale sono implementate nel backend. Poiché il backend
    ha accesso ai database, ad altri servizi e a prompt personalizzati, può facilmenteeseguire
    operazioni CRUD e passare da un prompt all'altro o da un modello all'altro per
    calcolare una risposta. Pertanto, un endpoint può fungere da unico punto di ingresso
    per la logica di commutazione, gestire gli stati dell'applicazione e generare
    risposte personalizzate.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简单的API设计模型是提供一个单一的入口点供客户端启动与您的GenAI模型的流，并使用头部、请求体或查询参数来激活后端的相关逻辑。在这种设计中，后端逻辑从客户端抽象出来，简化了前端的状态管理，而所有路由和业务逻辑都实现在后端。由于后端可以访问数据库、其他服务和自定义提示，它可以轻松执行CRUD操作，并在提示之间或模型之间切换以计算响应。因此，一个端点可以作为一个唯一的入口点用于切换逻辑，管理应用程序状态并生成定制响应。
- en: Riassunto
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Questo capitolo ha trattato diverse strategie per implementare la comunicazione
    in tempo reale tramite lo streaming dei dati nei tuoi servizi GenAI.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了多种策略，用于在您的GenAI服务中通过数据流实现实时通信。
- en: Hai imparato a conoscere diversi meccanismi di comunicazione web, tra cui il
    tradizionale modello HTTP richiesta-risposta, il polling breve/regolare, il polling
    lungo, SSE e WebSocket. Hai poi confrontato questi meccanismi in dettaglio per
    comprenderne le caratteristiche, i vantaggi, gli svantaggi e i casi d'uso, in
    particolare per i flussi di lavoro dell'intelligenza artificiale. Infine, hai
    implementato due endpoint di streaming LLM utilizzando il client asincrono Azure
    OpenAI per imparare a sfruttare imeccanismi di comunicazione in tempo reale SSE
    e WebSocket.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '你已经学习了多种Web通信机制，包括传统的HTTP请求-响应模型、短轮询/长轮询、SSE和WebSocket。然后你详细比较了这些机制，以理解它们的特性、优点、缺点和用例，特别是对于人工智能工作流程。最后，你使用Azure
    OpenAI的异步客户端实现了两个LLM流式传输端点，以学习如何利用实时通信机制SSE和WebSocket。 '
- en: Nel prossimo capitolo imparerai a conoscere meglio i flussi di lavoro per lo
    sviluppo delle API durante l'integrazione dei database per i servizi di intelligenza
    artificiale, tra cui come impostare, migrare e interagire con i database. Imparerai
    anche a gestire le operazioni di archiviazione e recupero dei dati all'interno
    degli endpoint di streaming utilizzando i task in background di FastAPI.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将更好地了解在集成人工智能服务数据库时开发API的工作流程，包括如何设置、迁移和与数据库交互。你还将学习如何使用FastAPI的背景任务来管理端点中的数据存储和检索操作。
- en: Gli argomenti trattati nel prossimo capitolo comprenderanno l'impostazione dei
    database e la progettazione degli schemi, il lavoro con SQLAlchemy, le migrazioni
    di database e la gestione delle operazioni di database durante lo streaming degli
    output dei modelli.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论数据库设置和模式设计、使用SQLAlchemy进行操作、数据库迁移以及模型输出流中的数据库操作管理。
- en: ^([1](ch06.html#id893-marker)) Gli aggressori possono utilizzare il cache poisoning
    per iniettare dati dannosi nei sistemi di caching, che poi servono dati errati
    agli utenti o ai sistemi. Per proteggersi da questo attacco, il client e il server
    mascherano i payload per farli apparire come dati casuali prima di inviarli.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.html#id893-marker)) 攻击者可以使用缓存中毒来向缓存系统注入有害数据，然后向用户或系统提供错误数据。为了防止这种攻击，客户端和服务器在发送之前将有效载荷伪装成随机数据。
- en: ^([2](ch06.html#id894-marker)) Questi attacchi consistono nell'ingannare un
    server per far trapelare informazioni sensibili inviando una risposta HTTP a un
    frame WebSocket.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.html#id894-marker)) 这些攻击包括通过向WebSocket帧发送HTTP响应来欺骗服务器泄露敏感信息。
- en: ^([3](ch06.html#id906-marker)) Per maggiori dettagli sull'[interfaccia`EventSource`](https://oreil.ly/0yuKA)
    , consulta le risorse MDN.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch06.html#id906-marker)) 有关`EventSource`接口的更多详细信息，请参阅MDN资源。
- en: ^([4](ch06.html#id909-marker)) Segui la [guida "Accesso ai modelli privati/garantiti"](https://oreil.ly/a7KeV)
    per generare un token di accesso per l'utente di Hugging Face.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch06.html#id909-marker)) 按照指南“访问私有/保证模型”(https://oreil.ly/a7KeV)生成Hugging
    Face用户的访问令牌。
- en: ^([5](ch06.html#id912-marker)) Gli aggressori utilizzano la vulnerabilità XSS
    per inserire script dannosi nelle pagine web, che vengono poi eseguiti dai browser
    degli altri utenti.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch06.html#id912-marker)) 攻击者利用XSS漏洞在网页中插入有害脚本，这些脚本随后由其他用户的浏览器执行。
- en: ^([6](ch06.html#id914-marker)) Il backoff esponenziale riduce le possibilità
    di errori di limitazione del tasso API aumentando il ritardo dopo ogni tentativo.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch06.html#id914-marker)) 指数退避通过在每次尝试后增加延迟来降低API速率限制错误的概率。
