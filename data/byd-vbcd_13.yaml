- en: Chapter 10\. Autonomous Background Coding Agents
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 自主后台编码代理
- en: '*Autonomous background coding agents* are rapidly emerging as the next evolution
    of AI coding tools.  Unlike familiar “copilot” assistants that suggest code while
    you type, these agents operate more like background junior developers you can
    dispatch to handle entire tasks asynchronously. Code is generated in an isolated
    environment spun up for the agent, tests can be run, and the result often comes
    back as a fully formed pull request for you to review.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*自主后台编码代理*正迅速成为AI编码工具的下一阶段进化。与在键入时建议代码的熟悉“领航员”助手不同，这些代理更像是可以异步处理整个任务的背景初级开发者。代码在为代理启动的隔离环境中生成，可以运行测试，结果通常以一个完整的拉取请求的形式返回供你审查。'
- en: In this section, I’ll explore what background coding agents are, how they work,
    the current landscape of tools (OpenAI Codex, Google Jules, Cursor, Devin, and
    more), and how they compare to traditional in-IDE assistants. I’ll also examine
    their capabilities, limitations, and the pragmatic changes they signal for the
    future of software engineering.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将探讨后台编码代理是什么，它们是如何工作的，当前工具的格局（OpenAI Codex、Google Jules、Cursor、Devin等），以及它们与传统IDE助手相比如何。我还会检查它们的性能、局限性和它们对未来软件工程预示的实用变化。
- en: 'From Copilots to Autonomous Agents: What Are Background Coding Agents?'
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从领航员到自主代理：后台编码代理是什么？
- en: Traditional AI coding assistants (like Cursor, GitHub Copilot, or VSCode extensions
    like Cline) are *supervised coding agents*—interactive helpers that respond to
    a developer’s prompts or inline context. They’re essentially autocomplete on steroids,
    generating suggestions in a chat or as you write, but the human developer is in
    the driver’s seat guiding every step.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的AI编码助手（如Cursor、GitHub Copilot或VSCode扩展Cline）是*监督编码代理*——响应开发者提示或内联上下文的交互式助手。它们本质上是在聊天或写作时生成建议的自动完成功能，但人类开发者是每个步骤的驾驶员。
- en: In contrast, autonomous background coding agents operate with much greater independence.
    You give them a high-level task or goal, then “send them off” to work through
    the problem on their own, without constant supervision. These agents will read
    and modify your codebase, formulate a plan, execute code (even running tests or
    commands), and produce a result (often a commit or pull request)—all in an asynchronous
    workflow.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，自主后台编码代理具有更大的独立性。你给他们一个高级任务或目标，然后“派他们去”独立解决问题，而不需要持续的监督。这些代理将阅读和修改你的代码库，制定计划，执行代码（甚至运行测试或命令），并产生结果（通常是提交或拉取请求）——所有这些都在异步工作流程中完成。
- en: 'Think of the difference between a copilot and an autopilot: your copilot (much
    like GitHub Copilot) is always in the cockpit beside you, awaiting your input;
    the autopilot (background agent) can fly the plane on its own for a while. This
    autonomy means that background agents can tackle multistep coding tasks while
    you focus elsewhere. Using async agents like Codex and Jules is like expanding
    your cognitive bandwidth: you can fire off a task to the AI and forget about it
    until it’s done. Instead of a single-threaded back-and-forth with an AI, you suddenly
    have a multithreaded workflow: the agent works in parallel with you, much like
    a competent junior dev working in the background.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下领航员和自动驾驶之间的区别：你的领航员（就像GitHub Copilot一样）始终在你旁边的驾驶舱内，等待你的指令；而自动驾驶（后台代理）可以在一段时间内独立驾驶飞机。这种自主性意味着后台代理可以在你专注于其他事情的同时处理多步骤编码任务。使用像Codex和Jules这样的异步代理就像扩展你的认知带宽：你可以将任务发送给AI，然后直到它完成都可以不去管它。与AI的单线程来回互动相比，你突然拥有了多线程的工作流程：代理与你并行工作，就像一个有能力的初级开发者一样在后台工作。
- en: Crucially, background agents operate in isolated development environments (often
    cloud VMs or containers) rather than directly in your editor. They typically clone
    your repository into a sandbox, install dependencies, and have the tools needed
    to build and test the project. For security, these sandboxes are restricted (with
    rules like “No internet access unless explicitly allowed”) and ephemeral. The
    agent can run compilers, tests, linters, and the like without any risk to your
    local machine. When the task is complete, the agent outputs the code changes (diffs)
    and a summary of what it did. Usually this comes through as a pull request (with
    code diffs, commit message, and sometimes an explanation), which you can then
    review and merge.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的是，后台代理在隔离的开发环境中（通常是云虚拟机或容器）而不是直接在你的编辑器中运行。它们通常将你的仓库克隆到沙盒中，安装依赖项，并拥有构建和测试项目所需的工具。出于安全考虑，这些沙盒受到限制（例如，“除非明确允许，否则不允许互联网访问”）并且是瞬时的。代理可以运行编译器、测试、linters等，而不会对你的本地机器造成任何风险。当任务完成时，代理输出代码更改（差异）和它所做的工作摘要。通常这会以拉取请求的形式出现（包含代码差异、提交信息，有时还有解释），然后你可以审查并合并。
- en: 'To sum up, a background coding agent is an AI-powered autonomous coder that
    understands your intent, works through an entire task in a sandbox environment
    by reading and writing code and testing it, and then delivers the results for
    you to review. It’s not just suggesting a line or two—it can handle larger-scope
    tasks:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，一个后台编码代理是一个由AI驱动的自主编码器，它理解你的意图，通过阅读和编写代码以及测试，在一个沙盒环境中完成整个任务，然后为你提供可审查的结果。它不仅仅是建议一两条代码——它可以处理更大范围的任务：
- en: Write a new feature X across the codebase.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码库中编写新的功能X。
- en: Refactor module Y for efficiency.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对模块Y进行重构以提高效率。
- en: Upgrade this project’s dependencies.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级此项目的依赖项。
- en: This is a significant shift in how we might incorporate AI into development
    workflows, moving from assistive suggestions to delegating *actual implementation
    work*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可能将AI融入开发工作流程的重大转变，从辅助建议转向委托*实际实施工作*。
- en: How Do Autonomous Coding Agents Work?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自主编码代理是如何工作的？
- en: 'Under the hood, most background agents follow a similar pattern of operation:
    *plan, execute, verify,* and *report*. Let’s walk through these steps and their
    capabilities.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，大多数后台代理遵循类似的操作模式：*计划、执行、验证、报告*。让我们来了解一下这些步骤及其功能。
- en: Plan
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计划
- en: 'When you give an agent a task (typically via a prompt or command describing
    what you want), the agent first parses the request and formulates a plan of attack.
    Some agents explicitly show you this plan before proceeding. For example, [Google’s
    Jules](https://oreil.ly/jxDhZ) presents an execution plan that you can review
    and tweak before it starts coding, which “prevents the anxiety of wondering whether
    the agent understood your request correctly.” A good agent will break the task
    into substeps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给代理一个任务（通常是通过一个提示或命令来描述你想要什么），代理首先解析请求并制定攻击计划。一些代理在开始编码之前会明确地展示这个计划。例如，[Google的Jules](https://oreil.ly/jxDhZ)提供了一个执行计划，你可以在它开始编码之前审查和调整，这“防止了担心代理是否正确理解了你的请求”的焦虑。一个好的代理会将任务分解成子步骤：
- en: 'Step 1: search the codebase for relevant sections; Step 2: make changes in
    files A, B, C; Step 3: run tests; Step 4: commit changes.'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第1步：在代码库中搜索相关部分；第2步：在文件A、B、C中进行更改；第3步：运行测试；第4步：提交更改。
- en: 'This planning stage is key to effective autonomy: it’s the AI’s way of reasoning
    about *how* to accomplish your goal before diving in.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规划阶段是有效自主性的关键：这是AI在深入之前思考*如何*实现你的目标的方式。
- en: The agent launches a dedicated development environment for the task. Jules,
    for instance, “clones your codebase into a secure Google Cloud VM” and works asynchronously
    there. OpenAI’s Codex similarly runs each task in its own cloud sandbox, preloaded
    with your repository. Tools like Cursor’s background agents use a remote Ubuntu-based
    machine that has internet access to install packages and can be customized via
    Docker or snapshots. Ensuring the environment has all needed dependencies (like
    the correct language runtimes and build tools) is both critical and nontrivial.
    As I noted in a previous analysis, “Figuring out a smooth experience to spin up
    just the right environment for an agent is key…and the user experience to configure
    it is as frustrating, if not more, than it can be for CI pipelines.” Nonetheless,
    agents are tackling this by allowing configuration files to specify setup steps.
    The goal is to create a *dev environment in the cloud* that mirrors what a human
    developer would need to successfully run the project’s code and tests.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 代理为任务启动了一个专用开发环境。例如，Jules会将你的代码库“克隆到安全的Google Cloud VM”中，并在那里异步工作。OpenAI的Codex同样在每个自己的云沙盒中运行每个任务，预先加载了你的存储库。Cursor等工具的后台代理使用具有互联网访问权限的远程基于Ubuntu的机器来安装包，可以通过Docker或快照进行自定义。确保环境具有所有必需的依赖项（如正确的语言运行时和构建工具）既关键又复杂。正如我在之前的分析中提到的，“为代理启动一个平滑的环境以运行所需的环境是关键……而配置它的用户体验可能和CI管道一样令人沮丧，甚至更糟。”尽管如此，代理通过允许配置文件指定设置步骤来解决这个问题。目标是创建一个*云中的开发环境*，它反映了人类开发者成功运行项目代码和测试所需的一切。
- en: 'Notably, many agents disable internet access to their code after setup, so
    they can sandbox the run without unauthorized data exfiltration or unrestricted
    internet calls. Some allow controlled internet use for specific needs: for example,
    OpenAI recently enabled optional internet access for Codex tasks like fetching
    package updates or documentation.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，许多代理在设置后禁用了其代码的互联网访问，这样他们就可以在不允许数据泄露或不受限制的互联网调用的情况下进行沙盒运行。一些代理允许为特定需求进行受控的互联网使用：例如，OpenAI最近为像获取包更新或文档这样的Codex任务启用了可选的互联网访问。
- en: Execute
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行
- en: 'Next comes the main show: the agent starts writing and modifying code according
    to the plan. Armed with a large language model (or a mix of models) fine-tuned
    for coding, it can read multiple files, generate new code, and even create new
    files if needed. This is where the agent essentially acts like a programmer: locating
    where changes should be made, editing code, and inserting new logic.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是重头戏：代理开始根据计划编写和修改代码。凭借针对编码进行了微调的大型语言模型（或模型混合），它可以读取多个文件，生成新代码，如果需要，甚至可以创建新文件。这就是代理本质上像程序员一样行动的地方：定位应该进行更改的位置，编辑代码，并插入新的逻辑。
- en: One interesting observation from early runs is that agents often use brute-force
    text search (like the Unix `grep` command) to find relevant parts of the codebase.
    For example, an agent might search for a function name or a keyword to figure
    out where in the repository to make changes. This seems surprisingly simplistic—shouldn’t
    they use fancy semantic code search or AST-based analysis? Yet, it’s effective
    and reliable. As [Birgitta Böckeler notes](https://oreil.ly/wDSkr), many coding
    agents default to straightforward full-text search, perhaps finding it the most
    broadly effective method despite more advanced techniques existing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从早期运行中一个有趣的观察是，代理通常使用暴力文本搜索（如Unix `grep`命令）来找到代码库中的相关部分。例如，一个代理可能会搜索函数名或关键字，以确定在存储库中的哪个位置进行更改。这似乎非常简单——他们不应该使用复杂的语义代码搜索或基于AST的分析吗？然而，它既有效又可靠。正如[Birgitta
    Böckeler指出](https://oreil.ly/wDSkr)，许多编码代理默认使用简单的全文搜索，可能发现这是最广泛有效的方法，尽管存在更先进的技术。
- en: As the agent edits code, some systems provide real-time logs or status updates
    so you can follow along if you want. OpenAI Codex exposes a log of the agent’s
    “thoughts” and commands (summarized) as it works through a task. Cursor allows
    you to “view their status and enter the machine the agent is running in” to observe
    or even intervene midtask. In practice, though, the idea is you don’t need to
    babysit—you can let the agent run on autopilot.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当代理编辑代码时，一些系统提供实时日志或状态更新，以便如果你想的话可以跟踪。OpenAI Codex在处理任务时暴露了代理的“思考”和命令（总结）日志。Cursor允许你“查看其状态并进入代理正在运行的机器”以观察或甚至在任务中途干预。然而，在实践中，这个想法是你不需要照看——你可以让代理自动运行。
- en: Verify
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证
- en: 'A defining capability of these agents is that they don’t stop at writing code—they
    often compile the code and *run tests to verify* their changes. For instance,
    OpenAI’s Codex is designed to iteratively run tests until it receives a passing
    result. If an agent can run the project’s test suite (or at least a relevant subset
    of tests), it can catch mistakes and automatically correct them in subsequent
    iterations. This is huge: it moves the AI from just *generating* code to also
    *debugging* and *validating* its code.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代理的一个定义性能力是它们不仅仅编写代码——它们经常编译代码并*运行测试以验证*它们的更改。例如，OpenAI的Codex被设计成迭代运行测试，直到收到通过的结果。如果一个代理能够运行项目的测试套件（或者至少是相关测试的子集），它就可以捕捉错误并在后续迭代中自动纠正它们。这是巨大的进步：它将AI从仅仅*生成*代码转变为同时*调试*和*验证*其代码。
- en: In theory, an agent with a robust test harness can attempt a fix, see a test
    fail, adjust the code, and loop until tests pass—without a human in the loop.
    In practice, environment issues sometimes thwart this. In one case I studied,
    Codex wasn’t able to run the full test suite due to environment mismatches (certain
    tools were missing), resulting in a pull request that still had two failing tests.
    Had the environment been fully aligned, the agent could have fixed those trivial
    issues before making the PR.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，一个具有强大测试框架的代理可以尝试修复问题，看到测试失败，调整代码，并循环直到测试通过——无需人类介入。实际上，环境问题有时会阻碍这一点。在我研究的一个案例中，由于环境不匹配（某些工具缺失），Codex无法运行完整的测试套件，导致PR中仍有两个失败的测试。如果环境完全一致，代理可以在创建PR之前修复这些微不足道的问题。
- en: 'This underscores why environment setup is so important for autonomous agents:
    if they can run everything a developer would (linters, tests, builds), they can
    self-correct many errors automatically. Agents like Devin emphasize this loop—Devin
    “writes code, finds bugs in the code, corrects the code, and runs its own end-to-end
    tests to verify it works” as a normal part of its operation. In fact, Devin will
    even spin up a live preview deployment of a frontend app it built so you can manually
    verify a feature in the browser, which is a clever extension of the verification
    step.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这强调了为什么环境设置对自主代理如此重要：如果它们能够运行开发者会运行的所有内容（linters、测试、构建），它们就可以自动纠正许多错误。像Devin这样的代理强调这个循环——Devin“编写代码，在代码中找到错误，纠正代码，并运行其自身的端到端测试以验证其工作”，这是其正常操作的一部分。事实上，Devin甚至可以启动它构建的前端应用的实时预览部署，这样你就可以在浏览器中手动验证一个功能，这是验证步骤的巧妙扩展。
- en: Report
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 报告
- en: Once the agent has a candidate solution (all tests have passed, or it deems
    the code ready), it prepares the results for you. Depending on the platform, this
    might come as a PR on GitHub, a diff and explanation in chat, or files ready to
    merge.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代理有一个候选解决方案（所有测试都通过，或者它认为代码已准备好），它就会为你准备结果。根据平台的不同，这可能是一个GitHub上的PR，聊天中的差异和解释，或者准备好合并的文件。
- en: 'At this point, you—the human—do a review. Here we come back to “Trust but verify”:
    you trust the agent to produce something useful, but you verify the changes through
    code review and additional testing. Many agent systems explicitly integrate with
    the PR review process because it’s a familiar workflow for developers. Jules,
    for example, plugs into your GitHub and will open a branch and PR with its changes.
    OpenAI’s Codex presents the diff inside ChatGPT for you to approve or ask follow-up
    questions. If you find issues or have change requests, you can often feed that
    back to the agent for another iteration.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你——人类——进行审查。这里我们回到了“信任但核实”：你信任代理生成有用的东西，但通过代码审查和额外的测试来核实这些变化。许多代理系统明确地与PR审查流程集成，因为这对开发者来说是一个熟悉的流程。例如，Jules可以连接到你的GitHub，并为其更改打开一个分支和PR。OpenAI的Codex在ChatGPT内展示差异和解释，供你批准或提出后续问题。如果你发现问题或有更改请求，你通常可以将这些反馈给代理进行另一轮迭代。
- en: 'Some agents handle this via chat (Devin can take feedback from a linked Slack
    thread: if you point out a problem or ask for tweaks, it will “start working on
    a reply” to address it). Others might require a new run with an adjusted prompt
    or use a review comment interface. Impressively, Devin even responded to a GitHub
    PR comment asking *why* it made certain changes—it reacted with an “eyes” emoji
    to signal it saw the comment, then posted a detailed explanation of its reasoning.
    (The explanation turned out to be not entirely correct in that case, but the fact
    that it can discuss PRs says something about how interactive these agents can
    become.)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代理通过聊天处理这个问题（Devin 可以从链接的 Slack 线路中获取反馈：如果你指出问题或请求调整，它将“开始回复”以解决问题）。其他代理可能需要一个新的运行，使用调整后的提示或使用审查评论界面。令人印象深刻的是，Devin
    甚至对 GitHub PR 评论中询问**为什么**它做出了某些更改做出了回应——它用一个“眼睛”表情符号来表示它看到了评论，然后发布了一个详细的解释来说明其推理。（在这种情况下，解释并不完全正确，但它能够讨论
    PR 的事实表明这些代理可以变得多么交互式。）
- en: If all looks good, you merge the agent’s PR or integrate the changes. If not,
    you might discard it or have the agent try again. One pragmatic question teams
    face is what to do if an agent’s output is *almost* good but not quite. Do you
    spend time fixing up the last 10%–20% of an agent-generated patch, even if it
    was a low-priority task you offloaded to the AI? This is what I call the “sunk
    cost” dilemma for AI contributions. [Birgitta Böckeler](https://oreil.ly/IdJ9d)
    muses that if an agent PR only partly succeeds, teams will have to decide “in
    which situations would [they] discard the pull request, and in which situations
    would they invest the time to get it the last 20% there” for a task that originally
    wasn’t worth much dev time. There’s no one answer—it depends on the context and
    value of the change—but it’s a new kind of trade-off introduced by autonomous
    agents.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切看起来都很好，你可以合并代理的 PR 或集成更改。如果不满意，你可能丢弃它或让代理再次尝试。团队面临的一个实用问题是，如果代理的输出**几乎**是好的但并不完全如此，该怎么办。你会花时间修复代理生成的补丁的最后
    10%–20%，即使它是一个你分配给 AI 的低优先级任务吗？这就是我所说的 AI 贡献的“沉没成本”困境。[Birgitta Böckeler](https://oreil.ly/IdJ9d)
    思考，如果一个代理 PR 只部分成功，团队将不得不决定“在哪些情况下他们会丢弃拉取请求，在哪些情况下他们会投入时间将其完成最后的 20%”对于原本不值得太多开发时间的任务。没有统一的答案——这取决于上下文和更改的价值——但这是由自主代理引入的一种新的权衡。
- en: 'In summary, background coding agents handle the end-to-end cycle of coding
    tasks: *understand → plan → code → test → deliver*. They essentially simulate
    what a diligent, methodical developer might do when assigned a task, albeit within
    the current limits of AI (see [Figure 10-1](#ch10_figure_1_1752630045078635)).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，背景编码代理处理编码任务的端到端周期：**理解 → 规划 → 编码 → 测试 → 交付**。它们本质上模拟了一个勤奋、有条理的开发者在被分配任务时可能做的事情，尽管是在当前人工智能的限制范围内（见[图
    10-1](#ch10_figure_1_1752630045078635)）。
- en: '![](assets/bevc_1001.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bevc_1001.png)'
- en: 'Figure 10-1\. Autonomous AI agent workflow: self-directed agents plan tasks,
    execute solutions, verify results, and report outcomes with minimal human intervention.'
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-1\. 自主人工智能代理工作流程：自我指导的代理规划任务、执行解决方案、验证结果，并在最小化人工干预的情况下报告结果。
- en: How Do Background Agents Compare to In-IDE AI Assistants?
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景代理与 IDE 内部人工智能助手相比如何？
- en: It’s worth drawing a clear line between the coding AI tools we’ve had for a
    couple years (GitHub Copilot, ChatGPT coding mode, etc.) and this new generation
    of autonomous agents. Both are useful, but they play different roles and have
    different strengths/weaknesses.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 值得明确区分我们拥有了几年的编码人工智能工具（如 GitHub Copilot、ChatGPT 编码模式等）和这一代新的自主代理。两者都很有用，但它们扮演不同的角色，具有不同的优势和劣势。
- en: The most obvious difference is their *level of autonomy*. In-IDE assistants
    like Copilot or VSCode’s AI extensions work *synchronously* with you—they generate
    suggestions or answer questions when invoked, and their scope is usually limited
    to the immediate context (like the file or function you’re editing or a specific
    prompt you gave). *You* decide when to accept a suggestion, ask for another, or
    apply a change.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的区别是它们的**自主程度**。像 Copilot 或 VSCode 的 AI 扩展这样的 IDE 内部助手与你**同步**工作——当你调用它们时，它们会生成建议或回答问题，它们的范围通常限于当前上下文（如你正在编辑的文件或函数，或你给出的特定提示）。**你**决定何时接受建议、请求另一个或应用更改。
- en: With background agents, once you hit “go” on a task, the agent will autonomously
    perform potentially hundreds of actions (file edits, runs, searches) without further
    confirmation. It’s operating *asynchronously*. This requires a higher degree of
    trust (you’re letting it change things on its own) but also frees you from micromanaging.
    I often describe it as the difference between having an AI *pair programmer* versus
    an AI *assistant developer* on the team. The pair programmer (Copilot) is with
    you keystroke by keystroke; the assistant dev (Codex/Jules/etc.) works in parallel
    on another issue.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台代理中，一旦你启动了一个任务，代理将自主执行可能数百个动作（文件编辑、运行、搜索）而无需进一步确认。它正在*异步*操作。这需要更高的信任度（你让它自主更改东西），但同时也让你免于微观管理。我经常将其描述为拥有一个AI
    *配对程序员*与一个AI *助理开发者*在团队中的区别。配对程序员（Copilot）与你一起逐个按键；助理开发者（Codex/Jules等）在另一个问题上并行工作。
- en: The copilot style of AI tools means they excel at microtasks—writing a function,
    completing a line, generating a small snippet, answering a question about how
    to use an API. They don’t maintain a long narrative or project-wide understanding,
    beyond what’s in your editor’s open files or a limited window.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: AI工具的副驾驶风格意味着它们擅长微任务——编写一个函数、完成一行、生成一小段代码、回答有关如何使用API的问题。它们不会维护长篇叙事或项目级理解，除非是在你的编辑器中打开的文件或有限的窗口内。
- en: Autonomous agents operate at the *project level*. They load your entire repository
    (or at least index it) and can make coordinated changes across multiple modules.
    They keep track of a multistep plan. For example, GitHub Copilot might help you
    write a unit test if you prompt it, but a background agent could, on its own,
    decide to add the corresponding implementation in one file, the test in another,
    and a modified a config in a third—all as part of one unified task. This makes
    agents far better suited for things like refactoring a cross-cutting concern (logging,
    error handling), performing upgrades (which often involve many files), or implementing
    a feature that touches backend and frontend. IDE assistants couldn’t easily handle
    those because they lack long-term task memory and whole-repo visibility.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 自主代理在*项目级别*上操作。它们加载你的整个仓库（或至少索引它），并可以在多个模块之间进行协调更改。它们跟踪多步骤计划。例如，GitHub Copilot可能会在你提示的情况下帮助你编写单元测试，但后台代理可以独立决定在一个文件中添加相应的实现，在另一个文件中添加测试，在第三个文件中修改配置——所有这些都是作为一个统一任务的一部分。这使得代理非常适合像重构跨切面关注点（日志记录、错误处理）、执行升级（通常涉及许多文件）或实现影响后端和前端的特性等任务。IDE助手难以处理这些任务，因为它们缺乏长期任务记忆和整个仓库的可见性。
- en: 'Copilot-style assistants are *reactive*—they respond to your code or queries.
    They don’t initiate actions. Background agents are *proactive* in the sense that
    once activated, they will take initiative to reach the goal. A Jules or Devin
    agent might decide, “I need to create a new file here” or “Let me run the tests
    now,” without being explicitly told at each step. They also can *notify you of
    things proactively*, like:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot风格的助手是*反应性*的——它们对你的代码或查询做出响应。它们不会主动采取行动。后台代理是*主动性*的，一旦激活，它们将主动采取行动以达到目标。Jules或Devin代理可能会决定，“我需要在这里创建一个新文件”或“让我现在运行测试”，而不需要在每个步骤都明确告知。它们还可以*主动通知你一些事情*，比如：
- en: I found another place to apply this change, so I’ll include that too.
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我发现另一个地方可以应用这个更改，所以我也会包括它。
- en: They behave more like an employee, who might say, “I noticed X while I was in
    the code, so I fixed that as well.” That said, autonomy also means they might
    do something you didn’t expect or necessarily want. The supervised nature of this
    style of tool means it will only do exactly what you accept (except maybe for
    subtle missuggestions you didn’t notice). So with great power (proactivity) comes
    the need for greater oversight.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的行为更像是一名员工，可能会说：“我在代码中注意到X，所以我也把它修复了。”尽管如此，自主性也意味着它们可能会做你预料不到或不一定想要的事情。这种工具风格的监督性质意味着它只会做你接受的事情（也许除了你没有注意到的细微建议）。因此，强大的力量（主动性）需要更大的监管。
- en: A major difference is that background agents can *execute code and commands*,
    whereas traditional IDE assistants usually cannot (unless you count things like
    ChatGPT’s Code Interpreter mode, but that’s more for data analysis, not integrated
    with your project’s build).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个主要区别是，后台代理可以*执行代码和命令*，而传统的IDE助手通常不能（除非你把ChatGPT的代码解释器模式算在内，但那更多是用于数据分析，而不是与你的项目构建集成）。
- en: Agents will run your test suite, start your dev server, compile the app, maybe
    even deploy it. They operate in a sandbox, but it’s effectively like having an
    automated developer who can use the terminal. This is a game changer—it closes
    the loop of verify/fix. An IDE helper might generate code that looks plausible,
    but if it didn’t actually run it, there could be runtime issues or failing tests.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 代理将运行您的测试套件，启动开发服务器，编译应用程序，甚至可能部署它。它们在沙盒中运行，但实质上就像有一个能够使用终端的自动化开发者。这是一个颠覆性的变化——它关闭了验证/修复的循环。IDE助手可能会生成看似合理的代码，但如果它没有实际运行，可能会出现运行时问题或失败的测试。
- en: With an agent that runs the code, you have a higher chance the output is actually
    functional. It also offloads the debugging step; if something fails, the agent
    can try to fix it immediately. The flip side is this requires the agent’s environment
    to be correct (as discussed earlier), and it opens the door to potential side
    effects. Imagine an agent running a database migration or modifying data—usually
    they’re in sandbox mode, so this doesn’t affect production, but be careful.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用运行代码的代理，您更有可能得到真正功能性的输出。它还卸载了调试步骤；如果出现问题，代理可以立即尝试修复。另一方面，这要求代理的环境必须正确（如前所述），并且可能带来潜在的副作用。想象一下，一个代理正在运行数据库迁移或修改数据——通常它们处于沙盒模式，所以这不会影响生产环境，但请小心。
- en: 'GitHub Copilot and tools like it live in the editor, which is great for in-the-flow
    coding. Agents often integrate with project management and DevOps tools, too.
    For example, you might create a GitHub issue and have an agent pick it up and
    generate a PR, or trigger an agent run from a CI pipeline for certain tasks (like
    autofixing lint errors on PRs). In fact, CodeGen advertises its agents’ ability
    to attach to issue trackers so that when an issue moves to “In Progress,” the
    AI agent works on it. This kind of integration is beyond what IDE tools do. It
    hints that AI agents could become part of the CI/CD loop—for instance, automatically
    attempting to fix build failures or automatically creating follow-up PRs for minor
    issues. That’s a different mode of collaboration: not just helping a dev write
    code but acting as a bot user in the team’s toolchain.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Copilot和类似工具位于编辑器中，这对于流程中的编码来说很棒。代理通常也与项目管理工具和DevOps工具集成。例如，您可能创建一个GitHub问题，让代理接管并生成一个PR，或者从CI管道触发代理运行某些任务（如自动修复PR上的lint错误）。实际上，CodeGen宣传其代理能够附加到问题跟踪器，以便当问题移动到“进行中”时，AI代理开始处理它。这种集成超出了IDE工具的范围。这暗示AI代理可能成为CI/CD循环的一部分——例如，自动尝试修复构建失败或自动为小问题创建后续PR。这是一种不同的协作模式：不仅帮助开发者编写代码，还作为团队工具链中的机器人用户。
- en: 'Using copilot-type assistants often still feels like programming, just faster—you
    type, they suggest, you accept, you test. Using a background agent feels more
    like delegation followed by review. The human effort shifts from writing code
    to writing a good task description and then reviewing the code produced. I call
    this *“*generator versus reviewer asymmetry”—generating a solution (or code) from
    scratch is hard, but reviewing and refining it is easier. Async agents capitalize
    on this: they handle the bulk generation, leaving you with the (typically faster)
    job of vetting and tweaking. This can be a productivity boon, but it also means
    as an engineer you need to sharpen your code review and verification skills.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似Copilot的助手通常仍然感觉像是在编程，只是更快——你输入，它们建议，你接受，你测试。使用后台代理感觉更像是一种委托后的审查。人力从编写代码转移到编写良好的任务描述，然后审查生成的代码。我称之为“生成者与审查者不对称”——从头开始生成解决方案（或代码）很困难，但审查和改进它更容易。异步代理利用这一点：它们处理大量生成，而您则负责（通常是更快地）审查和调整。这可能是一种生产力上的恩赐，但也意味着作为工程师，您需要提高您的代码审查和验证技能。
- en: 'Code review has always been important, but now it’s not just for other human
    colleagues’ code—it’s for AI-generated code as well, which might have different
    patterns of mistakes. My mantra is that you should treat agent-produced code as
    if it were written by a slightly overeager junior developer: assume good intentions
    and decent competence, but verify everything and don’t hesitate to request changes
    or reject if it’s not up to standards.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查始终很重要，但现在它不仅是为了其他人类同事的代码，也是为了AI生成的代码，这些代码可能存在不同的错误模式。我的座右铭是，您应该将代理生成的代码视为由一个略微过于热情的初级开发者编写的：假设有良好的意图和一定的能力，但验证一切，并且不要犹豫要求更改或拒绝不符合标准的情况。
- en: 'In practice, I find that I use copilot-style tools and background agents *together*.
    For instance, I might use Copilot or Cursor’s inline suggestions while I’m actively
    coding a complex piece of logic, because I want tight control over that logic.
    Meanwhile, I might delegate a peripheral but time-consuming task (like updating
    all our API client libraries for new endpoints) to a background agent to handle
    in parallel. They fill different niches. One doesn’t necessarily replace the other.
    In fact, I foresee IDEs offering a unified experience: a palette of options from
    “Complete this line” to “Generate a function” to “Hey, AI, please implement this
    entire ticket for me.” You’d choose the tool depending on the scope.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我发现我通常会将类似Copilot风格的工具和后台代理**一起**使用。例如，在我积极编码一个复杂的逻辑片段时，我可能会使用Copilot或Cursor的行内建议，因为我希望对这个逻辑有紧密的控制。同时，我可能会将一个边缘但耗时的工作（比如更新所有我们的API客户端库以支持新的端点）委托给后台代理并行处理。它们填补了不同的细分市场。一个不一定取代另一个。事实上，我预见IDE将提供统一的经验：从“完成此行”到“生成函数”再到“嘿，AI，请为我实现整个工单。”你可以根据范围选择工具。
- en: Combining Multiple AI Models to Maximize Strengths
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合多个AI模型以最大化优势
- en: So far, I’ve often referred to “the AI” as if it’s one monolithic assistant.
    In reality, there are many AI models, each with different strengths. Some are
    great at natural language understanding, others excel at generating code, and
    some might be specialized in certain domains (like a math problem solver or a
    UI generator). An advanced practitioner of vibe coding can orchestrate multiple
    AIs together, using each for what it’s best at. This is like having a team of
    specialists rather than a single generalist.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我经常将“AI”作为一个单一的、统一的助手来提及。实际上，有许多AI模型，每个都有不同的优势。有些在自然语言理解方面很出色，有些在生成代码方面表现出色，而有些可能专注于特定领域（如数学问题求解器或UI生成器）。高级的Vibe编码实践者可以一起协调多个AI，利用每个AI最擅长的地方。这就像拥有一支专家团队而不是一个单一的全能者。
- en: 'Consider a future workflow where you have:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个未来的工作流程，其中你将拥有：
- en: A CodeGen AI highly trained on programming that can produce code and fix code
    efficiently
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个高度训练于编程的CodeGen AI，能够高效地生成和修复代码
- en: A TestGen AI, specialized in generating test cases and finding edge cases
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个专注于生成测试用例和发现边缘情况的TestGen AI
- en: A Doc AI that writes clear documentation and explanations
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个编写清晰文档和解释的Doc AI
- en: A Design AI that’s skilled at generating UI layouts or graphics
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个擅长生成UI布局或图形的Design AI
- en: An Optimization AI focused on performance tuning and perhaps even aware of low-level
    details
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个专注于性能调优甚至可能了解底层细节的优化AI
- en: You can pipe your task through several of these AIs. For example, you ask CodeGen
    AI to write an implementation. Immediately, you feed that output to TestGen AI
    to generate tests for it (or to critique it). Then feed both code and tests to
    Doc AI to produce documentation or a usage guide. If the code involves user interface,
    maybe Design AI is used earlier to propose the layout structure that CodeGen AI
    then implements. By chaining them, you leverage each model’s domain expertise.
    This is analogous to a software pipeline or assembly line, but instead of different
    human roles, it’s different AI roles.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任务通过这些AI中的几个。例如，你可以要求CodeGen AI编写实现代码。立即，你将输出结果提供给TestGen AI以生成测试（或对其提出批评）。然后将代码和测试提供给Doc
    AI以生成文档或使用指南。如果代码涉及用户界面，也许Design AI会先提出布局结构，然后由CodeGen AI实现。通过串联它们，你可以利用每个模型的领域专业知识。这类似于软件流水线或装配线，但不同的是，这里不是不同的人类角色，而是不同的AI角色。
- en: Even among similar models, combining them can improve reliability. If you have
    two code-generation models from different providers or of different architectures,
    you can have them both attempt the solution and then compare or test both outputs.
    If one model’s output passes all tests and the other doesn’t, you pick the passing
    one. If both pass but have different approaches, you might manually choose the
    more readable one. If one fails, you can even show the failing one the successful
    code as a hint to learn from. This kind of AI cross-talk can reduce errors since
    it’s less likely that two different models will make the exact same mistake. It’s
    like getting a second opinion. You can already find research and tools that use
    one AI to check another’s reasoning⁠—for instance, one generates an answer and
    another judges it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在类似模型之间，结合它们可以提高可靠性。如果你有两个来自不同提供商或不同架构的代码生成模型，你可以让它们都尝试解决方案，然后比较或测试两个输出。如果一个模型的输出通过了所有测试，而另一个没有，你选择通过的那个。如果两个都通过了，但方法不同，你可能手动选择更易读的那个。如果一个失败了，你甚至可以向失败的模型展示成功的代码作为学习的提示。这种AI交叉对话可以减少错误，因为两个不同的模型犯完全相同的错误的可能性较小。这就像得到第二个意见。你现在已经可以找到使用一个AI检查另一个推理的研究和工具——例如，一个生成答案，另一个对其进行评判。
- en: Differentiate Models by Task Type
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根据任务类型区分模型
- en: 'Use the right tool for the job. Large language models (LLMs) are good generalists,
    but sometimes smaller, specialized models or tools do better. For example, for
    arithmetic or certain algorithms, a deterministic tool (or an AI that’s more constrained)
    might be better. Some advanced dev setups use symbolic solvers or older rule-based
    AI for specific subtasks and LLMs for others. As an advanced vibe coder, you might
    maintain a toolbox: when you need regex, you call a regex-specific generator;
    when you need a commit message, maybe a model fine-tuned for summarization is
    used. The beauty is these can be integrated via simple scripts or prompt wrappers.
    For instance, you could have a local script like `ai_regex_generator` that internally
    prompts an AI but with some pre- and postprocessing to ensure the output is a
    valid regex, and maybe tests it on provided examples.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适合的工具。大型语言模型（LLMs）是好的通用主义者，但有时较小的、专业的模型或工具表现更好。例如，对于算术或某些算法，一个确定性工具（或更受约束的AI）可能更好。一些高级开发设置使用符号求解器或较老的基于规则的AI来完成特定子任务，而使用LLMs来完成其他任务。作为一个高级的vibe程序员，你可能会维护一个工具箱：当你需要正则表达式时，你调用一个正则表达式特定的生成器；当你需要提交信息时，可能使用一个针对摘要微调的模型。美的是这些可以通过简单的脚本或提示包装器进行集成。例如，你可以有一个本地的脚本`ai_regex_generator`，它内部提示AI，但有一些预处理和后处理以确保输出是有效的正则表达式，并且可能在提供的示例上对其进行测试。
- en: Use an Orchestration System
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用编排系统
- en: 'If you find yourself frequently combining models, you might use or build an
    orchestration system, an emerging category of frameworks often referred to as
    *AI orchestration* or *agents*. These systems allow you to define a flow; for
    example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己经常结合模型，你可能需要使用或构建一个编排系统，这是一个被称为*AI编排*或*代理*的新兴框架类别。这些系统允许你定义一个流程；例如：
- en: 'Step 1: Use Model A to interpret user request.'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第1步：使用模型A来解释用户请求。
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Step 2: If request is about data analysis, use Model B to generate SQL; if
    about text, use Model C…'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第2步：如果请求是关于数据分析，使用模型B生成SQL；如果是关于文本，使用模型C...
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Step 3: Feed the result to Model D to explain it.'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第3步：将结果输入模型D进行解释。
- en: This is more relevant if you’re building an app or service powered by multiple
    AI steps. But even in personal dev, you can script a multistep approach. For example,
    one custom CLI tool, `ai_dev_assist`, takes a prompt and behind the scenes uses
    an AI to classify the prompt into categories like `code`, `design`, `test`, and
    `optimize`. Based on the category, it forwards the prompt to the appropriate specialist
    AI. When it receives the result, it can optionally pipe the result into another
    AI for review or improvement.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建由多个AI步骤驱动的应用程序或服务，这会更相关。但即使在个人开发中，你也可以编写一个多步骤的方法。例如，一个定制的CLI工具`ai_dev_assist`接受一个提示，并在幕后使用AI将提示分类到`代码`、`设计`、`测试`和`优化`等类别。根据类别，它将提示转发到适当的专家AI。当它收到结果时，它可以选择将结果管道输入另一个AI进行审查或改进。
- en: This kind of meta-AI coordinating other AIs sounds complex, but an advanced
    user can set it up with current technology. It will likely get easier as we begin
    to see dedicated support in IDEs or cloud platforms.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种协调其他AI的元-AI听起来很复杂，但高级用户可以利用现有技术来设置它。随着我们开始看到IDE或云平台上的专用支持，它可能会变得更简单。
- en: Human-AI Hybrid Teams
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人类-人工智能混合团队
- en: While on the subject of multiple intelligences, let’s not forget *human* collaborators.
    An advanced vibe coder also knows when to involve fellow human developers in the
    loop. For example, you might use AI to generate two or three different design
    prototypes for a feature, then bring those to your team’s UX designer for feedback.
    Which one aligns with our brand? Which feels intuitive? If an AI writes a complex
    piece of code, you might do a code review session with a colleague focusing on
    that piece, acknowledging that “an AI helped write this, so I want another pair
    of human eyes on it too.” In a sense, the “multiple model” approach can include
    humans as just highly advanced models—each entity (human or AI) has unique strengths.
    The future of development might often be human + AI pair programming or even team
    programming where some “team members” are AI.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论多种智能的同时，我们不要忘记*人类*协作者。一个高级的vibe编码者也知道何时将其他人类开发者纳入循环。例如，你可能会使用AI生成两个或三个不同的设计原型，然后将其带给你的团队的用户体验设计师进行反馈。哪一个与我们的品牌相符？哪一个感觉直观？如果一个AI编写了一块复杂的代码，你可能会与同事进行代码审查会议，专注于这一部分，承认“AI帮助编写了这个，所以我想要另一双人类的眼睛来看它。”在某种程度上，“多模型”方法可以包括人类作为高度先进模型——每个实体（人类或AI）都有独特的优势。开发的未来可能经常是人与AI的配对编程，甚至是团队编程，其中一些“团队成员”是AI。
- en: 'Imagine building a small web application through vibe coding. Your workflow
    might look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下通过vibe编码构建一个小型Web应用程序。你的工作流程可能看起来像这样：
- en: You use a UI Layout AI to generate the HTML/CSS for your page given a description
    (specialized in frontend).
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用UI布局AI根据描述生成你页面的HTML/CSS（专注于前端）。
- en: You use a Content AI to generate some placeholder text or images needed (like
    marketing text, maybe using a model geared for copywriting).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用内容AI生成所需的占位文本或图像（例如营销文本，可能使用针对文案写作的模型）。
- en: You then use your main Code AI to generate the interactive functionality in
    JavaScript, feeding it the HTML so it knows which element IDs to hook into.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你使用主要的代码AI在JavaScript中生成交互功能，给它HTML，这样它就知道要连接到哪些元素ID。
- en: You then ask a Testing AI to generate Selenium or Playwright tests for the interface
    interactions.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你要求一个测试AI为界面交互生成Selenium或Playwright测试。
- en: Finally, you use a Security AI to scan the code for common vulnerabilities.
    This could be a model or simply a static-analysis tool augmented with AI.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你使用安全AI扫描代码中的常见漏洞。这可能是一个模型，或者是一个简单的静态分析工具，它通过AI增强。
- en: This multimodel approach covers frontend, backend (if there is one), content,
    testing, and security in one integrated process. Each AI handled its portion and
    you, as the orchestrator, ensured they all align.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种多模型方法涵盖了一个集成流程中的前端、后端（如果有的话）、内容、测试和安全。每个AI处理其部分，而你作为协调者，确保它们都保持一致。
- en: 'While today you might have to manually copy outputs from one tool to another
    or use some glue scripts, tomorrow’s IDEs might let you configure this pipeline
    so it feels seamless. The key takeaway is: *don’t rely on just one AI model if
    you have access to several*. Use the best one for each job and make them work
    together. It leads to better outcomes and also reduces single-point failure—if
    one model isn’t good at something, another might cover that weakness.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然今天你可能需要手动将一个工具的输出复制到另一个工具，或者使用一些粘合脚本，但明天的集成开发环境（IDE）可能会让你配置这个管道，使其感觉无缝。关键点是：*如果你可以访问多个AI模型，不要只依赖一个AI模型*。为每个任务使用最好的模型，并使它们协同工作。这会导致更好的结果，同时也减少了单点故障——如果一个模型在某方面做得不好，另一个模型可能会弥补这个弱点。
- en: Combining AI models is an advanced move, but it’s a logical extension of specialization,
    a principle well known in software engineering (think microservices, each service
    doing one thing well). Here, each AI service does one thing well. As a vibe coder,
    your role expands to AI conductor, not just AI prompter. It requires a bit more
    setup and thought, but the payoff is a symphony of AI collaborators each contributing
    to a high-quality end product.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 结合AI模型是一个高级动作，但它是对专业化的逻辑扩展，这是软件工程中众所周知的原则（想想微服务，每个服务都擅长做一件事）。在这里，每个AI服务都擅长做一件事。作为一个vibe编码者，你的角色扩展到AI指挥家，而不仅仅是AI提示者。这需要更多的设置和思考，但回报是AI协作者的交响乐，每个协作者都对高质量的产品做出了贡献。
- en: Now that you know how they work, let’s meet some of the leading examples and
    see how they stack up.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了它们是如何工作的，让我们来认识一些领先的例子，看看它们是如何排列的。
- en: Major Players in Autonomous Coding Agents
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化编码代理的主要参与者
- en: As I write this in 2025, the autonomous coding agent landscape has rapidly evolved
    over the past year, with distinct approaches emerging across different platforms.
    These tools represent a shift from passively completing code to acting as active
    development partners that can execute complex tasks independently.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在2025年写下这些内容时，自主编码代理领域在过去一年中迅速发展，不同平台出现了不同的方法。这些工具代表了从被动完成代码到作为主动开发伙伴的转变，这些伙伴可以独立执行复杂任务。
- en: 'Cloud-based command-line agents: OpenAI Codex'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 云命令行代理：OpenAI Codex
- en: '[OpenAI’s Codex](https://oreil.ly/Ml-NU) exemplifies the cloud-based agent
    approach, operating through ChatGPT’s interface or an open source CLI. It spins
    up isolated sandboxes to execute coding tasks in parallel, handling everything
    from React upgrades to unit test creation. What distinguishes Codex is its reinforcement-learning
    training on real coding tasks, enabling it to follow best practices, like running
    tests iteratively until they pass. While results can vary between runs, Codex
    typically converges on working solutions for well-bounded tasks. Its strength
    lies in actual code execution within CI-like environments, representing the first
    wave of agents that truly “pair” with development pipelines.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[OpenAI的Codex](https://oreil.ly/Ml-NU)是云代理方法的典范，通过ChatGPT的界面或开源CLI操作。它启动隔离的沙盒以并行执行编码任务，处理从React升级到单元测试创建的一切。Codex的独特之处在于其在真实编码任务上的强化学习训练，使其能够遵循最佳实践，如迭代运行测试直到通过。虽然运行结果可能会有所不同，但Codex通常会在有良好界限的任务上收敛到有效解决方案。它的优势在于在类似CI的环境中进行实际代码执行，代表了真正与开发管道“配对”的第一波代理。'
- en: 'Workflow-integrated agents: Google Jules'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程集成代理：Google Jules
- en: '[Google Jules](https://jules.google) takes a different approach by deeply integrating
    with GitHub workflows. Running on Google Cloud VMs with full repository clones,
    Jules emphasizes visible, structured planning—presenting its reasoning and allowing
    plan modifications before execution. This “plan, then execute” philosophy, combined
    with real-time feedback capabilities, positions Jules as a supervised assistant
    rather than a black-box automation. Its GitHub-native design means it operates
    directly where teams work, creating branches and PRs without context switching.
    The agent even experiments with novel features like audio changelogs, pointing
    toward more accessible code review processes.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[Google Jules](https://jules.google)通过深度集成GitHub工作流程采取了不同的方法。在Google Cloud
    VM上运行，具有完整的仓库克隆，Jules强调可见的、结构化的规划——在执行前展示其推理并允许修改计划。这种“先计划后执行”的哲学，结合实时反馈能力，将Jules定位为监督助手而不是黑盒自动化。其GitHub原生设计意味着它直接在团队工作的地方运行，创建分支和PR而无需切换上下文。代理甚至尝试了新颖的功能，如音频变更日志，指向更易于访问的代码审查流程。'
- en: 'IDE-integrated agents: Cursor'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: IDE集成代理：Cursor
- en: '[Cursor’s background agents](https://oreil.ly/V-Pci) represent the IDE-centric
    approach, launched directly from the editor but executing on remote machines.
    This hybrid model lets developers orchestrate multiple AI workers from their command
    center while maintaining local control. Cursor provisions Ubuntu instances with
    customizable environments (via *environment.json* or Dockerfiles), giving agents
    full internet access and package installation capabilities. The key innovation
    is seamless IDE integration: developers can monitor agent progress, intervene
    when needed, and immediately access changes locally when complete. This approach
    blurs the line between local AI assistance and cloud execution power.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[Cursor的背景代理](https://oreil.ly/V-Pci)代表了以IDE为中心的方法，直接从编辑器启动但在远程机器上执行。这种混合模型允许开发者从他们的指挥中心编排多个AI工作者，同时保持本地控制。Cursor为Ubuntu实例提供可定制的环境（通过*environment.json*或Dockerfiles），为代理提供完整的互联网访问和包安装能力。关键创新是无缝的IDE集成：开发者可以监控代理进度，在需要时进行干预，并在完成后立即访问本地更改。这种方法模糊了本地AI辅助和云执行能力之间的界限。'
- en: 'Team-integrated agents: Devin'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 团队集成代理：Devin
- en: '[Devin](https://devin.ai) positions itself as an “AI teammate” rather than
    just a tool, integrating with Slack, GitHub, and issue trackers like Jira. Built
    by Cognition Labs, it uses custom AI models tuned for long-term reasoning and
    multistep execution. Devin excels at parallel execution of small maintenance tasks
    like bugfixes, test additions, and linter cleanups that often get deprioritized.
    Its collaborative design includes status updates, clarification requests, and
    even automatic preview deployments. While it handles straightforward tasks well,
    complex issues can still require significant human intervention, highlighting
    the current boundaries of autonomous coding.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[Devin](https://devin.ai)将自己定位为“AI队友”而非仅仅是工具，与Slack、GitHub和Jira等问题跟踪器集成。由Cognition
    Labs构建，它使用针对长期推理和多步执行定制的AI模型。Devin擅长并行执行小型维护任务，如错误修复、测试添加和代码检查清理，这些任务通常会被降级。其协作设计包括状态更新、澄清请求，甚至自动预览部署。虽然它处理简单任务很好，但复杂问题仍然可能需要显著的人工干预，突显了自主编码的当前边界。'
- en: The field is expanding rapidly, with both established players and startups racing
    to define the category. Microsoft has hinted at “Copilot++,” moving beyond inline
    suggestions to agent capabilities. Enterprises are being courted by startups like
    CodeGen (which uses Anthropic’s Claude) promising “SWEs that never sleep.” Meanwhile,
    open source projects and academic research continue pushing boundaries, exploring
    how to make code generation more reliable and contextual.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该领域正在迅速扩张，既有老牌玩家也有初创公司竞相定义这一类别。微软暗示了“Copilot++”，超越了内联建议，转向代理功能。企业正受到像CodeGen（使用Anthropic的Claude）这样的初创公司的追捧，承诺“永不休息的SWEs”。同时，开源项目和学术研究继续推动边界，探索如何使代码生成更可靠和更具上下文。
- en: 'This proliferation suggests that we’re witnessing the birth of a new development
    paradigm where individual developers orchestrate multiple AI agents, each specialized
    for different aspects of the software lifecycle. The key differentiators emerging
    are:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种激增表明，我们正在见证一个新开发范式的诞生，其中个人开发者协调多个AI代理，每个代理针对软件生命周期的不同方面进行专门化。正在出现的关键区别是：
- en: Execution environment (local versus cloud)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行环境（本地与云）
- en: Integration depth (IDE versus workflow tools)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成深度（集成开发环境与工作流程工具）
- en: Autonomy level (supervised versus independent)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自主程度（监督与独立）
- en: Target use cases (maintenance versus feature development)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标用例（维护与功能开发）
- en: Challenges and Limitations
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战与局限性
- en: 'While autonomous coding agents inherit the foundational challenges of AI-assisted
    development, as discussed throughout this book—particularly the 70% problem, explored
    in [Chapter 3](ch03.html#ch03_the_70_problem_ai_assisted_workflows_that_actual_1752630043200933)—their
    autonomous nature introduces distinct complications that warrant separate examination:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自主编码代理继承了本书中讨论的人工辅助开发的根本挑战——特别是第3章中探讨的70%问题——但它们的自主性质引入了独特的复杂性，需要单独审查：
- en: The compounding effect of sequential decisions
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 连续决策的复合效应
- en: 'Unlike interactive AI assistance where humans intervene at each step, autonomous
    agents make chains of decisions that can compound errors in unique ways. When
    an agent misinterprets the initial requirements, it doesn’t just generate one
    flawed function: it builds an *entire implementation architecture* on that misunderstanding.
    Each subsequent decision reinforces the original error, creating what I call “coherent
    incorrectness”: code that’s internally consistent but fundamentally misaligned
    with actual needs.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个步骤都由人类干预的交互式AI辅助不同，自主代理会做出一系列决策，这些决策可以以独特的方式累积错误。当一个代理误解了初始要求时，它不仅仅生成一个有缺陷的功能：它基于这种误解构建了一个*整个实现架构*。每个后续决策都会加强原始错误，形成我所说的“连贯的错误”：代码在内部是一致的，但与实际需求根本不匹配。
- en: This sequential decision making particularly challenges agents that tackle multifile
    changes. An agent implementing a new feature might correctly modify the backend
    API but then propagate incorrect assumptions through the frontend, database schema,
    and test suites. By the time you review the complete pull request, untangling
    these interconnected mistakes tends to require more effort than the interactive,
    incremental corrections that are possible with traditional AI assistance.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种顺序决策特别挑战处理多文件更改的代理。一个实现新功能的代理可能正确地修改了后端API，但随后通过前端、数据库模式和测试套件传播了错误假设。到你审查完整的pull
    request时，解开这些相互关联的错误通常需要比传统AI辅助可能的交互式、增量更正更多的努力。
- en: Environmental brittleness at scale
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 规模化环境脆弱性
- en: While [Chapter 8](ch08.html#ch08_security_maintainability_and_reliability_1752630044621528)
    discusses general environment configuration challenges, autonomous agents face
    unique complications from their sandbox execution model. Each agent run requires
    spinning up an isolated environment that *precisely* mirrors your development
    setup—a challenge that scales poorly. When you’re running multiple agents concurrently,
    even slight variations in the environment can lead to dramatically different outcomes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[第8章](ch08.html#ch08_security_maintainability_and_reliability_1752630044621528)讨论了一般的环境配置挑战，但自主代理由于它们的沙盒执行模型而面临独特的复杂情况。每次代理运行都需要启动一个与你的开发设置*精确*匹配的隔离环境——这是一个扩展性不佳的挑战。当你同时运行多个代理时，即使是环境中的微小变化也可能导致截然不同的结果。
- en: Consider a scenario where five agents work on different features simultaneously.
    Agent A might have a slightly older Node version in its container, Agent B might
    lack a specific system library, and Agent C might have different time zone settings.
    These variations, invisible during execution, surface as subtle bugs that only
    appear when you begin integrating their work. This “environmental drift” between
    agent sandboxes represents a new class of integration challenge that is absent
    from single-developer workflows.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，其中五个代理同时处理不同的功能。代理A可能在它的容器中有一个稍微旧一点的Node版本，代理B可能缺少特定的系统库，而代理C可能有不同的时区设置。这些在执行期间不可见的差异，在开始整合他们的工作时，会以微妙的错误形式出现，这些错误只有在开始整合他们的工作时才会显现。代理沙盒之间的这种“环境漂移”代表了一种新的集成挑战类型，这种挑战在单一开发者工作流程中是不存在的。
- en: The async coordination paradox
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 异步协调悖论
- en: Autonomous agents promise parallel development, but this introduces coordination
    challenges that are quite distinct from human team dynamics. When multiple agents
    modify overlapping code sections, they lack the implicit communication channels
    humans use—there’s no quick Slack message asking, “Are you touching the auth module?”
    or informal awareness of what colleagues are working on.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 自主代理承诺并行开发，但这引入了与人类团队动态截然不同的协调挑战。当多个代理修改重叠的代码部分时，它们缺乏人类使用的隐含沟通渠道——没有快速的信息请求“你正在修改认证模块吗？”或者对同事正在做什么的非正式了解。
- en: 'This creates what I term the *async coordination paradox*: the more agents
    you run in parallel to increase productivity, the more complex integrating them
    becomes. Unlike human developers, who naturally coordinate through standups and
    informal communication, agents operate in isolation. You might discover that Agent
    A has refactored a utility function, while Agent B was busy adding new calls to
    the old version, creating conflicts that wouldn’t occur if agents had human developers’
    natural awareness of each other’s work.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这就形成了我所说的*异步协调悖论*：你运行的代理越多以增加生产力，整合它们就越复杂。与自然通过站立会议和非正式沟通进行协调的人类开发者不同，代理在隔离状态下操作。你可能会发现代理A重构了一个实用函数，而代理B正忙于向旧版本添加新调用，从而产生了如果代理有人类开发者对彼此工作的自然意识就不会发生的冲突。
- en: The review bottleneck—amplified
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 审查瓶颈——放大
- en: While code review remains essential for all AI-generated code (as discussed
    in previous chapters), autonomous agents amplify this challenge through sheer
    volume and timing. Unlike interactive AI assistance, where code arrives incrementally
    as you work, agent-generated PRs appear as complete implementations—often as multiple
    PRs arriving simultaneously after overnight runs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码审查对于所有AI生成的代码仍然是必不可少的（如前几章所述），但自主代理通过数量和时机放大了这一挑战。与交互式AI辅助不同，代码是在你工作时逐步到达的，而代理生成的PRs则表现为完整的实现——通常是在夜间运行后同时到达的多个PR。
- en: This creates a kind of cognitive overload that’s distinct from the kind you
    get when reviewing human PRs. With human contributions, you can often rely on
    commit messages and PR descriptions to reflect a coder’s actual thought processes.
    Agent PRs, however, require you to reverse-engineer the agent’s “reasoning” from
    the code itself. When five agents each deliver PRs of 500 lines or more on Monday
    morning, the review burden shifts from being a collaborative quality check to
    something more like an archaeological expedition.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这创造了一种与审查人类PR时得到的认知过载不同的情况。对于人类贡献，你通常可以依赖提交信息和PR描述来反映开发者的实际思维过程。然而，代理PR要求你从代码本身逆向工程代理的“推理”。当五个代理在周一早上各自提交500行或更多的PR时，审查负担从协作质量检查转变为更像是考古探险。
- en: Delegating to agents requires trust
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将任务委托给代理需要信任
- en: Perhaps most significantly, autonomous agents challenge our trust models in
    ways interactive AI tools don’t. When you delegate a task to an agent and walk
    away, you’re making an implicit bet about acceptable risk. This differs fundamentally
    from supervised AI assistance, where you maintain moment-by-moment control.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最重要的是，自主代理以交互式AI工具不同的方式挑战了我们的信任模型。当你将任务委托给代理并离开时，你是在对可接受的风险进行隐含的赌注。这与监督式AI辅助截然不同，在监督式AI辅助中，你保持对每一刻的控制。
- en: Consider agentic technologies’ security implications. Autonomous agents with
    repository write access and execution capabilities present unique attack surfaces.
    A compromised or misdirected agent doesn’t just *suggest* bad code—it actively
    *commits* it and potentially even *deploys* it. Our sandboxing and access controls
    for agents must be correspondingly more sophisticated than for suggestion-based
    tools (covered in [Chapter 8](ch08.html#ch08_security_maintainability_and_reliability_1752630044621528)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑代理技术的安全影响。具有存储库写入访问权限和执行能力的自主代理提供了独特的攻击面。一个被破坏或误导的代理不仅会*建议*不良代码，它还会积极*提交*并可能甚至*部署*它。我们为代理的沙箱化和访问控制必须比基于建议的工具（在第8章中介绍）更为复杂。
- en: Emerging organizational challenges
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 新兴的组织挑战
- en: As teams scale up their agent usage, new organizational patterns are emerging
    that don’t exist with traditional AI assistance. Who “owns” agent-generated code
    when the requesting developer is out sick? How do you track agent resource usage
    across teams? What happens when an agent’s monthlong refactoring project conflicts
    with urgent feature development?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 随着团队扩大代理的使用规模，新的组织模式正在出现，这些模式在传统的AI辅助中并不存在。当请求代码的开发者因病缺席时，“拥有”代理生成的代码的是谁？如何跟踪团队间的代理资源使用情况？当代理的为期一个月的重构项目与紧急功能开发冲突时会发生什么？
- en: These aren’t technical limitations but organizational challenges, and they’re
    unique to autonomous systems. They require new roles (agent coordinators?), new
    processes (agent impact assessments?), and new tools (agent fleet management?)
    that extend beyond the individual developer considerations this book has addressed
    in earlier chapters.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是技术限制，而是组织挑战，并且它们是自主系统的独特挑战。它们需要新的角色（代理协调员？）、新的流程（代理影响评估？）和新的工具（代理机群管理？），这些工具超越了本书早期章节中讨论的个体开发者考虑因素。
- en: The autonomous nature of these agents—their ability to work independently, make
    sequential decisions, and operate at scale—transforms them from productivity tools
    into something approaching team members. This shift demands not just the technical
    practices discussed throughout this book but entirely new frameworks for coordination,
    trust, and integration that we’re only beginning to understand.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代理的自主性——它们独立工作、做出顺序决策和大规模操作的能力——将它们从生产力工具转变为接近团队成员的东西。这种转变不仅需要本书中讨论的技术实践，还需要全新的协调、信任和集成框架，而我们才刚刚开始理解这些框架。
- en: Best Practices for Using AI Coding Agents Effectively
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效使用AI编码代理的最佳实践
- en: While many general AI development practices apply to autonomous coding agents,
    certain aspects of agent-based development require specific consideration. Based
    on collective experience with tools like Codex, Jules, Devin, and Cursor’s background
    agents, these practices address the unique challenges of delegating entire development
    tasks to AI systems operating independently.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多通用AI开发实践适用于自主编码代理，但基于代理的开发需要特别考虑某些方面。基于对Codex、Jules、Devin和Cursor的背景代理等工具的集体经验，这些实践解决了将整个开发任务委托给独立运行的AI系统所面临的独特挑战。
- en: Strategically Select the Tasks Autonomous Agents Are Going to Implement
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略性地选择自主代理将要实施的任务
- en: The fundamental difference between AI assistants and autonomous agents lies
    in their scope and independence. Agents excel at well-defined, encapsulated tasks
    with clear success criteria—particularly those involving parallel execution of
    many small tasks. Ideal agent assignments include comprehensive test coverage
    improvements, systematic dependency updates, bulk refactoring operations, and
    standardized feature implementations across multiple components.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能助手和自主代理之间的基本区别在于它们的范围和独立性。代理擅长定义明确、封装的任务，具有清晰的成功标准——尤其是涉及许多小任务并行执行的任务。理想的代理任务分配包括全面的测试覆盖率改进、系统性的依赖项更新、批量重构操作以及跨多个组件的标准化功能实现。
- en: Consider the difference between asking an AI assistant to help write a single
    test versus tasking an agent to achieve 80% test coverage across an entire module.
    The agent can methodically work through each untested function, generate appropriate
    test cases, run them to verify correctness, and iterate until the coverage target
    is met. This type of systematic, measurable work is the sweet spot for autonomous
    agents.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下，要求人工智能助手帮助编写单个测试与指派代理在整个模块中实现80%测试覆盖率之间的区别。代理可以系统地处理每个未测试的功能，生成适当的测试用例，运行它们以验证正确性，并迭代直到达到覆盖率目标。这种系统性和可衡量的工作是自主代理的理想领域。
- en: Conversely, tasks that require making significant architectural decisions, interpreting
    complex stakeholder requirements, or designing novel algorithms remain better
    suited to human-led development with AI assistance. The key lies in recognizing
    which aspects of a larger task can be effectively delegated to agents and which
    require human judgment and creativity.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，那些需要做出重大架构决策、解释复杂利益相关者需求或设计新颖算法的任务，更适合由人类主导的开发，并辅以人工智能。关键在于识别更大任务中哪些方面可以有效地委托给代理，哪些方面需要人类的判断和创造力。
- en: Leverage Agent-Specific Planning and Oversight Features
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用代理特定的规划和监督功能
- en: Modern autonomous agents  distinguish themselves through sophisticated planning
    and execution transparency features that demand active engagement. When Jules
    presents its execution plan before beginning work or when Cursor displays real-time
    logs of agent activity, these represent critical intervention points that are
    unique to agent-based development.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现代自主代理通过复杂的规划和执行透明度功能脱颖而出，这些功能需要积极的参与。当Jules在开始工作之前展示其执行计划，或者当Cursor显示代理活动的实时日志时，这些代表了对基于代理的开发独特的关键干预点。
- en: The *planning phase* serves as your primary quality gate. Review proposed plans
    not just for correctness but for efficiency and alignment with your codebase conventions.
    If Jules plans to update a Next.js application but omits critical webpack configuration
    changes, catching this during planning prevents extensive rework later on. This
    proactive review differs fundamentally from reactive code review and represents
    a new skill in the developer toolkit.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*规划阶段*是您的主要质量关卡。不仅要审查提出的计划是否正确，还要审查其效率和与代码库约定的契合度。如果Jules计划更新Next.js应用程序但遗漏了关键的webpack配置更改，那么在规划阶段发现这些问题可以防止后续进行大量的返工。这种主动审查与被动代码审查有根本性的区别，代表了开发者工具包中的新技能。'
- en: '*Runtime monitoring* provides another layer of agent-specific oversight. While
    you need not watch every operation, periodic checks can prevent agents from pursuing
    inefficient solutions or making unnecessarily broad changes. Cursor’s ability
    to “enter” the agent’s environment midtask exemplifies how modern tools support
    intervention without completely abandoning the autonomous workflow. To maximize
    efficiency, you’ll need to learn when to intervene and when to let the agent self-correct.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行时监控*提供了另一层针对代理的特定监督。虽然您不需要监视每个操作，但定期的检查可以防止代理追求低效的解决方案或做出不必要的广泛更改。Cursor能够“进入”代理的环境进行中任务，这展示了现代工具如何在不完全放弃自主工作流程的情况下支持干预。为了最大化效率，您需要学会何时干预，何时让代理自行纠正。'
- en: Manage Concurrent Agent Operations
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理并发代理操作
- en: Unlike traditional development, where a single developer works on one task at
    a time, agents enable true parallel development. This capability requires new
    coordination strategies. When running multiple agents simultaneously—perhaps one
    updating dependencies while another adds logging infrastructure—you must consider
    the potential conflicts and dependencies between their work.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的开发不同，在传统开发中，单个开发者一次只处理一个任务，代理使真正的并行开发成为可能。这种能力需要新的协调策略。当同时运行多个代理时——可能一个在更新依赖项，另一个在添加日志基础设施——你必须考虑它们工作之间的潜在冲突和依赖关系。
- en: 'Establish clear boundaries for each agent’s scope to minimize merge conflicts.
    Assign agents to different modules or layers of the application when possible.
    Consider the order of integration: an agent that is adding new features might
    need to wait for another agent’s infrastructure improvements to complete. This
    orchestration resembles managing a distributed team more than it does traditional
    solo development.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个代理的范围设定清晰的边界，以最大限度地减少合并冲突。在可能的情况下，将代理分配到不同的模块或应用的不同层。考虑集成顺序：添加新功能的代理可能需要等待另一个代理的基础设施改进完成。这种协调比传统的独立开发更像是在管理一个分布式团队。
- en: Evolve Your Team Practices to Integrate Agents
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发展团队实践以整合代理
- en: The introduction of autonomous agents fundamentally alters team dynamics and
    review processes. Unlike reviewing a colleague’s carefully crafted PR, agent-generated
    PRs may contain technically correct but stylistically inconsistent code. Teams
    must develop new review practices that account for this difference.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 自主代理的引入从根本上改变了团队动态和审查流程。与审查同事精心制作的PR不同，代理生成的PR可能包含技术上正确但风格上不一致的代码。团队必须发展新的审查实践，以考虑到这种差异。
- en: 'Consider establishing agent-specific review checklists that emphasize not just
    correctness but also alignment with team conventions and architectural patterns.
    Document common quirks you spot as you work with the agent: perhaps your chosen
    agent consistently uses certain antipatterns or misses specific optimization opportunities.
    This institutional knowledge helps reviewers quickly identify and address recurring
    issues.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑建立针对特定代理的审查清单，强调的不仅是正确性，还有与团队惯例和架构模式的契合度。记录你在与代理一起工作时发现的常见怪癖：也许你选择的代理持续使用某些反模式或错过特定的优化机会。这种制度化的知识有助于审查员快速识别和解决反复出现的问题。
- en: Build Feedback Loops with Autonomous Systems
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自主系统构建反馈循环
- en: Perhaps most importantly, autonomous agents enable a new form of iterative development
    in which the feedback loop extends beyond mere code review. When an agent’s pull
    request needs refinement, you can often send it back and ask for another iteration
    with specific guidance. This differs from traditional development, where sending
    work back to a human colleague carries social and time costs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的可能就是，自主代理使迭代开发出现了一种新的形式，其中反馈循环不仅限于代码审查。当一个代理的拉取请求需要改进时，你通常可以将其退回并要求进行另一轮迭代，并提供具体的指导。这与传统开发不同，将工作退回给人类同事会带来社会和时间成本。
- en: Work to develop prompting patterns that work well with your chosen agents. When
    you find successful prompt formulations that consistently yield high-quality results,
    document them. Create templates for common task types that include all necessary
    context and constraints. This is a kind of prompt engineering specifically for
    agents that considers their planning, execution, and revision cycles, and it represents
    a distinct skill from general AI interaction.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 努力开发与所选代理配合良好的提示模式。当你找到成功的提示公式，并持续产生高质量的结果时，请记录下来。为常见任务类型创建模板，包括所有必要的上下文和约束。这是一种针对代理的提示工程，它考虑了他们的规划、执行和修订周期，并且它代表了一种与通用人工智能交互不同的独特技能。
- en: 'The goal remains unchanged: delivering high-quality software efficiently. Autonomous
    agents simply provide a new tool for achieving this goal, one you should integrate
    into your existing practices thoughtfully rather than replacing established methods
    wholesale. By understanding these agents and leveraging their unique capabilities
    while maintaining rigorous quality standards, teams can realize significant productivity
    gains without sacrificing code quality or architectural integrity.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 目标保持不变：高效地交付高质量的软件。自主代理只是提供了一种实现这一目标的新工具，你应该深思熟虑地将它整合到现有的实践中，而不是完全取代既定方法。通过理解这些代理并利用它们独特的功能，同时保持严格的质量标准，团队可以实现显著的生产力提升，而不会牺牲代码质量或架构完整性。
- en: Summary and Next Steps
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和下一步
- en: 'To wrap up, I’ll echo a sentiment from [Chapter 4](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362):
    AI won’t replace developers, but developers who can use AI effectively may well
    replace those who can’t. The advent of autonomous coding agents is a leap in that
    direction—those who learn to harness these “headless colleagues” will be able
    to do more in less time. It’s an exciting time to be a software engineer, as long
    as we adapt and continue to hold our work to high standards. The tools may be
    changing, but the goals remain: build reliable, efficient, and innovative software.
    With AI agents at our side (or in the background), we have new ways to reach those
    goals—and perhaps get a good night’s sleep while the bots burn the midnight oil.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我将重申[第4章](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362)中的观点：人工智能不会取代开发者，但能够有效使用人工智能的开发者可能会取代那些不能的人。自主编码代理的出现是朝着这个方向的一大步——那些学会利用这些“无头同事”的人将能够在更短的时间内完成更多工作。只要我们适应变化并继续将我们的工作标准保持得高，对软件工程师来说，这是一个激动人心的时代。工具可能会改变，但目标保持不变：构建可靠、高效和创新的软件。有了人工智能代理在我们身边（或在幕后），我们有了新的方式来实现这些目标——也许在机器人熬夜加班的时候，我们还能睡个好觉。
- en: Next, the final chapter of this book takes a broader look at the future of AI
    in coding, including the future of agentic AI.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，本书的最后一章更广泛地探讨了人工智能在编码领域的未来，包括代理人工智能的未来。
