- en: 7 Problem decomposition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 问题分解
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding problem decomposition and why we need to do it
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解问题分解及其必要性
- en: Using top-down design to carry out problem decomposition and write programs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自顶向下的设计进行问题分解和编写程序
- en: Writing a spelling suggestions program using top-down design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自顶向下的设计编写拼写建议程序
- en: In chapter 3, we talked about why we shouldn’t ask Copilot to solve big problems.
    Imagine what could happen if we asked Copilot to “Design a two-player strategy
    game.”
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们讨论了为什么我们不应该要求Copilot解决大问题。想象一下，如果我们要求Copilot“设计一个两人策略游戏”，会发生什么。
- en: In the worst case, Copilot wouldn’t do anything useful. We observe this sometimes
    when Copilot gives us comments again and again but never provides us with real
    code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，Copilot可能不会做任何有用的事情。我们有时会观察到Copilot反复给出评论，但从未提供真正的代码。
- en: In the best case, we’d get a canned program with all the decisions made for
    us. That program may not match what we wanted. Part of the power of being a programmer
    is customizing what we’re creating. Even if we didn’t want to customize anything,
    what would we do if the program from Copilot had flaws? It would be difficult
    for us to fix a large program that we don’t understand.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在最佳情况下，我们会得到一个预制的程序，其中所有决策都为我们做好了。这个程序可能不符合我们的需求。作为程序员的力量之一就是定制我们正在创建的内容。即使我们不想定制任何内容，如果Copilot的程序有缺陷，我们该怎么办？如果我们不理解一个大型程序，那么修复它将非常困难。
- en: For us to get a program that does what we want, we need to feed small subproblems
    to Copilot and assemble those solutions into our own program. The focus of this
    chapter is learning how to break large problems into smaller subproblems, which
    is essential to being able to solve the large problems we want to solve.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到一个能够实现我们想要的功能的程序，我们需要向Copilot提供小的子问题，并将这些解决方案组装成我们自己的程序。本章的重点是学习如何将大问题分解成更小的子问题，这对于解决我们想要解决的大问题至关重要。
- en: 7.1 Problem decomposition
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 问题分解
- en: Problem decomposition involves starting with a large problem that may not be
    fully specified and breaking it down into subproblems, each of which is well-defined
    and useful for solving our overall problem. Our goal is then to write a function
    to solve each of those subproblems. We may be able to do this for some subproblems
    with a reasonable amount of code, but other subproblems may still be too big for
    us to capture in a function of reasonable size. (In chapter 3, we mentioned that
    we want to keep functions short—something like 12–20 lines—to give us the best
    chance of getting good code from Copilot, testing that code, and fixing bugs in
    that code if necessary.) If a subproblem is still too large to be implemented
    in a single function, then we further divide that subproblem into sub-subproblems
    of their own. Hopefully, each of those sub-subproblems will be small enough now,
    but if not, we’ll continue dividing those too! The key reason we do this is to
    manage complexity. Each function should be simple enough so that we can understand
    its purpose and so that Copilot can solve it well. If something does go wrong,
    we won’t have too much code to trawl through to find the problem. When we write
    code that is extremely complex, we’re likely to make mistakes. The same goes for
    Copilot! And, when we have mistakes in long, complex code, they aren’t easy to
    find and fix. It’s hard to overstate the importance of problem decomposition for
    quality code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 问题分解涉及从一个可能没有完全定义的大问题开始，将其分解成更小的子问题，每个子问题都定义明确且对我们解决整体问题有用。我们的目标是编写一个函数来解决这些子问题。我们可能能够用一定量的代码解决一些子问题，但其他子问题可能仍然太大，无法用合理大小的函数来捕捉。
    (在第3章中，我们提到我们希望保持函数简短——大约12-20行——以增加从Copilot获得良好代码、测试该代码以及在必要时修复代码中的错误的机会。) 如果一个子问题仍然太大，无法在一个函数中实现，那么我们将进一步将这个子问题分解成更小的子子问题。希望现在每个子子问题都足够小，但如果不是的话，我们也会继续分解它们！我们这样做的主要原因是管理复杂性。每个函数都应该足够简单，以至于我们可以理解其目的，并且Copilot可以很好地解决它。如果出了问题，我们不会有很多代码需要检查以找到问题。当我们编写极其复杂的代码时，我们很可能会犯错误。Copilot也是如此！而且，当我们有长而复杂的代码中的错误时，它们并不容易找到和修复。问题分解对于编写高质量代码的重要性不容小觑。
- en: The process of starting with a large problem and breaking it down is called
    *problem decomposition*. The way we’re doing this here is synonymous with the
    software engineering technique known as *top-down design*. It’s called top-down
    design because we’re starting with the large task we want to complete and breaking
    it down into smaller tasks. Once we’ve completed the top-down design, we can implement
    the resulting functions in code. We’ll have one function for our overall problem,
    which will call the functions for each of our subproblems. Each of those subproblem
    functions will further call their own functions, as needed, to solve any of their
    sub-subproblems, and so on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个大的问题开始，并将其分解的过程被称为*问题分解*。我们在这里所做的方式与被称为*自上而下设计*的软件工程技术同义。它被称为自上而下设计，因为我们是从我们想要完成的大任务开始的，并将其分解成更小的任务。一旦我们完成了自上而下的设计，我们就可以在代码中实现产生的函数。我们将有一个用于整体问题的函数，它将调用每个子问题的函数。每个子问题函数将根据需要进一步调用它们自己的函数，以解决任何子子问题，依此类推。
- en: As we discussed in chapter 3, we’re looking to end up with functions that each
    have a small role to play in our overall program and whose behavior is clearly
    defined. We need those functions so that we can call them to reduce the complexity
    of functions that would otherwise be too complex. To improve clarity and ease
    of understanding, we seek to design functions that have a small number of parameters
    and return a small amount of highly useful information.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第3章中讨论的那样，我们希望最终得到每个函数都在我们的整体程序中扮演一个小角色，并且其行为是明确定义的。我们需要这些函数，以便我们可以调用它们来降低其他函数的复杂性。为了提高清晰度和易于理解，我们寻求设计具有少量参数并返回少量高度有用信息的函数。
- en: 7.2 Small examples of top-down design
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 自上而下设计的小例子
- en: 'We’ll soon jump into a more authentic example of how top-down design works,
    but we’d first like to set the stage using a couple of our earlier examples. Let’s
    think about the design of a function we previously wrote in chapter 3: `get_strong_password`.
    It repeatedly prompts the user for a password until they enter a strong password.
    Don’t go back and look at that code—we want to start fresh here.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将跳入一个更真实的例子，展示自上而下设计是如何工作的，但首先我们想要使用我们之前的一些例子来设定场景。让我们思考一下我们在第3章中编写的函数的设计：`get_strong_password`。它反复提示用户输入密码，直到他们输入一个强密码。不要回去看那段代码——我们想要从这里开始。
- en: Suppose that we want to use a top-down design to solve this task. If it were
    one small, well-defined task, we could implement it directly as a single function.
    However, for this task, we do see a subtask; namely, what’s a strong password?
    What are the rules around that? To us, this sounds like a subtask that we can
    try to carve out of this function to make it simpler. Indeed, in chapter 3, when
    we wrote this function, we did call our earlier `is_strong_password` function,
    which makes the True/False decision about what it means for a password to be strong.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要使用自上而下设计来解决这个问题。如果它是一个小而明确的任务，我们可以直接将其实现为一个单独的函数。然而，对于这个任务，我们确实看到了一个子任务；也就是说，什么是强密码？围绕这个问题的规则是什么？对我们来说，这听起来像是一个我们可以尝试从这个函数中分离出来的子任务，以使其更简单。确实，在第3章中，当我们编写这个函数时，我们确实调用了我们之前的`is_strong_password`函数，它对密码是否强大做出了真/假的判断。
- en: We can depict this top-down design as shown in figure 7.1\. For ease of displaying
    what will ultimately be large figures later in the chapter, we’re going to consistently
    show the design from left to right rather than top to bottom, but the same fundamental
    principles still apply.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这种自上而下的设计描绘如图7.1所示。为了便于在章节后面展示最终可能变得很大的图，我们将一致地从左到右展示设计，而不是从上到下，但同样的基本原理仍然适用。
- en: '![figure](../Images/7-1.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/7-1.png)'
- en: Figure 7.1 Functions diagram for the `get_strong_password` function. `get_strong_password`
    calls `is_strong_password`.
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1 `get_strong_password`函数的函数图。`get_strong_password`调用`is_strong_password`。
- en: This figure indicates that it’s our goal to have `get_strong_password` call
    `is_strong_ password` to do some of its work.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表明，我们的目标是让`get_strong_password`调用`is_strong_password`来完成其部分工作。
- en: Now, for our second example, recall from chapter 3 that we also wrote a `best_word`
    function that takes a list of words as its parameter and returns the one worth
    the most points. Again, don’t go back and look at that code—we want to figure
    it out again here. Let’s think about what the code for this task might look like.
    It will probably use a loop to consider each word, and in that loop, it will need
    to keep track of the best word we’ve seen so far. For each word, we need to figure
    out how many points it’s worth by adding up the number of points for each of its
    letters. Remember that *a* is worth 1 point, *b* is worth 3 points, *c* is worth
    3 points, *d* is worth 2 points, *e* is worth 1 point, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看第二个例子。回想一下第3章，我们也编写了一个`best_word`函数，它接受一个单词列表作为参数并返回得分最高的单词。再次强调，不要回去看那段代码——我们想要在这里再次解决这个问题。让我们思考一下这个任务的代码可能是什么样子。它可能会使用一个循环来考虑每个单词，并在那个循环中需要跟踪迄今为止我们看到的最佳单词。对于每个单词，我们需要通过累加其每个字母的分数来确定它值多少分。记住，*a*值1分，*b*值3分，*c*值3分，*d*值2分，*e*值1分，以此类推。
- en: 'Whoa there! We’re really going in-depth on this “How many points each letter
    is worth” thing. This sounds like a subtask to us. If we had a function that we
    could call to tell us the number of points each word is worth, we wouldn’t need
    to worry about this points business in our `best_word` function. In chapter 3,
    we wrote a function called `num_points` that carries out exactly this subtask:
    take a word as a parameter and return its total point value. We can call `num_points`
    from `best_word`, as depicted in figure 7.2\. Again, this makes the task of `best_word`
    easier for us.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们真的要深入探讨这个“每个字母值多少分”的问题。这听起来像是一个子任务。如果我们有一个可以调用的函数来告诉我们每个单词值多少分，我们就不需要在`best_word`函数中担心这个分数问题了。在第3章中，我们编写了一个名为`num_points`的函数，它正好执行这个子任务：接受一个单词作为参数并返回其总分数。我们可以从`best_word`中调用`num_points`，如图7.2所示。再次强调，这使我们的`best_word`任务变得更简单。
- en: '![figure](../Images/7-2.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/7-2.png)'
- en: Figure 7.2 Functions diagram for `best_word`
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2 `best_word`函数的功能图
- en: In chapter 3, we happened to write these functions from subtask to task, from
    the leaf function to the parent function. We’ll continue to do that in this chapter,
    but we’ll do the top-down design first to figure out which functions we’ll need.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们恰好是从子任务到任务，从叶函数到父函数来编写这些函数的。我们将在本章继续这样做，但我们将首先进行自顶向下的设计，以确定我们需要哪些函数。
- en: These two examples from chapter 3 we just talked about are small, and you may
    indeed be able to get their code written by powering ahead with a single function.
    But with large examples, problem decomposition is the only way to keep the complexity
    under control.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才在第3章中讨论的两个例子都很小，你确实可能能够通过一个函数快速编写它们的代码。但是，对于大型例子，问题分解是唯一控制复杂性的方法。
- en: We’ll next dive into a larger example of top-down design. The key skill that
    we want you to take from this chapter is how to break a large problem down into
    smaller subproblems. We encourage you to read through the upcoming example multiple
    times. On your first read, aim for a high-level view of how the pieces fit together
    to solve the overall problem. On your second read, feel free to dive deeper into
    how each function works on its own.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨一个更大的自顶向下设计的例子。我们希望你在本章中掌握的关键技能是如何将一个大问题分解成更小的子问题。我们鼓励你多次阅读即将到来的例子。在你第一次阅读时，目标是了解各个部分如何组合起来解决整体问题。在你第二次阅读时，你可以自由地深入了解每个函数是如何独立工作的。
- en: 7.3 Spelling suggestions
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 拼写建议
- en: For the rest of the chapter, we’re going to solve a problem from beginning to
    end using top-down design. We want you to be sucessful when you use this approach
    on your own to solve your own problems, so you’ll see top-down design reappear
    throughout the remainder of the book.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将使用自顶向下的设计方法从头到尾解决一个问题。我们希望你在自己解决问题时使用这种方法能够成功，所以你将在本书的其余部分看到自顶向下设计方法的重复出现。
- en: Oops—did we have a typo there? *Sucessful*? That was supposed to be *successful*.
    English words can be tricky to spell sometimes! You’ve probably run into many
    such words. Is it thorough or thourough? Acceptable or acceptible? Receive or
    recieve? We’re going to write a program that takes a word that’s potentially misspelled
    and offers possible corrections to that misspelling. It’s a basic spell-checker
    for individual words!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀——我们那里有误拼吗？*Sucessful*？那应该是*successful*。有时候英语单词的拼写可能很棘手！你可能遇到过很多这样的单词。是thorough还是thourough？Acceptable还是acceptible？Receive还是recieve？我们将编写一个程序，该程序接受一个可能拼写错误的单词，并为此拼写错误提供可能的更正。这是一个针对单个单词的基本拼写检查器！
- en: How are we supposed to come up with these possible corrections? Well, let’s
    look at the pairs of words we just provided and discuss the types of mistakes
    they exemplify.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何想出这些可能的更正呢？好吧，让我们看看我们刚刚提供的单词对，并讨论它们所体现的错误类型。
- en: The mistake we made with the word *sucessful* is that we left out one letter—we
    need to add a *c* in there to get the correct word *successful*. So, in general,
    it seems like a good idea to consider adding a letter to a misspelled word because
    that might be exactly what’s needed to fix it. We’re going to consider adding
    any possible letter in any possible position, not just adding a copy of a letter
    that’s already there. This will help us fix misspelled words such as *acknowlege*
    (which is missing a *d*).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在单词*sucessful*中犯的错误是漏掉了一个字母——我们需要在那里添加一个*c*来得到正确的单词*successful*。所以，总的来说，考虑向拼写错误的单词中添加一个字母似乎是个好主意，因为这可能是修复它的确切方法。我们将考虑在可能的任何位置添加任何可能的字母，而不仅仅是添加已经存在的字母的副本。这将帮助我们修复像*acknowlege*（缺少一个*d*）这样的拼写错误。
- en: There are other types of mistakes we’ll want to consider too. For example, the
    mistake in *thourough* isn’t that we’re missing a letter, but that we have an
    extra letter—we need to delete the first *u* to get *thorough*. We’re therefore
    going to consider removing any single letter from a misspelled word to see if
    that fixes it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑其他类型的错误。例如，在单词*thourough*中的错误并不是我们漏掉了一个字母，而是我们多了一个字母——我们需要删除第一个*u*来得到正确的单词*thorough*。因此，我们将考虑从任何拼写错误的单词中删除任何单个字母，看看是否可以修复它。
- en: 'What other mistakes can we fix? Well, there’s that misspelled word *acceptible*.
    That’s a new type of mistake: there’s no missing or extra letter, but there is
    a letter that should be changed to another letter. That is, if we change the *i*
    to an *a*, we arrive at the correctly spelled word *acceptable*. To that end,
    we can try changing each letter to each other letter in the alphabet to see if
    that fixes the misspelling.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能修复哪些错误？好吧，那个误拼的单词*acceptible*是一个新的错误类型：没有缺少或多余的字母，但有一个字母应该被改为另一个字母。也就是说，如果我们把*i*改为*a*，我们就能得到正确拼写的单词*acceptable*。为此，我们可以尝试将每个字母都改为字母表中的每个字母，看看是否可以修复误拼。
- en: There are many ways to fix misspelled words beyond the three that we just gave.
    But we’ll stop here because we think that fixing three types of mistakes is sufficient
    for our purposes of demonstrating top-down design. This means that our program
    will fail to correct the misspelled word *recieve* to *receive*, because we won’t
    be fixing the mistake of having two letters in the wrong order. We’ll also fail
    to correct the misspelled word *camoflague* to camouflage, because we’ll be fixing
    only one mistake in a misspelled word (*camoflague* has two different errors,
    one missing *u* and one added *u*). Once you finish the chapter, we encourage
    you to continue to improve your program and learn more about correcting misspelled
    words if you’d like to go further.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚刚给出的三种方法之外，还有许多方法可以修复拼写错误。但我们将在这里停止，因为我们认为修复三种类型的错误对于我们的目的——展示自顶向下的设计——是足够的。这意味着我们的程序将无法纠正拼写错误的单词*recieve*到*receive*，因为我们不会修复两个字母顺序错误的错误。我们也将无法纠正拼写错误的单词*camoflague*到*camouflage*，因为我们只会修复拼写错误中的一个错误（*camoflague*有两个不同的错误，一个是缺少*u*，另一个是添加了*u*）。一旦你完成这一章，我们鼓励你在愿意更进一步的情况下继续改进你的程序，并学习更多关于纠正拼写错误的知识。
- en: 7.4 Spelling suggestions using top-down design
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 使用自顶向下的设计进行拼写建议
- en: Our task is to “write a program that takes a word that’s potentially misspelled
    and offers possible corrections to that misspelling.” That’s a big task that we
    definitely don’t want to try to jam into a single function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是“编写一个程序，该程序接受一个可能拼写错误的单词，并为此拼写错误提供可能的更正。”这是一个很大的任务，我们绝对不希望将其强行塞入一个单独的函数中。
- en: 'Many programs—whether they analyze data, provide spelling suggestions, or guess
    the author of an unknown text—have three distinct tasks to perform. First, there’s
    the input task: we need to acquire the data on which our program will run. Second,
    there’s the process task, where the program does whatever it’s supposed to do
    with that data. Now, processing the data is all well and good, but it’s useless
    if our users don’t know what our programs discovered through that processing.
    That’s where the third step, the output step, comes in, and it’s where we communicate
    something to the user. Table 7.1 summarizes this process.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序——无论是分析数据、提供拼写建议还是猜测未知文本的作者——都有三个不同的任务要执行。首先，是输入任务：我们需要获取程序运行所需的数据。其次，是处理任务，程序用这些数据做它应该做的事情。然而，数据处理得再好，如果用户不知道程序通过处理发现了什么，那么它也是无用的。这就是第三步，输出步骤，我们在这里向用户传达信息。表7.1总结了这一过程。
- en: Table 7.1 A summary of the input, process data, and output tasks
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表7.1 输入、处理数据和输出任务的总结
- en: '| Phase | Role | Spelling Suggestions Example |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 阶段 | 角色 | 拼写建议示例 |'
- en: '| --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Input  | Take, as input, the information needed for the function.  | Provide
    the misspelled word *sucessful* and a collection of real words (properly spelled
    words).  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | 作为输入，提供函数所需的信息。 | 提供拼写错误的单词*sucessful*和一组真实单词（正确拼写的单词）。 |'
- en: '| Process data  | Perform the operation specified by the function on that data.  |
    Consider changes to that word that might result in a correctly spelled word, for
    example, adding a letter *c* either before or after the *c* in *sucessful* would
    produce the real word *successful*. Many other incorrect words (i.e., *scucessful*
    obtained by adding the letter *c* before the *u*) may also be attempted, but only
    real words should be in the result.  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 处理数据 | 在该数据上执行函数指定的操作。 | 考虑可能使单词拼写正确的更改，例如，在*sucessful*中的*c*之前或之后添加一个字母*c*会产生正确的单词*successful*。许多其他错误的单词（例如，通过在*u*之前添加字母*c*得到的*scucessful*）也可能被尝试，但结果中只应包含真实单词。
    |'
- en: '| Output  | Return the result of that data processing.  | Return the suggestion
    “successful”.  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 输出 | 返回数据处理的结果。 | 返回建议“成功”。 |'
- en: You can see this input-process-output model at work back in our data processing
    example from chapter 2\. We needed to read the data from the CSV file (that’s
    the input step), determine the number of passing yards for each quarterback (that’s
    the process step), and then output the quarterbacks and their passing yards (that’s
    the output step).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在第2章的数据处理示例中看到这个输入-处理-输出模型是如何工作的。我们需要从CSV文件中读取数据（这是输入步骤），确定每个四分卫的传球码数（这是处理步骤），然后输出四分卫及其传球码数（这是输出步骤）。
- en: 'We can think about our Spelling Suggestions problem in a similar way. What’s
    amazing here is that the input-process-output model gives us exactly the three
    subproblems that we’ll want to solve in our top-down design. Here’s what we mean
    (also see the example in table 7.1):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用类似的方式思考我们的拼写建议问题。这里令人惊讶的是，输入-处理-输出模型为我们提供了我们将在自顶向下设计中想要解决的三个子问题。我们的意思如下（也请参见表7.1中的示例）：
- en: For the input step, we need to ask the user for the word for which they want
    to obtain spelling suggestions.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于输入步骤，我们需要询问用户他们想要获取拼写建议的单词。
- en: For the process step, we need to figure out all the possible suggestions for
    the user’s word.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于处理步骤，我们需要找出用户单词的所有可能建议。
- en: For the output step, we need to tell the user about all the spelling suggestions
    that we found during the process step.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于输出步骤，我们需要告诉用户我们在处理步骤中找到的所有拼写建议。
- en: Notice that we started with one large problem to solve (the overall Spelling
    Suggestions problem), and now we have three smaller problems to solve. Our main
    or top-level function will end up calling any functions that result from this
    problem decomposition. We’ll name this main function `spell_check`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们最初有一个大问题要解决（即整体的拼写建议问题），而现在我们有三个更小的问题要解决。我们主要或顶级函数最终将调用由此问题分解产生的任何函数。我们将把这个主要函数命名为`spell_check`。
- en: It’s often but not always the case that we need a separate function for each
    of the subproblems we identify. Take a look at the input step again. We need to
    ask the user for a word. While we could split off a separate function for this
    subtask, that would be overkill. Why? This is because Python already has a built-in
    function for asking the user for input! The function is called `input`, and we
    saw it at work in chapter 3, section 3.3.7, when we were asking the user to enter
    passwords.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常需要为每个识别出的子问题创建一个单独的函数，但这并不是绝对的。再次看看输入步骤。我们需要要求用户输入一个单词。虽然我们可以为这个子任务分离出一个单独的函数，但这将是过度设计。为什么？这是因为Python已经有一个内置的函数可以用来获取用户的输入！这个函数叫做`input`，我们在第3章第3.3.7节中看到它在工作，当时我们要求用户输入密码。
- en: Do we need to split off a separate function for the output step? No again! The
    output step is just outputting stuff to the user. We know that we can do that
    with Python’s already-existing print function. Again, it wouldn’t be a mistake
    to split off a function for this, and you may have done so if you were doing this
    problem decomposition on your own. What you’d notice, though, is that the function
    would be very short, consisting of not much more than a call of `print`—and at
    that point you might think again about whether you want it as a separate function
    or not.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否需要为输出步骤分离出一个单独的函数？不，再次不是！输出步骤只是将内容输出给用户。我们知道我们可以使用Python已经存在的`print`函数来做这件事。再次强调，为这个步骤分离出一个函数并不是一个错误，如果你自己进行这个问题分解，你可能已经这样做了。不过，你会注意到，这个函数会非常短，可能只是调用了一次`print`——在这个时候，你可能又会考虑是否真的需要将其作为一个单独的函数。
- en: The process step, by comparison, is going to involve a lot more work. There’s
    quite a bit that goes into figuring out all the possible spelling suggestions!
    We have to support deleting a letter, inserting a letter, changing one letter
    to another, and so on, which is way too much to keep all in our main `spell_check`
    function. We need a separate function for the process step. This is what we need
    to work on next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相比，这个过程步骤将涉及更多的工作。在确定所有可能的拼写建议时，需要做很多事情！我们必须支持删除字母、插入字母、将一个字母更改为另一个字母等等，这远远超出了在我们的主`spell_check`函数中保留所有这些操作的范围。我们需要一个单独的函数来处理这个过程步骤。这正是我们接下来需要努力的地方。
- en: 7.5 Breaking down the process subproblem
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 分解过程子问题
- en: We need a name for our function that implements the process step. We’ll call
    it `get_spelling_suggestions` because it will be responsible for returning the
    spelling suggestions for what the user typed. It certainly needs to take the user’s
    misspelled word as an argument, or it wouldn’t have access to it!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个名字来命名实现过程步骤的函数。我们将称之为`get_spelling_suggestions`，因为它将负责返回用户输入的拼写建议。它当然需要将用户拼错的单词作为参数，否则它将无法访问它！
- en: 'Pause here for a second, though: Do you think this function needs any additional
    parameters? Answer: it does! Somehow the function needs to know which strings
    are real words in English. For example, it has to know about the words *successful*,
    *thorough*, *acceptable*, and thousands of other English words. We could do that
    in a couple of ways: we could pass a list or (Python) dictionary of real words
    as a parameter, or we could pass the name of a file that contains all the real
    words as a parameter. When you’re designing your functions, you’ll need to make
    similar decisions, focused on the inputs that the function needs to do its work
    and the return value that we need when it’s done.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在这里暂停一下：你认为这个函数需要任何额外的参数吗？答案：是的！这个函数必须以某种方式知道哪些字符串是英语中的真实单词。例如，它必须知道关于单词*successful*、*thorough*、*acceptable*以及成千上万的其它英语单词。我们可以通过几种方式来做这件事：我们可以传递一个包含真实单词列表或（Python）字典的参数，或者我们可以传递一个包含所有真实单词的文件的名称作为参数。当你设计你的函数时，你需要做出类似的决策，专注于函数完成其工作所需的输入以及完成时我们需要的返回值。
- en: In addition to the misspelled word, we’re going to have our function take a
    parameter giving the name of a file that contains the list of valid words. There
    will be one valid word per line of this file. In the resources for this book,
    we’ve included one sample word list file called wordlist.txt that you can use.
    (We found a list of free dictionary words online with a simple internet search.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拼错的单词外，我们的函数还将接受一个参数，给出包含有效单词列表的文件的名称。这个文件中的每一行将有一个有效单词。在这本书的资源中，我们包括了一个名为wordlist.txt的样本单词列表文件，你可以使用它。（我们通过简单的网络搜索找到了一个免费的词典单词列表。）
- en: 'What do we need to do for this process step? We can think of four subtasks.
    This is more problem decomposition! Those subtasks are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对这个过程步骤做什么？我们可以将其视为四个子任务。这是更多的问题分解！这些子任务如下：
- en: '*Get a list of words from the word list file.* A file of words is a good start,
    but it’s more convenient to have the words inside a Python list. That way, we
    can easily determine if a string is a valid word. We’ll name this function `create_word_list`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从单词列表文件中获取单词列表。* 单词文件是一个好的开始，但将单词放在 Python 列表中更方便。这样，我们可以轻松地确定一个字符串是否是有效单词。我们将把这个函数命名为
    `create_word_list`。'
- en: '*Generate a list of all possible words from the user’s string.* We need to
    delete a letter, insert a letter, or change one letter to another letter. This
    is going to generate many strings, some of which are real words and others that
    aren’t real words. For example, from the string `sucessful`, it would generate
    the real word *successful*, but also the strings `xsuccesful`, `sucxcesful`, and
    `succesfrl`, which are clearly not real words. But that’s OK. For now, we just
    want to generate every possible word so that we don’t miss any. We’ll name this
    function `all_possible_words`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成用户字符串中所有可能的单词列表。* 我们需要删除一个字母，插入一个字母，或者将一个字母改为另一个字母。这将生成许多字符串，其中一些是真实单词，而另一些则不是。例如，从字符串
    `sucessful` 中，它会生成真实单词 *successful*，但也会生成字符串 `xsuccesful`、`sucxcesful` 和 `succesfrl`，这些显然不是真实单词。但没关系。目前，我们只想生成所有可能的单词，以免遗漏任何。我们将把这个函数命名为
    `all_possible_words`。'
- en: '*Using the list of all possible words, generate a list of only the real words.*
    This is the step where we prune our full list of potential words down to those
    words that actually exist in English. We’ll name this function `all_real_words`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用所有可能的单词列表，生成仅包含真实单词的列表。* 这是修剪我们潜在单词完整列表到实际存在于英语中的单词的步骤。我们将把这个函数命名为 `all_real_words`。'
- en: '*Return a list of the unique words.* Why unique? We don’t want to return the
    same spelling suggestion twice, even though there may be two or more ways to arrive
    at that spelling suggestion from the user’s string. For example, to fix the word
    *sucessful*, there are two ways to do it: we can add the missing *c* before the
    *c* that’s already there, or we can add the *c* before the *e*. Both result in
    the correctly spelled word *successful*, but we only want to maintain that word
    once.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*返回唯一单词的列表。* 为什么是唯一的？我们不希望返回相同的拼写建议两次，即使可能有两种或更多种从用户字符串到达那个拼写建议的方法。例如，为了修复单词
    *sucessful*，有两种方法：我们可以在已有的 *c* 前面添加缺失的 *c*，或者我们可以在 *e* 前面添加 *c*。两者都导致正确拼写的单词 *successful*，但我们只想保留那个单词一次。'
- en: If we were to split out that final subtask—obtaining a list of unique words—into
    its own function, we’d call it something like `unique_words` or `only_unique_words`.
    While we could split out that subtask, and you’d be justified in doing so, we’ve
    decided to keep it as part of the `get_spelling_suggestions` function. The reason
    is that in Python, it ends up being just one line of code to remove duplicates
    from a list. For expediency, we’re telling you this now, but again, this would
    be a perfectly good subtask if you were doing this top-down design on your own.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将那个最终子任务——获取唯一单词列表——分解成它自己的函数，我们可以将其命名为 `unique_words` 或 `only_unique_words`。虽然我们可以将其分解出来，你这样做也是合理的，但我们决定将其保留为
    `get_spelling_suggestions` 函数的一部分。原因是，在 Python 中，从列表中删除重复项只需要一行代码。为了方便，我们现在告诉你这个，但再次强调，如果你自己进行自上而下的设计，这也会是一个非常好的子任务。
- en: Multiple ways to break down problems
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多种分解问题的方法
- en: There’s no single correct way to do a top-down design and no single correct
    way to decompose problems into subproblems. For example, you may have been surprised
    that we decided to first generate all possible words (including fake ones that
    aren’t actually English words), and then prune that to the list of actual English
    words. Why not just check each possible word first, and only add it to our list
    if it’s a real word? We certainly could have done it that way too! If you had
    this alternate decomposition in mind, or we’ve piqued your curiosity, we encourage
    you to try this alternate design on your own after you’ve finished with the chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种单一的正确方法来进行自上而下的设计，也没有一种单一的正确方法将问题分解为子问题。例如，你可能对我们的决定感到惊讶，即首先生成所有可能的单词（包括实际上不是英语单词的假单词），然后将其修剪成实际存在的英语单词列表。为什么不先检查每个可能的单词，只有当它是真实单词时才将其添加到我们的列表中呢？我们当然也可以那样做！如果你已经有了这种替代分解的想法，或者我们激起了你的好奇心，我们鼓励你在完成本章后自己尝试这种替代设计。
- en: There’s also no shame in trying a top-down design and then abandoning it if
    the design isn’t working out. What might it mean for the design to not work out?
    Well, maybe you’re finding it difficult to break up large functions into distinct
    subproblems. Or maybe you’re getting dozens of tiny functions and starting to
    worry that your functions are too specific and not solving general problems. Or
    maybe you’re having to pass around many parameters, perhaps some of which are
    only there to be passed further and further until finally a function needs them.
    Or maybe you just want to play out an alternate top-down design to see how it
    goes!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试自顶向下的设计并且如果设计不成功就放弃它，这并不是什么丢人的事情。设计不成功可能意味着什么？好吧，也许你发现很难将大函数分解成不同的子问题。或者也许你得到了几十个微小的函数，开始担心你的函数太具体，没有解决一般问题。或者也许你需要传递许多参数，其中一些可能只是为了传递得更远，直到最终一个函数需要它们。或者也许你只是想尝试一个不同的自顶向下的设计，看看结果如何！
- en: We encourage experimentation at the design phase before you settle on a final
    design for the code. In this experimentation, you’d try different possible functions
    and different inputs/outputs for functions. For example, earlier we debated whether
    the `get_spelling_suggestions` function should take a name of a file containing
    real words or a list (or dictionary) containing real words. Both options would
    be worth considering during your design phase.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你在确定代码的最终设计之前，在设计阶段进行实验。在这个实验中，你会尝试不同的可能函数以及函数的不同输入/输出。例如，我们之前讨论过`get_spelling_suggestions`函数是否应该接受包含真实单词的文件名或包含真实单词的列表（或字典）。在设计阶段，这两个选项都值得考虑。
- en: That leaves us with three subtasks we need to solve. We’re going to do our top-down
    design on these shortly. But first, let’s take stock of where we are right now
    (see figure 7.3).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这就剩下三个子任务我们需要解决。我们很快将对这些子任务进行自顶向下的设计。但首先，让我们看看我们现在处于什么位置（见图7.3）。
- en: '![figure](../Images/7-3.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/7-3.png)'
- en: Figure 7.3 Functions diagram showing the three subtasks of `get_spelling_suggestions`
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.3展示了`get_spelling_suggestions`的三个子任务的功能图
- en: 7.5.1 Getting the list of words from the word list file
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.1 从单词列表文件获取单词列表
- en: The function for this task is `create_word_list`. It will take one parameter,
    which is the name of the word list file, and will return the list of words from
    that file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务的函数是`create_word_list`。它将接受一个参数，即单词列表文件的名称，并将返回该文件中的单词列表。
- en: Do we need any further top-down design on this function? Let’s imagine we thought
    the answer was yes. What subtasks could we split out? We could imagine the tasks
    of opening the file, reading its contents, and closing the file. But opening the
    file, as we learned in chapter 5, section 5.1.4, is done by just calling Python’s
    `open` function. Similarly, closing the file is done by just calling Python’s
    `close` function. What about reading the words from the file? That doesn’t sound
    much different from reading the lines of the CSV file in chapter 5, section 5.1.4\.
    So we feel justified in leaving this function alone, without any further subtask
    splitting.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否需要对这个函数进行进一步的自顶向下的设计？让我们假设我们认为答案是肯定的。我们可以分解出哪些子任务？我们可以想象打开文件、读取其内容以及关闭文件的任务。但是，正如我们在第5章第5.1.4节中学到的，打开文件只需调用Python的`open`函数。同样，关闭文件只需调用Python的`close`函数。那么从文件中读取单词呢？这听起来并不比第5章第5.1.4节中读取CSV文件的行复杂多少。所以我们觉得有理由保留这个函数不变，不进行任何进一步的子任务分解。
- en: 7.5.2 Generating the list of all possible words
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.2 生成所有可能单词的列表
- en: The function for this task is `all_possible_words`, which will take one parameter
    giving us the string for which we want to provide spelling suggestions. It will
    return the list of all possible words that can be obtained by adding one letter,
    deleting one letter, or changing one letter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务的函数是`all_possible_words`，它将接受一个参数，即我们想要提供拼写建议的字符串。它将返回通过添加一个字母、删除一个字母或更改一个字母可以获得的所有可能单词的列表。
- en: 'Adding one letter, deleting one letter, and changing one letter are three distinct
    types of tasks. Moreover, they don’t strike us as particularly simple tasks: they’re
    going to involve some sort of loop over the letters in the user’s string. Aha!
    Looks like we have some further top-down design to do on this one. In particular,
    we’re going to split three subtasks out of this function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个字母、删除一个字母和更改一个字母是三种不同的任务类型。而且，它们在我们看来并不特别简单：它们将涉及到对用户字符串中的字母进行某种形式的循环。啊！看起来我们在这个任务上需要进一步的自顶向下的设计。特别是，我们将从这个函数中分解出三个子任务：
- en: '`add_letter`—This function will take a string parameter and return a list of
    all strings that can be obtained by adding one letter anywhere in the word.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_letter`—此函数将接受一个字符串参数，并返回所有可以通过在单词的任何位置添加一个字母而获得的所有字符串。'
- en: '`delete_letter`—This function will take a string parameter and return a list
    of all strings that can be obtained by deleting one letter.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_letter`—此函数将接受一个字符串参数，并返回所有可以通过删除一个字母而获得的所有字符串。'
- en: '`change_letter`—This function will take a string parameter and return a list
    of all strings that can be obtained by changing one letter.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`change_letter`—此函数将接受一个字符串参数，并返回所有可以通过更改一个字母而获得的所有字符串。'
- en: Table 7.2 provides what we expect each function will return for two different
    input strings. For both add_letter and change_letter, a large number of strings
    are returned because they will consider adding or changing every letter in English
    in every location in the input string.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.2提供了我们期望每个函数对两个不同输入字符串将返回的内容。对于`add_letter`和`change_letter`，返回了大量的字符串，因为它们将考虑在输入字符串的每个位置添加或更改英语中的每个字母。
- en: Table 7.2 Examples of the `add_letter`, `delete_letter`, and `change_letter`
    function
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表7.2 `add_letter`、`delete_letter`和`change_letter`函数的示例
- en: '| Input String | Strings Returned by `add_letter` | Strings Returned by `delete_letter`
    | Strings Returned by `change_letter` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 输入字符串 | `add_letter` 返回的字符串 | `delete_letter` 返回的字符串 | `change_letter` 返回的字符串
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `cu`  | `acu, bcu, ccu, …, zcu cau, cbu, ccu, …, czu cua, cub, cuc, …, cuz`  |
    `u, c`  | `au, bu, du, …, zu, ca, cb, cc, …, cz`  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `cu` | `acu, bcu, ccu, …, zcu cau, cbu, ccu, …, czu cua, cub, cuc, …, cuz`
    | `u, c` | `au, bu, du, …, zu, ca, cb, cc, …, cz` |'
- en: '| `cad`  | `acad, bcad, ccad, …, zcad caad, cbad, ccad, …, czad caad, cabd,
    cacd, …, cazd cada, cadb, cadc, …, cadz`  | `ad, cd, ca`  | `aad, bad, dad, …,
    za cbd, ccd, cdd, …, czd caa, cab, cac, …, caz`  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `cad` | `acad, bcad, ccad, …, zcad caad, cbad, ccad, …, czad caad, cabd,
    cacd, …, cazd cada, cadb, cadc, …, cadz` | `ad, cd, ca` | `aad, bad, dad, …, za
    cbd, ccd, cdd, …, czd caa, cab, cac, …, caz` |'
- en: As usual, it’s important to think through whether we need to split out further
    subtasks from these three functions. However, given that the pattern we expect
    to see is just a loop through the letters, we’d be comfortable pushing forward
    here and revisiting our top-down design if our assumption proves to be incorrect.
    For now, we can tell you that we’ll be just fine without any further splitting.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，思考是否需要从这三个函数中进一步分解出子任务是很重要的。然而，鉴于我们期望看到的是仅通过字母的循环，我们在这里可以推进，如果我们的假设被证明是错误的，我们再回头审视我们的自顶向下的设计。现在，我们可以告诉你，我们不需要进一步分解也能做得很好。
- en: Knowing when to stop dividing into subtasks
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 知道何时停止分解成子任务
- en: In general, knowing when to stop breaking a task into smaller subtasks is more
    art than science. It takes practice designing programs to get intuition about
    where to stop. Many experienced developers often pause for each subtask and consider
    how complex it is to program and sketch the steps of the function out in their
    mind. If the solution isn’t straightforward, they often choose to divide it into
    more steps. But we don’t expect you to be able to do this yet. Some companies
    put out guidelines to encourage simple functions by suggesting limits on the number
    of lines permitted (e.g., no more than 12 lines), but many feel the limit should
    be on the complexity moreso than the length, although length and complexity are
    certainly related.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，知道何时停止将任务分解成更小的子任务，更多的是一种艺术而非科学。这需要通过设计程序来获得关于何时停止的直觉。许多经验丰富的开发者通常会为每个子任务暂停一下，考虑编程的复杂程度，并在心中勾勒出函数的步骤。如果解决方案不是直截了当的，他们通常会选择将其分解成更多步骤。但我们不期望你能够做到这一点。一些公司发布指南，通过建议允许的行数上限（例如，不超过12行）来鼓励简单的函数，但许多人认为限制应该更多地在于复杂性，尽管长度和复杂性当然是有关系的。
- en: When you’re just getting started, a decent proxy then is to limit the number
    of lines per function to something like 12–20\. If you later find that a function
    ends up being just a single line, it’s still a subtask, but may not deserve its
    own function. (Sometimes, it’s okay to keep a short function though if it’s called
    many times by different functions or helps simplify the calling function.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始时，一个合理的代理方法是限制每个函数的行数在12-20行左右。如果你后来发现一个函数最终只有一行，它仍然是一个子任务，但可能不值得拥有自己的函数。（有时，如果它被不同的函数多次调用或有助于简化调用函数，保留一个短函数也是可以的。）
- en: It’s okay to get this wrong when you’re first practicing; we certainly have.
    Sometimes a subtask seems like it’ll make a simple function, only to end up being
    much more difficult than expected. In cases like that, you know to just subdivide
    it more. Likewise, we’ve had functions that were a single line and if they were
    used commonly or made the calling function simpler to understand, we just kept
    that line as a function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初练习时犯错是可以接受的；我们确实犯过。有时候一个子任务看起来会形成一个简单的函数，但最终却比预期的要困难得多。在这种情况下，您知道只需进一步细分它。同样，我们也有一些只有一行代码的函数，如果它们被频繁使用或使调用函数更容易理解，我们就保留那行代码作为一个函数。
- en: 7.5.3 Generating the list of all real words
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.3 生成所有真实单词的列表
- en: 'The function for this task is `all_real_words`. It will take two parameters:
    the list of real words, and the list of all possible words. It will return a list
    consisting of only the real words from the full list of possible words. The code
    for this function would involve going through the list of possible words and checking
    whether each one shows up in the list of real words. As this task is a small,
    well-defined task that won’t yield a lot of code, we’re comfortable leaving this
    function alone without any further splitting.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务的函数是`all_real_words`。它将接受两个参数：真实单词列表和所有可能的单词列表。它将返回一个仅包含完整可能单词列表中真实单词的列表。这个函数的代码将涉及遍历可能单词列表，并检查每个单词是否出现在真实单词列表中。由于这个任务是一个小而定义良好的任务，不会产生很多代码，所以我们很放心地保留这个函数，不做任何进一步的拆分。
- en: 7.6 Summary of our top-down design
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 自顶向下设计的总结
- en: We’ve reached the end of our top-down design process. You can see our final
    top-down design in figure 7.4.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了自顶向下的设计过程。您可以在图7.4中看到我们的最终自顶向下设计。
- en: '![figure](../Images/7-4.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/7-4.png)'
- en: Figure 7.4 Functions diagram with the three subtasks of `all_possible_words`
    added
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.4 添加了`all_possible_words`三个子任务的函数图
- en: 'Let’s not lose the forest for the trees here. If we zoom out, what we’ve done
    is break down our original big problem into several smaller problems, each of
    which we’re going to implement as a function. Our original `spell_check` problem
    may have felt overwhelming. That’s OK, though, because we broke it down into one
    primary subtask of `get_spelling_suggestions`. The `get_spelling_suggestions`
    function is still a big problem in its own right, but we were able to solve that
    through the same process: we split it into three subtasks. Two of those subtasks,
    `create_word_list` and `all_real_words`, felt as though they could be solved in
    a single function, but the other task, `all_possible_words`, was complex enough
    that we felt it needed three more additional subtasks (`add_letter`, `delete_letter`,
    and `change_letter`). The important thing we want you to take away from this is
    that we used the same technique of problem decomposition at every step to turn
    an initially daunting task into just a collection of solvable subtasks that will
    become functions.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不要因为树木而忽略了森林。如果我们退一步看，我们所做的是将原始的大问题分解成几个更小的问题，我们将每个问题都作为函数来实现。我们的原始`spell_check`问题可能感觉令人望而生畏。不过，没关系，因为我们将其分解为`get_spelling_suggestions`的一个主要子任务。`get_spelling_suggestions`函数本身也是一个大问题，但我们能够通过相同的过程来解决它：我们将其分解为三个子任务。其中两个子任务`create_word_list`和`all_real_words`似乎可以作为一个函数解决，但另一个任务`all_possible_words`足够复杂，我们觉得它需要三个额外的子任务（`add_letter`、`delete_letter`和`change_letter`）。我们希望您从中学到的重要一点是，我们在每个步骤都使用了相同的问题分解技术，将最初令人畏惧的任务变成了一组可解决的子任务，这些子任务将成为函数。
- en: Our next step is to move from design to implementation. We know which functions
    we need now to solve our problem. It’s time for the code!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是从设计转向实施。我们知道现在需要哪些函数来解决我们的问题。是时候编写代码了！
- en: 7.7 Implementing our functions
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 实现我们的函数
- en: When you’re doing a top-down design, as we just did, you start with your overall
    problem and break it into subproblems. That’s why we started with `spell_check`
    (our overall problem) and eventually reached functions such as `add_letter`, which
    didn’t need any further splitting. But when we ask Copilot to implement these
    functions, we’re not going to work in the same order. Rather, we’re going to work
    in the *opposite* order, doing the smallest subproblems first, then moving onto
    the functions that depend on those subproblems. This corresponds to moving from
    right to left in a figure such as figure 7.4, starting with leaf functions and
    continuing to nonleaf functions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行自顶向下的设计时，就像我们刚才做的那样，你从整体问题开始，将其分解为子问题。这就是为什么我们从`spell_check`（我们的整体问题）开始，最终达到了像`add_letter`这样的函数，这些函数不需要进一步分解。但是当我们要求Copilot实现这些函数时，我们不会按照相同的顺序工作。相反，我们将以相反的顺序工作，首先做最小的子问题，然后转向依赖于这些子问题的函数。这对应于在如图7.4所示的图中从右到左移动。
- en: We implement functions in the opposite order like this so that Copilot knows
    about the smaller functions by the time we want to implement larger functions.
    That way, Copilot will be more likely to call our subtask functions as desired.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以这种方式以相反的顺序实现函数，这样Copilot在我们想要实现较大函数的时候就会了解较小的函数。这样，Copilot更有可能按照我们的期望调用我们的子任务函数。
- en: We want to stay squarely focused on problem decomposition here, and we’ve made
    some decisions toward that end. First, while we’ll include some tests in our docstrings,
    we won’t be pursuing full testing in this example as we would have done in chapter
    6\. We encourage you to use doctest to run the tests that we do provide as well
    as add your own tests for further confidence in the code. Second, we haven’t dwelled
    much on our prompt engineering, instead focusing on the prompts that yielded good
    results. In the next chapter, we’ll focus on debugging, and that’s where we’ll
    return to prompt engineering. Third, we’re not focusing on reading and understanding
    the code in full detail. That said, we’ve included some annotations to explain
    what the code is doing and how it works.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在这里完全专注于问题分解，为此我们已经做出了一些决定。首先，虽然我们将在文档字符串中包含一些测试，但在这个例子中，我们不会像在第6章中那样追求完整的测试。我们鼓励您使用doctest运行我们提供的测试，并添加您自己的测试以增加对代码的信心。其次，我们没有过多关注我们的提示工程，而是专注于产生良好结果的提示。在下一章中，我们将专注于调试，那时我们将回到提示工程。第三，我们不是专注于全面阅读和理解代码。话虽如此，我们包含了一些注释来解释代码正在做什么以及它是如何工作的。
- en: 7.7.1 create_word_list
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.1 create_word_list
- en: We’ll start with our `create_word_list` function. As in chapter 3, we write
    the function header (the `def` line) and the docstring, and Copilot fills in the
    code. This is how we’ll have Copilot write the code for all the functions in this
    chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们的`create_word_list`函数开始。正如第3章中所述，我们编写函数头（`def`行）和文档字符串，Copilot填写代码。这就是我们将让Copilot编写本章中所有函数代码的方式。
- en: 'We already know what our `create_word_list` function is supposed to do: read
    the words from the word list file and return them as a Python list of words. We
    carefully write what we want in the docstring, as shown in listing 7.1.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们的`create_word_list`函数应该做什么：从单词列表文件中读取单词，并以Python单词列表的形式返回它们。我们仔细地在文档字符串中写下我们想要的内容，如列表7.1所示。
- en: Listing 7.1 Function to read the list of words
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.1 读取单词列表的函数
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#1 The header we wrote ourselves'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们自己编写的头'
- en: '#2 The docstring we wrote ourselves'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们自己编写的文档字符串'
- en: '#3 Opens the file'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 打开文件'
- en: '#4 Loops through each line of the file'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 遍历文件的每一行'
- en: '#5 Adds each word to our list of words'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 将每个单词添加到我们的单词列表中'
- en: We’ve used a descriptive parameter name, `filename`, which gives a good clue
    to the purpose of the parameter. We’ve also been careful to use this parameter
    name in the docstring. Our docstring also makes it explicit that we want to *return*
    the list (rather than, say, print it).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个描述性的参数名称，`filename`，这为参数的目的提供了一个很好的提示。我们还小心地在这个文档字符串中使用这个参数名称。我们的文档字符串还明确指出，我们希望*返回*列表（而不是，比如说，打印它）。
- en: We haven’t included a test in the docstring for this function, and that’s because
    we didn’t want to distract from the overall goal of implementing each of our functions.
    If you wanted to, though, you know how! Specifically, we did this in chapter 6
    where we created a small file for purposes of testing. Here, you could create
    a small file with one word per line but with only a few English words, and then
    test that the list of words we read from the file matches the words that we put
    in the file. We’re finished with our `create_word_list` function, so we can mark
    it as complete as in figure 7.5.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在函数的文档字符串中包含测试，这是因为我们不希望分散实现我们每个函数的整体目标。尽管如此，如果你想要测试，你知道如何做！具体来说，我们在第 6
    章中这样做，在那里我们创建了一个小文件用于测试目的。在这里，你可以创建一个包含每行一个单词但只有几个英语单词的小文件，然后测试从文件中读取的单词列表是否与放入文件中的单词匹配。我们的
    `create_word_list` 函数已经完成，所以我们可以像图 7.5 中那样将其标记为完成。
- en: '![figure](../Images/7-5.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图形](../Images/7-5.png)'
- en: Figure 7.5 Full functions diagram with `create_word_list` finished
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.5 完整函数图，`create_word_list` 已完成
- en: To save space, we won’t show the updated figure after we implement each function,
    but we’ll show it occasionally.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，我们在实现每个函数后不会展示更新后的图形，但我们会偶尔展示。
- en: 7.7.2 add_letter
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.2 添加字母
- en: Now we’ll work on the functions that `all_possible_words` needs, starting with
    `add_letter`. The `add_letter` function takes a string as a parameter and returns
    the list of potential words that can be formed by adding one letter to that string.
    Let’s think briefly about what to expect from this function with a quick example.
    If we gave the function the string `cu` (as in table 7.2) it’s going to generate
    a list of words with every letter added to each possible position. This means
    it should include strings that have an `a` added before `cu` to make `acu`, a
    `b` added before `cu` to make `bcu`, and so forth for the character before `cu`
    stopping with `zcu`. The function should also include every letter in between
    `c` and `u` to form `cau`, `cbu`, `ccu`… . , `czu`. Lastly (as there are three
    possible positions to add a letter), we’d expect the function to add every possible
    letter after `cu` to form `cua`, `cub`, `cuc`,… . , `cuz`. Our prompt to Copilot
    and the code generated by Copilot is shown in listing 7.2.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将处理 `all_possible_words` 所需要的函数，从 `add_letter` 函数开始。`add_letter` 函数接受一个字符串作为参数，并返回通过向该字符串添加一个字母可以形成的潜在单词列表。让我们简要思考一下这个函数的预期输出，通过一个快速示例。如果我们给这个函数字符串
    `cu`（如表 7.2 所示），它将生成一个列表，其中包含每个字母添加到每个可能位置的字词。这意味着它应该包括在 `cu` 前添加 `a` 以形成 `acu`，在
    `cu` 前添加 `b` 以形成 `bcu`，以及对于 `cu` 前面的字符，直到 `zcu`。该函数还应包括 `c` 和 `u` 之间的每个字母，以形成
    `cau`、`cbu`、`ccu`…，直到 `czu`。最后（因为有三个可能的位置可以添加字母），我们期望该函数在 `cu` 之后添加每个可能的字母以形成
    `cua`、`cub`、`cuc`…，直到 `cuz`。我们的 Copilot 提示和 Copilot 生成的代码显示在列表 7.2 中。
- en: Listing 7.2 Function to add any possible letter
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2 添加任何可能字母的函数
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#1 Loops through each index, from 0 to just past the final character'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 遍历每个索引，从 0 到最后一个字符之后'
- en: '#2 Loops through each lowercase letter'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 遍历每个小写字母'
- en: '#3 Forms a new word by placing character c at index i'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 通过在索引 i 处放置字符 c 来形成新单词'
- en: '#4 Adds this new word to our list of words'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 将这个新单词添加到我们的单词列表中'
- en: The code here is quite subtle and deserves careful testing. For example, notice
    that the outer loop uses `len(word) + 1`, rather than the more standard `len(word)`.
    Without the `+ 1`, we would add characters at each existing index of the word
    string. But that would actually miss the fact that we also want to be able to
    add letters *past* the existing letters! The `+ 1` adds one extra iteration where
    we add a character to the end of the string.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码相当微妙，需要仔细测试。例如，注意外循环使用 `len(word) + 1`，而不是更标准的 `len(word)`。如果没有 `+ 1`，我们将在单词字符串的每个现有索引处添加字符。但实际上，我们会错过我们还想能够在现有字母之后添加字母的事实！`+
    1` 添加了一个额外的迭代，在这个迭代中我们在字符串的末尾添加了一个字符。
- en: For each index of the outer loop, we consider each possible lowercase letter
    in the inner loop. The line `new_word = word[:i] + c + word[i:]` uses string slicing,
    the technique of extracting letters out of a string using two indices, to add
    the current inner-loop character to the current outer-loop position.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于外循环的每个索引，我们在内循环中考虑每个可能的 lowercase 字母。代码行 `new_word = word[:i] + c + word[i:]`
    使用了字符串切片技术，即通过两个索引从字符串中提取字母，以将当前内循环字符添加到当前外循环位置。
- en: Although we aren’t spending much time on testing in this chapter because the
    focus is problem decomposition, you would want to test this function by giving
    it a single misspelled word (i.e., *cu*) and then printing the returned words
    and ensuring it includes strings such as `acu` (add at the start), `cau` (add
    in the middle), and `cua` (add at the end), as well as possible real words such
    as *cup* and *cut*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在本章中花费在测试上的时间不多，因为重点是问题分解，但你仍然想通过给这个函数一个单个的拼写错误单词（即 *cu*）来测试它，然后打印返回的单词并确保它包括诸如
    `acu`（在开头添加），`cau`（在中间添加），和 `cua`（在末尾添加）这样的字符串，以及可能的真实单词如 *cup* 和 *cut*。
- en: 'Note that we wouldn’t want to include exact tests in the docstring because
    the lists returned by this function are huge! For example, try typing this at
    the Python prompt:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不想在文档字符串中包含确切的测试，因为这个函数返回的列表非常大！例如，尝试在 Python 提示符中输入以下内容：
- en: '[PRE2]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ll get a list with 78 strings in it! And that’s for our tiny `'cu'` string.
    The number of strings returned in the list grows significantly as we increase
    the number of characters in the parameter string.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到一个包含 78 个字符串的列表！这是针对我们微小的 `'cu'` 字符串。随着参数字符串中字符数量的增加，列表中返回的字符串数量会显著增加。
- en: 7.7.3 delete_letter
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.3 delete_letter
- en: Like `add_letter`, `delete_letter` takes a string as a parameter and returns
    a list of potential words. The difference is that rather than adding a letter,
    `delete_letter` deletes each possible letter from the string to arrive at new
    possible words. Let’s think about what we expect this function to do. If we give
    it the string “carf”, it should try deleting each letter to produce the strings
    “arf” by deleting “c”, “crf” by deleting “a”, “caf” by deleting “r”, and “car”
    by deleting “f”. Again, we gave the prompt to Copilot for this function, as shown
    in listing 7.3.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `add_letter` 类似，`delete_letter` 函数接受一个字符串作为参数并返回一个潜在单词的列表。不同之处在于，`delete_letter`
    不是添加一个字母，而是从字符串中删除每个可能的字母以到达新的可能单词。让我们思考我们期望这个函数做什么。如果我们给它字符串 “carf”，它应该尝试删除每个字母以产生字符串
    “arf”（通过删除 “c”），“crf”（通过删除 “a”），“caf”（通过删除 “r”），和 “car”（通过删除 “f”）。同样，我们为这个函数提供了提示，如列表
    7.3 所示。
- en: Listing 7.3 Function to delete any letter
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3 删除任何字母的函数
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 Loops through each index, from 0 to the final character'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 遍历每个索引，从 0 到最后一个字符'
- en: '#2 Forms a new word by deleting character at index i'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 通过删除索引 i 处的字符形成新词'
- en: '#3 Adds this new word to our list of words'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 将这个新词添加到我们的单词列表中'
- en: This code is similar to our code for `add_letter`. One difference is that we
    have only one loop this time, not two. The reason is that we don’t need an inner
    loop to loop through the letters *a*, *b*, *c*, *d*, and so on. That’s because
    we’re deleting letters that already exist in the word, rather than figuring out
    which letter to add.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们的 `add_letter` 函数代码类似。一个不同之处在于，这次我们只有一个循环，而不是两个。原因是，我们不需要内循环来遍历字母 *a*、*b*、*c*、*d*
    等等。那是因为我们是在删除单词中已经存在的字母，而不是确定要添加哪个字母。
- en: 7.7.4 change_letter
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.4 change_letter
- en: 'Now, it’s time for our third and final subtask of `all_possible_words: change_letter`!
    This function is responsible for generating words where one letter in the string
    is changed to some other letter. In thinking about what we’d like to see happen
    here, let’s consider the string `cu` again (as in table 7.2). We want this function
    to replace the letter *c* with all possible letters to create the strings `au`,
    `bu`, `du`… . , `zu` and to replace the letter *u* with all possible letters to
    create the strings `ca`, `cb`, `cc`… . , `cz`. (Note that we omit trying `cu`
    as that’s the initial string, we only consider changes to letters.) See listing
    7.4 for our prompt and the code from Copilot.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是我们 `all_possible_words` 的第三个也是最后一个子任务 `change_letter` 的时候了！这个函数负责生成将字符串中的一个字母更改为其他字母的单词。在思考我们希望在这里看到什么时，让我们再次考虑字符串
    `cu`（如表 7.2 所示）。我们希望这个函数将字母 *c* 替换为所有可能的字母以创建字符串 `au`、`bu`、`du`… . ，以及将字母 *u*
    替换为所有可能的字母以创建字符串 `ca`、`cb`、`cc`… . ，`cz`。 （注意，我们省略了尝试 `cu`，因为那是初始字符串，我们只考虑字母的变化。）请参阅列表
    7.4 中的提示和 Copilot 的代码。
- en: Listing 7.4 Function to change any letter
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4 修改任何字母的函数
- en: '[PRE4]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 Loops through each index, from 0 to the final character'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 遍历每个索引，从 0 到最后一个字符'
- en: '#2 Loops through each lowercase letter'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 遍历每个小写字母'
- en: '#3 If c is a different letter from the letter at index i'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 如果 c 与索引 i 处的字母不同'
- en: '#4 Forms a new word by changing the character at index i to character c'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 通过将索引 i 处的字符更改为字符 c 形成新词'
- en: '#5 Adds this new word to our list of words'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 将这个新词添加到我们的单词列表中'
- en: This code is quite similar to our `add_letter` code! The main difference is
    that we use string slicing not to add a new character but to change an existing
    character.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们`add_letter`的代码非常相似！主要区别在于我们使用字符串切片不是添加新字符，而是更改现有字符。
- en: At this point, we’ve completed the three functions we need to implement `all_possible_words`.
    Check out figure 7.6, where we’ve marked off the substantial progress that we’ve
    made! We’ll next tackle `all_possible_words`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了实现`all_possible_words`所需的三个函数。查看图7.6，我们标记了我们所取得的重大进展！接下来，我们将处理`all_possible_words`。
- en: '![figure](../Images/7-6.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/7-6.png)'
- en: Figure 7.6 Full functions diagram with `all_possible_words` helper functions
    finished
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.6 完整的功能图，`all_possible_words`辅助函数已完成
- en: 7.7.5 all_possible_words
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.5 all_possible_words
- en: The reason we can now implement `all_possible_words` is that we’ve already implemented
    the three subtask functions that `all_possible_words` needs to do its job. When
    we ask Copilot to write this code, we’re expecting to see calls of `add_letter`,
    `delete_letter`, and `change_letter`. Take a look at listing 7.5, and you’ll see
    Copilot doing exactly this with the prompt we’ve given it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够实现`all_possible_words`的原因是我们已经实现了`all_possible_words`完成其工作所需的三个子任务函数。当我们要求Copilot编写这段代码时，我们期望看到对`add_letter`、`delete_letter`和`change_letter`的调用。查看列表7.5，你会发现Copilot确实按照我们给出的提示做了这件事。
- en: Listing 7.5 Function to generate all possible words
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.5 生成所有可能单词的函数
- en: '[PRE5]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '#1 Calls helper functions to add a letter and delete a letter'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 调用辅助函数来添加字母和删除字母'
- en: '#2 Calls helper function to change a letter'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 调用辅助函数来更改字母'
- en: 'Generating all possible words is no easy feat. Yet, we’ve managed to do it
    with a single line of Python code here! It just calls to three helper functions
    and that’s it. This is exactly why we’re doing top-down design: to make complex
    functions much easier to implement by offloading much of their complexity to helper
    functions.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 生成所有可能的单词并非易事。然而，我们在这里用一行Python代码就做到了！它只是调用了三个辅助函数，就是这样。这正是我们进行自顶向下设计的原因：通过将大部分复杂性转移到辅助函数，使复杂函数的实现变得更加容易。
- en: 7.7.6 all_real_words
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.6 all_real_words
- en: We’re close to being able to implement `get_spelling_suggestions`, but not quite,
    because we first need to implement its subtask function `all_real_words`. The
    `all_ real_words` function takes two parameters. The first parameter is the English
    word list (this will come from an English word list file). The second parameter
    is the list of possible words (this will come from `all_possible_words`). The
    function returns the list of possible words that are real words. Let’s do this!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接近能够实现`get_spelling_suggestions`，但还不是完全接近，因为我们首先需要实现它的子任务函数`all_real_words`。`all_real_words`函数接受两个参数。第一个参数是英语单词列表（这将从英语单词列表文件中获取）。第二个参数是可能的单词列表（这将从`all_possible_words`中获取）。该函数返回可能的单词列表，这些单词是真实单词。让我们来做这件事！
- en: Listing 7.6 Function to generate all real words
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.6 生成所有真实单词的函数
- en: '[PRE6]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '#1 Loops through the possible words'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 遍历可能的单词'
- en: '#2 Is this word a real word?'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这个单词是真实单词吗？'
- en: '#3 Yes: add the word to the list of real words that we’ll return'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 是的：将单词添加到我们将返回的真实单词列表中'
- en: The test in the docstring is a good example of how this function works. It’s
    using the `english_words` list for the first parameter and the `possible_words`
    list as the second parameter. The function will return those words from `possible_words`
    that are also in `english_words`. We’re using this very small test case, rather
    than using thousands of English words, because this makes it much easier for us
    to determine by hand what the correct return value should be!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串中的测试是一个很好的例子，说明了这个函数是如何工作的。它使用`english_words`列表作为第一个参数，`possible_words`列表作为第二个参数。函数将返回`possible_words`中也在`english_words`中的那些单词。我们使用这个非常小的测试案例，而不是使用成千上万的英语单词，因为这使我们能够更容易地手动确定正确的返回值！
- en: Let’s check how well we’re progressing in figure 7.7\. We’re getting close—just
    two functions to go!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下图7.7中我们的进度如何。我们接近完成了——只剩下两个函数需要完成！
- en: '![figure](../Images/7-7.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/7-7.png)'
- en: Figure 7.7 Full functions diagram with `all_possible_words` and `all_real_words`
    finished
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.7 完整的功能图，`all_possible_words`和`all_real_words`已完成
- en: 7.7.7 get_spelling_suggestions
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.7 get_spelling_suggestions
- en: We’ve implemented `create_word_list`, `all_possible_words`, and `all_real_words`,
    and those are the only three subtask functions that `get_spelling_suggestions`
    needs. That means it’s time for us to implement `get_spelling_suggestions`!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了`create_word_list`、`all_possible_words`和`all_real_words`，这些是`get_spelling_suggestions`需要的唯一三个子任务函数。这意味着是我们实现`get_spelling_suggestions`的时候了！
- en: 'This function takes two parameters: the name of a file that contains real words
    (one word per line) and the string that we want to provide suggestions for. It
    returns the list of the unique suggestions. As always, when scrutinizing Copilot
    code for a nonleaf function, you want to check that it’s calling the helper functions
    that you expect it to be calling, as shown in listing 7.7\. Before you move on,
    convince yourself that it’s calling all the helper functions that it should be
    calling.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数：包含真实单词的文件名（每行一个单词）以及我们想要提供建议的字符串。它返回唯一建议的列表。像往常一样，当审查Copilot的非叶函数代码时，你想要检查它是否调用了你期望它调用的辅助函数，如列表7.7所示。在你继续之前，请确保它调用了它应该调用的所有辅助函数。
- en: Listing 7.7 Function to return spelling suggestions
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.7 返回拼写建议的函数
- en: '[PRE7]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 Gets the list of English words'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 获取英语单词列表'
- en: '#2 Gets the list of possible words'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 获取可能的单词列表'
- en: '#3 Figures out which possible words are spelling suggestions'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 确定哪些可能的单词是拼写建议'
- en: '#4 Returns the unique list of spelling suggestions'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 返回唯一的拼写建议列表'
- en: 'That last line there is tricky. Apparently, it’s ensuring that we return only
    unique words—but how? Let’s ask Copilot to explain! Here’s the explanation that
    we got when we used the `/explain` command to Copilot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 那最后一行有点棘手。显然，它确保我们只返回唯一的单词——但是如何做到的呢？让我们问问Copilot来解释！当我们使用`/explain`命令询问Copilot时，我们得到了以下解释：
- en: '![chatGpt](../Images/chatGpt.png)Copilot This line of Python code is performing
    two operations:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)Copilot 这行Python代码执行了两个操作：'
- en: '`set(real_words)`: This is creating a set from the `real_words` list. A set
    in Python is an unordered collection of unique elements. So, this operation is
    removing any duplicate elements from the `real_words` list.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`set(real_words)`：这是从`real_words`列表创建一个集合。在Python中，集合是一个无序的唯一元素集合。因此，这个操作是从`real_words`列表中删除任何重复的元素。'
- en: '`list(set(real_words))`: This is converting the set back into a list. The result
    is a list where all elements are unique.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`list(set(real_words))`：这是将集合转换回列表。结果是所有元素都是唯一的列表。'
- en: So, in summary, this line of code is removing any duplicate words from the `real_
    words` list.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结来说，这一行代码是从`real_words`列表中删除任何重复的单词。
- en: 7.7.8 spell_check
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.8 spell_check
- en: 'We’ve made it to our final function, `spell_check`! It takes one parameter:
    a string indicating the name of a word list file. It asks the user to type a string,
    and then shows the user all spelling corrections for that string.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了我们的最终功能，`spell_check`！它接受一个参数：一个表示单词列表文件名称的字符串。它会要求用户输入一个字符串，然后显示该字符串的所有拼写修正。
- en: Listing 7.8 Our main function that interacts with the user
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.8 与用户交互的主要函数
- en: '[PRE8]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 Asks the user to type a string'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 要求用户输入一个字符串'
- en: '#2 Gets the spelling suggestions for the user'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 获取用户的拼写建议'
- en: '#3 Loops through the spelling suggestions'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 遍历拼写建议'
- en: '#4 Prints each spelling suggestion on its own line'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 在单独的一行上打印每个拼写建议'
- en: Consult figure 7.8 to see that we have indeed implemented all of our functions!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考图7.8，以确认我们已经实现了所有我们的函数！
- en: '![figure](../Images/7-8.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/7-8.png)'
- en: Figure 7.8 Full functions diagram with all functions complete!
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.8 完整功能图，所有功能均已完整！
- en: 'You need to add one line of code at the bottom of your Python program to actually
    call this function. Otherwise, your program won’t do anything because no function
    is being called! So, add this line at the bottom:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的Python程序底部添加一行代码来实际调用这个函数。否则，你的程序将不会做任何事情，因为没有函数被调用！所以，在底部添加这一行：
- en: '[PRE9]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, assuming that you have the wordlist.txt file in your directory along with
    your Python program, you can run it! It will ask you to type a word. Try typing
    the misspelled word *sucessful* (the word that started it all!), and you should
    see the program provide the spelling suggestion of *successful*, like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你已经在你的目录中有了wordlist.txt文件以及你的Python程序，你可以运行它！它会要求你输入一个单词。尝试输入拼写错误的单词*sucessful*（这一切的起点！），你应该看到程序提供拼写建议*successful*，如下所示：
- en: '[PRE10]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Try other misspelled words too, such as *thourough* and *acceptible*. With these
    misspelled words so far, our program is replying with only a single spelling suggestion
    because there is only one real word a single edit away from the words we’re trying.
    We encourage you to try entering the word *carf* to see that our program can provide
    many possible spelling suggestions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 也尝试其他拼写错误的单词，例如 *thourough* 和 *acceptible*。到目前为止，由于只有一个真正的单词与我们要尝试的单词只有一个编辑距离，我们的程序只回复了一个拼写建议。我们鼓励你尝试输入单词
    *carf*，看看我们的程序能否提供许多可能的拼写建议。
- en: Congratulations! You’ve completed your first real-world top-down design. Your
    program provides spelling suggestions for a word, much as a spellchecker does.
    We made the problem considerably easier to implement by doing some up-front design
    work to break down the original problem into smaller subproblems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了你的第一个真正的自上而下的设计。你的程序为单词提供拼写建议，就像拼写检查器一样。我们通过一些前期设计工作，将原始问题分解成更小的子问题，使得问题实现起来变得容易得多。
- en: 'Many computer scientists view problem decomposition as *the* most critical
    skill needed to write good software [1]. We saw the value of problem decomposition
    in this chapter: it made a large problem solvable by breaking it into smaller
    steps until each step was easier to solve. We applied this skill in this chapter
    using top-down design (start with the large task and break it into smaller tasks)
    to put it in practice. This skill remains critical when working with tools such
    as Copilot and ChatGPT because they perform better when solving small, well-defined
    problems compared to large problems. As mentioned at the beginning of the chapter,
    problem decomposition is more of an art than a science, and it takes practice
    to get it right. We’ll do more problem decomposition in our upcoming chapters
    to help give you more intuition into how to approach it yourself.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机科学家认为问题分解是编写良好软件所需的最关键技能[1]。我们在本章中看到了问题分解的价值：它通过将其分解成更小的步骤，直到每个步骤都更容易解决，使得大问题变得可解。我们通过本章使用自上而下的设计（从大任务开始，将其分解成更小的任务）来应用这项技能。当使用Copilot和ChatGPT等工具时，这项技能仍然至关重要，因为它们在解决小而定义明确的问题时表现更好，而不是大问题。如本章开头所述，问题分解更多的是一种艺术，而不是科学，而且需要练习才能做得正确。我们将在接下来的章节中进行更多的问题分解，以帮助你更好地理解如何自己处理它。
- en: 7.8 Exercises
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8 练习
- en: 'Using the examples of `get_strong_password` and `best_word` discussed previously,
    let’s apply the top-down design approach to a new problem. Suppose we want to
    write a function called `find_highest_scoring_word` that takes a list of sentences
    as its parameter and returns the word with the highest score from all the sentences.
    Each word’s score is calculated the same way as in the `best_word` function:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前讨论过的 `get_strong_password` 和 `best_word` 的例子，让我们将自上而下的设计方法应用到新的问题上。假设我们想要编写一个名为
    `find_highest_scoring_word` 的函数，它接受一个句子列表作为参数，并返回所有句子中得分最高的单词。每个单词的得分计算方式与 `best_word`
    函数中的方式相同：
- en: Identify the subtasks needed to solve this problem. What are the individual
    functions you would design to break down the task into smaller, manageable pieces?
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定解决此问题所需的子任务。你会设计哪些单独的函数来将任务分解成更小、更易管理的部分？
- en: Draw a function diagram similar to figures 7.1 and 7.2, depicting how these
    functions would call each other to solve the overall problem.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个类似于图7.1和7.2的功能图，描述这些函数如何相互调用以解决整体问题。
- en: We talked about how sometimes a task is simple enough to be kept as it is, that
    is, not broken down into smaller tasks. Given the following tasks, decide if you
    would divide them into smaller subtasks. If so, list the subtasks and explain
    why. If not, explain why the task is simple enough to remain a single function.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们讨论了有时一个任务足够简单，可以保持原样，即不分解成更小的任务。针对以下任务，决定你是否会将其分解成更小的子任务。如果是，列出子任务并解释原因。如果不是，解释为什么任务足够简单，可以保持为一个单独的函数。
- en: Reading a file and printing its contents
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取文件并打印其内容
- en: Calculating the average grade for a class of students from a list of scores
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算学生成绩列表的平均成绩
- en: Finding the maximum value in a list of numbers
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数字列表中找到最大值
- en: Processing an order for an online store, which includes verifying the order,
    calculating the total price, applying discounts, and generating an invoice
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理在线商店的订单，包括验证订单、计算总价、应用折扣和生成发票
- en: Why did we choose to create the `create_word_list` function as a separate function?
    Could this task be kept as part of a larger function? Explain your reasoning.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们选择将`create_word_list`函数作为一个单独的函数来创建？这个任务能否作为更大函数的一部分保留？请解释你的理由。
- en: Imagine you need to change the way the spell-checker works. Specifically, you
    want to modify the `add_letter` function to exclude certain letters (e.g., *q*,
    *x*, *z*) from being added. How would you modify the program we’ve written?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你需要改变拼写检查器的工作方式。具体来说，你想要修改`add_letter`函数，以排除某些字母（例如，*q*，*x*，*z*）的添加。你将如何修改我们编写的程序？
- en: The following function processes a list of orders, calculates the total price
    with tax, applies a discount if applicable, and generates a summary report.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数处理订单列表，计算含税的总价，如果适用则应用折扣，并生成总结报告。
- en: '[PRE11]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Refactor (redesign) the `process_orders` function by breaking it down into smaller
    subproblems. Implement each subproblem as a separate function, and ensure the
    overall behavior remains the same.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其分解成更小的子问题来重构（重新设计）`process_orders`函数。将每个子问题实现为一个单独的函数，并确保整体行为保持不变。
- en: '6\. In this exercise, you’re given a code snippet already broken down into
    two functions: a main function and a helper function. When we call the function
    with Test Case 2 in the following code, we get a `ZeroDivisionError`. Your task
    is to identify and fix the error based on the provided error message.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6. 在这个练习中，你已经给出了一个代码片段，它已经被分解成两个函数：一个主函数和一个辅助函数。当我们使用以下代码中的测试用例2调用函数时，我们得到一个`ZeroDivisionError`错误。你的任务是根据提供的错误信息识别并修复错误。
- en: '[PRE12]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We need to divide a big programming problem into smaller subproblems before
    we can effectively implement it. This is known as problem decomposition.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将一个大型的编程问题分解成更小的子问题，然后才能有效地实现它。这被称为问题分解。
- en: Top-down design is a systematic technique for breaking a problem down into small
    subtask functions.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自顶向下设计是一种将问题分解成小任务函数的系统技术。
- en: In top-down design, we seek small functions that solve well-defined tasks and
    that can be used by one or more other functions.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自顶向下设计中，我们寻求解决定义明确的任务的小函数，并且这些函数可以被一个或多个其他函数使用。
- en: When we’re ready to implement our functions that arose from top-down design,
    we implement them from the bottom up; that is, we implement the leaf functions
    first, then functions that depend on those leaf functions, and so on until we
    implement the topmost function.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们准备实现从自顶向下设计产生的函数时，我们是从下往上实现的；也就是说，我们首先实现叶函数，然后是实现依赖于这些叶函数的函数，依此类推，直到我们实现了最顶层的函数。
