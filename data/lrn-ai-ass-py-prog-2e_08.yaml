- en: 9 *Automating tedious tasks*
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 *自动化繁琐的任务*
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding why programmers write tools
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解程序员编写工具的原因
- en: Determining which modules we need to write a given tool
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定我们需要编写特定工具的模块
- en: Automating cleaning up emails that have > > > symbols
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化清理带有> > >符号的电子邮件
- en: Automating manipulating PDF files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化操作PDF文件
- en: Automating removing duplicate pictures across multiple image libraries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化在多个图像库中删除重复图片
- en: Suppose that you’re responsible for creating 100 reports, one for each of 100
    people. Perhaps you’re a teacher and need to send a report to each of your students.
    Perhaps you work for HR and need to send an annual assessment report to each employee.
    Regardless of your role, you have the problem of having to create these reports,
    and you decided to prepare your reports as .pdf files. You need a customized cover
    page for each report too, and those cover pages are designed by one of your colleagues
    (a graphic design artist).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你负责创建100份报告，每份报告对应100个人中的每一个。也许你是一名教师，需要给每个学生发送一份报告。也许你在人力资源部门工作，需要给每个员工发送年度评估报告。无论你的角色如何，你都有必须创建这些报告的问题，你决定将这些报告作为.pdf文件准备。你还需要为每份报告准备定制的封面页，这些封面页是由你的同事（一位平面设计师）设计的。
- en: You and your colleague work independently, and, finally, the job is done. Or
    wait, not so fast. Because now you have to put each cover page at the beginning
    of each report.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你和你的同事独立工作，最后工作完成了。或者等等，不是那么快。因为现在你必须将每个封面页放在每份报告的开头。
- en: At this point, a nonprogrammer might grit their teeth and start on the job,
    manually merging the cover page with the first report, the second cover page with
    the second report, and so on. That could take hours. Not knowing that there may
    be another way, a nonprogrammer may just power ahead until the job is done.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，一个非程序员可能会咬紧牙关开始工作，手动将封面页与第一份报告合并，第二封面页与第二份报告合并，以此类推。这可能会花费数小时。由于不知道还有其他方法，一个非程序员可能会一直努力直到工作完成。
- en: But you’re a programmer now. And most programmers, the two of us included, would
    never power ahead with manual work like this.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但你现在是一名程序员。而且大多数程序员，包括我们两个，都不会手动进行这样的工作。
- en: In this chapter, we’re going to show you how to write programs to automate tedious
    tasks. The second example in the chapter will automate the “merging cover pages
    with reports” situation. But we’ll do others as well. Received an email that’s
    been forwarded so many times
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向你展示如何编写程序来自动化繁琐的任务。章节中的第二个例子将自动化“合并封面页与报告”的情况。但我们还会做其他的事情。收到已被转发多次的电子邮件
- en: that it looks
  id: totrans-12
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它看起来
- en: like
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样
- en: this?
  id: totrans-14
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个？
- en: Or does your family have several phones, each with hundreds of images, and you
    just want to get the images all in the same place so that you can archive them
    without losing anything? In this chapter, we’ll show you how to automate tasks
    like that.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你的家人有几部手机，每部手机都有几百张图片，你只是想将所有图片放在同一个地方，以便你可以归档它们而不会丢失任何东西？在本章中，我们将向你展示如何自动化这类任务。
- en: 9.1 Why programmers make tools
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 为什么程序员要制作工具
- en: 'There’s a common sentiment that programmers often express: we’re lazy. This
    doesn’t mean that we don’t want to do our work. It means that we don’t want to
    do *repetitive, boring, tedious* work because that’s what computers are good at.
    Programmers develop a sort of spidey-sense for this kind of drudgery. Suppose
    Leo has a few hundred photos, and he wants to delete any photos that are duplicates.
    There’s no way he’d do this by hand. Or suppose that Dan has to send out a customized
    email to each of his students. If it’s more than a few students, there’s no way
    he’s doing this by hand. As soon as programmers start noticing that they’re repeating
    the same keys on the keyboard or working through the same steps over and over,
    they’ll stop and make a tool to automate it.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员常常表达的一种普遍观点是：我们很懒惰。这并不意味着我们不想完成我们的工作。这意味着我们不想做那些重复、无聊、繁琐的工作，因为那是计算机擅长的事情。程序员对这种苦差事有一种类似蜘蛛侠的感觉。假设Leo有几百张照片，他想要删除任何重复的照片。他不可能手动做这件事。或者假设Dan必须给他的每个学生发送定制的电子邮件。如果学生人数超过几个，他也不可能手动做这件事。一旦程序员开始注意到他们在键盘上重复相同的按键或一遍又一遍地执行相同的步骤，他们就会停下来，制作一个工具来自动化这个过程。
- en: When programmers talk about tools, they’re talking about programs that do something
    that saves them time. A tool often isn’t the end goal, and writing one can itself
    feel tedious and not glamorous. But once we have a tool, we can use it to save
    us time. Sometimes, we’ll use a tool once, for one specific job, and then never
    again. Commonly, though, a tool ends up being useful over and over, whether we
    use the tool exactly as we wrote it or by making some small changes. For example,
    after Dan finishes teaching each course, he uses a program he wrote to collate
    all student grades and submit them to the university. He makes small changes to
    the tool each time—changing the weights of each assignment, for example—but then
    Dan can use that slightly modified tool to do the work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员谈论工具时，他们是在谈论那些能节省他们时间的程序。一个工具通常不是最终目标，编写一个工具本身可能会感觉枯燥乏味，并不光彩。但一旦我们有了工具，我们就可以用它来节省时间。有时，我们可能会用一次工具，完成一项特定的任务，然后就不会再用了。然而，通常情况下，一个工具会反复被证明是有用的，无论是我们按照我们编写的方式使用它，还是通过做一些小的改动。例如，丹完成每一门课程的授课后，他会使用自己编写的程序来整理所有学生的成绩并提交给大学。每次他都会对工具做一些小的改动——比如改变每个作业的权重——但丹就可以使用这个略微修改过的工具来完成工作。
- en: 'The great thing about using Copilot is that it makes cranking out these tools
    easier. Here’s how one software engineer explains it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Copilot 的好处是它使制作这些工具变得更加容易。以下是某位软件工程师的解释：
- en: We all know that tools are important, that effective tools are challenging to
    create, and that management doesn’t care or understand the need for tools. . .
    . I can’t express how fundamentally different programming feels now that I can
    build two quality tools per day, for every single itch I want to scratch. [1]
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们都知道工具很重要，有效的工具很难创建，而管理层并不关心或理解对工具的需求……我无法表达现在编程感觉有多么根本性地不同，因为我现在每天可以构建两个质量工具，以满足我每一个想要解决的问题。[1]
- en: 9.2 How to use Copilot to write tools
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 如何使用 Copilot 编写工具
- en: As we learned in chapter 5 when talking about modules, sometimes we need to
    use a module to help us write the program we want. Some modules are built into
    Python. For example, in chapter 5, we used the built-in zipfile module to help
    us create a .zip file. Other modules aren’t built in, and we need to install them
    first before we can use them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 5 章讨论模块时所学到的，有时我们需要使用一个模块来帮助我们编写我们想要的程序。一些模块是内置在 Python 中的。例如，在第 5 章中，我们使用了内置的
    zipfile 模块来帮助我们创建一个 .zip 文件。其他模块不是内置的，我们需要先安装它们才能使用。
- en: When writing a tool, it’s often the case that we’ll be working with some specialized
    data format (zip files, PDF files, Microsoft Excel spreadsheets, images) or performing
    some specialized task (sending email, interacting with a website, moving files
    around). For most of this, we’re going to need to use a module. Which module,
    though? And is it built in, or do we need to install it? These are the first questions
    we need to get answers to.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写工具时，我们通常需要处理一些特殊的数据格式（zip 文件、PDF 文件、Microsoft Excel 电子表格、图像）或执行一些特殊的任务（发送电子邮件、与网站交互、移动文件）。对于大多数这些任务，我们都需要使用一个模块。那么，是哪个模块呢？它是内置的还是我们需要安装它？这是我们首先需要得到答案的问题。
- en: Fortunately, we can use Copilot Chat (or ChatGPT) to help us get started. As
    a reminder, we’re using the Copilot Chat feature because it’s built into our Visual
    Studio Code (VS Code) IDE and because Copilot Chat has access to the very code
    we’re currently writing so it can incorporate what we’re doing into its answers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以使用 Copilot Chat（或 ChatGPT）来帮助我们开始。作为提醒，我们使用 Copilot Chat 功能是因为它内置在我们的
    Visual Studio Code（VS Code）IDE 中，并且因为 Copilot Chat 可以访问我们目前正在编写的代码，因此它可以将其所做的工作纳入其答案中。
- en: 'The plan is to have a conversation with Copilot to determine which module we
    need to use. Once we know that and install the module, if necessary, then we can
    get down to the business of writing the code for our tool. We’ll do that the way
    we’ve always done it: by writing the function header and a docstring and having
    Copilot fill in the code for us. Once Copilot starts writing code, we need to
    follow the same steps as in previous chapters, including checking code correctness,
    fixing bugs, and maybe even doing some problem decomposition. To focus our attention
    on writing tools to automate tasks, we’ll minimize the time we spend on these
    additional tasks here.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是与 Copilot 进行对话，以确定我们需要使用哪个模块。一旦我们知道这一点并安装了模块（如果需要的话），我们就可以着手编写我们工具的代码了。我们将像以前一样做：编写函数头和文档字符串，让
    Copilot 填写代码。一旦 Copilot 开始编写代码，我们需要遵循与前面章节相同的步骤，包括检查代码正确性、修复错误，甚至可能进行一些问题分解。为了将我们的注意力集中在编写自动化任务的工具上，我们将尽量减少在这些额外任务上花费的时间。
- en: It may be possible to ask Copilot or ChatGPT to write the entire tool for us,
    without even having to put it inside of a function. We won’t do that here, though,
    because we still think that the benefits of functions are worthwhile. A function
    will help us document our code so that we know what it does, and it enables flexibility
    if we later decide, for example, to add additional parameters to our function
    to change the behavior of the tool.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可能可以向 Copilot 或 ChatGPT 请求为我们编写整个工具，甚至不需要将其放入函数中。不过，我们在这里不会这样做，因为我们仍然认为函数的好处是值得的。函数将帮助我们记录代码，以便我们知道它做什么，并且它使我们能够在以后决定，例如，向函数添加额外的参数以改变工具的行为。
- en: '9.3 Example 1: Cleaning up email text'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 示例 1：清理电子邮件文本
- en: 'Sometimes, an email gets replied to and forwarded so many times that it becomes
    a mess, with many greater than (>) signs and spaces on some of the lines. Here’s
    a sample email of what we mean:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一封电子邮件被回复和转发多次，变得一团糟，有些行上有许多大于（>）符号和空格。以下是我们所指的样本电子邮件：
- en: Hi Leo,
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 嗨，利奥，
- en: Dan -- any luck with your natural language research?
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 丹 -- 你的自然语言研究有什么进展吗？
- en: Yes! That website you showed me
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是的！你给我看的那个网站
- en: '[https://www.kaggle.com/](https://www.kaggle.com/)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.kaggle.com/](https://www.kaggle.com/)'
- en: is very useful. I found a dataset on there that collects
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 非常有用。我在那里找到一个数据集，它收集了
- en: a lot
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 很多
- en: of questions and answers that might be useful to my research.
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可能对我的研究有用的问答。
- en: Thank you,
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 谢谢，
- en: Dan
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 丹
- en: 'Suppose that you wanted to save this email information for future use. You
    might like to clean up the > and space symbols at the start of lines. You could
    start manually deleting them—this email isn’t that long, after all—but don’t do
    that because here you have an opportunity to design a general-purpose tool that
    you can use whenever you need to perform this task. Whether your email has five
    lines, a hundred lines, or a million lines, it won’t matter: just use the tool
    and be done.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想保存这封电子邮件信息以备将来使用。你可能希望清理行首的>和空格符号。你可以开始手动删除它们——毕竟，这封电子邮件并不长——但不要这样做，因为这里你有机会设计一个通用的工具，你可以在需要执行此任务时使用它。无论你的电子邮件有五行、一百行还是一百万行，这都不会有关系：只需使用工具，完成任务即可。
- en: 9.3.1 Conversing with Copilot
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 与 Copilot 对话
- en: We need to make the messy email available to our tool so that the tool can clean
    it up. One way we can do this is to first copy the text of an email to the clipboard
    (using your Copy to Clipboard command on your operating system, such as Ctrl-C).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要让杂乱的电子邮件可供我们的工具使用，以便工具可以清理它。我们可以做到这一点的一种方法是将电子邮件的文本首先复制到剪贴板（使用您操作系统的复制到剪贴板命令，例如
    Ctrl-C）。
- en: Each computer operating system has a clipboard to store the last thing copied.
    If you’ve ever used Copy-Paste, you’ve used that clipboard. We’re going to use
    the clipboard for temporary storage of text so we can edit the text in the clipboard
    and then paste it where we need it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个计算机操作系统都有一个剪贴板来存储最后复制的内容。如果你曾经使用过复制粘贴，你就使用过那个剪贴板。我们将使用剪贴板作为文本的临时存储，以便我们可以在剪贴板中编辑文本，然后将其粘贴到所需的位置。
- en: After copying the text from the messy email to the clipboard, we could then
    run the tool on the text in the clipboard, and the tool could clean up the email
    and replace the clipboard contents with the cleaned-up version. For the tool to
    do something reasonable, we assume that your clipboard has email text on it. The
    tool will remove the > and space characters at the start of each line so that
    you can paste (using your operating system Paste command, such as Ctrl-V) the
    newly cleaned-up email wherever you want. In terms of Python, it will need to
    pull the clipboard contents into a string (i.e., copy the contents of the clipboard),
    clean it up, and then put that new cleaned-up text back on the clipboard (i.e.,
    paste to the clipboard), replacing the junky version of the email that was there
    before.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在将乱糟糟的电子邮件内容复制到剪贴板后，我们可以在剪贴板中的文本上运行工具，该工具可以清理电子邮件并将剪贴板内容替换为清理后的版本。为了使工具执行合理操作，我们假设您的剪贴板上有电子邮件文本。工具将删除每行开头的>和空格字符，这样您就可以使用操作系统的粘贴命令（如Ctrl-V）将新清理的电子邮件粘贴到您想要的位置。在Python方面，它需要将剪贴板内容拉入一个字符串（即复制剪贴板的内容），清理它，然后将新的清理文本放回剪贴板（即粘贴到剪贴板），替换之前那里的垃圾邮件版本。
- en: So, how do we access the clipboard in our Python program? That’s what we need
    to figure out, so that will frame the conversation that we have with Copilot.
    Similar to chapter 8, we’re going to use “Human” for the prompts that we type
    and “GitHub Copilot” for Copilot’s responses. You can use the Copilot Chat feature
    or ChatGPT to have a similar conversation. We’re typing our prompts into the Copilot
    Chat window.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在Python程序中访问剪贴板？这正是我们需要弄清楚的问题，这将是我们与Copilot对话的框架。类似于第8章，我们将使用“Human”作为我们输入的提示，使用“GitHub
    Copilot”作为Copilot的响应。您可以使用Copilot Chat功能或ChatGPT进行类似的对话。我们正在将提示输入到Copilot Chat窗口中。
- en: In our chats with Copilot, we’re going to explore widely before settling on
    a solution. We’ll explain why we’re doing this once we’ve gotten the hang of things
    through one example, but we note this here so that you’ll be ready for this seemingly
    less direct approach. Copilot provides quite a bit of sample code in its responses.
    As we’re exploring, feel free to skim that code, but don’t get bogged down in
    it. We’ll look at more particulars of the code once we finish exploring and settle
    on a plan. Let’s start learning!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们与Copilot的对话中，我们将广泛探索，然后确定解决方案。一旦我们通过一个示例掌握了事情，我们就会解释为什么这样做，但在这里我们注明这一点，以便您为这种看似不那么直接的方法做好准备。Copilot在其响应中提供了大量的示例代码。在我们探索的过程中，您可以随意浏览那些代码，但不要陷入其中。一旦我们完成探索并确定计划，我们再来看代码的更多细节。让我们开始学习吧！
- en: LPHumanI would like to write a Python program that accesses the clipboard and
    lets me copy and paste using the clipboard. How can I do this?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman我想写一个Python程序，可以访问剪贴板并让我使用剪贴板进行复制和粘贴。我该如何操作？
- en: '![chatGpt](../Images/chatGpt.png)GitHub CopilotYou can use the pyperclip module
    to access the clipboard in Python. Here’s an example program that lets you copy
    and paste using the clipboard:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot您可以使用pyperclip模块在Python中访问剪贴板。以下是一个示例程序，它允许您使用剪贴板进行复制和粘贴：'
- en: '[PRE0]`*[PRE1]`*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]`*[PRE1]`*'
- en: '*`*import pyperclip*`*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import pyperclip*`*'
- en: '*`*# Copy to clipboard*`*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 复制到剪贴板*`*'
- en: '*`*pyperclip.copy(''Hello, world!'')*`*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pyperclip.copy(''Hello, world!'')*`*'
- en: '*`*# Paste from clipboard*`*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 从剪贴板粘贴*`*'
- en: '*`*text = pyperclip.paste()*`*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*text = pyperclip.paste()*`*'
- en: '*`*print(text)*`*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(text)*`*'
- en: '*[PRE2]*[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE2]*[PRE3]'
- en: This program first imports the pyperclip module. It then copies the string `'Hello,`
    `world!'` to the clipboard using the `copy()` function. Finally, it pastes the
    contents of the clipboard into the “text” variable using the `paste()` function
    and prints the result.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序首先导入pyperclip模块。然后使用`copy()`函数将字符串`'Hello, world!'`复制到剪贴板。最后，使用`paste()`函数将剪贴板的内容粘贴到“text”变量中，并打印结果。
- en: You can install the pyperclip module using pip by running `pip` `install` `pyperclip`
    in your terminal.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在终端中运行`pip install pyperclip`来使用pip安装pyperclip模块。
- en: Copilot’s response teaches us that we can use the pyperclip module to interact
    with the clipboard in our Python program. The sample code that it provided even
    showed us how to copy stuff from our program to the clipboard and paste stuff
    from the clipboard into a variable (`text`). We’re making great progress!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot的响应告诉我们，我们可以在Python程序中使用pyperclip模块与剪贴板进行交互。它提供的示例代码甚至展示了如何从我们的程序中复制内容到剪贴板，并将剪贴板中的内容粘贴到一个变量（`text`）中。我们取得了很大的进步！
- en: The final paragraph of the response tells us how to install pyperclip. Aha!
    So pyperclip doesn’t come with Python by default. While we’ll learn how to install
    modules later, it might be nice to not have to worry about that. So, let’s continue
    the conversation, asking Copilot if we can do better.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的最后一段告诉我们如何安装 pyperclip。啊哈！所以 pyperclip 并不是 Python 默认自带的。虽然我们稍后会学习如何安装模块，但不必担心这一点可能是个好事。所以，让我们继续对话，询问
    Copilot 是否有更好的方法。
- en: LPHuman Is there a way I can do it without having to install a Python module?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman 想知道是否有办法在不安装 Python 模块的情况下完成这个操作？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, you can use the tkinter
    module that comes with Python to access the clipboard. Here’s an example program
    that lets you copy and paste using the clipboard without installing any additional
    modules:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 是的，你可以使用 Python 自带的 tkinter
    模块来访问剪贴板。以下是一个示例程序，它允许你使用剪贴板复制和粘贴，而不需要安装任何额外的模块：'
- en: '[PRE4]`*[PRE5]`*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]`*[PRE5]`*'
- en: '*`*import tkinter as tk*`*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import tkinter as tk*`*'
- en: '*`*# Create a Tkinter window*`*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Create a Tkinter window*`*'
- en: '*`*root = tk.Tk()*`*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*root = tk.Tk()*`*'
- en: '*`*# Hide the window*`*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Hide the window*`*'
- en: '*`*root.withdraw()*`*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*root.withdraw()*`*'
- en: '*`*# Copy to clipboard*`*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Copy to clipboard*`*'
- en: '*`*root.clipboard_clear()*`*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*root.clipboard_clear()*`*'
- en: '*`*root.clipboard_append(''Hello, world!'')*`*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*root.clipboard_append(''Hello, world!'')*`*'
- en: '*`*# Paste from clipboard*`*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Paste from clipboard*`*'
- en: '*`*text = root.clipboard_get()*`*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*text = root.clipboard_get()*`*'
- en: '*`*print(text)*`*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(text)*`*'
- en: '*[PRE6]*[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE6]*[PRE7]'
- en: This program first creates a hidden Tkinter window using the `Tk()` function
    and hides it using the `withdraw()` method. It then clears the clipboard using
    the `clipboard_ clear()` method and appends the string `'Hello,` `world!'` to
    the clipboard using the `clipboard_append()` method. Finally, it retrieves the
    contents of the clipboard using the `clipboard_get()` method and prints the result.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序首先使用 `Tk()` 函数创建一个隐藏的 Tkinter 窗口，并使用 `withdraw()` 方法将其隐藏。然后，它使用 `clipboard_clear()`
    方法清除剪贴板，并使用 `clipboard_append()` 方法将字符串 `'Hello, world!'` 添加到剪贴板。最后，它使用 `clipboard_get()`
    方法检索剪贴板的内容并打印结果。
- en: Note that this method only works if you have a graphical environment available,
    such as a desktop environment on Linux or macOS, or the Windows desktop on Windows.
    If you’re running Python in a terminal-only environment, you’ll need to use a
    different method to access the clipboard.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种方法仅在存在图形环境时才有效，例如 Linux 或 macOS 上的桌面环境，或 Windows 上的 Windows 桌面。如果你在仅终端的环境中运行
    Python，你需要使用不同的方法来访问剪贴板。
- en: It seems that we’ve won something and lost something else. The win is that this
    tkinter module is built into Python. The loss is that “the method only works if
    you have a graphical environment available.” Do we have a graphical environment
    available in our Python setup? While we could certainly try the code to find out,
    this requirement gives us pause. After all, the pyperclip solution didn’t have
    that requirement, so we might not need it (whatever it happens to mean). Let’s
    try again.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们既有所得也有所失。所得是，这个 tkinter 模块是 Python 内置的。所失是，“该方法仅在存在图形环境时才有效。”在我们的 Python
    设置中是否有图形环境呢？虽然我们可以尝试代码来找出答案，但这个要求让我们犹豫。毕竟，pyperclip 解决方案没有这个要求，所以我们可能不需要它（无论它具体意味着什么）。让我们再试一次。
- en: LPHumanIs there another way I can do it without having to install a Python module?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman 还有没有其他方法可以在不安装 Python 模块的情况下完成这个操作？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, you can access the clipboard
    using the win32clipboard module, which is included in the standard library on
    Windows. Here’s an example program that allows you to copy and paste using the
    clipboard without installing any additional modules:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 是的，你可以使用包含在 Windows 标准库中的 win32clipboard
    模块来访问剪贴板。以下是一个示例程序，它允许你使用剪贴板复制和粘贴，而不需要安装任何额外的模块：'
- en: '[PRE8]`*[PRE9]`*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]`*[PRE9]`*'
- en: '*`*import win32clipboard*`*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import win32clipboard*`*'
- en: '*`*# Copy to clipboard*`*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Copy to clipboard*`*'
- en: '*`*text = "Hello, world!"*`*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*text = "Hello, world!"*`*'
- en: '*`*win32clipboard.OpenClipboard()*`*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.OpenClipboard()*`*'
- en: '*`*win32clipboard.EmptyClipboard()*`*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.EmptyClipboard()*`*'
- en: '*`*win32clipboard.SetClipboardText(text)*`*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.SetClipboardText(text)*`*'
- en: '*`*win32clipboard.CloseClipboard()*`*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.CloseClipboard()*`*'
- en: '*`*# Paste from clipboard*`*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Paste from clipboard*`*'
- en: '*`*win32clipboard.OpenClipboard()*`*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.OpenClipboard()*`*'
- en: '*`*pasted_text = win32clipboard.GetClipboardData()*`*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pasted_text = win32clipboard.GetClipboardData()*`*'
- en: '*`*win32clipboard.CloseClipboard()*`*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.CloseClipboard()*`*'
- en: '*`*print(pasted_text)*`*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(pasted_text)*`*'
- en: '*[PRE10]*[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE10]*[PRE11]'
- en: This program first imports the win32clipboard module. To copy text to the clipboard,
    you can call the `OpenClipboard()` function to open the clipboard, then call `EmptyClipboard()`
    to clear any existing data, and finally call `SetClipboardText()` to set the text
    on the clipboard. After setting the text, you should call `CloseClipboard()` to
    close the clipboard.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序首先导入 win32clipboard 模块。要复制文本到剪贴板，你可以调用 `OpenClipboard()` 函数来打开剪贴板，然后调用 `EmptyClipboard()`
    来清除任何现有数据，最后调用 `SetClipboardText()` 来设置剪贴板上的文本。设置文本后，你应该调用 `CloseClipboard()`
    来关闭剪贴板。
- en: To paste from the clipboard, you can call `OpenClipboard()` to open the clipboard,
    then call `GetClipboardData()` to get the text from the clipboard. After getting
    the text, you should call `CloseClipboard()` to close the clipboard. In this example,
    the program copies the text `"Hello,` `world!"` to the clipboard, then pastes
    it and prints it to the console.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要从剪贴板粘贴，你可以调用 `OpenClipboard()` 来打开剪贴板，然后调用 `GetClipboardData()` 来从剪贴板获取文本。获取文本后，你应该调用
    `CloseClipboard()` 来关闭剪贴板。在这个例子中，程序将文本 `"Hello,` `world!"` 复制到剪贴板，然后粘贴并打印到控制台。
- en: “Standard library on Windows,” eh? That’s concerning because it means that our
    tool might not work on other operating systems. Let’s see about that.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: “Windows上的标准库？”这令人担忧，因为这意味着我们的工具可能在其他操作系统上无法工作。让我们看看情况。
- en: LPHumanDoes that work on Linux or macOS too?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman这个在 Linux 或 macOS 上也工作吗？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot No, the win32clipboard module
    is specific to Windows and won’t work on Linux or macOS. On Linux, you can use
    the `xclip` command-line utility to access the clipboard. Here’s an example program
    that allows you to copy and paste using the clipboard on Linux:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 不，win32clipboard 模块是针对 Windows
    的，在 Linux 或 macOS 上无法工作。在 Linux 上，你可以使用 `xclip` 命令行工具来访问剪贴板。以下是一个示例程序，允许你在 Linux
    上使用剪贴板复制和粘贴：'
- en: '[PRE12]`*[PRE13]`*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]`*[PRE13]`*'
- en: '*`*import subprocess*`*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import subprocess*`*'
- en: '*`*# Copy to clipboard*`*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 复制到剪贴板*`*'
- en: '*`*text = "Hello, world!"*`*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*text = "Hello, world!"*`*'
- en: '*`*subprocess.run([''xclip'', ''-selection'', ''clipboard''], input=text.encode(''utf-8''))*`*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*subprocess.run([''xclip'', ''-selection'', ''clipboard''], input=text.encode(''utf-8''))*`*'
- en: '*`*# Paste from clipboard*`*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 从剪贴板粘贴*`*'
- en: '*`*p = subprocess.Popen([''xclip'', ''-selection'', ''clipboard'', ''-o''],
    stdout=subprocess.PIPE)*`*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*p = subprocess.Popen([''xclip'', ''-selection'', ''clipboard'', ''-o''],
    stdout=subprocess.PIPE)*`*'
- en: '*`*pasted_text = p.stdout.read().decode(''utf-8'')*`*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pasted_text = p.stdout.read().decode(''utf-8'')*`*'
- en: '*`*print(pasted_text)*`*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(pasted_text)*`*'
- en: '*[PRE14]*[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE14]*[PRE15]'
- en: This program uses the subprocess module to run the `xclip` command-line utility.
    To copy text to the clipboard, you can call `subprocess.run()` and pass in the
    `xclip` command with the `-selection` `clipboard` option to specify the clipboard
    selection, and the `input` parameter to pass in the text you want to copy. To
    paste from the clipboard, you can call `subprocess.Popen()` and pass in the `xclip`
    command with the `-selection` `clipboard` `-o` options to read the text from the
    clipboard, and then read the output of the command using the `stdout` attribute
    of the `Popen` object. In this example, the program copies the text `"Hello,`
    `world!"` to the clipboard, then pastes it and prints it to the console.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序使用 subprocess 模块来运行 `xclip` 命令行工具。要复制文本到剪贴板，你可以调用 `subprocess.run()` 并传入
    `xclip` 命令，使用 `-selection` `clipboard` 选项来指定剪贴板选择，以及 `input` 参数来传入你想要复制的文本。要从剪贴板粘贴，你可以调用
    `subprocess.Popen()` 并传入 `xclip` 命令，使用 `-selection` `clipboard` `-o` 选项来从剪贴板读取文本，然后使用
    `Popen` 对象的 `stdout` 属性读取命令的输出。在这个例子中，程序将文本 `"Hello,` `world!"` 复制到剪贴板，然后粘贴并打印到控制台。
- en: On macOS, you can use the `pbcopy` and `pbpaste` command-line utilities to access
    the clipboard. The usage is similar to `xclip`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，你可以使用 `pbcopy` 和 `pbpaste` 命令行工具来访问剪贴板。用法与 `xclip` 类似。
- en: We’ve gotten some solutions that are specific to different operating systems.
    We don’t like this! We want our tool to work no matter which operating system
    we’re using. (Even if we’re using only Windows ourselves, maybe one day, we’ll
    share this tool with others who use different operating systems.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经得到了一些针对不同操作系统的特定解决方案。我们不喜欢这样！我们希望我们的工具无论在哪个操作系统上都能工作。（即使我们只使用 Windows，也许有一天，我们会将这个工具与其他使用不同操作系统的用户分享。）
- en: We could continue our conversation, but in retrospect, having to install that
    single pyperclip module doesn’t seem so bad. Let’s go ahead with it. In general,
    it can be valuable to explore your options when deciding how to start writing
    a tool, and conversing with Copilot is helpful for carrying out this exploration.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续我们的对话，但回顾起来，安装那个单一的pyperclip模块似乎并不那么糟糕。让我们继续吧。一般来说，在决定如何开始编写工具时探索你的选项是有价值的，与Copilot进行对话有助于进行这种探索。
- en: Why we should explore and understand our options
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为什么我们应该探索和理解我们的选项
- en: 'There are several reasons why you shouldn’t just use the first module that
    Copilot chat tells you to use:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因说明为什么你不应该仅仅使用Copilot聊天告诉你的第一个模块：
- en: It may not work on all operating systems. In general, we want to find modules
    that work across multiple operating systems so that the tool can be used by you
    (if you later switch operating systems) or others with whom you’ve shared the
    tool.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能不会在所有操作系统上工作。一般来说，我们想要找到可以在多个操作系统上工作的模块，这样工具就可以供你（如果你后来切换操作系统）或与你分享工具的其他人使用。
- en: It may turn out not to work for our use case after all, or we may struggle to
    get the code to work. If we have other options, we can start trying those before
    sinking too much time into a strategy that may or may not ultimately work out.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终可能发现它并不适用于我们的用例，或者我们可能难以让代码正常工作。如果我们有其他选择，我们可以在投入太多时间到一个可能或不可能最终成功的策略之前，先尝试那些其他选项。
- en: Modules are updated frequently. Usually this is to add new features and fix
    bugs, but sometimes, functions are removed or changed in this process as well.
    When the author of a module removes a function, it’s known as *deprecating that
    function**.* Once a function is deprecated,it may no longer work, and we need
    to find a replacement. Copilot is trained only every once in a while, not continuously,
    so if a new version of a module comes out after Copilot was trained on it, Copilot
    won’t know about the updates. This can lead to Copilot suggesting code that depends
    on an older version of the module than the one you have. There are ways to address
    this, as we’ll see later in the chapter. But if you run into trouble, having other
    options to explore is useful.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块经常更新。通常这是为了添加新功能并修复错误，但有时在这个过程中，功能也可能被移除或更改。当一个模块的作者移除一个功能时，这被称为*弃用该功能**。一旦一个功能被弃用，它可能就不再工作，我们需要找到一个替代方案。Copilot只是偶尔进行训练，而不是持续训练，所以如果Copilot在训练后该模块的新版本发布，Copilot将不会知道这些更新。这可能导致Copilot建议依赖于比你所拥有的模块旧版本的代码。我们将在本章后面看到解决这个问题的方法。但如果你遇到麻烦，有其他选项可供探索是有用的。
- en: 9.3.2 Writing the tool to clean up email
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 编写清理电子邮件的工具
- en: 'The first thing we need to do is to install the pyperclip module. How do we
    install it, though? The good news is that Python has made it easy to install new
    modules. Go to the Terminal at the bottom right of VS Code and type the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是安装pyperclip模块。那么我们该如何安装它呢？好消息是Python使得安装新模块变得很容易。前往VS Code右下角的终端，并输入以下命令：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note  For some operating systems, you may need to use `pip3` rather than `pip`.
    On Windows machines, we recommend using `pip` if you followed our installation
    instructions from chapter 2\. On Mac or Linux machines, we recommend using `pip3`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于某些操作系统，你可能需要使用`pip3`而不是`pip`。在Windows机器上，如果你遵循了第2章中的安装说明，我们建议使用`pip`。在Mac或Linux机器上，我们建议使用`pip3`。
- en: 'When you run this command, you might see that other modules get installed too.
    Don’t worry about that: sometimes modules need other modules to be able to do
    their work, and Python just installs them all so that you don’t have to worry
    about installing those dependencies yourself.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个命令时，你可能会看到还安装了其他模块。不用担心这个问题：有时模块需要其他模块来执行它们的工作，Python会自动安装所有这些模块，这样你就不必担心自己安装这些依赖项了。
- en: Once that’s installed, we can import the module and then write the header and
    docstring for our function that will remove the > and space characters from the
    start of lines. The reason we’re importing the module here is to influence Copilot
    to use that module when writing the code for the function. Here’s the prompt we
    used and the code that Copilot gave us.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以导入该模块，然后为我们的函数编写头和文档字符串，该函数将从行首删除>和空格字符。我们在这里导入模块的原因是影响Copilot在编写函数代码时使用该模块。以下是我们的提示和Copilot给出的代码。
- en: 'Listing 9.1 First try: Clean up email text in the clipboard'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1 第一次尝试：清理剪贴板中的电子邮件文本
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#1 Puts the current contents of the clipboard into the text string'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将剪贴板当前内容放入文本字符串'
- en: '#2 Splits the string into a list of its lines'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将字符串拆分为其行列表'
- en: '#3 Loops through each line'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 遍历每一行'
- en: '#4 Removes spaces and &gt; symbols from the start of the line'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 从行的开头移除空格和 &gt; 符号'
- en: '#5 This looks odd.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 这看起来有点奇怪。'
- en: '#6 Copies the cleaned-up text to the clipboard'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 将清理后的文本复制到剪贴板'
- en: '#7 Note a common Python convention (see the following discussion).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 注意一个常见的 Python 习惯（见以下讨论）。'
- en: '#8 Calls our function to automatically clean up the clipboard!'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 调用我们的函数来自动清理剪贴板！'
- en: 'We can see that the program is carrying out the correct sequence of steps:
    it’s obtaining the clipboard contents, cleaning up that text, and then copying
    the cleaned-up text back to the clipboard. As we learned from our earlier chat
    with Copilot, we want Copilot to write code that uses the `paste` and `copy` functions
    of `pyperclip`, and that’s exactly what it’s doing. The second-to-last line of
    the program is something we haven’t seen before in this book:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到程序正在执行正确的步骤序列：它正在获取剪贴板内容，清理文本，然后将清理后的文本复制回剪贴板。正如我们从与 Copilot 的早期聊天中学到的，我们希望
    Copilot 编写使用 `pyperclip` 的 `paste` 和 `copy` 函数的代码，这正是它所做的事情。程序倒数第二行是我们在这本书中之前没有见过的：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can actually remove this line if you like (and if you do, also unindent
    the line below it). It ensures that the `clean_email` function is only called
    when you run your program, not when you import it as a module. After all, if you
    did want to import this as a module (to be used as part of a larger program),
    you would call `clean_email` whenever you needed that functionality, not necessarily
    as soon as the module was imported. (And, in general, whenever you’re interested
    in understanding a line of code more fully, you can ask Copilot about it!) Unfortunately,
    this code doesn’t work. If you run it, you’ll receive this error:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果你喜欢，可以删除这一行（如果你这样做，也要取消下一行的缩进）。这确保了 `clean_email` 函数只有在运行你的程序时才会被调用，而不是在将其作为模块导入时。毕竟，如果你确实想将其作为模块导入（作为更大程序的一部分使用），你会在需要该功能时调用
    `clean_email`，而不一定是模块导入时。 （而且，一般来说，每当你想更全面地理解一行代码时，你都可以询问 Copilot！）不幸的是，这段代码不起作用。如果你运行它，你会收到以下错误：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The syntax error means that we have a program that isn’t written in valid Python
    code. We’re going to fix this now! We have a couple of options for how to do so.
    One is to highlight your code and ask Copilot Chat to fix the bug. For us, this
    did fix the problem. You could also try asking ChatGPT in conversation: “Propose
    a fix for the bugs in my code <insert your code>.” This is a useful tip to keep
    in mind whenever the code that you get back from Copilot doesn’t work as expected.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误意味着我们有一个没有用有效 Python 代码编写的程序。我们现在将修复它！我们有几个选项可以这样做。一个是突出显示你的代码，并要求 Copilot
    Chat 修复错误。对我们来说，这确实解决了问题。你也可以尝试在与 ChatGPT 的对话中提出：“为我的代码中的错误提出修复建议 <插入你的代码>。” 这是一个有用的提示，当你从
    Copilot 得到的代码没有按预期工作时要记住！
- en: Copilot fixed the code for us by fixing the line with the syntax error. The
    new code is shown in the following listing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 通过修复有语法错误的行为我们修复了代码。新的代码如下所示。
- en: 'Listing 9.2 Second try: Clean up email text in the clipboard'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2 第二次尝试：清理剪贴板中的电子邮件文本
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#1 Joins the individual lines back into one string'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将单独的行重新组合成一个字符串'
- en: The new line of code, changed from the odd line of code that we had previously,
    is
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码行，与之前奇怪的一行代码不同，是
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The goal of this line is to join all the lines of text together into a single
    string that the program will later copy to the clipboard. What does that `\n`
    mean? That represents the start of a newline in code. What is the `join` method?
    It takes all the items in a list (lines) and joins them together into a single
    string.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这行的目的是将所有文本行连接成一个单独的字符串，程序稍后会将其复制到剪贴板。那个 `\n` 代表什么？它代表代码中换行的开始。`join` 方法是什么？它接受列表（行）中的所有项并将它们连接成一个单独的字符串。
- en: 'We can understand how this works in more detail by experimenting a little with
    `join`. Here’s an example of using `join` with an empty string rather than the
    `''\n''` string:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过稍微实验 `join` 来更详细地理解它是如何工作的。这里是一个使用空字符串而不是 `'\n'` 字符串的 `join` 示例：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 Shows the list of three lines'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 显示三行的列表'
- en: '#2 Calls join on the empty string'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 在空字符串上调用 join 方法'
- en: 'Notice that some of the words are squished together. That’s not exactly what
    we want—we need something between them. How about a space? Let’s try using `join`
    again, this time with a space in the string rather than the empty string:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有些单词挤在一起。这并不是我们想要的--我们需要在它们之间留点空间。怎么样，让我们再次尝试使用`join`，这次在字符串中使用空格而不是空字符串：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Or, we could use `''*''`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用`'*'`：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That fixes our squished words. And, the `*s` tells us where each line ends,
    but it would be nicer to actually maintain the fact that the email is three lines.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就解决了我们的单词挤压问题。而且，`*s`告诉我们每行在哪里结束，但最好实际上保持电子邮件是三行的事实。
- en: 'We need a way in Python to use a line break or newline character, rather than
    a space or `*`. We can’t just press Enter because that would split the string
    over two lines and that isn’t valid Python syntax. The way to do it is by using
    `''\n''`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们需要一种方法来使用换行符或换行符字符，而不是空格或`*`。我们不能只是按Enter键，因为这会将字符串分成两行，这不是有效的Python语法。要做到这一点，我们可以使用`'\n'`：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now our tool is ready to be used. If you copy some messy email text to your
    clipboard, run our program, and paste the clipboard, you’ll see that the email
    has been cleaned up. For example, if we run it on our previous sample email, we
    get the following cleaned-up version:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的工具已经准备好使用了。如果你将一些杂乱的电子邮件文本复制到剪贴板，运行我们的程序，然后粘贴剪贴板，你会看到电子邮件已经被清理。例如，如果我们对之前的样本电子邮件运行它，我们会得到以下清理后的版本：
- en: Hi Leo,
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，利奥，
- en: Dan -- any luck with your natural language research?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 丹--你在自然语言研究方面有什么进展吗？
- en: Yes! That website you showed me
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！你给我看的那个网站
- en: '[https://www.kaggle.com/](https://www.kaggle.com/)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.kaggle.com/](https://www.kaggle.com/)'
- en: is very useful. I found a dataset on there that collects
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 非常有用。我在那里找到一个数据集，它收集了
- en: a lot
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 很多
- en: of questions and answers that might be useful to my research.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 可能对我的研究有用的问答。
- en: Thank you,
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢，
- en: Dan
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 丹
- en: Of course, we could still do more. The line breaks in that email aren’t great
    (the line “a lot” is extremely and needlessly short), and you might want to clean
    that up as well. You could begin to make these kinds of improvements by adding
    new requirements to your prompts to Copilot. We’ll stop here because we’ve accomplished
    our initial goal of email cleanup, but we encourage you to continue exploring
    more robust solutions on your own.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还可以做更多。那封电子邮件中的换行符不太好（“很多”这一行非常短且没有必要），你可能还想清理一下。你可以通过向Copilot的提示中添加新要求来开始进行这些改进。我们在这里停下来，因为我们已经完成了电子邮件清理的初步目标，但我们鼓励你继续独立探索更稳健的解决方案。
- en: '9.4 Example 2: Adding cover pages to PDF files'
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 示例2：向PDF文件添加封面页
- en: Let’s return to the scenario from the start of the chapter. We have written
    100 reports that are in .pdf format. Our colleague has designed 100 covers for
    those reports that are also in .pdf format, and we need to merge the covers with
    the reports so that each finalized .pdf file starts with the cover and continues
    with the report. Figure 9.1 provides an illustration of the desired process.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到本章开头的场景。我们已经编写了100份报告，这些报告都是.pdf格式的。我们的同事为这些报告设计了100个封面，这些封面也是.pdf格式的，我们需要将封面与报告合并，以便每个最终生成的.pdf文件从封面开始，然后继续是报告。图9.1展示了所需的过程。
- en: '![figure](../Images/9-1.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-1.png)'
- en: Figure 9.1 Illustration of the desired process of creating combined .pdfs by
    merging the report cover in the cover directory with the report in the report’s
    directory. Note that the reports may be more than one page.
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1 创建合并.pdf文件所需过程的示意图，通过将封面目录中的报告封面与报告目录中的报告合并。注意，报告可能有多页。
- en: PDF files (and Microsoft Word and Excel files) aren’t text files
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: PDF文件（以及Microsoft Word和Excel文件）不是文本文件
- en: You might wonder why we can’t simply use Python methods such as `read` and `write`
    to manipulate .pdf files. After all, that’s just what we did when working with
    .csv files in chapter 2.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们不能简单地使用Python的`read`和`write`方法来操作.pdf文件。毕竟，我们在第2章处理.csv文件时就是这样做的。
- en: 'The big difference is that .csv files are text files, which are files readable
    by humans with no formatting or special commands. However, many other file formats
    aren’t text files. A .pdf file, for example, isn’t human-readable and needs to
    be processed by code that is aware of the .pdf format. This is true of Microsoft
    Word files and Microsoft Excel files as well: they’re not text files, so we need
    specialized tools to work with them.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的区别在于.csv文件是文本文件，这些文件是未经格式化或特殊命令的人类可读文件。然而，许多其他文件格式不是文本文件。例如，.pdf文件不是人类可读的，需要由了解.pdf格式的代码进行处理。同样，Microsoft
    Word文件和Microsoft Excel文件也是如此：它们不是文本文件，因此我们需要专门的工具来处理它们。
- en: 'In the resources for this book, in the ch9 folder, you’ll find two subfolders:
    the reports subfolder contains 100 reports as .pdf files, and the covers subfolder
    contains 100 covers as .pdf files, one for each report. The reports are named
    1.pdf, 2.pdf, 3.pdf, and so on; the respective covers are named cover1.pdf, cover2.pdf,
    cover3.pdf, and so on. We’ll merge these reports and covers together in this section.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的资源中，在ch9文件夹中，您将找到两个子文件夹：报告子文件夹包含100个.pdf格式的报告，封面子文件夹包含100个.pdf格式的封面，每个报告一个。报告命名为1.pdf、2.pdf、3.pdf等；相应的封面命名为cover1.pdf、cover2.pdf、cover3.pdf等。在本节中，我们将合并这些报告和封面。
- en: Open some of the cover .pdf files and some of the report .pdf files. You can
    do that using a program such as Adobe Acrobat or however you typically open .pdf
    files on your computer. You’ll notice that the covers are always exactly one page,
    but the reports can be more than one page. When we get to the code, we should
    take care to tell Copilot that reports can be more than one page; otherwise, Copilot
    might write code assuming that the reports, like the covers, are only one page.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一些封面.pdf文件和一些报告.pdf文件。您可以使用Adobe Acrobat或您通常在计算机上打开.pdf文件的方式来实现。您会注意到封面总是恰好一页，但报告可能有多页。当我们到达代码时，我们应该注意告诉Copilot报告可能有多页；否则，Copilot可能会编写假设报告，就像封面一样，只有一页。
- en: You might be wondering how we created these 100 covers and reports. You’d be
    disappointed if we made them manually, one at a time, right? Don’t worry. We automated
    that creation process in much the same way we’ll automate the merging process
    next.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道我们是如何创建这100个封面和报告的。如果我们一个接一个地手动创建，您会感到失望，对吧？别担心。我们以与自动化合并过程相同的方式自动化了创建过程。
- en: 9.4.1 Conversing with Copilot
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 与Copilot对话
- en: We need our tool to find all reports and covers, add the cover to the front
    of each report, and produce a finalized .pdf for each report that contains both
    the cover page and report pages. How do we merge .pdf files using Python? Let’s
    find out.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工具需要找到所有报告和封面，将封面添加到每个报告的前面，并为每个报告生成一个包含封面页和报告页的最终.pdf文件。我们如何使用Python合并.pdf文件？让我们来看看。
- en: LPHumanI need to write a **Python program that merges .pdf files. How do I do
    this?**
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman我需要编写一个**Python程序来合并.pdf文件。我该如何操作？**
- en: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the PyPDF2 library
    to merge PDF files in Python. Here is an example code snippet that shows how to
    merge two PDF files:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot您可以使用PyPDF2库在Python中合并PDF文件。以下是一个示例代码片段，展示了如何合并两个PDF文件：'
- en: '[PRE26]`*[PRE27]`*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE26]`*[PRE27]`*'
- en: '*`*import PyPDF2*`*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import PyPDF2*`*'
- en: '*`*# Open the PDF files to be merged*`*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 打开要合并的PDF文件*`*'
- en: '*`*pdf1 = open(''file1.pdf'', ''rb'')*`*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf1 = open(''file1.pdf'', ''rb'')*`*'
- en: '*`*pdf2 = open(''file2.pdf'', ''rb'')*`*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf2 = open(''file2.pdf'', ''rb'')*`*'
- en: '*`*# Create a PDF reader object for each file*`*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*创建一个用于每个文件的PDF阅读器对象*`*'
- en: '*`*reader1 = PyPDF2.PdfFileReader(pdf1)*`*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*reader1 = PyPDF2.PdfFileReader(pdf1)*`*'
- en: '*`*reader2 = PyPDF2.PdfFileReader(pdf2)*`*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*reader2 = PyPDF2.PdfFileReader(pdf2)*`*'
- en: '*`*# Create a PDF writer object*`*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 创建一个PDF写入器对象*`*'
- en: '*`*writer = PyPDF2.PdfFileWriter()*`*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*writer = PyPDF2.PdfFileWriter()*`*'
- en: '*`*# Loop through the pages of each PDF and add them to the writer object*`*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 遍历每个PDF的页面并将它们添加到writer对象中*`*'
- en: '*`*for i in range(reader1.getNumPages()):*`*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*for i in range(reader1.getNumPages()):*`*'
- en: '*`*page = reader1.getPage(i)*`*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*page = reader1.getPage(i)*`*'
- en: '*`*writer.addPage(page)*`*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*writer.addPage(page)*`*'
- en: '*`*for i in range(reader2.getNumPages()):*`*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*for i in range(reader2.getNumPages()):*`*'
- en: '*`*page = reader2.getPage(i)*`*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*page = reader2.getPage(i)*`*'
- en: '*`*writer.addPage(page)*`*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*writer.addPage(page)*`*'
- en: '*`*# Write the merged PDF to a file*`*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 将合并后的PDF写入文件*`*'
- en: '*`*output = open(''merged.pdf'', ''wb'')*`*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*output = open(''merged.pdf'', ''wb'')*`*'
- en: '*`*writer.write(output)*`*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*writer.write(output)*`*'
- en: '*`*# Close the input and output files*`*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 关闭输入和输出文件*`*'
- en: '*`*pdf1.close()*`*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf1.close()*`*'
- en: '*`*pdf2.close()*`*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf2.close()*`*'
- en: '*`*output.close()*`*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*output.close()*`*'
- en: '*[PRE28]*[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE28]*[PRE29]'
- en: In this example, we first open the two PDF files to be merged using the `open()`
    function. We then create a PDF reader object for each file using the `PdfFileReader()`
    function from PyPDF2.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先使用`open()`函数打开要合并的两个PDF文件。然后，我们使用PyPDF2的`PdfFileReader()`函数为每个文件创建一个PDF读取对象。
- en: Next, we create a PDF writer object using the `PdfFileWriter()` function. We
    then loop through the pages of each PDF file using the `getNumPages()` and `getPage()`
    methods of the reader objects and add each page to the writer object using the
    `addPage()` method.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`PdfFileWriter()`函数创建一个PDF写入对象。然后，我们使用reader对象的`getNumPages()`和`getPage()`方法遍历每个PDF文件的页面，并使用`addPage()`方法将每个页面添加到writer对象中。
- en: Finally, we write the merged PDF to a file using the `write()` method of the
    writer object and close all the input and output files using the `close()` method.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用writer对象的`write()`方法将合并后的PDF写入文件，并使用`close()`方法关闭所有输入和输出文件。
- en: We have a lead! This PyPDF2 module seems to do what we need. It looks like it
    gives us `PdfFileReader` to read an existing .pdf file and `PdfFileWriter` to
    create a new .pdf file. We see the code using `getPage` to get a page from an
    existing .pdf file and `addPage` to write it to the new .pdf file—very promising.
    Is there something built-in to Python that we could use, so that we don’t have
    to worry about installing PyPDF2?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有线索了！这个PyPDF2模块似乎能完成我们需要的功能。它看起来提供了`PdfFileReader`来读取现有的.pdf文件和`PdfFileWriter`来创建新的.pdf文件。我们看到代码使用`getPage`从现有的.pdf文件中获取页面，并使用`addPage`将其写入新的.pdf文件——非常有前景。Python中有没有内置的我们可以使用的东西，这样我们就不必担心安装PyPDF2了？
- en: LPHumanIs there a way I can do it without having to install a Python module?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman有没有一种方法可以在不安装Python模块的情况下完成？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, you can use the subprocess
    module to call a command-line tool like `pdftk` to merge PDF files. Here is an
    example code snippet that shows how to merge two PDF files using `pdftk`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot——是的，你可以使用subprocess模块调用命令行工具，如`pdftk`来合并PDF文件。以下是一个示例代码片段，展示了如何使用`pdftk`合并两个PDF文件：'
- en: '[PRE30]`*[PRE31]`*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30]`*[PRE31]`*'
- en: '*`*import subprocess*`*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import subprocess*`*'
- en: '*`*# Call pdftk to merge the PDF files*`*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*调用pdftk合并PDF文件*`*'
- en: '*`*subprocess.call([''pdftk'', ''file1.pdf'', ''file2.pdf'',*`*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*subprocess.call([''pdftk'', ''file1.pdf'', ''file2.pdf'',*`*'
- en: '*`*''cat'', ''output'', ''merged.pdf''])*`*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*''cat'', ''output'', ''merged.pdf''])**'
- en: '*[PRE32]*[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE32]*[PRE33]'
- en: In this example, we use the `subprocess.call()` function to call `pdftk` with
    the appropriate arguments to merge the two PDF files `file1.pdf` and `file2.pdf`.
    The `cat` argument tells `pdftk` to concatenate the input files, and the `output`
    argument specifies the output file name as `merged.pdf`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`subprocess.call()`函数调用`pdftk`，并使用适当的参数合并两个PDF文件`file1.pdf`和`file2.pdf`。`cat`参数告诉`pdftk`连接输入文件，而`output`参数指定输出文件名为`merged.pdf`。
- en: 'Note that you will need to have `pdftk` installed on your system for this code
    to work. If you don’t have `pdftk` installed, you can download it from the official
    website: [https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/](https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要在你的系统上安装`pdftk`才能使此代码工作。如果你没有安装`pdftk`，你可以从官方网站下载它：[https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/](https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/)。
- en: This approach may ultimately end up being valuable, but it’s not exactly a built-in
    solution. After all, the final paragraph talks about us having to install some
    new software called `pdftk`!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法最终可能很有价值，但并不是一个内置的解决方案。毕竟，最后一段提到了我们不得不安装一些名为`pdftk`的新软件！
- en: At this point, we’d probably go with the first option of using PyPDF2\. But
    let’s press forward once more with Copilot to make sure we don’t miss any good
    options.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可能会选择使用PyPDF2的第一个选项。但让我们再次使用Copilot来确保我们没有错过任何好的选项。
- en: LPHumanAre there other Python .pdf libraries that I should consider?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman我应该考虑其他Python .pdf库吗？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, there are several other
    Python libraries that you can use to work with PDF files. Here are some popular
    ones:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot——是的，还有几个其他Python库你可以用来处理PDF文件。以下是一些流行的库：'
- en: ReportLab—a library for creating PDF documents from scratch, with support for
    text, graphics, and images.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ReportLab——一个用于从头创建PDF文档的库，支持文本、图形和图像。
- en: FPDF—a library for creating PDF documents from scratch, with support for text,
    graphics, and images.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FPDF——一个用于从头创建PDF文档的库，支持文本、图形和图像。
- en: PDFMiner—a library for extracting text and metadata from PDF files.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PDFMiner——一个用于从PDF文件中提取文本和元数据的库。
- en: PyMuPDF—a library for working with PDF files, with support for text, graphics,
    and images.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyMuPDF——一个用于处理PDF文件的库，支持文本、图形和图像。
- en: pdfrw—a library for reading and writing PDF files, with support for text, graphics,
    and images.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: pdfrw——一个用于读取和写入PDF文件的库，支持文本、图形和图像。
- en: Each library has its own strengths and weaknesses, so you should choose the
    one that best fits your needs. If you only need to merge PDF files, then PyPDF2
    or pdftk may be sufficient. However, if you need to create or manipulate PDF files
    in more complex ways, then one of the other libraries may be a better choice.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每个库都有其自身的优缺点，因此您应该选择最适合您需求的库。如果您只需要合并PDF文件，那么PyPDF2或pdftk可能就足够了。然而，如果您需要以更复杂的方式创建或操作PDF文件，那么其他库可能是一个更好的选择。
- en: The last paragraph tells us that we’re probably in good shape using PyPDF2 if
    all we need to do is merge .pdf files. But let’s finish our conversation here
    by understanding the pros and cons of all of these tools. That way, if we get
    stuck with PyPDF2, we know where to turn to next.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段告诉我们，如果我们只需要合并.pdf文件，那么使用PyPDF2可能就足够了。但让我们通过了解所有这些工具的优缺点来结束我们的对话。这样，如果我们遇到PyPDF2的问题，我们就知道下一步该怎么做。
- en: LPHumanCan you summarize the **strengths and weaknesses of these libraries?**
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman您可以总结一下这些库的优缺点吗？
- en: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot Certainly! Here is a summary
    of the strengths and weaknesses of the libraries I mentioned:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot** 毫无疑问！以下是关于我提到的库的优缺点的总结：'
- en: PyPDF2—a library for working with PDF files, with support for text, graphics,
    and images.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: PyPDF2——一个用于处理PDF文件的库，支持文本、图形和图像。
- en: 'Strengths:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Easy to use for simple tasks like merging PDF files.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于简单任务（如合并PDF文件）来说易于使用。
- en: Good documentation and examples available.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: Supports a wide range of PDF features.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: 'Weaknesses:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Limited support for advanced PDF features like forms and annotations.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对高级PDF功能（如表单和注释）的支持有限。
- en: Can be slow for large PDF files.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大型PDF文件可能运行缓慢。
- en: ReportLab—a library for creating PDF documents from scratch, with support for
    text, graphics, and images.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ReportLab——一个用于从头创建PDF文档的库，支持文本、图形和图像。
- en: 'Strengths:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Very powerful and flexible for creating complex PDF documents.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建复杂的PDF文档非常强大和灵活。
- en: Supports a wide range of PDF features.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: Good documentation and examples available.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: 'Weaknesses:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Steep learning curve for beginners.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于初学者来说，学习曲线陡峭。
- en: Can be slow for large PDF files.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大型PDF文件可能运行缓慢。
- en: FPDF—a library for creating PDF documents from scratch, with support for text,
    graphics, and images.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: FPDF——一个用于从头创建PDF文档的库，支持文本、图形和图像。
- en: 'Strengths:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Lightweight and easy to use.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轻量级且易于使用。
- en: Good documentation and examples available.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: Supports a wide range of PDF features.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: 'Weaknesses:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Limited support for advanced PDF features like forms and annotations.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对高级PDF功能（如表单和注释）的支持有限。
- en: Can be slow for large PDF files.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大型PDF文件可能运行缓慢。
- en: PDFMiner—a library for extracting text and metadata from PDF files.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: PDFMiner——一个用于从PDF文件中提取文本和元数据的库。
- en: 'Strengths:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Very powerful and flexible for extracting text and metadata from PDF files.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从PDF文件中提取文本和元数据非常强大和灵活。
- en: Supports a wide range of PDF features.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: Good documentation and examples available.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: 'Weaknesses:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Steep learning curve for beginners.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于初学者来说，学习曲线陡峭。
- en: Limited support for creating or manipulating PDF files.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或操作PDF文件的支持有限。
- en: PyMuPDF—a library for working with PDF files, with support for text, graphics,
    and images.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: PyMuPDF——一个用于处理PDF文件的库，支持文本、图形和图像。
- en: 'Strengths:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Very fast and efficient for working with PDF files.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理PDF文件非常快速和高效。
- en: Supports a wide range of PDF features.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: Good documentation and examples available.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: 'Weaknesses:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Steep learning curve for beginners.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于初学者来说，学习曲线陡峭。
- en: Limited support for creating or manipulating PDF files.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或操作PDF文件的支持有限。
- en: pdfrw—a library for reading and writing PDF files, with support for text, graphics,
    and images.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: pdfrw——一个用于读取和写入PDF文件的库，支持文本、图形和图像。
- en: 'Strengths:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Very powerful and flexible for reading and writing PDF files.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取和写入PDF文件非常强大和灵活。
- en: Supports a wide range of PDF features.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: Good documentation and examples available.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: 'Weaknesses:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Steep learning curve for beginners.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于初学者来说学习曲线陡峭。
- en: Can be slow for large PDF files.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于大型 PDF 文件可能运行缓慢。
- en: Don’t be too intimidated by the “Steep learning curve for beginners” cautions
    in there. If Copilot has been trained on the library, then you may still be successful.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被“对于初学者来说学习曲线陡峭”的警告吓倒。如果 Copilot 在该库上进行了训练，那么你仍然可能成功。
- en: Based on what we’ve learned here, we might eliminate PDFMiner because it apparently
    has “limited support for creating or manipulating PDF files,” but we’d keep all
    others in contention just in case we need them. For now, we’re going to proceed
    with PyPDF2 and see how it goes.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在这里学到的知识，我们可能会消除 PDFMiner，因为它显然对创建或操作 PDF 文件的支持“有限”，但我们仍会保留所有其他选项，以防万一我们需要它们。目前，我们将继续使用
    PyPDF2 并看看效果如何。
- en: 9.4.2 Writing the tool
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 编写工具
- en: 'Go ahead and install the PyPDF2 module. Be careful with the capitalization:
    the module is called exactly PyPDF2, not pypdf2, pyPDF2, or any other capitalization.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 前往安装 PyPDF2 模块。注意大小写：模块名为 PyPDF2，而不是 pypdf2、pyPDF2 或任何其他大小写形式。
- en: 'In our previous example, we wrote a function to clean up an email that was
    on the clipboard. We didn’t need to pass any information to that function, so
    the function had no parameters. Here, our function will need three parameters:
    the name of the directory with the reports, the name of the directory with the
    covers, and the name of the directory where we want to write our finalized (merged)
    .pdf files.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们编写了一个用于清理剪贴板上的电子邮件的函数。我们不需要向该函数传递任何信息，因此该函数没有参数。在这里，我们的函数将需要三个参数：包含报告的目录名称、包含封面的目录名称以及我们想要写入最终（合并）.pdf
    文件的目录名称。
- en: In our docstring, we need to explain what each of these directories is for and
    also the pattern of the filenames in the directories. After all, Copilot will
    need to know how the reports match up with the cover pages.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文档字符串中，我们需要解释每个目录的作用，以及目录中文件名的模式。毕竟，Copilot 需要知道报告是如何与封面页匹配的。
- en: Trying PyPDF2
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 尝试 PyPDF2
- en: We’re going to use the PyPDF2 Python library to try to get the job done. Look
    back to what Copilot Chat told us about the PyPDF2 library. The sample code it
    gave us used `PdfFileReader` to read existing .pdf files and `PdfFileWriter` to
    create a new .pdf file. It also used `getPage` and `addPage` to manipulate pages.
    Look out for these in the code that Copilot produces—they’re telltale signs that
    Copilot is generating code that’s on the right track. Here’s the prompt that we
    used and the code that Copilot gave us.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 PyPDF2 Python 库来尝试完成这项工作。回顾 Copilot Chat 告诉我们的关于 PyPDF2 库的信息。它给出的示例代码使用了
    `PdfFileReader` 来读取现有的 .pdf 文件，并使用 `PdfFileWriter` 来创建新的 .pdf 文件。它还使用了 `getPage`
    和 `addPage` 来操作页面。注意 Copilot 生成的代码中的这些内容——它们是 Copilot 正在生成正确代码的明显迹象。以下是我们的提示和
    Copilot 给出的代码。
- en: Listing 9.3 Function to add covers to .pdf documents
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3 添加封面到 .pdf 文档的函数
- en: '[PRE34]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '#1 Gets list of the .pdf reports'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 获取 .pdf 报告的列表'
- en: '#2 Loops through the .pdf reports'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 遍历 .pdf 报告'
- en: '#3 We can use report_reader to read the pages of the report.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 我们可以使用 report_reader 来读取报告的页面。'
- en: '#4 We can use report_writer to write pages into a new .pdf file'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 我们可以使用 report_writer 将页面写入新的 .pdf 文件'
- en: '#5 Loops through each page of the report'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 遍历报告的每一页'
- en: '#6 Adds the page to our new .pdf file'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 将页面添加到我们新的 .pdf 文件中'
- en: '#7 Opens the cover associated with this report'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 打开与该报告关联的封面'
- en: '#8 We can use cover_reader to read the cover.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 我们可以使用 cover_reader 来读取封面。'
- en: '#9 Adds the cover to the start of our new .pdf file'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '#9 将封面添加到我们新的 .pdf 文件的开头'
- en: '#10 Saves our new .pdf file'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '#10 保存我们新的 .pdf 文件'
- en: '#11 Calls our function to do all the merging!'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '#11 调用我们的函数来完成所有合并操作！'
- en: Be careful with automation programs
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意自动化程序
- en: Programs like the one we’ve written to merge .pdf files can rip through hundreds
    or thousands of files very quickly. If they aren’t operating correctly, they can
    easily result in damaged or lost files. Any time we use `open` with `'w'` or `'wb'`
    as the second parameter, it means that we’re overwriting a file.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的用于合并 .pdf 文件的程序可以非常快速地处理数百或数千个文件。如果它们操作不正确，它们很容易导致文件损坏或丢失。每次我们使用 `open`
    并将 `'w'` 或 `'wb'` 作为第二个参数时，这意味着我们正在覆盖一个文件。
- en: 'Let’s focus on this line from our program in listing 9.3:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注列表 9.3 中的这一行：
- en: '[PRE35]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It’s using the `open` function to open a file. Specifically, it’s opening the
    current `report_file` file in the `final_dir` directory. The second argument to
    `open` here, `'wb'`, means that we want to open the file so we can write to it
    (that’s the `'w'`) and that the file we’re writing is a binary file (that’s the
    `'b'`), not a text file. If the file doesn’t already exist, then the `'w'` we’ve
    included will result in the file being created. That’s not the dangerous part.
    The dangerous part is what happens when the file already exists. In that case,
    `'w'` wipes out its contents and gives us an empty file that we can start writing
    to. Now, if our program is working correctly and only doing this in our `final_dir`,
    then we’re OK. But this is what we need to carefully verify before letting our
    program loose.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 它正在使用`open`函数打开一个文件。具体来说，它正在打开`final_dir`目录中的当前`report_file`文件。`open`函数这里的第二个参数`'wb'`意味着我们想要打开文件以便写入（这就是`'w'`），而我们正在写入的文件是一个二进制文件（这就是`'b'`），而不是文本文件。如果文件不存在，那么我们包含的`'w'`将导致文件被创建。这不是危险的部分。危险的部分是当文件已经存在时会发生什么。在这种情况下，`'w'`会清除其内容，给我们一个空文件，我们可以开始写入。现在，如果我们的程序运行正确，并且只在我们`final_dir`中这样做，那么我们就没问题。但这是我们让程序运行之前需要仔细验证的。
- en: 'We highly recommend that you first test on a small directory of files that
    you don’t care about. Further, we recommend changing lines of code that open files
    using `''w''` or `''wb''` to print a harmless output message instead, so that
    you can see exactly which files are going to be overwritten or created. For example,
    in our program here, we need to comment out these two lines:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您首先在一个您不关心的文件小目录上测试。此外，我们建议将使用 `'w'` 或 `'wb'` 打开文件的代码行更改为打印一条无害的输出消息，这样您就可以确切地看到哪些文件将被覆盖或创建。例如，在我们的程序中，我们需要注释掉这两行：
- en: '[PRE36]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Instead, we’ll use `print` to print out the file that we would have created
    or overwritten:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用`print`打印出我们本应创建或覆盖的文件：
- en: '[PRE37]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Then, when you run your program, you’ll see the names of files that the program
    *intended* to write. If the output looks good—that is, the program is operating
    exactly on the files that you wanted it to operate on—then you can uncomment the
    code that actually does the work.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当您运行程序时，您将看到程序*打算*写入的文件名。如果输出看起来不错——也就是说，程序正在对您想要的文件进行操作——那么您就可以取消注释实际执行工作的代码。
- en: Exercise caution, and *always* keep backups of your important files!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 练习谨慎，并且*始终*备份您的重要文件！
- en: The last line of the program in listing 9.3 makes the assumption that the directory
    of reports is called `reports`, the directory of cover pages is called `covers`,
    and the directory where the final .pdf files should go is called `final`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3中的程序最后一行假设报告目录被称为`reports`，封面页目录被称为`covers`，最终.pdf文件应该放入的目录被称为`final`。
- en: Now, create the `final` directory. It should be there along with your `reports`
    and `covers` directories.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建`final`目录。它应该与您的`reports`和`covers`目录一起存在。
- en: 'The overall structure of the code looks promising to us: it’s getting a list
    of the .pdf reports, and then, for each one, it’s merging those pages with the
    cover page. It’s using a `for` loop to loop through the pages of the report, which
    is good because it can grab all the pages that way. By contrast, it’s *not* using
    a `for` loop on the cover .pdf file, which again is good because we know that
    the cover has only one page anyway.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的整体结构对我们来说很有希望：它获取了一份.pdf报告的列表，然后，对于每一个，它将那些页面与封面页合并。它使用`for`循环遍历报告的页面，这是好的，因为它可以通过这种方式抓取所有页面。相比之下，它*没有*在封面.pdf文件上使用`for`循环，这同样很好，因为我们知道封面页只有一页。
- en: 'However, the first line of code it gave us looks like it’s using a function
    called `listdir` in a module called os. There are other lines that use this module
    as well. Do we need to be importing that os module? Indeed, we do! And we can
    prove it by running the code. If you run the code, you’ll get an error:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它给出的第一行代码看起来像是在一个名为`os`的模块中使用了一个名为`listdir`的函数。还有其他一些行也使用了这个模块。我们需要导入这个`os`模块吗？实际上，我们需要！我们可以通过运行代码来证明这一点。如果您运行代码，您将得到一个错误：
- en: '[PRE38]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We need to add `import os` at the start of our program to fix this. The updated
    code is in the following listing.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在程序开始处添加`import os`来修复这个问题。更新的代码在下面的列表中。
- en: Listing 9.4 Improved function to add covers to .pdf documents
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.4 改进的添加封面到.pdf文档的功能
- en: '[PRE39]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '#1 We were missing this import before.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们之前缺少这个导入。'
- en: 'We’re not out of the woods yet, though. Our updated program still doesn’t work.
    Here’s the error we get when we run our program:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们还没有走出困境。我们的更新程序仍然无法工作。当我们运行程序时，我们得到了以下错误：
- en: '[PRE40]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '#1 The line in our code that’s causing an error'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 导致错误的代码行'
- en: '#2 We can’t use PdfFileReader anymore—it’s gone!'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们不能再使用PdfFileReader了——它已经消失了！'
- en: 'We’ve run into the problem where Copilot thinks, “Hey, let’s use `PdfFileReader`,
    since I’ve been trained that this is part of PyPDF2,” but between Copilot being
    trained and the time of our writing, the PyPDF2 maintainers have removed `PdfFileReader`
    and replaced it with something else (`PdfReader`, according to the final line
    of the error message). This discrepancy may very well be fixed for you by the
    time you read this book, but we want to pretend it’s still messed up so that we
    can teach you what to do if this does happen to you in the future. At this point,
    we have three options:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了一个问题，Copilot认为，“嘿，让我们使用`PdfFileReader`，因为我被训练过这是PyPDF2的一部分”，但是在Copilot被训练和我们现在写作的时间之间，PyPDF2的维护者已经移除了`PdfFileReader`，并用其他东西（根据错误信息的最后一行，是`PdfReader`）替换了它。这个差异可能在你阅读这本书的时候已经被修复了，但我们想假装它仍然有问题，这样我们就可以教你如果将来这种情况发生在你身上应该怎么做。到目前为止，我们有三种选择：
- en: '*Install an earlier version of PyPDF2.* The last two lines of the error message
    tell us that `PdfFileReader`, the function we need from PyPDF2, was removed in
    PyPDF2 3.0.0\. As a result, if we install a version of PyPDF2 earlier than 3.0.0,
    we should have our function back. In general, installing earlier versions of libraries
    isn’t advisable because security concerns may be present in those versions that
    have since been fixed in more recent versions. In addition, there may be bugs
    present in the older versions that have since been fixed. It’s worth googling
    what has been changed in the library recently to determine whether using an older
    version is safe. In this case, we have done that homework and see no obvious risk
    in using an older version of PyPDF2\.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安装PyPDF2的早期版本。* 错误信息的最后两行告诉我们，我们需要从PyPDF2中获取的函数`PdfFileReader`在PyPDF2 3.0.0版本中被移除了。因此，如果我们安装一个低于3.0.0版本的PyPDF2，我们应该能够恢复我们的函数。一般来说，安装库的早期版本是不推荐的，因为这些版本可能存在安全漏洞，这些漏洞在较新版本中已经被修复。此外，旧版本中可能存在一些后来被修复的bug。值得谷歌一下最近库中发生了什么变化，以确定使用旧版本是否安全。在这种情况下，我们已经完成了这项作业，并看到使用PyPDF2的旧版本没有明显的风险。'
- en: '*Fix the code ourselves using the suggestion in the error message.* That is,
    we would replace `PdfFileReader` with `PdfReader` and run the program again. In
    this case, we would be told about other deprecations, and we’d need to fix those
    following the same process. It’s very nice of the authors of PyPDF2 to tell us
    what to do inside the error messages. For practice, you might like to work through
    this, making each update suggested by the error message. We wish all error messages
    were so useful, but this won’t always be the case. Sometimes, a function will
    be removed without giving us any recourse. In that case, it may be easier to consider
    our next option.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自己修复代码，使用错误信息中的建议。* 也就是说，我们会将`PdfFileReader`替换为`PdfReader`，然后再次运行程序。在这种情况下，我们会被告知其他弃用的情况，我们需要按照相同的过程修复它们。PyPDF2的作者在错误信息中告诉我们该怎么做是非常好的。为了练习，你可能喜欢通过这个，按照错误信息中提出的每个更新进行操作。我们希望所有的错误信息都这么有用，但这种情况并不总是如此。有时，一个函数会被移除，而不给我们任何回旋的余地。在这种情况下，考虑我们的下一个选项可能更容易。'
- en: '*Use a different library.* Earlier, we asked Copilot for other possible .pdf
    Python libraries we could use, and we received many suggestions. If the first
    two of our options here aren’t satisfactory, we could jump to trying one of those.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用不同的库。* 之前，我们向Copilot询问了其他可能的.pdf Python库，我们收到了很多建议。如果这里的头两个选项不满意，我们可以尝试其中之一。'
- en: We’re going to illustrate how to solve the problem and get our code running
    with the first option (using an earlier version of PyPDF2) and the third option
    (using a different library entirely).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何使用第一个选项（使用PyPDF2的早期版本）和第三个选项（使用完全不同的库）来解决问题，并让我们的代码运行起来。
- en: Using an earlier version of PyPDF2
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用PyPDF2的早期版本
- en: When using `pip install` to install a Python library, by default, we get the
    most current version of the library. That’s usually what we want—the latest and
    greatest—but it’s also possible to explicitly request an older version of the
    library.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`pip install`来安装Python库时，默认情况下，我们会得到库的最新版本。这通常是我们想要的——最新和最好的，但也可以明确请求库的旧版本。
- en: Here, we need a version of PyPDF2 prior to version 3.0.0\. Rather than the standard
    usage of pip,
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要PyPDF2的一个低于3.0.0版本的版本。而不是使用pip的标准用法，
- en: '[PRE41]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: we can instead use
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用
- en: '[PRE42]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `< 3.0.0` is what we use to ask for the most recent version of the library
    that’s less than version 3.0.0\. The command should result in output like the
    following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`< 3.0.0`是我们用来请求小于3.0.0版本的最新的库版本。该命令应该产生如下所示的输出：'
- en: '[PRE43]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '#1 We had an existing version that is &gt;= 3.0.0.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们有一个现有的版本，版本号大于等于3.0.0。'
- en: '#2 That version is being removed . . .'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 那个版本正在被移除 ...'
- en: '#3 . . . and version 2.12.1 is being installed.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 ... 正在安装版本2.12.1。'
- en: 'Now we have an older version of PyPDF2 installed. At this point, you should
    be able to run our program. It’ll take a few seconds, and then the job will be
    done. You can check your final directory for the newly created .pdf files. Open
    a few of them to make sure that our program has done the right thing: each .pdf
    file should start with a cover page and contain all the pages of the report (not
    just the first page if the report has multiple pages).'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了PyPDF2的较旧版本。到这一点，你应该能够运行我们的程序。这可能需要几秒钟，然后工作就会完成。你可以检查你的最终目录，看看是否有新创建的.pdf文件。打开几个文件，以确保我们的程序已经正确操作：每个.pdf文件都应该从封面页开始，并包含报告的所有页面（如果报告有多页，不仅仅是第一页）。
- en: Think of how tedious this would have been by hand, and we’ve gotten the computer
    to do it for us. Moreover, the next time we have to do the same thing at work
    (more reports for more people), we’ve got a tool all set to help us get it done
    quickly.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 想想如果手动操作会有多麻烦，我们已经让计算机帮我们完成了这项工作。此外，下次我们在工作中需要做同样的事情（为更多的人制作更多报告）时，我们已经有一个工具可以快速帮助我们完成。
- en: Using a different .pdf library
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用不同的.pdf库
- en: Now let’s try solving our problem with PyPDF2 by using another library—one of
    those that Copilot told us about in our initial conversation about .pdf libraries.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试使用另一个库（Copilot在我们关于.pdf库的初始对话中提到的一个库）通过PyPDF2来解决我们的问题。
- en: 'We won’t go through all the gory details with you on how we decided which library
    to try next, but we’ll walk through the highlights of our journey. We started
    by asking Copilot Chat how we can use the ReportLab Python module to merge .pdf
    files, but that redirected us back to using PyPDF2\. We received the same response
    for FPDF: we were told that FPDF can’t merge .pdf files but that PyPDF2 can. We
    then moved on to asking about PyMuPDF, and this part of the conversation was productive:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细向您介绍我们如何决定尝试下一个库的细节，但我们会概述我们的旅程亮点。我们首先询问Copilot Chat如何使用ReportLab Python模块来合并PDF文件，但这又让我们回到了使用PyPDF2。对于FPDF，我们也得到了同样的回应：我们被告知FPDF不能合并PDF文件，但PyPDF2可以。然后我们转向询问PyMuPDF，这次对话是有成效的：
- en: LPHumanHow can I use the Python PyMuPDF library to merge .pdf files?
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman我如何使用Python PyMuPDF库来合并.pdf文件？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the fitz module
    from the PyMuPDF library to merge PDF files. Here’s an example code snippet that
    shows how to merge two PDF files using PyMuPDF:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 您可以使用PyMuPDF库中的fitz模块来合并PDF文件。以下是一个示例代码片段，展示了如何使用PyMuPDF合并两个PDF文件：'
- en: '[PRE44]`*[PRE45]`*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE44]`*[PRE45]`*'
- en: '*`*import fitz*`*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import fitz*`*'
- en: '*`*# Merge the two PDF files*`*'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*合并两个PDF文件*`*'
- en: '*`*pdf_files = [''file1.pdf'', ''file2.pdf'']*`*'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf_files = [''file1.pdf'', ''file2.pdf'']*`*'
- en: '*`*pdf_writer = fitz.Document()*`*'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf_writer = fitz.Document()*`*'
- en: '*`*for pdf_file in pdf_files:*`*'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*for pdf_file in pdf_files:*`*'
- en: '*`*pdf_reader = fitz.open(pdf_file)*`*'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf_reader = fitz.open(pdf_file)*`*'
- en: '*`*for page in pdf_reader:*`*'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*for page in pdf_reader:*`*'
- en: '*`*pdf_writer.insert_pdf(page)*`*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf_writer.insert_pdf(page)*`*'
- en: '*`*pdf_writer.save(''merged.pdf'')*`*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf_writer.save(''merged.pdf'')*`*'
- en: '*`*pdf_writer.close()*`*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf_writer.close()*`*'
- en: '*[PRE46]*[PRE47]'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE46]*[PRE47]'
- en: This code first creates a list of PDF files to merge (`file1.pdf` and `file2.pdf`).
    It then creates a new `Document` object using `fitz`, which represents the merged
    PDF. It loops through each PDF file in the list, opens it using `fitz`, and inserts
    each page of the PDF file into the `pdf_writer` object using the `insert_pdf()`
    method. Finally, it saves the merged PDF to a new file called `merged.pdf` using
    the `save()` method.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先创建了一个要合并的PDF文件列表（`file1.pdf`和`file2.pdf`）。然后使用`fitz`创建一个新的`Document`对象，代表合并后的PDF。它遍历列表中的每个PDF文件，使用`fitz`打开它，并使用`insert_pdf()`方法将PDF文件的每一页插入到`pdf_writer`对象中。最后，使用`save()`方法将合并后的PDF保存到名为`merged.pdf`的新文件中。
- en: You can modify this code to add any additional content to the merged PDF using
    PyMuPDF. Just create a new `Page` object, add the content to the page, and insert
    the page into the `pdf_writer` object using the `insert_page()` method.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 PyMuPDF 修改此代码，以向合并的 PDF 添加任何其他内容。只需创建一个新的 `Page` 对象，将内容添加到页面，然后使用 `insert_page()`
    方法将页面插入到 `pdf_writer` 对象中。
- en: The sample code here is using `insert_pdf` to add each .pdf file to the merged
    .pdf file. We should be on the lookout for our code using `insert_pdf` as well.
    The library is called PyMuPDF, so we need to install it with
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此处提供的示例代码使用 `insert_pdf` 将每个 .pdf 文件添加到合并的 .pdf 文件中。我们应该留意我们使用 `insert_pdf`
    的代码。这个库叫做 PyMuPDF，所以我们需要使用以下命令来安装它：
- en: '[PRE48]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: But then we have to use `import fitz`? Why `import fitz` and not `import PyMuPDF`?
    Apparently, the designers of this library liked fitz more than PyMuPDF, so we’ll
    need to go with it. It’s rare indeed, but occasionally we use one name to install
    the library and another to import it!
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后我们必须使用 `import fitz`？为什么使用 `import fitz` 而不是 `import PyMuPDF`？显然，这个库的设计者更喜欢
    fitz 而不是 PyMuPDF，所以我们将使用它。这确实很少见，但偶尔我们会使用一个名称来安装库，另一个名称来导入它！
- en: If you encounter NameError when you import
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 当你导入时遇到 NameError，
- en: If Python gives you a `NameError` referring to the library that you’re trying
    to import, it’s a good bet that you haven’t successfully imported that library.
    It could be that the library isn’t in fact installed, or that you need to use
    a different name to import it. Use Copilot Chat to have a conversation if you
    ever find that you’ve installed a library but can’t seem to import it.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Python 给你一个关于你试图导入的库的 `NameError`，那么很可能你没有成功导入那个库。可能是库实际上没有安装，或者你需要使用不同的名称来导入它。如果你发现你安装了库但似乎无法导入它，请使用
    Copilot Chat 进行对话。
- en: Now we’re ready to generate some code. The following listing shows the prompt
    that we used and the code that Copilot gave us.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备生成一些代码。以下列表显示了我们所使用的提示和 Copilot 给出的代码。
- en: Listing 9.5 Improved function to add covers to .pdf documents
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5 用于向 .pdf 文档添加封面的改进函数
- en: '[PRE49]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '#1 If the final_dir directory doesn’t exist, . . .'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 如果 final_dir 目录不存在， . . .'
- en: '#2 . . . create the final_dir directory.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 . . . 创建 final_dir 目录。'
- en: '#3 Loops through the .pdf reports'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 遍历 .pdf 报告'
- en: '#4 Used to read the cover'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 用于读取封面'
- en: '#5 Used to read the report'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 用于读取报告'
- en: '#6 Used as our new output file'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 用作我们的新输出文件'
- en: '#7 Adds the cover to our new .pdf file'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 将封面添加到我们的新 .pdf 文件中'
- en: '#8 Adds the report to our new .pdf file'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 将报告添加到我们的新 .pdf 文件中'
- en: '#9 Saves our new .pdf file'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '#9 保存我们的新 .pdf 文件'
- en: This program happens to start with some code that creates the output directory
    if it doesn’t already exist. After that, the steps are similar to those in our
    earlier program that used PyPDF2, although the functions called by each program
    are different. (That makes sense because PyPDF2 and PyMuPDF are different libraries,
    with different features and functions.) In both cases, we’re using `listdir` to
    get a list of the report .pdf filenames. In the `for` loop, we go through each
    of those reports; the code in the loop is responsible for creating a new .pdf
    file that contains the cover followed by the report. In our PyPDF2 code, there
    was an inner `for` loop that we needed to loop through all the pages of the report.
    In our current program, we don’t need that because Copilot used the `insert_pdf`
    function, which inserts a .pdf file into another .pdf file in one shot (not page
    by page). Whether you took the approach of installing the older library or you
    chose to use a different library, we’ve solved our problem and automated what
    would have been an unpleasantly tedious task.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序恰好以一些代码开始，这些代码会在输出目录不存在的情况下创建它。之后，步骤与我们在之前使用 PyPDF2 的程序中使用的步骤相似，尽管每个程序调用的函数不同。（这是有道理的，因为
    PyPDF2 和 PyMuPDF 是不同的库，具有不同的功能和函数。）在两种情况下，我们都在使用 `listdir` 来获取报告 .pdf 文件名列表。在
    `for` 循环中，我们遍历这些报告；循环中的代码负责创建一个新的 .pdf 文件，其中包含封面后跟报告。在我们的 PyPDF2 代码中，有一个嵌套的 `for`
    循环，我们需要遍历报告的所有页面。在我们的当前程序中，我们不需要这样做，因为 Copilot 使用了 `insert_pdf` 函数，该函数一次（而不是逐页）将
    .pdf 文件插入到另一个 .pdf 文件中。无论你选择安装较旧的库还是选择使用不同的库，我们都解决了问题，并自动化了原本可能是一项令人不愉快的繁琐任务。
- en: Notice that we’ve slightly altered the workflow that we described in the previous
    chapter to take into account handling the different Python modules that could
    aid you with your task. A modified workflow is provided in figure 9.2.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经稍微修改了上一章中描述的工作流程，以考虑到处理可能帮助你完成任务的不同 Python 模块。图 9.2 提供了一个修改后的工作流程。
- en: '![figure](../Images/9-2.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-2.png)'
- en: Figure 9.2 Additions to our workflow to account for working with different Python
    modules
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2 为处理不同Python模块而添加到我们的工作流程中的内容
- en: '9.5 Example 3: Merging phone picture libraries'
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 示例3：合并手机照片库
- en: Now suppose that you take a lot of pictures on your phone. Your partner (or
    sibling, parent, or child) also takes a lot of pictures on their phone. You each
    have hundreds or thousands of pictures! Sometimes you send pictures to your partner,
    and they send pictures to you, so that you and your partner have some but not
    all of each other’s pictures.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你在手机上拍了大量照片。你的伴侣（或兄弟姐妹、父母或孩子）也在他们的手机上拍了大量照片。你们每个人都有数百或数千张照片！有时你会给伴侣发送照片，他们也会给你发送照片，这样你和伴侣就拥有了一些但不是全部的照片。
- en: You live life like this for a while, but honestly, it’s becoming a mess. Half
    the time when you want a picture, you can’t find it because it’s a picture that
    your partner took on their phone that they didn’t send you. And, you’re starting
    to have many duplicate pictures all over the place.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你这样生活了一段时间，但说实话，这变得越来越乱。一半的时候你想找一张照片，却找不到，因为那是你的伴侣在他们手机上拍的照片，他们没有发给你。而且，你开始到处都有很多重复的照片。
- en: 'You then have an idea: “What if we take all the pictures from my phone and
    all the pictures from your phone, and we create a combined library of all the
    pictures! Then we’ll have all the pictures in one place!” Remember that both of
    your phones may have hundreds of pictures, so doing this manually is out of the
    question. We’re going to automate this!'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你有了这样一个想法：“如果我们把我的手机上的所有照片和你的手机上的所有照片都合并在一起，创建一个包含所有照片的合并库！那么我们就会有一个地方可以找到所有的照片！”记住，你们两个的手机可能都有数百张照片，所以手动做这件事是不可能的。我们将自动化这个过程！
- en: To specify our task more precisely, we’ll say that we have two directories of
    pictures (think of each directory as the contents of a phone) that we want to
    combine into a new directory. A common file format for pictures is a .png file,
    so we’ll work with those files here. Your actual phone might use .jpg files rather
    than .png files, but don’t worry. You can adapt what we do here to that picture
    file format (or any other picture file format) if you like.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更精确地指定我们的任务，我们将说我们有两个图片目录（将每个目录想象成手机的存储内容），我们希望将它们合并到一个新的目录中。图片的常见文件格式是.png文件，所以我们将在这里处理这些文件。你的实际手机可能使用.jpg文件而不是.png文件，但不用担心。如果你喜欢，你可以将我们在这里做的事情适应到那种图片文件格式（或任何其他图片文件格式）。
- en: In the resources for this book, in the ch9 directory, you’ll find two subdirectories
    of picture files. These subdirectories are named pictures1 and pictures2\. You
    can imagine that pictures1 has the pictures from your phone (98 pictures) and
    pictures2 has the pictures from your partner’s phone (112 pictures). We’re going
    to combine these two phone directories into a new directory.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的资源中，在ch9目录下，你可以找到两个图片子目录。这些子目录被命名为pictures1和pictures2。你可以想象pictures1包含你手机上的照片（98张照片）和pictures2包含你伴侣手机上的照片（112张照片）。我们将把这两个手机目录合并到一个新的目录中。
- en: Open some of the .png files in the same way that you open pictures or photos
    on your computer. The pictures we’ve generated are just some random shapes, but
    the program we write here will work no matter what’s inside the pictures.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 以与你在电脑上打开图片或照片相同的方式打开一些.png文件。我们生成的图片只是随机形状，但我们在这里编写的程序将适用于图片中的任何内容。
- en: At the outset, we said that the same picture might be on both phones, so we’ve
    generated some duplicate files in our pictures. (We have a total of 210 picture
    files, but 10 of them are duplicates, so there are only 200 unique pictures.)
    For example, in the pictures1 directory, there’s a file called 1566.png, and in
    the pictures2 directory, there’s a file called 2471.png. These two files are identical,
    and when we generate our directory of files from both phones, we’ll only want
    to keep one of these. What’s tricky here is that these pictures are the same even
    though their filenames are not.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们就说过同一张照片可能出现在两部手机上，所以我们已经在图片中生成了一些重复的文件。（我们总共有210个图片文件，但其中10个是重复的，所以只有200张独特的图片。）例如，在pictures1目录中有一个名为1566.png的文件，在pictures2目录中有一个名为2471.png的文件。这两个文件是相同的，当我们从两部手机生成文件目录时，我们只想保留其中一个。这里棘手的是，尽管它们的文件名不同，但这些图片实际上是相同的。
- en: 'What if two filenames are the same? Does that mean that the pictures are the
    same? For example, notice that each directory, pictures1 and pictures2, has a
    file called 9595.png. You might think that filenames being the same means that
    the pictures inside will be the same too. But no, if you open these pictures,
    you’ll see that they’re different! This could happen in real life too: you and
    your partner could both take different pictures, and, however remote, it’s possible
    that the filenames your phones choose for those pictures just happen to be the
    same.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个文件名相同，这难道意味着图片也相同吗？例如，请注意，每个目录，pictures1 和 pictures2，都有一个名为 9595.png 的文件。你可能认为文件名相同意味着里面的图片也会相同。但不是这样，如果你打开这些图片，你会发现它们是不同的！这种情况在现实生活中也可能发生：你和你的伴侣可能拍了不同的图片，而且不管有多遥远，手机为这些图片选择的文件名恰好相同。
- en: If we’re not careful, we’ll end up copying 9595.png from pictures1 into our
    new directory and then overwriting it later by copying 9595.png from pictures2
    into our new directory. We need to be sure that when we copy a file, we’re not
    overwriting a different picture that may already be there with the same filename.
    We provide an example of this process in figure 9.3.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不小心，我们可能会将 pictures1 中的 9595.png 复制到我们的新目录中，然后稍后通过从 pictures2 中复制 9595.png
    到我们的新目录来覆盖它。我们需要确保当我们复制文件时，我们不会覆盖可能已经存在的不同图片，而这些图片具有相同的文件名。我们在图 9.3 中提供了一个这个过程示例。
- en: '![figure](../Images/9-3.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/9-3.png)'
- en: Figure 9.3 Example of merging the photos in the pictures1 and pictures2 folders
    into the pictures–combined folder and managing the removal of duplicates
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.3 将 pictures1 和 pictures2 文件夹中的照片合并到 pictures–combined 文件夹中并管理删除重复项的示例
- en: We’re working with directories, not actual phones
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 我们正在处理目录，而不是实际的手机
- en: We’re assuming here that you have two directories of pictures already on your
    computer. These directories could have come from anywhere, and nothing we do here
    has anything specific to do with cell phones.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里假设你已经在电脑上有了两个图片目录。这些目录可能来自任何地方，我们在这里所做的一切都与手机无关。
- en: But if you wanted to do this task for real, with pictures on your phones, you’d
    need to get those pictures onto your computer first. You could use ChatGPT to
    have that discussion! As the details are specific to different phones and go beyond
    what we want to use Copilot to automate, we won’t go further into this here.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '但如果你真的想用手机上的图片来完成这个任务，你需要首先将这些图片上传到电脑上。你可以使用 ChatGPT 来进行这个讨论！由于这些细节与不同的手机有关，并且超出了我们想要使用
    Copilot 自动化的范围，所以我们在这里不会进一步讨论。 '
- en: 9.5.1 Conversing with Copilot
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1 与 Copilot 对话
- en: Our tool is going to create a combined directory of pictures from pictures1
    and pictures2, but without duplicate pictures. If our combined original picture
    directories have the same picture multiple times, we want only one of those copies
    of the picture to survive in our new directory.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工具将从 pictures1 和 pictures2 中创建一个图片的合并目录，但不会包含重复的图片。如果我们合并的原始图片目录中有相同的图片多次，我们只想保留其中一张图片的副本在我们的新目录中。
- en: 'At this point, there are at least two things we might like to know: How do
    we copy a file using Python, and how do we know whether two files are the same
    picture? Let’s start by asking Copilot Chat how we can copy a file:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可能想知道至少两件事：我们如何使用 Python 复制文件，以及我们如何知道两个文件是否是同一张图片？让我们先询问 Copilot Chat
    我们如何复制文件：
- en: LPHumanI need to write a Python program that copies files. How do I do this?
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman 我需要编写一个 Python 程序来复制文件。我该如何做？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the shutil module
    in Python to copy files. Here’s an example:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 你可以使用 Python 中的 shutil 模块来复制文件。以下是一个示例：'
- en: '[PRE50]`*[PRE51]`*'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE50]`*[PRE51]`*'
- en: '*`*import shutil*`*'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import shutil*`*'
- en: '*`*# Replace the source and destination paths with your own*`*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Replace the source and destination paths with your own*`*'
- en: '*`*source = ''/path/to/source/file''*`*'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*source = ''/path/to/source/file''*`*'
- en: '*`*destination = ''/path/to/destination/file''*`*'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*destination = ''/path/to/destination/file''*`*'
- en: '*`*# Copy the file*`*'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Copy the file*`*'
- en: '*`*shutil.copy(source, destination)*`*'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*shutil.copy(source, destination)*`*'
- en: '*[PRE52]*[PRE53]'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE52]*[PRE53]'
- en: This will copy the file from the source path to the destination path. If the
    destination file already exists, it will be overwritten.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把文件从源路径复制到目标路径。如果目标文件已存在，它将被覆盖。
- en: Excellent. We can use that shutil module to copy a file; we’ll need to remember
    to import that module. The final sentence that Copilot gave us is an important
    warning. We should be careful to avoid copying a file over the top of another
    file that already exists. Next, let’s determine whether this shutil module is
    built-in to Python.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。我们可以使用那个shutil模块来复制文件；我们需要记住导入这个模块。Copilot给出的最后一句是一个重要的警告。我们应该小心避免覆盖已经存在的文件。接下来，让我们确定这个shutil模块是否是Python内置的。
- en: LPHumanIs this shutil module built into Python?
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman这个shutil模块是Python内置的吗？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, the shutil module is a
    built-in module in Python, so you don’t need to install anything extra to use
    it.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 是的，shutil模块是Python的一个内置模块，所以你不需要安装任何额外的包来使用它。'
- en: You might wonder why we’re focusing on making copies of files and putting them
    into our new directory, rather than moving them from our original directories
    into the new directory. The reason is that we want to leave our original directories
    alone just in case we have a bug and fail to get all the files into our new directory.
    If anything goes wrong in our new directory, it won’t matter because our original
    directories will still be intact.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，为什么我们专注于在新的目录中复制文件而不是将它们从原始目录移动到新目录。原因是我们想保持原始目录不变，以防我们有一个bug并且未能将所有文件都复制到新目录中。如果新目录中发生任何问题，那没关系，因为我们的原始目录仍然完好无损。
- en: That wraps up what we need to know about copying files. Now let’s move on to
    learn how we can determine whether two files are the same picture.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们需要了解的关于复制文件的知识。现在让我们继续学习如何确定两个文件是否是同一张图片。
- en: As we’ve already said, it’s not sufficient to use filenames to determine whether
    pictures are the same. How can we do it, then?
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所说，仅使用文件名来确定图片是否相同是不够的。那么我们该如何做呢？
- en: LPHumanUsing Python, how can I determine whether .png files are the same?
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman使用Python，我该如何确定.png文件是否相同？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the filecmp module
    in Python to compare two files and check if they are the same. Here’s an example
    code snippet that compares two .png files:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 你可以使用Python中的filecmp模块来比较两个文件并检查它们是否相同。这里有一个比较两个.png文件的代码片段示例：'
- en: '[PRE54]`*[PRE55]`*'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE54]`*[PRE55]`*'
- en: '*`*import filecmp*`*'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import filecmp*`*'
- en: '*`*# Replace these file paths with the actual file paths of the .png files*`*'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# Replace these file paths with the actual file paths of the .png files*`*'
- en: '*`*# you want to compare*`*'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# you want to compare*`*'
- en: '*`*file1 = ''/path/to/file1.png''*`*'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*file1 = ''/path/to/file1.png''*`*'
- en: '*`*file2 = ''/path/to/file2.png''*`*'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*file2 = ''/path/to/file2.png''*`*'
- en: '*`*if filecmp.cmp(file1, file2):*`*'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*if filecmp.cmp(file1, file2):*`*'
- en: '*`*print(''The files are the same.'')*`*'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(''The files are the same.'')*`*'
- en: '*`*else:*`*'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*else:*`*'
- en: '*`*print(''The files are different.'')*`*'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(''The files are different.'')*`*'
- en: '*[PRE56]*[PRE57]'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE56]*[PRE57]'
- en: This code will compare the contents of the two files and return `True` if they
    are the same, and `False` if they are different.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将比较两个文件的 内容，如果它们相同则返回`True`，如果不同则返回`False`。
- en: As a quick aside, the last sentence from Copilot is wrong. That code isn’t returning
    `True` or `False` anywhere. Just like Copilot can generate faulty code for us
    in our Python file, Copilot Chat can produce faulty explanations.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小插曲，Copilot的最后一句是错误的。那段代码在任何地方都没有返回`True`或`False`。就像Copilot可以在我们的Python文件中为我们生成错误的代码一样，Copilot
    Chat也可以产生错误的解释。
- en: Our prompt wasn’t precise about the number of files that we need to compare.
    Do we want to compare two files? Hundreds of files? Our prompt doesn’t say. Copilot
    has told us what to do if we want to compare two files, which is a reasonable
    thing to tell us. But that’s not quite what we need. We need to be able to determine,
    among hundreds of files, which files are duplicates of other files. That way,
    we can detect a duplicate file and not copy it into our new directory. Let’s try
    again.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的提示并没有精确说明我们需要比较的文件数量。我们是想比较两个文件吗？还是几百个文件？我们的提示没有说。Copilot告诉我们如果想要比较两个文件应该怎么做，这是合理的。但这并不是我们需要的。我们需要能够在几百个文件中确定哪些文件是其他文件的副本。这样，我们就可以检测到重复文件，并且不会将其复制到新目录中。让我们再试一次。
- en: LPHumanWhat if I have hundreds of .png files and I want to find duplicates—is
    that approach you gave me still good?
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman如果我有一百多个.png文件，并且我想找到重复的文件，你给我的那种方法仍然有效吗？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot If you have hundreds of .png
    files and you want to find duplicates, you can use the os module to iterate over
    all the files in a directory and compare each file to every other file in the
    directory. Here’s an example code snippet that does that:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 如果您有数百个.png文件，并且想要查找重复项，您可以使用os模块遍历目录中的所有文件，并将每个文件与目录中的每个其他文件进行比较。以下是一个示例代码片段，展示了如何做到这一点：'
- en: '[PRE58]`*[PRE59]`*'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE58]`*[PRE59]`*'
- en: '*`*import os*`*'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import os*`*'
- en: '*`*import filecmp*`*'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import filecmp*`*'
- en: '*`*# Replace this with the actual directory path where your .png*`*'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 将此替换为实际的目录路径，其中包含您的.png*`*'
- en: '*`*# files are located*`*'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 文件位置*`*'
- en: '*`*directory = ''/path/to/directory''*`*'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*directory = ''/path/to/directory''*`*'
- en: '*`*# Iterate over all the files in the directory*`*'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 遍历目录中的所有文件*`*'
- en: '*`*for filename1 in os.listdir(directory):*`*'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*for filename1 in os.listdir(directory):*`*'
- en: '*`*if filename1.endswith(''.png''):*`*'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*if filename1.endswith(''.png''):*`*'
- en: '*`*for filename2 in os.listdir(directory):*`*'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*for filename2 in os.listdir(directory):*`*'
- en: '*`*if filename2.endswith(''.png'') and filename1 != filename2:*`*'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*if filename2.endswith(''.png'') and filename1 != filename2:*`*'
- en: '*`*file1 = os.path.join(directory, filename1)*`*'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*file1 = os.path.join(directory, filename1)*`*'
- en: '*`*file2 = os.path.join(directory, filename2)*`*'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*file2 = os.path.join(directory, filename2)*`*'
- en: '*`*if filecmp.cmp(file1, file2):*`*'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*if filecmp.cmp(file1, file2):*`*'
- en: '*`*print(f''{filename1} and {filename2} are duplicates.'')*`*'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(f''{filename1} and {filename2} are duplicates.'')*`*'
- en: '*[PRE60]*[PRE61]'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE60]*[PRE61]'
- en: This code will iterate over all the files in the directory and compare each
    `.png` file to every other `.png` file in the directory. If two files are the
    same, it will print a message indicating that they are duplicates. Note that this
    approach can be slow for large directories with many files.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将遍历目录中的所有文件，并将目录中的每个`.png`文件与每个其他`.png`文件进行比较。如果两个文件相同，它将打印一条消息，指出它们是重复的。请注意，对于包含大量文件的目录，这种方法可能很慢。
- en: 'The outer `for` loop goes through each file in the directory. How do we know
    whether the current file has a duplicate? Well, we can go through each other file
    in the directory and compare it to the current file. That’s the role of the inner
    `for` loop: it uses `filecmp.cmp` to compare the current file (`file1`) to each
    other file (`file2`).'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 外层`for`循环遍历目录中的每个文件。我们如何知道当前文件是否有重复项呢？嗯，我们可以遍历目录中的其他文件，并将它们与当前文件进行比较。这就是内层`for`循环的作用：它使用`filecmp.cmp`将当前文件（`file1`）与每个其他文件（`file2`）进行比较。
- en: We didn’t mention in our prompt that we care about finding duplicates across
    multiple directories, so Copilot has focused on a single directory here. If that
    difference turns out to be a roadblock, we could make our prompt more precise.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的提示中，我们没有提到我们关心跨多个目录查找重复项，所以Copilot在这里关注的是单个目录。如果这种差异成为障碍，我们可以使我们的提示更加精确。
- en: Copilot is using two other modules here, os and filecmp. We could ask Copilot
    if these are built-in Python modules or not, but we’ll save a little time and
    just tell you here that they are built-in.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot在这里使用了两个其他模块，os和filecmp。我们可以询问Copilot这些是否是内置的Python模块，但我们将节省一点时间，在这里直接告诉您它们是内置的。
- en: 'We now want you to focus on the final sentence from Copilot: “Note that this
    approach can be slow for large directories with many files.” How slow is “slow”?
    How many is “many”? We don’t know.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望您关注Copilot的最后一句：“请注意，这种方法对于包含大量文件的目录来说可能很慢。”“慢”有多慢？“多”有多少？我们不知道。
- en: You might be tempted to ask Copilot for a better solution, one that isn’t “slow
    for large directories with many files.” But many programmers wouldn’t do that.
    It’s often a mistake to optimize our solution before we have even tried out our
    (unoptimized, apparently slow) approach for two reasons. First, maybe our “slow”
    program turns out to be fast enough! We may as well try it. Second, more optimized
    programs are often more sophisticated programs, and they may be more difficult
    for us to get right. That isn’t always the case, but it can be. And again, if
    our unoptimized program gets the job done, we don’t even have to worry about a
    more optimized version at all.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想要求Copilot提供一个更好的解决方案，一个对于“对于包含大量文件的目录来说可能很慢”的解决方案。但许多程序员不会这样做。在我们尝试我们的（未优化的、显然慢的）方法之前，优化我们的解决方案通常是一个错误，原因有两个。首先，也许我们的“慢”程序最终足够快！我们不妨试试。其次，更优化的程序通常是更复杂的程序，它们可能更难正确实现。这并不总是这种情况，但它可能是。而且，如果我们的未优化程序完成了工作，我们甚至不必担心更优化的版本。
- en: Now, if it turns out that our program really is too slow or you find yourself
    using the program repeatedly, then it may be worth the extra investment in continuing
    to work with Copilot on a faster solution. For now, though, we’re good.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们的程序真的太慢，或者你发现自己反复使用这个程序，那么继续与Copilot合作以获得更快的解决方案可能值得额外的投资。不过，目前来说，我们做得很好。
- en: 9.5.2 Top-down design
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.2 自顶向下设计
- en: There’s a little more going on in this task than in our prior two tasks. For
    one, we need to be careful not to overwrite a file that already exists in our
    new directory. For another, we need to determine which files to copy in the first
    place (remember that we only want to copy files that don’t already match a file
    in our new directory). Compare this to the .pdf merging task we just accomplished,
    where we didn’t have these extra concerns.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务比我们之前两个任务要复杂一些。一方面，我们需要小心不要覆盖我们新目录中已经存在的文件。另一方面，我们需要确定首先需要复制哪些文件（记住我们只想复制那些在新目录中不匹配的文件）。这与我们刚刚完成的.pdf合并任务形成对比，在那个任务中我们没有这些额外的担忧。
- en: To that end, we’re going to use top-down design and problem decomposition here.
    Don’t worry, it won’t be a full-on top-down design example like we did in chapter
    7\. Our task here is much smaller than our spelling suggestions task from that
    chapter. We’ll just do a little top-down design and that will help Copilot get
    us what we want.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，我们将在这里使用自顶向下设计和问题分解。不用担心，这不会是一个像我们在第7章中做的完全自顶向下的设计示例。我们这里的任务比第7章中的拼写建议任务要小得多。我们只需进行一点自顶向下的设计，这将帮助Copilot为我们提供我们想要的结果。
- en: 'Our top-level function will be responsible for solving our overall task: taking
    the pictures1 and pictures2 directories and putting all unique pictures into a
    target directory. Back in chapter 3, we learned that we should make functions
    as general as we can, to make them more useful or generalizable to other tasks.
    Here, we’ve been thinking about combining two picture directories together. But
    why not 3, 5, or 50 directories? Who cares how many directories we have; we should
    be able to just combine as many directories as we want.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的顶级函数将负责解决我们的整体任务：将pictures1和pictures2目录中的所有独特图片放入目标目录。在第三章，我们学习了我们应该尽可能使函数通用，以便使它们更有用或更易于推广到其他任务。在这里，我们一直在考虑合并两个图片目录。但为什么不是3、5或50个目录呢？谁在乎我们有多少个目录；我们应该能够合并我们想要的任意多个目录。
- en: So, instead of designing our top-level function to take two strings (directory
    names) as parameters, we’ll have the function take a list of strings. That way,
    we can use it on as many picture directories as we want. And, we can still readily
    use it on two picture directories—we’ll just pass a list containing the names
    of the two directories.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不会设计我们的顶级函数以接受两个字符串（目录名）作为参数，我们将让函数接受一个字符串列表。这样，我们就可以用它来处理我们想要的任意多个图片目录。而且，我们仍然可以轻松地用它来处理两个图片目录——我们只需传递一个包含两个目录名称的列表。
- en: 'We’ll name our top-level function `make_copies`. We’ll need two parameters:
    the list of directory names that we just discussed, and the name of our target
    directory where we want all the files to go.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将命名我们的顶级函数为`make_copies`。我们需要两个参数：我们刚才讨论的目录名称列表，以及我们想要所有文件都放入的目标目录的名称。
- en: What’s this function going to do? It’s going to loop through each directory
    in the list of directories, and then, for each directory, it’s going to loop through
    each file. For each file, we need to determine whether to copy it or not and,
    if we need to copy it, to do the actual copying.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将要做什么？它将遍历目录列表中的每个目录，然后，对于每个目录，它将遍历每个文件。对于每个文件，我们需要确定是否复制它，如果需要复制，则执行实际的复制操作。
- en: 'Determining whether to copy the file, and then possibly copying it, is a subtask
    that we can split out of `make_copies`. We’ll name our function for this subtask
    `make_copy`. Our `make_copy` function will take two parameters: the name of a
    file and the target directory. If the file isn’t identical to any file in the
    target directory, then the function will copy the file into the target directory.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 确定是否复制文件，然后可能复制它，这是一个可以从`make_copies`中分离出来的子任务。我们将为这个子任务命名函数为`make_copy`。我们的`make_copy`函数将接受两个参数：文件的名称和目标目录。如果文件与目标目录中的任何文件都不相同，那么该函数将把文件复制到目标目录中。
- en: Say we want to copy a file called 9595.png from one of our picture directories
    into our target directory but that file already exists in the target directory.
    We don’t want to overwrite the file that’s already there, so we’ll need to come
    up with a new filename. We might try adding an _ (underscore) character prior
    to the .png part of the filename. That would give us 9595_.png. That one probably
    wouldn’t exist in the target directory, but if it did, we could then try 9595__.png,
    9595___.png, and so on, until we find a filename that doesn’t already exist in
    there.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将名为9595.png的文件从一个图片目录复制到我们的目标目录，但该文件已经在目标目录中存在。我们不希望覆盖已经存在的文件，因此我们需要想出一个新的文件名。我们可能会尝试在文件名中的.png部分之前添加一个_（下划线）字符。这将给我们9595_.png。这个文件可能不在目标目录中，但如果它确实存在，我们可以尝试9595__.png，9595___.png，等等，直到我们找到一个不存在的文件名。
- en: Generating a unique filename is a task that we can split out of our `make_copy`
    function. We’ll call it `get_good_filename`. It will take a filename as a parameter
    and return a version of that filename that doesn’t already exist.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个唯一的文件名是我们可以从`make_copy`函数中分离出来的任务。我们将称它为`get_good_filename`。它将接受一个文件名作为参数，并返回一个不存在的文件名版本。
- en: And with that, our top-down design is done. Figure 9.4 depicts our work as a
    tree (well, at least the trunk of a tree), showing which function is called by
    which other function.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的自顶向下设计就完成了。图9.4描绘了我们的工作作为一个树（至少是树的树干），显示了哪个函数被哪个其他函数调用。
- en: '![figure](../Images/9-4.png)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/9-4.png)'
- en: Figure 9.4 Top-down design for image merging. The top-most (left-most) function
    is `make_copies`, the child of that is `make_copy`, and the child of that is `get_good_filename`.
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4 图像合并的自顶向下设计。最顶层（最左侧）的函数是`make_copies`，它的子函数是`make_copy`，而`make_copy`的子函数是`get_good_filename`。
- en: 9.5.3 Writing the tool
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.3 编写工具
- en: We don’t have any modules to install this time around. We do know from our Copilot
    conversation that we’ll use the built-in shutil module to copy files. We’ll also
    use the built-in filecmp module to compare files and the built-in os module to
    get a list of the files in a directory. We’ll therefore import these three modules
    at the top of our Python program.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们没有需要安装的模块。我们知道从我们的Copilot对话中，我们将使用内置的shutil模块来复制文件。我们还将使用内置的filecmp模块来比较文件，以及内置的os模块来获取目录中的文件列表。因此，我们将在Python程序的顶部导入这三个模块。
- en: As in chapter 7, we’re going to solve our problem by starting at the bottom
    of our function tree and working toward the top. We do that so Copilot can call
    our already-written functions when writing code for a parent function. For each
    function, we provide the `def` line and docstring, and Copilot writes the code.
    We’ve also provided some annotations to explain how the code works.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 正如第7章所述，我们将从函数树的底部开始解决问题，逐步向上工作。我们这样做是为了当Copilot为父函数编写代码时，可以调用我们已编写的函数。对于每个函数，我们提供`def`行和文档字符串，然后Copilot编写代码。我们还提供了一些注释来解释代码的工作原理。
- en: Looking again at figure 9.4, we see that the first function we need to implement
    is `get_good_filename`. Let’s get that one done now in the following listing.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看图9.4，我们看到我们需要实现的第一项功能是`get_good_filename`。现在让我们在下面的列表中完成这个功能。
- en: Listing 9.6 `get_good_filename` function for our picture merge task
  id: totrans-477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.6 为我们的图片合并任务编写的`get_good_filename`函数
- en: '[PRE62]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '#1 While the filename exists . . .'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 当文件名存在时...'
- en: '#2 . . . insert an _ prior to .png by replacing .png with _.png.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 ...在.png之前插入一个_，通过将.png替换为_.png。'
- en: '#3 Returns the filename that we know now doesn’t exist'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 返回我们现在知道不存在的文件名'
- en: 'The next function we need to write is `make_copy`. This is the function that
    copies a file into a target directory but only if the file isn’t identical to
    a file that we’ve already copied. We’re looking for Copilot to do several things
    in its code here:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们需要编写的函数是`make_copy`。这个函数将文件复制到目标目录，但前提是文件与我们之前复制的文件不相同。我们希望Copilot在其代码中完成以下几件事情：
- en: Use `os.listdir` to get a list of files in the target directory.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`os.listdir`获取目标目录中的文件列表。
- en: Use `filecmp.cmp` to determine whether two files are identical.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`filecmp.cmp`确定两个文件是否相同。
- en: Use `shutil.copy` to copy the file if there was no identical file.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`shutil.copy`复制文件，如果没有找到相同的文件。
- en: Call the function `get_good_filename` that we just wrote.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用我们刚刚编写的`get_good_filename`函数。
- en: The following listing shows our prompt and the code that Copilot provided. Notice
    that the code is doing everything that we wanted it to do.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了我们的提示和Copilot提供的代码。请注意，代码正在做我们希望它做的事情。
- en: Listing 9.7 `make_copy` function for our pictures merge task
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.7 `make_copy`函数，用于我们的图片合并任务
- en: '[PRE63]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '#1 Loops through the files in the target directory'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 遍历目标目录中的文件'
- en: '#2 If the file is the same as one of the files in the target directory, . .
    .'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 如果文件与目标目录中的某个文件相同，……'
- en: '#3 . . . returns from the function without having copied the file.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 ……从函数中返回而没有复制文件。'
- en: '#4 Otherwise, copies the file and uses a good filename that doesn’t already
    exist.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 否则，复制文件并使用一个尚未存在的良好文件名。'
- en: There’s only one function to go, and it’s our top-level `make_copies` function.
    For each file in each of our picture directories, we’re expecting the code to
    call `make_copy` to copy the file if needed, as shown in the following listing.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下最后一个函数，那就是我们的顶级`make_copies`函数。对于我们的每个图片目录中的每个文件，我们期望代码调用`make_copy`来复制文件（如果需要的话），如下面的列表所示。
- en: Listing 9.8 `make_copies` function for our picture merge task
  id: totrans-495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.8 `make_copies`函数，用于我们的图片合并任务
- en: '[PRE64]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '#1 Loops through our picture directories'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 遍历我们的图片目录'
- en: '#2 Loops through the files in the current picture directory'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 遍历当前图片目录中的文件'
- en: '#3 Copies the current file into the target directory, if needed'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 如果需要，将当前文件复制到目标目录'
- en: '#4 Runs our program on our two picture directories and the given target directory'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 在我们的两个图片目录和给定的目标目录上运行我们的程序'
- en: The final line of code from Copilot, beneath the `make_copies` function, makes
    the assumption that our target directory will be named pictures_combined. Create
    that directory now so that it sits alongside your pictures1 and pictures2 directories
    of pictures.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot在`make_copies`函数下面的最后一行代码假设我们的目标目录将被命名为pictures_combined。现在创建该目录，以便它位于你的图片1和图片2目录旁边。
- en: As we discussed when working with .pdf files earlier in the chapter, it’s important
    that you first test the program on sample directories that you don’t care about.
    Your sample directories should have only a few files in them, so that you can
    manually determine whether the program is working as expected. You should also
    include important edge cases, such as having the same filename in each directory.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面处理.pdf文件时讨论的那样，你首先在你不关心的样本目录上测试程序是很重要的。你的样本目录中应该只有几个文件，这样你可以手动确定程序是否按预期工作。你还应该包括重要的边缘情况，例如每个目录中都有相同的文件名。
- en: Once you have your sample directories, you should create a “harmless” version
    of the program that simply outputs messages rather than actually copying files.
    For our program here, you would change the line in `make_copy` to use `print`
    rather than `shutil.copy`.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了样本目录，你应该创建一个“无害”的程序版本，该程序简单地输出消息而不是实际复制文件。对于我们的程序，你将更改`make_copy`中的行，使用`print`而不是`shutil.copy`。
- en: If the output looks good after you check the results carefully, only then should
    you run the real program on your real directories. Remember that our program is
    copying (rather than moving) files, so even in our real directories, if something
    goes wrong, there’s a good chance that the problem will be in our new directory
    and not the original directories that we actually care about.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在仔细检查结果后，如果输出看起来不错，那么你应该只在你的真实目录上运行真正的程序。记住，我们的程序是在复制（而不是移动）文件，所以即使在我们的真实目录中，如果出现问题，有很大可能性问题出在我们的新目录中，而不是我们真正关心的原始目录中。
- en: We’ll assume that you’re now ready to run the program on the pictures1 and pictures2
    directories. Once you run it, you can check your pictures_combined directory for
    the results. You should see that the directory has 200 files, which is exactly
    the number of unique pictures that we had across our two picture directories.
    Did we correctly handle the situation where the same filename existed in both
    picture directories but were different pictures? Yes, you can see that we have
    files named 9595.png and 9595_.png and that we therefore haven’t overwritten one
    with the other.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你现在已经准备好在pictures1和pictures2目录上运行程序。一旦运行，你可以检查你的pictures_combined目录以查看结果。你应该看到该目录有200个文件，这正好是我们两个图片目录中独特的图片数量。我们是否正确处理了在两个图片目录中都存在相同文件名但图片不同的情况？是的，你可以看到我们有名为9595.png和9595_.png的文件，因此我们没有覆盖彼此。
- en: Oh, and how long did the program take to run on your computer? At most a few
    seconds, right? It turns out that Copilot’s warning that “this approach can be
    slow for large directories with many files” didn’t matter for us.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，你的程序在你的电脑上运行了多久？最多几秒钟，对吧？结果是，Copilot的警告“这种方法对于包含许多文件的大型目录可能会很慢”对我们来说并不重要。
- en: Now, we all know that people tend to have thousands of pictures on their phones,
    not hundreds. If you ran this program on two real phone picture libraries, you
    would again need to determine whether it completes in an acceptable amount of
    time. You could run the program and let it run for a minute or two or however
    long you’re willing to wait. For fun, we also tested our program on a total of
    10,000 small image files (a more realistic scenario than the 210 pictures across
    our pictures1 and pictures2 directories that we used in this chapter), and we
    found that it only took 1 minute to complete. At some point, our program will
    become too slow to be practical, and that’s when you’d need to do further research
    with Copilot Chat to arrive at a more efficient program.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们都知道人们通常在手机上有成千上万的照片，而不是几百张。如果您在两个真实的手机图片库上运行这个程序，您还需要确定它是否在可接受的时间内完成。您可以运行程序，让它运行一分钟左右，或者您愿意等待多久。为了好玩，我们还测试了我们的程序在总共10,000个小图像文件上的运行情况（比我们在本章中使用的图片1和图片2目录中的210张图片更现实的场景），我们发现它只用了1分钟就完成了。在某个时候，我们的程序可能会变得太慢而无法实用，那时您就需要使用Copilot
    Chat进行进一步的研究，以得到一个更高效的程序。
- en: 'In this chapter, we succeeded in automating three tedious tasks: cleaning up
    an email, adding covers to hundreds of .pdf files, and wrangling multiple picture
    libraries into one. The approach in each case was the same: use Copilot Chat to
    determine which module(s) to use, then follow the approach that we’ve honed throughout
    the book to have Copilot write the required code.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们成功地自动化了三个繁琐的任务：清理电子邮件、为数百个.pdf文件添加封面，以及将多个图片库合并为一个。在每种情况下，方法都是相同的：使用Copilot
    Chat确定要使用哪个模块，然后遵循我们在整本书中磨练的方法，让Copilot编写所需的代码。
- en: Remember, whenever you find yourself repeating the same task, it’s worth trying
    to automate it using Copilot and Python. There are many helpful Python modules
    for doing so, beyond what we showed in this chapter. For example, there are modules
    to manipulate images, work with Microsoft Excel or Microsoft Word files, send
    email, scrape data from websites, and more. If it’s a tedious task, chances are
    that someone has made a Python module to help with it and that Copilot will be
    able to help you use that module effectively.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，无论何时您发现自己重复执行相同的任务，尝试使用Copilot和Python来自动化它都是值得的。除了本章中展示的之外，还有很多有用的Python模块可以做到这一点。例如，有用于操作图像、处理Microsoft
    Excel或Microsoft Word文件、发送电子邮件、从网站抓取数据等模块。如果是一项繁琐的任务，那么很可能有人已经编写了一个Python模块来帮助完成这项任务，并且Copilot可以帮助您有效地使用该模块。
- en: 9.6 Exercises
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 练习
- en: You already have a tool that cleans up email text by removing any `>` or space
    characters from the beginning of each line. What steps will you take to enhance
    this tool to also remove lines that are excessively short (e.g., lines with fewer
    than five characters, excluding spaces)?
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已经有一个工具可以清理电子邮件文本，通过从每行的开头删除任何`>`或空格字符。您将采取哪些步骤来增强这个工具，使其也能删除过短的行（例如，少于五个字符的行，不包括空格）？
- en: 'You’re writing a Python program to clean up a bunch of images that you have
    stored on your computer, and you’ve decided to use the Pillow library (a fork
    of the Python Image Library [PIL]). After installing the latest version of Pillow,
    you run your program but encounter the following error:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在编写一个Python程序来清理您存储在电脑上的大量图片，您决定使用Pillow库（Python图像库[PIL]的一个分支）。在安装了Pillow的最新版本后，您运行了您的程序，但遇到了以下错误：
- en: '[PRE65]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: What steps can you take to fix this problem?
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以采取哪些步骤来解决这个问题？
- en: 3\. You’ve been given an Excel file named sales_data.xlsx that contains monthly
    sales data for different products. Your task is to write a Python program that
    reads the sales data, calculates the total sales for each product, and writes
    the results to a new Excel file named total_sales.xlsx. The sales_data.xlsx file
    has columns for each month (January, February, etc.).
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 您已经得到了一个名为sales_data.xlsx的Excel文件，其中包含不同产品的月度销售数据。您的任务是编写一个Python程序，读取销售数据，计算每个产品的总销售额，并将结果写入一个名为total_sales.xlsx的新Excel文件。sales_data.xlsx文件有每个月份（1月、2月等）的列。
- en: 'Your program should do the following:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序应该执行以下操作：
- en: Read the data from `sales_data.xlsx`.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`sales_data.xlsx`读取数据。
- en: Calculate the total sales for each product across all months.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算所有月份中每个产品的总销售额。
- en: Write the product names and their total sales to `total_sales.xlsx`.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将产品名称和它们的总销售额写入`total_sales.xlsx`。
- en: 'Hints: make reasonable assumptions about the input file and you may need to
    import libraries to help you work with the .xlsx files. If you don’t have Excel
    or OpenOffice to read/write .xlsx files, feel free to do the task with .csv files
    instead.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：对输入文件做出合理的假设，你可能需要导入库来帮助你处理 .xlsx 文件。如果你没有 Excel 或 OpenOffice 来读取/写入 .xlsx
    文件，请随意使用 .csv 文件来完成这项任务。
- en: 4\. It can be tedious to find news articles from different sources to read every
    day. Your task is to write a webscraper in Python that extracts and display the
    titles and URLs of the latest articles from a news website. You’ll need the beautifulsoup4
    and requests modules.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 每天从不同来源寻找新闻文章来阅读可能会很繁琐。你的任务是编写一个 Python 爬虫，从新闻网站上提取并显示最新文章的标题和 URL。你需要 beautifulsoup4
    和 requests 模块。
- en: Summary
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Programmers often make tools to automate tedious tasks.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员经常制作工具来自动化繁琐的任务。
- en: It’s often necessary to use a Python module to help us write our tool.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常需要使用 Python 模块来帮助我们编写工具。
- en: We can use Copilot Chat to determine which Python modules we should be using.
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 Copilot Chat 来确定我们应该使用哪些 Python 模块。
- en: It’s helpful to converse with Copilot to understand the pros and cons of various
    Python modules that may be available to us.
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Copilot 对话以了解可能对我们可用的各种 Python 模块的优缺点是有帮助的。
- en: There are Python modules for working with the clipboard, working with .pdf files
    and other file formats, copying files, and more.****
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有 Python 模块可以用于处理剪贴板、处理 .pdf 文件和其他文件格式、复制文件等。
