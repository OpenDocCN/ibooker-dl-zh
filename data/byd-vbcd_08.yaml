- en: 'Chapter 6\. AI-Driven Prototyping: Tools and Techniques'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章\. AI驱动的原型设计：工具和技术
- en: This chapter explores how AI-driven vibe coding accelerates the prototyping
    phase of software development. Prototyping is all about rapidly turning an idea
    into a working model. With AI assistants, developers can achieve in hours what
    might normally take days, quickly iterating on concepts. I’ll discuss techniques
    for going from concept to prototype with AI, compare popular AI prototyping tools
    (including Vercel v0 and screenshot-to-code utilities), and examine how to refine
    prototypes iteratively under AI guidance. I also address the crucial step of transitioning
    a rough AI-generated prototype into production-quality code. Throughout the chapter,
    I’ll also look at case studies where AI-driven prototyping led to successful outcomes
    and demonstrate both the potential and the pitfalls of this approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了AI驱动的动态编码如何加速软件开发的原型阶段。原型设计就是快速将想法转化为工作模型。有了AI助手，开发者可以在几小时内完成可能通常需要几天的工作，快速迭代概念。我将讨论使用AI从概念到原型的技术，比较流行的AI原型设计工具（包括Vercel
    v0和截图转代码工具），并检查如何在AI指导下迭代优化原型。我还将讨论将粗糙的AI生成的原型过渡到生产质量代码的关键步骤。在整个章节中，我还会分析AI驱动的原型设计导致成功案例的研究，并展示这种方法的潜力和陷阱。
- en: Rapid Prototyping with AI Assistants
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AI助手进行快速原型设计
- en: Prototyping benefits greatly from the speed of AI-generated code. The goal in
    prototyping is not polished, production-ready code but a *proof of concept* that
    you can evaluate and refine. AI coding assistants shine here by producing functioning
    code quickly from minimal input. For example, instead of manually coding a UI
    mockup, a developer can describe the desired interface in natural language and
    let the AI generate the HTML/CSS or React components. This allows for a very fast
    idea-to-implementation cycle.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计极大地受益于AI生成代码的速度。原型设计的目的是不是经过抛光的、生产就绪的代码，而是一个*概念验证*，你可以评估和改进。AI编码助手在这里表现出色，因为它可以从最小的输入中快速生成功能代码。例如，开发者可以不用手动编写UI原型，而是用自然语言描述所需的界面，让AI生成HTML/CSS或React组件。这允许非常快速地从想法到实施周期的转换。
- en: '[One UX engineer](https://oreil.ly/dP5U3) describes how using a generative
    AI tool has completely transformed his workflow: “The speed at which I could generate
    functional prototypes with Generative AI was amazing. I built prototypes in a
    few hours [that] would normally take days.” The AI handles routine boilerplate
    and repetitive patterns automatically, freeing him to focus on higher-level design
    decisions. In prototyping, this means you can try out more ideas in the same amount
    of time. Another benefit is that AI can fill in the tedious parts of a prototype
    (basic UI components, form handling, sample data) almost instantly, allowing the
    human developer to concentrate on the core concept or unique feature being tested.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[一位用户体验工程师](https://oreil.ly/dP5U3)描述了使用生成式AI工具如何彻底改变他的工作流程：“我使用生成式AI生成功能原型时的速度令人惊叹。我几个小时就完成了通常需要几天时间才能完成的原型。”AI可以自动处理常规的模板和重复的模式，使他能够专注于更高层次的设计决策。在原型设计中，这意味着你可以在相同的时间内尝试更多的想法。另一个好处是，AI可以几乎瞬间填充原型中繁琐的部分（基本的UI组件、表单处理、示例数据），使人类开发者能够专注于被测试的核心概念或独特功能。'
- en: However, it’s important to remember that a prototype’s code is often throwaway
    code. An AI may generate a working solution quickly, but that code might not be
    structured for maintainability or scale. This is acceptable in prototypes, where
    speed and experimentation matter more than elegance—as long as you plan to refactor
    or rewrite critical parts for production (I’ll discuss this process later in the
    chapter). As Chapters [3](ch03.html#ch03_the_70_problem_ai_assisted_workflows_that_actual_1752630043200933)
    and [4](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362)
    explored, the AI can confidently handle about 70% of the coding for a prototype,
    while you guide the overall architecture and correct any critical flaws.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要记住，原型的代码通常是废弃代码。AI可能快速生成一个可行的解决方案，但该代码可能没有为维护或扩展而设计。在原型中这是可以接受的，因为速度和实验比优雅更重要——只要你计划在生产中重构或重写关键部分（我将在本章后面讨论这个过程）。正如第[3](ch03.html#ch03_the_70_problem_ai_assisted_workflows_that_actual_1752630043200933)章和第[4](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362)章所探讨的，AI可以自信地处理原型约70%的编码工作，而你则指导整体架构并纠正任何关键缺陷。
- en: 'Programming with intent, a concept introduced in [Chapter 1](ch01.html#ch01_introduction_what_is_vibe_coding_1752630042333281),
    is essential here. You provide high-level instructions (the intent of what you
    want the prototype to do or look like) and let the AI fill in the implementation.
    To illustrate, let’s walk through a very simple prototyping example using an AI
    assistant. Suppose you have an idea for a sign-up page for a new service. You
    want to prototype the frontend quickly, so you start with the following developer
    prompt:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](ch01.html#ch01_introduction_what_is_vibe_coding_1752630042333281)中引入的概念“有意图的编程”在这里至关重要。你提供高级指令（你希望原型做什么或看起来像什么的目的）并让
    AI 填充实现。为了说明，让我们通过使用 AI 助手的一个非常简单的原型示例来操作。假设你有一个为新服务创建注册页面的想法。你希望快速原型化前端，所以你从以下开发者提示开始：
- en: Create a simple HTML page for a sign-up form with fields for Name, Email, and
    Password, and a Submit button. Make it look presentable with basic styling.
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个简单的 HTML 页面，用于注册表单，包含姓名、电子邮件和密码字段，以及一个提交按钮。用基本的样式让它看起来更美观。
- en: 'A modern code assistant like Cline might provide a complete HTML/CSS example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个现代的代码助手，如 Cline，可能会提供一个完整的 HTML/CSS 示例：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This AI-generated code is a decent starting point for a prototype of the sign-up
    form. It includes a basic layout and some inline CSS for styling. As a developer,
    you didn’t have to write any HTML/CSS by hand—you simply described the outcome,
    and the AI provided an implementation. This demonstrates programming by intent:
    you focus on *what* the UI should do, and the AI figures out *how* to do it.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这段由 AI 生成的代码是注册表原型的一个不错的起点。它包括基本的布局和一些内联 CSS 用于样式。作为一个开发者，你不必手动编写任何 HTML/CSS——你只需描述结果，AI
    就提供了实现。这展示了有意图的编程：你专注于 UI 应该做什么，AI 就会想出如何做。
- en: 'Of course, this is a trivial example. In practice, prototypes can be more complex
    and involve multiple files, frameworks, or data. But the principle is the same:
    You use the AI to create a first draft swiftly. You might then open this prototype
    in a browser, see how it looks, and refine it further. That leads me to the next
    topic: using specialized AI prototyping tools that go beyond plain-language prompts.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个简单的例子。在实践中，原型可能更复杂，涉及多个文件、框架或数据。但原则是相同的：你使用 AI 快速创建一个初稿。然后你可以在浏览器中打开这个原型，看看它的样子，并进一步改进它。这让我想到了下一个话题：使用超越纯语言提示的专门化
    AI 原型工具。
- en: AI Prototyping Tools
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI 原型工具
- en: While general-purpose assistants like Gemini, ChatGPT, and Claude can generate
    prototype code from prompts, the landscape of specialized AI-assisted prototyping
    tools continues to evolve rapidly. As I write this, the available tools offer
    different approaches to the fundamental trade-off between fidelity and control
    in AI-generated prototypes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然像 Gemini、ChatGPT 和 Claude 这样的通用助手可以从提示中生成原型代码，但专门化的 AI 辅助原型工具领域仍在迅速演变。在我撰写本文时，可用的工具提供了不同的方法来解决
    AI 生成原型中的基本权衡：保真度和控制度。
- en: The ecosystem has matured to serve distinct prototyping needs. Some tools excel
    at transforming visual designs into code, allowing designers to upload screenshots
    or sketches and receive working HTML, CSS, or React components within seconds.
    This “screenshot-to-code” capability dramatically accelerates the design-to-code
    process, particularly valuable when you have hand-drawn sketches or Figma designs
    that need rapid implementation. Tools like Vercel v0 exemplify this approach,
    offering high fidelity to the original design while trading off some control over
    code structure.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 生态系统已经成熟，以满足不同的原型需求。一些工具擅长将视觉设计转换为代码，允许设计师上传截图或草图，并在几秒钟内接收可工作的 HTML、CSS 或 React
    组件。这种“截图转代码”的能力极大地加速了设计到代码的过程，特别是当你有需要快速实施的亲手草图或 Figma 设计时非常有价值。像 Vercel v0 这样的工具就体现了这种方法，它在保持原始设计高保真的同时，牺牲了一些对代码结构的控制。
- en: Other platforms focus on generating complete applications through conversational
    interfaces. These allow users to describe functionality in natural language and
    receive full stack implementations. For instance, a designer wanting a quick app
    without coding might use tools like Lovable or Bolt.new, which offer high-level
    prompt interfaces that can scaffold entire applications. Some designers report
    building functional prototypes in hours that would traditionally take days, with
    the AI automatically handling tedious components and patterns.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其他平台专注于通过对话界面生成完整的应用程序。这些界面允许用户用自然语言描述功能，并接收全栈实现。例如，一个想要快速应用而无需编码的设计师可能会使用Lovable或Bolt.new等工具，这些工具提供高级提示界面，可以构建整个应用程序。一些设计师报告说，他们可以在几小时内构建出传统上需要几天时间才能完成的具有功能的原型，AI自动处理繁琐的组件和模式。
- en: 'A third category integrates AI directly into development environments, functioning
    as intelligent pair programmers during the prototyping phase. These AI-augmented
    IDEs like Cursor, Windsurf, and Cline allow developers to maintain more control
    over the code generation process while still benefiting from AI acceleration.
    The distinction often lies in workflow philosophy: some prioritize automated application
    of changes for rapid experimentation, while others require explicit acceptance
    of modifications for more careful iteration.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第三类将人工智能直接集成到开发环境中，在原型设计阶段充当智能配对程序员。这些AI增强型IDE，如Cursor、Windsurf和Cline，允许开发者在对代码生成过程保持更多控制的同时，仍然受益于AI加速。区别通常在于工作流程哲学：一些优先考虑自动应用更改以进行快速实验，而另一些则需要明确接受修改以进行更细致的迭代。
- en: The common thread across all these approaches is their ability to compress the
    journey from concept to working prototype. However, they differ significantly
    in two key dimensions that shape their utility for different users and use cases.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法之间的共同点是它们能够压缩从概念到工作原型的旅程。然而，它们在两个关键维度上存在显著差异，这些维度决定了它们对不同用户和用例的实用性。
- en: '*Fidelity* refers to how closely the generated output matches your input or
    intention. Screenshot-to-code tools typically offer high fidelity to visual designs
    but may produce code that doesn’t align with your architectural preferences. Conversational
    tools might interpret your requirements more loosely, generating functional but
    generic implementations that require refinement.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*保真度*指的是生成的输出与您的输入或意图的匹配程度。截图到代码的工具通常提供高保真度视觉设计，但可能生成的代码与您的架构偏好不符。对话工具可能更宽松地解释您的需求，生成功能但通用的实现，需要进一步优化。'
- en: Control encompasses your ability to guide and modify the generation process.
    Some tools operate as black boxes that produce complete outputs, while others
    allow iterative refinement through continued dialogue or direct code editing.
    This dimension becomes crucial when you need specific architectural patterns,
    performance optimizations, or integration with existing codebases.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 控制包括您引导和修改生成过程的能力。一些工具作为黑盒产生完整的输出，而其他工具则允许通过持续的对话或直接代码编辑进行迭代改进。当您需要特定的架构模式、性能优化或与现有代码库集成时，这个维度变得至关重要。
- en: Understanding these trade-offs helps in selecting the right tool for your prototyping
    needs. A designer validating a new interaction pattern might prioritize fidelity
    and speed, accepting less control over implementation details. A developer exploring
    technical feasibility might value control and transparency, even if it means more
    manual intervention in the generation process.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些权衡有助于选择适合您原型设计需求的正确工具。一个验证新交互模式的设计师可能会优先考虑保真度和速度，接受对实现细节的控制较少。一个探索技术可行性的开发者可能会重视控制和透明度，即使这意味着在生成过程中需要更多手动干预。
- en: None of these tools produces production-quality code without human oversight.
    They typically deliver what I call the “80% prototype”—functional enough to test
    concepts and demonstrate to stakeholders but requiring additional work for production
    deployment. The remaining 20% often involves security hardening, performance optimization,
    error handling, and architectural refinement.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何这些工具在没有人工监督的情况下产生生产质量的代码。它们通常交付我所说的“80%原型”——足够功能化以测试概念并向利益相关者展示，但需要额外的工作才能用于生产部署。剩余的20%通常涉及安全加固、性能优化、错误处理和架构优化。
- en: Even during rapid prototyping, a quick code review remains essential. While
    you might not polish every detail in a prototype, scanning for obvious issues
    like exposed API keys or insecure data handling prevents problems from propagating
    into later development stages. Most modern tools provide transparency into their
    generated code, allowing you to inspect and understand what’s being created.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在快速原型设计过程中，快速代码审查仍然至关重要。虽然你可能不会在原型中完善每一个细节，但扫描明显的问题，如暴露的API密钥或不安全的数据处理，可以防止问题传播到后续的开发阶段。大多数现代工具都提供了对其生成代码的透明度，允许你检查和理解正在创建的内容。
- en: As the AI prototyping landscape continues to evolve, the specific tools will
    undoubtedly change, but these fundamental considerations of fidelity versus control,
    and the need for human oversight, will remain constant. The key is understanding
    your prototyping goals and selecting approaches that align with your specific
    needs, whether that’s rapid visual implementation, functional demonstration, or
    technical exploration.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 随着AI原型设计领域的持续发展，具体工具无疑会发生变化，但这些关于忠实度与控制之间的基本考虑，以及需要人工监督的需求将保持不变。关键是理解你的原型设计目标，并选择与你的具体需求相一致的方法，无论是快速视觉实现、功能演示还是技术探索。
- en: 'From Concept to Prototype: Iterative Refinement'
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从概念到原型：迭代改进
- en: 'One of the strengths of AI-driven prototyping is the *iterative loop*: you
    can generate an initial version and then refine it by interacting with the AI. Instead
    of manually editing code, you just tell the AI what you want changed (see [Figure 6-1](#ch06_figure_1_1752630043791661)).
    While I advocate a more responsible approach than pure “seat-of-the-pants” vibe
    coding, the fast feedback cycle is definitely something to embrace in prototypes.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: AI驱动原型设计的一个优势是*迭代循环*：你可以生成一个初始版本，然后通过与AI交互对其进行改进。你不必手动编辑代码，只需告诉AI你想要改变的内容（见[图6-1](#ch06_figure_1_1752630043791661)）。虽然我提倡比纯“即兴创作”的vibe编码更负责任的方法，但快速反馈周期在原型设计中确实值得拥抱。
- en: '![](assets/bevc_0601.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/bevc_0601.png)'
- en: 'Figure 6-1\. Iterative prototype refinement process: initial prompts generate
    baseline prototypes, and developer feedback drives successive improvements, creating
    increasingly refined solutions through AI collaboration.'
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1\. 迭代原型改进过程：初始提示生成基线原型，开发者反馈推动后续改进，通过AI协作创建越来越精细的解决方案。
- en: 'Most AI prototyping tools keep a history or context of your requests, which
    is extremely useful. It means the AI remembers the *purpose* of your app and previous
    instructions, so you don’t have to re-explain everything each time. This *context
    persistence* is a hallmark of vibe-coding environments: the conversation with
    the AI becomes the development log.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数AI原型设计工具都会保存你的请求历史或上下文，这非常有用。这意味着AI记得你应用的目的和之前的指令，因此你不必每次都重新解释一切。这种*上下文持久性*是vibe-coding环境的标志：与AI的对话变成了开发日志。
- en: 'Here’s how a typical iterative refinement might go:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是典型的迭代改进可能的过程：
- en: 'Step 1: Initial generation'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第1步：初始生成
- en: 'You provide a prompt or input to create the prototype:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你提供提示或输入以创建原型：
- en: Generate a basic expense-tracker app with a form to add expenses and a table
    to list them.
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 生成一个基本的费用追踪应用，包含一个用于添加费用的表单和一个用于列出费用的表格。
- en: 'Step 2: Review and run the code'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步：审查和运行代码
- en: You get the generated code and run it. Maybe it works, but you notice some things
    that could be improved. For example, the UI is functional but plain, or the table
    doesn’t sort the expenses.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到生成的代码并运行它。可能它工作得很好，但你注意到一些可以改进的地方。例如，UI功能正常但平淡无奇，或者表格不能对费用进行排序。
- en: 'Step 3: Refine your prompts'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步：细化你的提示
- en: 'You go back to the AI and provide additional instructions. For instance:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你回到AI那里并提供额外的指令。例如：
- en: Make the expense list sortable by amount or date.
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使费用列表按金额或日期排序。
- en: 'The AI might modify the code to include sorting logic or use a library for
    sortable tables:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: AI可能会修改代码以包含排序逻辑或使用可排序表格的库：
- en: Add some color styling, maybe use a modern CSS framework.
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 添加一些颜色样式，也许使用现代CSS框架。
- en: 'The AI could integrate a CSS library (like Tailwind or Bootstrap) or just add
    custom styles to make it look nicer:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: AI可以集成CSS库（如Tailwind或Bootstrap）或仅添加自定义样式以使其看起来更美观：
- en: Validate the form so you can’t add an expense without a name and amount.
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 验证表单，以确保你无法添加没有名称和金额的费用。
- en: The AI might add simple frontend validation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: AI可能会添加简单的前端验证。
- en: Each of these prompts modifies the prototype. Because the AI understands the
    context (tools like Cursor and ongoing chat tools will keep the code state), it
    can often apply changes in the right places—for example, inserting validation
    code in the form or rewriting the table rendering to include sortable columns.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些提示中的每一个都会修改原型。因为AI理解上下文（如Cursor和持续的聊天工具将保持代码状态），它通常可以在正确的地方应用更改——例如，在表单中插入验证代码或重写表格渲染以包括可排序的列。
- en: 'Step 4: Rinse and repeat'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步：重复使用
- en: 'After each refinement, you check the result. If the AI introduced a new issue
    or didn’t do exactly what you intended, you clarify or fix it via prompts:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次细化后，你检查结果。如果AI引入了新的问题或没有完全按照你的意图执行，你通过提示进行澄清或修复：
- en: The sorting is backward—please sort ascending by default.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序是逆序的——请默认按升序排序。
- en: The new color scheme is good, but make the header dark blue instead of black.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的颜色方案很好，但将标题改为深蓝色而不是黑色。
- en: Each iteration cycle is quite fast—often taking just a few seconds of processing—which
    means you can go through a dozen iterations within an hour. Compared to manually
    coding and checking all those changes, the AI approach can be significantly faster.
    That’s especially true for broad changes, like restyling or adding a feature.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个迭代周期都非常快——通常只需要几秒钟的处理时间——这意味着你可以在一个小时内完成十几个迭代。与手动编码和检查所有这些更改相比，AI方法可以显著更快。这尤其适用于广泛的更改，如重设计或添加功能。
- en: 'Importantly, iterating with AI requires clear communication. This is where
    your *prompt engineering* skills come into play. The more explicit and clear you
    are about the change you want, the more likely the AI will do it correctly. For
    example, saying “Make it look nicer” is vague. A more specific prompt gives the
    assistant a concrete direction:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，使用AI进行迭代需要清晰的沟通。这正是你的**提示工程**技巧发挥作用的地方。你对想要的变化描述得越明确和清晰，AI就越有可能正确执行。例如，说“让它看起来更漂亮”是模糊的。一个更具体的提示会给助手一个具体的方向：
- en: Apply a light theme with a blue header and increase the font sizes for readability.
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应用浅色主题，带有蓝色标题，并增加字体大小以提高可读性。
- en: If you’re using a tool like Vercel v0 or Lovable, you might even point to a
    part of the UI using its interface and say, “Change this to X.”
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Vercel v0或Lovable这样的工具，你甚至可以使用其界面指向UI的一部分，并说，“将其改为X。”
- en: 'Let’s look at a short conversational iteration process between a developer
    and an AI coding assistant:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看开发者和AI编码助手之间简短的对话迭代过程：
- en: Generate a React component for a to-do list. It should display a list of tasks
    and a text input to add a new task.
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 生成一个用于待办事项列表的React组件。它应显示任务列表和一个用于添加新任务的文本输入框。
- en: 'The AI produces a React component with state for tasks and renders a list,
    an input, and a button to add tasks:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: AI生成一个具有状态的React组件，用于任务，并渲染一个列表、一个输入框和一个添加任务的按钮：
- en: Great. Now make each task editable and add a checkbox to mark it complete.
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 太好了。现在使每个任务可编辑，并添加一个复选框来标记它已完成。
- en: 'The AI updates the code, rendering each task with a checkbox and an edit function
    and modifying state accordingly. The developer runs the app and finds that editing
    works, but there’s no delete button:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: AI更新代码，渲染每个任务带有复选框和编辑功能，并相应地修改状态。开发者运行应用程序并发现编辑功能正常，但没有删除按钮：
- en: Add a delete button for each task.
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为每个任务添加一个删除按钮。
- en: 'The AI adds a delete feature in the code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: AI在代码中添加了删除功能：
- en: The layout is a bit cramped. Add some basic CSS to space out the list items
    and make the font a bit larger.
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 布局有点拥挤。添加一些基本的CSS来分隔列表项，并使字体略大一些。
- en: 'The AI outputs CSS styling, possibly as a `<style>` in the component or a separate
    CSS snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: AI输出CSS样式，可能作为组件中的`<style>`或单独的CSS片段：
- en: Looks better!
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 看起来更好！
- en: This kind of back-and-forth could continue until the prototype meets the vision.
    In the end, the developer gets a working prototype for a to-do list app, with
    create, edit, complete, and delete functionalities—all built via natural-language
    requests and quick AI code outputs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种来回沟通可能持续到原型符合预期。最终，开发者得到了一个待办事项列表应用程序的工作原型，具有创建、编辑、完成和删除功能——所有这些都是通过自然语言请求和快速的AI代码输出构建的。
- en: Throughout this process, remember that the developer remains the director of
    what happens. The AI might propose a way to implement a feature, but *you* decide
    if that fits your needs. Sometimes the AI’s implementation is correct but not
    what you expected (maybe it uses a different UI approach than what you had in
    mind). You can either accept it (if it doesn’t harm the prototype goals) or instruct
    the AI to change to your preferred approach.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，请记住，开发者仍然是发生事情的主导者。AI可能会提出一种实现功能的方法，但*你*决定它是否符合你的需求。有时AI的实现是正确的，但不是你所预期的（可能它使用了与你在意中不同的UI方法）。你可以接受它（如果它不影响原型目标）或指示AI改变到你喜欢的方案。
- en: Evolving a Prototype Toward Production
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将原型演进为生产版本
- en: A prototype is meant to be a proof of concept and a tool for learning what works.
    Once it has served that purpose—say, you’ve validated the design with users or
    proven that a certain feature is feasible—the next step is often to turn it into
    a production application. This transition is a critical juncture. AI can still
    help, but human developers must sand down the rough edges of the prototype. This
    section looks at some key considerations when moving from prototype to production
    code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 原型旨在证明概念和了解哪些可行的工具。一旦它完成了这个目的——比如说，你已通过用户验证了设计或证明某个功能是可行的——下一步通常是将它转变为生产应用程序。这种转变是一个关键转折点。AI仍然可以提供帮助，但人类开发者必须磨平原型的粗糙边缘。本节将探讨从原型到生产代码迁移时的关键考虑因素。
- en: First, review the architecture and code structure carefully. Prototypes can
    be messy under the hood. Perhaps all your code ended up in one file or you bypassed
    certain best practices for speed. Now is the time to introduce a proper structure.
    For example, if the prototype was a single-page script, you might separate it
    into multiple modules; for a web UI, you might introduce a proper component structure;
    for a backend, you might set up a formal model–view–controller (MVC) architectural
    pattern.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，仔细审查架构和代码结构。原型在底层可能会很混乱。也许你的所有代码都集中在一个文件中，或者为了速度而绕过了某些最佳实践。现在是引入适当结构的时候了。例如，如果原型是一个单页脚本，你可能将其拆分为多个模块；对于Web
    UI，你可能引入适当的组件结构；对于后端，你可能设置正式的模型-视图-控制器（MVC）架构模式。
- en: While AI wrote much of the prototype, you, as the developer, understand the
    architecture goals best. You might even start a fresh project and use the prototype
    as a reference or as scaffolding, perhaps reusing some of the prototype code but
    generally treating it as throwaway code. Others might incrementally refactor the
    prototype codebase into shape, with AI suggesting refactorings or generating tests
    to ensure nothing breaks during cleanup.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然AI编写了大部分原型，但你作为开发者，最了解架构目标。你可能甚至开始一个全新的项目，并将原型作为参考或脚手架，可能重用一些原型代码，但通常将其视为可丢弃的代码。其他人可能会逐步重构原型代码库，AI建议重构或生成测试以确保清理过程中不会出错。
- en: Next, add error handling and edge cases. Prototype code often focuses on the
    sunny-day scenario, but what if the API call fails? What if the input is empty?
    Go through each feature systematically and consider potential failure modes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加错误处理和边缘情况。原型代码通常专注于晴朗天气的场景，但API调用失败怎么办？输入为空怎么办？系统地审查每个功能并考虑潜在的失败模式。
- en: 'AI can help you brainstorm edge cases, given a prompt like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这样的提示，AI可以帮助你构思边缘情况：
- en: What are potential error cases for this feature and how to handle them?
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个功能的潜在错误情况有哪些？如何处理它们？
- en: The assistant will likely list some scenarios (network errors, bad input, concurrency
    issues) for which you can implement handling (or ask AI to help implement it).
    Ensuring your code’s robustness is part of making it production-ready.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 助手可能会列出一些场景（如网络错误、输入错误、并发问题），针对这些场景你可以实现处理（或请求AI帮助实现）。确保你的代码的健壮性是使其准备投入生产的一部分。
- en: Your prototype code probably isn’t optimized, so check for any parts that are
    inefficient or could pose security issues. For instance, maybe the AI in the prototype
    used a naive algorithm that works on small test datasets but would be slow with
    real data. Identify such spots and optimize them. (I’ll cover common AI-generated
    code flaws in [Chapter 8](ch08.html#ch08_security_maintainability_and_reliability_1752630044621528).)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你的原型代码可能没有优化，因此检查任何低效或可能引发安全问题的部分。例如，原型中的AI可能使用了一个在小型测试数据集上工作的朴素算法，但处理真实数据时会很慢。识别这些区域并对其进行优化。（我将在[第8章](ch08.html#ch08_security_maintainability_and_reliability_1752630044621528)中介绍常见的AI生成代码缺陷。）
- en: One strategy is to run performance tests or use profilers on the prototype to
    see bottlenecks, then ask AI to help optimize that function. Definitely review
    security features like authentication and data handling too—it’s not uncommon
    for AI prototypes to use SQL queries without proper parameterization (risking
    SQL injection attacks) or to include [sensitive information](https://oreil.ly/gzUjn).
    These problems *must* be fixed. A [2021 study](https://oreil.ly/a72lb) found that
    about *40% of AI-generated code had potential vulnerabilities*. So part of productionizing
    is staying vigilant. Run static analysis and/or security tests on the code manually,
    or prompt the AI to “scan this code for security issues.”
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一种策略是在原型上运行性能测试或使用分析器查看瓶颈，然后请求 AI 帮助优化该函数。当然，也要审查安全功能，如身份验证和数据处理——AI 原型在没有适当参数化（风险
    SQL 注入攻击）或包含[敏感信息](https://oreil.ly/gzUjn)的情况下使用 SQL 查询并不罕见。这些问题*必须*得到解决。一项[2021
    年的研究](https://oreil.ly/a72lb)发现，大约 *40% 的 AI 生成的代码存在潜在漏洞*。因此，将代码投入生产的一部分是保持警惕。手动运行静态分析和安全测试，或者提示
    AI “扫描此代码中的安全问题”。
- en: 'Prototypes often lack documentation, which you’ll need to add as you formalize
    the code: a clear, human-reviewed explanation of each module will help future
    team members, as well as you, when you revisit the code months later. Once you’ve
    cleaned up your code, you might prompt an AI tool to produce a Markdown API document
    or README based on the code that describes how the system works. [Chapter 1](ch01.html#ch01_introduction_what_is_vibe_coding_1752630042333281)
    discussed how AI can produce explanations of code; this is a great moment to leverage
    that.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 原型通常缺乏文档，随着你正式化代码，你需要添加这些文档：对每个模块的清晰、经过人工审查的解释将有助于未来的团队成员，以及当你几个月后再次查看代码时，也会对你有所帮助。一旦你清理了代码，你可以提示
    AI 工具根据代码生成 Markdown API 文档或 README，描述系统的工作方式。[第 1 章](ch01.html#ch01_introduction_what_is_vibe_coding_1752630042333281)讨论了
    AI 如何生成代码的解释；这是一个利用这一点的绝佳时刻。
- en: 'It’s crucial to test your prototype thoroughly, as you learned in [Chapter 5](ch05.html#ch05_understanding_generated_code_review_refine_own_1752630043592278).
    You might write unit tests for core logic, integration tests for major flows,
    etc. You can accelerate this by asking the AI to generate test cases:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细测试你的原型至关重要，正如你在[第 5 章](ch05.html#ch05_understanding_generated_code_review_refine_own_1752630043592278)中学到的。你可能需要为核心逻辑编写单元测试，为主要流程编写集成测试等。你可以通过请求
    AI 生成测试用例来加速这个过程：
- en: Write Jest tests for the to-do list component covering adding, editing, completing,
    deleting tasks.
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为待办事项组件编写 Jest 测试，涵盖添加、编辑、完成、删除任务。
- en: Then run and adjust the tests it generates. Having a good test suite gives you
    confidence as you refactor the prototype code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行并调整它生成的测试。拥有一个好的测试套件，在重构原型代码时，你会更有信心。
- en: 'Sometimes you might decide to replace certain sections of your code entirely—such
    as if the prototype used some quick-and-dirty library or a hack that isn’t suitable
    in the long term. AI can speed this up as well. Suppose your prototype code uses
    local arrays for data, but now you need a proper database integration. Your prompt
    might be something like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能会决定完全替换代码的某些部分——例如，如果原型使用了某些快速且不干净的库或长期不合适的黑客技巧。AI 也可以加速这个过程。假设你的原型代码使用本地数组进行数据存储，但现在你需要适当的数据库集成。你的提示可能如下所示：
- en: Integrate an SQLite database for storing the tasks instead of an in-memory array.
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 SQLite 数据库集成用于存储任务，而不是使用内存数组。
- en: The AI can provide a starting point for this integration, which you should then
    refine.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: AI 可以为此集成提供一个起点，然后你应该对其进行细化。
- en: 'In making these changes, it’s wise to switch your mindset from “rapid prototyping
    mode” to a more disciplined engineering approach. The AI is now your assistant
    in improving code quality—it’s no longer just spitting out quick features. The
    dynamic is a bit different: you might evaluate each AI suggestion more critically
    now that stability and quality are your top priorities. As I mentioned back in
    [Chapter 4](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362),
    *senior developers can derive enormous benefit from AI* because they know what
    to accept and what to fix. At this stage, you’ll be exercising that senior mindset
    heavily: you have a vision of the final system, so you task the AI with specific
    improvements or implementations.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改时，明智的做法是将你的思维方式从“快速原型模式”转变为更严谨的工程方法。现在，AI成为你提高代码质量的助手——它不再只是快速输出功能。动态也略有不同：由于稳定性和质量成为你的首要任务，你可能现在会更为批判性地评估每个AI建议。正如我在[第4章](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362)中提到的，*高级开发者可以从AI中获得巨大的益处*，因为他们知道什么该接受，什么该修正。在这个阶段，你将大量运用高级思维模式：你对最终系统有一个愿景，因此你让AI负责特定的改进或实现。
- en: 'To ground this discussion, let’s consider a brief example. Imagine a solo developer,
    Jane, who wants to build a small web app that converts data from CSV files into
    charts. She uses an AI assistant to get a quick prototype done in just one weekend:
    a basic Node.js script with an API, plus a simple frontend to upload CSVs and
    render charts using a JavaScript chart library.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这次讨论更具体，让我们考虑一个简短的例子。想象一个独立开发者Jane，她想要构建一个将CSV文件中的数据转换为图表的小型网络应用。她使用AI助手在仅仅一个周末内就完成了快速原型：一个基本的Node.js脚本，包含API，以及一个简单的前端，用于上传CSV文件并使用JavaScript图表库渲染图表。
- en: 'She demonstrates this prototype to a few potential users and gets positive
    feedback, so Jane decides to turn it into a real product (a web service). Here’s
    how she navigates the transition:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 她向几位潜在用户展示了这个原型，并获得了积极的反馈，因此Jane决定将其转变为一个真实的产品（一个网络服务）。以下是她的过渡过程：
- en: Hardening the backend
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 加强后端
- en: The prototype’s Node.js API had no  authentication (anyone could upload data).
    For production, she needs user accounts and auth. She uses the AI to integrate
    an authentication system (maybe JWT-based). The AI provides a scaffold, but she
    carefully reviews it to ensure passwords are hashed properly and tokens are secure.
    She also adds input validation to the upload endpoint (the AI had not done that),
    using a combination of AI-suggested code and her own tweaks.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 原型的Node.js API没有认证（任何人都可以上传数据）。对于生产环境，她需要用户账户和认证。她使用AI集成了认证系统（可能是基于JWT的）。AI提供了一个框架，但她仔细审查以确保密码被正确散列，令牌是安全的。她还添加了输入验证到上传端点（AI没有做这个），结合了AI建议的代码和她的个人调整。
- en: Refactoring the frontend
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重构前端
- en: The initial frontend was a single HTML file with script  tags pointing at a
    CDN for dependencies. Jane decides to refactor into a structured React app for
    maintainability. She first asks the AI to refactor her project to be more production-ready
    by using a build system and npm rather than script tags. She then asks the AI
    to help integrate them as React components. For example, it turns the chart-rendering
    code from the prototype into a `<Chart>` component. Jane uses the AI to expedite
    writing these components, but she ensures that the state management and component
    hierarchy follow best practices (something the prototype didn’t consider deeply).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的前端是一个包含指向CDN依赖项的script标签的单个HTML文件。Jane决定重构为一个结构化的React应用以提高可维护性。她首先要求AI通过使用构建系统和npm而不是script标签来使她的项目更适用于生产。然后她要求AI帮助将这些集成到React组件中。例如，它将原型中的图表渲染代码转换为`<Chart>`组件。Jane使用AI来加速编写这些组件，但她确保状态管理和组件层次结构遵循最佳实践（这是原型没有深入考虑的）。
- en: Testing and checking performance
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和检查性能
- en: 'Jane writes unit tests for critical functions (CSV parsing, data transformation).
    When she’s unsure about edge cases, she queries the AI:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Jane为关键功能编写单元测试（CSV解析，数据转换）。当她不确定边缘情况时，她会向AI查询：
- en: What edge cases should I test for CSV parsing?
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我应该为CSV解析测试哪些边缘情况？
- en: It suggests scenarios like empty fields and irregular columns, which she incorporates
    into her tests. She also notices that the prototype loaded entire CSV files into
    memory; for large files, this could crash. She modifies the code to stream the
    processing and uses AI to double-check her stream logic. Now the app can handle
    bigger files more reliably.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它建议了诸如空字段和不规则列等场景，她将这些场景纳入她的测试中。她还注意到原型将整个CSV文件加载到内存中；对于大文件，这可能会导致崩溃。她修改了代码以流式处理处理，并使用AI来双重检查她的流逻辑。现在，该应用可以更可靠地处理更大的文件。
- en: Polishing the UI
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 精炼UI
- en: The prototype UI was utilitarian. For her product, Jane spends a bit more time
    on user experience. She asks the AI to recommend a responsive layout and perhaps
    integrate a CSS framework. The AI adds Bootstrap, which she then uses to improve
    the look (forms, buttons, layout). She manually fine-tunes some CSS afterward.
    This polishing stage is less about heavy coding and more about design choices,
    but AI still helps by providing quick code for standard UI patterns (like a navigation
    bar and a loading spinner).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 原型UI是实用的。对于她的产品，简花了一些时间在用户体验上。她要求AI推荐一个响应式布局，并可能集成一个CSS框架。AI添加了Bootstrap，她随后使用它来改善外观（表单、按钮、布局）。之后，她手动调整了一些CSS。这个抛光阶段与其说是重编码，不如说是设计选择，但AI仍然通过提供标准UI模式（如导航栏和加载指示器）的快速代码来帮助。
- en: After these efforts, the once-rough prototype is a far cleaner, more secure,
    and more scalable application ready for real users. Jane deploys it, feeling confident
    because she added tests and reviewed the AI-generated code. This process from
    prototype to production might have taken her a couple of weeks, whereas writing
    the entire product from scratch would have taken much longer. The AI accelerated
    the initial prototype and continued to assist in the transition, but Jane’s human
    oversight and restructuring were indispensable in reaching production quality.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些努力，曾经粗糙的原型现在是一个更干净、更安全、更可扩展的应用程序，准备迎接真实用户。简部署了它，因为她添加了测试并审查了AI生成的代码，所以她感到自信。从原型到生产的这个过程可能花费了她几周时间，而从头开始编写整个产品可能需要更长的时间。AI加速了初始原型，并在过渡过程中继续提供帮助，但简的人类监督和重构对于达到生产质量是不可或缺的。
- en: Addressing Challenges in AI Prototyping
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决AI原型设计中的挑战
- en: While AI-driven prototyping is powerful, it’s not without challenges. As a developer,
    you should be aware of these and know how to mitigate them. Two areas of particular
    interest are scope creep and integration.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然AI驱动的原型设计功能强大，但它并非没有挑战。作为一名开发者，你应该意识到这些挑战并知道如何减轻它们。两个特别感兴趣的区域是范围蔓延和集成。
- en: 'Because it’s so easy to add features with AI, you might be tempted to keep
    going and going, adding “one more thing” to the prototype, a phenomenon known
    as *scope creep*.  This can lead to an ever-growing prototype that tries to be
    the final product. Remember the purpose of a prototype: to focus on the key question
    you want to answer or the core experience to demonstrate. If you find yourself
    implementing login systems, payment processing, etc., ask if that’s really needed
    at the prototype stage. It might be better to stub those out (the AI can generate
    a fake login flow that isn’t real, just to simulate it). Keeping the prototype
    focused will save you time and make it easier to throw away or rework later.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用AI添加功能非常容易，你可能会被诱惑继续添加“另一件事”到原型中，这种现象被称为*范围蔓延*。这可能导致原型不断增长，试图成为最终产品。记住原型的目的：专注于你想要回答的关键问题或要展示的核心体验。如果你发现自己正在实现登录系统、支付处理等，问问自己这些在原型阶段是否真的需要。可能更好的是，将这些功能简化（AI可以生成一个模拟的登录流程，而不是真正的流程）。保持原型的专注将节省你的时间，并使其更容易在以后丢弃或重做。
- en: Stay Focused
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持专注
- en: Write down the goal of your prototype (“Demonstrate that users can upload a
    CSV and get a chart to test viability”), and use that as a North Star. Use the
    AI to get to that goal quickly, and resist the allure of gold-plating the prototype.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 记下你原型的目标（“展示用户可以上传CSV文件并得到图表以测试可行性”），并以此为目标。使用AI快速达到这个目标，并抵制对原型进行过度美化的诱惑。
- en: 'Second, there’s the question of integration to real systems. Prototypes often
    use mock data or simplified subsystems. If your AI prototype uses dummy data or
    a local file, integrating it with real databases or services in production can
    be nontrivial. Be mindful when prototyping that some shortcuts were taken. For
    example, maybe the prototype emails weren’t actually sent but just logged to console.
    In production, you’ll need a real email service. The AI can help integrate those
    later, but it’s good to keep track: maintain a list of “things to address if we
    move forward” while prototyping. That way you won’t forget which parts were temporary.
    If working in a team, communicate these clearly. For instance, you might leave
    a comment in code: `// TODO: integrate real email service here`. Many AI tools
    actually include such TODO comments themselves when they generate a simplified
    solution, which is helpful.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '其次，是集成到真实系统中的问题。原型通常使用模拟数据或简化的子系统。如果你的AI原型使用模拟数据或本地文件，将其与生产中的真实数据库或服务集成可能并非易事。在原型设计时，要留意可能采取了某些捷径。例如，原型中的电子邮件可能实际上并没有发送，只是记录到控制台。在生产中，你需要一个真实的电子邮件服务。AI可以帮助在以后集成这些服务，但最好保持跟踪：在原型设计时维护一份“如果我们继续前进需要解决的问题”清单。这样你就不会忘记哪些部分是临时的。如果在一个团队中工作，要清楚地沟通这些内容。例如，你可能在代码中留下一条注释：`//
    TODO: 在此处集成真实电子邮件服务`。许多AI工具在生成简化解决方案时实际上会包含这样的TODO注释，这很有帮助。'
- en: By anticipating these challenges, you can use AI prototyping effectively without
    falling into its traps. When it is used thoughtfully, the result is a robust prototype
    developed in record time, ready to either be transformed into a final product
    or set aside after extracting the lessons it offered.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过预见这些挑战，你可以在不陷入其陷阱的情况下有效地使用AI原型设计。当它被深思熟虑地使用时，结果是记录时间内开发出的稳健原型，既可以转化为最终产品，也可以在提取其提供的经验教训后搁置。
- en: Summary and Next Steps
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和下一步行动
- en: 'In this chapter, you saw how AI-assisted vibe coding turbocharges the prototyping
    process. By letting AI handle the heavy lifting of code generation, developers
    can move from concept to working model with unprecedented speed. I covered tools
    like Vercel v0 for UI generation, Lovable for full stack prototypes, and AI-augmented
    IDEs like Cursor and Windsurf—each enabling different aspects of rapid prototyping.
    I also emphasized the iterative nature of AI prototyping: generating, testing,
    and refining in quick cycles, with natural-language prompts guiding the changes.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了AI辅助的vibe编码如何加速原型设计过程。通过让AI处理代码生成的繁重工作，开发者可以以前所未有的速度从概念到工作模型。我介绍了用于UI生成的Vercel
    v0工具、用于全栈原型的Lovable，以及Cursor和Windsurf等AI增强型IDE——每个都使快速原型设计的不同方面成为可能。我还强调了AI原型设计的迭代性质：快速循环生成、测试和改进，自然语言提示引导变化。
- en: 'While AI-driven prototyping can produce a functional demo in hours, we also
    discussed the critical transition to production. The message is clear: a prototype
    is not a final product. It’s the first draft. Human developers must refactor and
    harden the code, with AI continuing to assist in that journey (suggesting improvements,
    generating tests, etc.). Case studies of individuals and teams using these techniques
    highlight the real productivity gains—prototypes built in days instead of weeks,
    enabling faster user feedback and business decisions.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 AI 驱动的原型设计可以在几小时内产生一个功能演示，但我们还讨论了至关重要的过渡到生产阶段。信息很明确：原型不是最终产品。它是第一稿。人类开发者必须重构和强化代码，AI
    在此过程中继续提供协助（提出改进建议、生成测试等）。使用这些技术的个人和团队案例研究突出了真正的生产力提升——几天内而不是几周内构建原型，从而加快了用户反馈和商业决策。
- en: 'By now, you should appreciate how vibe coding makes prototyping feel more like
    brainstorming with an assistant rather than grinding out boilerplate. It’s a fundamentally
    different vibe: more conversational, more high-level, and a lot faster. However,
    you’ve also seen the importance of maintaining code quality awareness even in
    a quick prototype—and definitely when evolving it beyond the prototype stage.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经理解了vibe编码如何使原型设计感觉更像与助手头脑风暴而不是苦干。这是一种根本不同的感觉：更对话式、更高级，而且更快。然而，你也看到了即使在快速原型中也要保持代码质量意识的重要性——当然，在原型阶段之后演变时更是如此。
- en: In [Chapter 7](ch07.html#ch07_building_web_applications_with_ai_1752630044184850),
    I’ll shift focus from rapid prototyping to comprehensive web application development
    with AI assistance. While prototyping explores possibilities, full-scale development
    demands systematic approaches to architecture, implementation, and deployment.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html#ch07_building_web_applications_with_ai_1752630044184850)，我将关注点从快速原型设计转移到在人工智能辅助下的全面网络应用开发。虽然原型设计探索可能性，但全面开发需要系统性的方法来处理架构、实施和部署。
