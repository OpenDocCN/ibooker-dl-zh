- en: Chapter 9\. Securing AI Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 保护人工智能服务
- en: In earlier chapters, you learned how to build GenAI services that serve various
    AI generators while supporting concurrency and data streaming in real time. Additionally,
    you integrated external systems like databases and implemented your own authentication
    and authorization mechanisms. Finally, you wrote a test suite to verify the functionality
    and performance of your entire system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何构建通用人工智能服务，这些服务服务于各种人工智能生成器，同时支持实时并发和数据流。此外，你集成了外部系统，如数据库，并实现了自己的身份验证和授权机制。最后，你编写了一个测试套件来验证整个系统的功能和性能。
- en: In this chapter, you’ll learn how to implement usage moderation and abuse-protection
    mechanisms to secure your GenAI services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何实施使用限制和滥用保护机制来确保你的通用人工智能服务安全。
- en: Usage Moderation and Abuse Protection
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用限制和滥用保护
- en: When deploying your GenAI services, you’ll need to consider how your services
    will be misused and abused by malicious users. This is essential to protect user
    safety and your own reputation. You won’t know how the users will use your system,
    so you need to assume the worst and implement *guardrails* to protect against
    any misuse or abuse.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署你的通用人工智能服务时，你需要考虑恶意用户如何滥用和误用你的服务。这对于保护用户安全和你的声誉至关重要。你不知道用户会如何使用你的系统，因此你需要假设最坏的情况并实施*护栏*来防止任何滥用或误用。
- en: According to a [recent study on nefarious applications of GenAI](https://oreil.ly/ihmzR),
    your services may potentially be used with *malicious intents*, as described in
    [Table 9-1](#malicious_intents).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[最近关于通用人工智能恶意应用的[研究](https://oreil.ly/ihmzR)]，你的服务可能被用于具有*恶意意图*，如[表9-1](#malicious_intents)中所述。
- en: Table 9-1\. Malicious intents behind abusing GenAI services
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-1\. 滥用通用人工智能服务背后的恶意意图
- en: '| Intent | Examples | Real-world cases |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 意图 | 示例 | 现实案例 |'
- en: '| --- | --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Dishonesty**Supporting lies and untruthfulness | Plagiarism, faking competency
    and knowledge, document forgery, cheating in exams and in interviews, etc. | Increasing
    cases of students cheating with AI at UK and Australian universities^([a](ch09.html#id1032))
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| **不诚实**支持谎言和不真实性 | 抄袭、伪造能力和知识、伪造文件、考试和面试作弊等 | 英国和澳大利亚大学中越来越多的学生使用AI作弊的案例^([a](ch09.html#id1032))
    |'
- en: '| **Propaganda**Skewing perceptions of reality to advance an agenda | Impersonating
    others, promoting extremism, influencing campaigns, etc. | Fake AI news anchors
    spreading misinformation or propaganda^([b](ch09.html#id1033)) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **宣传**扭曲现实感知以推进议程 | 模仿他人、推广极端主义、影响竞选活动等 | 伪造的人工智能新闻主播传播虚假信息或宣传^([b](ch09.html#id1033))
    |'
- en: '| **Deception**Misleading others and creating false impressions | Generating
    fake reviews, scam ads and phishing emails, and synthetic profiles (i.e., sockpuppeting),
    etc. | Engineering firm Arup revealed as a victim of a $25 million deepfake scam^([c](ch09.html#id1034))
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **欺骗**误导他人并创造虚假印象 | 生成虚假评论、诈骗广告和钓鱼邮件，以及合成个人资料（即网络水军）等 | 工程公司Arup被揭露是价值2500万美元深度伪造诈骗的受害者^([c](ch09.html#id1034))
    |'
- en: '| ^([a](ch09.html#id1032-marker)) Sources: *Times Higher Education* and *The
    Guardian*^([b](ch09.html#id1033-marker)) Sources: *The Guardian*, *MIT Technology
    Review*, and *The Washington Post*^([c](ch09.html#id1034-marker)) Sources: CNN
    and *The Guardian* |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch09.html#id1032-marker)) 来源：*《泰晤士高等教育》* 和 *《卫报》*^([b](ch09.html#id1033-marker))
    来源：*《卫报》*、*《麻省理工学院技术评论》* 和 *《华盛顿邮报》*^([c](ch09.html#id1034-marker)) 来源：CNN 和 *《卫报》*
    |'
- en: 'The same study categorizes GenAI application abuse into the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的研究将通用人工智能应用的滥用分为以下几类：
- en: '*Misinformation and disinformation* to spread propaganda and fake news'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*虚假信息和错误信息* 传播宣传和假新闻'
- en: '*Bias amplification and discrimination* to advance racist agendas and societal
    discrimination'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*偏见放大和歧视* 推进种族主义议程和社会歧视'
- en: '*Malicious content generation* by creating toxic, deceptive, and radicalizing
    content'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*恶意内容生成* 通过创建有毒、欺骗性和极端主义内容'
- en: '*Data privacy attacks* to fill in gaps in stolen private data and leak sensitive
    information'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据隐私攻击* 通过填补被盗私人数据的空白并泄露敏感信息'
- en: '*Automated cyberattacks* to personalize phishing and ransomware attacks'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动化网络攻击* 定制钓鱼和勒索软件攻击'
- en: '*Identity theft and social engineering* to increase the success rate of scams'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*身份盗窃和社会工程* 提高诈骗的成功率'
- en: '*Deepfakes and multimedia manipulation* to make a profit and skew perceptions
    of reality and social beliefs'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深度伪造和多媒体操纵* 获利并扭曲现实和社会信念的感知'
- en: '*Scam and fraud* by manipulating stock markets and crafting targeted scams'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*诈骗和欺诈* 通过操纵股市和制定有针对性的诈骗'
- en: This may not be an exhaustive list but should give you a few ideas on what usage
    moderation measures to consider.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是一份详尽的清单，但它应该能给您一些关于考虑哪些使用监管措施的思路。
- en: '[Another study on the taxonomy of GenAI misuse tactics](https://oreil.ly/jbG01)
    investigated abuse by modality and found that:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[关于GenAI滥用策略分类法的另一项研究](https://oreil.ly/jbG01)调查了按模式进行的滥用，并发现：'
- en: '*Audio and video generators* were used for the majority of impersonation attempts.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*音频和视频生成器* 被用于大多数模仿尝试。'
- en: '*Image and text generators* were used for the majority of sockpuppeting, content
    farming for opinion manipulation at scale, and falsification attempts.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图像和文本生成器* 被用于大多数假身份尝试、大规模意见操纵的内容农场和伪造尝试。'
- en: '*Image and video generators* were used for the majority of steganography, (i.e.,
    hiding coded messages in model outputs), and nonconsensual intimate content (NCII)
    generation attempts.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图像和视频生成器* 被用于大多数隐写术尝试（即在模型输出中隐藏编码信息）和非自愿亲密内容（NCII）生成尝试。'
- en: If you’re building services supporting such modalities, you should consider
    their associated forms of abuse and implement relevant protection mechanisms.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建支持此类模式的服务，您应该考虑其相关的滥用形式并实施相关保护机制。
- en: Aside from misuse and abuse, you’ll also need to consider security vulnerabilities.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了滥用和误用之外，您还需要考虑安全漏洞。
- en: Securing GenAI services is still an area of research at the time of writing.
    For instance, if your services leverage LLMs, OWASP has categorized the [top 10
    LLM vulnerabilities](https://oreil.ly/4zob2), as shown in [Table 9-2](#llm_vulnerabilities).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，确保GenAI服务仍然是一个研究领域。例如，如果您的服务利用LLM，OWASP已将[前10大LLM漏洞](https://oreil.ly/4zob2)分类，如[表9-2](#llm_vulnerabilities)所示。
- en: Table 9-2\. OWASP top 10 LLM vulnerabilities
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-2\. OWASP前10大LLM漏洞
- en: '| Risk | Description |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 风险 | 描述 |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Prompt injection | Manipulating inputs to control the LLM’s responses leading
    to unauthorized access, data breaches, and compromised decision-making. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 提示注入 | 操作输入以控制LLM的响应，导致未经授权的访问、数据泄露和决策受损。|'
- en: '| Insecure output handling | Failing to sanitize or validate LLM outputs causing
    remote code execution on downstream systems. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 不安全的输出处理 | 未对LLM的输出进行清理或验证，导致下游系统上的远程代码执行。|'
- en: '| Training data poisoning | Injecting data in sources that models get trained
    on to compromise security, accuracy, or ethical behavior. Open source models and
    RAG services that rely on web data are most prone to these attacks. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 训练数据中毒 | 在模型训练的数据源中注入数据，以损害安全性、准确性或道德行为。开源模型和依赖网络数据的RAG服务最容易受到这些攻击。|'
- en: '| Model denial of service | Causing service disruption and cost explosions
    by overloading the LLMs with heavy payloads and concurrent requests. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 模型拒绝服务 | 通过向LLM加载大量有效载荷和并发请求，导致服务中断和成本激增。|'
- en: '| Supply chain vulnerabilities | Causing various components, including data
    sources, to be compromised, undermining system integrity. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 供应链漏洞 | 导致各种组件，包括数据源，被破坏，损害系统完整性。|'
- en: '| Sensitive information leakage | Leading to accidental exposure of private
    data, legal liabilities and loss of competitive advantage. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 敏感信息泄露 | 导致私人数据意外泄露，法律责任和竞争优势丧失。|'
- en: '| Insecure plug-in design | Vulnerabilities in third-party integrations cause
    remote code execution. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 不安全的插件设计 | 第三方集成中的漏洞导致远程代码执行。|'
- en: '| Excessive agency | Where LLMs have too much autonomy to take actions can
    lead to unintended consequences and harmful actions. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 过度代理 | 当LLM有太多自主权采取行动时，可能导致意外后果和有害行为。|'
- en: '| Overreliance on LLM | Compromising decision-making, contributing to security
    vulnerabilities and legal liabilities. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 过度依赖LLM | 危害决策，导致安全漏洞和法律责任。|'
- en: '| Model theft | Related to unauthorized copying or usage of your models. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 模型盗窃 | 与未经授权复制或使用您的模型相关。|'
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Similar vulnerabilities exist for other types of GenAI systems such as image,
    audio, video, and geometry generators.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他类型的GenAI系统，如图像、音频、视频和几何生成器，也存在类似的安全漏洞。
- en: I recommend researching and identifying software vulnerabilities relevant to
    your own use cases.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议研究和识别与您自己的用例相关的软件漏洞。
- en: Without guardrails, your services can be abused to cause personal and financial
    harm, identity theft, economic damage, spread misinformation, and contribute to
    societal problems. As a result, it’s crucial to implement several safety measures
    and guardrails to protect your services against such attacks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 没有防护栏，您的服务可能会被滥用，造成个人和财务损害、身份盗窃、经济损失、传播错误信息，并导致社会问题。因此，实施多项安全措施和防护栏以保护您的服务免受此类攻击至关重要。
- en: In the next section, you’ll learn usage moderation and security measures you
    can implement to protect your GenAI services prior to deployment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解在部署之前可以实施的用法调节和安全措施，以保护您的 GenAI 服务。
- en: Guardrails
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防护栏
- en: '*Guardrails* refer to *detective controls* that aim to guide your application
    toward the intended outcomes. They are incredibly diverse and can be configured
    to fit any situation that may go wrong with your GenAI systems.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*防护栏* 指的是旨在引导您的应用程序达到预期结果的 *检测控制*。它们极其多样，可以配置以适应您 GenAI 系统可能出现的任何错误情况。'
- en: As an example, *I/O guardrails* are designed to verify data entering a GenAI
    model and outputs sent to the downstream systems or users. Such guardrails can
    flag inappropriate user queries and validate output content against toxicity,
    hallucinations, or banned topics. [Figure 9-1](#guardrails) shows how an LLM system
    looks once you add I/O guardrails to it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*I/O 防护栏* 被设计来验证进入 GenAI 模型的数据和发送到下游系统或用户的输出。这样的防护栏可以标记不适当的用户查询，并验证输出内容是否具有毒性、幻觉或禁止的主题。[图
    9-1](#guardrails) 展示了在 LLM 系统中添加 I/O 防护栏后的样子。
- en: '![bgai 0901](assets/bgai_0901.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0901](assets/bgai_0901.png)'
- en: Figure 9-1\. Comparison of an LLM system without and with guardrails
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-1\. 无防护栏和有防护栏的 LLM 系统的比较
- en: You don’t have to implement guardrails from scratch. At the time of writing,
    prebuilt open source guardrail frameworks exist like NVIDIA NeMo Guardrails, LLM-Guard,
    and Guardrails AI to protect your services. However, they may require learning
    framework-related languages and have a trade-off of slowing down your services
    and bloating your application due to various external dependencies.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必从头开始实现防护栏。在撰写本文时，存在一些预构建的开源防护栏框架，如 NVIDIA NeMo Guardrails、LLM-Guard 和 Guardrails
    AI，以保护您的服务。然而，它们可能需要学习与学习框架相关的语言，并且由于各种外部依赖，可能会以减慢服务速度和膨胀应用程序为代价。
- en: Other commercial guardrails available on the market, such as Open AI’s Moderation
    API, Microsoft Azure AI Content Safety API, and Google’s Guardrails API are either
    not open source or lack details and contents to measure quality constraints.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上可用的其他商业防护栏，例如 Open AI 的 Moderation API、Microsoft Azure AI 内容安全 API 和 Google
    的 Guardrails API，要么不是开源的，要么缺乏衡量质量约束的详细信息和内容。
- en: Warning
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Guardrails remain an active area of research. While such defenses can counter
    some attacks, powerful attacks backed by AI can still bypass them. This may lead
    to an [ongoing and endless loop of assaults and defenses](https://oreil.ly/xlUmw).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 防护栏仍然是研究的一个活跃领域。虽然这些防御措施可以抵御一些攻击，但由 AI 支持的强大攻击仍然可以绕过它们。这可能导致一个 [持续不断的攻击和防御的循环](https://oreil.ly/xlUmw)。
- en: While engineering application-level I/O guardrails may not provide perfect protection,
    upcoming GenAI models may include baked-in guardrails inside the model to improve
    security guarantees. However, such guardrails may have a performance impact on
    response times by introducing latency to the system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在应用层面构建 I/O 防护栏可能无法提供完美的保护，但即将推出的 GenAI 模型可能包含内置的防护栏，以提高安全保证。然而，这样的防护栏可能会通过引入系统延迟来影响响应时间。
- en: Input Guardrails
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入防护栏
- en: The purpose of input guardrails is to prevent malicious or inappropriate content
    from reaching your model. [Table 9-3](#guardrails_input) shows common input guardrails.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输入防护栏的目的是防止恶意或不适当的内容到达您的模型。[表 9-3](#guardrails_input) 展示了常见的输入防护栏。
- en: Table 9-3\. Common input guardrails
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-3\. 常见输入防护栏
- en: '| Input guardrails | Examples |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 输入防护栏 | 例子 |'
- en: '| --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Topical**Steer inputs away from off-topic or sensitive content. | Preventing
    a user from discussing political topics and explicit content. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **主题** | 将输入引导远离非主题或敏感内容。 | 防止用户讨论政治话题和露骨的内容。 |'
- en: '| **Direct prompt injection** (jail-breaking)Prevent users from revealing or
    overriding system prompts and secrets. The longer the input content, the more
    prone your system will be to these attacks. | Blocking attempts to override system
    prompts and manipulating the system into revealing internal API keys or configuration
    settings.^([a](ch09.html#id1036)) |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **直接提示注入**（越狱）防止用户泄露或覆盖系统提示和秘密。输入内容越长，你的系统就越容易受到这些攻击。 | 阻止覆盖系统提示并操纵系统泄露内部
    API 密钥或配置设置.^([a](ch09.html#id1036)) |'
- en: '| **Indirect prompt injection**Prevent acceptance of malicious content from
    external sources such as files or websites that may cause model confusion or remote
    code execution on downstream systems.Malicious content may be invisible to the
    human eye and encoded within input text or images. | Sanitizing encoded payloads
    in upload images, hidden characters or prompt overrides in uploaded documents,
    hidden scripts in remote URLs or even YouTube video transcripts. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **间接提示注入**防止接受来自外部来源（如文件或网站）的恶意内容，这些内容可能导致模型混淆或在下层系统中执行远程代码。恶意内容可能对人类眼睛不可见，并编码在输入文本或图像中。
    | 清理上传图像中的编码有效负载、上传文档中的隐藏字符或提示覆盖、远程 URL 中的隐藏脚本，甚至是 YouTube 视频字幕中的隐藏脚本。 |'
- en: '| **Moderation**Comply with brand guidelines, legal, and branding requirements.
    | Flag and refuse invalid user queries if user queries include mentions of profanity,
    competitor, explicit content, personally identifiable information (PII), self-harm,
    etc. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **审查**遵守品牌指南、法律和品牌要求。 | 如果用户查询中包含粗俗语言、竞争对手、露骨内容、个人可识别信息（PII）、自残等提及，则标记并拒绝无效的用户查询。
    |'
- en: '| **Attribute**Validate input properties. | Check query length, file size,
    choices, range, data format and structure, etc. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **属性**验证输入属性。 | 检查查询长度、文件大小、选项、范围、数据格式和结构等。 |'
- en: '| ^([a](ch09.html#id1036-marker)) Although guardrails are useful, best practice
    is to avoid giving your GenAI models direct knowledge of secrets or sensitive
    configuration settings in the first place. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch09.html#id1036-marker)) 尽管护栏很有用，但最佳实践是首先避免让你的 GenAI 模型直接了解秘密或敏感的配置设置。
    |'
- en: The input guardrails can also be combined with content sanitizers to clean bad
    inputs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输入护栏也可以与内容净化器结合使用，以清理不良输入。
- en: If you want to implement your own guardrails, you can start off with using advanced
    prompt engineering techniques within your system prompts. Additionally, you can
    use auto-evaluation techniques, (i.e., AI models).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要实现自己的护栏，可以从在你的系统提示中使用高级提示工程技术开始。此外，你可以使用自动评估技术（即，AI 模型）。
- en: '[Example 9-1](#guardrail_topical_prompt) shows an example system prompt for
    an AI guardrail auto-evaluator to reject off-topic queries.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-1](#guardrail_topical_prompt) 展示了一个 AI 护栏自动评估器拒绝离题查询的系统提示示例。'
- en: Example 9-1\. Topical input guardrail system prompt
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-1\. 主题输入护栏系统提示
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see an implementation of an input topical guardrail in [Example 9-2](#guardrail_topical)
    using the LLM auto-evaluation technique.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[示例 9-2](#guardrail_topical)中看到使用 LLM 自动评估技术实现的输入主题护栏的示例。
- en: Example 9-2\. Topical input guardrail
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-2\. 主题输入护栏
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_securing_ai_services_CO1-1)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_securing_ai_services_CO1-1)'
- en: Handle cases where the LLM doesn’t return a valid classification
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 LLM 不返回有效分类的情况
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Using the technique shown in [Example 9-2](#guardrail_topical), you can implement
    auto-evaluators to check for jail-breaking and prompt injection attempts or even
    detect the presence of PII and profanity in the inputs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[示例 9-2](#guardrail_topical)中展示的技术，你可以实现自动评估器来检查越狱和提示注入尝试，甚至检测输入中是否存在 PII
    和粗俗语言。
- en: As discussed in [Chapter 5](ch05.html#ch05), you can leverage async programming
    as much as possible even when using auto-evaluation techniques in your guardrails.
    This is because AI guardrails require sending multiple model API calls per user
    query. To improve user experience, you can run these guardrails in parallel to
    the model inference process.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第 5 章](ch05.html#ch05)所述，即使在使用护栏中的自动评估技术时，你也可以尽可能多地利用异步编程。这是因为 AI 护栏需要为每个用户查询发送多个模型
    API 调用。为了提高用户体验，你可以将这些护栏并行运行于模型推理过程。
- en: Once you have an auto-evaluator guardrail for checking allowed topics, you can
    execute it in parallel to your data generation^([1](ch09.html#id1037)) using `asyncio.wait`,
    as shown in [Example 9-3](#guardrail_concurrent_execution).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个用于检查允许主题的自动评估护栏，你就可以使用 `asyncio.wait` 并行执行它，同时进行数据生成^([1](ch09.html#id1037))，如[示例
    9-3](#guardrail_concurrent_execution)所示。
- en: Warning
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Be mindful that implementing async guardrails may trigger model provider API
    rate-limiting and throttling mechanisms. Depending on your application requirements,
    you may want to request higher rate limits or reduce the rate of API calls within
    a short time frame.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，实现异步防护栏可能会触发模型提供者API的速率限制和节流机制。根据您的应用需求，您可能需要请求更高的速率限制或在短时间内减少API调用的频率。
- en: Example 9-3\. Running AI guardrails in parallel to response generation
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例9-3\. 并行运行AI防护栏以生成响应
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_securing_ai_services_CO2-1)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_securing_ai_services_CO2-1)'
- en: Create two asyncio tasks to run in parallel using `asyncio.wait`. The operation
    returns as soon as a task is completed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`asyncio.wait`创建两个并行运行的asyncio任务。操作会在任一任务完成时返回。
- en: '[![2](assets/2.png)](#co_securing_ai_services_CO2-2)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_securing_ai_services_CO2-2)'
- en: If the guardrail is triggered, cancel the chat operation and return a hard-coded
    response. You can log the trigger in a database and send notification emails here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果触发防护栏，取消聊天操作并返回硬编码的响应。您可以在数据库中记录触发事件并发送通知电子邮件。
- en: '[![3](assets/3.png)](#co_securing_ai_services_CO2-3)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_securing_ai_services_CO2-3)'
- en: Keep checking in with the asyncio event loop every 100 ms until a task is done.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每100毫秒检查一次asyncio事件循环，直到任务完成。
- en: '[![4](assets/4.png)](#co_securing_ai_services_CO2-4)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_securing_ai_services_CO2-4)'
- en: Leverage dependency injection to return the model response if guardrails aren’t
    triggered.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有触发防护栏，利用依赖注入返回模型响应。
- en: Since GenAI-enabled guardrails like those you implemented in [Example 9-3](#guardrail_concurrent_execution)
    remain probabilistic, your GenAI services can still be vulnerable to prompt injection
    and jail-breaking attacks. For instance, attackers can use more advanced prompt
    injection techniques to get around your AI guardrails too. On the other hand,
    your guardrails may also incorrectly over-refuse valid user queries, leading to
    false positives that can downgrade your user experience.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于像在[示例9-3](#guardrail_concurrent_execution)中实现的GenAI启用防护栏仍然是概率性的，您的GenAI服务仍然可能容易受到提示注入和越狱攻击。例如，攻击者可以使用更高级的提示注入技术来绕过您的AI防护栏。另一方面，您的防护栏也可能错误地过度拒绝有效用户查询，导致假阳性，从而降低用户体验。
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Combining guardrails with rules-based or traditional machine learning models
    for detection can help mitigate some of the aforementioned risks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将防护栏与基于规则的或传统的机器学习模型结合用于检测可以帮助减轻一些上述风险。
- en: Additionally, you can use guardrails that only consider the latest message to
    reduce the risk of the model being confused by a long conversation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以使用仅考虑最新消息的防护栏来降低模型被长时间对话所混淆的风险。
- en: When designing guardrails, you need to consider trade-offs between *accuracy*,
    *latency*, and *cost* to balance user experience with your required security controls.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计防护栏时，您需要考虑*准确性*、*延迟*和*成本*之间的权衡，以平衡用户体验与您所需的安全控制。
- en: Output Guardrails
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出防护栏
- en: The purpose of output guardrails is to validate GenAI-produced content before
    it’s passed to users or downstream systems. [Table 9-4](#guardrails_output) shows
    common output guardrails.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输出防护栏的目的是在内容传递给用户或下游系统之前验证由GenAI生成的内容。[表9-4](#guardrails_output)显示了常见的输出防护栏。
- en: Table 9-4\. Common output guardrails
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-4\. 常见输出防护栏
- en: '| Output guardrails | Examples |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 输出防护栏 | 示例 |'
- en: '| --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Hallucination/fact-checking**Block hallucinations and return canned responses
    such as “I don’t know.” | Measuring metrics such as *relevancy*, *coherence*,
    *consistency*, *fluency*, etc., on the model outputs against a corpus of ground
    truth in RAG applications. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **幻觉/事实核查**阻止幻觉并返回如“我不知道”之类的标准响应 | 在RAG应用中，在真实数据集的语料库上对模型输出进行如*相关性*、*连贯性*、*一致性*、*流畅性*等指标的测量。|'
- en: '| **Moderation**Apply brand and corporate guidelines to govern the model outputs,
    either filtering or rewriting responses that breach them. | Checking against metrics
    such as *readability*, *toxicity*, *sentiment*, *count of competitor mentions*,
    etc. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **审查**应用品牌和公司指南来管理模型输出，过滤或重写违反这些指南的响应。 | 与如*可读性*、*毒性*、*情感*、*竞争对手提及次数*等指标进行核对。|'
- en: '| **Syntax checks**Verify the structure and content of model outputs. These
    guardrails can either detect and retry or gracefully handle exceptions to prevent
    failures in the downstream systems. | Validating JSON schemas and function parameters
    in *function calling* workflows when models invoke functions.Checking tool/agent
    selections in *agentic workflows*. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **语法检查**验证模型输出的结构和内容。这些守卫可以检测并重试，或者优雅地处理异常，以防止下游系统失败。在模型调用函数时验证 JSON 架构和函数参数。在
    *代理工作流程* 中检查工具/代理的选择。|'
- en: Any of the aforementioned output guardrails will rely on *threshold value* to
    detect invalid responses.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 任何上述输出守卫都将依赖于 *阈值值* 来检测无效响应。
- en: Guardrail Thresholds
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 守卫阈值
- en: 'Guardrails can use various metrics such as *readability*, *toxicity*, etc.,
    to measure and validate the quality of the model outputs. For each metric, you’ll
    need to experiment to identify the appropriate *threshold value* for your use
    case, bearing in mind that:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 守卫可以使用各种指标，如 *可读性*、*毒性* 等，来衡量和验证模型输出的质量。对于每个指标，您需要实验以确定适用于您用例的适当 *阈值值*，同时考虑到：
- en: More *false positives* can annoy your users and reduce the usability of your
    services.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多的 *假阳性* 可能会令您的用户烦恼，并降低您服务的可用性。
- en: More *false negatives* can cause lasting harm to your reputation and explode
    costs since malicious users can abuse the system or perform prompt injection/jail-breaking
    attacks.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多的 *假阴性* 可能会对您的声誉造成长期损害，并导致成本激增，因为恶意用户可能会滥用系统或执行提示注入/越狱攻击。
- en: Normally, you should assess the risks and worst cases of having false negatives
    and whether you’re happy to trade off a few false negatives in your use case for
    enhanced user experience. For instance, you can reduce instances of blocking outputs
    if they include more jargon and aren’t as readable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您应该评估出现假阴性的风险和最坏情况，以及您是否愿意为了增强用户体验而牺牲一些假阴性。例如，您可以减少包含更多术语且可读性不高的输出被阻止的情况。
- en: Implementing a Moderation Guardrail
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现审查守卫
- en: Let’s implement a moderation guardrail using a version of the [*G-Eval* evaluation
    method](https://oreil.ly/7Nent) to measure the presence of unwanted content in
    the model output.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 [*G-Eval* 评估方法](https://oreil.ly/7Nent) 的一个版本来实现审查守卫，以测量模型输出中不希望出现的内容。
- en: 'The G-Eval framework uses the following components to score invalid content:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: G-Eval 框架使用以下组件来评分无效内容：
- en: A *domain* name specifying the type of content to be moderated
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指定要审查的内容类型的 *域名*
- en: A set of *criteria* to clearly outline what is considered valid versus invalid
    content
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一套 *标准*，用于明确区分有效内容与无效内容
- en: An ordered list of *instruction steps* for grading the content
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一份用于评分内容的有序 *指令步骤* 列表
- en: The *content* to grade between a discrete score of 1 to 5
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在离散评分 1 到 5 之间的 *内容* 进行评分
- en: '[Example 9-4](#guardrail_moderation_prompt) shows a system prompt implementing
    the *G-Eval* framework that an LLM auto-evaluator will use.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-4](#guardrail_moderation_prompt) 展示了一个实现 *G-Eval* 框架的系统提示，该框架是 LLM 自动评估器将要使用的。'
- en: Example 9-4\. Moderation guardrail system prompt
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-4\. 审查守卫系统提示
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the system prompt implemented in [Example 9-4](#guardrail_moderation_prompt),
    you can now implement a moderation guardrail following [Example 9-2](#guardrail_topical).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [示例 9-4](#guardrail_moderation_prompt) 中实现的系统提示，你现在可以按照 [示例 9-2](#guardrail_topical)
    的方式实现一个审查守卫。
- en: Next, let’s integrate the moderation guardrail with your existing chat invocation
    logic, as shown in [Example 9-5](#guardrail_moderation).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将审查守卫与您现有的聊天调用逻辑集成，如 [示例 9-5](#guardrail_moderation) 所示。
- en: Example 9-5\. Integrating moderation guardrail
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-5\. 集成审查守卫
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_securing_ai_services_CO3-1)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_securing_ai_services_CO3-1)'
- en: Use a Pydantic constrained integer type to validate LLM auto-evaluator G-Eval
    score.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Pydantic 限制整数类型来验证 LLM 自动评估器 G-Eval 分数。
- en: '[![2](assets/2.png)](#co_securing_ai_services_CO3-2)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_securing_ai_services_CO3-2)'
- en: Flag content that is scored above the threshold as not passing moderation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将评分高于阈值的内标为未通过审查。
- en: '[![3](assets/3.png)](#co_securing_ai_services_CO3-3)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_securing_ai_services_CO3-3)'
- en: Integrate and run the output moderation guardrail with other guardrails.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 集成并运行输出审查守卫与其他守卫。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Beyond the novel *G-Eval* framework implemented using an LLM auto-evaluator,
    you can also use more traditional automatic evaluation frameworks such as [ROUGE](https://oreil.ly/_9Q9g),
    [BERTScore](https://oreil.ly/jRTeL), and [SummEval](https://oreil.ly/5YtJG) for
    moderating output content.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用LLM自动评估器实现的创新**G-Eval**框架之外，您还可以使用更传统的自动评估框架，如[ROUGE](https://oreil.ly/_9Q9g)、[BERTScore](https://oreil.ly/jRTeL)和[SummEval](https://oreil.ly/5YtJG)来调节输出内容。
- en: Well done. You have now implemented two I/O guardrails, one to verify topics
    of user queries and another to moderate the LLM outputs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。您现在已经实现了两个I/O安全栏，一个用于验证用户查询的主题，另一个用于调节LLM输出。
- en: 'To improve your guardrail system even further, you can:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步提高您的安全栏系统，您可以：
- en: Adopt the *fast failure* approach by exiting early if a guardrail is triggered
    to optimize response times.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用**快速失败**方法，如果触发安全栏则提前退出，以优化响应时间。
- en: Only select *appropriate guardrails* for your use cases instead of using them
    all together, which could overwhelm your services.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只为您的用例选择**合适的**安全栏，而不是全部一起使用，这可能会压倒您的服务。
- en: Run guardrails *asynchronously* instead of sequentially to optimize latency.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将安全栏**异步**运行而不是顺序运行，以优化延迟。
- en: Implement *request sampling* by running slower guardrails on a sample of requests
    to reduce overall latency when your services are under a heavy load.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在请求样本上运行较慢的安全栏来**实现请求采样**，以减少在服务负载过重时的整体延迟。
- en: You should now feel more confident implementing your own guardrails using classical
    or LLM auto-evaluation techniques without relying on external tools and libraries.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该更有信心使用经典或LLM自动评估技术来实施自己的安全栏，而不依赖于外部工具和库。
- en: In the next section, you’ll learn about API rate limiting so that you can protect
    your services against model overloading and scraping attempts.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解API速率限制，以便您可以为保护您的服务免受模型过载和抓取尝试而采取行动。
- en: API Rate Limiting and Throttling
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API速率限制和节流
- en: When deploying GenAI services, you will need to consider service exhaustion
    and model overloading issues in production. Best practice is to implement rate
    limiting and potentially throttling into your services.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署GenAI服务时，您需要考虑生产中的服务耗尽和模型过载问题。最佳实践是在您的服务中实施速率限制和可能的节流。
- en: '*Rate limiting* controls the amount of incoming and outgoing traffic to and
    from a network to prevent abuse, ensure fair usage, and avoid overloading the
    server. On the other hand, *throttling* controls the API throughput by temporarily
    slowing down the rate of request processing to stabilize the server.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**速率限制**控制网络到和从的入出流量，以防止滥用，确保公平使用，并避免服务器过载。另一方面，**节流**通过暂时减慢请求处理速率来控制API吞吐量，以稳定服务器。'
- en: 'Both techniques can help you:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术都可以帮助您：
- en: '*Prevent abuse* by blocking malicious users or bots from overwhelming your
    services from data scraping and brute-force attacks that involve too many requests
    or large payloads.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止滥用**，通过阻止恶意用户或机器人通过数据抓取和涉及过多请求或大负载的暴力攻击来压倒您的服务。'
- en: '*Enforce fair usage policies* so that capacity is shared among multiple users
    and a handful of users are prevented from monopolizing server resources.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制执行公平使用政策**，以便多个用户共享容量，并防止少数用户垄断服务器资源。'
- en: '*Maintain server stability* by regulating incoming traffic to maintain consistent
    performance and prevent crashes during peak periods.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调节入站流量来**维持服务器稳定性**，以保持一致的性能并防止在高峰期崩溃。
- en: To implement rate limiting, you will need to monitor incoming requests within
    a time period and use a queue to balance the load.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现速率限制，您需要在一段时间内监控入站请求，并使用队列来平衡负载。
- en: There are several rate-limiting strategies you can choose from, which are compared
    in [Table 9-5](#rate_limiting_strategies) and shown in [Figure 9-2](#rate_limiting_strategies_comparison).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择几种速率限制策略，这些策略在[表9-5](#rate_limiting_strategies)中进行了比较，并在[图9-2](#rate_limiting_strategies_comparison)中显示。
- en: Table 9-5\. Rate-limiting strategies
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-5\. 速率限制策略
- en: '| Strategy | Benefits | Limitations | Use cases |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 策略 | 利益 | 局限性 | 用例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **Token Bucket**A list is filled with tokens at a constant rate, and every
    incoming request consumes a token. If there aren’t enough tokens for incoming
    requests, they’ll be rejected. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **令牌桶**一个列表以恒定速率填充令牌，每个入站请求消耗一个令牌。如果入站请求没有足够的令牌，它们将被拒绝。|'
- en: Handles temporary bursts and dynamic traffic patterns
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理临时突增和动态流量模式
- en: Granular control over request processing
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对请求处理进行细粒度控制
- en: '| Complex to implement | Commonly used in most APIs and services, and interactive
    or event-driven GenAI systems where request rates can be irregular |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 实现复杂 | 在大多数 API 和服务以及交互式或事件驱动的 GenAI 系统中常用，其中请求速率可能不规则 |'
- en: '| **Leaky Bucket**Incoming requests are added to a queue and processed at a
    constant rate to smooth the traffic. If the queue overflows, any new incoming
    requests are rejected. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **漏桶**将传入请求添加到队列中，并以恒定速率处理以平滑流量。如果队列溢出，则拒绝任何新的传入请求。|'
- en: Simple to implement
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现简单
- en: Maintains consistent traffic flow
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维持一致的流量
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Less flexible to dynamic traffic
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对动态流量的灵活性较低
- en: May reject valid requests during sudden spikes
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在突发高峰期间可能会拒绝有效请求
- en: '| Services that require maintaining consistent response times in AI inference
    services |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 需要在 AI 推理服务中保持一致响应时间的服务 |'
- en: '| **Fixed Window**Limits requests within fixed time windows (e.g., 100 requests
    per minute). | Simple to implement | Does not handle burst traffic well |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **固定窗口**在固定时间窗口内限制请求（例如，每分钟100个请求）。| 实现简单 | 不擅长处理突发流量 |'
- en: Enforcing strict usage policies for expensive AI inferences and API calls
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制执行昂贵的 AI 推理和 API 调用的严格使用策略
- en: Ideal for free tier users or batch-processing systems with predictable usage
    patterns
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于免费层用户或具有可预测使用模式的批处理系统来说，是理想的
- en: Each request is treated equally
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个请求都同等对待
- en: '|'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Sliding Window**Counts requests over a rolling time frame. | Provides better
    flexibility, granularity, and burst traffic smoothing |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **滑动窗口**在滚动时间框架内计算请求。| 提供更好的灵活性、粒度，以及突发流量平滑处理 |'
- en: More complex to implement
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现更复杂
- en: Requires higher memory usage for tracking requests
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪请求需要更高的内存使用
- en: '|'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Much better at handling burst traffic
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更擅长处理突发流量
- en: Ideal for conversational AI or premium-tier users who expect flexible, high-frequency
    access over time
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于期望随时间灵活、高频访问的对话式 AI 或高级用户来说，是理想的
- en: '|'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![bgai 0902](assets/bgai_0902.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0902](assets/bgai_0902.png)'
- en: Figure 9-2\. Comparison of rate-limiting strategies
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-2\. 速率限制策略比较
- en: Now that you’re more familiar with rate-limiting concepts, let’s try to implement
    rate limiting in FastAPI.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对速率限制概念更加熟悉了，让我们尝试在 FastAPI 中实现速率限制。
- en: Implementing Rate Limits in FastAPI
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 FastAPI 中实现速率限制
- en: 'The fastest approach to add rate limiting within FastAPI is to use a library
    such as `slowapi` that is a wrapper over the `limits` package, supporting most
    of the strategies mentioned in [Table 9-5](#rate_limiting_strategies). First,
    install the `slowapi` library:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FastAPI 中添加速率限制的最快方法是使用 `slowapi` 这样的库，它是对 `limits` 包的包装，支持 [表 9-5](#rate_limiting_strategies)
    中提到的大多数策略。首先，安装 `slowapi` 库：
- en: '[PRE5]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once you’ve installed the `slowapi` package, you can follow [Example 9-6](#rate_limiting_slowapi_configurations)
    to apply global API or endpoint rate limiting. You can also track and limit usage
    per IP address.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 `slowapi` 包后，你可以按照 [示例 9-6](#rate_limiting_slowapi_configurations) 进行操作，以应用全局
    API 或端点速率限制。你还可以按 IP 地址跟踪和限制使用。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Without configuring an external data store, `slowapi` stores and tracks IP addresses
    in the application memory for rate limiting.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 不配置外部数据存储，`slowapi` 在应用程序内存中存储和跟踪 IP 地址以进行速率限制。
- en: Example 9-6\. Configuring global rate limits
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-6\. 配置全局速率限制
- en: '[PRE6]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_securing_ai_services_CO4-1)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_securing_ai_services_CO4-1)'
- en: Create rate limiter that tracks usage across each IP address and rejects requests
    if they exceed specified limits across the application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 创建速率限制器，跟踪每个 IP 地址的使用情况，并在应用程序中超过指定限制时拒绝请求。
- en: '[![2](assets/2.png)](#co_securing_ai_services_CO4-2)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_securing_ai_services_CO4-2)'
- en: Add a custom exception handler for rate-limited requests to compute and provide
    waiting times before requests are accepted again.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为速率限制请求添加自定义异常处理器，以在请求再次接受之前计算和提供等待时间。
- en: With the `limiter` decorator configured, you can now use it on your API handlers,
    as shown in [Example 9-7](#rate_limiting_slowapi).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了 `limiter` 装饰器后，你现在可以在你的 API 处理器上使用它，如 [示例 9-7](#rate_limiting_slowapi) 所示。
- en: Example 9-7\. Setting API rate limits for each API handler
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-7\. 为每个 API 处理器设置 API 速率限制
- en: '[PRE7]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_securing_ai_services_CO5-1)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_securing_ai_services_CO5-1)'
- en: Specify more granular rate limits at endpoint level using a rate-limiting decorator.
    The `limiter` decorator must be ordered last.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用速率限制装饰器在端点级别指定更细粒度的速率限制。`limiter` 装饰器必须放在最后。
- en: '[![2](assets/2.png)](#co_securing_ai_services_CO5-2)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_securing_ai_services_CO5-2)'
- en: Pass the `Request` object to each controller so that the `slowapi` limiter decorator
    can hook into the incoming request. Otherwise, rate limiting will not function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Request`对象传递给每个控制器，以便`slowapi`限制器装饰器可以挂钩到传入的请求。否则，速率限制将不会起作用。
- en: '[![3](assets/3.png)](#co_securing_ai_services_CO5-3)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)(#co_securing_ai_services_CO5-3)'
- en: Exclude the `/health` endpoint from rate-limiting logic as cloud providers or
    Docker daemons may ping this endpoint continually to check the status of your
    application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 将`/health`端点从速率限制逻辑中排除，因为云提供商或Docker守护进程可能会不断ping此端点以检查应用程序的状态。
- en: '[![4](assets/4.png)](#co_securing_ai_services_CO5-4)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)(#co_securing_ai_services_CO5-4)'
- en: Avoid rate limiting the `/health` endpoint as external systems may frequently
    trigger it to check the current status of your service.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 避免对`/health`端点进行速率限制，因为外部系统可能会频繁触发它以检查服务的当前状态。
- en: Now that you’ve implemented the rate limits, you can run load tests using the
    `ab` (Apache Benchmarking) CLI tool, as shown in [Example 9-8](#rate_limiting_load_testing).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经实现了速率限制，您可以使用`ab`（Apache Benchmarking）CLI工具运行负载测试，如[示例 9-8](#rate_limiting_load_testing)所示。
- en: Example 9-8\. API load testing with Apache Benchmark CLI
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-8\. 使用Apache Benchmark CLI进行API负载测试
- en: '[PRE8]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_securing_ai_services_CO6-1)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)(#co_securing_ai_services_CO6-1)'
- en: Send 100 requests with a rate of 2 parallel requests per second.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以每秒2个并行请求的速率发送100个请求。
- en: 'Your terminal outputs should show the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您的终端输出应显示以下内容：
- en: '[PRE9]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Your global and local limiting system should now be working as intended based
    on incoming IPs.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 根据传入的IP地址，您的全局和本地限制系统现在应该按预期工作。
- en: User-based rate limits
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于用户的速率限制
- en: With an IP rate limit, you’re limiting excess usage based on IP, but users can
    get around IP rate limiting by using VPNs, proxies, or rotating IP addresses.
    Instead, you want each user to have a dedicated quota to prevent a single user
    from consuming all available resources. Adding user-based limits can help you
    prevent abuse, as shown in [Example 9-9](#rate_limiting_slowapi_users).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IP速率限制，您是根据IP限制过度使用，但用户可以通过使用VPN、代理或轮换IP地址来绕过IP速率限制。相反，您希望每个用户都有一个专用的配额，以防止单个用户消耗所有可用资源。添加基于用户的限制可以帮助您防止滥用，如[示例
    9-9](#rate_limiting_slowapi_users)所示。
- en: Example 9-9\. User-based rate limiting
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-9\. 基于用户的速率限制
- en: '[PRE10]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Your system will now be limiting users based on their account IDs alongside
    their IP addresses.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您的系统现在将根据用户的账户ID以及他们的IP地址来限制用户。
- en: Rate limits across instances in production
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生产实例中的速率限制
- en: Since you may run multiple instances of your application in production as you
    scale your services, you’ll also want to centralize your usage tracking. Otherwise,
    each instance will provide their own counters to users, and a load balancer distributes
    requests between instances; usage won’t be capped as you’d expect. To rectify
    this issue, you can switch the `slowapi` in-memory storage backend with a centralized
    in-memory database such as Redis, as shown in [Example 9-10](#rate_limiting_slowapi_redis).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您在扩展服务时可能会在生产中运行多个应用程序实例，因此您还希望集中跟踪使用情况。否则，每个实例将向用户提供自己的计数器，负载均衡器在实例之间分配请求；使用情况不会像您预期的那样受限。为了解决这个问题，您可以将`slowapi`的内存存储后端切换为中央内存数据库，如Redis，如[示例
    9-10](#rate_limiting_slowapi_redis)所示。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'To run [Example 9-10](#rate_limiting_slowapi_redis), you will need a Redis
    database to store user API usage data:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行[示例 9-10](#rate_limiting_slowapi_redis)，您需要一个Redis数据库来存储用户API使用数据：
- en: '[PRE11]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Example 9-10\. Adding a centralized usage memory store (Redis) across multiple
    instances
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-10\. 在多个实例中添加集中使用内存存储（Redis）
- en: '[PRE12]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You now have a working rate-limited API that functions as intended across multiple
    instances.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在有一个按预期在多个实例上工作的速率限制API。
- en: You can get around this issue by implementing your own limiter supported by
    the `limits` package instead. Alternatively, you can apply rate limiting via a
    *load balancer*, a *reverse proxy*, or an *API gateway* instead.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过实现自己的限制器，该限制器由`limits`包支持，来解决这个问题。或者，您可以通过*负载均衡器*、*反向代理*或*API网关*来应用速率限制。
- en: Each solution can route requests while performing rate limits, protocol translation,
    and traffic monitoring at an infrastructure layer. Applying rate limiting externally
    may be more suitable for your use case if you don’t require a customized rate-limiting
    logic.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 每个解决方案都可以在基础设施层执行请求路由、速率限制、协议转换和流量监控，同时执行速率限制。如果您不需要定制的速率限制逻辑，那么在您的用例中，外部应用速率限制可能更合适。
- en: Limiting WebSocket connections
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制WebSocket连接
- en: Unfortunately the `slowapi` package also doesn’t support limiting async and
    WebSocket endpoints at the time of writing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`slowapi`包在撰写本文时也不支持限制异步和WebSocket端点。
- en: Because WebSocket connections are likely to be long-lived, you may want to limit
    the data transition rate sent over the socket. You can rely on external packages
    such as `fastapi-limiter` to rate limit WebSocket connections, as shown in [Example 9-11](#rate_limiting_websocket).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于WebSocket连接可能是长期存在的，你可能想要限制通过套接字发送的数据转换速率。你可以依赖外部包，如`fastapi-limiter`，来限制WebSocket连接，如图[示例9-11](#rate_limiting_websocket)所示。
- en: Example 9-11\. Rate-limiting WebSocket connections with the `fastapi_limiter`
    package
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例9-11\. 使用`fastapi_limiter`包限制WebSocket连接的速率
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_securing_ai_services_CO7-1)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_securing_ai_services_CO7-1]'
- en: Configure the `FastAPILimiter` application lifespan with a Redis storage backend.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Redis存储后端配置`FastAPILimiter`应用程序的生命周期。
- en: '[![2](assets/2.png)](#co_securing_ai_services_CO7-2)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_securing_ai_services_CO7-2]'
- en: Configure a WebSocket rate limiter to allow one request per second.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 配置WebSocket速率限制器，允许每秒一个请求。
- en: '[![3](assets/3.png)](#co_securing_ai_services_CO7-3)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_securing_ai_services_CO7-3]'
- en: Use the user’s ID as the unique identifier for rate limiting.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用用户的ID作为速率限制的唯一标识符。
- en: '[Example 9-11](#rate_limiting_websocket) shows how to limit the number of active
    WebSocket connections for a given user.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例9-11](#rate_limiting_websocket)展示了如何限制给定用户的活跃WebSocket连接数。'
- en: Beyond rate-limiting WebSocket endpoints, you may also want to limit the data
    streaming rate of your GenAI models. Let’s look at how you can throttle real-time
    data streams next.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 除了限制WebSocket端点之外，你还可能想要限制你的GenAI模型的数据流速率。接下来，让我们看看如何节流实时数据流。
- en: Throttling Real-Time Streams
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节流实时流
- en: When working with real-time streams, you may need to slow down the streaming
    rate to give clients enough time to consume the stream and improve streaming throughput
    across multiple clients. In addition, throttling can help you manage the network
    bandwidth, server load, and resource utilization.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当与实时流一起工作时，你可能需要减慢流速率，以便给客户端足够的时间来消费流，并提高多个客户端之间的流吞吐量。此外，节流可以帮助你管理网络带宽、服务器负载和资源利用率。
- en: Applying a *throttle* at the stream generation layer, as shown in [Example 9-12](#throttling_stream),
    is an effective approach to managing throughput if your services are under pressure.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在流生成层应用*节流*，如图[示例9-12](#throttling_stream)，如果你的服务处于压力之下，这是一种有效的管理吞吐量的方法。
- en: Example 9-12\. Throttling streams
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例9-12\. 节流流
- en: '[PRE14]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_securing_ai_services_CO8-1)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_securing_ai_services_CO8-1]'
- en: Set a fixed throttling rate or dynamically adjust based on usage.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 设置固定的节流速率或根据使用情况动态调整。
- en: '[![2](assets/2.png)](#co_securing_ai_services_CO8-2)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_securing_ai_services_CO8-2]'
- en: Slow down the streaming rate without blocking the event loop.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 减慢流速率而不阻塞事件循环。
- en: You can then use the throttled stream within an SSE or WebSocket endpoint. Or,
    you can limit the number of active WebSocket connections per your own custom policies.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用节流流在SSE或WebSocket端点内使用。或者，你可以根据你自己的自定义策略限制每个活动的WebSocket连接数。
- en: Alongside the application-level throttling for real-time streams, you can also
    leverage *traffic shaping* at the infrastructure layer.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实时流的本地节流之外，你还可以在基础设施层利用*流量整形*。
- en: Using safeguards, rate limits, and throttles should provide enough barriers
    in protecting your services from abuse and misuse.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用防护措施、速率限制和节流，应该为保护你的服务免受滥用和误用提供足够的障碍。
- en: In the next section, you’ll learn more about optimization techniques that can
    help you reduce latency, increase response quality, and throughput alongside reducing
    the costs of your GenAI services.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解更多优化技术，这些技术可以帮助你降低延迟，提高响应质量和吞吐量，同时降低你的GenAI服务的成本。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided a comprehensive summary of attack vectors for GenAI services
    and how to safeguard them against adversarial attempts, misuse, and abuse.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了GenAI服务的攻击向量全面总结以及如何防范对抗性尝试、误用和滥用。
- en: You learned to implement input and output guardrails alongside evaluation and
    content filtering mechanisms to moderate service usage. Alongside guardrails,
    you also developed API rate-limiting and throttling protections to manage server
    load and prevent abuse.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了在评估和内容过滤机制的同时实现输入和输出防护栏，以调节服务使用。在防护栏的基础上，你还开发了API速率限制和节流保护来管理服务器负载并防止滥用。
- en: In the next chapter, we will learn about optimizing AI services through various
    techniques such as caching, batch processing, model quantizing, prompt engineering,
    and model fine-tuning.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习通过各种技术优化 AI 服务，例如缓存、批量处理、模型量化、提示工程和模型微调。
- en: ^([1](ch09.html#id1037-marker)) Inspired by [OpenAI Cookbook’s “How to Implement
    LLM Guardrails”](https://oreil.ly/UQV6i).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch09.html#id1037-marker)) 受到[《OpenAI 烹饪手册》中的“如何实现 LLM 防护栏”](https://oreil.ly/UQV6i)的启发。
