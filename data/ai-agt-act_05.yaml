- en: 6 Building autonomous assistants
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 构建自主助手
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Behavior trees for robotics and AI apps
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于机器人和人工智能应用程序的行为树
- en: GPT Assistants Playground and creating assistants and actions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPT 助手游乐场和创建助手及动作
- en: Autonomous control of agentic behavior trees
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自主控制代理行为树
- en: Simulating conversational multi-agent systems via agentic behavior trees
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过代理行为树模拟对话多代理系统
- en: Using back chaining to create behavior trees for complex systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反向链接创建复杂系统的行为树
- en: Now that we’ve covered how actions extend the power/capabilities of agents,
    we can look at how behavior trees can guide agentic systems. We’ll start by understanding
    the basics of behavior trees and how they control robotics and AI in games.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何通过动作扩展代理的能力，我们可以看看行为树如何指导代理系统。我们将从理解行为树的基本原理以及它们如何控制游戏中的机器人和人工智能开始。
- en: We’ll return to agentic actions and examine how actions can be implemented on
    the OpenAI Assistants platform using the GPT Assistants Playground project. From
    there, we’ll look at how to build an autonomous agentic behavior tree (ABT) using
    OpenAI assistants. Then, we’ll move on to understanding the need for controls
    and guardrails on autonomous agents and using control barrier functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回到代理动作，并检查如何使用 GPT 助手游乐场项目在 OpenAI 助手平台上实现动作。从那里，我们将探讨如何使用 OpenAI 助手构建自主代理行为树（ABT）。然后，我们将转向理解自主代理需要控制和护栏，并使用控制屏障函数。
- en: In the final section of the chapter, we’ll examine the use of the AgentOps platform
    to monitor our autonomous behavior-driven agentic systems. This will be an exciting
    chapter with several challenges. Let’s begin by jumping into the next section,
    which introduces behavior trees.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将检查使用 AgentOps 平台来监控我们的自主行为驱动代理系统。这将是一个充满挑战的章节。让我们首先跳到下一节，介绍行为树。
- en: 6.1 Introducing behavior trees
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 行为树的介绍
- en: Behavior trees are a long-established pattern used to control robotics and AI
    in games. Rodney A. Brooks first introduced the concept in his “A Robust Layered
    Control System for a Mobile Robot” paper in 1986\. This laid the groundwork for
    a pattern that expanded on using the tree and node structure we have today.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树是一种长期建立的模式，用于控制游戏中的机器人和人工智能。罗德尼·A·布鲁斯（Rodney A. Brooks）首次在 1986 年的“为移动机器人设计的鲁棒分层控制系统”论文中介绍了这个概念。这为今天我们所使用的树和节点结构扩展了模式奠定了基础。
- en: 'If you’ve ever played a computer game with nonplayer characters (NPCs) or interacted
    with advanced robotic systems, you’ve witnessed behavior trees at work. Figure
    6.1 shows a simple behavior tree. The tree represents all the primary nodes: selector
    or fallback nodes, sequence nodes, action nodes, and condition nodes.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经玩过与非玩家角色（NPC）互动的电脑游戏或与高级机器人系统互动，你就已经见证了行为树在工作。图 6.1 展示了一个简单的行为树。该树代表所有主要节点：选择器或回退节点、序列节点、动作节点和条件节点。
- en: '![figure](../Images/6-1.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/6-1.png)'
- en: Figure 6.1 A simple behavior tree of eating an apple or a pear
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1 吃苹果或梨的简单行为树
- en: Table 6.1 describes the functions and purpose of the primary nodes we’ll explore
    in this book. There are other nodes and node types, and you can even create custom
    nodes, but for now, we’ll focus on those in the table.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 描述了本书中将探讨的主要节点的功能和目的。还有其他节点和节点类型，你甚至可以创建自定义节点，但就目前而言，我们将专注于表中的那些。
- en: Table 6.1 The primary nodes used in behavior trees
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 6.1 行为树中使用的主要节点
- en: '| Node | Purpose | Function | Type |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 节点 | 目的 | 功能 | 类型 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Selector (fallback)  | This node works by selecting the first child that
    completes successfully. It’s often called the fallback node because it will always
    fall back to the last successful node that executed.  | The node calls its children
    in sequence and stops executing when the first child succeeds. When a child node
    succeeds, it will return success; if no nodes succeed, it returns failure.  |
    Composite  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 选择器（回退） | 此节点通过选择第一个成功完成的子节点来工作。它通常被称为回退节点，因为它总是会回退到最后一个成功执行的节点。 | 节点按顺序调用其子节点，并在第一个子节点成功时停止执行。当子节点成功时，它将返回成功；如果没有节点成功，它将返回失败。
    | 组合 |'
- en: '| Sequence  | This node executes all of its children in sequence until one
    node fails or they all complete successfully.  | The node calls each of its children
    in sequence regardless of whether they fail or succeed. If all children succeed,
    it returns success, and failure if just one child fails.  | Composite  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 序列 | 此节点按顺序执行其所有子节点，直到某个节点失败或它们都成功完成。 | 节点按顺序调用其所有子节点，无论它们是否失败或成功。如果所有子节点都成功，则返回成功，如果只有一个子节点失败，则返回失败。
    | 组合节点 |'
- en: '| Condition  | Behavior trees don’t use Boolean logic but rather success or
    failure as a means of control. The condition returns success if the condition
    is true and false otherwise.  | The node returns success or failure based on a
    condition.  | Task  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 条件 | 行为树不使用布尔逻辑，而是使用成功或失败作为控制手段。条件在条件为真时返回成功，否则返回失败。 | 节点根据条件返回成功或失败。 | 任务节点
    |'
- en: '| Action  | This is where the action happens.  | The node executes and returns
    success if successful or returns failure otherwise.  | Task  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 动作 | 这就是动作发生的地方。 | 节点执行并返回成功，如果成功则返回成功，否则返回失败。 | 任务节点 |'
- en: '| Decorator  | They work by controlling the execution of child nodes. They
    are often referred to as conditionals because they can determine whether a node
    is worth executing or safe to execute.  | The node controls execution of the child
    nodes. Decorators can operate as control barrier functions to block or prevent
    unwanted behaviors.  | Decorator  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 装饰器 | 它们通过控制子节点的执行来工作。它们通常被称为条件，因为它们可以确定一个节点是否值得执行或安全执行。 | 节点控制子节点的执行。装饰器可以作为控制屏障函数来阻止或防止不受欢迎的行为。
    | 装饰器节点 |'
- en: '| Parallel  | This node executes all of its nodes in parallel. Success or failure
    is controlled by a threshold of the number of children needed to succeed to return
    success.  | The node executes all of its child nodes in sequence regardless of
    the status of the nodes.  | Composite  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 并行 | 此节点并行执行其所有节点。成功或失败由所需成功子节点的阈值控制。 | 节点按顺序执行其所有子节点，无论节点状态如何。 | 组合节点 |'
- en: The primary nodes in table 6.1 can provide enough functionality to handle numerous
    use cases. However, understanding behavior trees initially can be daunting. You
    won’t appreciate their underlying complexity until you start using them. Before
    we build some simple trees, we want to look at execution in more detail in the
    next section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1中的主要节点可以提供足够的功能来处理多种用例。然而，最初理解行为树可能会感到困难。你只有在开始使用它们之后才会欣赏到它们背后的复杂性。在我们构建一些简单的树之前，我们希望在下一节中更详细地探讨执行过程。
- en: 6.1.1 Understanding behavior tree execution
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 理解行为树的执行
- en: Understanding how behavior trees execute is crucial to designing and implementing
    behavior trees. Unlike most concepts in computer science, behavior trees operate
    in terms of success and failure. When a node in a behavior tree executes, it will
    return either success or failure; this even applies to conditions and selector
    nodes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 理解行为树的执行方式对于设计和实现行为树至关重要。与计算机科学中的大多数概念不同，行为树以成功和失败为操作术语。当行为树中的节点执行时，它将返回成功或失败；这甚至适用于条件和选择节点。
- en: Behavior trees execute from top to bottom and left to right. Figure 6.2 shows
    the process and what happens if a node fails or succeeds. In the example, the
    AI the tree controls has an apple but no pear. In the first sequence node, a condition
    checks if the AI has an apple. Because the AI doesn’t have an apple, it aborts
    the sequence and falls back to the selector. The selector then selects its next
    child node, another sequence, that checks if the AI has a pear, and because it
    does, the AI eats the apple.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树从上到下、从左到右执行。图6.2显示了执行过程以及节点失败或成功时会发生什么。在示例中，该树控制的AI有一个苹果但没有梨。在第一个序列节点中，一个条件检查AI是否有苹果。因为AI没有苹果，所以它终止序列并回退到选择器。然后选择器选择其下一个子节点，另一个序列，检查AI是否有梨，因为它有，所以AI吃掉了苹果。
- en: '![figure](../Images/6-2.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/6-2.png)'
- en: Figure 6.2 The execution process of a simple behavior tree
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2 简单行为树的执行过程
- en: Behavior trees provide control over how an AI system will execute at a macro
    or micro level. Regarding robotics, behavior trees will typically be designed
    to operate at the micro level, where each action or condition is a small event,
    such as detecting the apple. Conversely, behavior trees can also control more
    macro systems, such as NPCs in games, where each action may be a combination of
    events, like attacking the player.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树提供对人工智能系统在宏观或微观层面执行的控制。在机器人领域，行为树通常被设计为在微观层面运行，其中每个动作或条件都是一个小的事件，例如检测苹果。相反，行为树也可以控制更宏观的系统，例如游戏中的非玩家角色（NPC），其中每个动作可能是一系列事件的组合，如攻击玩家。
- en: For agentic systems, behavior trees support controlling an agent or assistant
    at your chosen level. We’ll explore controlling agents at the task and, in later
    chapters, the planning levels. After all, with the power of LLMs, agents can construct
    their own behavior tree.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于智能体系统，行为树支持在所选级别控制智能体或助手。我们将探讨在任务层面控制智能体，在后面的章节中，我们将探讨规划层面的控制。毕竟，有了LLM的力量，智能体可以构建自己的行为树。
- en: Of course, several other forms of AI control could be used to control agentic
    systems. The next section will examine those different systems and compare them
    to behavior trees.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有其他几种形式的人工智能控制系统可以用来控制智能体系统。下一节将探讨这些不同的系统，并将它们与行为树进行比较。
- en: 6.1.2 Deciding on behavior trees
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 行为树的选择
- en: Numerous other AI control systems have benefits and are worth exploring in controlling
    agentic systems. They can demonstrate the benefits of behavior trees and provide
    other options for specific use cases. The behavior tree is an excellent pattern,
    but it isn’t the only one, and it’s worth learning about others.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他人工智能控制系统都有其优点，值得在控制智能体系统时进行探索。它们可以展示行为树的优势，并为特定用例提供其他选项。行为树是一个优秀的模式，但并非唯一，了解其他模式也是值得的。
- en: Table 6.2 highlights several other systems we may consider for controlling AI
    systems. Each item in the table describes what the method does, its shortcomings,
    and its possible application to agentic AI control.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.2突出了我们可能考虑用于控制人工智能系统的其他几个系统。表中的每一项都描述了该方法的功能、其缺点以及它可能应用于智能体AI控制的应用。
- en: Table 6.2 Comparison of other AI control systems
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.2 其他人工智能控制系统的比较
- en: '| Control name | Description | Shortcomings | Control agentic AI? |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 控制名称 | 描述 | 短处 | 是否适用于控制智能体AI？ |'
- en: '| --- | --- | --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Finite state machine ^a (FSM)  | FSMs model AI using a set of states and
    transitions triggered by events or conditions.  | FSMs can become unwieldy with
    increasing complexity.  | FSMs aren’t practical for agents because they don’t
    scale well.  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 有限状态机 ^a (FSM)  | 有限状态机使用一组状态和由事件或条件触发的转换来模拟人工智能。  | 随着复杂性的增加，有限状态机可能会变得难以控制。  |
    对于智能体来说，有限状态机不实用，因为它们扩展性不好。  |'
- en: '| Decision tree ^b  | Decision trees use a tree-like model of decisions and
    their possible consequences.  | Decision trees can suffer from overfitting and
    lack generalization in complex scenarios.  | Decision trees can be adapted and
    enhanced with behavior trees.  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 决策树 ^b  | 决策树使用树状模型来表示决策及其可能的结果。  | 决策树在复杂场景中可能会出现过度拟合和泛化不足的问题。  | 决策树可以通过行为树进行适应和增强。  |'
- en: '| Utility-based system ^b  | Utility functions evaluate and select the best
    action based on the current situation.  | These systems require careful design
    of utility functions to balance priorities.  | This pattern can be adopted within
    a behavior tree.  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 基于效用的系统 ^b  | 效用函数评估并选择基于当前情况的最佳行动。  | 这些系统需要精心设计效用函数以平衡优先级。  | 这种模式可以在行为树中采用。  |'
- en: '| Rule-based system ^a  | This set of if-then rules define the behavior of
    the AI.  | These systems can become cumbersome with many rules, leading to potential
    conflicts.  | These aren’t very practical when paired with agentic systems powered
    by LLMs.  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 基于规则的系统 ^a  | 这组if-then规则定义了人工智能的行为。  | 当规则众多时，这些系统可能会变得繁琐，并可能导致潜在冲突。  |
    当与由LLM驱动的智能体系统结合时，这些系统不太实用。  |'
- en: '| Planning system ^c  | Planning systems generate a sequence of actions to
    achieve a specific goal using planning algorithms.  | These systems are computationally
    expensive and require significant domain knowledge.  | Agents can already implement
    such patterns on their own as we’ll see in later chapters.  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 计划系统 ^c  | 计划系统使用规划算法生成一系列动作以实现特定目标。  | 这些系统计算成本高昂，需要大量的领域知识。  | 智能体可以在后面的章节中看到，它们可以自行实现这样的模式。  |'
- en: '| Behavioral cloning ^c  | Behavioral cloning refers to learning policies by
    mimicking expert demonstrations.  | This system may struggle with generalization
    to unseen situations.  | This can be incorporated into behavior trees or into
    a specific task.  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 行为克隆^c | 行为克隆指的是通过模仿专家演示来学习策略。 | 这个系统可能难以泛化到未见过的情境。 | 这可以集成到行为树中或特定任务中。 |'
- en: '| Hierarchical Task Network (HTN) ^d  | HTNs decompose tasks into smaller,
    manageable subtasks arranged in a hierarchy.  | These are complex to manage and
    design for very large tasks.  | HTNs allow for better organization and execution
    of complex tasks. This pattern can be used for larger agentic systems.  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 层次化任务网络（HTN）^d | HTNs将任务分解成更小、更易于管理的子任务，并按层次排列。 | 这些对于非常大的任务来说管理和设计都很复杂。
    | HTNs允许更好地组织和执行复杂任务。这种模式可以用于更大的智能体系统。 |'
- en: '| Blackboard system ^b  | These systems feature collaborative problem-solving
    using a shared blackboard for different subsystems.  | These systems are difficult
    to implement and manage communication between subsystems.  | Agentic systems can
    implement similar patterns using conversation or group chats/threads.  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 黑板系统^b | 这些系统使用共享黑板进行不同子系统的协作问题解决。 | 这些系统难以实现，并且管理子系统之间的通信很困难。 | 智能体系统可以通过对话或群聊/线程实现类似的模式。
    |'
- en: '| Genetic algorithm (GA) ^d  | These optimization techniques are inspired by
    natural selection to evolve solutions to solve problems.  | GAs are computationally
    intensive and may not always find the optimal solution.  | GAs have potential
    and could even be used to optimize behavior trees.  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 遗传算法（GA）^d | 这些优化技术受自然选择启发，用于进化解决方案以解决问题。 | 遗传算法计算密集，并且不一定总能找到最优解。 | 遗传算法具有潜力，甚至可以用来优化行为树。
    |'
- en: '| ^a Not practical when considering complex agentic systems ^b Exists in behavior
    trees or can easily be incorporated'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '| ^a 考虑到复杂的智能体系统时不实用 ^b 存在于行为树中或可以轻松集成'
- en: ^c Typically applied at the task or action/condition level
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ^c 通常应用于任务或动作/条件级别
- en: ^d Advanced systems that would require heavy lifting when applied to agents
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ^d 应用到智能体时需要大量工作的高级系统
- en: '|'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: In later chapters of this book, we’ll investigate some of the patterns discussed
    in table 6.2\. Overall, several patterns can be enhanced or incorporated using
    behavior trees as the base. While other patterns, such as FSMs, may be helpful
    for small experiments, they lack the scalability of behavior trees.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续章节中，我们将探讨表6.2中讨论的一些模式。总的来说，可以通过使用行为树作为基础来增强或整合几个模式。而其他模式，如有限状态机（FSMs），虽然可能对小型实验有帮助，但它们缺乏行为树的扩展性。
- en: 'Behavior trees can provide several benefits as an AI control system, including
    scalability. The following list highlights other notable benefits of using behavior
    trees:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树作为人工智能控制系统可以提供几个好处，包括可扩展性。以下列表突出了使用行为树的其它显著好处：
- en: '*Modularity and reusability*—Behavior trees promote a modular approach to designing
    behaviors, allowing developers to create reusable components. Nodes in a behavior
    tree can be easily reused across different parts of the tree or even in different
    projects, enhancing maintainability and reducing development time.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块化和可重用性*——行为树促进了一种模块化的行为设计方法，允许开发者创建可重用组件。行为树中的节点可以轻松地在树的各个部分或甚至在不同项目中重用，从而提高可维护性并减少开发时间。'
- en: '*Scalability*—As systems grow in complexity, behavior trees handle the addition
    of new behaviors more gracefully than other methods, such as FSMs. Behavior trees
    allow for the hierarchical organization of tasks, making it easier to manage and
    understand large behavior sets.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可扩展性*——随着系统复杂性的增加，行为树比其他方法（如FSMs）更优雅地处理新行为的添加。行为树允许对任务进行分层组织，这使得管理和理解大型行为集变得更加容易。'
- en: '*Flexibility and extensibility*—Behavior trees offer a flexible framework where
    new nodes (actions, conditions, decorators) can be added without drastically altering
    the existing structure. This extensibility makes it straightforward to introduce
    new behaviors or modify existing ones to adapt to new requirements.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*灵活性和可扩展性*——行为树提供了一个灵活的框架，其中可以添加新的节点（动作、条件、装饰器）而不会大幅改变现有结构。这种可扩展性使得引入新行为或修改现有行为以适应新要求变得简单直接。'
- en: '*Debugging and visualization*—Behavior trees provide a clear and intuitive
    visual representation of behaviors, which is beneficial for debugging and understanding
    the decision-making process. Tools that support behavior trees often include graphical
    editors that allow developers to visualize and debug the tree structure, making
    it easier to identify and fix problems.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调试和可视化*——行为树提供了清晰直观的行为可视化表示，这对调试和理解决策过程有益。支持行为树的工具通常包括图形编辑器，允许开发者可视化并调试树结构，使其更容易识别和修复问题。'
- en: '*Decoupling of decision logic*—Behavior trees separate the decision-making
    and execution logic, promoting a clear distinction between high-level strategy
    and low-level actions. This decoupling simplifies the design and allows for more
    straightforward modifications and testing of specific behavior parts without affecting
    the entire system.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*决策逻辑解耦*——行为树将决策和执行逻辑分离，促进了高级策略和低级动作之间的清晰区分。这种解耦简化了设计，并允许更直接地修改和测试特定的行为部分，而不会影响整个系统。'
- en: Having made a strong case for behavior trees, we should now consider how to
    implement them in code. In the next section, we look at how to build a simple
    behavior tree, using Python code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在为行为树做了强有力的论证之后，我们现在应该考虑如何在代码中实现它们。在下一节中，我们将探讨如何使用 Python 代码构建一个简单的行为树。
- en: 6.1.3 Running behavior trees with Python and py_trees
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 使用 Python 和 py_trees 运行行为树
- en: Because behavior trees have been around for so long and have been incorporated
    into many technologies, creating a sample demonstration is very simple. Of course,
    the easiest way is to ask ChatGPT or your favorite AI chat tool. Listing 6.1 shows
    the result of using a prompt to generate the code sample and submitting figure
    6.1 as the example tree. The final code had to be corrected for simple naming
    and parameter errors.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于行为树已经存在很长时间，并且被整合到许多技术中，因此创建一个示例演示非常简单。当然，最简单的方法是询问 ChatGPT 或您喜欢的 AI 聊天工具。列表
    6.1 显示了使用提示生成代码示例并将图 6.1 作为示例树提交的结果。最终代码必须进行简单的命名和参数错误修正。
- en: Note  All the code for this chapter can be found by downloading the GPT Assistants
    Playground project at [https://mng.bz/Ea0q](https://mng.bz/Ea0q).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意  本章的所有代码都可以通过下载 GPT 助手游乐场项目在 [https://mng.bz/Ea0q](https://mng.bz/Ea0q) 找到。
- en: Listing 6.1 `first_btree.py`
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.1 `first_btree.py`
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#1 Creates a class to implement an action or condition'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 创建一个类来实现动作或条件'
- en: '#2 Creates the action and condition nodes'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 创建动作和条件节点'
- en: '#3 Adds the nodes to their respective parents'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 将节点添加到相应的父节点'
- en: '#4 Creates the action and condition nodes'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 创建动作和条件节点'
- en: '#5 Creates the whole behavior tree'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 创建整个行为树'
- en: '#6 Executes one step/tick on the behavior tree'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 在行为树上执行一步/一个时间单位'
- en: The code in listing 6.1 represents the behavior tree in figure 6.1\. You can
    run this code as is or alter what the conditions return and then run the tree
    again. You can also change the behavior tree by removing one of the sequence nodes
    from the root selector.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 中的代码代表了图 6.1 中的行为树。您可以按原样运行此代码，或更改条件返回的内容，然后再次运行树。您还可以通过从根选择器中删除一个序列节点来更改行为树。
- en: Now that we have a basic understanding of behavior trees, we can move on to
    working with agents/assistants. Before doing that, we’ll look at a tool to help
    us work with OpenAI Assistants. This tool will help us wrap our first ABTs around
    OpenAI Assistants.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对行为树有了基本的了解，我们可以继续处理代理/助手。在这样做之前，我们将查看一个帮助我们与 OpenAI 助手一起工作的工具。这个工具将帮助我们围绕
    OpenAI 助手包装我们的第一个 ABT。
- en: 6.2 Exploring the GPT Assistants Playground
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 探索 GPT 助手游乐场
- en: For the development of this book, several GitHub projects were created to address
    various aspects of building agents and assistants. One such project, the GPT Assistants
    Playground, is built using Gradio for the interface that mimics the OpenAI Assistants
    Playground but with several extras added.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的开发，创建了几个 GitHub 项目来处理构建代理和助手的各种方面。其中一个项目，GPT 助手游乐场，使用 Gradio 构建了界面，模仿了
    OpenAI 助手游乐场，但增加了几个额外功能。
- en: The Playground project was developed as both a teaching and demonstration aid.
    Inside the project, the Python code uses the OpenAI Assistants API to create a
    chat interface and an agentic system to build and power assistants. There is also
    a comprehensive collection of actions assistants you can use, and you can easily
    add your own actions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: PlayGround项目被开发为一个教学和演示辅助工具。在项目内部，Python代码使用OpenAI助手API创建聊天界面和用于构建和驱动助手的代理系统。同时，还提供了一系列您可以使用的行为助手，并且您可以轻松地添加您自己的行为。
- en: 6.2.1 Installing and running the Playground
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 安装和运行PlayGround
- en: The following listing shows installing and running the Playground project from
    the terminal. There is currently no PyPI package to install.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了从终端安装和运行PlayGround项目的过程。目前还没有PyPI包可以安装。
- en: Listing 6.2 Installing the GPT Assistants Playground
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.2 安装GPT助手PlayGround
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#1 Pulls the source code from GitHub'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从GitHub拉取源代码'
- en: '#2 Changes directory to the project source code folder'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将目录切换到项目源代码文件夹'
- en: '#3 Installs the requirements'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 安装需求'
- en: You can run the application from the terminal or using Visual Studio Code (VS
    Code), with the latter giving you more control. Before running the application,
    you need to set your OpenAI API key through the command line or by creating an
    `.env` file, as we’ve done a few times already. Listing 6.3 shows an example of
    setting the environment variable on Linux/Mac or the Git Bash shell (Windows recommended)
    and running the application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从终端或使用Visual Studio Code（VS Code）运行应用程序，后者给您更多的控制权。在运行应用程序之前，您需要通过命令行或创建一个`.env`文件来设置您的OpenAI
    API密钥，就像我们之前已经做过的几次一样。列表6.3显示了在Linux/Mac或Git Bash shell（推荐Windows）上设置环境变量并运行应用程序的示例。
- en: Listing 6.3 Running the GPT Assistants Playground
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.3 运行GPT助手PlayGround
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#1 Sets your API key as an environment variable'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将您的API密钥设置为环境变量'
- en: '#2 Runs the app from the terminal or via VS Code'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 从终端或通过VS Code运行应用'
- en: Open your browser to the URL displayed (typically `http://127.0.0.1:7860`) or
    what is mentioned in the terminal. You’ll see an interface similar to that shown
    in figure 6.3\. If you’ve already defined the OpenAI Assistants, you’ll see them
    in the Select Assistant dropdown.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的浏览器到显示的URL（通常是 `http://127.0.0.1:7860`）或终端中提到的地址。您将看到一个类似于图6.3所示的界面。如果您已经定义了OpenAI助手，您将在“选择助手”下拉菜单中看到它们。
- en: '![figure](../Images/6-3.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/6-3.png)'
- en: Figure 6.3 The GPT Assistants Playground interface being used to learn math
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3 使用GPT助手PlayGround界面学习数学
- en: If you’ve never defined an assistant, you can create one and choose the various
    options and instructions you need. If you’ve visited the OpenAI Playground, you’ve
    already experienced a similar interface.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从未定义过助手，您可以创建一个并选择您需要的各种选项和指令。如果您访问过OpenAI PlayGround，您已经体验过类似的界面。
- en: GPT vs. an assistant
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: GPT与助手对比
- en: OpenAI defines a GPT as the assistant you can run and use within the ChatGPT
    interface. An assistant can only be consumed through the API and requires custom
    code in most cases. When you run an assistant, you’re charged according to the
    model token usage and any special tools, including the Code Interpreter and files,
    whereas a GPT runs within ChatGPT and is covered by account costs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI将GPT定义为可以在ChatGPT界面中运行和使用的助手。助手只能通过API进行消费，并且在大多数情况下需要自定义代码。当您运行一个助手时，您将根据模型令牌使用情况和任何特殊工具（包括代码解释器和文件）进行收费，而GPT在ChatGPT内部运行，并由账户费用覆盖。
- en: 'The reason for creating a local version of the Playground was an exercise to
    demonstrate the code structure but also provide additional features listed here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 创建PlayGround本地版本的原因是为了演示代码结构，同时也提供以下列出的额外功能：
- en: '*Actions (custom actions)*—Creating your own actions allows you to add any
    functionality you want to an assistant. As we’ll see, the Playground makes it
    very easy to create your own actions quickly.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*行为（自定义行为）*——创建您自己的行为允许您向助手添加任何您想要的功能。正如我们将看到的，PlayGround使创建您自己的行为变得非常简单。'
- en: '*Code runner*—The API does come with a Code Interpreter, but it’s relatively
    expensive ($.03 per run), doesn’t allow you to install your modules, can’t run
    code interactively, and runs slowly. The Playground will enable you to run Python
    code locally in an isolated virtual environment. While not as secure as pushing
    code out to Docker images, it does execute code windowed and out of process better
    than other platforms.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码运行器*——API确实附带了一个代码解释器，但它相对昂贵（每次运行0.03美元），不允许你安装你的模块，不能以交互方式运行代码，并且运行速度较慢。游戏场将使你能够在隔离的虚拟环境中本地运行Python代码。虽然不如将代码推送到Docker镜像安全，但它比其他平台更好地执行了代码窗口化和进程外执行。'
- en: '*Transparency and logging*—The Playground provides for comprehensive capturing
    of logs and will even show how the assistant uses internal and external tools/actions.
    This can be an excellent way to see what the assistant is doing behind the scenes.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*透明度和日志记录*——游戏场提供了全面的日志捕获功能，甚至可以显示助手如何使用内部和外部工具/操作。这可以是一个查看助手幕后所做事情的优秀方式。'
- en: Each of these features is covered in more detail over the next few sections.
    We’ll start with a look at using and consuming actions in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能将在接下来的几节中更详细地介绍。我们将在下一节中开始查看使用和消费操作。
- en: 6.2.2 Using and building custom actions
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 使用和构建自定义操作
- en: Actions and tools are the building blocks that empower agents and assistants.
    Without access to tools, agents are functionless chatbots. The OpenAI platform
    is a leader in establishing many of the patterns for tools, as we saw in chapter
    3.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 操作和工具是赋予代理和助手能力的基石。没有工具的访问权限，代理就变成了无功能的聊天机器人。OpenAI平台在建立许多工具模式方面处于领先地位，正如我们在第3章中看到的。
- en: The Playground provides several custom actions that can be attached to assistants
    through the interface. In this next exercise, we’ll build a simple assistant and
    attach a couple of custom actions to see what is possible.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏场提供了几个可以通过界面附加到助手的自定义操作。在接下来的练习中，我们将构建一个简单的助手并附加几个自定义操作，以查看可以做到什么程度。
- en: Figure 6.4 shows the expanded Actions accordion, which displays many available
    custom actions. Run the Playground from the terminal or debugger, and create a
    new assistant. Then, select the actions shown in the figure. After you’re done
    selecting the actions, scroll to the bottom, and click Add Assistant to add the
    assistant. Assistants need to be created before they can be used.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4显示了扩展的操作手风琴，它显示了许多可用的自定义操作。从终端或调试器运行游戏场，创建一个新的助手。然后，选择图中的操作。在你完成选择操作后，滚动到页面底部，点击添加助手以添加助手。助手在使用之前需要被创建。
- en: '![figure](../Images/6-4.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/6-4.png)'
- en: Figure 6.4 Selecting and using custom actions in the interface
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4 在界面中选择和使用自定义操作
- en: After you create the assistant, you can ask it to list all available assistants.
    Listing the assistants also gives you the IDs required to call the assistant.
    You can also call other assistants and ask them to complete tasks in their area
    of specialization.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建助手之后，你可以要求它列出所有可用的助手。列出助手也会给你调用助手所需的ID。你还可以调用其他助手并要求它们在其专业领域内完成任务。
- en: Adding your custom actions is as simple as adding code to a file and dropping
    it in the right folder. Open the `playground/assistant_actions` folder from the
    main project folder, and you’ll see several files that define the various actions.
    Open the `file_actions.py` file in VS Code, as shown in listing 6.4.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 添加自定义操作就像向文件中添加代码并将其放入正确的文件夹一样简单。从主项目文件夹中打开`playground/assistant_actions`文件夹，你会看到定义各种操作的几个文件。在VS
    Code中打开`file_actions.py`文件，如图6.4所示。
- en: Listing 6.4 `playground/assistant_actions/file_actions.py`
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.4 `playground/assistant_actions/file_actions.py`
- en: '[PRE3]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 This decorator automatically adds the function as an action.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这个装饰器会自动将函数添加为操作。'
- en: '#2 Give your functions clear names that align with the purpose.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 给你的函数起一个清晰且与其目的相符的名字。'
- en: '#3 The description is what the assistant uses to determine the function, so
    document it well.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 描述是助手用来确定函数的内容，所以请好好记录。'
- en: '#4 Generally returns a message stating success or failure'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 通常返回一个表示成功或失败的消息'
- en: You can add any custom action you want by placing the file in the `assistant_actions`
    folder and decorating it with the `agent_action` decorator. Just make sure to
    give the function a good name and enter quality documentation for how the function
    should be used. When the Playground starts up, it loads all the actions in the
    folder that are decorated correctly and have descriptions/documentation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将文件放置在`assistant_actions`文件夹中，并用`agent_action`装饰器装饰它来添加任何您想要的自定义操作。只需确保给函数起一个好名字，并输入关于如何使用函数的良好文档。当Playground启动时，它会加载文件夹中所有正确装饰并带有描述/文档的操作。
- en: It’s that simple. You can add several custom actions as needed. In the next
    section, we’ll look at a special custom action that allows the assistant to run
    code locally.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。您可以根据需要添加多个自定义操作。在下一节中，我们将探讨一个特殊的自定义操作，允许助手在本地运行代码。
- en: 6.2.3 Installing the assistants database
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 安装助手数据库
- en: 'To run several of the examples in this chapter, you’ll need to install the
    assistants database. Fortunately, this can be easily done through the interface
    and just by asking agents. The upcoming instructions detail the process for installing
    the assistants and are taken directly from the GPT Assistants Playground README.
    You can install several of the demo assistants located in the `assistants.db`
    SQLite database:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的多个示例，您需要安装助手数据库。幸运的是，这可以通过界面轻松完成，只需询问代理即可。即将到来的说明详细介绍了安装助手的过程，并直接来自GPT助手Playground的README。您可以从位于`assistants.db`
    SQLite数据库中的`assistants.db`安装几个演示助手：
- en: Create a new assistant, or use an existing assistant.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的助手，或使用现有的助手。
- en: Give the assistant the `create_manager_assistant` action (found under the Actions
    section).
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给助手分配`create_manager_assistant`操作（在操作部分下找到）。
- en: Ask the assistant to create the manager assistant (i.e., “please create the
    manager assistant”), and be sure to name the assistant “Manager Assistant.”
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请助手创建管理助手（即，“请创建管理助手”），并确保将助手的名称命名为“管理助手”。
- en: Refresh your browser to reload the assistants selector.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新您的浏览器以重新加载助手选择器。
- en: Select the new Manager Assistant. This assistant has the instructions and actions
    that will allow it to install assistants from the `assistants.db` database.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新的管理助手。这个助手拥有安装助手的指令和操作，这些操作将允许它从`assistants.db`数据库中安装助手。
- en: Talk to the Manager Assistant to give you a list of assistants to install, or
    just ask the Manager Assistant to install all available assistants.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与管理助手交谈，以获取要安装的助手列表，或者直接请管理助手安装所有可用的助手。
- en: 6.2.4 Getting an assistant to run code locally
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.4 获取本地运行代码的助手
- en: Getting agents and assistants to generate and run executable code has a lot
    of power. Unlike the Code Interpreter, running code locally provides numerous
    opportunities to iterate and tune quickly. We saw this earlier with AutoGen, where
    the agents could keep running the code until it worked as expected.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使代理和助手生成和运行可执行代码具有很大的能力。与代码解释器不同，本地运行代码提供了快速迭代和调整的众多机会。我们之前在AutoGen中看到了这一点，代理可以持续运行代码，直到它按预期工作。
- en: In the Playground, it’s a simple matter to select the custom action `run_code`,
    as shown in figure 6.5\. You’ll also want to choose the `run_shell_command` action
    because it allows the assistant to `pip install` any required modules.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Playground中，选择自定义操作`run_code`非常简单，如图6.5所示。您还希望选择`run_shell_command`操作，因为它允许助手`pip
    install`任何所需的模块。
- en: '![figure](../Images/6-5.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/6-5.png)'
- en: Figure 6.5 Selecting custom actions for the assistant to run Python code
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5 选择助手运行Python代码的自定义操作
- en: You can now ask an assistant to generate and run the code to be sure it works
    on your behalf. Try this out by adding the custom actions and asking the assistant
    to generate and run code, as shown in figure 6.6\. If the code doesn’t work as
    expected, tell the assistant what problems you encountered.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以请助手生成和运行代码，以确保它代表您工作。通过添加自定义操作并请助手生成和运行代码来尝试这一点，如图6.6所示。如果代码没有按预期工作，告诉助手您遇到的问题。
- en: '![figure](../Images/6-6.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/6-6.png)'
- en: Figure 6.6 Getting the assistant to generate and run Python code
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.6 使助手生成和运行Python代码
- en: Again, the Python code running in the Playground creates a new virtual environment
    in a project subfolder. This system works well if you’re not running any operating
    system–level code or low-level code. If you need something more robust, a good
    option is AutoGen, which uses Docker containers to run isolated code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，沙盒中运行的Python代码会在项目子文件夹中创建一个新的虚拟环境。如果你没有运行任何操作系统级别的代码或底层代码，这个系统工作得很好。如果你需要更健壮的解决方案，一个好的选择是AutoGen，它使用Docker容器来运行隔离的代码。
- en: Adding actions to run code or other tasks can make assistants feel like a black
    box. Fortunately, the OpenAI Assistants API allows you to consume events and see
    what the assistant is doing behind the scenes. In the next section, we’ll see
    what this looks like.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 添加运行代码或其他任务的动作可以使助手看起来像一个黑盒。幸运的是，OpenAI助手API允许你消费事件并查看助手在幕后做了什么。在下一节中，我们将看到这看起来是什么样子。
- en: 6.2.5 Investigating the assistant process through logs
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.5 通过日志调查助手进程
- en: OpenAI added a feature into the Assistants API that allows you to listen to
    events and actions chained through tool/action use. This feature has been integrated
    into the Playground, capturing action and tool use when an assistant calls another
    assistant.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI将一个功能添加到了助手API中，允许你监听通过工具/动作使用链式的事件和动作。这个功能已经集成到沙盒中，当助手调用另一个助手时，它会捕获动作和工具的使用。
- en: We can try this by asking an assistant to use a tool and then open the log.
    A great example of how you can do this is by giving an assistant the Code Interpreter
    tool and then asking it to plot an equation. Figure 6.7 shows an example of this
    exercise.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过要求助手使用一个工具并打开日志来尝试这一点。一个很好的例子是给助手提供代码解释器工具，然后要求它绘制一个方程式。图6.7展示了这个练习的一个例子。
- en: '![figure](../Images/6-7.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/6-7.png)'
- en: Figure 6.7 Internal assistant logs being captured
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.7 内部助手日志被捕获
- en: Usually, when the Assistant Code Interpreter tool is enabled, you don’t see
    any code generation or execution. This feature allows you to see all tools and
    actions used by the assistant as they happen. Not only is it an excellent tool
    for diagnostics, but it also provides additional insights into the functions of
    LLMs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当辅助代码解释器工具被启用时，你不会看到任何代码生成或执行。这个功能允许你看到助手在执行过程中使用的所有工具和动作。这不仅是一个出色的诊断工具，而且还能提供对LLM（大型语言模型）功能的额外见解。
- en: We haven’t reviewed the code to do all this because it’s extensive and will
    likely undergo several changes. That being said, if you plan on working with the
    Assistants API, this project is a good place to start. With the Playground introduced,
    we can continue our journey into ABTs in the next section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有审查执行所有这些操作所需的代码，因为代码量很大，并且可能经历几次变化。话虽如此，如果你计划使用助手API，这个项目是一个很好的起点。随着沙盒的引入，我们可以在下一节继续我们的ABT之旅。
- en: 6.3 Introducing agentic behavior trees
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 介绍代理行为树
- en: Agentic behavior trees (ABTs) implement behavior trees on assistant and agent
    systems. The key difference between regular behavior trees and ABTs is that they
    use prompts to direct actions and conditions. Because prompts may return a high
    occurrence of random results, we could also name these trees *stochastic* behavior
    trees, which do exist. For simplicity, we’ll differentiate behavior trees used
    to control agents, referring to them as agentic.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 代理行为树（ABTs）在助手和代理系统中实现行为树。与常规行为树相比，ABTs的关键区别在于它们使用提示来指导动作和条件。由于提示可能会返回高频率的随机结果，我们也可以将这些树称为*随机*行为树，这种树确实存在。为了简单起见，我们将用于控制代理的行为树区分开来，称其为代理行为树。
- en: Next, we’ll undertake an exercise to create an ABT. The finished tree will be
    written in Python but will require the setup and configuration of various assistants.
    We’ll cover how to manage assistants using the assistants themselves.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进行一个练习来创建一个ABT（代理行为树）。完成的树将以Python编写，但需要设置和配置各种助手。我们将介绍如何使用助手本身来管理助手。
- en: 6.3.1 Managing assistants with assistants
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 使用助手管理助手
- en: 'Fortunately, the Playground can help us quickly manage and create the assistants.
    We’ll first install the Manager Assistant, followed by installing the predefined
    assistants. let’s get started with installing the Manager Assistant using the
    following steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，沙盒可以帮助我们快速管理和创建助手。我们首先安装管理助手，然后安装预定义的助手。让我们按照以下步骤开始安装管理助手：
- en: Open Playground in your browser, and create a new simple assistant or use an
    existing assistant. If you need a new assistant, create it and then select it.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开游乐场，创建一个新的简单助理或使用现有的助理。如果你需要一个新助理，创建它然后选择它。
- en: With the assistant selected, open the Actions accordion, and select the `create_
    manager_assistant` action. You don’t need to save; the interface will update the
    assistant automatically.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择助理后，打开操作面板，并选择`create_manager_assistant`操作。你不需要保存；界面将自动更新助理。
- en: 'Now, in the chat interface, prompt the assistant with the following: “Please
    create the manager assistant.”'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在聊天界面中，提示助理以下内容：“请创建经理助理。”
- en: After a few seconds, the assistant will say it’s done. Refresh your browser,
    and confirm that the Manager Assistant is now available. If, for some reason,
    the new assistant isn’t shown, try restarting the Gradio app itself.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，助理会说它已经完成。刷新你的浏览器，并确认经理助理现在可用。如果由于某种原因，新助理没有显示，尝试重新启动Gradio应用程序本身。
- en: 'The Manager Assistant is like an admin that has access to everything. When
    engaging the Manager Assistant, be sure to be specific about your requests. With
    the Manager Assistant active, you can now install new assistants used in the book
    using the following steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 经理助理就像一个可以访问所有内容的管理员。在启用经理助理时，请确保你的请求具体明确。当经理助理处于激活状态时，你可以按照以下步骤安装书中使用的新助理：
- en: Select the Manager Assistant. If you’ve modified the Manager Assistant, you
    can delete it and reinstall it anytime. Although it’s possible to have multiple
    Manager Assistants, it’s not recommended.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择经理助理。如果你修改了经理助理，你可以随时删除并重新安装它。尽管可以拥有多个经理助理，但并不推荐这样做。
- en: 'Ask the Manager Assistant what assistants can be installed by typing the following
    in the chat interface:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在聊天界面中输入以下内容以询问经理助理可以安装哪些助理：
- en: '[PRE4]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '3\. Identify which assistant you want installed when you ask the Manager Assistant
    to install it:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 当你要求经理助理安装助理时，确定你想要安装哪个助理：
- en: '[PRE5]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can manage and install any available assistants using the Playground. You
    can also ask the Manager Assistant to save the definitions of all your assistants
    as JSON:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用游乐场管理并安装任何可用的助理。你还可以要求经理助理将所有助理的定义保存为JSON：
- en: '[PRE6]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Manager Assistant can access all actions, which should be considered unique
    and used sparingly. When crafting assistants, it’s best to keep them goal specific
    and limit the actions to just what they need. This not only avoids giving the
    AI too many decisions but also avoids accidents or mistakes caused by hallucinations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 经理助理可以访问所有操作，这些操作应被视为独特且应谨慎使用。在制作助理时，最好保持它们的目标特定，并将操作限制在它们需要的范围内。这不仅避免了给AI过多的决策，也避免了由幻觉引起的事故或错误。
- en: As we go through the remaining exercises in this chapter, you’ll likely need
    to install the required assistants. Alternatively, you can ask the Manager Assistant
    to install all available assistants. Either way, we look at creating an ABT with
    assistants in the next section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本章剩余的练习时，你可能需要安装所需的助理。或者，你可以要求经理助理安装所有可用的助理。无论哪种方式，我们将在下一节中查看使用助理创建ABT。
- en: 6.3.2 Building a coding challenge ABT
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 构建编码挑战ABT
- en: Coding challenges provide a good baseline for testing and evaluating agent and
    assistant systems. Challenges and benchmarks can quantify how well an agent or
    agentic system operates. We already applied coding challenges to multi-platform
    agents in chapter 4 with AutoGen and CrewAI.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 编码挑战为测试和评估代理和助理系统提供了一个良好的基准。挑战和基准可以量化代理或代理系统的工作效果。我们已经在第4章中应用了编码挑战到多平台代理AutoGen和CrewAI。
- en: For this coding challenge, we’re going a little further and looking at Python
    coding challenges from the Edabit site ([https://edabit.com](https://edabit.com)),
    which range in complexity from beginner to expert. We’ll stick with the expert
    code challenges because GPT-4o and other models are excellent coders. Look at
    the challenge in the next listing, and think about how you would solve it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个编码挑战，我们将更进一步，查看来自Edabit网站（[https://edabit.com](https://edabit.com)）的Python编码挑战，这些挑战的复杂度从入门级到专家级不等。我们将坚持使用专家级代码挑战，因为GPT-4o和其他模型都是优秀的编码者。查看下一列表中的挑战，并思考你会如何解决它。
- en: 'Listing 6.5 Edabit challenge: Plant the Grass'
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.5 Edabit挑战：种植草地
- en: '[PRE7]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can use any challenge or coding exercise you want, but here are a few things
    to consider:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何你想要的挑战或编码练习，但以下是一些需要考虑的事项：
- en: The challenge should be testable with quantifiable assertions (pass/fail).
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挑战应该可以通过可量化的断言（通过/失败）进行测试。
- en: Avoid opening windows when asking for a game, building a website, or using another
    interface. At some point, testing full interfaces will be possible, but for now,
    it’s just text output.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在请求游戏、构建网站或使用其他界面时打开窗口。在某个时候，测试完整界面将是可能的，但到目前为止，它只是文本输出。
- en: Avoid long-running challenges, at least initially. Start by keeping the challenges
    concise and short lived.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免进行长时间运行的挑战，至少最初是这样。开始时，保持挑战简短且生命周期短暂。
- en: Along with any challenge, you’ll also want a set of tests or assertions to confirm
    the solution works. On Edabit, a challenge typically provides a comprehensive
    set of tests. The following listing shows the additional tests provided with the
    challenge.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 任何挑战之外，你还会想要一组测试或断言来确认解决方案的有效性。在Edabit上，一个挑战通常提供一套全面的测试。以下列表显示了与挑战一起提供的附加测试。
- en: Listing 6.6 Plant the Grass tests
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.6 种植草地测试
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The tests will be run as part of a two-step verification to confirm that the
    solution works. We’ll also use the tests and challenges as written, which will
    further test the AI.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将作为两步验证的一部分运行，以确认解决方案的有效性。我们还将使用所写的测试和挑战，这将进一步测试AI。
- en: Figure 6.8 shows the makeup of a straightforward behavior tree that will be
    used to solve various programming challenges. You’ll notice that this ABT uses
    a different assistant for the actions and conditions. For the first step, the
    Python coding assistant (called the Hacker) generates a solution that is then
    reviewed by the coding challenge Judge (called the Judge), which produces a refined
    solution that is verified by a different Python coding assistant (called the Verifier).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8显示了将用于解决各种编程挑战的简单行为树的组成。你会注意到这个ABT为动作和条件使用了不同的助手。对于第一步，Python编码助手（称为黑客）生成一个解决方案，然后由编码挑战裁判（称为裁判）进行审查，产生一个经过改进的解决方案，然后由另一个Python编码助手（称为验证器）进行验证。
- en: '![figure](../Images/6-8.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/6-8.png)'
- en: Figure 6.8 The ABT for the coding challenge
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.8 编码挑战的ABT
- en: Figure 6.8 also shows how each agent converses on which thread. Assistants use
    message threads, similar to a Slack or Discord channel, where all assistants conversing
    on a thread will see all messages. For this ABT, we keep one main conversation
    thread for the Hacker and Judge to share messages, while the Verifier works on
    a separate message thread. Keeping the Verifier on its own thread isolates it
    from the noise of the solution-solving efforts.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8还显示了每个代理在哪个线程上进行交流。助手使用消息线程，类似于Slack或Discord频道，所有在某个线程上交流的助手将看到所有消息。对于这个ABT，我们保留一个主要对话线程供黑客和裁判共享消息，而验证器则在单独的消息线程上工作。将验证器保持在单独的线程上可以将其从解决方案的努力中的噪音中隔离出来。
- en: Now, building the ABT in code is a matter of combining the `py_trees` package
    and the Playground API functions. Listing 6.7 shows an excerpt of code that creates
    each of the action/condition nodes with the assistants and gives them the instructions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在代码中构建ABT是一个将`py_trees`包和Playground API函数结合起来的问题。列表6.7显示了创建每个动作/条件节点并给助手下达指令的代码摘录。
- en: Listing 6.7 `agentic_btree_coding_challenge.py`
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.7 `agentic_btree_coding_challenge.py`
- en: '[PRE9]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '#1 Creates a message thread that will be shared by the Hacker and Judge'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 创建一个将由黑客和裁判共享的消息线程'
- en: '#2 The challenge as shown in the example listing 6.5'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 如示例列表6.5所示，挑战的体现'
- en: '#3 The tests as shown in the example listing 6.6'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 如示例列表6.6所示，测试的体现'
- en: '#4 Creates a message thread that will be shared by the Hacker and Judge'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 创建一个将由黑客和裁判共享的消息线程'
- en: '#5 The challenge as shown in the example listing 6.5'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 如示例列表6.5所示，挑战的体现'
- en: '#6 Creates a message thread that will be shared by the Hacker and Judge'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 创建一个将由黑客和裁判共享的消息线程'
- en: '#7 The challenge as shown in the example listing 6.5'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 如示例列表6.5所示，挑战的体现'
- en: '#8 The tests as shown in the example listing 6.6'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 如示例列表6.6所示，测试的体现'
- en: '#9 Call creates a new message thread'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '#9 调用创建一个新的消息线程'
- en: '#10 The challenge as shown in the example listing 6.5'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '#10 如示例列表6.5所示，挑战的体现'
- en: '#11 The tests as shown in the example listing 6.6'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '#11 如示例列表6.6所示，测试的体现'
- en: '#12 The sleep time can be adjusted up or down as needed and can be used to
    throttle the messages sent to an LLM.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#12 睡眠时间可以根据需要调整上下，并且可以用来限制发送给LLM的消息。'
- en: '#13 The process will continue until the verification succeeds.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '#13 过程将继续，直到验证成功。'
- en: Run the ABT by loading the file in VS Code or using the command line. Follow
    the output in the terminal, and watch how the assistants work through each step
    in the tree.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 VS Code 中加载文件或使用命令行来运行 ABT。在终端中跟踪输出，并观察助手如何通过树中的每个步骤工作。
- en: If the solution fails to be verified at the condition node, the process will
    continue per the tree. Even with this simple solution, you could quickly create
    numerous variations. You could extend the tree with more nodes/steps and subtrees.
    Perhaps you want a team of Hackers to break down and analyze the challenge, for
    example.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在条件节点上解决方案未能通过验证，则过程将按照树继续进行。即使在这个简单解决方案中，您也可以快速创建许多变体。您可以通过添加更多节点/步骤和子树来扩展树。也许您希望一个黑客团队分解和分析挑战，例如。
- en: This example’s work is done mainly with the Playground code, using the helper
    functions `create_assistant_condition` and `create_assistant_action_on_thread`.
    This code uses a couple of classes to integrate the `py_trees` behavior tree code
    and the OpenAI Assistants code wrapped in the Playground. Review the code within
    the project if you want to understand the lower-level details.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的工作主要使用 Playground 代码完成，使用了辅助函数 `create_assistant_condition` 和 `create_assistant_action_on_thread`。此代码使用几个类来集成
    `py_trees` 行为树代码和 OpenAI 助手代码，这些代码被封装在 Playground 中。如果您想了解底层细节，请审查项目中的代码。
- en: 6.3.3 Conversational AI systems vs. other methods
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 对话式 AI 系统与其他方法
- en: We already looked at conversational multi-agent systems in chapter 4 when we
    looked at AutoGen. The ABT can work using a combination of conversations (over
    threads) and other methods, such as file sharing. Having your assistants/agents
    pass files around helps reduce the number of noisy and repetitive thoughts/conversations.
    In contrast, conversational systems benefit from potential emergent behaviors.
    So, using both can help evolve better control and solutions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第 4 章中查看 AutoGen 时，我们已经研究了对话式多智能体系统。ABT 可以通过对话（通过线程）和其他方法（如文件共享）的组合来工作。让您的助手/智能体传递文件有助于减少嘈杂和重复的思想/对话的数量。相比之下，对话式系统从潜在的涌现行为中受益。因此，使用两者可以帮助进化更好的控制和解决方案。
- en: The simple solution in listing 6.7 could be extended to handle more real-world
    coding challenges and perhaps even to work as a coding ABT. In the next section,
    we build a different ABT to handle a different problem.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 中的简单解决方案可以扩展以处理更多现实世界的编码挑战，甚至可能作为编码 ABT 工作。在下一节中，我们将构建一个不同的 ABT 来处理不同的问题。
- en: 6.3.4 Posting YouTube videos to X
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.4 将 YouTube 视频发布到 X
- en: 'In this section’s exercise, we look at an ABT that can do the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的练习中，我们查看一个可以执行以下操作的 ABT：
- en: Search for videos on YouTube for a given topic and return the latest videos.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 YouTube 上特定主题的视频并返回最新视频。
- en: Download the transcripts for all the videos your search provided.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载您搜索提供的所有视频的转录内容。
- en: Summarize the transcripts.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总结转录内容。
- en: Review the summarized transcripts and select a video to write an X (formerly
    Twitter) post about.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查总结的转录内容，并选择一个视频来撰写 X（以前称为 Twitter）帖子。
- en: Write an exciting and engaging post about the video, ensuring it’s less than
    280 characters.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一篇引人入胜的帖子关于视频，确保其字符数少于 280 个。
- en: Review the post and then post it on X.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查帖子，然后在 X 上发布。
- en: Figure 6.9 shows the ABT assembled with each of the different assistants. In
    this exercise, we use a sequence node for the root, and each assistant performs
    a different action. Also, to keep things simple, each assistant interaction will
    always occur in a new thread. This isolates each assistant’s interaction into
    a concise conversation that’s easier to debug if something goes wrong.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 显示了使用每个不同助手组装的 ABT。在这个练习中，我们使用序列节点作为根节点，每个助手执行不同的操作。此外，为了保持简单，每个助手的交互将始终在新的线程中发生。这将每个助手的交互隔离成简短的对话，如果出现问题，更容易调试。
- en: '![figure](../Images/6-9.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/6-9.png)'
- en: Figure 6.9 The YouTube social media ABT
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.9 YouTube 社交媒体 ABT
- en: 6.3.5 Required X setup
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.5 需要的 X 设置
- en: If you plan to run the code in this exercise, you must add your X credentials
    to the `.env` file. The `.env.default` file shows an example of how the credentials
    need to be, as shown in listing 6.8\. You don’t have to enter your credentials.
    This means the last step, posting, will fail, but you can still look at the file
    (`youtube_twitter_post.txt`) to see what was generated.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划运行本练习中的代码，您必须将您的 X 凭证添加到 `.env` 文件中。`.env.default` 文件显示了凭证需要的样子，如列表 6.8
    所示。您不必输入您的凭证。这意味着最后一步，发布，将会失败，但您仍然可以查看文件（`youtube_twitter_post.txt`）以查看生成了什么。
- en: Listing 6.8 Configuring credentials
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.8 配置凭证
- en: '[PRE10]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: YouTube search and spam
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: YouTube搜索和垃圾邮件
- en: If you plan to run this exercise for real and let it post to your X account,
    be aware that YouTube has a bit of a spam problem. The assistants have been configured
    to try to avoid video spam, but some of it may get through. Building a working
    ABT that can wade through videos while avoiding spam has some suitable applications.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算真正运行这个练习并让它发布到您的X账户，请注意YouTube存在一些垃圾邮件问题。助手已被配置为尝试避免视频垃圾邮件，但其中一些可能仍然会通过。构建一个可以在避免垃圾邮件的同时处理视频的ABT具有一些合适的应用。
- en: Listing 6.9 shows just the code for creating the assistant actions. This ABT
    uses three different assistants, each with its own task instructions. Note that
    each assistant has a unique set of instructions defining its role. You can review
    the instructions for each assistant by using the Playground.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.9仅显示了创建助手操作的代码。这个ABT使用了三个不同的助手，每个助手都有自己的任务指令。请注意，每个助手都有定义其角色的独特指令集。您可以通过Playground查看每个助手的指令。
- en: Listing 6.9 `agentic_btree_video_poster_v1.py`
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.9 `agentic_btree_video_poster_v1.py`
- en: '[PRE11]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the code as you normally would, and after a few minutes, a new post will
    appear in the `assistants_output` folder. Figure 6.10 shows an example of a post
    generated using this ABT. Running this ABT to generate more than a few posts a
    day could, and likely will, get your X account blocked. If you’ve configured X
    credentials, you’ll see the post appear on your feed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规方式运行代码，几分钟后，在`assistants_output`文件夹中会出现一个新的帖子。图6.10显示了使用此ABT生成的帖子示例。如果每天运行此ABT生成超过几个帖子，可能会被X账户封禁。如果您已配置X凭证，您将在您的动态中看到帖子。
- en: '![figure](../Images/6-10.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/6-10.png)'
- en: Figure 6.10 A sample X post from the ABT
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.10 ABT的一个示例X帖子
- en: This ABT is shown for demonstration purposes and isn’t for production or long-term
    use. The primary features of this demonstration are to show search and loading
    data, summarization and filtering, then generating new content, and finally highlighting
    multiple custom actions and integrations with APIs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ABT仅用于演示目的，并不适用于生产或长期使用。这个演示的主要功能是展示搜索和加载数据，摘要和过滤，然后生成新内容，最后突出多个自定义操作和与API的集成。
- en: 6.4 Building conversational autonomous multi-agents
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 构建对话式自主多智能体
- en: The conversational aspect of multi-agent systems can drive mechanisms such as
    feedback, reasoning, and emergent behaviors. Driving agents with ABTs that silo
    assistants/agents can be effective for controlling structured processes, as we
    saw in the YouTube posting example. However, we also don’t want to miss out on
    the benefits of conversation across agents/assistants.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 多智能体系统的对话方面可以驱动反馈、推理和涌现行为等机制。使用隔离助手/智能体的ABTs来驱动智能体可以有效地控制结构化过程，正如我们在YouTube发布示例中看到的那样。然而，我们也不愿错过智能体/助手之间对话的好处。
- en: Fortunately, the Playground provides methods to silo or join assistants to conversation
    threads. Figure 6.11 shows how assistants can be siloed or mixed in various combinations
    to threads. Combining silos with conversation provides the best of both patterns.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Playground提供了将助手隔离或加入对话线程的方法。图6.11显示了助手如何以各种组合被隔离或混合到线程中。将隔离与对话相结合提供了两种模式的最佳效果。
- en: '![figure](../Images/6-11.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/6-11.png)'
- en: Figure 6.11 The various layouts of siloed and conversational assistants
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.11 隔离和对话助手的各种布局
- en: We’ll examine a simple but practical exercise to demonstrate the effectiveness
    of the conversational pattern. For the next exercise, we’ll employ two assistants
    in an ABT that converse over the same thread. The next listing shows the tree’s
    construction in code with the respective assistants.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检验一个简单但实用的练习，以展示对话模式的效率。对于下一个练习，我们将使用两个助手在一个ABT中进行对话。下面的列表显示了代码中树的结构以及相应的助手。
- en: Listing 6.10 `agentic_conversation_btree.py`
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.10 `agentic_conversation_btree.py`
- en: '[PRE12]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#1 Creates a message thread for the assistants to share and converse over'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 为助手创建一个消息线程以共享和对话'
- en: '#2 Creates the debug code action with a special assistant'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用特殊助手创建调试代码操作'
- en: '#3 Creates the verification condition to test if the code is fixed or not'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 创建验证条件以测试代码是否已修复'
- en: '#4 The tree will continue to run until the root sequence completes with success.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 树将继续运行，直到根序列成功完成。'
- en: 'Three nodes comprise the tree: the root sequence, the debug code action, and
    the verify fix condition. Because the tree’s root is a sequence, the two assistants
    will continue to work one after another until they both return with success. Both
    assistants converse on the same thread and yet are controlled in a manner that
    provides constant feedback.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 树由三个节点组成：根序列、调试代码动作和验证修复条件。因为树的根是一个序列，所以两个助手将依次工作，直到它们都返回成功。两个助手在同一个线程上对话，但以提供持续反馈的方式进行控制。
- en: Run the exercise by loading the file in VS Code, or execute it directly from
    the command line. The example code has a few minor bugs and problems that the
    assistants will work through to fix. After the ABT completes running successfully,
    you can open the `assistants_output/fixed_bug.py` file and verify the results
    are all good.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在VS Code中加载文件或直接从命令行执行来运行练习。示例代码有几个小错误和问题，助手将解决这些问题以修复。在ABT成功运行后，您可以打开`assistants_output/fixed_bug.py`文件并验证结果是否都很好。
- en: We’ve now seen a couple of ABTs in action and understand the nuances of using
    silos or conversations. The following section will teach you some techniques for
    building your own ABTs.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了几个ABT的实际应用，并了解了使用隔离或对话的细微差别。下一节将向您介绍一些构建自己的ABT的技术。
- en: 6.5 Building ABTs with back chaining
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 使用追溯法构建ABT
- en: 'Back chaining is a method derived from logic and reasoning used to help build
    behavior trees by working backward from the goal. This section will use the back
    chaining process to construct an ABT that works to achieve the goal. The following
    list provides a description of the process in more detail:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 追溯法是一种从目标逆向推理的逻辑和推理方法，用于通过从目标反向构建行为树。本节将使用追溯过程构建一个旨在实现目标的ABT。以下列表详细描述了该过程：
- en: '*Identify goal behavior*. Start with the behavior you want the agent to perform.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*确定目标行为*。从您希望智能体执行的行为开始。'
- en: '*Determine the required actions*. Identify the actions that lead to the goal
    behavior.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*确定所需动作*。识别导致目标行为的动作。'
- en: '*Identify the conditions*. Determine the conditions that must be met for each
    action to succeed.'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*确定条件*。确定每个动作要成功必须满足的条件。'
- en: '*Determine the mode of communication*. Determine how the assistants will pass
    on information. Will the assistants be siloed or converse over threads, or is
    a combination of patterns better?'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*确定通信模式*。确定助手如何传递信息。助手将被隔离还是通过线程进行对话，或者两种模式的组合更好？'
- en: '*Construct the tree.* Start by building the behavior tree from the goal behavior,
    adding nodes for actions and conditions recursively until all necessary conditions
    are linked to known states or facts.'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*构建树*。从目标行为开始构建行为树，递归地添加动作和条件节点，直到所有必要的条件都链接到已知状态或事实。'
- en: Behavior trees typically use a pattern called the *blackboard* to communicate
    across nodes. Blackboards, like those in `py_trees`, use a key/value store to
    save information and make it accessible across nodes. It also provides for several
    controls, such as limiting access to specific nodes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树通常使用称为*黑板*的模式在节点之间进行通信。黑板，如`py_trees`中的那些，使用键/值存储来保存信息并使其跨节点可访问。它还提供了一些控制，例如限制对特定节点的访问。
- en: We deferred to using files for communication because of their simplicity and
    transparency. At some point, agentic systems are expected to consume much more
    information and in different formats than those designed for blackboards. Blackboards
    must either become more sophisticated or be integrated with file storage solutions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的简单性和透明性，我们推迟使用文件进行通信。在某个时候，智能体系统预计将消耗比为黑板设计的更多信息，并且以不同的格式。黑板必须变得更加复杂或与文件存储解决方案集成。
- en: 'Let’s build an ABT using back chaining. We could tackle a variety of goals,
    but one interesting and perhaps meta goal is to build an ABT that helps build
    assistants. So let’s first present our goal as a statement “Create an assistant
    that can help me do {task}”:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用追溯法构建一个ABT。我们可以解决各种目标，但一个有趣且可能是元目标的是构建一个有助于构建助手的ABT。所以，让我们首先将我们的目标陈述为“创建一个可以帮助我完成{任务}的助手”：
- en: '*Required actions*: (working backwards)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*所需动作*：（逆向工作）'
- en: Create an assistant.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个助手。
- en: Verify the assistant.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证助手。
- en: Test the assistant.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试助手。
- en: Name the assistant.
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名助手。
- en: Give the assistant the relevant instructions.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给助手提供相关指令。
- en: '*Identified condition:*'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*已识别的条件*：'
- en: Verify the assistant.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证助手。
- en: '*Determine communication patterns*: To keep things interesting, we’ll run all
    assistants on the same message thread.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确定沟通模式*：为了保持趣味性，我们将所有助手放在同一个消息线程上。'
- en: '*Construct the tree*: To construct the tree, let’s first reverse the order
    of actions and mark each of the element’s actions and conditions accordingly:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建树*：为了构建树，让我们首先反转行动的顺序，并相应地标记每个元素的行动和条件：'
- en: (action) Give the assistant relevant instructions to help a user with a given
    task.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: （行动）为助手提供相关指令，以帮助用户完成给定任务。
- en: (action) Name the assistant.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: （行动）命名助手。
- en: (action) Test the assistant.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: （行动）测试助手。
- en: (condition) Verify the assistant.
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: （条件）验证助手。
- en: (action) Create the assistant.
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: （行动）创建助手。
- en: Of course, the simple solution to building the tree now is to ask ChatGPT or
    an otherwise capable model. The result of asking ChatGPT to make the tree is shown
    in the next listing. You could also work the tree out independently and perhaps
    introduce other elements.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在构建树的简单解决方案是询问 ChatGPT 或其他有能力的模型。询问 ChatGPT 制作树的成果将在下一列表中展示。你也可以独立工作并可能引入其他元素。
- en: Listing 6.11 ABT for building an assistant
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.11 构建助手的 ABT
- en: '[PRE13]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: From this point, we can start building the tree by iterating over each action
    and condition node and determining what instructions the assistant needs. This
    can also include any tools and custom actions, including ones you may need to
    develop. On your first pass, keep the instructions generic. Ideally, we want to
    create as few assistants as necessary.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，我们可以通过迭代每个行动和条件节点来构建树，并确定助手需要哪些指令。这也可以包括任何工具和自定义行动，包括你可能需要开发的。在第一次遍历时，保持指令通用。理想情况下，我们希望创建尽可能少的助手。
- en: 'After determining the assistant, tools, and actions for each assistant and
    for which task, you can try to generalize things further. Think about where it
    may be possible to combine actions and reduce the number of assistants. It’s better
    to start evaluating with insufficient assistants than with too many. However,
    be sure to maintain the proper divisions of work as tasks: for example, testing
    and verification are best done with different assistants.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定每个助手的助手、工具和行动以及任务后，你可以尝试进一步概括。考虑一下在哪里可能可以合并行动并减少助手的数量。与过多助手相比，开始评估时助手不足更好。然而，务必保持适当的工作分工：例如，测试和验证最好由不同的助手完成。
- en: 6.6 Exercises
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 练习
- en: 'Complete the following exercises to improve your knowledge of the material:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下练习以提高你对材料的了解：
- en: '*Exercise 1*—Creating a Travel Planner ABT'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*练习 1*—创建旅行规划器 ABT'
- en: '*Objective *—Build an agentic behavior tree (ABT) to plan a travel itinerary
    using assistants.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标*—构建一个使用助手规划旅行行程的代理行为树（ABT）。'
- en: '*Tasks*:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务*：'
- en: Set up the GPT Assistants Playground on your local machine.
  id: totrans-273
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的本地机器上设置 GPT 助手游乐场。
- en: 'Create an ABT to plan a travel itinerary. The tree should have the following
    structure:'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个规划旅行行程的 ABT。该树应具有以下结构：
- en: 'Action: Use the Travel assistant to gather information about potential destinations.'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动：使用旅行助手收集有关潜在目的地的信息。
- en: 'Action: Use the Itinerary Planner to create a day-by-day travel plan.'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动：使用行程规划器创建每日旅行计划。
- en: 'Condition: Verify the completeness and feasibility of the itinerary using another
    Travel Assistant.'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件：使用另一个旅行助手验证行程的完整性和可行性。
- en: Implement and run the ABT to create a complete travel itinerary.
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施并运行 ABT 以创建完整的旅行行程。
- en: '*Exercise 2*—Building an ABT for Customer Support Automation'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*练习 2*—为客服自动化构建 ABT'
- en: '*Objective *—Create an ABT that automates customer support responses using
    assistants.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标*—创建一个自动客户支持回复的 ABT。'
- en: '*Tasks*:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务*：'
- en: Set up the GPT Assistants Playground on your local machine.
  id: totrans-282
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的本地机器上设置 GPT 助手游乐场。
- en: 'Create an ABT with the following structure:'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有以下结构的 ABT：
- en: 'Action: Use the Customer Query Analyzer assistant to categorize customer queries.'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动：使用客户查询分析助手对客户查询进行分类。
- en: 'Action: Use the Response Generator assistant to draft responses based on the
    query categories.'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动：使用响应生成助手根据查询类别起草回复。
- en: 'Action: Use the Customer Support assistant to send the responses to customers.'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动：使用客服助手向客户发送回复。
- en: Implement and run the ABT to automate the process of analyzing and responding
    to customer queries.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施并运行 ABT 以自动化分析和响应客户查询的过程。
- en: '*Exercise 3*—Managing Inventory with an ABT'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*练习 3*—使用 ABT 管理库存'
- en: '*Objective *—Learn how to create and manage inventory levels using an ABT.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标*—学习如何使用ABT创建和管理库存水平。'
- en: '*Tasks*:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务*：'
- en: Set up the GPT Assistants Playground on your local machine.
  id: totrans-291
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的本地机器上设置GPT助手游乐场。
- en: 'Create an ABT that manages inventory for a retail business:'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个管理零售业务库存的ABT：
- en: 'Action: Use the Inventory Checker assistant to review current stock levels.'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动：使用库存检查助手审查当前库存水平。
- en: 'Action: Use the Order assistant to place orders for low-stock items.'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动：使用订单助手为库存低的物品下订单。
- en: 'Condition: Verify that orders have been placed correctly and update inventory
    records.'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件：验证订单是否已正确下订单，并更新库存记录。
- en: Implement and run the ABT to manage inventory dynamically.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过执行和运行ABT，动态管理库存。
- en: '*Exercise 4*—Creating a Personal Fitness Trainer ABT'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*练习4*—创建个人健身教练ABT'
- en: '*Objective *—Create an ABT that provides personalized fitness training plans
    using assistants.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标*—创建一个使用助手提供个性化健身训练计划的ABT。'
- en: '*Tasks*:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务*：'
- en: Set up the GPT Assistants Playground on your local machine.
  id: totrans-300
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的本地机器上设置GPT助手游乐场。
- en: 'Create an ABT to develop a personalized fitness plan:'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个ABT以开发个性化的健身计划：
- en: 'Action: Use the Fitness Assessment assistant to evaluate the user’s current
    fitness level.'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动：使用健康评估助手评估用户的当前健康水平。
- en: 'Action: Use the Training Plan Generator to create a custom fitness plan based
    on the assessment.'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动：使用训练计划生成器根据评估创建自定义健身计划。
- en: 'Condition: Verify the plan’s suitability and safety using another Fitness assistant.'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件：使用另一个健身助手验证计划的适宜性和安全性。
- en: Implement and run the ABT to generate and validate a personalized fitness training
    plan.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过执行和运行ABT，生成和验证个性化的健身训练计划。
- en: '*Exercise 5*—Using Back Chaining to Build a Financial Advisor ABT'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*练习5*—使用反向链接构建财务顾问ABT'
- en: '*Objective *—Apply back chaining to construct an ABT that provides financial
    advice and investment strategies.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标*—应用反向链接构建提供财务建议和投资策略的ABT。'
- en: '*Tasks*:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务*：'
- en: Set up the GPT Assistants Playground on your local machine.
  id: totrans-309
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的本地机器上设置GPT助手游乐场。
- en: 'Define the following goal: “Create an assistant that can provide financial
    advice and investment strategies.”'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义以下目标：“创建一个可以提供财务建议和投资策略的助手。”
- en: Using back chaining, determine the actions and conditions needed to achieve
    this goal.
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反向链接确定实现此目标所需的行为和条件。
- en: Implement and run the ABT to generate a comprehensive financial advisory service
    by back chaining the construction of the base actions and conditions for the tree.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过反向链接构建基础动作和条件，实现ABT的执行和运行，以生成全面的财务咨询服务。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Behavior trees are a robust and scalable AI control pattern, first introduced
    in robotics by Rodney A. Brooks. They are widely used in gaming and robotics for
    their modularity and reusability.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为树是一种强大且可扩展的AI控制模式，首次由罗德尼·A·布鲁克斯在机器人领域引入。它们因其模块化和可重用性而在游戏和机器人领域得到广泛应用。
- en: 'The primary nodes in behavior trees are the selector, sequence, condition,
    action, decorator, and parallel nodes. Selectors are like “or” blocks: sequence
    executes nodes in sequence, condition tests the state, action does the work, decorator
    is a wrapper, and parallel nodes allow for dual execution.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为树中的主要节点是选择器、序列、条件、动作、装饰器和并行节点。选择器类似于“或”块：序列按顺序执行节点，条件测试状态，动作执行工作，装饰器是一个包装器，并行节点允许双重执行。
- en: Understanding the execution flow of behavior trees can be critical to designing,
    building, and operating them to provide control for making clear decision-making
    paths.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解行为树的执行流程对于设计、构建和操作它们以提供清晰的决策路径控制至关重要。
- en: The advantages of behavior trees include modularity, scalability, flexibility,
    debugging ease, and decoupling of decision logic, making behavior trees suitable
    for complex AI systems.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为树的优势包括模块化、可扩展性、灵活性、调试容易性和决策逻辑解耦，使行为树适用于复杂的AI系统。
- en: Setting up and running a simple behavior tree in Python requires correctly naming
    and documenting custom nodes.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中设置和运行一个简单的行为树需要正确命名和记录自定义节点。
- en: The GPT Assistants Playground project is a Gradio-based interface that mimics
    the OpenAI Assistants Playground with additional features for teaching and demonstrating
    ABTs.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPT助手游乐场项目是一个基于Gradio的界面，它模仿了OpenAI助手游乐场，并增加了教学和演示ABT的功能。
- en: The GPT Assistants Playground allows for creating and managing custom actions,
    which is essential for building versatile assistants.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPT助手游乐场允许创建和管理自定义操作，这对于构建多功能助手至关重要。
- en: ABTs control agents and assistants by using prompts to direct actions and conditions
    for assistants. ABTs use the power of LLMs to create dynamic and autonomous systems.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ABTs通过使用提示来指导助手的行为和条件，控制代理和助手。ABTs利用LLMs（大型语言模型）的力量来创建动态和自主的系统。
- en: Back chaining is a method for constructing behavior trees by working backward
    from the goal behavior. This process involves identifying required actions, conditions,
    and communication patterns, and then constructing the tree step by step.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追溯链式是构建行为树的一种方法，它从目标行为逆向工作。这个过程包括识别所需的行为、条件和通信模式，然后逐步构建树形结构。
- en: Agentic systems benefit from siloed and conversation patterns for communicating
    between entities. ABTs can benefit from combining siloed and conversational assistants
    to use structured processes and emergent behaviors.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理系统从实体间的隔离和对话模式中受益，用于通信。ABTs可以通过结合隔离和对话助手来受益，以使用结构化流程和涌现行为。
