- en: '5 Reading Python code: Part 2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 阅读Python代码：第 2 部分
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Repeating code the required number of times using loops
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环重复所需的代码次数
- en: Using indentation to tell Python which code goes together
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缩进来告诉 Python 哪些代码属于一组
- en: Building dictionaries to store pairs of associated values
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建字典来存储相关值的对
- en: Setting up files to read and process data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置文件以读取和处理数据
- en: Using modules to work in new domains
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块在新的领域工作
- en: 'In chapter 4, we explored five Python features that you’re going to see all
    the time as you continue in your programming journey: functions, variables, conditionals
    (`if` statements), strings, and lists. You need to know those features to read
    code, and we explained why being able to read code is important whether or not
    we’re using Copilot.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中，我们探讨了你在继续你的编程之旅时将经常看到的五个 Python 特性：函数、变量、条件语句（`if` 语句）、字符串和列表。你需要了解这些特性来阅读代码，我们也解释了为什么无论是否使用
    Copilot，能够阅读代码都很重要。
- en: We’ll continue in this chapter with five more Python features, which will round
    out our top 10\. As in chapter 4, we’ll do this through a combination of our own
    explanations, explanations from Copilot, and experimenting at the Python prompt.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续介绍五个更多的 Python 特性，这将使我们的前 10 个特性更加完整。与第 4 章一样，我们将通过我们自己的解释、Copilot
    的解释以及在 Python 提示符下的实验来做到这一点。
- en: '5.1 Top 10 programming features you need to know: Part 2'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 你需要知道的 10 个编程特性：第 2 部分
- en: 'This section details the next five of the top 10 programming features you need
    to know. Let’s continue where we left off in the previous chapter with feature
    number 6: loops.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节详细介绍了你需要知道的下一个五个顶级编程特性。让我们从上一章留下的地方继续，即第 6 个特性：循环。
- en: '5.1.1 #6\. Loops'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '5.1.1 #6\. 循环'
- en: 'A loop allows the computer to repeat the same block of code as many times as
    needed. If a single one of our top 10 programming features exemplifies why computers
    are so useful for helping us get work done, it’s this one. Without the ability
    to loop, our programs would generally execute in order, line by line. Sure, they
    could still call functions and use `if` statements to make decisions, but the
    amount of work a program does would be proportional to the amount of code we write.
    Not so with loops: a single loop can process thousands or millions of values with
    ease.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 循环允许计算机根据需要重复执行相同的代码块。如果我们前 10 个编程特性中的任何一个能体现为什么计算机对我们完成工作如此有用，那就是这个特性。如果没有循环的能力，我们的程序通常会按顺序逐行执行。当然，它们仍然可以调用函数并使用
    `if` 语句来做出决定，但程序完成的工作量将与我们编写的代码量成比例。但循环不是这样：一个循环可以轻松处理成千上万的值。
- en: 'There are two types of loops: `for` loops and `while` loops. Generally speaking,
    we use a `for` loop whenever we know how many times we need the loop to run, and
    we use a `while` loop when we don’t. For example, in chapter 3, our `best_word`
    function (reproduced as listing 5.1) used a `for` loop because we know how many
    times we want the loop to run: once for each word in `word_list`! But in `get_strong_password`,
    which we’ll see again in listing 5.4, we used a `while` loop, because we have
    no idea how many bad passwords the user is going to type before they type a strong
    one. We’ll start with `for` loops and then move on to `while` loops.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的循环：`for` 循环和 `while` 循环。一般来说，当我们知道循环需要运行多少次时，我们使用 `for` 循环；当我们不知道时，我们使用
    `while` 循环。例如，在第 3 章中，我们的 `best_word` 函数（如列表 5.1 所示）使用了一个 `for` 循环，因为我们知道循环需要运行多少次：对
    `word_list` 中的每个单词运行一次！但在 `get_strong_password` 中，我们将在列表 5.4 中再次看到它，我们使用了一个 `while`
    循环，因为我们不知道用户在输入一个强密码之前会输入多少个坏密码。我们将从 `for` 循环开始，然后转向 `while` 循环。
- en: Listing 5.1 `best_word` function from chapter 3
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1 来自第 3 章的 `best_word` 函数
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**#1 This is an example of a for loop.**  **A `for` loop allows us to access
    each value in a string or list. Let’s try it with a string first:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1 这是一个 for 循环的例子。** **`for` 循环允许我们访问字符串或列表中的每个值。让我们先从一个字符串开始尝试：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#1 This repeats the indented code one time for each character of string s.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这将重复缩进的代码，每次对应字符串 s 中的一个字符。'
- en: '#2 Because “vacation” has eight letters, this code will run eight times.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 因为“vacation”有八个字母，所以这段代码将运行八次。'
- en: Notice that we don’t need an assignment statement for `char`. That’s because
    it’s a special variable called a loop variable that’s automatically managed by
    the `for` loop. `char` stands for character, and it’s an extremely popular name
    that people use for the loop variable. The `char` variable automatically gets
    assigned each character of the string. When talking about a loop, we often use
    the word *iteration* to refer to the code that executes each time through the
    loop. Here, for example, we would say that on the first iteration,`char` refers
    to `v`; on the second iteration, it refers to `a`; and so on. Notice also, just
    like for functions and `if` statements, we have indentation for the code that
    makes up the loop. We have only one line of code in the body of this loop, but
    just like for functions and `if` statements, we could have more.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要为 `char` 赋值语句。这是因为它是一个特殊的变量，称为循环变量，它由 `for` 循环自动管理。`char` 代表字符，这是人们用来命名循环变量的一个非常流行的名字。`char`
    变量会自动分配字符串中的每个字符。在谈论循环时，我们经常使用单词 *迭代* 来指代每次通过循环执行的代码。例如，我们可以说在第一次迭代中，`char` 指的是
    `v`；在第二次迭代中，它指的是 `a`；依此类推。注意，就像函数和 `if` 语句一样，我们为构成循环的代码有缩进。在这个循环的主体中，我们只有一行代码，但就像函数和
    `if` 语句一样，我们也可以有更多。
- en: Let’s see an example of a `for` loop on a list this time (listing 5.2), demonstrating
    that we can process each value of a list like we process each value of a string.
    We’ll also throw two lines of code into the loop instead of just one, to demonstrate
    how that works too.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个 `for` 循环在列表上的示例（列表 5.2），演示我们可以像处理字符串的每个值一样处理列表的每个值。我们还会在循环中放入两行代码，而不是一行，以演示这是如何工作的。
- en: Listing 5.2 Example using a `for` loop
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2 使用 `for` 循环的示例
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**#1 1st is a list, so this is a for loop on a list.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1 第一个是一个列表，所以这是一个列表上的 for 循环。'
- en: '#2 This code runs on each iteration.**  **The code in listing 5.2 is just one
    way to loop through a list. The approach of `for` `animal` `in` `lst` assigns
    the variable `animal` to the next value in the list each time through the loop.
    Alternatively, you could use an index to access each element of the list. To do
    that, we need to learn about the built-in `range` function.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这段代码在每次迭代时运行。**  **列表 5.2 中的代码只是循环遍历列表的一种方式。`for` `animal` `in` `lst` 的方法在每次通过循环时将变量
    `animal` 赋值为列表中的下一个值。作为替代，您可以使用索引来访问列表中的每个元素。为此，我们需要了解内置的 `range` 函数。'
- en: 'The `range` function gives you numbers within a range. We can provide a starting
    number and an ending number, and it will produce the range that goes from the
    starting number up to, but not including, the ending number. To see the numbers
    that `range` produces, we need to put the `list` function around it. Here’s an
    example of using `range`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 函数可以给你一个范围内的数字。我们可以提供一个起始数字和一个结束数字，它将生成从起始数字开始，但不包括结束数字的范围。要查看 `range`
    生成的数字，我们需要在它周围放置 `list` 函数。以下是一个使用 `range` 的示例：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 Produces the range from 3 to 8 (not 3 to 9!)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 生成从 3 到 8 的范围（不是 3 到 9！）'
- en: Notice that it starts with the value `3` and includes all values between `3`
    and `8`. That is, it includes all numbers from the starting value `3` up to, but
    not including, the ending value `9`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它从值 `3` 开始，包括 `3` 和 `8` 之间的所有值。也就是说，它包括从起始值 `3` 到，但不包括，结束值 `9` 的所有数字。
- en: 'Now, how is `range` going to help us write a loop? Well, rather than hard-coding
    numbers like 3 and 9 in the range, we can include the length of a string or list,
    like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`range` 如何帮助我们编写循环呢？嗯，而不是在范围中硬编码像 3 和 9 这样的数字，我们可以包括字符串或列表的长度，如下所示：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 Start at 0 and go up to, but not including, the length of 1st.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从 0 开始，直到但不包括 1st 的长度。'
- en: Notice that the range values here are 0, 1, 2, 3, which are the valid indices
    of our `lst` list! We can therefore use `range` to control a `for` loop, and that
    will give us access to each valid index from the string or list.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里的范围值是 0、1、2、3，这是我们的 `lst` 列表的有效索引！因此，我们可以使用 `range` 来控制 `for` 循环，这将使我们能够访问字符串或列表中的每个有效索引。
- en: We can use `range` to perform the same task in listing 5.2\. See listing 5.3
    for the new code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `range` 在列表 5.2 中执行相同的任务。查看列表 5.3 以获取新代码。
- en: Listing 5.3 Loop example using for `loop` and `range`
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3 使用 `for` 循环和 `range` 的循环示例
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**#1 for loop using the range function'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1 使用 `range` 函数的 for 循环'
- en: '#2 Indexing into the list using the index variable**  **We’ve used a variable
    named `index` here, but you’ll also often see people use just `i` for simplicity.
    That variable will be given the value `0` for the first iteration of the loop,
    `1` for the second, `2` for the third, and `3` for the last iteration. It stops
    at `3` because the length of the list is 4, and `range` stops one before that.
    Using indexing into the list, the code grabs the first element, then the second,
    then the third, and then the fourth, using the increasing indices. We could have
    also written the `for` loop without the `0`; `range` will assume we want the values
    between `0` and the value provided, like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用索引变量对列表进行索引**  **在这里，我们使用了一个名为`index`的变量，但你也经常会看到人们为了简单起见只使用`i`。该变量将在循环的第一次迭代时被赋予`0`的值，第二次迭代时为`1`，第三次迭代时为`2`，最后一次迭代时为`3`。它停止在`3`，因为列表的长度是4，而`range`在它之前停止。使用列表的索引，代码获取第一个元素，然后是第二个，然后是第三个，最后是第四个，使用递增的索引。我们也可以不写`0`来编写`for`循环；`range`将假设我们想要从`0`到提供的值的值，如下所示：'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '#1 With one argument, range assumes that we want to start at 0.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用一个参数时，`range`假设我们要从0开始。'
- en: 'We’ll stop here with `for` loops. But we’re not done with loops yet because
    there’s another type of loop that we need to talk about: the `while` loop.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里就停止`for`循环的讨论。但我们还没有结束循环的讨论，因为还有另一种类型的循环需要我们讨论：`while`循环。
- en: We use a `while` loop when we don’t know how many times to loop. A nice example
    of this situation is in our `get_strong_password` function from chapter 3\. We’ve
    reproduced that code here as listing 5.4.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们不知道要循环多少次时，我们会使用`while`循环。这种情况的一个很好的例子是在第3章的`get_strong_password`函数中。我们在这里将其代码作为列表5.4重现。 '
- en: Listing 5.4 `get_strong_password` function from chapter 3
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.4 第3章的`get_strong_password`函数
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 Keeps looping while the password isn’t strong'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 当密码不够强大时持续循环'
- en: 'We have no idea how many passwords the user is going to type until they type
    a strong one. Will it be on the 1st try, 2nd try, or 50th try? Who knows. That’s
    why we need a `while` loop: it ensures that the user is asked again and again
    until they provide a strong password.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道用户会输入多少个密码，直到他们输入一个强大的密码。是第一次尝试、第二次尝试，还是第50次尝试？谁知道。这就是为什么我们需要一个`while`循环：它确保用户会不断被要求输入，直到他们提供一个强大的密码。
- en: To write a `while` loop, we follow `while` with a Boolean condition. If it’s
    `True`, Python runs one iteration of the loop. If, after that iteration, that
    Boolean condition is still `True`, then it runs another iteration. It keeps doing
    that until the condition is `False`, at which point the loop terminates.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个`while`循环，我们需要在`while`后面跟一个布尔条件。如果它是`True`，Python将运行循环的一次迭代。如果在那次迭代之后，那个布尔条件仍然是`True`，那么它将运行另一次迭代。它将一直这样做，直到条件变为`False`，此时循环终止。
- en: Now, we have enough information to make sense of the code for our `get_strong_`
    `password` function. By looking at the code, we can see that it begins by using
    the `input` function to ask the user for a password. Then, there’s a `while` loop.
    This loop continues as long as the password isn’t a strong password. The Boolean
    condition `not` `is_strong_password(password)` is equivalent to writing it as
    `is_strong_password` `(password)` `==` `False`. To avoid an infinite loop and
    to ask the user to try again, we have another use of `input` inside of the loop.
    We need the call of `input` above the loop to get the first try from the user.
    Without that, the `password` variable wouldn’t exist, and the `while` loop line
    would give an error because it wouldn’t have a `password` value to pass to the
    `is_strong_password` function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了足够的信息来理解我们的`get_strong_password`函数的代码。通过查看代码，我们可以看到它首先使用`input`函数来要求用户输入密码。然后，有一个`while`循环。这个循环会一直持续，直到密码不是一个强大的密码。布尔条件`not
    is_strong_password(password)`等同于写作`is_strong_password(password) == False`。为了避免无限循环并要求用户再次尝试，我们在循环内部又使用了另一个`input`。我们需要在循环上面的`input`调用，以从用户那里获取第一次尝试。如果没有这个，`password`变量就不会存在，而`while`循环行会出错，因为它没有`password`值传递给`is_strong_password`函数。
- en: 'Don’t forget that we can ask Copilot for an explanation of this code, using
    what we learned in chapter 4, section 4.2\. This is useful whenever you’re feeling
    that you aren’t quite understanding what the code is doing or how it works. Here’s
    the explanation we received from Copilot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，我们可以向Copilot请求对这个代码的解释，使用我们在第4章第4.2节学到的知识。当你觉得你并不完全理解代码正在做什么或它是如何工作时，这很有用。这是我们从Copilot那里收到的解释：
- en: This Python code defines a function named `get_strong_password`. The purpose
    of this function is to interactively prompt the user to enter a password and keep
    asking until the user provides a password that is considered strong. The criteria
    for what constitutes a strong password is not defined in this function but is
    determined by another function named `is_strong_password`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这段Python代码定义了一个名为`get_strong_password`的函数。这个函数的目的是交互式地提示用户输入密码，并持续询问，直到用户提供一个被认为是强密码的密码。构成强密码的标准在此函数中未定义，而是由另一个名为`is_strong_password`的函数确定。
- en: The function begins by asking the user to enter a password using Python’s built-in
    `input` function. The entered password is then stored in the variable `password`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 函数开始时使用Python的内置`input`函数提示用户输入密码。然后，输入的密码存储在变量`password`中。
- en: Next, the function enters a `while` loop. The condition for this loop is `not`
    `is_strong_` `password(password)`. This means that the loop will continue to execute
    as long as the `is_strong_password` function returns `False` when called with
    the current password. In other words, the loop will keep running until the user
    enters a password that is considered strong.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，函数进入一个`while`循环。这个循环的条件是`not` `is_strong_` `password(password)`。这意味着只要`is_strong_password`函数在用当前密码调用时返回`False`，循环就会继续执行。换句话说，循环会一直运行，直到用户输入一个被认为是强密码的密码。
- en: Inside the loop, the function again prompts the user to enter a password. The
    new password replaces the previous one stored in the `password` variable. If this
    new password is still not strong, the loop will continue to prompt the user.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，函数再次提示用户输入密码。新密码替换了之前存储在`password`变量中的旧密码。如果这个新密码仍然不够强，循环会继续提示用户。
- en: Once the user enters a password that is considered strong (i.e., `is_strong_password`
    `(password)` returns `True`), the `while` loop condition becomes `False` and the
    loop ends. The function then returns the strong password entered by the user.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户输入了一个被认为是强密码（即`is_strong_password`(password)返回`True`），`while`循环的条件变为`False`，循环结束。然后函数返回用户输入的强密码。
- en: This function is a good example of using a `while` loop to repeatedly prompt
    the user for input until the input meets certain criteria. However, the actual
    criteria for a strong password are not defined in this function and would need
    to be implemented in the `is_strong_password` function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是使用`while`循环反复提示用户输入直到输入满足某些条件的一个很好的例子。然而，强密码的实际标准并未在此函数中定义，需要在`is_strong_password`函数中实现。
- en: This explanation is a very good description of the function and matches the
    description that we just gave! It contains useful general Python information as
    well, including a reminder in the final paragraph of why exactly we’re using a
    `while` loop. The explanation also mentions that we need the `is_strong_password`
    function to tell us whether a password is strong or not; we didn’t highlight that
    function, which is why Copilot is telling us that we need to implement it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解释非常详细地描述了函数，与我们刚刚给出的描述相匹配！它还包含了一些有用的Python通用信息，包括在最后一段中提醒我们为什么我们使用`while`循环。解释还提到我们需要`is_strong_password`函数来告诉我们密码是否强大；我们没有强调这个函数，这就是为什么Copilot告诉我们需要实现它。
- en: Copilot explanations can be wrong
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Copilot解释可能会出错
- en: We chose the previous Copilot explanation because it was the best answer from
    Copilot after we asked it to explain the code three times. One of the answers
    it gave us sounded quite plausible, until it started talking about functions that
    didn’t exist. We believe the explanations can be helpful as a learning aid if
    you run it multiple times and look for common ideas, but a principal goal of this
    chapter is to give you the tools you need to understand when it makes mistakes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择之前的Copilot解释，因为它是在我们要求Copilot解释代码三次后给出的最佳答案。它给出的其中一个答案听起来相当可信，直到它开始谈论不存在的函数。我们相信，如果您多次运行并寻找共同的想法，这些解释可以作为学习辅助工具很有帮助，但本章的主要目标是为您提供理解何时出错所需的工具。
- en: We encourage you to use Copilot explanations going forward and, if you’re interested,
    ask Copilot to explain any code from prior chapters that you’re still curious
    about. Again, these explanations can be wrong, so you should ask Copilot for several
    explanations to limit your reliance on a single erroneous explanation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您继续使用Copilot解释，如果您感兴趣，可以要求Copilot解释您仍然好奇的任何前几章的代码。再次提醒，这些解释可能会出错，因此您应该要求Copilot提供多个解释以减少对单个错误解释的依赖。
- en: As with anything related to AI coding assistants right now, they’re going to
    mess up. But we’ve given the explanation here because we see this Copilot feature
    as a potentially powerful teaching resource now and that will become even more
    true as Copilot improves.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就像现在与任何与 AI 编码助手相关的事情一样，它们可能会出错。但我们在这里给出解释，因为我们认为 Copilot 的这个功能现在是一个潜在的有力教学资源，而且随着
    Copilot 的改进，这一点将变得更加真实。
- en: We’re supposed to use a `while` loop in these kinds of situations where we don’t
    know how many iterations there will be. But we *can* use a`while` loop even when
    we know how many iterations there are. For example, we can use a `while` loop
    to process the characters in a string or the values in a list. We sometimes see
    Copilot do this in the code that it generates, even though a `for` loop would
    have been a better choice. For example, we can use a `while` loop to process the
    animals in our earlier `animals` list, as in the following listing. It’s more
    work, though!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们不知道迭代次数的情况下，我们应该使用 `while` 循环。但即使我们知道迭代次数，我们也可以使用 `while` 循环。例如，我们可以使用 `while`
    循环来处理字符串中的字符或列表中的值。我们有时会在 Copilot 生成的代码中看到它这样做，尽管使用 `for` 循环可能更好。例如，我们可以使用 `while`
    循环来处理我们之前提到的 `animals` 列表中的动物，如下所示。但这会多做一些工作！
- en: Listing 5.5 Loop example using a `while` loop
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5 使用 `while` 循环的循环示例
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 len tells us the length of the string and is the number of iterations we
    want.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 `len` 函数告诉我们字符串的长度，这也是我们想要的迭代次数。'
- en: '#2 It’s a common human error to leave this out!'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这是常见的错误，很多人都会犯这个错误！'
- en: Without the `index` `+=` `1`, we would never increase the index through the
    string, and we’d print out the information for the first value over and over.
    That’s called an *infinite loop*. If you think back to how we wrote `for` loops,
    you’ll find that we didn’t have to manually increase any index variables. For
    such reasons, many programmers prefer to use `for` loops when they can. We don’t
    have to manually keep track of any index in a `for` loop, so we automatically
    avoid certain kinds of indexing problems and infinite loops.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 `index` `+=` `1`，我们就永远不会增加字符串中的索引，我们会不断地输出第一个值的详细信息。这被称为*无限循环*。如果你回想一下我们是如何编写
    `for` 循环的，你会发现我们不必手动增加任何索引变量。出于这些原因，许多程序员在可能的情况下更喜欢使用 `for` 循环。我们不必在 `for` 循环中手动跟踪任何索引，因此我们自动避免了某些类型的索引问题和无限循环。
- en: '5.1.2 #7\. Indentation'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '5.1.2 #7\. 缩进'
- en: 'Indentation is critical in Python code, because Python uses it to determine
    which lines of code go together. That’s why, for example, we always indent all
    the lines of code inside a function, the various portions of an `if` statement,
    and the code for a `for` or `while` loop. It’s not just nice formatting: if we
    get the indentation wrong, then we get the code wrong. For example, let’s say
    that we want to ask the user for the current hour and then output some text based
    on whether it’s morning, afternoon, or evening:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 代码中，缩进至关重要，因为 Python 使用它来确定哪些代码行属于一起。这就是为什么，例如，我们总是在函数内部的代码行、`if` 语句的各个部分以及
    `for` 或 `while` 循环的代码中进行缩进。这不仅仅是格式化得更好：如果我们缩进错误，那么代码也会出错。例如，假设我们想要询问用户当前的小时，然后根据是早上、下午还是晚上输出一些文本：
- en: If it’s morning, we want to output “Good morning!” and “Have a nice day.”
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是早上，我们想要输出“早上好！”和“祝您有个愉快的一天。”
- en: If it’s afternoon, we want to output “Good afternoon!”
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是下午，我们想要输出“下午好！”
- en: If it’s evening, we want to output “Good evening!” and “Have a good night.”
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是晚上，我们想要输出“晚上好！”和“祝您有个美好的夜晚。”
- en: 'Take a look at the following code we’ve written and try to spot the problem
    with the indentation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们编写的以下代码，并尝试找出缩进的问题：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '#1 This line is not indented.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这一行没有缩进。'
- en: 'The problem is the last line: it’s not indented, but it should be! Because
    it’s not indented, we’ll output `Have` `a` `good` `night.` regardless of which
    hour the user types in. We need to indent it so that it’s part of the `else` portion
    of the `if` statement, ensuring that it only executes when it’s evening.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于最后一行：它没有缩进，但它应该缩进！因为它没有缩进，所以无论用户输入哪个小时，我们都会输出 `Have` `a` `good` `night.`。我们需要缩进它，使其成为
    `if` 语句的 `else` 部分的一部分，确保它只在晚上执行。
- en: Whenever we write code, we need to use multiple levels of indentation to express
    which pieces of code are associated with functions, `if` statements, loops, and
    so on. For example, when we write a function header, we need to indent all the
    code associated with that function below the function header. Some languages use
    brackets (e.g., {}) to show this, but Python just indents. If you’re already in
    the body of a function (one indent) and write a loop, then you’ll have to indent
    again (two indents) for the body of the loop, and so forth.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时编写代码，我们都需要使用多级缩进来表达哪些代码片段与函数、`if`语句、循环等相关联。例如，当我们编写函数头时，我们需要将函数头下面的所有相关代码缩进。一些语言使用括号（例如{}）来显示这一点，但Python只是缩进。如果你已经在函数体（一个缩进）中编写了一个循环，那么你将需要再次缩进（两个缩进）以缩进循环体，依此类推。
- en: Looking back at our functions from chapter 3, we can see this in action. For
    example, in our `larger` function (reprinted as listing 5.6), the whole body of
    the function is indented, but there’s further indentation on the `if` portion
    and the `else` portion of the `if` statement.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾第3章中的函数，我们可以看到这一点。例如，在我们的`larger`函数（重新打印为列表5.6）中，整个函数体都是缩进的，但在`if`语句的`if`部分和`else`部分有进一步的缩进。
- en: Listing 5.6 Function to determine the larger of two values
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.6 比较两个值大小的函数
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#1 This shows a single indent for the body of the function.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这显示了函数体的单级缩进。'
- en: '#2 This shows a double indent for the body of the function and the body of
    the if statement.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这显示了函数体和if语句体的双重缩进。'
- en: '#3 This shows a single indent for the body of the function.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 这显示了函数体的单级缩进。'
- en: '#4 This shows a double indent for the body of the function and the body of
    the else statement.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 这显示了函数体和else语句体的双重缩进。'
- en: 'Next, consider our `get_strong_password` function that we looked at in listing
    5.4 earlier: as usual, everything in the function is indented, but there’s further
    indentation for the body of the `while` loop.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑我们之前在列表5.4中查看的`get_strong_password`函数：通常，函数中的所有内容都是缩进的，但`while`循环体的缩进更深。
- en: There are even more levels of indentation in the first version of our `num_points`
    function (reproduced here from chapter 3 as listing 5.7). That’s because, inside
    of the `for` loop through each character of the word, we have an `if` statement.
    Each piece of the `if` statement, as we’ve learned, needs to be indented, leading
    to the extra level of indentation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们`num_points`函数的第一版中（此处从第3章的列表5.7中复制），甚至还有更多级别的缩进。这是因为，在遍历单词每个字符的`for`循环内部，我们有一个`if`语句。正如我们所学的，`if`语句的每一部分都需要缩进，从而导致额外的缩进级别。
- en: Listing 5.7 `num_points` function
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.7 `num_points`函数
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 This is indented to be inside the function.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这是为了位于函数内部而缩进的。'
- en: '#2 This is indented again to be inside the for loop.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这再次缩进，以便位于for循环内部。'
- en: '#3 This is indented yet again to be inside the if statement.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 这再次缩进，以便位于if语句内部。'
- en: There’s additional indentation in `is_strong_password` too (reproduced from
    chapter 3 as listing 5.8), but that’s only to spread out one super-long line of
    code across multiple lines. Notice that the lines end with `\`, which is the character
    that allows us to continue a line of code on the next line.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`is_strong_password`函数中也有额外的缩进（此处从第3章的列表5.8中复制），但这只是为了将一条超长的代码行扩展到多行。注意，这些行以`\`结尾，这是我们可以在下一行继续代码行的字符。
- en: Listing 5.8 `is_strong_password` function
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.8 `is_strong_password`函数
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#1 The line ends with a backslash to continue the statement.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这行以反斜杠结尾，以继续语句。'
- en: '#2 The indent isn’t required but is useful for visually laying out the single
    return statement.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 缩进不是必需的，但有助于在视觉上布局单行返回语句。'
- en: Similarly, there’s some further indentation in our second version of `num_points`
    (reproduced from chapter 3 as listing 5.9), but that’s just to spread the dictionary
    out over multiple lines to make it more readable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在我们的`num_points`函数的第二版中（此处从第3章的列表5.9中复制）也有一些进一步的缩进，但这只是为了将字典扩展到多行，使其更易于阅读。
- en: Listing 5.9 `num_points` alternative solution
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.9 `num_points`的替代解决方案
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#1 We’re allowed to write a dictionary value over multiple lines.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们允许将字典值写为多行。'
- en: '#2 The indent isn’t required but is useful for visually laying out the dictionary.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 缩进不是必需的，但有助于在视觉上布局字典。'
- en: 'Indentation makes a huge difference on what our programs ultimately do. For
    example, let’s compare putting two consecutive loops versus nesting one in the
    other using indentation. Here are two loops in a row:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进对程序最终执行的结果有很大影响。例如，让我们比较使用连续的两个循环与使用缩进嵌套一个循环在另一个循环中使用的情况。这里有连续的两个循环：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#1 This is the first loop.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这是第一个循环。'
- en: '#2 This is the second loop (happens after the first loop).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这是第二个循环（在第一个循环之后发生）。'
- en: 'That caused us to get the same output twice because we looped two separate
    times through the countries list. Now, if instead we nest the loops, this happens:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致我们得到了相同的输出两次，因为我们两次分别遍历了国家列表。现在，如果我们嵌套循环，情况如下：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#1 This is the first loop.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这是第一个循环。'
- en: '#2 This is the nested loop inside of the first loop.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这是第一个循环中的嵌套循环。'
- en: '#3 print is nested in the second loop, which is nested in the first loop.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 `print`是在第二个循环中嵌套的，而第二个循环又嵌套在第一个循环中。'
- en: We’ve used different variable names, `country1` and `country2`, for each `for`
    loop, so that we can refer to both. On the first iteration of the `country1` loop,
    `country1` refers to `Canada`. On the first iteration of the `country2` loop,
    `country2` refers to `Canada` as well. That’s why the first line of output is
    `Canada` `Canada`. Did you expect the next line of output after that to be `USA`
    `USA`? That isn’t what happens! Instead, the `country2` loop moves on to its next
    iteration, but the `country1` loop doesn’t move yet. The `country1` loop only
    moves ahead when the `country2` loop is complete. That’s why we get `Canada` `USA`
    and `Canada` `Japan` before the `country1` loop finally moves on to its second
    iteration. When one loop is inside of another loop, this is called *nested loops.*
    In general, when there’s nesting, the inner loop (`for` `country2` `in` `countries`)
    will complete all of its steps before the outer loop (`for` `country1` `in` `countries`)
    moves on to its next step, which, in turn, will restart the inner loop.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个`for`循环使用了不同的变量名，`country1`和`country2`，这样我们就可以引用它们。在`country1`循环的第一次迭代中，`country1`指的是`加拿大`。在`country2`循环的第一次迭代中，`country2`同样指的是`加拿大`。这就是为什么第一行输出是`加拿大`
    `加拿大`。你期望下一行输出是`USA` `USA`吗？但这并不是发生的事情！相反，`country2`循环继续到它的下一次迭代，但`country1`循环还没有移动。`country1`循环只有在`country2`循环完成后才会向前移动。这就是为什么我们在`country1`循环最终移动到第二次迭代之前得到了`加拿大`
    `USA`和`加拿大` `日本`。当一个循环在另一个循环内部时，这被称为*嵌套循环*。一般来说，当有嵌套时，内循环（`for` `country2` `in`
    `countries`）将在外循环（`for` `country1` `in` `countries`）移动到它的下一步之前完成所有步骤，然后外循环将重新启动内循环。
- en: If you see a loop nested inside another loop, chances are good that the loops
    are being used to process two-dimensional data. Two-dimensional data is organized
    into rows and columns, of the kind you might see in a table (e.g., table 5.1).
    This kind of data is really common in computing because it includes basic spreadsheet
    data such as CSV files, images such as photos or a single frame of video, or the
    computer screen.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到嵌套在另一个循环内部的循环，那么很可能这些循环正在用于处理二维数据。二维数据组织成行和列，就像你在表格中看到的那样（例如，表5.1）。这种数据在计算机中非常常见，因为它包括基本的工作表数据，如CSV文件，图像如照片或视频的单帧，或者计算机屏幕。
- en: In Python, we can store two-dimensional data using a list where the values themselves
    are other lists. Each sublist in the overall list is one row of data, and each
    row has a value for each column. For example, say we had some data about the figure
    skating medals won at the 2018 Winter Olympics, as shown in table 5.1.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以使用一个列表来存储二维数据，其中值本身是其他列表。列表中的每个子列表是整体列表中的一行数据，每行都有一个列值。例如，假设我们有关于2018年冬季奥运会花样滑冰奖牌的一些数据，如表5.1所示。
- en: Table 5.1 Medals in the 2018 Winter Olympics
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.1 2018年冬季奥运会奖牌
- en: '| Nation | Gold | Silver | Bronze |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 国家 | 金牌 | 银牌 | 铜牌 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Canada  | 2  | 0  | 2  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 加拿大 | 2 | 0 | 2 |'
- en: '| OAR  | 1  | 2  | 0  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| OAR | 1 | 2 | 0 |'
- en: '| Japan  | 1  | 1  | 0  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 日本 | 1 | 1 | 0 |'
- en: '| China  | 0  | 1  | 0  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 中国 | 0 | 1 | 0 |'
- en: '| Germany  | 1  | 0  | 0  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 德国 | 1 | 0 | 0 |'
- en: 'We could store this as a list, with one country per row:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些存储为一个列表，每行一个国家：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice that our list of lists is just storing the numeric values, and we can
    find a value in the list of lists by referring to its row and column (e.g., Japan’s
    gold medal corresponds to the row at index 2 and the column at index 0). We can
    use an index to get a complete row of data:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的列表列表只是存储了数值，我们可以通过引用其行和列来找到列表列表中的值（例如，日本的金牌对应于索引为2的行和索引为0的列）。我们可以使用索引来获取完整的数据行：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '****#1 This is row 0 (first row).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '****#1 这是第一行（第一行）。'
- en: '#2 This is row 1 (second row).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这是第一行（第二行）。'
- en: '#3 This is the last row.****  ****If we do a `for` loop on this list, we get
    each complete row, one row at a time:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 这是最后一行。****  ****如果我们对这个列表执行`for`循环，我们将逐行获取每个完整的行：'
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '#1 The for loop gives us one value of the list at a time (i.e., one sublist
    at a time).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 `for`循环一次给我们列表中的一个值（即一次子列表）。'
- en: 'If we want just a specific value from the medals list (not a whole row), we
    have to index twice:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想从奖牌列表中获取特定的值（而不是整个行），我们必须索引两次：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#1 This is row 0, column 0.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这是第一行，第一列。'
- en: '#2 This is row 0, column 1.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这是第一行，第一列。'
- en: '#3 This is row 1, column 0.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 这是第一行，第一列。'
- en: Suppose we want to loop through each value individually. To do that, we can
    use nested `for` loops. To help us keep track of exactly where we are, we’ll use
    `range` `for` loops so that we can print out the current row and column numbers
    in addition to the value stored there.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要逐个遍历每个值。为了做到这一点，我们可以使用嵌套`for`循环。为了帮助我们确切地跟踪我们的位置，我们将使用`range` `for`循环，这样我们就可以打印出当前的行和列数字，以及存储在该处的值。
- en: The outer loop will go through the rows, so we need to control it using `range`
    `(len(medals))`. The inner loop will go through the columns. How many columns
    are there? Well, the number of columns is the number of values in one of the rows,
    so we can use `range(len(medals[0]))` to control this loop.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 外层循环将遍历行，因此我们需要使用`range` `(len(medals))`来控制它。内层循环将遍历列。有多少列？嗯，列的数量是行中值的数量，因此我们可以使用`range(len(medals[0]))`来控制这个循环。
- en: 'Each line of output will provide three numbers: the row coordinate, the column
    coordinate, and the value (number of medals) at that row and column. Here’s the
    code and output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每行输出将提供三个数字：行坐标、列坐标以及在该行和列的值（奖牌数量）。以下是代码和输出：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#1 Loops through the rows'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 遍历行'
- en: '#2 Loops through the columns for the current row'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 遍历当前行的列'
- en: Notice how the row stays constant for the first three lines of output, during
    which the column varies from 0 to 2\. That’s how we work our way through the first
    row. Only then does the row increase to 1, at which point we complete the work
    for columns 0 to 2 on this new row.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在输出的前三行中，行保持不变，而列从0到2变化。这就是我们如何遍历第一行的方式。只有在行增加到1之后，我们才完成对这一新行上列0到2的工作。
- en: Nested loops give us a systematic way to loop through each value in a two-dimensional
    list. You’ll see them frequently when dealing with two-dimensional data in general,
    such as images, board games, and spreadsheets.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套循环为我们提供了一种系统地遍历二维列表中每个值的系统方法。在处理二维数据时，你经常会看到它们，例如图像、棋盘游戏和电子表格。
- en: '5.1.3 #8\. Dictionaries'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '5.1.3 #8\. 字典'
- en: Remember that each value in Python has a specific type. There are a lot of different
    types because there are many kinds of values that we might want to use! We’ve
    talked about using numbers to work with numeric values, Booleans to work with
    `True`/`False` values, strings to work with text, and lists to work with a sequence
    of other values such as numbers or strings.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Python中的每个值都有一个特定的类型。由于我们可能想要使用许多不同类型的值，因此存在许多不同的类型！我们已经讨论了使用数字来处理数值，布尔值来处理`True`/`False`值，字符串来处理文本，以及列表来处理其他值（如数字或字符串）的序列。
- en: 'There’s one more Python type that shows up often, and it’s called a *dictionary.*
    When we talk about a dictionary in Python, we don’t mean a list of words and their
    definitions. In Python, a dictionary is a useful way of storing data whenever
    you need to keep track of associations between data. For example, imagine that
    you wanted to know which words are used most often in your favorite book. You
    could use a dictionary to map each word to the number of times it’s used. That
    dictionary would probably be huge, but a small version of such a dictionary might
    look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，还有一个经常出现的类型，它被称为*字典*。当我们谈论Python中的字典时，我们并不是指单词及其定义的列表。在Python中，字典是一种在需要跟踪数据之间的关联时非常有用的存储数据的方式。例如，想象一下，如果你想知道你最喜欢的书中使用最频繁的单词。你可以使用字典将每个单词映射到其使用的次数。这样一个字典可能非常大，但这样一个字典的小版本可能看起来像这样：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each entry in the dictionary maps a word to its frequency. For example, we can
    tell from this dictionary that the word *DNA* shows up 11 times and that the word
    *Taxxon* shows up 13 times. The words here (*DNA*, *acquire*, *Taxxon*, etc.)
    are referred to as *keys,* and the frequencies (11, 11, 13, etc.) are referred
    to as *values**.* So, a dictionary maps each key to its value. We’re not allowed
    to have duplicate keys, but as shown here with the two `11` values, having duplicate
    values is no problem.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的每个条目将一个单词映射到其频率。例如，我们可以从这个字典中得知单词*DNA*出现了11次，而单词*Taxxon*出现了13次。这里的单词（*DNA*，*acquire*，*Taxxon*等）被称为*键*，而频率（11，11，13等）被称为*值*。因此，字典将每个键映射到其值。我们不允许有重复的键，但正如这里所示的两个`11`值，有重复的值是没有问题的。
- en: We saw a dictionary in chapter 2 (listing 2.1) that stored each quarterback’s
    name and their associated number of passing yards. In chapter 3, we saw a dictionary
    again in our second solution for `num_points` (reproduced earlier in listing 5.9).
    There, the dictionary mapped each letter to the number of points awarded for using
    that letter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第2章（列表2.1）中看到了一个字典，它存储了每个四分卫的名字和他们相关的传球码数。在第3章中，我们又看到了一个字典，这是我们的第二个`num_points`解决方案（在列表5.9中较早重现）。在那里，字典将每个字母映射到使用该字母所获得的分数。
- en: 'Just like for strings and lists, dictionaries have methods that you can use
    to interact with them. Here are some methods operating on our `freq` dictionary:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字符串和列表一样，字典也有你可以用来与之交互的方法。以下是一些在`freq`字典上操作的方法：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**#1 Gets all the keys'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1 获取所有键'
- en: '#2 Gets all the values'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 获取所有值'
- en: '#3 Gets rid of key and associated value**  **You can also use the index notation
    to access the value for a given key:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 删除键及其关联的值**  **你也可以使用索引符号来访问给定键的值：'
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 Gets values associated with the key “DNA”'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 获取与键“DNA”关联的值'
- en: 'Dictionaries, like lists, are mutable. This means that we can change the keys
    and values in a dictionary, which is useful for modeling data that changes over
    time. We can use indexing to change a value. The value associated with `''morph''`
    is currently `41`. Let’s change it to `6`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 字典，就像列表一样，是可变的。这意味着我们可以更改字典中的键和值，这对于模拟随时间变化的数据很有用。我们可以使用索引来更改值。与`'morph'`关联的值目前是`41`。让我们将其更改为`6`：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 Changes value associated with key “morph” to 6'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将与键“morph”关联的值更改为6'
- en: 'Our `freq` dictionary allows us to start from whatever word we want and find
    its frequency. More generally, a dictionary allows us to go from *key to value.*
    However, it doesn’t allow us to easily go in the opposite direction, from value
    to key. If we wanted to do that, we’d need to produce the opposite dictionary—for
    example, one whose keys are frequencies and whose values are lists of words with
    those frequencies. That would enable us to answer questions such as the following:
    which words have a frequency of exactly 5? Which words have the minimum or maximum
    frequency of all?'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`freq`字典允许我们从任何我们想要的单词开始，并找到它的频率。更普遍地说，字典允许我们从*键到值*进行转换。然而，它不允许我们轻松地朝相反的方向转换，从值到键。如果我们想这样做，我们需要生成相反的字典——例如，一个键是频率，值是具有这些频率的单词列表的字典。这将使我们能够回答以下问题：哪些单词的频率正好是5？哪些单词的频率是所有单词中的最小或最大？
- en: 'As with strings and lists, we can use a loop to process the information in
    a dictionary as well. A `for` loop gives us the dictionary keys, and we can use
    indexing to get the associated value for each key:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字符串和列表一样，我们也可以使用循环来处理字典中的信息。`for`循环给我们字典的键，我们可以使用索引来获取每个键的关联值：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*#1 Loops through each key in the freq dictionary'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*#1 遍历freq字典中的每个键'
- en: '#2 Uses the key (word) and associated value (freq[word])*  *### 5.1.4 #9\.
    Files'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用键（单词）和关联值（freq[word])*  *### 5.1.4 #9\. 文件'
- en: It’s often the case that we’ll want to work with datasets that exist in files.
    For example, in chapter 2, we worked with a file of NFL stats to determine the
    most effective quarterbacks. Using files is common for other data science tasks
    as well. For example, if you’re plotting information about earthquakes around
    the world or determining whether two books are written by the same author, you’ll
    need to work with those datasets, and typically those datasets will be stored
    in files.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要处理存在于文件中的数据集。例如，在第2章中，我们使用NFL统计数据文件来确定最有效的四分卫。使用文件对于其他数据科学任务也很常见。例如，如果你正在绘制关于全球地震的信息或确定两本书是否由同一作者撰写，你需要处理这些数据集，通常这些数据集会存储在文件中。
- en: In chapter 2, we worked with a file called nfl_offensive_stats.csv. Make sure
    that this file is in your current program directory because we’ll use that file
    now to further understand some of the code we used in chapter 2.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章中，我们处理了一个名为 nfl_offensive_stats.csv 的文件。请确保这个文件在你的当前程序目录中，因为我们现在将使用这个文件来进一步理解第
    2 章中使用的某些代码。
- en: 'The first step in working with data from a file is to use Python’s `open` function
    to open the file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文件中的数据的第一步是使用 Python 的 `open` 函数打开文件：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You’ll sometimes see Copilot add an `r` as a second argument here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时会看到 Copilot 在这里添加一个 `r` 作为第二个参数：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: But we don’t need the `r`; the `r` just means that we want to read from the
    file, but that’s the default anyway if we don’t specify it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不需要 `r`；`r` 只意味着我们想要从文件中读取，但如果我们没有指定，这已经是默认的。
- en: 'We’ve used an assignment statement to assign that open file to a variable named
    `nfl_file`. Now, we can use `nfl_file` to access the contents of the file. An
    open file is a Python type, just like numbers and strings and all of the other
    types you’ve seen to this point. As such, there are methods that we can call to
    interact with the file. One method is `readline`, which gives us the next line
    of the file as a string. We’ll use it now to get the first line of our open file,
    but don’t worry about the line itself because it’s super long with tons of information
    about columns we won’t end up using:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用赋值语句将打开的文件分配给名为 `nfl_file` 的变量。现在，我们可以使用 `nfl_file` 来访问文件的内容。一个打开的文件是 Python
    类型，就像数字和字符串以及到目前为止你看到的所有其他类型一样。因此，我们可以调用一些方法来与文件交互。其中一个方法是 `readline`，它以字符串的形式给出文件的下一行。我们现在将使用它来获取打开文件的第一行，但不用担心这一行本身，因为它非常长，包含大量我们最终不会使用的列信息：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '#1 Reads the line from the file'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从文件中读取一行'
- en: 'It’s not easy to pull individual values out of a messy string like that. So,
    one of the first things we tend to do with such a line is split it up into its
    individual column data. We can do that using the string `split` method. That method
    takes a separator as an argument and splits the string into a list by using that
    separator:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从这样的混乱字符串中提取单个值并不容易。因此，我们首先倾向于做的是将这样的行拆分成其单个列数据。我们可以使用字符串 `split` 方法来做这件事。该方法接受一个分隔符作为参数，并使用该分隔符将字符串拆分成一个列表：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '#1 Splits the string using a comma (,) as a separator'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用逗号 (,) 作为分隔符拆分字符串'
- en: 'Now we can look at individual column names:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查看单个列名：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '#1 The space at the end of the word is in the original dataset, but no other
    column headers have a space.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 单词末尾的空格在原始数据集中存在，但其他列标题没有空格。'
- en: 'That first line of the file that we’re looking at isn’t a real data line—it’s
    just the header that tells us the name of each column. The next time we do `readline`,
    we get the first real line of data:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在查看的文件的第一行不是真实的数据行——它只是告诉我们每个列名的标题。下次我们调用 `readline` 时，我们得到第一行真实的数据：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Moving one line at a time like this is fine for exploring what’s in a file,
    but eventually, we’ll probably want to process the whole thing. To do so, we can
    use a `for` loop on the file. It’ll give us back one line on each iteration, which
    we can process in any way we like. Once we’re finished with a file, we should
    call `close` on it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 逐行移动这种方式适合探索文件中的内容，但最终我们可能想要处理整个文件。要做到这一点，我们可以在文件上使用一个 `for` 循环。它会在每次迭代时给我们一行，我们可以以任何我们喜欢的方式处理它。一旦我们完成了一个文件，我们应该调用它的
    `close` 方法：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After closing, we aren’t allowed to use the file anymore. Now that we’ve discussed
    how to read, process, and close a file, let’s see a full example. In listing 5.10,
    we provide a new version of our program from chapter 2 that sorts quarterbacks
    by their total passing yards. In addition to showcasing files, we’re also using
    many of the Python features that we’ve seen in chapter 4 and the current chapter,
    including conditionals, strings, lists, loops, and dictionaries.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭后，我们不再允许使用该文件。现在我们已经讨论了如何读取、处理和关闭文件，让我们看看一个完整的示例。在列表 5.10 中，我们提供了一个第 2 章程序的版本，该程序按总传球码数对四分卫进行排序。除了展示文件外，我们还使用了第
    4 章和本章中看到的大多数 Python 功能，包括条件语句、字符串、列表、循环和字典。
- en: Listing 5.10 Alternative NFL statistics code without the csv module
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.10 不使用 csv 模块的替代 NFL 统计代码
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '#1 This dictionary maps quarterback names to their passing yards.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这个字典将四分卫的名字映射到他们的传球码数。'
- en: '#2 Loops through each line of the file'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 遍历文件的每一行'
- en: '#3 Focuses only on the quarterbacks'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 仅关注四分卫'
- en: '#4 Quarterback is already in our dictionary.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 四分卫已经在我们的字典中了。'
- en: '#5 Add to quarterback’s total; int converts string like ''203'' to integer.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 将四分卫的总数增加；int将类似''203''的字符串转换为整数。'
- en: '#6 Quarterback isn’t yet in our dictionary.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 四分卫尚未在我们的字典中。'
- en: '#7 Sets initial quarterback’s total'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 设置初始四分卫的总数'
- en: '#8 Loops through quarterbacks from highest to lowest passing yards'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 从最高到最低传球码数遍历四分卫'
- en: 'That loop at the bottom, `for` `player` `in` `sorted(passing_yards,` `key=passing_yards
    .get,` `reverse=True):`, has a lot going on. We explained this line in the annotations
    as looping through the quarterbacks from highest to lowest. The `reverse=True`
    makes us sort from highest to lowest rather than the default of lowest to highest.
    The `key=passing_yards.get` focuses the sort on the number of passing yards (rather
    than, e.g., the player’s names). If you’d like to break down this line of code
    further, feel free to ask Copilot for further explanation. This highlights the
    balancing act that we’re trying to maintain here: to know enough to be able to
    get the gist of code without necessarily needing to understand every nuance.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的这个循环`for player in sorted(passing_yards, key=passing_yards.get, reverse=True):`有很多内容。我们在注释中解释了这一行是按从高到低遍历四分卫。`reverse=True`使我们按从高到低排序，而不是默认的从低到高。`key=passing_yards.get`使排序集中在传球码数（而不是，例如，球员的名字）。如果您想进一步分解这一行代码，请随时向Copilot请求进一步解释。这突显了我们在这里试图保持的平衡：知道足够多的知识，能够理解代码的精髓，而不一定需要理解每一个细微之处。
- en: This program works just fine; if you run it, you would see the same output as
    if you ran the code from chapter 2\. Sometimes, though, it’s possible to write
    a program more easily using modules (we cover modules in more depth in the next
    section), and that’s what the program from chapter 2 did. Because CSV files are
    so common, Python comes with a module to make it easier to process them. In chapter
    2, the solution that we were given used the csv module. So, let’s discuss the
    main differences between our code in listing 5.10 that doesn’t use the module
    and our code from chapter 2, reprinted here in the following listing (our prompts
    given to Copilot aren’t shown).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序运行得很好；如果你运行它，你会看到与从第2章运行代码相同的输出。不过，有时候，使用模块（我们将在下一节更深入地介绍模块）可以更容易地编写程序，这就是第2章的程序所做的事情。由于CSV文件非常常见，Python自带了一个模块来简化处理它们。在第2章中，我们给出的解决方案使用了csv模块。因此，让我们讨论一下列表5.10中的代码（不使用模块）和第2章中的代码（以下列表中重新打印）之间的主要区别（我们给Copilot的提示没有显示）。
- en: Listing 5.11 NFL statistics code using the csv module
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.11使用csv模块的NFL统计数据代码
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '#1 Shows the alternate syntax for opening a file'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 显示打开文件的另一种语法'
- en: '#2 Uses a special csv module; reads all data from the file'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用特殊的csv模块；读取文件中的所有数据'
- en: '#3 Loops through each line of data'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 遍历每行数据'
- en: First, listing 5.11 uses the csv module to make dealing with CSV files easier.
    The csv module knows how to manipulate CSV files, so, for example, we don’t have
    to worry about breaking a line into its columns. Second, listing 5.11 uses the
    `with` keyword, which results in the file automatically being closed when the
    program is done with it. Third, listing 5.11 reads the entire file first before
    doing any processing. By contrast, in listing 5.10, we read and process each line
    as soon as we read it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，列表5.11使用csv模块使处理CSV文件变得更容易。csv模块知道如何操作CSV文件，因此，例如，我们不必担心将行拆分成列。其次，列表5.11使用了`with`关键字，这意味着当程序完成对该文件的操作时，文件会自动关闭。第三，列表5.11在开始任何处理之前先读取整个文件。相比之下，在列表5.10中，我们读取并处理每行，一旦读取。
- en: More than one way to solve a programming problem
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决编程问题有多种方法
- en: There are always many different programs that can be written to solve the same
    task. Some may be easier to read than others. The most important criterion for
    code is that it does the correct thing. After that, we care most about readability
    and efficiency. So, if you find yourself struggling to understand how some code
    works, it may be worth some time looking at other code from Copilot in case there’s
    a simpler or more understandable solution available there.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 总是存在许多不同的程序可以用来解决同一个任务。有些可能比其他更容易阅读。代码最重要的标准是它能正确地完成工作。之后，我们最关心的是可读性和效率。所以，如果你发现自己难以理解某些代码的工作方式，花些时间查看Copilot的其他代码可能值得，以防那里有更简单或更易于理解的解决方案。
- en: Files are used commonly in computing tasks because they are a common source
    of data to be processed. This includes CSV files like the one from this section,
    log files that keep track of events on computers or websites, and files that store
    data for graphics you might see in video games, among others. Because files are
    so commonly used, it’s no surprise there are many modules that help us read various
    file formats. That leads us to the larger topic of modules.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算任务中，文件被广泛使用，因为它们是常见的数据来源，需要被处理。这包括本节中的CSV文件，记录计算机或网站事件日志文件，以及存储你在视频游戏中可能看到的图形数据的文件等。由于文件被如此广泛地使用，因此并不奇怪有许多模块帮助我们读取各种文件格式。这引出了模块的更大主题。
- en: '5.1.5 #10\. Modules'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '5.1.5 #10\. 模块'
- en: People use Python to make all kinds of things—games, websites, and apps for
    analyzing data, automating repetitive tasks, controlling robots, you name it.
    You might be wondering how Python can possibly let you create so many different
    types of programs. Surely, the creators of Python couldn’t have anticipated or
    created all the needed support!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 人们使用Python制作各种东西——游戏、网站、用于数据分析、自动化重复任务、控制机器人等应用程序。你可能想知道Python怎么可能让你创建如此多种类的程序。当然，Python的创造者不可能预见到或创建所有需要的支持！
- en: The truth is that, by default, your Python program has access only to some core
    Python features (such as those we’ve showed you in the previous and current chapter).
    To get any more than that, we need to use modules. And, to use a module, you need
    to import it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，默认情况下，你的Python程序只能访问一些核心Python功能（例如我们在上一章和本章中向您展示的那些）。要获取更多功能，我们需要使用模块。而且，要使用一个模块，你需要导入它。
- en: Modules in Python
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Python中的模块
- en: 'A *module* is a collection of code designed for a specific purpose. Recall
    that we don’t need to know how a function works to use it. It’s the same with
    modules: we don’t need to know how modules work to be able to use them, much as
    we don’t need to know how a light switch works internally to use it. As users
    of modules, we just need to know what a module will help us do and how to write
    the code to correctly call its functions. Of course, Copilot can help us write
    that kind of code.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块* 是为特定目的设计的代码集合。回想一下，我们不需要知道一个函数是如何工作的就可以使用它。模块也是一样：我们不需要知道模块是如何工作的就可以使用它们，就像我们不需要知道电灯开关内部是如何工作的就可以使用它一样。作为模块的用户，我们只需要知道模块能帮助我们做什么以及如何编写代码来正确调用其函数。当然，Copilot可以帮助我们编写这种代码。'
- en: Some modules come with Python when you install it, but we still need to import
    them. Other modules we first have to install before we can import them. Trust
    us, if there’s a specific kind of task you want to do with Python, someone’s probably
    already written a module to help you out.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装Python时，一些模块会随Python一起安装，但我们需要导入它们。其他模块我们首先需要安装，然后才能导入。相信我们，如果你想在Python中完成特定的任务，可能已经有某人编写了一个模块来帮助你。
- en: You might be wondering how to determine which Python modules you should use.
    How do you know which ones exist? A simple chat with Copilot or Google search
    is often helpful. For example, if we google “Python module to create a zip file,”
    the first result tells us that the module we need is part of the Python standard
    library, which means that it comes with Python. If we google “Python module for
    visualization,” we learn about modules named matplotlib, plotly, seaborn, and
    more. Searching for each of these should lead you to galleries of visualizations
    showing you their capabilities and what each is typically used for. Most modules
    are free to download and use, although your search results can help you confirm
    whether a module is free and its specific usage license. We’re going to hold off
    on installing and using newly installed modules until chapter 9, but, at that
    time, you’ll see this process of finding, installing, and using relevant modules
    to help us complete our tasks.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如何确定应该使用哪些Python模块。你怎么知道哪些模块存在呢？与Copilot或Google搜索进行简单对话通常很有帮助。例如，如果我们搜索“Python模块创建zip文件”，第一个结果告诉我们所需的模块是Python标准库的一部分，这意味着它随Python一起提供。如果我们搜索“Python模块用于可视化”，我们会了解到名为matplotlib、plotly、seaborn等模块。搜索这些模块应该会引导你到展示它们功能和典型用途的可视化画廊。大多数模块都可以免费下载和使用，尽管你的搜索结果可以帮助你确认模块是否免费以及其具体的使用许可。我们将在第9章中推迟安装和使用新安装的模块，但到那时，你会看到这个过程：寻找、安装和使用相关模块来帮助我们完成任务。
- en: Table 5.2 has a list of some of the commonly used Python modules and whether
    they are built-in or not. If a module is built-in, you can import the module and
    start using it right away; if not, you need to install it first.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2列出了一些常用的Python模块以及它们是否为内置模块。如果一个模块是内置的，你可以直接导入该模块并开始使用它；如果不是，你需要先安装它。
- en: Table 5.2 Summary of commonly used Python modules
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.2 常用Python模块总结
- en: '| Module | Built-In | Description |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 内置 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '**#1 创建新的.zip文件'
- en: '| csv  | Yes  | Aids in the reading, writing, and analysis of CSV files  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| csv  | 是  | 帮助读取、写入和分析CSV文件  |'
- en: '| zipfile  | Yes  | Aids in the creation and extraction of compressed zip archive
    files  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| zipfile  | 是  | 帮助创建和提取压缩的zip存档文件  |'
- en: '| matplotlib  | No  | Graphics library for plotting that serves as the basis
    of other graphics libraries and can offer high levels of customization  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| matplotlib  | 否  | 用于绘图的图形库，作为其他图形库的基础，并提供高度的自定义化  |'
- en: '| plotly  | No  | A graphics library used for creating interactive plots for
    the web  |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| plotly  | 否  | 一个用于创建网络交互式图表的图形库  |'
- en: '| seaborn  | No  | A graphics library built on top of matplotlib that aids
    in creating high- quality plots more easily than matplotlib  |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| seaborn  | 否  | 建立在matplotlib之上的图形库，可以比matplotlib更容易地创建高质量图表  |'
- en: '| pandas  | No  | A data processing library that specializes in data frames,
    which are analogous to spreadsheets  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| pandas  | 否  | 一个专注于数据框的数据处理库，类似于电子表格  |'
- en: '| scikit-learn  | No  | Contains basic tools for machine learning (i.e., helping
    to learn from data and make predictions)  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| scikit-learn  | 否  | 包含机器学习的基本工具（即，帮助从数据中学习并做出预测）  |'
- en: '| numpy  | No  | Offers highly efficient data processing  |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| numpy  | 否  | 提供高效的数据处理  |'
- en: '| pygame  | No  | A game programming library that helps to build interactive,
    graphical games in Python  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| pygame  | 否  | 一个游戏编程库，帮助在Python中构建交互式、图形化的游戏  |'
- en: '| django  | No  | Web development library that aids in designing websites and
    web applications  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: In chapter 2, our code used the csv module that comes with Python. Let’s continue
    here by learning about a different module that comes with Python.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我们的代码使用了Python自带的csv模块。让我们继续学习Python自带的其他模块。
- en: When people want to organize their files, perhaps prior to backing them up or
    uploading them, they often archive them first into a .zip file. Then they can
    pass around that single .zip file, rather than potentially hundreds or thousands
    of individual files. Python comes with a module called zipfile that can help you
    create a .zip file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们想要组织他们的文件，可能是在备份或上传之前，他们通常会首先将它们存档到一个.zip文件中。然后他们可以传递这个单一的.zip文件，而不是可能成百上千的单独文件。Python自带了一个名为zipfile的模块，可以帮助你创建.zip文件。
- en: To try this, create a few files in your programming directory, and make them
    all end with .csv. You could start with your nfl_offensive_stats.csv file and
    then add a few more. For example, you could add one called actors.csv with the
    names of a few actors and their ages, such as
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个，在你的编程目录中创建一些文件，并让它们都以.csv结尾。你可以从你的nfl_offensive_stats.csv文件开始，然后添加几个更多。例如，你可以添加一个名为actors.csv的文件，其中包含一些演员的名字和他们的年龄，如下所示
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'and you could add one called chores.csv with a list of chores and whether you’ve
    finished each one:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以添加一个名为chores.csv的文件，其中包含一项任务列表以及你是否完成了每一项：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The contents don’t matter as long as you have a few .csv files to test with.
    Now we can use the zipfile module to add them all to a new .zip file!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 内容并不重要，只要你有一两个.csv文件来测试即可。现在我们可以使用zipfile模块将它们全部添加到一个新的.zip文件中！
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**#1 Creates the new .zip file'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '| django  | 否  | 一个辅助设计网站和Web应用的Web开发库  |'
- en: '#2 Adds the first file'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 添加第一个文件'
- en: '#3 Adds the second file'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 添加第二个文件'
- en: '#4 Adds the third file**  **If you run that code, you’ll find a new file called
    my_stuff.zip that contains your three .csv files. Working with .zip files directly
    used to be a very specialized, error-prone task with other earlier programming
    languages, but that’s not so with Python. Python comes with modules that are helpful
    for data science, making games, dealing with various file formats, and so on,
    but again, Python can’t come with everything. When we need more, we turn to downloadable
    modules as we’ll see in chapter 9.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 添加第三个文件**  **如果你运行这段代码，你会找到一个名为my_stuff.zip的新文件，其中包含你的三个.csv文件。直接使用.zip文件在以前的其他编程语言中是一个非常专业、容易出错的任务，但Python并非如此。Python自带了一些对数据科学、游戏制作、处理各种文件格式等有帮助的模块，但Python并不能提供一切。当我们需要更多的时候，我们会转向可下载的模块，正如我们在第9章中将要看到的。'
- en: In this chapter, we introduced you to the second half of our top 10 Python features,
    as summarized in table 5.3\. We’ve covered a lot about reading code in the previous
    chapter and this chapter. Although we haven’t covered everything you might see
    Copilot produce, you’re in a good position to spot-check Copilot code to determine
    whether it’s given a good attempt at producing the code you requested. We also
    showed more examples of using the Copilot explanation tool to help you understand
    new code. In the next chapters, we’ll see how to test the code from Copilot to
    determine whether it’s correct, and what you can do when it’s not.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了我们前 10 个 Python 特性的后半部分，总结如表 5.3 所示。在前一章和本章中，我们讨论了很多关于阅读代码的内容。尽管我们没有涵盖你可能会看到
    Copilot 生成的一切，但你处于一个很好的位置来检查 Copilot 代码，以确定它是否尽力按照你请求的方式生成代码。我们还展示了更多使用 Copilot
    解释工具的示例，以帮助你理解新代码。在接下来的章节中，我们将看到如何测试 Copilot 生成的代码，以确定其是否正确，以及当它不正确时你可以做什么。
- en: Table 5.3 Summary of Python code features from this chapter
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.3 本章 Python 代码特性总结
- en: '| Code Element | Example | Brief Description |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 代码元素 | 示例 | 简要描述 |'
- en: '| --- | --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Loops  | `for` loop: `for country in countries: print(country)` `while` loop:
    `index = 0 while index < 4: print(index) index = index + 1`  | Loops allow us
    to run the same code as many times as needed. We use a `for` loop when we know
    how many iterations there will be (e.g., number of characters in a string) and
    a `while` loop when we don’t (e.g., asking the user for a strong password).  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 循环 | `for` 循环：`for country in countries: print(country)` `while` 循环：`index
    = 0 while index < 4: print(index) index = index + 1` | 循环允许我们根据需要多次运行相同的代码。当我们知道迭代次数时（例如，字符串中的字符数）使用
    `for` 循环，不知道时（例如，要求用户输入强密码）使用 `while` 循环。|'
- en: '| Indentation  | `for country in countries: print(country)`  | Indentation
    tells Python when a piece of code belongs as part of another body of code (e.g.,
    that the `print` call is within the `for` loop).  |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 缩进 | `for country in countries: print(country)` | 缩进告诉 Python 何时一段代码属于另一个代码块的一部分（例如，`print`
    调用位于 `for` 循环内）。|'
- en: '| Dictionaries  | `points = {''a'': 1, ''b'': 3}`  | Dictionaries allow us
    to associate a key with a value. For example, the key `''a''` is associated with
    the value `1`.  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 字典 | `points = {''a'': 1, ''b'': 3}` | 字典允许我们将键与值关联起来。例如，键 `''a''` 与值 `1`
    相关联。|'
- en: '| Files  | `file = open(''chores.csv'') first_line = file.readline()`  | Files
    contain data and are stored on your computer. Python can be used to open many
    types of files and read their contents, allowing you to process the data in the
    file.  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 文件 | `file = open(''chores.csv'') first_line = file.readline()` | 文件包含数据，存储在您的计算机上。Python
    可以打开许多类型的文件并读取其内容，允许您处理文件中的数据。|'
- en: '| Modules  | `import` `csv`  | Modules are already-existing libraries that
    provide additional functionality. Commonly used modules include csv, numpy, matplotlib,
    pandas, and scikit-learn. Some modules come with the standard Python distribution;
    others need to be installed separately.  |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | `import csv` | 模块是已经存在的库，提供了额外的功能。常用的模块包括 csv、numpy、matplotlib、pandas
    和 scikit-learn。一些模块包含在标准的 Python 发行版中；其他模块需要单独安装。|'
- en: 5.2 Exercises
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 练习
- en: Recall the `for` loop code we looked at in listing 5.3 to print animals in a
    list. What does this modified code do differently compared to the original example
    in the chapter? Specifically, what additional output does it produce?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回想一下我们在列表 5.3 中查看的 `for` 循环代码，用于打印列表中的动物。与章节中的原始示例相比，这段修改后的代码有何不同？具体来说，它产生了哪些额外的输出？
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 2\. Consider the following `while` loop code that seeks to repeat what we did
    using a `for` loop in listing 5.3\. When we run the code, we notice that it runs
    indefinitely. Can you identify and fix the error that would cause it to run indefinitely?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 考虑以下 `while` 循环代码，试图重复我们在列表 5.3 中使用 `for` 循环所做的操作。当我们运行代码时，我们会注意到它无限期地运行。你能识别并修复导致它无限期运行的错误吗？
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 3\. Arrange the following lines of code to create a `while` loop that prints
    each number in the list until it encounters the number 7\. Be careful about indentation!
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 将以下代码行排列成 `while` 循环，打印列表中的每个数字，直到遇到数字 7。注意缩进！
- en: '[PRE40]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 4\. Think of a real-world scenario where a `while` loop would be more appropriate
    than a `for` loop. Describe the scenario and explain why a `while` loop is the
    better choice.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 想一个现实场景，其中 `while` 循环比 `for` 循环更合适。描述这个场景，并解释为什么 `while` 循环是更好的选择。
- en: 5\. Modify the `get_strong_password` function (or the `is_strong_password` function
    that it calls) to provide specific feedback on why the entered password isn’t
    strong enough. For instance, if the password doesn’t have an uppercase character,
    print “Password must include an uppercase character,” and if it doesn’t contain
    a digit, print “Password must contain at least one digit.”
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5. 修改`get_strong_password`函数（或它调用的`is_strong_password`函数）以提供有关输入密码不够强大的具体反馈。例如，如果密码没有大写字母，则打印“密码必须包含大写字母”，如果它不包含数字，则打印“密码必须至少包含一个数字”。
- en: 6\. Given the following `print_quarterbacks` function, can you rewrite it to
    use the “with” statement to open and close the file? Why is it important to close
    the file?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6. 给定以下`print_quarterbacks`函数，你能将其重写为使用“with”语句来打开和关闭文件吗？为什么关闭文件很重要？
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '7\. In this exercise, we’ll further practice working with the zipfile module
    to create a .zip file containing multiple CSV files. Follow these steps to complete
    the task and answer the questions:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7. 在这个练习中，我们将进一步练习使用zipfile模块创建包含多个CSV文件的.zip文件。按照以下步骤完成任务并回答问题：
- en: 'First, create three CSV files in your current directory:'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在你的当前目录中创建三个CSV文件：
- en: nfl_offensive_stats.csv (you should already have this file)
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: nfl_offensive_stats.csv（你应该已经有了这个文件）
- en: 'actors.csv with the following content:'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: actors.csv包含以下内容：
- en: '[PRE42]'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'chores.csv with the following content:'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: chores.csv包含以下内容：
- en: '[PRE43]'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Using Copilot (don’t type the code directly as we did in the chapter), write
    a Python script that uses the zipfile module to add these three CSV files to a
    .zip file named my_stuff.zip.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Copilot（不要直接像我们在本章中那样输入代码），编写一个Python脚本，使用zipfile模块将这些三个CSV文件添加到名为my_stuff.zip的.zip文件中。
- en: What are some of the other functions provided by the zipfile module that Copilot
    suggests? How can they be useful?
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Copilot建议的zipfile模块提供的其他一些功能有哪些？它们有什么用？
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A loop is used to repeat code as many times as needed.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环用于重复执行代码，直到满足所需次数。
- en: We use a `for` loop when we know how many iterations the loop will do; we use
    a `while` loop when we don’t know how many iterations a loop will do.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们知道循环将执行多少次迭代时，我们使用`for`循环；当我们不知道循环将执行多少次迭代时，我们使用`while`循环。
- en: Python uses indentation to determine which lines of code go together.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 使用缩进来确定哪些代码行属于同一组。
- en: A dictionary is a mapping from keys (e.g., words in a book) to values (e.g.,
    their frequencies).
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典是从键（例如，一本书中的单词）到值（例如，它们的频率）的映射。
- en: We need to open a file before we can read from it.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在读取文件之前，我们需要先打开文件。
- en: Once a file is open, we can use methods (e.g., readline) or a loop to read its
    lines.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦文件打开，我们可以使用方法（例如，readline）或循环来读取其行。
- en: Some modules, such as csv and zipfile, come with Python and can be used by importing
    them.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些模块，如csv和zipfile，与Python一起提供，可以通过导入它们来使用。
- en: Other modules, such as matplotlib, need to be installed first before they can
    be imported and used.***************
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他模块，如matplotlib，需要先安装，然后才能导入和使用。***************
