- en: Chapter 7\. Integrating Databases into AI Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章\. 将数据库集成到AI服务中
- en: In this chapter, you’ll integrate a database to your current API service to
    store and retrieve user interactions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将集成数据库到当前的API服务中，以存储和检索用户交互。
- en: This chapter assumes basic experience working with databases and Structured
    Query Language (SQL), so it won’t cover every aspect of SQL programming and database
    workflows. Instead, you will learn the higher-level database concepts, development
    workflows, and best practices when integrating databases to your FastAPI applications
    that interact with GenAI models such as LLMs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你具备使用数据库和结构化查询语言（SQL）的基本经验，因此它不会涵盖SQL编程和数据库工作流程的各个方面。相反，你将学习在将数据库集成到与LLM等GenAI模型交互的FastAPI应用程序时，更高层次的数据库概念、开发工作流程和最佳实践。
- en: As part of this, you will learn the role of relational (SQL) versus nonrelational
    (noSQL) databases in application development and will be able to confidently select
    the right database for your use case. Next, you will understand more about the
    features of relational databases and associated tooling such as object relational
    mappers (ORMs) and database migration tools. Finally, as a hands-on exercise,
    you will integrate a database to your existing application using SQLAlchemy and
    Alembic, to store and retrieve user conversations with an LLM.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其中的一部分，你将了解关系型（SQL）数据库与无关系型（noSQL）数据库在应用程序开发中的作用，并能够自信地选择适合你用例的正确数据库。接下来，你将了解更多关于关系型数据库及其相关工具（如对象关系映射器（ORMs）和数据库迁移工具）的功能。最后，作为一个动手练习，你将使用SQLAlchemy和Alembic将数据库集成到现有的应用程序中，以存储和检索与LLM的用户对话。
- en: By the end of this chapter, you will feel more confident in selecting, configuring,
    and resolving database-related issues within your GenAI applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将在选择、配置和解决GenAI应用程序中的数据库相关问题方面更有信心。
- en: The Role of a Database
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库的作用
- en: When building backend services, you often require a database to persist application
    state and store user data. In other cases, your application won’t need a database,
    and you shouldn’t try to add one since any database integration can significantly
    increase the complexity of your services.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建后端服务时，你通常需要一个数据库来持久化应用程序状态和存储用户数据。在其他情况下，你的应用程序可能不需要数据库，你不应该尝试添加一个，因为任何数据库集成都可能显著增加你服务的复杂性。
- en: 'Here are several cases for which you could forgo using a database:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下几种情况下，你可以选择不使用数据库：
- en: Your application can start from a fresh state on startup for each new user session.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的应用程序可以在每个新的用户会话启动时从全新状态开始。
- en: Recalculating the application data is straightforward and resource-efficient.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新计算应用程序数据是直接且资源高效的。
- en: The application data is small enough to be stored in memory.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序数据足够小，可以存储在内存中。
- en: Your application is tolerant to data losses due to various reasons such as server
    errors, restarts, or other unexpected events.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的应用程序能够容忍由于服务器错误、重启或其他意外事件等原因导致的数据丢失。
- en: Different user sessions or application instances won’t need to share data.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不同的用户会话或应用程序实例不需要共享数据。
- en: The data you need can directly be fetched from external systems, GenAI models,
    and other application APIs, and not your own database.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你所需的数据可以直接从外部系统、GenAI模型和其他应用程序API中获取，而不是从你自己的数据库中获取。
- en: The user is happy to wait for data to be recomputed for each new session or
    action.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户愿意等待为每个新的会话或操作重新计算数据。
- en: Your service requirements allow for the data to be persisted in files on disk,
    the browser storage, or an external cloud storage instead of a database. With
    these alternatives, your services can tolerate that data storage and retrieval
    won’t be as reliable and efficient as a database.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的服务需求允许数据持久化存储在磁盘上的文件、浏览器存储或外部云存储，而不是数据库。使用这些替代方案，你的服务可以容忍数据存储和检索的可靠性不如数据库高效。
- en: You’re building a proof-of-concept and need to avoid project delays or complexity
    at all costs.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在构建一个概念验证，需要不惜一切代价避免项目延迟或复杂性。
- en: An example application that matches the previous criteria is a *GenAI image
    generator* only used for demonstration purposes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个符合上述标准的应用程序示例是一个仅用于演示目的的*GenAI图像生成器*。
- en: In this example, you won’t need to store any generated images, and you can always
    restart or use the application at any time from a fresh state. Additionally, the
    application doesn’t need to know who the user is. Plus, there is no need to share
    data between sessions. Furthermore, if there is a server error, the impact of
    data loss is minimal since you can regenerate a new image on the fly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您不需要存储任何生成的图像，并且您始终可以从一个全新的状态重新启动或使用应用程序。此外，应用程序不需要知道用户是谁。此外，不需要在会话之间共享数据。此外，如果发生服务器错误，由于您可以即时重新生成新的图像，数据丢失的影响最小。
- en: As you can see, there are at least a handful of cases where you won’t need a
    database to build your own GenAI services. However, you may be wondering when
    you do really need a database.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，至少有几种情况您不需要数据库来构建自己的GenAI服务。然而，您可能会想知道何时您确实需要数据库。
- en: To determine when a database is necessary, you will want to understand the role
    of databases. In short, you can use them to store, organize, and manage data in
    an efficient format allowing for easy retrieval, manipulation, and analysis. Additionally,
    databases ship with critical features such as restore/backup, concurrent access
    management, indexing, caching, and role-based access control, alongside many others,
    that make them an irreplaceable component of any services that displays, produces
    and consumes data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定何时需要数据库，您需要了解数据库的作用。简而言之，您可以使用它们以高效格式存储、组织和管理工作数据，从而便于检索、操作和分析。此外，数据库还配备了诸如恢复/备份、并发访问管理、索引、缓存和基于角色的访问控制等关键功能，以及许多其他功能，使它们成为任何显示、生成和消耗数据的服务的不可或缺的组成部分。
- en: In the next section, we will examine in significant detail the inner workings
    of databases, with an emphasis on relational databases that practical examples
    of this chapter will focus on. With a detailed understanding of database internals,
    you can then design fully optimized and production-ready GenAI APIs. This will
    then allow you to delegate heavy workloads to the database engine, which is specifically
    designed for data-heavy tasks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将以显著详细的程度检查数据库的内部运作机制，重点是关系型数据库，本章的实践示例将聚焦于此。通过对数据库内部结构的详细了解，您可以设计出完全优化且适用于生产的GenAI
    API。这将使您能够将繁重的工作负载委托给专门为处理数据密集型任务而设计的数据库引擎。
- en: Database Systems
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库系统
- en: Now that you understand when to leverage a database, let’s learn more about
    different databases you can use and how they work.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经了解了何时可以利用数据库，那么让我们更深入地了解您可以使用的不同数据库以及它们的工作原理。
- en: 'You can construct a mental model of databases by placing them into two main
    categories: *relational* (SQL) and *nonrelational* (NoSQL) databases.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将数据库分为两大类来构建数据库的心理模型：*关系型*（SQL）和*非关系型*（NoSQL）数据库。
- en: The *SQL* versus *NoSQL* categorization is based on the fact that relational
    databases use various dialects of SQL as their main query language, whereas nonrelational
    databases often come packaged with their own specialized query languages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*SQL*与*NoSQL*的分类基于这样一个事实：关系型数据库使用SQL的各种方言作为其主要查询语言，而非关系型数据库通常附带自己的专用查询语言。'
- en: 'With both categories of database systems, you can adopt a mental model of how
    such systems are structured. Both SQL and NoSQL database systems often consist
    of the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种数据库系统类别，您可以采用一种心理模型来理解这些系统的结构。SQL和NoSQL数据库系统通常由以下内容组成：
- en: A *server* at the highest level, which hosts the entire database infrastructure
    and consumes system resources (CPU, RAM, and storage).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最高级别的*服务器*，它托管整个数据库基础设施并消耗系统资源（CPU、RAM和存储）。
- en: One or more *databases* within the server, which act as *logical container(s)*
    that hold related data.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器内部的一个或多个*数据库*，它们作为*逻辑容器*，持有相关数据。
- en: One or more *schemas* within a database (depending on the database software),
    which serve as a *blueprint* that defines the complete structure of the data and
    various structural objects such as indexes, logical constraints, triggers, etc.
    However, NoSQL database servers may not use strict schemas, unlike relational
    databases.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库内部的一个或多个*模式*（取决于数据库软件），它作为*蓝图*，定义了数据的完整结构和各种结构对象，如索引、逻辑约束、触发器等。然而，与关系型数据库不同，NoSQL数据库服务器可能不会使用严格的模式。
- en: Zero or more *tables* (SQL) or *collections* (NoSQL) created inside the database
    (as part of a schema), which group related data.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据库内部（作为模式的一部分）创建的零个或多个*表*（SQL）或*集合*（NoSQL），它们将相关数据分组。
- en: Zero or more *items* within each collection (as documents) or table (as rows),
    which represent specific records or entities.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个集合（作为文档）或表格（作为行）中可以有零个或多个*项目*，它们代表特定的记录或实体。
- en: '[Figure 7-1](#database_server_breakdown) visualizes the aforementioned breakdown.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-1](#database_server_breakdown)展示了上述分解。'
- en: '![bgai 0701](assets/bgai_0701.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0701](assets/bgai_0701.png)'
- en: Figure 7-1\. Database system breakdown
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-1\. 数据库系统分解
- en: Adopting a mental model as shown in [Figure 7-1](#database_server_breakdown)
    will help you navigate the ever-increasing variety of database systems as you
    can expect similar underlying mechanisms to be present. This familiarity will
    hopefully reduce your learning curve in adopting different database systems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 采用如图7-1所示的思维模型将帮助您在数据库系统种类不断增多的同时，能够预期到类似的底层机制存在。这种熟悉感有望减少您采用不同数据库系统时的学习曲线。
- en: Next, let’s briefly review both SQL and NoSQL database systems so that you have
    a better understanding of their use cases, features, and limitations when building
    APIs and services.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们简要回顾一下SQL和NoSQL数据库系统，以便您在构建API和服务时能更好地理解它们的使用场景、特性和局限性。
- en: To help you with creating a mental model of both relational and nonrelational
    databases, take a look at [Figure 7-2](#db_types).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您构建关联性和非关联性数据库的思维模型，请参阅[图7-2](#db_types)。
- en: '![bgai 0702](assets/bgai_0702.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0702](assets/bgai_0702.png)'
- en: Figure 7-2\. Database types
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-2\. 数据库类型
- en: You can also use the summary in [Table 7-1](#db_comparison) as a reference of
    the database types that will be covered in this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用[表7-1](#db_comparison)中的摘要作为本章将要涵盖的数据库类型的参考。
- en: Table 7-1\. Comparison of databases
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表7-1\. 数据库比较
- en: '| Type | Data model | Examples | Use cases |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 数据模型 | 示例 | 使用场景 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Key-value stores | Key-value pairs | Redis, DynamoDB, Memcached | Caching,
    session management |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| Key-value stores | 键值对 | Redis, DynamoDB, Memcached | 缓存，会话管理 |'
- en: '| Graph stores | Nodes and edges | Neo4j, Amazon Neptune, ArangoDB | Social
    networks, recommendation engines, fraud detection |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| Graph stores | 节点和边 | Neo4j, Amazon Neptune, ArangoDB | 社交网络，推荐引擎，欺诈检测 |'
- en: '| Document stores | Documents | MongoDB, CouchDB, Amazon DocumentDB | Content
    management, e-commerce, real-time analytics |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| Document stores | 文档 | MongoDB, CouchDB, Amazon DocumentDB | 内容管理，电子商务，实时分析
    |'
- en: '| Vector stores | High-dimensional vectors | Pinecone, Weaviate | Recommendation
    systems, image/text search, ML model storage |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| Vector stores | 高维向量 | Pinecone, Weaviate | 推荐系统，图像/文本搜索，机器学习模型存储 |'
- en: '| Wide-column family stores | Tables with rows and columns | Apache Cassandra,
    HBase, ScyllaDB | Time-series data, real-time analytics, logging |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| Wide-column family stores | 表格，具有行和列 | Apache Cassandra, HBase, ScyllaDB
    | 时间序列数据，实时分析，日志记录 |'
- en: Now that you have a broad overview of every common relational and nonrelational
    database, you can visualize a real-world GenAI service that makes use of these
    databases together.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对每个常见的关联性和非关联性数据库有了广泛的概述，您可以可视化一个利用这些数据库的实时世界GenAI服务。
- en: Imagine you’re building a RAG-enabled LLM service that can talk to a knowledge
    base. The documents in this knowledge base are related to each other, so you decide
    to implement a RAG graph to capture a richer context. To implement a RAG graph,
    you integrate your service with a graph-based database.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您正在构建一个支持RAG的LLM服务，它可以与知识库进行交互。这个知识库中的文档相互关联，因此您决定实现一个RAG图来捕捉更丰富的上下文。为了实现RAG图，您将您的服务与基于图的数据库集成。
- en: Now, to retrieve relevant chunks of documents, you also need to embed them in
    a vector database. As part of this, you also need a relational database to monitor
    usage, and store user data and conversation histories.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了检索相关的文档块，您还需要将它们嵌入到向量数据库中。作为这一过程的一部分，您还需要一个关系数据库来监控使用情况，并存储用户数据和会话历史。
- en: Since the users may ask common questions, you also decide to cache the LLM responses
    by generating several outputs in advance. Therefore, you also integrate a key-value
    store to your service.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户可能会提出常见问题，您还决定通过提前生成多个输出来缓存LLM的响应。因此，您还向您服务中集成了键值存储。
- en: Finally, you want to give administrators control over system prompts with the
    ability to version-control prompts. So, you add a content management system as
    a prompt manager to your solution. However, since the prompt templates can often
    change, you also decide to integrate a document database.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你希望管理员能够通过版本控制提示的能力来控制系统提示。因此，你将内容管理系统作为提示管理器添加到你的解决方案中。然而，由于提示模板经常发生变化，你也决定集成一个文档数据库。
- en: As you can see, each database type ends up solving a particular problem in your
    complex RAG-enabled application. One stores your backend and user data, another
    captures the document relationships, one stores your document embeddings, another
    helps store flexible schemas of your prompts, and the last one helps you to return
    cached outputs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每种数据库类型最终都会解决你复杂 RAG 启用应用程序中的特定问题。一个存储你的后端和用户数据，另一个捕获文档关系，一个存储你的文档嵌入，另一个帮助你存储提示的灵活模式，最后一个帮助你返回缓存输出。
- en: You can see a visualization of the application architecture in [Figure 7-3](#rag_graph_architecture)
    to understand how these databases can work together to realize a solution.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 [图 7-3](#rag_graph_architecture) 中的可视化了解这些数据库如何协同工作以实现解决方案。
- en: '![bgai 0703](assets/bgai_0703.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0703](assets/bgai_0703.png)'
- en: Figure 7-3\. Using various database types together
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-3\. 使用各种数据库类型一起
- en: Now that you understand how your GenAI services can integrate with a variety
    of databases, in the next section, we will focus on adding a relational database
    to your service.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了你的 GenAI 服务如何与各种数据库集成，在下一节中，我们将专注于向你的服务添加一个关系型数据库。
- en: 'Project: Storing User Conversations with an LLM in a Relational Database'
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目：在关系型数据库中存储与 LLM 的用户对话
- en: In the previous section, we covered the core database concepts relevant to adding
    data persistence to your applications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了添加数据持久性到你的应用程序相关的核心数据库概念。
- en: In this section, you will integrate a relational database to your GenAI service
    so that you can store user conversation histories with an LLM in the database.
    As part of this work, you will also learn the best practices, tooling, and development
    workflow to manage schema changes and data migrations in your database.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将集成一个关系型数据库到你的 GenAI 服务中，以便你可以在数据库中存储与 LLM 的用户对话历史。作为这项工作的一个部分，你还将学习管理数据库模式更改和数据迁移的最佳实践、工具和开发工作流程。
- en: For this project, we will install a Postgres relational database that is open
    source, free, and battle-tested and is in use by many enterprises. To get started,
    let’s download and run the Postgres container using `docker run`, as shown in
    [Example 7-1](#postgres).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将安装一个开源、免费且经过实战检验的 Postgres 关系型数据库，许多企业都在使用它。为了开始，让我们使用 `docker run`
    命令下载并运行 Postgres 容器，如 [示例 7-1](#postgres) 所示。
- en: Example 7-1\. Download and run the Postgres database container
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-1\. 下载并运行 Postgres 数据库容器
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO1-1)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)（[将数据库集成到 AI 服务中](https://wiki.example.org/co_integrating_databases_into_ai_services_CO1-1)）'
- en: Download and run the latest `postgres` relational database image from in the
    Docker registry.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Docker 仓库下载并运行最新的 `postgres` 关系型数据库镜像。
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO1-2)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)（[将数据库集成到 AI 服务中](https://wiki.example.org/co_integrating_databases_into_ai_services_CO1-2)）'
- en: Run the `postgres` image and then expose and map container port `5432` to the
    same ports on the host machine.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `postgres` 镜像，然后将容器端口 `5432` 映射到主机机器上的相同端口。
- en: '[![3](assets/3.png)](#co_integrating_databases_into_ai_services_CO1-3)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)（[将数据库集成到 AI 服务中](https://wiki.example.org/co_integrating_databases_into_ai_services_CO1-3)）'
- en: Run the container with several environmental variables that specify the default
    database administrator username and password, database name, and DBMS data location
    within the container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用几个环境变量运行容器，这些变量指定了默认数据库管理员用户名和密码、数据库名称以及容器内的 DBMS 数据位置。
- en: '[![4](assets/4.png)](#co_integrating_databases_into_ai_services_CO1-4)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)（[将数据库集成到 AI 服务中](https://wiki.example.org/co_integrating_databases_into_ai_services_CO1-4)）'
- en: Mount the Postgres database storage to the host machine filesystem at a `dbstorage`
    folder in the present working directory.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Postgres 数据库存储挂载到主机机器文件系统中的当前工作目录下的 `dbstorage` 文件夹。
- en: 'Next, let’s install the `sqlalchemy`, `alembic`, and `psycopg3` packages:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们安装 `sqlalchemy`、`alembic` 和 `psycopg3` 包：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These battle-tested packages allow you to directly communicate with the Postgres
    relational database via Python. `psycopg3` is a popular PostgreSQL database adapter
    for Python, and SQLAlchemy is SQL toolkit and ORM that allows you to run SQL queries
    against your database in Python.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些经过实战检验的包允许您通过Python直接与Postgres关系型数据库通信。`psycopg3`是Python中流行的PostgreSQL数据库适配器，而SQLAlchemy是一个SQL工具包和ORM，允许您在Python中运行SQL查询。
- en: Lastly, the `alembic` package is a *database migration tool* created by the
    SQLAlchemy developers for usage with the SQLAlchemy. The data migration workflow
    is like the Git version control system but for your database schemas. It allows
    you to manage the changes and updates to your schemas so that you avoid any data
    corruptions, track changes over time, and revert any changes as required.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`alembic`包是由SQLAlchemy开发者创建的用于与SQLAlchemy一起使用的数据库迁移工具。数据迁移工作流程类似于Git版本控制系统，但针对您的数据库模式。它允许您管理对模式的更改和更新，从而避免任何数据损坏，跟踪随时间的变化，并在需要时撤销任何更改。
- en: Defining ORM Models
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义ORM模型
- en: The first step to query your database in Python is to define your ORM models
    with SQLAlchemy classes, as shown in [Example 7-2](#sqlalchemy_models). You can
    use the data schemas from the ERD diagram mentioned in [Figure 8-4](ch08.html#erd).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中查询数据库的第一步是使用SQLAlchemy类定义您的ORM模型，如[示例 7-2](#sqlalchemy_models)所示。您可以使用[图
    8-4](ch08.html#erd)中提到的ERD图中的数据模式。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You will add the `user` table in the next chapter when implementing authentication
    and authorization mechanisms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现身份验证和授权机制时，您将在下一章中添加`user`表。
- en: Example 7-2\. Defining database ORM models
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-2\. 定义数据库ORM模型
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO2-1)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO2-1)'
- en: Declare a declarative base class for creating SQLAlchemy models for its ORM
    engine.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个声明性基类，用于创建SQLAlchemy模型的ORM引擎。
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO2-2)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO2-2)'
- en: Create the `Conversation` model specifying the table columns, primary key, and
    secondary indexes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Conversation`模型，指定表列、主键和二级索引。
- en: '[![3](assets/3.png)](#co_integrating_databases_into_ai_services_CO2-3)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_integrating_databases_into_ai_services_CO2-3)'
- en: Use the `mapped_column()` to derive the column type from the type hint given
    to `Mapped`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mapped_column()`从`Mapped`提供的类型提示中推导列类型。
- en: '[![4](assets/4.png)](#co_integrating_databases_into_ai_services_CO2-4)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_integrating_databases_into_ai_services_CO2-4)'
- en: Index the `model_type` in case you want faster filtering of conversations by
    model type.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想根据模型类型更快地过滤会话，则对`model_type`进行索引。
- en: '[![5](assets/5.png)](#co_integrating_databases_into_ai_services_CO2-5)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_integrating_databases_into_ai_services_CO2-5)'
- en: Specify defaults and update operations for datetime columns.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 指定日期时间列的默认值和更新操作。
- en: '[![6](assets/6.png)](#co_integrating_databases_into_ai_services_CO2-6)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_integrating_databases_into_ai_services_CO2-6)'
- en: Indicate that all orphan messages must be deleted if a conversation is deleted
    through a `CASCADE DELETE` operation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 指示如果通过`CASCADE DELETE`操作删除会话，则必须删除所有孤儿消息。
- en: '[![7](assets/7.png)](#co_integrating_databases_into_ai_services_CO2-7)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_integrating_databases_into_ai_services_CO2-7)'
- en: Create the `Message` model specifying the table columns, primary key, secondary
    indexes, table relationships, and foreign keys.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Message`模型，指定表列、主键、二级索引、表关系和外键。
- en: '[![8](assets/8.png)](#co_integrating_databases_into_ai_services_CO2-9)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_integrating_databases_into_ai_services_CO2-9)'
- en: The `messages` table will contain both the LLM prompts and responses, usage
    tokens, and costs alongside the status codes and success states.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`messages`表将包含LLM提示和响应、使用令牌和成本，以及状态码和成功状态。'
- en: '[![9](assets/9.png)](#co_integrating_databases_into_ai_services_CO2-10)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_integrating_databases_into_ai_services_CO2-10)'
- en: Specify `Mapped[int | None]` to declare an optional typing so the column will
    allow `NULL` values (i.e., `nullable=True`).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Mapped[int | None]`指定为声明一个可选类型，这样列将允许`NULL`值（即，`nullable=True`）。
- en: Once you have your data models defined, you can create a connection to the database
    to create each table with the specified configurations. To achieve this, you will
    need to create a *database engine* and implement *session management*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您定义了数据模型，您就可以创建一个连接到数据库的连接，以使用指定的配置创建每个表。为了实现这一点，您需要创建一个数据库引擎并实现会话管理。
- en: Creating a Database Engine and Session Management
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库引擎和会话管理
- en: '[Example 7-3](#sqlalchemy_engine) shows how to create a SQLAlchemy engine using
    your Postgres database connection string. Once created, you can use the engine
    and the `Base` class to create tables for each of your data models.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-3](#sqlalchemy_engine) 展示了如何使用你的 Postgres 数据库连接字符串创建一个 SQLAlchemy 引擎。一旦创建，你可以使用该引擎和
    `Base` 类为你的每个数据模型创建表。'
- en: Warning
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The SQLAlchemy’s `create_all()` method in [Example 7-3](#sqlalchemy_engine)
    can only create tables in the database but not modify existing tables. This workflow
    is useful only if you’re prototyping and happy to reset the database schemas with
    new tables on each run.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-3](#sqlalchemy_engine) 中的 SQLAlchemy 的 `create_all()` 方法只能在数据库中创建表，但不能修改现有表。这种工作流程仅在原型设计且你愿意在每次运行时用新表重置数据库模式时才有用。'
- en: For production environments, you should use a database migration tool such as
    `alembic` to update your database schemas and to avoid unintended data loss. You
    will learn about the database migration workflow shortly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境，你应该使用像 `alembic` 这样的数据库迁移工具来更新你的数据库模式，以避免意外的数据丢失。你将很快了解数据库迁移工作流程。
- en: Example 7-3\. Create the SQLAlchemy database engine
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-3\. 创建 SQLAlchemy 数据库引擎
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO3-1)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO3-1)'
- en: 'For Postgres databases, the connection string is defined using the following
    template: `*<driver>*://*<username>*:*<password>*@*<origin>*/*<database>*`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Postgres 数据库，连接字符串使用以下模板定义：`*<driver>*://*<username>*:*<password>*@*<origin>*/*<database>*`。
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO3-2)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO3-2)'
- en: Create an async database engine using the database connection string. Turn on
    debug logging with `echo=True`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库连接字符串创建一个异步数据库引擎。通过设置 `echo=True` 打开调试日志。
- en: '[![3](assets/3.png)](#co_integrating_databases_into_ai_services_CO3-3)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_integrating_databases_into_ai_services_CO3-3)'
- en: Drop any existing tables and then create all database tables using the defined
    SQLAlchemy models in [Example 7-3](#sqlalchemy_engine).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [示例 7-3](#sqlalchemy_engine) 中定义的 SQLAlchemy 模型删除任何现有表，然后创建所有数据库表。
- en: '[![4](assets/4.png)](#co_integrating_databases_into_ai_services_CO3-4)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_integrating_databases_into_ai_services_CO3-4)'
- en: Dispose of the database engine during the server shutdown process. Any code
    after the `yield` keyword inside the FastAPI’s `lifespan` context manager is executed
    when server shutdown is requested.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器关闭过程中处理数据库引擎。在 FastAPI 的 `lifespan` 上下文管理器内部的 `yield` 关键字之后的任何代码，在请求服务器关闭时执行。
- en: Warning
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: For clarity, environment variables and secrets such as database connection strings
    are hard-coded in every code example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，环境变量和如数据库连接字符串之类的机密信息在每个代码示例中都是硬编码的。
- en: In production scenarios, never hard-code secrets and environment variables.
    Leverage environment files, secret managers, and tools like Pydantic Settings
    to handle application secrets and variables.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产场景中，永远不要硬编码机密信息和环境变量。利用环境文件、机密管理器和像 Pydantic Settings 这样的工具来处理应用程序的机密信息和变量。
- en: With the engine created, you can now implement a factory function for creating
    sessions to the database. Session factory is a design pattern that allows you
    to open, interact with, and close database connections across your services.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了引擎之后，你现在可以实施一个用于创建数据库会话的工厂函数。会话工厂是一种设计模式，它允许你在你的服务中打开、交互和关闭数据库连接。
- en: Since you may reuse a session, you can use FastAPI’s dependency injection system
    to cache and reuse sessions across each request runtime, as shown in [Example 7-4](#sqlalchemy_session).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可能需要重用会话，你可以使用 FastAPI 的依赖注入系统来缓存和重用每个请求运行时期间的会话，如 [示例 7-4](#sqlalchemy_session)
    所示。
- en: Example 7-4\. Creating a database session FastAPI dependency
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-4\. 创建数据库会话 FastAPI 依赖项
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO4-1)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO4-1)'
- en: Create an async database session factory bound to the database engine you created
    previously to asynchronously connect to your Postgres instance. Disable automatic
    committing of transactions with `autocommit=false` and automatic flushing of changes
    to the database with `autoflush=False`. Disabling both behaviors gives you more
    control, helps prevent unintended data updates, and allows you to implement more
    robust transaction management.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个与之前创建的数据库引擎绑定的异步数据库会话工厂，以异步连接到你的 Postgres 实例。使用 `autocommit=false` 禁用事务的自动提交，使用
    `autoflush=False` 禁用更改自动刷新到数据库。禁用这两种行为可以给你更多的控制权，有助于防止意外的数据更新，并允许你实现更健壮的事务管理。
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO4-2)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_integrating_databases_into_ai_services_CO4-2]'
- en: Define a dependency function to reuse and inject across your FastAPI app into
    route controller functions. Since the function uses the `yield` keyword within
    the `async with`, it is considered an async context manager. FastAPI will internally
    decorate the `get_db_session` as context manager when it is used as a dependency.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个依赖函数，以便在您的 FastAPI 应用程序中将它重用和注入到路由控制器函数中。由于该函数在 `async with` 中使用了 `yield`
    关键字，因此它被视为异步上下文管理器。当它作为依赖项使用时，FastAPI 会将其内部装饰为上下文管理器 `get_db_session`。
- en: '[![3](assets/3.png)](#co_integrating_databases_into_ai_services_CO4-3)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_integrating_databases_into_ai_services_CO4-3]'
- en: Use the database session factory to create an async session. The context manager
    helps to manage the database session lifecycle such as opening, interacting with,
    and closing the database connections in each session.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库会话工厂创建异步会话。上下文管理器有助于管理数据库会话的生命周期，例如在每个会话中打开、交互和关闭数据库连接。
- en: '[![4](assets/4.png)](#co_integrating_databases_into_ai_services_CO4-4)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_integrating_databases_into_ai_services_CO4-4]'
- en: Yield the database session to the caller of the `get_db_session` function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据库会话传递给 `get_db_session` 函数的调用者。
- en: '[![5](assets/5.png)](#co_integrating_databases_into_ai_services_CO4-5)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)[#co_integrating_databases_into_ai_services_CO4-5]'
- en: If there are any exceptions, roll back the transaction and reraise the exception.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何异常，请回滚事务并重新抛出异常。
- en: '[![6](assets/6.png)](#co_integrating_databases_into_ai_services_CO4-6)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png)[#co_integrating_databases_into_ai_services_CO4-6]'
- en: In any case, close the database session at the end to release any resources
    that it holds.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，最后都要关闭数据库会话以释放它所持有的任何资源。
- en: '[![7](assets/7.png)](#co_integrating_databases_into_ai_services_CO4-7)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![7](assets/7.png)[#co_integrating_databases_into_ai_services_CO4-7]'
- en: Declare an annotated database session dependency that can be reused across different
    controllers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个可跨不同控制器重用的带注释的数据库会话依赖项。
- en: Now that you can create a database session from any FastAPI route via dependency
    injection, let’s implement the create, read, update, and delete (CRUD) endpoints
    for the conversations resource.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以通过依赖注入从任何 FastAPI 路由创建数据库会话，让我们为对话资源实现创建、读取、更新和删除（CRUD）端点。
- en: Implementing CRUD Endpoints
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现CRUD端点
- en: As FastAPI relies on Pydantic to serialize and validate incoming and outgoing
    data, before implementing CRUD endpoints, you’ll need to map database entities
    to Pydantic models. This avoids tightly coupling your API schema with your database
    models to give you the freedom and flexibility in developing your API and databases
    independent of each other.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 FastAPI 依赖于 Pydantic 来序列化和验证传入和传出的数据，在实现 CRUD 端点之前，您需要将数据库实体映射到 Pydantic
    模型。这避免了将您的 API 架构与数据库模型紧密耦合，从而为您在独立于彼此的情况下开发 API 和数据库提供了自由和灵活性。
- en: You can follow [Example 7-5](#sqlalchemy_pydantic) to define your CRUD schemas.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以遵循[示例 7-5](#sqlalchemy_pydantic) 来定义您的 CRUD 模式。
- en: Example 7-5\. Declaring Pydantic API schemas for conversation endpoints
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-5\. 声明对话端点的 Pydantic API 模式
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO5-1)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_integrating_databases_into_ai_services_CO5-1]'
- en: Set up the Pydantic model to read and validate attributes of other models like
    SQLAlchemy, which is often used in Pydantic when working with database models.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Pydantic 模型以读取和验证其他模型（如 SQLAlchemy）的属性，这在处理数据库模型时在 Pydantic 中经常使用。
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO5-2)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_integrating_databases_into_ai_services_CO5-2]'
- en: Create separate Pydantic models based on the base model for different use cases
    such as conversation record creation and update, or data retrieval.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 根据基础模型创建不同的 Pydantic 模型，以适应不同的用例，例如对话记录的创建和更新，或数据检索。
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Having to declare Pydantic and SQLAlchemy models may feel like code duplication
    but will allow you to implement your data access layer however you like.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 声明 Pydantic 和 SQLAlchemy 模型可能感觉像是代码重复，但它将允许您以您喜欢的任何方式实现数据访问层。
- en: Alternatively, if you want to avoid any code duplication, you can leverage the
    `sqlmodel` package, which integrates Pydantic with SQLAlchemy, removing much of
    the code duplication. However, bear in mind that `sqlmodel` may not be ideal for
    production due to limited flexibility and support for advanced use cases with
    SQLAlchemy. Therefore, you may want to use separate Pydantic and SQLAlchemy models
    for complex applications.^([1](ch07.html#id951))
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想避免任何代码重复，可以利用`sqlmodel`包，该包将Pydantic与SQLAlchemy集成，从而减少了大量的代码重复。然而，请注意，由于灵活性和对SQLAlchemy高级用例的支持有限，`sqlmodel`可能不适合生产环境。因此，你可能希望为复杂应用程序使用独立的Pydantic和SQLAlchemy模型。^([1](ch07.html#id951))
- en: Now that you have the SQLAlchemy and Pydantic models, you can start developing
    your CRUD API endpoints.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了SQLAlchemy和Pydantic模型，你可以开始开发你的CRUD API端点。
- en: When implementing CRUD endpoints, you should try to leverage FastAPI dependencies
    as much as you can to reduce database round-trips. For instance, when retrieving,
    updating, and deleting records, you need to check in with the database that a
    record exists using its ID.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现CRUD端点时，你应该尽可能利用FastAPI依赖项来减少数据库往返次数。例如，在检索、更新和删除记录时，你需要使用其ID检查数据库中是否存在记录。
- en: You can implement a record retrieval function to use a dependency across your
    get, update, and delete endpoints, as shown in [Example 7-6](#sqlalchemy_endpoints).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以实现一个记录检索函数，在获取、更新和删除端点中使用依赖项，如[示例7-6](#sqlalchemy_endpoints)所示。
- en: Warning
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Bear in mind that FastAPI can only cache the output of the `get_conversation`
    dependency within a single request and not across multiple requests.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，FastAPI只能在单个请求内缓存`get_conversation`依赖项的输出，而不能跨多个请求。
- en: Example 7-6\. Implementing resource-based CRUD endpoints for the `conversations`
    table
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例7-6\. 为`conversations`表实现基于资源的CRUD端点
- en: '[PRE6]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO6-1)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO6-1)'
- en: Define a dependency to check if the conversation record exists. Raise a 404
    `HTTPException` if a record is not found; otherwise, return the retrieved record.
    This dependency can be reused across several CRUD endpoints through dependency
    injection.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个依赖项以检查会话记录是否存在。如果找不到记录，则引发404 `HTTPException`；否则，返回检索到的记录。这个依赖项可以通过依赖注入在多个CRUD端点之间重用。
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO6-2)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO6-2)'
- en: Begin the async session within an async context manager during each request.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个请求中，在异步上下文中开始异步会话。
- en: '[![3](assets/3.png)](#co_integrating_databases_into_ai_services_CO6-3)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_integrating_databases_into_ai_services_CO6-3)'
- en: When listing records, it’s more efficient to retrieve only a subset of records.
    By default, SQLAlchemy ORM returns a subset of most recent records in the database,
    but you can use the `.offset(skip)` and `.limit(take)` chained methods to retrieve
    any subset of records.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当列出记录时，只检索记录的子集会更有效率。默认情况下，SQLAlchemy ORM返回数据库中最新的记录子集，但你可以使用`.offset(skip)`和`.limit(take)`链式方法检索任何记录子集。
- en: '[![4](assets/4.png)](#co_integrating_databases_into_ai_services_CO6-4)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_integrating_databases_into_ai_services_CO6-4)'
- en: Create a Pydantic model from a SQLAlchemy model using `model_validate()`. Raises
    a `ValidationError` if the SQLAlchemy object passed can’t be created or doesn’t
    pass Pydantic’s data validation checks.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`model_validate()`从SQLAlchemy模型创建Pydantic模型。如果传递给SQLAlchemy的对象无法创建或未通过Pydantic的数据验证检查，则引发`ValidationError`。
- en: '[![5](assets/5.png)](#co_integrating_databases_into_ai_services_CO6-5)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_integrating_databases_into_ai_services_CO6-5)'
- en: For operations that mutate a record (i.e., create, update, and delete), commit
    the transaction then send the refreshed record to the client, except for the successful
    delete operation that should return `None`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于会修改记录的操作（即创建、更新和删除），提交事务然后将刷新后的记录发送给客户端，除了成功的删除操作应该返回`None`。
- en: Notice how the controller logic is simplified through this dependency injection
    approach.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意通过这种依赖注入方法如何简化了控制器逻辑。
- en: Additionally, pay attention to success status codes you should to send to the
    client. Successful retrieval operations should return 200, while record creation
    operations return 201, updates return 202, and deletions return 204.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意您应该发送给客户端的成功状态码。成功的检索操作应返回200，而记录创建操作返回201，更新返回202，删除返回204。
- en: Congratulations! You now have a resource-based RESTful API that you can use
    to perform CRUD operations on your `conversations` table.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在拥有了一个基于资源的RESTful API，你可以用它来对你的`conversations`表执行CRUD操作。
- en: Now that you can implement CRUD endpoints, let’s refactor the existing code
    examples to use the *repository and services* design pattern you learned about
    in [Chapter 2](ch02.html#ch02). With this design pattern, you can abstract the
    database operations to achieve a more modular, maintainable, and testable codebase.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以实施CRUD端点，让我们重构现有的代码示例，以使用你在[第2章](ch02.html#ch02)中学到的*存储库和服务*设计模式。使用这种设计模式，你可以抽象数据库操作，以实现更模块化、可维护和可测试的代码库。
- en: Repository and Services Design Pattern
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储库和服务设计模式
- en: A *repository* is a design pattern that mediates the business logic of your
    application and the database access layer—for instance, via an ORM. It contains
    several methods for performing CRUD operations in the database layer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*存储库*是一种设计模式，它协调应用程序的业务逻辑和数据库访问层——例如，通过ORM。它包含执行数据库层CRUD操作的方法。'
- en: In [Chapter 2](ch02.html#ch02), you first saw [Figure 7-4](#onion), which showed
    where the repositories sit within the onion/layered application architecture when
    working with a database.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html#ch02)中，你首先看到了[图7-4](#onion)，它展示了在处理数据库时，存储库在洋葱/分层应用架构中的位置。
- en: '![bgai 0704](assets/bgai_0704.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0704](assets/bgai_0704.png)'
- en: Figure 7-4\. The repository pattern within the onion/layered application architecture
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-4. 在洋葱/分层应用架构中的存储库模式
- en: To implement a repository pattern, you can use an *abstract interface*, which
    enforces certain constraints on how you define your specific repository classes
    as you can see in [Example 7-7](#sqlalchemy_repository).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现存储库模式，你可以使用一个*抽象接口*，它强制你以特定的方式定义你的存储库类，正如你在[示例7-7](#sqlalchemy_repository)中看到的那样。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’ve never used *abstract* classes, they’re classes that can’t be instantiated
    on their own. Abstract classes can contain methods without implementation that
    its subclasses must implement.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未使用过*抽象*类，它们是那些不能独立实例化的类。抽象类可以包含没有实现的方法，其子类必须实现这些方法。
- en: A concrete class is one that inherits an abstract class and implements each
    of its abstract methods.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 具体类是继承自抽象类并实现其所有抽象方法的类。
- en: Example 7-7\. Implementing a repository abstract interface
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例7-7. 实现存储库抽象接口
- en: '[PRE7]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO7-1)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO7-1)'
- en: Define the abstract `Repository` interface with several CRUD-related abstract
    method signatures that subclasses must implement. If an abstract method is not
    implemented in a concrete subclass, a `NotImplementedError` will be raised.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 定义具有几个与CRUD相关的抽象方法签名的抽象`Repository`接口。如果具体子类中没有实现抽象方法，将引发`NotImplementedError`。
- en: Now that you have a `Repository` class, you declare subclasses for each of your
    tables to define how database operations must be performed following the CRUD-based
    methods. For instance, to perform CRUD operations on the conversation records
    in the database, you can implement a concrete `ConversationRepository` class,
    as shown in [Example 7-8](#sqlalchemy_conversation_repository).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个`Repository`类，你为每个表声明子类以定义必须遵循基于CRUD的方法来执行数据库操作。例如，要执行数据库中对话记录的CRUD操作，你可以实现一个具体的`ConversationRepository`类，如[示例7-8](#sqlalchemy_conversation_repository)所示。
- en: Example 7-8\. Implementing the conversation repository using the abstract repository
    interface
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例7-8. 使用抽象存储库接口实现对话存储库
- en: '[PRE8]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO8-1)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO8-1)'
- en: Inherit the abstract `Repository` interface and implement each of its methods
    while adhering to the method signatures.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 继承抽象`Repository`接口并实现其每个方法，同时遵守方法签名。
- en: You have now moved the database logic for conversations into the `ConversationRepository`.
    This means you can now import this class into your route controller functions
    and start using it right away.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经将对话的数据库逻辑移动到了`ConversationRepository`。这意味着你现在可以将其导入到你的路由控制器函数中并立即开始使用它。
- en: Go back to your `main.py` file and refactor your route controllers to use the
    `ConversationRepository`, as shown in [Example 7-9](#sqlalchemy_conversation_repository_endpoints).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 回到你的`main.py`文件，重构你的路由控制器以使用`ConversationRepository`，如[示例7-9](#sqlalchemy_conversation_repository_endpoints)所示。
- en: Example 7-9\. Refactoring the conversation CRUD endpoints to use the repository
    pattern
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-9\. 将会话 CRUD 端点重构为使用存储库模式
- en: '[PRE9]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO9-1)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO9-1)'
- en: Place conversation CRUD routes on a separate API router and include on the FastAPI
    application for modular API design.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将会话 CRUD 路由放置在单独的 API 路由器上，并将其包含在 FastAPI 应用程序中，以实现模块化 API 设计。
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO9-2)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO9-2)'
- en: Refactor conversation CRUD routes to use the repository pattern for more readable
    controller implementation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将会话 CRUD 路由重构为使用存储库模式，以实现更易读的控制器实现。
- en: Do you notice how cleaner your route controllers appear now that the database
    logic has been abstracted within the `ConversationRepository` class?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，自从数据库逻辑被抽象到 `ConversationRepository` 类中后，你的路由控制器看起来更加整洁了？
- en: You can take this approach one step further and implement a service pattern
    as well. A *service* pattern is an extension of the repository pattern that encapsulates
    the business logic and operations in a higher layer. These higher-level operations
    often require more complex queries and a sequence of CRUD operations to be performed
    to implement the business logic.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这种方法进一步发展，并实现一个服务模式。*服务*模式是存储库模式的扩展，它将业务逻辑和操作封装在更高层。这些高级操作通常需要更复杂的查询和一系列
    CRUD 操作来执行业务逻辑。
- en: As an example, you can implement a `ConversationService` to fetch messages related
    to a conversation or a specific user (see [Example 7-10](#sqlalchemy_conversation_service)).
    Since it extends a `ConversationRepository`, you can still access the lower-level
    data access CRUD methods such as `list`, `get`, `create`, `update`, and `delete`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以实现一个 `ConversationService` 来获取与某个会话或特定用户相关的消息（参见[示例 7-10](#sqlalchemy_conversation_service)）。由于它扩展了
    `ConversationRepository`，你仍然可以访问底层的数据访问 CRUD 方法，如 `list`、`get`、`create`、`update`
    和 `delete`。
- en: Once again you can go back to your controllers and replace references to the
    `ConversationRepository` with the `ConversationService` instead. Additionally,
    you can use the same service to add a new endpoint for fetching messages within
    a single conversation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回到你的控制器中，你可以将 `ConversationRepository` 的引用替换为 `ConversationService`。此外，你可以使用相同的服务来添加一个新端点，用于获取单个会话中的消息。
- en: Example 7-10\. Implementing the conversation services pattern
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-10\. 实现会话服务模式
- en: '[PRE10]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO10-1)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO10-1)'
- en: Add a new endpoint to list messages of a conversation using the conversation
    ID.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新端点，使用会话 ID 列出会话的消息。
- en: You now have a fully working RESTful API for interacting with your conversation
    data following the repository and service patterns.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经根据存储库和服务模式实现了与你的会话数据交互的完整 RESTful API。
- en: Tip
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Now that you’re more familiar with the repository and services pattern, you
    can try implementing CRUD endpoints for the `messages` table.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对存储库和服务模式更加熟悉了，你可以尝试为 `messages` 表实现 CRUD 端点。
- en: When using the repository and service patterns, be mindful that you avoid tightly
    coupling your services to specific repository implementation and not overload
    your services with many responsibilities. Keep repositories focused on data access
    and manipulation and avoid placing business logic in them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用存储库和服务模式时，请注意避免将你的服务与特定的存储库实现紧密耦合，并不要让服务承担过多的责任。保持存储库专注于数据访问和操作，并避免在其中放置业务逻辑。
- en: You’ll also need to handle database transactions and exceptions properly, especially
    when performing multiple related operations. Also, consider performance implications
    of your queries such as including many JOINs, and optimize queries where you can.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要正确处理数据库事务和异常，尤其是在执行多个相关操作时。此外，考虑查询的性能影响，例如包含多个 JOIN，并在可能的情况下优化查询。
- en: Good practice is to use consistent naming conventions for your methods and classes
    and to avoid hard-coding configuration settings.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的做法是使用一致的命名约定为你的方法和类命名，并避免硬编码配置设置。
- en: There is one more aspect of the database development workflow that we need to
    address next. That is managing ever-changing database schemas, in particular in
    collaborative teams where multiple people are working on the same database both
    in development and production environments.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库开发工作流程中还有一个方面我们需要接下来解决。那就是管理不断变化的数据库模式，特别是在协作团队中，多个人在开发和生产环境中都在同一个数据库上工作。
- en: Managing Database Schemas Changes
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理数据库模式变更
- en: You must have noticed that in [Example 7-3](#sqlalchemy_engine) you are deleting
    and re-creating your database tables every time you start your FastAPI server.
    This is acceptable for development workflows during the prototyping stage, but
    not at all when you need to deploy your services in production with active users.
    You can’t reset your database from scratch every time you update your database
    schema.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定注意到了，在 [示例 7-3](#sqlalchemy_engine) 中，每次你启动 FastAPI 服务器时，你都会删除并重新创建你的数据库表。这在原型设计阶段的发展工作流程中是可以接受的，但在你需要将服务部署到具有活跃用户的实际生产环境中时则完全不适用。你每次更新数据库模式时都不能从头开始重置你的数据库。
- en: You also will probably need a way to revert changes if something breaks or if
    you decide to roll back certain features. To achieve this, you can use a database
    migration tool such as Alembic that is designed to work seamlessly with the SQLAlchemy
    ORM.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要一种方法来撤销更改，以防出现故障或你决定回滚某些功能。为了实现这一点，你可以使用 Alembic 这样的数据库迁移工具，它被设计成可以无缝地与
    SQLAlchemy ORM 一起工作。
- en: Alembic allows you to version control your database schemas the same way that
    tools like Git can help you version control your code. They’re extremely useful
    when you’re working in a team with multiple application environments and need
    to keep track of changes or revert updates as needed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Alembic 允许你以与 Git 等工具帮助你版本控制代码相同的方式版本控制你的数据库模式。当你在具有多个应用程序环境的团队中工作时，它们非常有用，需要跟踪更改或根据需要撤销更新。
- en: To get started, you must first install `alembic` via `pip` and then initialize
    it by running [Example 7-11](#alembic_init) at the root of your FastAPI project.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你必须首先通过 `pip` 安装 `alembic`，然后在 FastAPI 项目的根目录下运行 [示例 7-11](#alembic_init)
    来初始化它。
- en: Example 7-11\. Initializing an Alembic environment
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-11\. 初始化 Alembic 环境
- en: '[PRE11]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Alembic will create its environment within the `alembic` folder with several
    files and a `versions` directory, as shown in [Example 7-12](#alembic_dir).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Alembic 将在其 `alembic` 文件夹内创建其环境，包括几个文件和一个 `versions` 目录，如图 [示例 7-12](#alembic_dir)
    所示。
- en: Example 7-12\. Alembic environment within your project root directory
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-12\. 项目根目录内的 Alembic 环境
- en: '[PRE12]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO11-1)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_integrating_databases_into_ai_services_CO11-1]'
- en: An environment file for specifying target schema and database connections
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 用于指定目标模式和数据库连接的环境文件
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO11-2)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_integrating_databases_into_ai_services_CO11-2]'
- en: A directory for holding *migrations* files, which specify the instructions on
    how to update or revert the database schema
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于存放 *迁移* 文件的目录，这些文件指定了如何更新或撤销数据库模式
- en: Once the Alembic environment is generated, open and modify the *env.py* file
    located in the `alembic` directory, as shown in [Example 7-13](#alembic_env),
    so that it gets access to your SQLAlchemy metadata object that contains the target
    schema information.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了 Alembic 环境，打开并修改位于 `alembic` 目录下的 *env.py* 文件，如图 [示例 7-13](#alembic_env)
    所示，以便它能够访问包含目标模式信息的 SQLAlchemy 元数据对象。
- en: Example 7-13\. Connect the Alembic environment with your SQLAlchemy models
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-13\. 将 Alembic 环境与 SQLAlchemy 模型连接
- en: '[PRE13]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With Alembic connected to your SQLAlchemy models, Alembic can now auto-generate
    your migration files by comparing the current schema of your database with your
    SQLAlchemy models:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Alembic 连接到你的 SQLAlchemy 模型后，Alembic 现在可以通过比较你的数据库当前模式与 SQLAlchemy 模型来自动生成迁移文件：
- en: '[PRE14]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This command will compare the defined SQLAlchemy models against the existing
    database schema and automatically generate a SQL migration file under the `alembic/versions`
    directory.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将比较定义的 SQLAlchemy 模型与现有数据库模式，并在 `alembic/versions` 目录下自动生成一个 SQL 迁移文件。
- en: If you open the generated migration file, you should see a file content similar
    to [Example 7-14](#alembic_initial_migration).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开生成的迁移文件，你应该会看到一个类似 [示例 7-14](#alembic_initial_migration) 的文件内容。
- en: Example 7-14\. The initial Alembic migration
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-14\. 初始 Alembic 迁移
- en: '[PRE15]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that you’ve updated your first migration file, you’re ready to run it against
    the database:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更新了第一个迁移文件，你就可以运行它来对数据库进行操作：
- en: '[PRE16]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If your ever need to revert the operation, you can run `alembic downgrade` instead.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要回滚操作，可以运行`alembic downgrade`。
- en: What Alembic does under the hood is to generate the raw SQL needed to run or
    revert a migration and create an `alembic_versions` table in the database. It
    uses this table to keep track of migrations that have already been applied on
    your database so that rerunning the `alembic upgrade head` command won’t perform
    any duplicate migrations.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Alembic在底层执行的操作是生成运行或回滚迁移所需的原始SQL，并在数据库中创建一个`alembic_versions`表。它使用这个表来跟踪已经应用在您的数据库上的迁移，这样再次运行`alembic
    upgrade head`命令就不会执行任何重复的迁移。
- en: If in any case, your database schemas and your migration history drift away,
    you can always remove files from the `versions` directory and truncate the `alembic_revision`
    table. Then reinitialize Alembic to start with a fresh environment against an
    existing database.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何情况下，您的数据库模式和迁移历史发生了偏移，您始终可以删除`versions`目录中的文件并截断`alembic_revision`表。然后重新初始化Alembic，以全新的环境开始对现有数据库进行操作。
- en: Warning
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: After migrating a database with a migration file, make sure to commit to a Git
    repository. Avoid re-editing migration files after migrating a database as Alembic
    will skip existing migrations by cross-checking them with its versioning table.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用迁移文件迁移数据库后，请确保将其提交到Git仓库。避免在迁移数据库后重新编辑迁移文件，因为Alembic将通过与其版本控制表交叉检查来跳过现有的迁移。
- en: If a migration file has already been run, it won’t detect changes in its content.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迁移文件已经运行，它将不会检测其内容的变化。
- en: To update your database schema, create a new migration file instead.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新数据库模式，请创建一个新的迁移文件。
- en: Following the aforementioned workflow will now allow you to not only version
    control your database schemas but also manage changes to your production environments
    as your application requirements change.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 按照上述工作流程，现在不仅可以版本控制数据库模式，还可以在应用程序需求变化时管理生产环境中的更改。
- en: Storing Data When Working with Real-Time Streams
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在处理实时流时存储数据
- en: You should now be in a position to implement your own CRUD endpoints to retrieve
    and mutate both user conversation and message records in your database.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够实现自己的CRUD端点，以检索和修改数据库中的用户对话和消息记录。
- en: One question that remains unanswered is how to handle transactions within data
    streaming endpoints, such as an LLM streaming outputs to a client.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个悬而未决的问题是，如何在数据流式传输端点中处理事务，例如LLM将流式输出到客户端。
- en: You can’t stream data into a traditional relational database as ensuring ACID
    compliance with streaming transactions will prove challenging. Instead, you will
    want to perform your standard database operation as soon as your FastAPI server
    returns a response to the client. This challenge is exactly what a FastAPI’s background
    task can solve, as you can see in [Example 7-15](#db_stream).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法将数据流式传输到传统的关系型数据库，因为确保流式事务的ACID兼容性将是一项挑战。相反，您将希望尽快执行标准数据库操作，一旦FastAPI服务器向客户端返回响应。这正是FastAPI的后台任务可以解决的问题，正如您在[示例7-15](#db_stream)中看到的那样。
- en: Example 7-15\. Storing content of an LLM output stream
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例7-15\. 存储LLM输出流的内 容
- en: '[PRE17]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_integrating_databases_into_ai_services_CO12-1)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_integrating_databases_into_ai_services_CO12-1]'
- en: Create a function to store a message against a conversation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个函数来存储与对话相关的消息。
- en: '[![2](assets/2.png)](#co_integrating_databases_into_ai_services_CO12-2)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_integrating_databases_into_ai_services_CO12-2]'
- en: Check that the conversation record exists and fetch it within a dependency.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 检查对话记录是否存在，并在依赖关系中获取它。
- en: '[![3](assets/3.png)](#co_integrating_databases_into_ai_services_CO12-3)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_integrating_databases_into_ai_services_CO12-3]'
- en: Create two separate copies of the LLM stream, one for the `StreamingResponse`
    and another to process in a background task.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 创建LLM流的两个单独副本，一个用于`StreamingResponse`，另一个用于后台任务处理。
- en: '[![4](assets/4.png)](#co_integrating_databases_into_ai_services_CO12-4)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_integrating_databases_into_ai_services_CO12-4]'
- en: Create a background task to store the message after the `StreamingResponse`
    is finished.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StreamingResponse`完成后创建一个后台任务来存储消息。
- en: In [Example 7-15](#db_stream), you allow FastAPI to fully stream the LLM response
    to the client.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例7-15](#db_stream)中，您允许FastAPI完全将LLM响应流式传输到客户端。
- en: It won’t matter whether you’re using an SSE or WebSocket endpoint. Once a request
    a response is fully streamed, invoke a background task passing in the full stream
    response content. Within the background task, you can then run a function to store
    the message after the request is sent, with the full LLM response content.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用的是 SSE 还是 WebSocket 端点，都不会有任何区别。一旦请求和响应完全流式传输，调用一个后台任务，传入完整的流式响应内容。在后台任务中，你可以在请求发送后运行一个函数来存储消息，并带有完整的
    LLM 响应内容。
- en: Using the same approach, you can even generate a title for a conversation based
    on the content of the first message. To do this, you can invoke the LLM again
    with the content of the first message in the conversation, requesting for an appropriate
    title for the conversation. Once a conversation title is generated, you can create
    the conversation record in the database, as shown in [Example 7-16](#conversation_title).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的方法，你甚至可以根据第一条消息的内容为对话生成一个标题。为此，你可以再次调用 LLM，使用对话中第一条消息的内容，请求为对话提供一个合适的标题。一旦生成了对话标题，你可以在数据库中创建对话记录，如[示例
    7-16](#conversation_title)所示。
- en: Example 7-16\. Using the LLM to generate conversation titles based on the initial
    user prompt
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-16\. 使用 LLM 根据初始用户提示生成对话标题
- en: '[PRE18]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using SQLAlchemy with Alembic is a tried and tested approach to working with
    relational databases in FastAPI, so you’re more likely to find a lot of resources
    on integrating these technologies.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FastAPI 中使用 SQLAlchemy 与 Alembic 是一种经过验证和测试的方法来处理关系型数据库，因此你更有可能找到很多关于集成这些技术的资源。
- en: Both the SQLAlchemy ORM and Alembic allow you to interact with your database
    and control the changes to its schemas.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy ORM 和 Alembic 都允许你与数据库交互并控制其模式的变化。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you dove into the critical aspects of integrating a database
    into your FastAPI application to store and retrieve user conversations.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你深入探讨了将数据库集成到你的 FastAPI 应用程序中以存储和检索用户对话的关键方面。
- en: You learned to identify when a database is necessary and how to identify the
    appropriate type for your project, whether it be relational or nonrelational.
    By understanding the underlying mechanisms of relational databases and the use
    cases for nonrelational databases, you’re now equipped to make informed decisions
    about database selection.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你学会了如何识别何时需要数据库以及如何为你的项目选择合适的数据库类型，无论是关系型还是非关系型。通过理解关系型数据库的底层机制和非关系型数据库的使用场景，你现在可以做出关于数据库选择的明智决策。
- en: You also explored the development workflow, tooling, and best practices for
    working with relational databases. This includes learning techniques to improve
    query performance and efficiency, as well as strategies for managing evolving
    database schema changes. Additionally, you gained insights into managing codebase,
    database schema, and data drifts when working in teams.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你还探索了与关系型数据库一起工作的开发工作流程、工具和最佳实践。这包括学习提高查询性能和效率的技术，以及管理数据库模式变化的策略。此外，你在团队工作中获得了关于管理代码库、数据库模式和数据漂移的见解。
- en: As you move forward, the next chapter will guide you through implementing user
    management, authentication, and authorization mechanisms. This will further enhance
    your application’s security and user experience, building on the solid database
    foundation you’ve established in this chapter.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你继续前进，下一章将指导你实现用户管理、身份验证和授权机制。这将进一步增强你的应用程序的安全性并提升用户体验，基于你在本章中建立的稳固数据库基础。
- en: ^([1](ch07.html#id951-marker)) Refer to this [reddit discussion thread](https://oreil.ly/OMaOT).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.html#id951-marker)) 请参阅此 [reddit 讨论线程](https://oreil.ly/OMaOT)。
