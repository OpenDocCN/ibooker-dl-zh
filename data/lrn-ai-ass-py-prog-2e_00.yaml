- en: 1 Introducing AI-assisted programming with GitHub Copilot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 使用GitHub Copilot介绍AI辅助编程
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: How AI assistants change how new programmers learn
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AI助手如何改变新程序员的学习方式
- en: Why programming is never going to be the same
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么编程永远不会一成不变
- en: How AI assistants such as GitHub Copilot work
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用GitHub Copilot等AI助手工作
- en: Possible perils of AI-assisted programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AI辅助编程的可能风险
- en: Computer programming has long been the domain of professionals with special
    training and advanced skills. After all, you want the applications running your
    bank, phone, car, and so on to work exactly right every time! Just as room-sized
    computers with stacks of paper cards and miles of magnetic tape have been replaced
    by modern devices, programming languages and tools have also become easier to
    use. And now, artificial intelligence (AI) tools such as ChatGPT put computer
    programming within the reach of almost everyone. We want to help open this door
    for you!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机编程长期以来一直是受过特殊培训并拥有高级技能的专业人士的领域。毕竟，你希望运行银行、电话、汽车等应用的程序每次都能完全正确地运行！正如曾经占据房间大小的计算机，堆满纸卡片和数英里长的磁带被现代设备所取代一样，编程语言和工具也变得更容易使用。现在，像ChatGPT这样的AI工具让计算机编程几乎对每个人来说都触手可及。我们希望帮助你打开这扇门！
- en: Learn how to program, and you’ll be able to take on new tasks at work, create
    your own computer games, and put the computer to work for you at your job. In
    this book, we’ll show you how to write your own computer programs using ChatGPT
    and GitHub Copilot. Along the way, you’ll learn some skills in Python, one of
    the most popular programming languages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何编程，你将能够承担工作中的新任务，创建自己的电脑游戏，并在工作中让电脑为你工作。在这本书中，我们将向你展示如何使用ChatGPT和GitHub
    Copilot编写自己的计算机程序。在这个过程中，你将学习一些Python编程语言中的技能，Python是最受欢迎的编程语言之一。
- en: 1.1 Improving how we talk to computers
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 改善我们与计算机的交流方式
- en: 'Let’s start by asking a computer to count from 0 to 9\. Decades ago, a book
    about programming would have asked you to learn how to read and understand the
    following code (based on [https://mng.bz/EOdO](https://mng.bz/EOdO)):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先请计算机从0数到9。几十年前，一本关于编程的书会要求你学习如何阅读和理解以下代码（基于[https://mng.bz/EOdO](https://mng.bz/EOdO)）：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’re glad that’s not how we program anymore. That monstrosity was written using
    code in assembly language, a low-level programming language. Low-level programming
    languages, as you can see, aren’t languages that humans can easily read and write.
    They’re designed for computers, not humans.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很高兴我们不再是这样编程的。那个怪物是用汇编语言编写的，汇编语言是一种低级编程语言。正如你所见，低级编程语言并不是人类可以轻松阅读和编写的语言。它们是为计算机设计的，而不是为人类设计的。
- en: No one wants to write programs like that, but, especially in the past, it was
    sometimes necessary. Programmers could use it to define exactly what they wanted
    the computer to do, down to individual instructions. This level of control was
    needed to squeeze every bit of performance out of underpowered computers. For
    example, the most speed-critical pieces of 1990s computer games, such as Doom
    and Quake, were written in assembly language like the previous code example. It
    wouldn’t have been possible to make those games otherwise.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人想编写那样的程序，但，特别是在过去，有时这是必要的。程序员可以使用它来精确定义他们希望计算机执行的操作，甚至到单个指令。这种程度的控制是必要的，以便从性能不足的计算机中榨取每一丝性能。例如，90年代最速度关键的电脑游戏，如Doom和Quake，就是用汇编语言编写的，就像之前的代码示例一样。否则，制作那些游戏是不可能的。
- en: 1.1.1 Making it a little easier
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 让它变得稍微容易一些
- en: Okay, let’s move on. Here’s a more modern computer program that also prints
    numbers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续前进。这是一个更现代的计算机程序，它也会打印数字。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code is in the Python language, which is what many programmers use these
    days. Unlike assembly language, which is a low-level language, Python is considered
    a high-level language because it’s much closer to natural language. Even though
    you don’t know about Python code yet, you might be able to guess what this program
    is trying to do. The first line looks like it’s doing something with the range
    of numbers from 0 to 9\. The second line is printing something. It’s not too hard
    to believe that this program, just like the assembly language monstrosity, is
    supposed to print the numbers 0 to 9\. Unfortunately, something is wrong, and
    it prints the numbers 0 to 8 instead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是用Python语言编写的，这是许多程序员现在使用的语言。与低级语言汇编语言不同，Python被认为是一种高级语言，因为它与自然语言更加接近。即使你还不了解Python代码，你也可能猜出这个程序试图做什么。第一行看起来像是在处理从0到9的数字范围。第二行是在打印某些内容。相信这个程序，就像汇编语言的怪物一样，旨在打印从0到9的数字并不困难。不幸的是，出了点问题，它只打印了0到8的数字。
- en: While this code is closer to English, it isn’t English. It’s a programming language
    that, like assembly language, has specific rules. As in the previous code, misunderstanding
    the details of those rules can result in a broken program. If you’re curious,
    the misunderstood rule was that the `range` function stops one before the second
    number provided, so it doesn’t include the number 9\. If you wanted 0 through
    9, you’d need to say `range(0,10)`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码更接近英语，但它并不是英语。它是一种像汇编语言一样的编程语言，具有特定的规则。就像之前的代码一样，误解这些规则的细节可能会导致程序出错。如果你好奇，误解的规则是`range`函数在第二个数字之前停止，所以它不包括数字9。如果你想从0到9，你需要说`range(0,10)`。
- en: The holy grail of communicating with a computer is to do so in a natural language
    such as English. We’ve been talking to computers using various programming languages
    over the past 80 years not because we want to but because we have to. Computers
    were simply not powerful enough for the vagaries and idiosyncrasies of a language
    like English. Our programming languages improved—from symbol-soup assembly language
    to Python, for example—but they are still computer languages, not natural languages.
    This is changing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与计算机进行交流的圣杯是使用像英语这样的自然语言。在过去80年里，我们使用各种编程语言与计算机交谈，并不是因为我们想这么做，而是因为我们不得不这么做。计算机的运算能力不足以处理像英语这样的语言的复杂性和特殊性。我们的编程语言从符号汤汇编语言发展到例如Python，但它们仍然是计算机语言，而不是自然语言。这种状况正在改变。
- en: 1.1.2 Making it a lot easier
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 使其变得更加容易
- en: 'Using an AI assistant, we can now ask for what we want in English and have
    the computer code written for us in response. To get a correct Python program
    that prints the numbers from 0 to 9, we can ask our AI assistant (Copilot) in
    normal English language like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用人工智能助手，我们现在可以用英语提出我们想要的内容，并让计算机为我们编写相应的代码。为了得到一个正确打印从0到9的Python程序，我们可以用正常的英语语言向我们的AI助手（Copilot）提出如下请求：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Copilot might respond to this prompt by generating something like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot可能会对此提示做出如下回应：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unlike the example we showed you before, this piece of Python code actually
    works!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前展示的例子不同，这段Python代码实际上是可以运行的！
- en: AI coding assistants can be used to help people write code. In this book, we’ll
    learn how to use Copilot to write code for us. We’ll ask for what we want in English
    and get the code back in Python.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能编码助手可以帮助人们编写代码。在这本书中，我们将学习如何使用Copilot为我们编写代码。我们可以用英语提出我们想要的内容，然后得到Python代码的回应。
- en: 'More than that, we’ll be able to use Copilot as a seamless part of our workflow.
    Without tools like Copilot, programmers routinely have two windows open: the one
    to write code and the other to ask Google how to write code. This second window
    has Google search results, Python documentation, or forums of programmers talking
    about how to write code to solve that particular problem. They’re often pasting
    code from these results into their code, then tweaking it slightly for their context,
    trying alternatives, and so on. This has become a way of life for programmers,
    but you can imagine the inefficiency here. By some estimates, up to 35% of programmers’
    time is spent searching for code [1], and much of the code that is found isn’t
    readily usable. Copilot greatly improves this experience by helping us write our
    code.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，我们还将能够将Copilot作为工作流程中无缝的一部分来使用。如果没有像Copilot这样的工具，程序员通常会打开两个窗口：一个用于编写代码，另一个用于询问Google如何编写代码。第二个窗口包含Google搜索结果、Python文档或程序员论坛，他们讨论如何编写代码来解决特定问题。他们经常将这些结果中的代码粘贴到他们的代码中，然后根据他们的上下文稍作修改，尝试其他替代方案等等。这已经成为程序员的一种生活方式，但你可以想象这里的低效。据估计，高达35%的程序员时间用于搜索代码[1]，而且找到的代码往往不易使用。Copilot通过帮助我们编写代码，极大地改善了这种体验。
- en: 1.2 About the technology
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 关于技术
- en: 'We’ll use two main technologies in this book: Python and GitHub Copilot. Python
    is the programming language that we’ll use, and GitHub Copilot is our AI assistant
    that will help us work with the Python code.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本书我们将使用两种主要技术：Python和GitHub Copilot。Python是我们将使用的编程语言，GitHub Copilot是我们的人工智能助手，它将帮助我们与Python代码一起工作。
- en: 1.2.1 Python, your programming language
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 Python，你的编程语言
- en: As mentioned, Python is a programming language, which is a way to communicate
    with a computer. People use it to write all kinds of programs that do useful things
    such as data analysis, games, interactive websites, visualizations, file organization
    apps, automating routine tasks, and so on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python是一种编程语言，它是与计算机进行交流的方式。人们用它编写各种程序，执行有用的任务，如数据分析、游戏、交互式网站、可视化、文件组织应用、自动化常规任务等等。
- en: There are other programming languages as well, such as Java, C++, Rust, and
    many others. Copilot works with those, too, but at the time of this writing, it
    works really well with Python. Python code is a lot easier to write compared to
    many other languages (especially assembly code). Even more importantly, Python
    is easy to *read*. After all, we’re not going to be the ones writing the Python
    code—our AI assistant is!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他编程语言，例如Java、C++、Rust以及许多其他语言。Copilot也可以与这些语言配合使用，但截至本书编写时，它与Python配合得非常好。与许多其他语言（尤其是汇编语言）相比，Python代码编写起来要容易得多。更重要的是，Python易于*阅读*。毕竟，我们不会是编写Python代码的人——我们的AI助手会！
- en: Computers don’t know how to read and run Python code. The only thing computers
    can understand is something called *machine code*, which looks even more ridiculous
    than assembly code because it’s the binary representation of the assembly code
    (yep, just a bunch of 0s and 1s!). Behind the scenes, your computer takes any
    Python code that you provide and converts it into machine code before it runs,
    as shown in figure 1.1.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机不知道如何读取和运行Python代码。计算机唯一能理解的是一种称为*机器码*的东西，它看起来甚至比汇编码还要荒谬，因为它实际上是汇编码的二进制表示（是的，只是一堆0和1！）。在幕后，你的计算机将你提供的任何Python代码转换为机器码，然后再运行，如图1.1所示。
- en: '![figure](../Images/1-1.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/1-1.png)'
- en: Figure 1.1 Your Python program goes through several steps before you see the
    output on your screen.
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1 你的Python程序在你在屏幕上看到输出之前要经过几个步骤。
- en: So, no one is writing code from scratch in the machine code language of computers
    anymore. Programmers are all picking the language that’s most convenient for their
    particular task at the time and using software to help them write, run, and debug
    (i.e., fix) the code, called an Integrated Development Environment (IDE). In the
    book, we’ll be using Visual Studio Code (VS Code) as our IDE because it works
    exceptionally well with GitHub Copilot.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在没有人再从零开始用计算机的机器码语言编写代码了。程序员们都会选择当时对他们特定任务最方便的语言，并使用软件来帮助他们编写、运行和调试（即修复）代码，这种软件被称为集成开发环境（IDE）。在本书中，我们将使用Visual
    Studio Code（VS Code）作为我们的IDE，因为它与GitHub Copilot配合得非常好。
- en: 1.2.2 GitHub Copilot, your AI assistant
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 GitHub Copilot，你的AI助手
- en: What is an AI assistant? An AI assistant is an AI agent that helps you get work
    done. Maybe you have an Amazon Alexa device at home or an iPhone with Siri—these
    are AI assistants. They help you order groceries, be aware of the weather, or
    determine that, yes, the woman who played Bellatrix in the *Harry Potter* movies
    really was in *Fight Club*. An AI assistant is just a computer program that responds
    to typical human inputs such as speech and text with human-like answers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 AI 助手？AI 助手是一种 AI 代理，它帮助你完成工作。也许你家里有 Amazon Alexa 设备或者一部带有 Siri 的 iPhone——这些是
    AI 助手。它们帮助你订购杂货，了解天气，或者确定，是的，在 *哈利·波特* 电影中扮演贝拉特里克斯的女演员真的在 *斗士俱乐部* 中出现过。AI 助手只是一个能够对典型的人类输入，如语音和文本，以类似人类的回答进行响应的计算机程序。
- en: 'Copilot is an AI assistant with a specific job: it converts English into computer
    programs (along with a whole lot more, as we’ll soon see). There are other AI
    assistants like Copilot, including Amazon Q Developer, Tabnine, and Ghostwriter.
    We chose Copilot for this book based on a combination of the quality of code that
    we’ve been able to produce, stability (it has never crashed for us!), and our
    own personal preferences. We encourage you to also check out other tools when
    you feel comfortable doing so.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 是一个具有特定任务的 AI 助手：它将英语转换为计算机程序（以及更多，我们很快就会看到）。还有其他像 Copilot 一样的 AI 助手，包括
    Amazon Q Developer、Tabnine 和 Ghostwriter。我们选择 Copilot 来编写这本书，是基于我们能够产生的代码质量、稳定性（它从未崩溃过！）以及我们自己的个人偏好。我们鼓励你在感到舒适的时候也去检查其他工具。
- en: 1.2.3 How Copilot works behind the scenes—in 30 seconds
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 Copilot 在幕后是如何工作的——30 秒内了解
- en: You can think of Copilot as a layer between you and the computer program you’re
    writing. Instead of writing the Python directly, you simply describe the program
    you want in words—this is called a *prompt *—and Copilot generates the program
    for you.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把 Copilot 看作是你和你要编写的计算机程序之间的一个层。你不需要直接编写 Python，你只需用文字描述你想要的程序——这被称为 *提示*——然后
    Copilot 就会为你生成程序。
- en: The brain behind Copilot is a fancy computer program called a *large language
    model* (LLM). An LLM stores information about relationships between words, including
    which words make sense in certain contexts, and uses this to predict the best
    sequence of words to respond to a prompt.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 背后的“大脑”是一个名为 *大型语言模型*（LLM）的复杂计算机程序。LLM 存储关于词语之间关系的信息，包括哪些词语在特定上下文中是有意义的，并使用这些信息来预测对提示的最佳词语序列。
- en: 'Imagine that we asked you what the next word should be in this sentence: “The
    person opened the ________.” There are many words that you could fill in here,
    like “door,” “box,” or “conversation,” but there are also many words that wouldn’t
    fit here, like “the,” “it,” or “open.” An LLM takes into account the current context
    of words to produce the next word, and it keeps doing this until it has completed
    the task. It does this in a way that is *nondeterministic*, which just means that
    its decisions are somewhat random, meaning if you ask it to fill in that word,
    sometimes it will give you the word “door,” and sometimes it will give you the
    word “box.” This means that if you ask Copilot to give you code, it may give you
    different answers each time you ask.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们问你这句话的下一个词应该是什么：“这个人打开了 ________。”这里可以填入很多词，比如“门”、“盒子”或“对话”，但也有许多词不适合这里，比如“the”、“it”或“open”。LLM
    会考虑到词语的当前上下文来生成下一个词，并且它会一直这样做，直到完成任务。它以 *非确定性* 的方式做这件事，这意味着它的决策是有些随机的，也就是说，如果你要求它填入那个词，有时它会给你“门”这个词，有时它会给你“盒子”这个词。这意味着如果你要求
    Copilot 给你代码，它可能会每次给出不同的答案。
- en: 'In addition, notice that we didn’t say anything about Copilot having an understanding
    of what it’s doing. It just uses the current context to keep writing code. Keep
    this in mind throughout your journey: only we know whether the code that’s generated
    does what we intended it to do. Very often it does, but you should always exercise
    healthy skepticism regardless. Figure 1.2 gives you an idea of how Copilot goes
    from prompt to program.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们并没有说 Copilot 理解它在做什么。它只是使用当前上下文来继续编写代码。在整个过程中请记住这一点：只有我们知道生成的代码是否是我们想要它做的。通常它确实做到了，但无论如何，你都应该保持健康的怀疑态度。图
    1.2 展示了 Copilot 从提示到程序的过程。
- en: '![figure](../Images/1-2.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/1-2.png)'
- en: Figure 1.2 Going from prompt to program with Copilot
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.2 使用 Copilot 从提示到程序的过程
- en: You might wonder why Copilot writes Python code for us and not machine code
    directly. Isn’t Python an expendable intermediate step now? Well, no, and the
    reason is that Copilot is going to make mistakes. And if it’s going to make mistakes
    that we need to fix, it’s a lot easier to do that with Python than with machine
    code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么 Copilot 为我们编写 Python 代码而不是直接编写机器代码。Python 现在不是可替代的中间步骤吗？嗯，不是的，原因在于
    Copilot 会犯错误。而且如果它要犯我们需要修复的错误，用 Python 来做比用机器代码要容易得多。
- en: In fact, virtually no one checks if the machine code produced from Python is
    correct. This is partially because of the determinism of the Python language specification.
    One could imagine a future where Copilot conversations are so accurate that inspecting
    the Python is unnecessary, but we’re a long way from that.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，几乎没有人检查从 Python 生成的机器代码是否正确。这部分原因是因为 Python 语言规范的确定性。我们可以想象一个未来，Copilot
    的对话如此精确，以至于检查 Python 代码变得没有必要，但我们离那个未来还有很长的路要走。
- en: 1.3 How Copilot changes how we learn to program
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 Copilot如何改变我们学习编程的方式
- en: When learning how to program in the past, learners often spent most of their
    time working with the syntax and basic structure of programs. When we use the
    word *syn**tax*, we’re referring to the symbols and words that are valid in a
    given language. Programmers would need to write all of the syntax of a program
    from scratch (character by character, line by line). People learning to program
    used to spend weeks or months to get to a point where they could write even basic
    programs. Now, Copilot can immediately write those same basic programs and offers
    code that is almost always syntactically and structurally correct. As you’ll see
    in the rest of the book, we still need to verify that this code is correct because
    Copilot can make mistakes. However, we don’t need to write it from scratch anymore.
    We believe Copilot and similar tools signal the end of the old way that people
    learned to program.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去学习如何编程时，学习者通常花费大部分时间与程序的语法和基本结构打交道。当我们提到 *语法* 时，我们指的是在给定语言中有效的符号和单词。程序员需要从头开始（一个字符一个字符，一行一行）编写程序的所有语法。学习编程的人过去常常需要花费数周或数月才能达到能够编写甚至基本程序的水平。现在，Copilot
    可以立即编写这些相同的基本程序，并提供的代码几乎总是语法和结构上正确的。正如你将在本书的其余部分看到的那样，我们仍然需要验证这些代码是否正确，因为 Copilot
    可能会出错。然而，我们不再需要从头编写它。我们相信 Copilot 和类似工具标志着人们学习编程的旧方式的终结。
- en: You, as someone interested in learning how to program, simply don’t need to
    struggle with syntax, understanding exactly how to call a given Python function,
    and the host of other Python concepts needed to write code like you’d have had
    to in the past. Sure, we’re going to learn about those concepts in this book,
    but not so that you can demonstrate your understanding by writing code from scratch
    that Copilot can produce easily. No, we’ll learn those concepts only because they
    help us solve meaningful problems and interact productively with Copilot. Instead,
    you get to learn how to write larger, more meaningful software faster because
    of how an AI assistant fundamentally changes the skills needed to learn programming.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你作为一个对学习编程感兴趣的人，根本不需要与语法作斗争，理解如何准确调用给定的 Python 函数，以及编写代码时所需的其他 Python 概念。当然，我们将在本书中学习这些概念，但不是为了让你通过从头编写
    Copilot 可以轻松生成的代码来展示你的理解。不，我们学习这些概念仅仅是因为它们帮助我们解决有意义的问题，并与 Copilot 有效地互动。相反，你将能够更快地学习如何编写更大、更有意义的软件，因为
    AI 助手从根本上改变了学习编程所需掌握的技能。
- en: 1.4 What else can Copilot do for us?
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 Copilot还能为我们做些什么？
- en: 'As we’ve seen, we can use Copilot to write Python code for us starting from
    an English description of what we want. So, we can say that Copilot takes a description
    in English syntax and gives us back code in Python syntax. That’s a big win because
    learning programming syntax has historically been a major stumbling block for
    new programmers. What kind of bracket—[, (, or {—am I supposed to use here? Do
    I need indentation here? What order are we supposed to write these things in:
    x and then y, or y and then x?'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们可以使用 Copilot 根据我们想要的英文描述来为我们编写 Python 代码。因此，我们可以这样说，Copilot 接收英文语法的描述，并以
    Python 语法的代码返回。这是一个巨大的进步，因为学习编程语法在历史上一直是新程序员的一个主要障碍。我应该在这里使用哪种括号——[、( 或 {]？我需要在这里缩进吗？我们应该按照什么顺序编写这些内容：x
    然后是 y，还是 y 然后是 x？
- en: Such questions abound, and—let’s be honest—it’s uninteresting stuff. Who cares
    about this when all we want to do is write a program to make something happen?
    Copilot can help free us from the tedium of syntax. We see this as an important
    step to help more people successfully write programs, and we look forward to the
    day when this artificial barrier is completely removed. For now, we still need
    Python syntax, but at least Copilot helps us with it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的问题层出不穷，而且——让我们说实话——这并不有趣。当我们只想编写一个程序让某事发生时，谁会在乎这些呢？Copilot可以帮助我们摆脱语法上的枯燥。我们认为这是帮助更多人成功编写程序的重要一步，我们期待着有一天这个人工障碍被完全消除。目前，我们仍然需要Python语法，但至少Copilot在这方面帮助我们。
- en: 'But that’s not all Copilot can do. Here are some associated—and no less important—tasks
    Copilot can help us with:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但Copilot能做的不仅仅是这些。以下是一些相关且同样重要的任务，Copilot可以帮助我们完成：
- en: '*Explaining code —*When Copilot generates Python code for us, we’ll need to
    determine whether that code does what we want. Again, as we said previously, Copilot
    is going to make mistakes. Although we’re not interested in teaching you every
    nuance of how Python works (that’s the old model of programming), we’ll teach
    you how to read Python code to gain an overall understanding of what it does.
    We’ll also use the Copilot feature that explains code to you in English. When
    you finish with this book and our explanations, you’ll still have Copilot available
    to help you understand that next bit of gnarly code that it gives you.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解释代码* — 当Copilot为我们生成Python代码时，我们需要确定该代码是否满足我们的需求。同样，正如我们之前所说的，Copilot可能会犯错误。尽管我们并不想教你Python工作的每一个细节（那是旧的编程模式），但我们会教你如何阅读Python代码，以获得对其功能的整体理解。我们还会使用Copilot的代码解释功能，用英语向你解释代码。当你完成这本书和我们的解释后，你仍然可以使用Copilot来帮助你理解它给出的下一部分复杂的代码。'
- en: '*Making code easier to understand —*There are different ways to write code
    to accomplish the same task. Some may be easier to understand than others. You
    can ask Copilot to reorganize your code to make it easier to work with. Code that’s
    easier to read is often easier to enhance or fix when needed.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使代码更容易理解* — 有不同的方式来编写代码以完成同一任务。有些可能比其他更容易理解。你可以要求Copilot重新组织你的代码，使其更容易使用。易于阅读的代码在需要时通常更容易增强或修复。'
- en: '*Fixing bugs —*A *bug* is a mistake made when writing a program that can result
    in the program doing the wrong thing. Sometimes, your Python code almost works
    or works almost always but not in one specific circumstance. If you’ve listened
    to programmers talk, you may have heard the common story where a programmer would
    spend hours only to finally remove one = symbol that was making their program
    fail. That’s not a fun few hours! In these cases, you can try the Copilot feature
    that helps to automatically find and fix the bug in the program.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修复错误* — 一个 *错误* 是在编写程序时犯下的错误，可能会导致程序执行错误。有时，你的Python代码几乎可以工作，或者几乎总是可以工作，但在一种特定情况下却不行。如果你听过程序员的谈话，你可能听说过这样一个常见的例子：程序员可能花费数小时，最终只移除了一个导致程序失败的等号符号。那可不是几个小时的乐趣！在这些情况下，你可以尝试Copilot的功能，该功能可以帮助自动找到并修复程序中的错误。'
- en: '*Explaining errors —*If your code isn’t working correctly, you’ll often get
    an error report back from the Python runtime environment. Those errors can be
    fairly cryptic at times, but Copilot can help you interpret the error and guide
    you on how to fix it.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解释错误* — 如果你的代码没有正确工作，你通常会从Python运行时环境得到一个错误报告。有时，这些错误可能相当晦涩难懂，但Copilot可以帮助你解释错误，并指导你如何修复它。'
- en: '*Finding Python libraries —*Python is a mature language with many modules (libraries)
    that can aid particular tasks, such as data analysis, writing games, working with
    different image file formats, and so on. A quick conversation with Copilot can
    often help you find modules that will make your work easier and give you examples
    to get you started.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*寻找Python库* — Python是一种成熟的编程语言，拥有许多模块（库）可以帮助完成特定任务，例如数据分析、编写游戏、处理不同的图像文件格式等等。与Copilot进行一次简短的对话通常可以帮助你找到使你的工作变得更轻松的模块，并为你提供一些入门示例。'
- en: 1.5 Risks and challenges when using Copilot
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 使用Copilot的风险和挑战
- en: 'Now that we’re all pumped up about getting Copilot to write code for us, we
    need to talk about the dangers inherent in using AI assistants (see references
    [2] and [3] for elaboration on some of these points):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们都对让Copilot为我们编写代码感到兴奋，我们需要谈谈使用AI助手固有的危险（参见参考文献[2]和[3]，以详细说明这些观点的一些内容）：
- en: '*Copyright*—Copilot learned how to program using human-written code. (You’ll
    hear people use the word “train” when talking about AI tools like Copilot. In
    this context, training is another word for learning.) More specifically, it was
    trained using millions of GitHub repositories containing open-source code. One
    worry is that Copilot will “steal” that code and give it to us. In our experience,
    Copilot doesn’t often suggest a large chunk of someone else’s code, but that possibility
    is there. Even if the code that Copilot gives us is a melding and transformation
    of various bits of other people’s code, there may still be licensing problems.
    For example, who owns the code produced by Copilot? There is currently no consensus
    on the answer. The Copilot team is adding features to help; for example, Copilot
    can tell you whether the code that it produced is similar to already-existing
    code and what the license is on that code [4]. Learning and experimenting on your
    own is great, and we encourage that—but take care if you intend to use this code
    for purposes beyond your home. We’re intentionally a bit vague here because it
    may take some time for laws to catch up to this new technology. It’s best to play
    it safe while these debates are had within society.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*版权*—Copilot通过使用人类编写的代码来学习编程。（当人们谈论像Copilot这样的AI工具时，你会听到他们使用“训练”这个词。在这个上下文中，训练是学习的另一个词。）更具体地说，它是通过使用包含开源代码的数百万个GitHub仓库进行训练的。一个担忧是Copilot会“窃取”那段代码并给我们。根据我们的经验，Copilot很少建议大量他人的代码，但这种可能性是存在的。即使Copilot给出的代码是各种他人代码片段的融合和转换，也可能存在许可问题。例如，Copilot产生的代码归谁所有？目前还没有关于这个问题的共识。Copilot团队正在添加功能来帮助；例如，Copilot可以告诉你它产生的代码是否与现有的代码相似以及该代码的许可情况[4]。自学和实验是很好的，我们鼓励这样做——但如果你打算将此代码用于家庭以外的目的，请务必小心。我们故意说得比较含糊，因为法律可能需要一段时间才能赶上这种新技术。在这些社会辩论进行时，最安全的做法是谨慎行事。'
- en: '*Education —*As instructors of introductory programming courses ourselves,
    we’ve seen firsthand how well Copilot does on the types of assignments we’ve given
    our students in the past. In one study [5], Copilot was asked to solve 166 common
    introductory programming tasks. How well did it do? On its first attempt, it solved
    almost 50% of these problems. Give Copilot a little more information, and that
    number goes up to 80%. Education needs to change in light of tools like Copilot,
    and instructors are currently discussing how these changes may look. At some schools,
    students are allowed to use Copilot to aid in their learning and on their assignments.
    At other schools, Copilot isn’t allowed in some contexts (i.e., exams) or for
    some students (computer science majors). At many schools, LLMs are being allowed
    to act as tutors for students. In some cases, the LLM tutors are just regular
    LLMs like Copilot or ChatGPT, but, in other cases, the LLM interface has been
    changed to restrict the kind of answers students receive. It’s still too early
    to know how LLMs will affect computing education, but trends like these have already
    started to emerge.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*教育*—作为入门级编程课程的讲师，我们亲眼见证了Copilot在我们过去给学生布置的作业类型上的出色表现。在一项研究中[5]，Copilot被要求解决166个常见的入门级编程任务。它做得怎么样？在第一次尝试中，它解决了近50%的问题。给Copilot更多的信息，这个数字会上升到80%。鉴于像Copilot这样的工具，教育需要改变，目前讲师们正在讨论这些变化可能的样子。在一些学校，学生被允许使用Copilot来辅助他们的学习和作业。在其他学校，Copilot在某些情况下（例如，考试）或对某些学生（计算机科学专业学生）是不被允许的。在许多学校，LLMs被允许作为学生的辅导老师。在某些情况下，LLM辅导老师只是像Copilot或ChatGPT这样的常规LLM，但在其他情况下，LLM界面已被改变以限制学生收到的答案类型。目前还太早知道LLMs将如何影响计算机教育，但这样的趋势已经初露端倪。'
- en: '*Code quality*—We need to be careful not to trust Copilot, especially with
    sensitive code or code that needs to be secure. Code written for medical devices,
    for example, or code that handles sensitive user data must always be thoroughly
    understood. It’s tempting to ask Copilot for code, marvel at the code that it
    produces, and accept that code without scrutiny. But that code might be plain
    wrong. In this book, we’ll work on code that won’t be deployed at large, so, while
    we’ll focus on getting the correct code, we won’t worry about the implications
    of using this code for broader purposes. We’ll also build the foundations you’ll
    need to independently determine whether code is correct.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码质量*—我们需要小心不要信任Copilot，特别是对于敏感代码或需要安全的代码。例如，为医疗设备编写的代码或处理敏感用户数据的代码必须始终彻底理解。向Copilot请求代码，对它产生的代码感到惊奇，并未经审查就接受这些代码是很诱人的。但在本书中，我们将处理不会大规模部署的代码，因此，虽然我们将关注获取正确的代码，但我们不会担心使用此代码的更广泛用途的影响。我们还将建立你需要的独立确定代码是否正确的基础。'
- en: '*Code security*—As with code quality, code security is absolutely not assured
    when we get code from Copilot. For example, if we’re working with user data, getting
    code from Copilot isn’t enough. We would need to perform security audits and have
    expertise to determine that the code is secure. Again, though, we won’t be using
    code from Copilot in real-world scenarios, so we won’t focus on security concerns.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码安全*—与代码质量一样，当我们从Copilot获取代码时，代码的安全性绝对不能得到保证。例如，如果我们正在处理用户数据，仅仅从Copilot获取代码是不够的。我们需要进行安全审计，并拥有专业知识来确定代码的安全性。然而，尽管如此，我们不会在实际场景中使用Copilot的代码，因此我们不会关注安全问题。'
- en: '*Not an expert*—One of the markers of being an expert is awareness of what
    one knows and, equally important, what one doesn’t. Experts are also often able
    to state how confident they are in their response, and if they aren’t confident
    enough, they will learn further until they know that they know. Copilot and, more
    generally, LLMs, don’t do this. You ask them a question, and they answer, plain
    as that. They will confabulate if necessary: they will mix bits of truth with
    bits of garbage into a plausible-sounding but overall nonsensical response. For
    example, we’ve seen LLMs fabricate obituaries for people who are alive, which
    doesn’t make any sense, yet the “obituaries” do contain elements of truth about
    people’s lives. When asked why an abacus can perform math faster than a computer,
    we’ve seen LLMs come up with confident-sounding responses—including something
    about abacuses being mechanical and therefore necessarily the fastest. There is
    ongoing work in this area for LLMs to be able to say, “Sorry, no, I don’t know
    this,” but we’re not there yet. They don’t know what they don’t know, and that
    means they need supervision.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非专家*—成为专家的一个标志是意识到自己知道什么，同样重要的是，知道自己不知道什么。专家通常也能表达他们对回答的信心程度，如果他们不够自信，他们会进一步学习，直到他们确信自己知道。Copilot和更广泛的LLMs则不具备这种能力。你问他们一个问题，他们就会直接回答，就是这样。如果需要，他们会编造：他们会将真实信息与垃圾信息混合，形成一个听起来合理但实际上毫无意义的回答。例如，我们见过LLMs为活着的人编造讣告，这显然是没有意义的，但这些“讣告”确实包含了一些关于人们生活的真实信息。当被问及算盘为什么能比电脑更快地完成数学运算时，我们见过LLMs给出听起来自信的回答——包括关于算盘是机械的，因此必然是最快的说法。LLMs在这个领域正在进行工作，以便能够说，“抱歉，不，我不知道这个。”但我们还没有达到那个阶段。他们不知道自己不知道什么，这意味着他们需要监督。'
- en: '*Bias*—LLMs will reproduce the same biases present in the data on which they
    were trained. If you ask Copilot to generate a list of names, it will generate
    primarily English names. If you ask for a graph, it may produce a graph that doesn’t
    consider perceptual differences among humans. And, if you ask for code, it may
    produce code in a style reminiscent of how particular groups write code. (After
    all, the demographic groups that are well represented in computing wrote most
    of the code in the world, and Copilot is trained on that code.) Computer science
    and software engineering have long suffered from a lack of diversity. We can’t
    afford to stifle diversity further, and we need to reverse the trend. We need
    to let more people in and allow them to express themselves in their own ways.
    How this will be handled with tools like Copilot is currently being worked out
    and is crucially important to the future of programming. However, we believe Copilot
    has the potential to improve diversity by lowering barriers to entry into the
    field.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*偏见*——LLMs会复制它们在训练数据中存在的相同偏见。如果你要求Copilot生成一个名字列表，它将主要生成英语名字。如果你要求一个图表，它可能产生的图表没有考虑人类之间的感知差异。而且，如果你要求代码，它可能产生一种特定群体编写代码风格的代码。（毕竟，在计算机科学中，人口群体得到了很好的代表，Copilot就是在这些代码上训练的。）计算机科学和软件工程长期以来一直遭受着缺乏多样性的困扰。我们无法进一步压制多样性，我们需要扭转这一趋势。我们需要让更多的人加入，并允许他们以自己的方式表达自己。如何使用像Copilot这样的工具来处理这个问题目前正在被解决，这对编程的未来至关重要。然而，我们相信Copilot有潜力通过降低进入该领域的门槛来提高多样性。'
- en: 1.6 The skills we need
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 我们需要的技能
- en: If Copilot can write our code, explain it, and fix bugs in it, are we just done?
    Do we just tell Copilot what to do and celebrate our pure awesomeness?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Copilot可以编写我们的代码、解释它并修复其中的错误，我们是不是就完成了？我们是不是只需要告诉Copilot要做什么，然后庆祝我们的纯粹厉害？
- en: No. First, Copilot can make mistakes. The code it gives us might be syntactically
    correct, but sometimes it doesn’t do what we want it to do. We need to be vigilant
    to catch when Copilot makes these mistakes. Second, although some of the skills
    that programmers rely on (e.g., writing correct syntax) will decrease in importance,
    other skills remain critical. For example, you can’t throw a huge task at Copilot
    like, “Make a video game. Oh, and make it fun.” Copilot will fail. Instead, we
    need to break down such a large problem into smaller tasks that Copilot can help
    us with. How do we break a problem down like that? Not easily, it turns out. Humans
    need to develop this key skill when engaging in conversations with tools like
    Copilot, and we teach this skill throughout the book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不。首先，Copilot可能会犯错误。它给出的代码可能在语法上是正确的，但有时它并不做我们想要它做的事情。我们需要保持警惕，以便在Copilot犯这些错误时能够捕捉到。其次，尽管程序员依赖的一些技能（例如，编写正确的语法）的重要性可能会降低，但其他技能仍然至关重要。例如，你不能把一个巨大的任务扔给Copilot，比如，“制作一个视频游戏。哦，还要让它有趣。”Copilot会失败的。相反，我们需要将这样一个大问题分解成Copilot可以帮助我们的小任务。我们如何那样分解问题？实际上并不容易。当与像Copilot这样的工具进行对话时，人类需要发展这种关键技能，我们在整本书中都在教授这种技能。
- en: Other skills, believe it or not, may take on even more importance with Copilot.
    Testing code has always been a critical task in creating high-quality code. We
    know a lot about testing code written by humans because we know where to look
    for typical problems. We know that humans often make programming errors at the
    boundaries of values. For example, if we wrote a program to multiply two numbers,
    we’d likely get most values right but maybe not when one value is 0\. What about
    code written by AI, where 20 lines of flawless code could hide 1 line so absurd
    that we likely wouldn’t expect it there? We don’t have experience with that. We
    need to test even more carefully than before.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，其他技能在Copilot的帮助下可能会变得更加重要。测试代码在创建高质量代码中一直是一项关键任务。我们了解人类编写的代码的测试，因为我们知道在哪里寻找典型问题。我们知道人类经常在值的边界处犯编程错误。例如，如果我们编写了一个乘以两个数的程序，我们可能会得到大多数值正确，但可能不会在其中一个值为0时正确。那么，AI编写的代码呢？20行无瑕疵的代码可能隐藏着一行如此荒谬的代码，我们可能不会期望它在那里。我们没有这方面的经验。我们需要比以前更加仔细地测试。
- en: We also need to know how to fix mistakes when the code is wrong. This process
    is called *debugging* and is still essential, particularly when Copilot gives
    you code that is close to correct but not quite there yet.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要知道如何在代码出错时修复错误。这个过程被称为*调试*，并且仍然非常重要，尤其是当Copilot给你接近正确但还不够准确的代码时。
- en: Finally, some required skills are entirely new. The main one here is called
    *prompt engineering*, which involves how to tell Copilot what to do. As mentioned
    earlier, when we’re asking Copilot to write some code, we’re using a prompt to
    make the request. Although we can use English to write that prompt and ask for
    what we want, it’s not enough. We need to be very precise if we want Copilot to
    have any chance of doing the right thing. And, even when we’re precise, Copilot
    may still do the wrong thing. In that case, we need to first identify that Copilot
    has indeed made a mistake. Then, we can try to tweak our description to hopefully
    nudge it in the right direction. In our experience, seemingly minor changes to
    the prompt can have outsized effects on what Copilot produces. In this book, we’ll
    teach you all of these skills.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些必需的技能完全是新的。其中最主要的是被称为*提示工程*的技能，它涉及如何告诉Copilot要做什么。如前所述，当我们要求Copilot编写一些代码时，我们使用提示来发出请求。虽然我们可以用英语来编写这个提示并要求我们想要的东西，但这还不够。如果我们想让Copilot有做对事情的机会，我们需要非常精确。即使我们很精确，Copilot仍然可能做错事情。在这种情况下，我们首先需要确定Copilot确实犯了一个错误。然后，我们可以尝试调整我们的描述，希望将其引导到正确的方向。根据我们的经验，对提示的看似微小的改变可能会对Copilot产生的结果产生不成比例的影响。在这本书中，我们将教你所有这些技能。
- en: 1.7 Societal concerns about AI code assistants like Copilot
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 对像Copilot这样的AI代码助手的社会担忧
- en: 'There’s societal uncertainty right now about AI code assistants like Copilot.
    We thought we’d end the chapter with a few questions and our current answers.
    Perhaps you’ve been wondering about some of these questions yourself! Our answers
    may turn out to be hilariously incorrect, but they do capture our current thoughts
    as two professors and researchers who have dedicated their careers to teaching
    programming:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 目前社会对像Copilot这样的AI代码助手存在不确定性。我们认为应该以几个问题和我们的当前答案结束本章。也许你自己也在思考这些问题！我们的答案可能最终会显得荒谬错误，但它们确实捕捉了我们作为两位致力于编程教学的教授和研究者的当前想法：
- en: '*Q:* Are there going to be fewer tech and programming jobs now that we have
    Copilot?'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Q:* 现在我们有了Copilot，技术编程工作会减少吗？'
- en: '*A:* Probably not. What we do expect to change is the nature of these jobs.
    For example, we see Copilot as being able to help with many tasks typically associated
    with entry-level programming jobs. This doesn’t mean that entry-level programming
    jobs go away, only that they change as programmers are able to get more done given
    increasingly sophisticated tools.'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*A:* 很可能不是。我们预期会改变的是这些工作的性质。例如，我们认为Copilot可以帮助完成许多通常与初级编程工作相关的任务。这并不意味着初级编程工作会消失，只是随着程序员能够利用越来越复杂的工具完成更多工作，这些工作会发生变化。'
- en: '*Q:* Will Copilot stifle human creativity? Will it just keep swirling around
    and recycling the same code that humans have already written, limiting the introduction
    of new ideas?'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Q:* Copilot会扼杀人类的创造力吗？它会不会只是不断循环和重复人类已经编写过的代码，限制新想法的引入？'
- en: '*A:* We suspect not. Copilot helps us work at a higher level, further removed
    from the underlying machine code, assembly code, or Python code. Computer scientists
    use the term *abstraction* to refer to the extent that we can disconnect ourselves
    from the low-level details of computers. Abstraction has been happening since
    the dawn of computer science, and we don’t seem to have suffered for it. On the
    contrary, it enables us to ignore problems that have already been solved and focus
    on solving broader and broader problems. Indeed, it’s been the advent of better
    programming languages that have facilitated better software—software that powers
    Google search, Amazon shopping carts, and macOS weren’t written (and likely couldn’t
    have been written) when we only had assembly!'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*A:* 我们怀疑不是。Copilot帮助我们以更高的层次工作，远离底层机器代码、汇编代码或Python代码。计算机科学家使用术语*抽象*来指代我们与计算机底层细节断开连接的程度。抽象自计算机科学诞生以来一直在发生，我们似乎并未因此遭受损失。相反，它使我们能够忽略已经解决的问题，并专注于解决越来越广泛的问题。事实上，更好的编程语言的诞生促进了更好的软件的发展——当只有汇编语言时，Google搜索、Amazon购物车和macOS等软件都没有被编写（很可能也无法编写）！'
- en: '*Q:* I keep hearing about ChatGPT. What is it? Is it the same as Copilot?'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Q:* 我经常听到关于ChatGPT的消息。那是什么？它和Copilot一样吗？'
- en: '*A:* It’s not the same as Copilot, but it’s built on the same technology. Rather
    than focus on code, though, ChatGPT focuses on knowledge in general. As a result,
    it has insinuated itself into a wider variety of tasks than Copilot. For example,
    it can answer questions, write essays, and even do well on a Wharton MBA exam
    [6]. Education will need to change as a result: we can’t have people ChatGPTing
    their way to MBAs! The worthwhile ways in which we spend our time may change.
    Will humans keep writing books and, if so, in what ways? Will people want to read
    books knowing they were partially or fully written by AI? There will be effects
    across industries, including finance, health care, and publishing [7]. At the
    same time, there is unfettered hype right now, so it can be difficult to separate
    truth from fiction. This problem is compounded by the simple truth that no one
    knows what’s going to happen here in the long term. There’s an old adage coined
    by Roy Amara (known as Amara’s law ) that says, “We tend to overestimate the effect
    of a technology in the short run and underestimate the effect in the long run.”
    As such, we need to do our best to be tuned into the discussion so that we can
    adapt accordingly.'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*A:* 它与Copilot不同，但建立在相同的技术之上。然而，ChatGPT并不是专注于代码，而是关注一般性的知识。因此，它已经渗透到比Copilot更广泛的各种任务中。例如，它可以回答问题，撰写文章，甚至在沃顿商学院的MBA考试中表现出色[6]。因此，教育将需要改变：我们不能让人们通过ChatGPT的方式获得MBA！我们花费时间的有价值的方式可能会改变。人类是否会继续写书，如果是的话，会以什么方式？人们是否愿意阅读那些部分或全部由AI撰写的书籍？这将在包括金融、医疗保健和出版在内的各个行业产生影响[7]。同时，目前存在无节制的炒作，因此很难区分真相与虚构。这个问题由于一个简单的事实而加剧，即没有人知道长期会发生什么。罗伊·阿玛拉（被称为阿玛拉定律）提出了一句古老的谚语说：“我们往往高估了技术在短期内的影响，而低估了在长期的影响。”因此，我们需要尽我们所能关注讨论，以便我们可以相应地适应。'
- en: In the next chapter, we’ll get you started using Copilot on your computer so
    you can get up and running writing software.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将指导您在电脑上开始使用Copilot，以便您可以开始编写软件。
- en: Summary
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Copilot is an AI assistant, which is an AI agent that helps you get work done.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot是一个AI助手，它是一种AI代理，可以帮助您完成工作。
- en: Copilot changes how humans interact with computers, as well as the way we write
    programs.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot改变了人类与计算机的互动方式，以及我们编写程序的方式。
- en: Copilot changes the focus of skills we need to hone (less focus on syntax, more
    focus on problem decomposition and testing).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot改变了我们需要磨练的技能的焦点（减少对语法的关注，更多关注问题分解和测试）。
- en: Copilot is nondeterministic; sometimes it produces correct code, and sometimes
    it doesn’t. We need to be vigilant.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot是非确定性的；有时它会产生正确的代码，有时则不会。我们需要保持警惕。
- en: Problems around copyright of code, education and job training, and bias in Copilot
    results still need to be worked out.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于代码版权、教育和职业培训以及Copilot结果中的偏见等问题仍需要解决。
