- en: Chapter 3\. Creating Your Database
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章\. 创建您的数据库
- en: “You don’t seem to give much thought to the matter in hand,” I said at last,
    interrupting Holmes’ musical disquisition.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “您似乎没有太多考虑手头的事情，”我最后说，打断霍尔斯的音乐论述。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “No data yet,” he answered. “It is a capital mistake to theorize before you
    have all the evidence. It biases the judgement.”
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “还没有数据，”他回答。“在没有所有证据之前就下结论是一个严重的错误。它会偏见判断。”
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “You will have your data soon,” I remarked.
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “您很快就会有数据了，”我说。
- en: ''
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sir Arthur Conan Doyle, *A Study in Scarlet* (Ward Lock & Co., 1887)
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 亚瑟·柯南·道尔爵士，《血字的研究》（Ward Lock & Co.，1887年）
- en: In [Chapter 2](ch02.html#chapter_2), you designed the API architecture and set
    up your GitHub Codespace environment. In this chapter, you will create the database
    and the Python code to read from it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html#chapter_2)中，您设计了API架构并设置了您的GitHub Codespace环境。在本章中，您将创建数据库以及从它读取的Python代码。
- en: Since you are creating a data API, this chapter is important. It will walk you
    through the process of designing your database structures, creating them in the
    SQLite database, creating Python code to read the database, and creating unit
    tests to verify all of these pieces work together.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您正在创建数据API，本章很重要。它将指导您设计数据库结构的过程，在SQLite数据库中创建它们，创建读取数据库的Python代码，以及创建单元测试以验证所有这些组件是否协同工作。
- en: If you are in a rush to see how this code works, you can use the files in the
    *chapter3/complete* folder, and come back later to follow the instructions step
    by step.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您急于看到代码是如何工作的，您可以使用*chapter3/complete*文件夹中的文件，稍后再回来按步骤执行指令。
- en: Components of Your API
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的API组件
- en: In the previous chapter, [Figure 2-2](ch02.html#future_state_architecture_ch2)
    showed the application architecture you are implementing. The API in that diagram
    is made up of several components. [Figure 3-1](#application_components_ch3) shows
    these components and the software you will use to implement them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，[图2-2](ch02.html#future_state_architecture_ch2)显示了您正在实施的应用程序架构。该图中的API由几个组件组成。[图3-1](#application_components_ch3)显示了这些组件以及您将用于实现它们的软件。
- en: '![API components](assets/haad_0301.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![API组件](assets/haad_0301.png)'
- en: Figure 3-1\. API components
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1\. API组件
- en: There are four major subcomponents of the API. The data transfer and validation
    components are used to ensure that the API requests and responses have valid data
    and conform to their definitions. You will create these with Pydantic. You will
    create the API controller with FastAPI. It handles all of the processing of the
    API along with other functions you will learn. You will create the database classes
    using SQLAlchemy. These classes handle querying the database and storing the data
    in Python classes. Since SQLite is a file-based database and you’ll deploy it
    along with your API code, the diagram shows it as a fourth component of the API.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: API有四个主要子组件。数据传输和验证组件用于确保API请求和响应具有有效数据并符合其定义。您将使用Pydantic创建这些组件。您将使用FastAPI创建API控制器。它处理API的所有处理以及其他您将学习的功能。您将使用SQLAlchemy创建数据库类。这些类处理查询数据库以及在Python类中存储数据。由于SQLite是一个基于文件的数据库，并且您将与其API代码一起部署，因此图中将其显示为API的第四个组件。
- en: Software Used in This Chapter
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章使用的软件
- en: 'The software introduced in this chapter will focus on databases: creating them,
    reading data from them, and testing them (see [Table 3-1](#tools_table_chapter_3)).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的软件将专注于数据库：创建数据库、从数据库中读取数据以及测试它们（见[表3-1](#tools_table_chapter_3)）。
- en: Table 3-1\. New tools or services used in this chapter
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表3-1\. 本章使用的新工具或服务
- en: '| Software name | Version | Purpose |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 软件名称 | 版本 | 用途 |'
- en: '| --- | --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| pytest | 8 | Unit-testing library |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| pytest | 8 | 单元测试库 |'
- en: '| SQLAlchemy | 2 | Object-Relational Mapping (ORM) library to connect Python
    to SQLite |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| SQLAlchemy | 2 | 连接Python到SQLite的对象关系映射（ORM）库 |'
- en: '| SQLite | 3 | Stores the data used by the APIs |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| SQLite | 3 | 存储API使用的数据库数据 |'
- en: SQLite
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite
- en: As shown in [Figure 3-1](#application_components_ch3), the API uses the read
    replica database, which is a read-only copy of the website database that receives
    quick updates from the website database. The SWC website contains large amounts
    of data about fantasy teams, NFL players, managers, scoring, and numerous other
    data points that used by a fantasy football league host.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图3-1](#application_components_ch3)所示，API使用的是只读副本数据库，这是网站数据库的只读副本，它从网站数据库中快速接收更新。SWC网站包含大量关于梦幻球队、NFL球员、经理、得分以及许多其他由梦幻足球联赛主办方使用的数据点。
- en: For your project, you will simulate this with a condensed database using SQLite.
    SQLite is well suited for learning projects because it is file based and the entire
    database can easily be stored in a Git repository like the one you’ll be using.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的项目，您将使用SQLite创建一个压缩数据库来模拟。SQLite非常适合学习项目，因为它基于文件，整个数据库可以轻松存储在Git仓库中，就像您将要使用的那样。
- en: Although considered a lightweight database, SQLite supports all the SQL commands
    that you will use and is fully supported by SQLAlchemy, which you’ll use for Python
    database work. It is a great choice to begin the prototyping of a project. You
    might replace it with a traditional database such as PostgreSQL or MySQL as the
    application or API develops. But it is used in many production applications as
    well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然被认为是轻量级数据库，但SQLite支持您将使用的所有SQL命令，并且完全由SQLAlchemy支持，您将使用它进行Python数据库工作。它是开始项目原型设计的绝佳选择。随着应用程序或API的发展，您可能会用像PostgreSQL或MySQL这样的传统数据库来替换它。但SQLite也被用于许多生产应用程序中。
- en: You will use SQLite 3 for your project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目将使用SQLite 3。
- en: SQLAlchemy
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLAlchemy
- en: 'SQLAlchemy is a popular Python database toolkit and ORM. It works nicely with
    FastAPI, which will be introduced in [Chapter 3](#chapter_3). Here are a few of
    the jobs that SQLAlchemy does for Python developers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy是一个流行的Python数据库工具包和ORM。它与FastAPI配合良好，将在[第3章](#chapter_3)中介绍。以下是SQLAlchemy为Python开发者所做的一些工作：
- en: It provides query access to databases using Python, without using SQL.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供使用Python查询数据库的访问，而不使用SQL。
- en: It populates Python objects with the data from the source database without requiring
    any conversion of data types.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在不需要任何数据类型转换的情况下，使用源数据库中的数据填充Python对象。
- en: It supports a variety of databases.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持多种数据库。
- en: It allows the same Python code to be used with different underlying databases.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许使用相同的Python代码与不同的底层数据库一起使用。
- en: It creates queries as prepared statements, which combat SQL injection attacks.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建查询作为预编译语句，这有助于抵御SQL注入攻击。
- en: Warning
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '*SQL injection* is a serious vulnerability in any software that accepts input
    from users and queries a database with it, including web applications and APIs.
    It occurs when bad actors insert malicious code into inputs that are intended
    for data values.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*SQL注入*是任何接受用户输入并使用它查询数据库的软件的严重漏洞，包括Web应用程序和API。当恶意行为者将恶意代码插入旨在用于数据值的输入时，就会发生这种情况。'
- en: Using *prepared statements* (also known as parameterized statements) instead
    of raw SQL queries is one technique to reduce the risk of SQL injection. For more
    information, reference [OWASP’s article on SQL injection](https://oreil.ly/24SAy).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *预编译语句*（也称为参数化语句）而不是原始SQL查询是减少SQL注入风险的一种技术。更多信息，请参考[OWASP关于SQL注入的文章](https://oreil.ly/24SAy)。
- en: You will be using SQLAlchemy 2 for your project.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目将使用SQLAlchemy 2。
- en: pytest
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pytest
- en: You will be using pytest, a Python testing library, throughout Part I to create
    tests for the Python code you write. You will create *unit tests* to verify that
    individual parts of your code work as intended. You will also use it to *regression-test*
    your code as you make changes or update libraries.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在第一部分中使用pytest，这是一个Python测试库，为所编写的Python代码创建测试。您将创建 *单元测试* 来验证代码的各个部分是否按预期工作。您还将使用它来
    *回归测试* 代码，当您进行更改或更新库时。
- en: You will be using pytest 8 for your project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目将使用pytest 8。
- en: Creating Your SQLite Database
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的SQLite数据库
- en: 'Change to *chapter3* and open SQLite with a new database:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 *第3章* 并使用新数据库打开SQLite：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The version of SQLite may differ from what is shown, because it is automatically
    included in your Codespace.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite的版本可能与显示的不同，因为它自动包含在您的Codespace中。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'To save screen real estate, I have trimmed the directory listing in the terminal
    prompt of my Codespace. You can configure this by editing the */home/codespace/.bashrc*
    file in VS Code. Find the `export PROMPT_DIRTRIM` statement and set it to `export
    PROMPT_DIRTRIM=1`. Then, execute this terminal command: **`source ~/.bashrc`**.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省屏幕空间，我已经在我的Codespace的终端提示符中剪短了目录列表。您可以通过编辑VS Code中的*/home/codespace/.bashrc*文件来配置此设置。找到`export
    PROMPT_DIRTRIM`语句并将其设置为`export PROMPT_DIRTRIM=1`。然后，执行此终端命令：**`source ~/.bashrc`**。
- en: Creating Database Tables
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库表
- en: For this project, you will create several tables and load them with data. [Figure 3-2](#database_structure_ch3)
    displays the structure of the tables you will create.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，您将创建几个表并将数据加载到它们中。[图3-2](#database_structure_ch3)显示了您将创建的表的结构。
- en: 'You will create these tables by executing Structured Query Language (SQL) statements.
    As mentioned previously, SQL is a language used frequently by data scientists.
    This book does not teach the syntax of SQL, but the scripts used are fairly basic.
    To learn more about SQL, I recommend *Learning SQL: Generate, Manipulate, and
    Retrieve Data, 3rd Edition*, by Alan Beaulieu (O’Reilly, 2020).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '您将通过执行结构化查询语言（SQL）语句来创建这些表。如前所述，SQL是数据科学家经常使用的一种语言。本书不教授SQL的语法，但使用的脚本相当基础。要了解更多关于SQL的信息，我推荐Alan
    Beaulieu所著的《Learning SQL: Generate, Manipulate, and Retrieve Data, 3rd Edition》（O’Reilly，2020年）。'
- en: '![Database table structure](assets/haad_0302.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![数据库表结构](assets/haad_0302.png)'
- en: Figure 3-2\. Database table structure
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-2\. 数据库表结构
- en: 'Be sure you are still at the `sqlite` prompt, and one-by-one execute the following
    SQL statements, one by one:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您仍然处于`sqlite`提示符下，并逐个执行以下SQL语句，一个接一个：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is a breakdown of one of the statements:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对其中一个语句的分解：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_creating_your_database_CO1-1)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_your_database_CO1-1)'
- en: '`CREATE TABLE` is standard SQL syntax, and `player` is the name for this table.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE TABLE`是标准的SQL语法，`player`是此表的名称。'
- en: '[![2](assets/2.png)](#co_creating_your_database_CO1-2)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_your_database_CO1-2)'
- en: The `player_id` is the name of a single column with a data type of `INTEGER`
    that is a required field. If you insert a row in this table with this value, an
    error will occur.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`player_id`是一个名为单列的名称，其数据类型为`INTEGER`，是必填字段。如果您在此表中插入具有此值的行，将发生错误。'
- en: '[![3](assets/3.png)](#co_creating_your_database_CO1-3)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_your_database_CO1-3)'
- en: After all the columns are defined, the `player_id` value is defined as the *primary
    key*, which is the value in this table that will always be unique and can be used
    to join to other tables.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了所有列之后，将`player_id`值定义为*主键*，这是在此表中始终唯一的值，可以用来与其他表连接。
- en: 'To verify that all five tables were created, enter **`.tables`**, resulting
    in the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证是否已创建了所有五个表，请输入**`.tables`**，结果如下：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Understanding Table Structure
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解表结构
- en: The first thing to notice about the tables is that each column has a data type
    defined. The data types used are `INTEGER` for identifier values, `VARCHAR` for
    names and text fields, `DATE` for date fields, and `FLOAT` for scoring value fields
    that have a decimal. All fields have a `NOT NULL` statement because they are required.
    Each table has a `PRIMARY KEY()` constraint on the table’s identifier field. This
    ensures that these values are unique in each table.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关于表的第一件事要注意的是，每个列都有一个数据类型定义。使用的数据类型是`INTEGER`用于标识值，`VARCHAR`用于名称和文本字段，`DATE`用于日期字段，`FLOAT`用于有小数的评分值字段。所有字段都有`NOT
    NULL`语句，因为它们是必需的。每个表在其标识字段上都有一个`PRIMARY KEY()`约束。这确保了这些值在每个表中都是唯一的。
- en: In [“Designing APIs for Data Scientists”](ch01.html#designing_APIs_data_scientists),
    I recommended that APIs support querying by the last changed date. This allows
    them to use APIs in data pipelines and only retrieve records that have changed
    since a point in time. (This is a major time-saver.) You will enable this by populating
    the `last_changed_date` column in each table.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“为数据科学家设计API”](ch01.html#designing_APIs_data_scientists)中，我建议API支持按最后更改日期进行查询。这使得他们可以在数据管道中使用API，并且只检索自某个时间点以来已更改的记录。（这是一个节省大量时间的方法。）您将通过在每个表中填充`last_changed_date`列来启用此功能。
- en: 'As shown in [Figure 3-2](#database_structure_ch3), each table is related to
    at least one other table. This is accomplished using `FOREIGN KEY` statements
    in the child table, which references the primary key in the parent table. For
    an example, look at the definition of the `team` table:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图3-2](#database_structure_ch3)所示，每个表都与至少另一个表相关联。这是通过在子表中使用`FOREIGN KEY`语句来实现的，它引用父表中的主键。例如，查看`team`表的定义：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `FOREIGN KEY` statement inserts a column named `league_id` into the child
    table (`team`), which links it to a matching record in the parent table (`league`).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`FOREIGN KEY`语句在子表（`team`）中插入一个名为`league_id`的列，将其与父表（`league`）中的匹配记录链接起来。'
- en: 'The `team_player` is the only table that has two foreign keys, as shown:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`team_player`是唯一一个有两个外键的表，如下所示：'
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It has two foreign keys because it is an *association table*, which serves as
    a child that associates two separate parent tables. In your database, a player
    can be on many fantasy teams and a team can have many fantasy players. The `team_player`
    table enables this *many-to-many relationship*. Later, this relationship will
    be reflected in the Python classes that are mapped to these tables.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个外键，因为它是一个 *关联表*，它作为关联两个单独父表的子表。在您的数据库中，一个球员可以属于多个梦幻球队，一个球队可以有多个梦幻球员。`team_player`
    表实现了这种 *多对多关系*。稍后，这种关系将在映射到这些表的 Python 类中得到反映。
- en: The rest of the tables follow a similar design, with data fields that serve
    the purpose of the data they are storing. You are ready to load data into the
    tables.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的表遵循类似的设计，数据字段服务于存储的数据的目的。您已准备好将数据加载到表中。
- en: Loading Your Data
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载数据
- en: Now that the tables are created, you will populate them with football data.
    You will use SQLite’s `.import` tool to load data files that are in CSV format.
    You will find data files in this chapter’s */data* directory.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表已经创建，您将使用足球数据填充它们。您将使用 SQLite 的 `.import` 工具来加载 CSV 格式的数据文件。您可以在本章的 */data*
    目录中找到数据文件。
- en: Before you execute the import, you need to configure SQLite to enforce foreign
    keys. This means that if you try to insert a record into a child table (a table
    containing the `FOREIGN KEY` statement) that doesn’t match a record in the parent
    table (the table named in the `REFERENCES` of a foreign key), an error will occur
    and the record won’t be imported. For example, when foreign keys are enforced,
    you can’t insert a record in the `performance` table that uses a `player_id` value
    that isn’t in the `player` table.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行导入之前，您需要配置 SQLite 以强制执行外键。这意味着如果您尝试向子表（包含 `FOREIGN KEY` 语句的表）插入一个记录，该记录与父表（外键
    `REFERENCES` 中命名的表）中的记录不匹配，将发生错误，并且记录不会被导入。例如，当强制执行外键时，您不能在 `performance` 表中插入一个使用不在
    `player` 表中的 `player_id` 值的记录。
- en: 'Turn on foreign key enforcement with the following statement:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下语句启用外键约束：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Prepare the import statement to recognize CSV format with the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令准备导入语句以识别 CSV 格式：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the following commands from the `sqlite` prompt to load the data. Run them
    in the order shown here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `sqlite` 提示符运行以下命令来加载数据。按照此处显示的顺序运行它们：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use the following commands to verify that the correct number of records was
    loaded into each table. The `performance` table has been loaded with records using
    two different `last_changed_date` values so that you can verify date searching
    functions are working correctly:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令验证每个表是否加载了正确数量的记录。`performance` 表已使用两个不同的 `last_changed_date` 值加载了记录，以便您可以验证日期搜索功能是否正常工作：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To exit the SQLite application, type **`.exit`**:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出 SQLite 应用程序，请输入 **`.exit`**：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You have loaded sample data in your database, which represents the data from
    the SWC website data. Now you’ll start using it with Python.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您已在数据库中加载了示例数据，它代表了 SWC 网站数据。现在您将开始使用 Python 来使用它。
- en: Accessing Your Data Using Python
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 访问您的数据
- en: There are several ways to access this data in Python. For example, you could
    create a connection to the database and execute SQL queries directly. This sounds
    simple, but you would quickly run into several issues, such as mapping the SQLite
    data types into Python objects. You would also need to take steps to avoid SQL
    injection attacks when you accept input from your API users.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中访问这些数据有几种方法。例如，您可以创建到数据库的连接并直接执行 SQL 查询。这听起来很简单，但您会迅速遇到几个问题，例如将 SQLite
    数据类型映射到 Python 对象。您还需要采取措施来避免在从 API 用户接受输入时发生 SQL 注入攻击。
- en: 'To avoid this manual work, you will use an ORM, which handles the process of
    reading database tables and creating Python objects from them. You will be using
    a very common Python ORM: SQLAlchemy.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这项手动工作，您将使用 ORM，它处理从数据库表读取并从中创建 Python 对象的过程。您将使用一个非常常见的 Python ORM：SQLAlchemy。
- en: Installing SQLAlchemy in Your Environment
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您的环境中安装 SQLAlchemy
- en: SQLAlchemy is the first Python library that you will need to install directly
    in your Codespace. You want to be certain of the version of SQLAlchemy installed,
    so first create a `pip` requirements file in the directory with your Python code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 是您需要直接在 Codespace 中安装的第一个 Python 库。您需要确保安装的 SQLAlchemy 版本正确，因此首先在包含您的
    Python 代码的目录中创建一个 `pip` 需求文件。
- en: 'In your editor, create a file named *requirements.txt* with the following contents,
    and save the file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的编辑器中，创建一个包含以下内容的文件，并将其命名为 *requirements.txt*，然后保存该文件：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This file will be used to install libraries from the `pip` Python package manager.
    These libraries are stored on the internet, and `pip` will automatically download
    them to your Codespace.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件将用于从 `pip` Python 软件包管理器安装库。这些库存储在互联网上，`pip` 将自动将它们下载到你的 Codespace。
- en: Throughout the book, you will add additional Python libraries to your Codespace.
    Using the requirements file is a convenient way to install multiple libraries
    and make sure the versions of the libraries are all compatible with one another.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你将在你的 Codespace 中添加额外的 Python 库。使用需求文件是安装多个库并确保库版本之间兼容的便捷方式。
- en: 'To install the library, execute the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装库，请执行以下命令：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should see a message that says SQLAlchemy 2.0 or higher has been successfully
    installed or was “already satisfied.” To verify the installation, type **`pip3
    show SQLAlchemy`** and you will receive a confirmation similar to the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个消息，表明 SQLAlchemy 2.0 或更高版本已成功安装或“已满足”。要验证安装，请输入 **`pip3 show SQLAlchemy`**，你将收到类似于以下内容的确认：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating Python Files for Database Access
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为数据库访问创建 Python 文件
- en: You will now create the files that are required to query the database using
    Python. [Table 3-2](#file_table_chapter_3) explains the purpose of all the files
    you will have when this chapter is complete.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将创建使用 Python 查询数据库所需的文件。[表 3-2](#file_table_chapter_3) 解释了当你完成本章时将拥有的所有文件的用途。
- en: Table 3-2\. Purpose of the Chapter 3 files
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-2\. 第 3 章文件的用途
- en: '| Filename | Purpose |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 文件名 | 用途 |'
- en: '| --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *crud.py* | Helper function to query the database |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| *crud.py* | 查询数据库的辅助函数 |'
- en: '| *database.py* | Configures SQLAlchemy to use the SQLite database |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| *database.py* | 配置 SQLAlchemy 使用 SQLite 数据库 |'
- en: '| *models.py* | Defines the SQLAlchemy classes related to the database tables
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| *models.py* | 定义与数据库表相关的 SQLAlchemy 类 |'
- en: '| *requirements.txt* | Used to install specific versions of libraries with
    the `pip` package manager |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| *requirements.txt* | 用于使用 `pip` 软件包管理器安装特定版本的库 |'
- en: '| test_crud.py | The pytest file to unit-test your SQLAlchemy files |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| test_crud.py | 用于单元测试你的 SQLAlchemy 文件 pytest 文件 |'
- en: The file named *models.py* will contain the Python representation of the data.
    The classes in this file will be used when you query databases in Python.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 *models.py* 的文件将包含数据的 Python 表示形式。该文件中的类将在你使用 Python 查询数据库时使用。
- en: 'Here are the two tasks that you need to perform in this file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，你需要执行的两个任务是：
- en: Define the SQLAlchemy classes to store information from database tables.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 SQLAlchemy 类以存储数据库表中的信息。
- en: Describe the relationship between these tables so that the Python code can access
    the related tables.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述这些表之间的关系，以便 Python 代码可以访问相关表。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: The term *model* is used in a lot of different ways in this book, which is unavoidable
    but confusing. In this instance, the SQLAlchemy model is a Python representation
    of the data from the SQLite database.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，“模型”一词被用于许多不同的方式，这是不可避免的，但可能会造成混淆。在这种情况下，SQLAlchemy 模型是 SQLite 数据库中数据的
    Python 表示形式。
- en: 'Create a file with the following contents, and name it *models.py*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的文件，并将其命名为 *models.py*：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Take a look at *models.py* piece by piece. At the top of most Python files,
    you will find `import` statements. The power of the Python ecosystem comes from
    the variety of external libraries you can use. The process you will use in this
    book is to install the libraries using the `pip` package manager, and then reference
    them in your code using import statements:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个查看 *models.py* 文件。在大多数 Python 文件的顶部，你会找到 `import` 语句。Python 生态系统的强大之处在于你可以使用的各种外部库。本书中你将使用的过程是使用
    `pip` 软件包管理器安装库，然后在代码中使用导入语句引用它们：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_creating_your_database_CO2-1)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_your_database_CO2-1)'
- en: Because this file will create Python representations of the database tables,
    you first import the data types that SQLAlchemy will use for the database fields.
    For more information about SQLAlchemy data types, reference the [SQLAlchemy Type
    Hierarchy](https://oreil.ly/Z1jfo).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因为此文件将创建数据库表的 Python 表示形式，所以你首先需要导入 SQLAlchemy 将用于数据库字段的类型。有关 SQLAlchemy 数据类型的更多信息，请参考
    [SQLAlchemy 类型层次](https://oreil.ly/Z1jfo)。
- en: '[![2](assets/2.png)](#co_creating_your_database_CO2-2)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_your_database_CO2-2)'
- en: Next, you import SQLAlchemy’s relationship functionality, which enables foreign
    key relationships between tables.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您导入 SQLAlchemy 的关系功能，它允许表之间建立外键关系。
- en: '[![3](assets/3.png)](#co_creating_your_database_CO2-3)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_your_database_CO2-3)'
- en: The `database` import refers to the *database.py* file with the SQLAlchemy configuration.
    You are using the `Base` class, which is a standard template you’ll use for the
    classes in the *models.py* file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`database` 导入指的是包含 SQLAlchemy 配置的 *database.py* 文件。您正在使用 `Base` 类，这是一个标准模板，您将在
    *models.py* 文件中的类中使用。'
- en: 'Now it’s time to begin the definition of the `Player` class, which is the Python
    class you’ll use to store data from the SQLite `player` table. You do this using
    the `class` statement, stating the name of the class and specifying that it will
    be a subclass of the `Base` template imported from the *database.py* file. Use
    the magic command `*tablename*` to tell SQLAlchemy to reference the `player` table.
    Because of this statement, when you ask SQLAlchemy to query `Player`, it will
    know behind the scenes to access the `player` table in the database. This is one
    of the key benefits of an ORM—mapping the Python code automatically to the underlying
    database:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是开始定义 `Player` 类的时候了，这是您将用于存储 SQLite `player` 表数据的 Python 类。您使用 `class` 语句来完成此操作，指定类的名称，并说明它将是来自
    *database.py* 文件的 `Base` 模板的子类。使用魔法命令 `*tablename*` 来告诉 SQLAlchemy 引用 `player`
    表。因为这个语句，当您要求 SQLAlchemy 查询 `Player` 时，它会在幕后知道访问数据库中的 `player` 表。这是 ORM 的一个关键好处——自动将
    Python 代码映射到底层数据库：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The rest of the `Player` class definition maps additional details about the
    database table. Each statement defines one attribute in the class using the `Column`
    method provided by SQLAlchemy:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 类的其余定义映射了数据库表的更多详细信息。每个语句都使用 SQLAlchemy 提供的 `Column` 方法在类中定义一个属性：'
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here are a few things to notice about the definitions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义中需要注意以下几点：
- en: The attribute names are automatically matched to the column names in the database.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性名称会自动匹配到数据库中的列名称。
- en: The data types used (e.g., `String`, `Integer`) are SQLAlchemy data types that
    you specified in your `import` statement at the beginning of the file.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的数据类型（例如，`String`，`Integer`）是 SQLAlchemy 数据类型，您在文件开头 `import` 语句中指定的。
- en: The `primary_key` definition provides several benefits from SQLAlchemy, such
    as query optimization, enforcing uniqueness, and enabling relationships between
    classes.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`primary_key` 定义提供了 SQLAlchemy 的几个好处，如查询优化、强制唯一性和在类之间启用关系。'
- en: 'Along with the definition of the tables, you define the foreign key relationship
    between the tables using the `relationship()` function. This results in a `Player​.per⁠formances`
    attribute that will return all the related rows from the `performance` table for
    each row in the `player` table:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义表之外，您还使用 `relationship()` 函数定义表之间的外键关系。这导致一个 `Player.performances` 属性，它将为
    `player` 表中的每一行返回 `performance` 表中相关的所有行：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There is another kind of relationship, which uses the `team_player` association
    table to connect `player` to `team`. By defining `secondary="team_player"`, this
    relationship allows a `Player` record to have an attribute named `Player.teams`.
    This is the many-to-many relationship that was discussed when creating the database
    tables:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种关系类型，它使用 `team_player` 关联表将 `player` 连接到 `team`。通过定义 `secondary="team_player"`，这种关系允许
    `Player` 记录有一个名为 `Player.teams` 的属性。这是在创建数据库表时讨论的许多多关系之一：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next is the definition for the `Performance` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `Performance` 类的定义：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This class has a `player` relationship that is the mirror image of the `performances`
    relationship in the `player` table. When you look at these two relationships together,
    you can see that the `back_populates` statement in one refers to the variable
    assigned in the other. Together these allow a two-way relationship between the
    parent (`player`) and child (`performance`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个 `player` 关系，它是 `player` 表中 `performances` 关系的镜像。当您一起查看这两个关系时，您可以看到一个关系中的
    `back_populates` 语句引用了另一个中的变量。这些共同允许父（`player`）和子（`performance`）之间的双向关系。
- en: 'Next up is the `League` class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `League` 类：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`League` is going to be the topmost parent class in your code, as was reflected
    in [Figure 3-2](#database_structure_ch3). The `teams` relationship will be used
    to enable `League.teams` in this class and has a matching relationship in the
    `Team` class.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`League` 将成为你代码中最顶层的父类，正如 [图 3-2](#database_structure_ch3) 所反映的那样。`teams` 关系将用于在这个类中启用
    `League.teams`，并在 `Team` 类中有一个匹配的关系。'
- en: 'Look at the next block of code, which defines the `Team` class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下一个代码块，它定义了 `Team` 类：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that this file has matching relationships to connect with the `league`
    table and indirectly to the `player` table.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个文件有匹配的关系来连接到 `league` 表，并间接连接到 `player` 表。
- en: 'The last class definition is for the `team-player` table:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个类定义是为 `team-player` 表：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `TeamPlayer` class is created without any relationships, because those are
    defined on the `Team` and `Player` classes. You have now defined all of the SQLAlchemy
    models needed for the new database tables and the necessary database configuration
    file. Excellent progress!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`TeamPlayer` 类在没有任何关系的情况下创建，因为这些关系是在 `Team` 和 `Player` 类中定义的。你现在已经定义了所有为新的数据库表和必要的数据库配置文件所需的
    SQLAlchemy 模型。进展非常出色！'
- en: Creating the Database Configuration File
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库配置文件
- en: 'Next, a file named *database.py* will set up the SQLAlchemy configuration to
    connect to the SQLite database, along with some other Python objects that you’ll
    use for database work. The tasks that you need to accomplish in this file are
    the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将创建一个名为 *database.py* 的文件，该文件将设置 SQLAlchemy 配置以连接到 SQLite 数据库，以及一些你将用于数据库工作的其他
    Python 对象。你需要在这个文件中完成的任务如下：
- en: Create a database connection that points to the SQLite database and has the
    correct settings.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个指向 SQLite 数据库并具有正确设置的数据库连接。
- en: 'Create a parent class that you’ll use to define the Python table classes:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个父类，你将使用它来定义 Python 表类：
- en: 'Create a file with the following contents, and name it *database.py*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的文件，并将其命名为 *database.py*：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Take a look at this file piece by piece. Three specific functions are imported
    from the SQLAlchemy libraries. Although it would be possible to import the entire
    SQLAlchemy library all at once, it is better to import specific functions to limit
    possible conflicts between duplicate functions in multiple libraries:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个查看这个文件。从 SQLAlchemy 库中导入了三个特定的函数。虽然可以一次性导入整个 SQLAlchemy 库，但最好导入特定的函数以限制多个库中重复函数可能产生的冲突：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The next three steps work together to get the *session*, which is a SQLAlchemy
    object that manages the conversation with the database. Create a database URL
    that tells SQLAlchemy what type of database you’ll be using (SQLite) and where
    to find the file (in the same folder as this file, with the name *fantasy_data.db*):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的三个步骤共同工作以获取 *session*，这是一个 SQLAlchemy 对象，用于管理与数据库的对话。创建一个数据库 URL，告诉 SQLAlchemy
    你将使用哪种类型的数据库（SQLite）以及在哪里可以找到该文件（与该文件在同一文件夹中，文件名为 *fantasy_data.db*）：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using this database URL, create an `engine` object, with one configuration
    setting that allows multiple connections to this database without an error being
    thrown:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个数据库 URL，创建一个 `engine` 对象，其中一个配置设置允许对该数据库进行多次连接而不会抛出错误：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, use the `engine` object to create a session named `SessionLocal` that
    points to that engine and adds a couple of more configuration settings:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 `engine` 对象创建一个名为 `SessionLocal` 的会话，该会话指向该引擎并添加了一些额外的配置设置：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The last command in this file creates a `Base` class. This is a standard template
    SQLAlchemy provides for the models you will create in the *models.py* file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件中的最后一个命令创建了一个 `Base` 类。这是 SQLAlchemy 为你在 *models.py* 文件中创建的模型提供的一个标准模板：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Creating SQLAlchemy Helper Functions
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 SQLAlchemy 辅助函数
- en: The files created so far give you a connection to the database and classes that
    represent database tables. Next, you will create the file *crud.py* that contains
    query functions. This strange-sounding name stands for Create, Read, Update, Delete
    (CRUD).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止创建的文件为你提供了与数据库和表示数据库表的类的连接。接下来，你将创建一个名为 *crud.py* 的文件，该文件包含查询函数。这个听起来有些奇怪的名称代表创建（Create）、读取（Read）、更新（Update）、删除（Delete）（CRUD）。
- en: 'Create a file with the following contents, and name it *crud.py*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的文件，并将其命名为 *crud.py*：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s look at the import statements in *crud.py*:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 *crud.py* 中的导入语句：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_creating_your_database_CO3-1)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_creating_your_database_CO3-1]'
- en: '`Session` and `joinedload` are used by the query functions.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Session` 和 `joinedload` 在查询函数中被使用。'
- en: '[![2](assets/2.png)](#co_creating_your_database_CO3-2)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_creating_your_database_CO3-2]'
- en: The `date` will be an important data type to allow you to filter by date.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`date`将是一个重要的数据类型，允许您按日期进行筛选。'
- en: '[![3](assets/3.png)](#co_creating_your_database_CO3-3)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_your_database_CO3-3)'
- en: This import lets you reference the model file that you created. These functions
    reference the classes that you created in *models.py* and use SQLAlchemy built-in
    functions to retrieve data using prepared SQL statements.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此导入允许您引用您创建的模型文件。这些函数引用您在`models.py`中创建的类，并使用SQLAlchemy内置函数通过预定义SQL语句检索数据。
- en: 'Take a look at the first query:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 看看第一个查询：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The parameters in this function include a database session, which the function
    will use to connect to the database, and a specific `player_id` value. By using
    `filter(models.Player.player_id == player_id).first()`, this function looks up
    a specific `Player.player_id` value and returns the first matching instance. Because
    you have defined `player_id` as a primary key in the *models.py* file and the
    SQLite database, this query will return a single result.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数中的参数包括数据库会话，该函数将使用它来连接到数据库，以及特定的`player_id`值。通过使用`filter(models.Player.player_id
    == player_id).first()`，此函数查找特定的`Player.player_id`值并返回第一个匹配的实例。因为您在`models.py`文件和SQLite数据库中将`player_id`定义为主键，所以此查询将返回单个结果。
- en: 'The signature of the next function adds several new parameters to the `.query()`
    statement:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数的签名向`.query()`语句添加了几个新参数：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `skip` and `limit` parameters will be used for *pagination*, which allows
    the user to specify a set of records in chunks rather than a full list. The `min_last_changed_date`
    parameter will be used to exclude records older than a specified date.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip`和`limit`参数将用于*分页*，允许用户指定记录的集合而不是完整列表。`min_last_changed_date`参数将用于排除早于指定日期的记录。'
- en: The `int = 0` on the `skip` parameter sets a default value of zero. If this
    parameter isn’t sent in a call to this function, `skip` will default to zero.
    The `limit` has a default of 100\. There is no default given for `min_last_changed_date`,
    `first_name`, and `last_name`, so those default to null.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip`参数上的`int = 0`设置了默认值为零。如果在这个函数的调用中没有发送此参数，`skip`将默认为零。`limit`的默认值为100。对于`min_last_changed_date`、`first_name`和`last_name`没有给出默认值，因此它们默认为null。'
- en: 'The body of the function uses the queries to filter the results:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体使用查询来筛选结果：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The last statement applies the `skip` and `limit` parameters:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句应用了`skip`和`limit`参数：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This statement applies the `skip` and `limit` parameters to grab a specific
    chunk of records from the query results. The `skip` instructs the query to skip
    a number of records from the beginning of the results, and `limit` instructs the
    query to return only a certain number of records. For instance, a user might begin
    by skipping zero and limiting 20\. This would return the first 20 records. They
    could call it again, this time skipping 20 and limiting 20\. This would grab the
    next 20.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句将`skip`和`limit`参数应用于查询结果中抓取特定记录块。`skip`指示查询从结果开始处跳过一定数量的记录，而`limit`指示查询只返回一定数量的记录。例如，用户可能从跳过零并限制20开始。这将返回前20条记录。他们可以再次调用它，这次跳过20并限制20。这将抓取下20条记录。
- en: 'The `get_leagues` function uses a new statement, so it is worth a closer look:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_leagues`函数使用了一个新语句，因此值得仔细看看：'
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This function uses the `.options(joinedload(models.League.teams))` statement.
    This is a type of *eager loading*, which causes SQLAlchemy to retrieve the joined
    `team` data when it retrieves the `league` data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用`.options(joinedload(models.League.teams))`语句。这是一种*懒加载*类型，导致SQLAlchemy在检索`league`数据时检索关联的`team`数据。
- en: 'The final set of queries are designed to support AI and large language models,
    based on the recommendation to provide a separate endpoint for analytics questions.
    You will create endpoints that provide counts for users, leagues, and teams. This
    will help the AI use the pagination functions, and it will answer questions about
    the number of records without making large API calls:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的查询集旨在支持人工智能和大型语言模型，基于提供单独端点用于分析问题的建议。您将创建提供用户、联赛和球队计数的端点。这将帮助人工智能使用分页功能，并回答有关记录数量的查询，而无需进行大型API调用：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You have created all the SQLAlchemy classes and helper functions. Since all
    of the functions in *crud.py* are reading (querying) data, you have only implemented
    the “r” in CRUD. That is appropriate, because all of your user stories require
    read-only functionality. If you were developing an API that allowed creating,
    updating, or deleting records, this file could be extended with additional functions.
    Now it is time to unit-test these queries with pytest.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您已创建了所有SQLAlchemy类和辅助函数。由于 *crud.py* 中的所有函数都是读取（查询）数据，您只实现了CRUD中的“r”。这是合适的，因为您的所有用户故事都需要只读功能。如果您正在开发允许创建、更新或删除记录的API，则此文件可以扩展以包含额外的函数。现在，是时候使用pytest对这些查询进行单元测试了。
- en: Installing pytest in Your Environment
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您的环境中安装pytest
- en: 'Now that all the database code is written, you are ready to test it. You will
    use the pytest library for this task. First, add an entry to the *requirements.txt*
    file for pytest. The updated file should look like the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有数据库代码都已编写，您已准备好对其进行测试。您将使用pytest库来完成此任务。首先，在 *requirements.txt* 文件中添加pytest条目。更新后的文件应如下所示：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To install pytest, execute the following command again:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装pytest，再次执行以下命令：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should see a message that says pytest 8.1.0 or higher has been successfully
    installed or was “already satisfied.” To verify the installation, type **`pip3
    show Pytest`** and you will receive a confirmation similar to the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个消息，表明pytest 8.1.0或更高版本已成功安装或“已满足”。要验证安装，请键入 **`pip3 show Pytest`**，您将收到类似于以下内容的确认：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Testing Your SQLAchemy Code
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试您的SQLAlchemy代码
- en: As the library’s summary says, pytest is simple to use. There are a couple of
    naming conventions that pytest expects. Any file that contains tests will have
    a filename beginning with *test* followed by an underscore or ending with an underscore
    followed by *test*. Inside the test file, pytest will execute any function name
    beginning with *test*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如库的总结所述，pytest易于使用。pytest期望一些命名约定。任何包含测试的文件都将有一个以 *test* 开头，后跟下划线或以下划线结尾后跟 *test*
    的文件名。在测试文件中，pytest将执行任何以 *test* 开头的函数名。
- en: Inside the test functions, you will include an `assert` statement. If it returns
    true, the flow continues. If all assertions evaluate as true in the test, the
    test returns with a success status. If an assertion evaluates as false, the code
    raises an `AssertionError` and the test evaluates as false.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试函数内部，您将包含一个 `assert` 语句。如果它返回true，则流程继续。如果测试中的所有断言都评估为true，则测试以成功状态返回。如果断言评估为false，则代码引发一个
    `AssertionError`，并且测试评估为false。
- en: 'Your unit tests will be very basic: they will check that the row counts returned
    from your SQLAlchemy classes match the values you checked in the previous SQL
    query.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您的单元测试将非常基础：它们将检查从您的SQLAlchemy类返回的行数是否与您在之前的SQL查询中检查的值匹配。
- en: 'Create a file named *test_crud.py* with the following contents:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 *test_crud.py* 的文件，内容如下：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, look at how this file follows the conventions expected by pytest. The
    file is named *test_crud.py*, so it will be recognized as a test file automatically.
    The file contains six function names beginning with *test_*. These will be executed
    when the file runs. Each of these test functions ends with an `assert` statement.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看看这个文件是如何遵循pytest期望的约定的。文件被命名为 *test_crud.py*，因此它将被自动识别为测试文件。文件包含以 *test_*
    开头的六个函数名。这些函数将在文件运行时被执行。这些测试函数每个都以一个 `assert` 语句结束。
- en: 'The first function needs a bit of explanation. On top of the function is the
    decorator `@pytest.fixture(scope="function")`. A fixture is used during the *arrange*
    phase, which prepares the testing setup. This fixture uses session scope, which
    means it will run once for each function:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数需要一些解释。在函数上方是装饰器 `@pytest.fixture(scope="function")`。在 *arrange* 阶段，即准备测试设置时，会使用到fixture。此fixture使用session范围，这意味着它将为每个函数运行一次：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The body of the `db_session()` function creates a database session, pauses
    while the test function uses the session (through the `yield` statement), and
    then closes the session when the test completes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`db_session()` 函数的主体创建了一个数据库会话，在测试函数使用会话（通过 `yield` 语句）时暂停，并在测试完成后关闭会话：'
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To verify the date-based queries are working correctly, the queries for `performance`
    check the full results and then results that are limited using `last_changed_date`.
    First remember that in the SQL queries earlier you got the following results for
    the `performance` table:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证基于日期的查询是否正常工作，`performance` 查询首先检查完整结果，然后使用 `last_changed_date` 限制的结果。首先记住，在之前的
    SQL 查询中，你得到了以下 `performance` 表的结果：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To verify the first result using pytest, this function does not include a data
    parameter:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 pytest 验证第一个结果，这个函数不包括数据参数：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To verify the second result, the next function uses a `last_changed_date` value
    of `2024_04_01`, set in the `test_date` variable at the top of the testing code.
    That date is earlier that all by 2,711 records:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证第二个结果，下一个函数使用了一个 `last_changed_date` 值为 `2024_04_01`，这个值设置在测试代码顶部的 `test_date`
    变量中。这个日期比所有记录都要早 2,711 条：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The last test verifies one of the analytics queries:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个测试验证了一个分析查询：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To execute the tests, enter the **`pytest test_crud.py`** command and you should
    see an output that looks similar to this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行测试，请输入 **`pytest test_crud.py`** 命令，你应该会看到一个类似以下输出的结果：
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You have verified that your SQLAlchemy classes and a few helper functions work
    correctly—way to go! The database work is done.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经验证了你的 SQLAlchemy 类和一些辅助函数工作正常——做得好！数据库工作已完成。
- en: Additional Resources
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'SQL is one of the essential skills for data professionals. The number of resources
    available is limitless, but here are a couple to start:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 是数据专业人士必备的一项基本技能。可用的资源数量无限，但以下是一些开始的地方：
- en: '*Learning SQL, 3rd Edition*, by Alan Beaulieu (O’Reilly, 2020)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*学习 SQL，第 3 版*》，由艾伦·博利厄（O’Reilly，2020年）
- en: '*SQL Pocket Guide, 4th Edition*, by Alice Zhao (O’Reilly, 2021)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*SQL 实用指南，第 4 版*》，由爱丽丝·赵（O’Reilly，2021年）
- en: To learn more about SQLAlchemy, check out [the official SQLAlchemy 2 documentation](https://oreil.ly/PhsUf).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 SQLAlchemy 的信息，请查看 [官方 SQLAlchemy 2 文档](https://oreil.ly/PhsUf)。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you created your database and the SQLAlchemy code to read
    it. Here is what you accomplished in this chapter:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你创建了数据库和用于读取的 SQLAlchemy 代码。以下是本章你取得的成就：
- en: You designed your database tables and their relationships.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你设计了数据库表及其关系。
- en: You created a database using SQLite and created all of your tables using SQL
    commands.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用 SQLite 创建了一个数据库，并使用 SQL 命令创建了所有表。
- en: You imported data from CSV files to load your tables.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你从 CSV 文件中导入数据以加载数据表。
- en: You created the Python model files and database configuration files.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你创建了 Python 模型文件和数据库配置文件。
- en: You created helper functions to query your database.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你创建了查询数据库的辅助函数。
- en: You unit-tested the end-to-end database functionality using pytest.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用 pytest 对端到端数据库功能进行了单元测试。
- en: In [Chapter 4](ch04.html#chapter_4), you will create the FastAPI code to use
    this data and publish it as a REST API.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](ch04.html#chapter_4)，你将创建 FastAPI 代码来使用这些数据并将其发布为 REST API。
