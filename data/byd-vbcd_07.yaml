- en: 'Chapter 5\. Understanding Generated Code: Review, Refine, Own'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：理解生成的代码：审查、精炼、掌握
- en: 'You’ve learned how to prompt an AI to generate code, and by this point you’ve
    likely produced some code using these techniques. Now comes a critical phase:
    making sure that code is correct, safe, and maintainable.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何提示AI生成代码，到这个阶段，你很可能已经使用这些技术生成了一些代码。现在进入一个关键阶段：确保代码是正确的、安全的和可维护的。
- en: As a developer, you can’t just take the AI’s output and blithely ship it. You
    need to review it, test it, possibly improve it, and integrate it with the rest
    of your codebase. This chapter focuses on how to understand what the AI gave you,
    iteratively edit and debug it, and fully take ownership of the code as part of
    your project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你不能仅仅接受AI的输出并随意发布。你需要审查它，测试它，可能还需要改进它，并将其集成到你的代码库中。本章重点介绍如何理解AI提供的内容，迭代编辑和调试它，并将代码作为项目的一部分完全掌握。
- en: 'This chapter covers:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖：
- en: Interpreting the AI’s code in terms of your original intent
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将AI的代码解释为你的原始意图
- en: The “majority solution” phenomenon, or why AI-generated code often looks like
    a common solution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “多数解决方案”现象，或为什么AI生成的代码常常看起来像常见解决方案
- en: Techniques to review code for clarity and potential issues
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码清晰性和潜在问题审查的技术
- en: Debugging AI-written code when it doesn’t work as expected
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当AI编写的代码不符合预期时进行调试
- en: Refactoring the code for style or efficiency
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化代码以改进风格或效率
- en: Writing tests to validate the code’s behavior
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试以验证代码的行为
- en: By mastering these skills, you’ll be able to integrate AI contributions into
    your projects with confidence.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握这些技能，你将能够自信地将AI的贡献整合到你的项目中。
- en: 'From Intent to Implementation: Understanding the AI’s Interpretation'
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从意图到实现：理解AI的解释
- en: When you get the AI’s code, your first step should be to compare it to your
    intent (the prompt you gave). Does the code fulfill the requirements you set out?
    Sometimes the AI might slightly misinterpret or only partially implement what
    you asked.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你得到AI的代码时，你的第一步应该是将其与你的意图（你给出的提示）进行比较。代码是否满足你设定的要求？有时AI可能会略微误解或只部分实现你所要求的。
- en: 'Read through the code carefully. Step through it in your mind or on paper:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读代码。在心中或纸上逐步执行：
- en: Trace what it does for a typical input.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪它对典型输入所做的事情。
- en: If your prompt had multiple parts (“do X and Y”), verify that the AI has done
    them all.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的提示有多个部分（“做X和Y”），验证AI是否都完成了。
- en: Ensure that the AI didn’t add functionality you didn’t ask for—sometimes it
    will add an extra feature it “thinks” is useful, like adding logging or a parameter,
    which could be OK or not.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保AI没有添加你未请求的功能——有时它会添加一个它认为有用的额外功能，比如添加日志或参数，这可能可以接受，也可能不行。
- en: Just as you would with a colleague’s code, if something is unclear, note it.
    If you look for a good reason for it to be there, you might find one. If you don’t,
    query it or consider removing it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对待同事的代码一样，如果有什么不清楚的地方，记下来。如果你寻找一个合理的理由来解释它为什么在那里，你可能会找到一个。如果没有，查询它或考虑移除它。
- en: For example, if you ask for a prime-number checker and the AI code also prints
    something like “Checking 7…” for each number, that may be an artifact of how you
    prompted it or a pattern from its training data (some tutorial code prints its
    progress). If you don’t want that, plan to remove it or prompt the AI to remove
    it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你要求一个素数检查器，而AI代码还打印出“检查7...”这样的信息，这可能是因为你如何提示它或其训练数据中的模式（一些教程代码会打印其进度）。如果你不希望这样，计划移除它或提示AI移除它。
- en: Also make sure the edge cases are handled as you expect. If you intended it
    to handle empty input, does it? If the input could be `None` or negative, did
    the AI consider that?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 确保边缘情况按照你的预期处理。如果你打算处理空输入，它做到了吗？如果输入可能是`None`或负数，AI考虑到了吗？
- en: If something about your prompt was ambiguous and the AI had to choose an interpretation,
    identify where that happened. Perhaps you didn’t specify an output format, and
    it chose to print results instead of returning them. Now you have to decide if
    you want to accept that or modify the code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的提示中有一些内容不明确，AI不得不做出选择，确定发生这种情况的地方。也许你没有指定输出格式，它选择打印结果而不是返回结果。现在你必须决定是否接受它或修改代码。
- en: This understanding phase is crucial; don’t skip it. Even if you’re going to
    test the code, understanding it by reading is important because tests might not
    cover everything (and reading is faster for some obvious things).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个理解阶段至关重要；不要跳过它。即使你打算测试代码，通过阅读来理解它也很重要，因为测试可能无法涵盖所有内容（而且阅读对于一些明显的事情来说更快）。
- en: Last, consider the AI’s assumptions. AI often goes for the “majority” or most
    common interpretation (which leads us to the next section).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑AI的假设。AI通常倾向于“多数”或最常见的解释（这引出了下一个部分）。
- en: 'The “Majority” Problem: Most Common Doesn’t Mean Most Appropriate'
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “多数”问题：最常见的不一定是最合适的
- en: AI models trained on lots of code will often produce the solution that’s most
    represented in that training data (or the simplest solution that fits). I call
    this the *majority solution* effect. It’s correct in general cases, but it might
    not be the best for your specific situation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在大量代码上训练的AI模型通常会生成在训练数据中最常见（或最简单）的解决方案。我称之为“多数解决方案”效应。它在一般情况下是正确的，但可能不适合你的具体情况。
- en: For example, if you ask for a search algorithm without further context, the
    AI might output a basic linear search, because that’s straightforward and common.
    Maybe you actually needed a binary search, but the AI didn’t know that efficiency
    was critical, because you didn’t say so. Linear search works for many moderate
    cases but not if performance is key.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你没有提供更多上下文就要求一个搜索算法，AI可能会输出一个基本的线性搜索，因为这是直接且常见的。也许你实际上需要一个二分搜索，但AI不知道效率是关键，因为你没有说明。线性搜索对于许多适度的情况有效，但如果性能是关键，则不适用。
- en: Similarly, the AI might use a global variable because many simple examples do,
    but perhaps in your project, that’s not acceptable practice.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，AI可能会使用全局变量，因为许多简单示例都这样做，但也许在你的项目中，这不是可接受的实践。
- en: Be mindful that the AI’s solution might optimize for a generic scenario. As
    a human developer, you have insight into context that the AI lacks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意AI的解决方案可能针对通用场景进行优化。作为一个人类开发者，你拥有AI所缺乏的洞察力。
- en: 'To address this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题：
- en: Identify assumptions in the code. If it assumes a list is sorted or an input
    is valid, was that assumption OK? Did you specify it? If not, maybe it should
    have included a check.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别代码中的假设。如果它假设列表已排序或输入有效，这个假设是否合理？你是否指定了它？如果没有，也许它应该包含一个检查。
- en: 'Consider alternatives: If you know multiple ways to solve the problem (like
    different algorithms), did the AI pick one? Is it the one you want? If not, you
    can prompt for the alternative or just change it.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑替代方案：如果你知道解决这个问题的多种方法（如不同的算法），AI是否选择了其中一个？这是否是你想要的？如果不是，你可以要求替代方案或直接更改它。
- en: If the AI code works for the “usual” case but not for edge conditions that matter
    to you, that’s something to fix. For instance, maybe it didn’t consider integer
    overflow in some math. In many training examples, that might not have been addressed,
    but in your context, it could be important.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果AI代码对于“常规”情况有效，但对于对你来说重要的边缘情况无效，那么这是一个需要解决的问题。例如，它可能没有考虑某些数学中的整数溢出。在许多训练示例中，这可能没有被解决，但在你的情况下，它可能很重要。
- en: Understanding that the AI tends toward generic solutions will make you better
    at reviewing its code. It’s not magic or tailor-made; it’s a very educated guess
    at a solution. The tailoring is your job.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 了解AI倾向于通用解决方案将使你在审查其代码时更加出色。它不是魔法或量身定制；它是对解决方案的一个非常明智的猜测。定制是你的工作。
- en: 'Code Readability and Structure: Patterns and Potential Issues'
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码可读性和结构：模式和潜在问题
- en: 'AI-generated code often has some telltale patterns. It might:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: AI生成的代码通常有一些明显的模式。它可能：
- en: Include more comments than usual or oddly phrased comments (since it learned
    from tutorial code, which tends to be heavily commented)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比平常包含更多的注释或措辞奇怪的注释（因为它是从教程代码中学习的，而教程代码通常注释很多）
- en: Use certain variable names consistently (like i, j, k for loops)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用某些变量名保持一致（如i、j、k用于循环）
- en: Lay out code in a somewhat verbose style (to cover general cases)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以某种冗长的风格布局代码（以覆盖通用情况）
- en: 'Check for these and consider whether they match your project’s style. The code
    might be functionally fine but need a readability pass. In that pass, you may
    want to:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 检查这些并考虑它们是否与你的项目风格相符。代码可能在功能上没有问题，但可能需要可读性审查。在这个审查过程中，你可能想要：
- en: Rename variables to be more descriptive or consistent with your codebase.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将变量重命名为更具描述性或与你的代码库保持一致。
- en: Remove or refine comments. If it added a comment like `# check if number is
    prime` above a self-explanatory `if` statement, you could remove that. But if
    it has a comment explaining a complex bit of logic, that’s good—keep or improve
    it.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除或精炼注释。如果它添加了一个注释，比如在自解释的`if`语句上方写`# check if number is prime`，你可以删除它。但如果它有一个解释复杂逻辑的注释，那很好——保留或改进它。
- en: Ensure consistent formatting by running the code through a linter or formatter
    (like Black for Python or `gofmt` for Go) to match the spacing and bracket styles
    you want.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过运行代码通过一个代码检查器或格式化工具（如Python的Black或Go的`gofmt`）来确保格式的一致性，以匹配你想要的间距和括号样式。
- en: Also look for any unusual structure. Did the AI define multiple classes or functions
    when you expected one? Sometimes it might break a problem into multiple functions
    because that’s how a training example did it. If that’s overkill, you can inline
    them (or vice versa). Is the code too clever or too naive? AI sometimes produces
    a very straightforward solution or, occasionally, a fancy one-liner. Does that
    align with your team’s preferences? If not, adjust accordingly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 也要寻找任何不寻常的结构。当你预期只有一个类或函数时，AI是否定义了多个？有时它可能会将问题分解成多个函数，因为训练示例就是这样做的。如果这样做过于冗余，你可以将它们内联（或反之亦然）。代码是否过于聪明或过于简单？AI有时会提供一个非常直接或偶尔一个花哨的一行解决方案。这是否符合你团队的偏好？如果不一致，相应地调整。
- en: 'Other potential issues to watch out for include:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其他需要留意的问题包括：
- en: Off-by-one errors
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 离谱的错误
- en: Yes, AI can make those, too. For example, loop boundaries can be tricky. If
    you have time, mentally test a simple case through the loop.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，AI也可以创建这些。例如，循环边界可能很棘手。如果你有时间，通过在循环中测试一个简单的案例来心理测试。
- en: Unhandled exceptions
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 未处理的异常
- en: Does the code assume that a file opens successfully or that all input is in
    the correct format? Add error handling if it’s needed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是否假设文件可以成功打开或所有输入都是正确的格式？如果需要，添加错误处理。
- en: Performance pitfalls
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 性能陷阱
- en: Maybe the AI is using an inner loop on a large dataset for membership checks,
    even though a better approach exists, like using a set. The AI solution might
    be correct but not optimal.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 也许AI在大型数据集上使用内部循环进行成员资格检查，尽管存在更好的方法，比如使用集合。AI解决方案可能是正确的，但不是最优的。
- en: Library usage
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 库的使用
- en: If the code uses a library, ensure it’s one you want to use (and that it’s available).
    Sometimes it might use, say, `numpy` for a simple sum (because it saw that in
    examples in its training data). If dragging in that dependency isn’t worth it,
    you can switch to pure Python or the library you intended.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码使用了库，确保它是你想要使用的（并且它是可用的）。有时它可能会使用，比如说，`numpy`来进行简单的求和（因为它在训练数据中的示例中看到了这一点）。如果引入这个依赖项不值得，你可以切换到纯Python或你打算使用的库。
- en: Inconsistencies
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不一致性
- en: Occasionally, the AI code might have minor inconsistencies, like a function
    docstring saying one thing but the code doing another (if it revised the logic
    but not the comment, for instance). Fix those.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，AI代码可能会有一些小的不一致，比如函数文档字符串说了一件事，但代码做了另一件事（例如，如果它修改了逻辑但没有修改注释）。修复这些问题。
- en: Minor syntax issues
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 小型语法问题
- en: This is rare with well-tested models but not impossible in languages where it
    might confuse something.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这在经过良好测试的模型中很少见，但在可能混淆某些内容的语言中并非不可能。
- en: Using outdated APIs
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用过时的API
- en: The AI might use an old version of a library’s function that has changed, for
    instance. If you see a function call you don’t recognize, quickly check the library
    docs to ensure it’s correct for the version you use.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: AI可能会使用库函数的旧版本，该版本已经更改。如果你看到一个你不认识的函数调用，请快速检查库文档，以确保它适用于你使用的版本。
- en: Placeholders
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符
- en: If the AI output uses placeholders like “Your code here” (rare, but it can happen
    in a generic template), fill those in.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果AI输出使用了占位符，如“Your code here”（虽然很少见，但可能会在通用模板中发生），请填写这些占位符。
- en: In short, treat the AI code as if an intern wrote it and left for the day. You
    need to review it for quality and integrate it properly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，将AI代码视为一个实习生编写并在当天离开的代码。你需要对其进行质量审查并正确集成。
- en: 'Debugging Strategies: Finding and Fixing Errors'
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试策略：查找和修复错误
- en: Let’s say you run the code (or write tests for it, which we’ll cover soon) and
    something’s not working. Debugging AI-generated code is no different than debugging
    your own or someone else’s code—except you didn’t write it, so you might be less
    familiar. But because you’ve carefully read it already, you’re in good shape (see
    [Figure 5-1](#ch05_figure_1_1752630043586545)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你运行了代码（或为其编写测试，我们将在不久的将来介绍），但某些东西不起作用。调试人工智能生成的代码与调试你自己的或他人的代码没有不同——除了你没有编写它，所以你可能不太熟悉。但因为你已经仔细阅读了它，所以你处于良好状态（见图
    [5-1](#ch05_figure_1_1752630043586545)）。
- en: '![](assets/bevc_0501.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bevc_0501.png)'
- en: 'Figure 5-1\. The AI code debugging cycle: execute AI-generated code, capture
    errors, provide error context back to AI for analysis, implement suggested fixes,
    and iterate until resolution.'
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 人工智能代码调试周期：执行人工智能生成的代码，捕获错误，将错误上下文反馈给人工智能进行分析，实施建议的修复，并迭代直到解决。
- en: 'Here’s a six-step approach to debugging:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个六步调试方法：
- en: '*Reproduce the issue.*'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*重现问题。*'
- en: Run the function or code with inputs that fail. Observe the output or error.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用失败的输入运行函数或代码。观察输出或错误。
- en: '*Locate the source of the issue.*'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*定位问题根源。*'
- en: Use typical debugging techniques like print statements, or use a debugger to
    step through. If it’s a logical error (wrong output), trace the logic manually
    or with prints to see where it diverges from your expectations.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用典型的调试技术，如打印语句，或者使用调试器逐步执行。如果是逻辑错误（错误的输出），手动或通过打印跟踪逻辑，看看它偏离了你的预期。
- en: '*Check the prompt against the code.*'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*检查提示与代码的一致性。*'
- en: Sometimes the bug is simply that the code didn’t fully implement the requirement,
    like if you asked for something to be sorted but it isn’t sorting properly. That
    might mean the AI’s logic is flawed or that an edge case (like an empty list)
    isn’t handled.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时候错误仅仅是代码没有完全实现要求，比如如果你要求对某物进行排序但排序不正确。这可能意味着人工智能的逻辑有缺陷，或者没有处理边缘情况（如空列表）。
- en: '*Leverage the AI to debug!*'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*利用人工智能进行调试！*'
- en: You can actually feed the problematic code back into the AI and say, “This code
    is giving the wrong result for X. Can you help find the bug?” Often, it will analyze
    it (like a code review) and point out issues. For example, maybe it sees that
    a loop should go to `len(arr)` but goes to `len(arr)-1`. It might catch that quicker.
    (Be mindful to not fully trust it either—but it’s like asking a colleague to help
    debug.)
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你实际上可以将有问题的代码反馈给人工智能，并说：“这段代码在 X 上给出错误的结果。你能帮我找到错误吗？”通常，它将分析它（就像代码审查一样）并指出问题。例如，它可能看到循环应该跳到
    `len(arr)` 但跳到了 `len(arr)-1`。它可能更快地捕捉到这一点。（但也要注意不要完全信任它——但它就像请求同事帮助你调试。）
- en: '*Fix the code.*'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*修复代码。*'
- en: 'Now you have a choice: fix it manually or prompt the AI for a corrected version.
    If the fix is obvious, just do it. If it’s not, you can try something like “The
    above function fails on input X (expected Y, got Z). Please correct it.” The AI
    might then adjust the code accordingly.'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你有选择：手动修复或提示人工智能提供一个修正版本。如果修复很明显，就做吧。如果不明显，你可以尝试像“上述函数在输入 X 上失败（预期 Y，得到 Z）。请修正它。”这样的提示。人工智能可能会相应地调整代码。
- en: '*Test again.*'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*再次测试。*'
- en: Ensure the bug is resolved and that no new issues have been introduced.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保错误已解决，且没有引入新的问题。
- en: I recommend using test-driven debugging. If possible, write a few tests for
    critical functions (more on that in the testing section later in this chapter).
    Any failing tests will directly show what’s wrong. This can be faster than manual
    checking, for anything but the simplest functions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用测试驱动调试。如果可能的话，为关键函数编写一些测试（关于测试的内容将在本章后面的测试部分详细说明）。任何失败的测试都会直接显示哪里出了问题。这比手动检查要快，除了最简单的函数之外。
- en: Finally, when debugging, be sure you ask *why*, not just *what*. Try to understand
    why the AI made the mistake. Was the prompt unclear on that point? This can inform
    how you prompt next time or whether you need to always double-check that aspect
    in AI outputs. For example, if you notice the AI often doesn’t handle empty inputs
    unless told, you’ll start always specifying that in prompts and reviewing for
    it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在调试时，务必问 *为什么*，而不仅仅是 *什么*。试图理解人工智能为什么会犯错误。在那个点上提示是否不清楚？这可以指导你下次如何提示，或者是否需要始终在人工智能输出中检查该方面。例如，如果你注意到人工智能通常不会处理除非被告知的空输入，你将开始在提示中始终指定这一点，并对其进行审查。
- en: 'Refactoring for Maintainability: Making AI Code Your Code'
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化可维护性：将人工智能代码变成你的代码
- en: Once the code is functionally correct, consider refactoring it to align with
    your project’s standards and to make it easier to work with in the future. The
    AI’s job was to get you code quickly; your job is to polish it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码在功能上是正确的，考虑重构它以符合你的项目标准，并使其在未来更容易工作。AI的工作是快速为你提供代码；你的工作是润色它。
- en: 'Here is another six-step process, this time for refactoring:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个六步过程，这次是关于重构的：
- en: '*Align with style guidelines.*'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*与风格指南保持一致。*'
- en: Run the code through your formatter or linter. Fix any warnings like “Variable
    name should be lowercase” or “Line too long.” This instantly makes the code look
    like the rest of your codebase. Many AI tools do a decent job at style, but slight
    adjustments might be needed.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码通过你的格式化器或lint工具。修复任何警告，如“变量名应该是小写”或“行太长”。这立即使代码看起来像你的代码库中的其他代码。许多AI工具在风格方面做得相当不错，但可能需要稍作调整。
- en: '*Improve naming and structure.*'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*改进命名和结构。*'
- en: If the AI named functions `_helper1` and `_helper2` in a class, and you prefer
    meaningful names, rename them. If it created a bunch of small functions that are
    only used once, maybe inline them, unless they add clarity.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果AI在一个类中命名了函数`_helper1`和`_helper2`，而你更喜欢有意义的名称，请将它们重命名。如果它创建了一堆只使用一次的小函数，也许可以将其内联，除非它们增加了清晰度。
- en: '*Remove any unnecessary parts.*'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除任何不必要的部分。*'
- en: For example, perhaps the AI included a main block or test code in the output
    that you didn’t ask for. If you don’t need that, remove it. Conversely, maybe
    it wrote everything in one function but you want to split it into smaller pieces
    for clarity; if so, do that split now.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，也许AI在输出中包含了一些你不需要的主块或测试代码。如果你不需要它，请将其删除。相反，也许它将所有内容都写在一个函数中，但你希望将其拆分成更小的部分以提高清晰度；如果是这样，现在就进行拆分。
- en: '*Add documentation.*'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*添加文档。*'
- en: If this code is intended to be part of a library or a module that others will
    use, add docstrings or comments where appropriate. The AI might have commented
    some, but ensure it meets your standards. For example, maybe your project requires
    a certain docstring format with parameters and returns documented.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果这段代码打算成为其他人将使用的库或模块的一部分，请在不适当的地方添加docstrings或注释。AI可能已经注释了一些，但请确保它符合你的标准。例如，也许你的项目需要一种特定的docstring格式，其中参数和返回值都有记录。
- en: '*Optimize if needed.*'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*如有需要，进行优化。*'
- en: 'Now that the code works, is it efficient enough? If this code might be called
    in a tight loop or on large data, check its complexity. The AI might not have
    used the most optimal approach (again, the “majority solution” might be a simple
    loop, not a more optimized approach). If performance is a concern, refactor to
    a better algorithm. You can again involve the AI:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在代码已经可以工作了，它是否足够高效？如果这段代码可能会在紧密循环或大量数据上被调用，检查其复杂度。AI可能没有使用最优化方法（再次强调，“多数解决方案”可能只是一个简单的循环，而不是更优化的方法）。如果性能是关注点，重构以使用更好的算法。你还可以再次涉及AI：
- en: Optimize this code to run faster by using a set instead of a list for lookups.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过使用集合而不是列表进行查找来优化这段代码，使其运行更快。
- en: But you, as a developer, often know what pattern you want, so you might just
    implement that change.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但作为开发者，你通常知道你想要的模式，所以你可能只是实施这个更改。
- en: '*Simplify if needed.*'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*如有需要，进行简化。*'
- en: Sometimes AI code can be overly verbose. For instance, it might use an if-else
    with returns where a single return with a condition would suffice. While explicit
    code is not necessarily bad, you might want to simplify it to fewer lines to improve
    readability without losing clarity.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时AI代码可能会过于冗长。例如，它可能使用if-else语句和返回，而一个带有条件的单一返回就足够了。虽然显式代码不一定不好，但你可能希望将其简化为更少的行数以提高可读性，同时不失清晰度。
- en: The goal of refactoring is that if another developer pulls up this code later,
    it shouldn’t be obvious that “an AI wrote this.” It should just look like good
    code. That often means giving it the small human touches that make code clean.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重构的目标是，如果另一个开发者稍后查看这段代码，不应该明显看出“这是AI写的。”它应该看起来就像好的代码。这通常意味着给它添加一些小的人类触摸，使代码更干净。
- en: When you refactor, you need to verify you didn’t break anything. So let’s segue
    into testing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重构时，你需要验证你没有破坏任何东西。所以让我们过渡到测试。
- en: 'The Importance of Testing: Unit, Integration, and End to End'
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的重要性：单元测试、集成测试和端到端测试
- en: 'Testing is always important, but it’s especially important for AI-generated
    code for two reasons.  First, since you didn’t write it from scratch, you want
    assurance that it will work in all cases. Second, if you prompt the AI for changes
    later or integrate more AI code, tests help you ensure that any new changes don’t
    break the existing functionality. Let’s look quickly at different kinds of tests:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 测试始终很重要，但对于人工智能生成的代码来说，有两个特别重要的原因。首先，因为你不是从头开始编写的，你想要确保它在所有情况下都能工作。其次，如果你稍后提示人工智能进行更改或集成更多人工智能代码，测试可以帮助你确保任何新的更改不会破坏现有的功能。让我们快速看一下不同类型的测试：
- en: Unit tests
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试
- en: Write tests for each function or module you got from the AI, particularly covering
    edge cases. For our prime example, you might test with a prime number, a nonprime,
    1 (an edge case), 0 or negative (maybe defining the expected behavior), a large
    prime, and so on. If the code passes all those tests, it’s likely correct.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为从人工智能那里获得的每个函数或模块编写测试，特别是要涵盖边缘情况。以我们的主要示例来说，你可能用质数、非质数、1（一个边缘情况）、0或负数（可能定义预期的行为）、一个大质数等进行测试。如果代码通过了所有这些测试，它很可能是正确的。
- en: 'You can even ask the AI to generate these tests:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以要求人工智能生成这些测试：
- en: Write PyTest unit tests for the above function, covering edge cases.
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为上述函数编写PyTest单元测试，涵盖边缘情况。
- en: It often does a decent job. Still, review them to ensure they’re valid and cover
    what you think is necessary.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常能做得相当不错。不过，还是要检查它们以确保它们是有效的，并且涵盖了你认为必要的所有内容。
- en: Integration tests
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试
- en: If the AI code interacts with other parts of the codebase, like a function that
    uses a database, write a test that calls it in context. Does it actually store
    to the database what it should? If it produces output consumed by another function,
    chain them in a test.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果人工智能代码与代码库的其他部分交互，比如使用数据库的函数，编写一个在上下文中调用它的测试。它实际上是否存储了它应该存储到数据库中的内容？如果它产生被另一个函数消耗的输出，请在测试中链接它们。
- en: End-to-end tests
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试
- en: If this code is part of a larger workflow, run a scenario from start to finish.
    For example, if the AI code was part of a web route, do a test request to that
    route in a test environment and see if the format, error handling, and everything
    else holds up.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码是更大工作流程的一部分，从开始到结束运行一个场景。例如，如果人工智能代码是Web路由的一部分，在一个测试环境中对该路由进行测试请求，看看格式、错误处理以及所有其他内容是否保持一致。
- en: The level of testing you need to do depends on how critical and complex the
    code is. But even a quick manual test run or simple assert statements in a script
    are better than nothing for verification. Remember, testing doesn’t just find
    bugs; it locks down behavior. If you change something later (or an AI does), testing
    helps you ensure the code’s functionality doesn’t regress.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要进行的测试级别取决于代码的重要性和复杂性。但即使是快速的手动测试运行或脚本中的简单断言语句，对于验证来说也比没有好。记住，测试不仅仅是找到错误；它还锁定行为。如果你稍后更改了某些内容（或者人工智能做了），测试可以帮助你确保代码的功能没有退化。
- en: Testing is also a good way to assert ownership. Once you’ve tested for and fixed
    any issues, you can be confident in the code. At this point, it’s fair to say
    the code is “yours,” just like any other code in the codebase. You understand
    it, you trust it, and you have tests to guard it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 测试也是一种主张所有权的好方法。一旦你测试并修复了任何问题，你就可以对代码有信心。在这个时候，可以说代码是“你的”，就像代码库中的任何其他代码一样。你理解它，信任它，并且有测试来保护它。
- en: A Note on AI and Testing
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于人工智能和测试的注意事项
- en: Some AI coding tools are starting to integrate testing suggestions. For example,
    CodeWhisperer will sometimes suggest an assert after a piece of code. Use those
    suggestions as a starting point, but don’t assume they’re 100% comprehensive.
    Think of creative edge cases⁠—that’s one place where human intuition is still
    very valuable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人工智能编码工具开始整合测试建议。例如，CodeWhisperer有时会在一段代码后建议使用断言。将这些建议作为起点，但不要假设它们是100%全面的。考虑创造性的边缘情况——这是人类直觉仍然非常有价值的一个地方。
- en: Summary and Next Steps
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述和下一步行动
- en: We’ve gone through generating, understanding, debugging, and refactoring the
    code. This loop might happen in a short span (within minutes, for a small function)
    or take longer (for a complex module, over hours or days, with intermittent AI
    assistance).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经经历了生成、理解、调试和重构代码的过程。这个循环可能在短时间内发生（对于一个小函数来说，在几分钟内）或者需要更长的时间（对于复杂的模块，可能需要数小时或数天，并有间歇的人工智能辅助）。
- en: 'It’s important to acknowledge that *you, the developer, are responsible for
    the final code.* AI is a tool to accelerate creation, but it won’t take the blame
    if something fails. There’s also a licensing or copyright risk: [some AI providers](https://oreil.ly/kYyO_)
    say that outputs over a certain length might be statistically likely to contain
    copied material. It’s rare, and the providers mitigated the problem a lot, but
    just as you scan Stack Overflow answers for any obviously licensed text or attributions,
    do a quick check—especially if the output is big or too clean. For instance, if
    you prompt “implement quicksort” and the AI gives you 20 lines of pristine code,
    that’s probably fine and common knowledge. But if you ask for something obscure
    and get a large chunk of code, try searching a unique string from it online to
    see if it was pulled verbatim from somewhere. This issue has become more apparent
    recently, with [documented cases](https://oreil.ly/h_BzA) of AI systems reproducing
    text from journal articles and other copyrighted sources. As part of responsible
    code ownership, developers should verify the provenance of any AI-generated content
    that appears to go beyond generic patterns or seems unusually specific to particular
    sources.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要承认**你，作为开发者，对最终代码负责**。AI是一个加速创作的工具，但如果出现问题，它不会承担责任。还存在许可或版权风险：[一些AI提供商](https://oreil.ly/kYyO_)表示，超过一定长度的输出可能统计上很可能包含复制的内容。这种情况很少见，提供商已经大大减轻了这个问题，但就像你扫描Stack
    Overflow答案以查找任何显然受版权保护的文本或归属一样，快速检查一下——特别是如果输出很大或过于干净。例如，如果你提示“实现快速排序”，AI给你20行纯净的代码，那可能没问题，这是常识。但如果你要求一些不常见的东西，得到一大块代码，尝试从其中搜索一个独特的字符串，看看它是否是从某个地方直接复制过来的。这个问题最近变得更加明显，因为[有记录的案例](https://oreil.ly/h_BzA)显示AI系统从期刊文章和其他受版权保护的来源复制文本。作为负责任的代码所有权的一部分，开发者应该验证任何看似超出通用模式或似乎特别针对特定来源的AI生成内容的来源。
- en: 'Finally, integrate the code into your project: add it to your version control
    system, perhaps mentioning in your commit message that AI helped. There’s no requirement
    to do this, but some teams like to track it.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将代码集成到你的项目中：将其添加到你的版本控制系统，也许在提交信息中提到AI的帮助。这不是强制性的，但一些团队喜欢跟踪它。
- en: 'Over time, you’ll likely modify this AI-generated code as requirements change.
    Treat it like any other code: don’t think, “Oh, that’s the AI’s code; I’ll ask
    the AI to change it.” You can, if you want, but you can also freely modify it
    by hand. Do whatever is most efficient and maintainable.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，你可能会根据需求的变化修改这个AI生成的代码。把它当作任何其他代码一样处理：不要想，“哦，那是AI的代码；我会让AI来修改它。”如果你想，你可以，但你也可以自由地手动修改它。做最有效率和最易于维护的事情。
- en: Through careful review and testing, AI-generated code becomes just more code
    in your project. At that point, whether an AI wrote line 10 or you did is irrelevant—what
    matters is that it meets the project’s needs and standards.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细审查和测试，AI生成的代码只是你项目中更多的代码。在那个阶段，无论是AI编写了第10行还是你编写的，这并不重要——重要的是它符合项目的需求和标准。
- en: By following these practices, you harness the speed of AI coding while ensuring
    quality. You avoid the pitfalls of unquestioningly trusting AI output and instead
    integrate it into a professional development workflow.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些实践，你利用了AI编码的速度，同时确保了质量。你避免了盲目信任AI输出的陷阱，而是将其整合到专业开发工作流程中。
- en: Next, [Chapter 6](ch06.html#ch06_ai_driven_prototyping_tools_and_techniques_1752630043797954)
    examines how AI tools can fundamentally transform the prototyping phase of software
    development. I will explore practical techniques for leveraging AI assistants
    to accelerate the journey from initial concept to working prototype, often reducing
    development time from days to hours. The discussion covers specific AI-powered
    prototyping tools, including Vercel v0 and screenshot-to-code utilities, along
    with strategies for iterative refinement under AI guidance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，[第6章](ch06.html#ch06_ai_driven_prototyping_tools_and_techniques_1752630043797954)探讨了AI工具如何从根本上改变软件开发的原型阶段。我将探讨利用AI助手加速从初始概念到工作原型的旅程的实际技术，这通常可以将开发时间从几天缩短到几小时。讨论涵盖了特定的AI驱动原型工具，包括Vercel
    v0和截图转代码工具，以及AI指导下的迭代改进策略。
- en: I will also address the critical transition process from AI-generated prototypes
    to production-ready code, examining both the opportunities and potential challenges
    that arise when AI becomes a central part of the development workflow. Through
    real-world case studies, I will demonstrate how developers are successfully using
    AI to test ideas rapidly while maintaining code quality—and avoiding common pitfalls
    that can emerge when moving too quickly from concept to implementation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将探讨从AI生成的原型到生产就绪代码的关键过渡过程，分析当AI成为开发工作流程的核心部分时出现的机遇和潜在挑战。通过实际案例研究，我将展示开发者如何成功利用AI快速测试想法，同时保持代码质量——并避免在从概念到实施过渡过快时可能出现的常见陷阱。
