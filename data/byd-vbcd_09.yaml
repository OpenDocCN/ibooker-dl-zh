- en: Chapter 7\. Building Web Applications with AI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章\. 使用AI构建Web应用程序
- en: This chapter shifts the focus from prompting quick prototypes to developing
    complete web applications using AI assistance. Web apps typically involve a frontend
    (often written in frameworks like React, Angular, or Vue), a backend (APIs, databases,
    servers), and glue to connect everything. Vibe coding can accelerate each of these
    layers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点从提示快速原型转向使用AI辅助开发完整的Web应用程序。Web应用程序通常涉及前端（通常使用React、Angular或Vue等框架编写）、后端（API、数据库、服务器）以及连接一切的粘合剂。Vibe编码可以加速每一层。
- en: 'I’ll walk you through an end-to-end workflow for building a web application
    with an AI pair programmer, including:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向您展示一个端到端的工作流程，使用AI配对程序员构建Web应用程序，包括：
- en: Setting up the project and its scaffolding
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置项目和其脚手架
- en: Coding the frontend UI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写前端UI代码
- en: Implementing backend logic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现后端逻辑
- en: Integrating with a database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成数据库
- en: Testing and validating the whole stack
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和验证整个堆栈
- en: Along the way, I’ll highlight AI development patterns for frontends (for example,
    having AI generate React or Vue components from descriptions) and backends (writing
    routes, business logic, and database queries through natural-language prompts).
    I’ll also cover how to optimize collaboration between humans and AI in a full
    stack project, ensuring that each side contributes its strongest work. By the
    end of this chapter, you should have a clear roadmap for using AI not just for
    isolated coding tasks but for managing entire web development workflow efficiently
    and effectively.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我将突出前端（例如，通过描述生成React或Vue组件）和后端（通过自然语言提示编写路由、业务逻辑和数据库查询）的AI开发模式。我还会介绍如何在全栈项目中优化人类与AI之间的协作，确保每一方都能贡献其最强的工作。到本章结束时，你应该对使用AI不仅用于孤立的编码任务，而且高效有效地管理整个Web开发工作流程有一个清晰的路线图。
- en: 'Setting Up the Project: Scaffolding with AI'
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目：使用AI进行脚手架搭建
- en: Every web application starts with some *scaffolding*—the initial setup of build
    tools, file structure, dependencies, etc. AI can automate the creation of a lot
    of the boilerplate. Modern web frameworks often come with command-line interface
    (CLI) tools that can generate a base project, but you might still need to configure
    certain things or integrate additional libraries. An AI assistant can help by
    either guiding you through these CLI tools or setting up custom project structures
    on demand.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Web应用程序都从一些*脚手架*开始——构建工具、文件结构、依赖等的初始设置。AI可以自动化创建大量样板代码。现代Web框架通常带有命令行界面（CLI）工具，可以生成基础项目，但你可能仍然需要配置某些事情或集成额外的库。AI助手可以通过引导你通过这些CLI工具或在需要时设置自定义项目结构来提供帮助。
- en: 'For example, suppose you want to start a new application project using React
    for the frontend and Express for the backend. A pre-AI workflow for this task
    would probably look something like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想使用React作为前端和Express作为后端开始一个新的应用程序项目。这个任务在AI之前的流程可能看起来像这样：
- en: Run a CLI tool or Vite to set up the React project.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行CLI工具或Vite设置React项目。
- en: Initialize an Express app (perhaps with `npm init` and installing Express).
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个Express应用（可能使用`npm init`并安装Express）。
- en: Set up a proxy for development or configure [Cross-Origin Resource Sharing (CORS)](https://oreil.ly/bgw1V)
    so the React frontend can talk to the Express backend.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为开发设置代理或配置[跨源资源共享（CORS）](https://oreil.ly/bgw1V)，以便React前端可以与Express后端通信。
- en: Maybe integrate a database like MongoDB or set up an SQLite file for simple
    usage.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能集成MongoDB数据库或为简单使用设置SQLite文件。
- en: 'Using an AI coding environment like Cursor or Cline, you can instead describe
    your desired setup in one go:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AI编码环境如Cursor或Cline，你可以一次性描述你想要的设置：
- en: Set up a new project with a React frontend (using Vite) and an Express backend.
    The backend should serve a REST API for a to-do list and use an in-memory array
    to start. Configure the frontend to proxy API requests to the backend in development.
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用Vite创建一个新的React前端项目（后端使用Express）。后端应提供待办事项列表的REST API，并使用内存数组开始。配置前端在开发中将API请求代理到后端。
- en: 'An advanced AI IDE can take this instruction and do the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个高级AI IDE可以接受这个指令并执行以下操作：
- en: Create two directories (frontend and backend).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两个目录（前端和后端）。
- en: Run `npm create vite@latest` (if it has shell access) or template out a basic
    React app.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`npm create vite@latest`（如果具有shell访问权限）或模板化一个基本的React应用。
- en: Initialize a basic Express server file in the backend, with an endpoint like
    */api/to-dos* (returning some sample data).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后端初始化一个基本的Express服务器文件，例如带有/api/to-dos端点（返回一些示例数据）。
- en: Include a *package.json* in each directory with relevant scripts (like `start
    both`).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个目录中包含一个*package.json*文件，并包含相关的脚本（如`start both`）。
- en: Set up communication between frontend and backend by either configuring a proxy
    in the React development server or providing instructions for implementing CORS
    headers.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在React开发服务器中配置代理或提供实现CORS头部的说明来设置前后端之间的通信。
- en: Within a couple of minutes, you’ll have the skeleton of a full stack web app.
    Even if the AI doesn’t do everything automatically, it might present you with
    code and the instructions you need to finalize it (for example, “Add this proxy
    setting to your React *package.json* file”). This saves a lot of mindless setup
    time and allows you to focus immediately on features.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟内，你将拥有一个全栈Web应用的骨架。即使AI没有自动完成所有工作，它也可能提供你需要来完成它的代码和说明（例如，“将此代理设置添加到你的React
    *package.json* 文件中”）。这节省了大量无意义的设置时间，并允许你立即专注于功能。
- en: 'If you aren’t using an AI IDE, you can still use ChatGPT or another assistant
    step-by-step as you go; for example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用AI IDE，你仍然可以在进行过程中逐步使用ChatGPT或其他助手；例如：
- en: I want to create a new React app. What commands should I run?
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我想创建一个新的React应用。我应该运行哪些命令？
- en: 'The AI can guide you through steps or recommend newer alternatives like Vite
    or Next.js:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: AI可以引导你完成步骤或推荐更新的替代方案，如Vite或Next.js：
- en: Now set up an Express server with a /api/to-dos route.
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在设置一个带有/api/to-dos路由的Express服务器。
- en: 'It can generate the code for the Express server, which you copy into a file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以生成Express服务器的代码，你可以将其复制到文件中：
- en: How do I connect my React app to this API during development?
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我如何在开发期间将我的React应用连接到这个API？
- en: It might suggest either a proxy configuration or tell you how to call the API
    (including the full URL, if not proxying).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会建议配置代理或告诉你如何调用API（包括完整的URL，如果未使用代理）。
- en: This way, even setting up the basic plumbing becomes a conversation rather than
    a hunt through documentation. As noted in earlier chapters, *programming by intent*
    means you tell the AI what outcome you want, and it figures out the steps. Setting
    up a project is a perfect scenario for that.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，即使是设置基本的基础设施也变成了一场对话，而不是在文档中搜索。正如前面章节中提到的，“按意图编程”意味着你告诉AI你想要的结果，然后它找出步骤。设置项目是一个完美的场景。
- en: 'At this stage, it’s important to assert your architectural decisions. The AI
    will follow your lead. Humans are essential for architectural and high-level decisions,
    so decide on the stack and major patterns yourself: Do you want a monorepo or
    separate repos for front and back? Will you use REST or GraphQL? Which database?'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，重要的是要明确你的架构决策。AI会跟随你的领导。人类在架构和高层次决策中至关重要，所以自己决定栈和主要模式：你想要一个单仓库还是前后端分开的仓库？你会使用REST还是GraphQL？哪个数据库？
- en: 'Once you have these in mind, you can instruct the AI accordingly:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了这些想法，你可以相应地指导AI：
- en: Also set up a basic Prisma schema for the SQLite database.
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还为SQLite数据库设置一个基本的Prisma模式。
- en: 'Or:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: Include a GraphQL server instead of REST.
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用GraphQL服务器而不是REST。
- en: The AI might not perfectly execute complex setups, but it will get the bulk
    of the work done, and you can refine from there.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: AI可能无法完美执行复杂的设置，但它会完成大部分工作，然后你可以在此基础上进行细化。
- en: 'Many experienced developers integrate these steps into project templates or
    use boilerplate generators, but AI offers a more flexible approach: you can customize
    on the fly using natural language. This means if your project is slightly unusual
    (maybe you need three services instead of the usual two tiers, or you want to
    preconfigure a particular library like Tailwind CSS), just ask the AI to include
    what you want.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 许多经验丰富的开发者将这些步骤集成到项目模板中或使用样板生成器，但AI提供了一种更灵活的方法：你可以使用自然语言即时自定义。这意味着如果你的项目略有不同（可能需要三个服务而不是通常的两个层级，或者你想要预配置特定的库，如Tailwind
    CSS），只需让AI包含你想要的内容。
- en: Frontend Development Patterns with AI
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AI进行前端开发模式
- en: Once the scaffolding is ready, developing the frontend of a web app is a major
    part of the effort. This section explores how you can leverage an AI pair programmer
    for your frontend code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦搭建好脚手架，开发一个Web应用的前端就是主要的工作部分。本节将探讨如何利用AI代码伙伴来辅助你的前端代码开发。
- en: Implementing components from descriptions
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据描述实现组件
- en: 'You can ask the AI to create components by describing their functionality and
    appearance; for example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以要求 AI 通过描述其功能和外观来创建组件；例如：
- en: Create a React component called TodoList that takes a list of to-do items and
    displays them. Each item should show its title and a checkbox to mark it complete.
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个名为 TodoList 的 React 组件，它接受待办事项列表并显示它们。每个项目应显示其标题和一个复选框以标记它已完成。
- en: 'The AI should produce the code as a functional component, with props and state
    as needed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: AI 应该以功能组件的形式生成代码，根据需要包含属性和状态：
- en: Create a Vue component for a login form with inputs for username and password,
    and emit an event with the form data on submit.
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个带有用户名和密码输入的登录表单的 Vue 组件，并在提交表单时发出包含表单数据的事件。
- en: The AI will likely output the `<template>`, `<script>`, and `<style>` sections
    accordingly. You, as the developer, skip writing boilerplate and directly get
    the structure you need. It’s then easy to tweak if needed. Often the AI will even
    include basic validation or state handling, if your prompt implies that they’re
    needed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: AI 将相应地输出 `<template>`、`<script>` 和 `<style>` 部分。作为开发者，你可以跳过编写样板代码，直接获取所需的架构。如果需要，很容易进行调整。通常，如果提示暗示需要，AI
    甚至会包括基本的验证或状态处理。
- en: It’s important to ensure consistency at this stage. If you generate multiple
    components in isolation, you might need to adjust them to work together. For instance,
    if the `TodoList` expects items as a certain prop shape, make sure any component
    that uses `TodoList` provides that. You can either generate components in one
    prompt (so the AI is aware of everything) or simply wire them up yourself and
    ask the AI to fix any mismatches.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段确保一致性很重要。如果你独立生成多个组件，可能需要调整它们以便它们可以一起工作。例如，如果 TodoList 期望项目以特定的属性形状，确保任何使用
    TodoList 的组件都提供该属性。你可以在一个提示中生成组件（这样 AI 就会了解所有内容），或者简单地自己连接它们并要求 AI 修复任何不匹配。
- en: Styling and layout
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式和布局
- en: 'CSS and styling can be tedious. Describe the look you want and let the AI handle
    the CSS details:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 和样式可能很繁琐。描述你想要的样式，让 AI 处理 CSS 的细节：
- en: 'Style the to-do list component: use a flex column for the list, add some spacing,
    and change the text color of completed items to gray and crossed out.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计待办事项列表组件：使用 flex 列表，添加一些间距，并将已完成项的文本颜色改为灰色并划掉。
- en: For the login form component, center it on the page and make the input fields
    larger with rounded borders.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于登录表单组件，将其在页面上居中，并将输入字段的大小调整为更大的圆角边框。
- en: The assistant can output CSS-in-JS, plain CSS, or inline styles, depending on
    context. If you’re using a framework like Tailwind CSS, you could even ask it
    to output the appropriate classes (though keep in mind that not all models know
    Tailwind thoroughly).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上下文，助手可以输出 CSS-in-JS、纯 CSS 或内联样式。如果你使用 Tailwind CSS 这样的框架，甚至可以要求它输出适当的类（但请注意，并非所有模型都完全了解
    Tailwind）。
- en: 'The point is: you can iterate on design without manually fiddling with CSS
    values. This keeps your focus at a higher level of abstraction—specifying *what
    looks good* rather than writing every `margin` and `color`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重点在于：你可以在不手动调整 CSS 值的情况下迭代设计。这使你的关注点保持在更高层次的抽象——指定“看起来怎么样”而不是编写每个 `margin` 和
    `color`。
- en: Integrating APIs and state management
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成 API 和状态管理
- en: 'Web frontends often need to fetch data from backends and manage state with
    something like Redux, context, or simple component state. AI can help write these
    integration pieces; for example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 网络前端通常需要从后端获取数据，并使用 Redux、context 或简单的组件状态来管理状态。AI 可以帮助编写这些集成部分；例如：
- en: Add code to fetch the to-do list from /api/to-dos when the `TodoList` component
    mounts, and store it in state.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 TodoList 组件挂载时添加代码以从 /api/to-dos 获取待办事项列表，并将其存储在状态中。
- en: Implement a function in the `TodoList` that, when a checkbox is toggled, sends
    a `POST` request to */api/to-dos/{id}/complete* and then updates the state accordingly.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 TodoList 中实现一个函数，当复选框切换时，向 */api/to-dos/{id}/complete* 发送 `POST` 请求，然后相应地更新状态。
- en: The AI can generate the `useEffect` hook in React to do the fetch or the `mounted()`
    hook in Vue. It can also stub out the HTTP calls (using `fetch` or Axios, etc.).
    You’ll want to confirm that the API endpoints and payloads match what your backend
    expects (if you’ve built the backend or have a spec for it).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: AI 可以在 React 中生成 `useEffect` 钩子以执行获取操作或在 Vue 中生成 `mounted()` 钩子。它还可以模拟 HTTP
    调用（使用 `fetch` 或 Axios 等）。你将想要确认 API 端点和有效负载与你的后端期望的一致（如果你已经构建了后端或对其有规范）。
- en: If you haven’t built the backend yet, you might simultaneously be using the
    AI to create it—we’ll get to that soon. But you can work on front and back in
    parallel with AI assistance, because each can be specified and generated relatively
    independently, as long as you keep track of the interface between them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有构建后端，你可能同时在使用AI来创建它——我们很快就会讨论这一点。但你可以使用AI辅助并行处理前端和后端，因为它们可以相对独立地指定和生成，只要你保持对它们之间接口的跟踪。
- en: Handling complexity with AI guidance
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在AI指导下处理复杂性
- en: 'If your frontend has complex logic, such as dynamic form validation rules,
    conditional rendering, or intricate user interactions, you can implement these
    step-by-step with AI. A good practice is to break the problem down:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的前端有复杂的逻辑，例如动态表单验证规则、条件渲染或复杂的用户交互，你可以使用AI逐步实现这些功能。一个好的做法是将问题分解：
- en: 'Add a feature: when the user checks the “complete” box on a to-do, fade out
    that list item (CSS transition), then remove it from the list after 1 second.'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 添加一个功能：当用户在待办事项上勾选“完成”复选框时，使用CSS过渡效果使该列表项淡出，然后在1秒后将它从列表中移除。
- en: 'The AI might produce the code to add a CSS class on check and use a timeout
    to remove the item, including the necessary CSS for fading out:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: AI可能会生成在勾选时添加CSS类和使用超时移除项的代码，包括必要的CSS以实现淡出效果：
- en: The form has an optional field for ‘notes’. Only show the notes text area if
    an ‘Add notes’ checkbox is checked.
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表单有一个可选的“笔记”字段。只有当“添加笔记”复选框被勾选时才显示笔记文本区域。
- en: The AI can modify the component state and JSX to conditionally render the notes
    field.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: AI可以修改组件状态和JSX以条件渲染笔记字段。
- en: Each of these can be an iterative prompt. Essentially, you describe the UX behavior
    and AI writes the code. Always test after each addition to ensure it behaves as
    expected.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些都可以是一个迭代提示。本质上，你描述UX行为，AI编写代码。在每次添加后都要进行测试，以确保其按预期行为。
- en: Framework-specific tips
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 框架特定的技巧
- en: 'Different frameworks have different idioms:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的框架有不同的惯例：
- en: In React, the AI might use hooks (like `useState`, `useEffect`). Double-check
    that it’s following best practices (for instance, that the dependencies array
    in `use​Ef⁠fect` is correct).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中，AI可能会使用钩子（如`useState`、`useEffect`）。请确保它遵循最佳实践（例如，`useEffect`中的依赖项数组是正确的）。
- en: In Vue, the AI might output Options API style or Composition API style depending
    on what it has seen. If you prefer one, you should specify that (for instance,
    “Use Vue 3 Composition API”).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vue中，AI可能会根据其所见输出选项API风格或组合API风格。如果你更喜欢其中一种，你应该指定它（例如，“使用Vue 3组合API”）。
- en: In Angular, the AI can generate components, but Angular has a steeper learning
    curve. The AI might be able to produce a template, a TypeScript class, and basic
    service injection on request, but you’ll likely need to do more manual work or
    use Angular CLI for structure, then ask AI to fill in specific parts (like form
    validation logic).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中，AI可以生成组件，但Angular的学习曲线较陡。AI可能会在请求时生成模板、TypeScript类和基本的服务注入，但你可能需要做更多手动工作或使用Angular
    CLI来构建结构，然后让AI填写特定的部分（如表单验证逻辑）。
- en: Backend/API Development Patterns with AI
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AI的后端/API开发模式
- en: 'Now let’s turn to the backend. Using AI to build the server side of a web application
    follows a similar paradigm: you describe the endpoints, data models, and logic
    you want, and the AI produces code. Common backend components include route handlers,
    business logic, database interactions, and validations. AI can help with all of
    these.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向后端。使用AI构建Web应用的服务器端遵循类似的范式：你描述你想要的端点、数据模型和逻辑，然后AI生成代码。常见的后端组件包括路由处理程序、业务逻辑、数据库交互和验证。AI可以帮助完成所有这些。
- en: Implementing API endpoints
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现API端点
- en: 'Suppose you’re building a RESTful API for your to-do list app. You might have
    endpoints like `GET /to-dos`, `POST /to-dos`, `PUT /to-dos/:id`, `DELETE /to-dos/:id`.
     You can go endpoint by endpoint:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在为待办事项应用构建RESTful API。你可能会有`GET /to-dos`、`POST /to-dos`、`PUT /to-dos/:id`、`DELETE
    /to-dos/:id`这样的端点。你可以逐个端点进行：
- en: In the Express app, add a `GET /api/to-dos` route that returns the list of to-dos
    (just use an array stored in memory for now).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Express应用中，添加一个`GET /api/to-dos`路由，该路由返回待办事项列表（现在只需使用存储在内存中的数组即可）。
- en: Add a `POST /api/to-dos` route that accepts a JSON body and adds a new to-do
    to the list. Return the new to-do with an ID.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个`POST /api/to-dos`路由，该路由接受JSON主体并将新的待办事项添加到列表中。返回带有ID的新待办事项。
- en: 'The AI will write the Express route handlers accordingly, likely using something
    like `app.get(''/api/to-dos'', ...)`. If you’ve indicated that you’re using Express
    with JSON, it might include the necessary middleware if it’s not already present:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: AI将相应地编写Express路由处理程序，可能使用类似`app.get('/api/to-dos', ...)`的东西。如果你已经表明你正在使用带有JSON的Express，它可能会包括必要的中间件，如果它尚未存在的话：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As your backend grows, you can ask the AI to refactor:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 随着后端的增长，你可以要求AI进行重构：
- en: Refactor the Express routes into a separate router module.
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将Express路由重构为单独的路由模块。
- en: It might split the routes out into a separate file, which is a good practice
    for maintainability.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会将路由拆分到单独的文件中，这对于维护性来说是一个好习惯。
- en: Database integration
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库集成
- en: 'You might use in-memory data for a prototype, but for a more complete application,
    you’ll want a database. Let’s say you choose MongoDB or PostgreSQL. You can prompt:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能可以使用内存数据来制作原型，但对于更完整的应用程序，你将需要一个数据库。假设你选择了MongoDB或PostgreSQL。你可以提示：
- en: 'Integrate MongoDB into the Express app using Mongoose. Create a to-do model
    with fields: title (string), completed (boolean). Modify the GET/POST routes to
    use the database instead of an in-memory array.'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用Mongoose将MongoDB集成到Express应用中。创建一个待办事项模型，包含字段：标题（字符串），完成状态（布尔值）。修改GET/POST路由，使用数据库而不是内存中的数组。
- en: The AI may output the Mongoose model definition and adjust the route handlers
    to query the database (like `Todo.find()` for `GET` and `Todo.create()` for `POST`).
    Similarly, for SQL, you could ask it to set up an [*object-relational mapping*
    (ORM)](https://oreil.ly/AoWDL) like Prisma or Sequelize. Keep in mind you might
    need to provide configuration details (like connection strings). The AI might
    not know your database URI; you’ll have to slot that in. But it will handle the
    generic code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: AI可能会输出Mongoose模型定义，并调整路由处理程序以查询数据库（例如`Todo.find()`用于`GET`和`Todo.create()`用于`POST`）。类似地，对于SQL，你可以要求它设置一个[*对象关系映射*（ORM）](https://oreil.ly/AoWDL)如Prisma或Sequelize。请记住，你可能需要提供配置细节（如连接字符串）。AI可能不知道你的数据库URI；你将不得不将其插入。但它会处理通用代码。
- en: Business logic and validation
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 业务逻辑和验证
- en: 'If your backend has specific rules (for example, that users cannot delete a
    to-do that is marked important or that list titles must be unique), you can encode
    those via AI:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的后端有特定的规则（例如，用户不能删除标记为重要的待办事项，或者列表标题必须是唯一的），你可以通过AI来编码这些规则：
- en: 'Add validation to the `POST /api/to-dos` route: reject if the title is empty
    or longer than 100 chars, and return 400 status.'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在`POST /api/to-dos`路由中添加验证：如果标题为空或超过100个字符，则拒绝，并返回400状态。
- en: The AI will include checks and send proper responses.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: AI将包括检查并发送适当的响应。
- en: 'Add logic: when a to-do is marked complete (say via `PUT /api/to-dos/:id`),
    if all to-dos are complete, log a message ‘All done!’'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 添加逻辑：当待办事项被标记为完成（例如通过`PUT /api/to-dos/:id`），如果所有待办事项都已完成，记录消息“全部完成！”
- en: It can insert that logic in the `PUT` handler.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在`PUT`处理程序中插入这个逻辑。
- en: You describe these requirements in plain terms, and the AI modifies the code
    accordingly. You still need to test that the code does what you expect.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用简单的术语描述这些需求，AI会相应地修改代码。你仍然需要测试代码是否按预期工作。
- en: Using frameworks or boilerplates
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用框架或模板
- en: 'Many web backends use frameworks beyond raw Express (like NestJS for Node or
    Django for Python). AI can work with those, too, though you may have to break
    down more involved tasks:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Web后端使用比原始Express更广泛的框架（如Node的NestJS或Python的Django）。AI也可以与这些框架一起工作，尽管你可能需要分解更复杂的任务：
- en: 'For Django (Python), you might prompt:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Django（Python），你可能提示：
- en: Create a Django model for to-do with fields X, and corresponding views for list
    and create.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为待办事项创建一个Django模型，包含字段X，以及相应的列表和创建视图。
- en: The AI might output model code and a generic view or DRF (Django REST Framework)
    serializer/viewset if it knows that context.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果AI知道这个上下文，它可能会输出模型代码和一个通用的视图或DRF（Django REST Framework）序列化器/视图集。
- en: For Ruby on Rails, you can get help generating models and controllers. (At that
    point, you might just use Rails scaffolding, but the AI could supplement by adding
    validations or adjusting routes).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Ruby on Rails，你可以获得帮助生成模型和控制器。（在那个阶段，你可能会直接使用Rails脚手架，但AI可以通过添加验证或调整路由来补充）。
- en: AI models demonstrate varying levels of proficiency across different programming
    languages and technology stacks, largely determined by the prevalence of those
    technologies in their training data. While models can work with any language they’ve
    encountered during training, their effectiveness varies significantly. Popular
    languages like JavaScript, Python, and Java typically receive stronger support
    due to their abundant representation in open source repositories, documentation,
    and educational materials that form part of the training corpus.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: AI模型在不同编程语言和技术堆栈中的熟练程度各不相同，这主要取决于这些技术在训练数据中的普及程度。虽然模型可以处理他们在训练期间遇到的任何语言，但他们的有效性差异很大。像JavaScript、Python和Java这样的流行语言通常由于在开源存储库、文档和教育材料中的丰富表示而得到更强的支持，这些材料构成了训练语料库的一部分。
- en: Determining a model’s proficiency with your chosen stack requires practical
    evaluation. Start by testing the model with basic tasks in your target language,
    then progressively increase complexity to gauge its capabilities. Pay attention
    to whether the model generates idiomatic code that follows language-specific conventions,
    recognizes common frameworks and libraries without extensive explanation, and
    suggests appropriate design patterns for that ecosystem. Strong proficiency manifests
    as contextually appropriate suggestions, while weaker support often results in
    generic or outdated code patterns.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 确定模型在您选择的堆栈中的熟练程度需要实际评估。首先，用您目标语言中的基本任务测试模型，然后逐步增加复杂性以评估其能力。注意模型是否生成遵循语言特定约定的地道代码，是否能够无需详细解释就识别常见的框架和库，以及是否为该生态系统建议适当的设计模式。熟练程度强的表现是上下文适当的建议，而较弱的支持通常会导致通用的或过时的代码模式。
- en: Many AI providers publish documentation about their models’ capabilities, though
    these rarely include detailed language-specific benchmarks. The most reliable
    approach involves running small experiments with your actual technology stack.
    For instance, if you’re working with Ruby on Rails, test whether the model understands
    Rails conventions like ActiveRecord patterns or can generate proper RSpec tests.
    Similarly, for newer frameworks or less common languages, expect more variable
    results, and be prepared to provide additional context in your prompts to compensate
    for potential gaps in the model’s training.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 许多AI提供商发布了关于其模型能力的文档，尽管这些很少包括详细的语言特定基准。最可靠的方法是使用您实际的技术堆栈进行小实验。例如，如果您使用Ruby on
    Rails，测试模型是否理解Rails约定，如ActiveRecord模式，或能否生成适当的RSpec测试。同样，对于较新的框架或不太常见的语言，预期会有更多可变的结果，并准备好在提示中提供更多上下文以弥补模型训练中的潜在差距。
- en: Orchestrating multistep operations
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协调多步骤操作
- en: 'Some endpoints might involve multiple steps, like creating an entry in one
    table and then another, or calling an external API. You can outline the sequence
    and let the AI draft it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一些端点可能涉及多个步骤，例如在一个表中创建条目，然后是另一个，或者调用外部API。您可以概述顺序，并让人工智能起草：
- en: When a new user signs up (`POST /api/users`), create a user record and also
    send a welcome email via SendGrid API.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当新用户注册（`POST /api/users`）时，创建用户记录并通过SendGrid API发送欢迎邮件。
- en: 'The AI can write code to save the user (maybe using an object-relational mapper,
    or ORM) and then an HTTP request to SendGrid’s API with appropriate payload. You’d
    fill in actual API keys or tweak content, but most of the boilerplate is done:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能可以编写代码来保存用户（可能使用对象关系映射器，或ORM）以及向SendGrid的API发送带有适当有效载荷的HTTP请求。您将填写实际的API密钥或调整内容，但大部分模板代码已经完成：
- en: 'Implement a transaction: when transferring money (`POST /api/transfer`), deduct
    from account A and add to account B, ensure it’s atomic (all-or-nothing).'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实施事务：在转账时（`POST /api/transfer`），从账户A扣除并添加到账户B，确保它是原子性的（全部或无）。
- en: 'If you’re using an ORM or database that supports transactions, the AI might
    use those features (like an SQL transaction block or an ORM’s transaction method).
    Review such code cautiously for correctness—transaction logic, especially, can
    be tricky. But the AI might know common pitfalls and include checks. For instance,
    when prompted to handle a money transfer endpoint, an AI generated the following
    code structure:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用支持事务的ORM或数据库，人工智能可能会使用这些功能（如SQL事务块或ORM的事务方法）。谨慎审查此类代码的正确性——特别是事务逻辑，可能会很复杂。但人工智能可能知道常见的陷阱，并包括检查。例如，当被提示处理货币转账端点时，人工智能生成了以下代码结构：
- en: '[PRE1]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: async function transferMoney(fromAccountId, toAccountId, amount) {
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: async function transferMoney(fromAccountId, toAccountId, amount) {
- en: const session = await db.startSession();
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: const session = await db.startSession();
- en: try {
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: try {
- en: await session.startTransaction();
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: await session.startTransaction();
- en: // Deduct from source account
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: // 从源账户扣除
- en: const sourceAccount = await Account.findByIdAndUpdate(
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: const sourceAccount = await Account.findByIdAndUpdate(
- en: fromAccountId,
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: fromAccountId,
- en: '{ $inc: { balance: -amount } },'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '{ $inc: { balance: -amount } },'
- en: '{ session, new: true }'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '{ session, new: true }'
- en: );
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: if (sourceAccount.balance < 0) {
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: if (sourceAccount.balance < 0) {
- en: throw new Error('Insufficient funds');
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: throw new Error('Insufficient funds');
- en: '}'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // Add to destination account
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: // 添加到目标账户
- en: await Account.findByIdAndUpdate(
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: await Account.findByIdAndUpdate(
- en: toAccountId,
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: toAccountId,
- en: '{ $inc: { balance: amount } },'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '{ $inc: { balance: amount } },'
- en: '{ session }'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '{ session }'
- en: );
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: await session.commitTransaction();
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: await session.commitTransaction();
- en: 'return { success: true };'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'return { success: true };'
- en: '} catch (error) {'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (error) {'
- en: await session.abortTransaction();
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: await session.abortTransaction();
- en: throw error;
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: throw error;
- en: '} finally {'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '} finally {'
- en: session.endSession();
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: session.endSession();
- en: '}'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE2]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The AI correctly wrapped both database operations in a transaction, included
    validation for insufficient funds, and properly handled rollback on any error.
    While you’d still need to review edge cases and add appropriate logging, the fundamental
    transaction structure demonstrates understanding of atomic operations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: AI正确地将数据库操作包装在事务中，包括对资金不足的验证，并在任何错误发生时正确处理回滚。虽然你仍然需要审查边缘情况并添加适当的日志记录，但基本的事务结构展示了对原子操作的理解。
- en: API documentation and testing
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API文档和测试
- en: 'When building APIs, you can also have the AI produce documentation. For instance,
    *“Write a brief documentation for the /api/to-dos endpoints.”* It may generate
    something like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建API时，AI也可以生成文档。例如，“为/api/to-dos端点编写简要文档。”它可能会生成如下内容：
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is handy for quick reference and also to share with frontend developers
    (if you’re working in a team). Additionally, you can use AI to write tests for
    your API endpoints, using a testing framework like Jest or Mocha for Node, or
    PyTest for a Python API. With a prompt like “Generate tests for the to-dos API
    (one test for listing, one for creating, one for validation error),” the AI will
    output test code that you can run and verify.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于快速参考和与前端开发者（如果你在一个团队中工作）分享都很有用。此外，你可以使用AI为你的API端点编写测试，使用像Jest或Mocha这样的测试框架（用于Node）或PyTest（用于Python
    API）。使用提示“为待办事项API生成测试（一个用于列出，一个用于创建，一个用于验证错误）”，AI将输出你可以运行和验证的测试代码。
- en: Database Design and Integration
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库设计和集成
- en: Human knowledge of the business domain is crucial in designing a database schema,
    but AI can assist in translating that design into code (like migration scripts
    or ORM models). Also, if you’re unsure about your schema, you can brainstorm with
    the AI.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计数据库模式时，人类对业务领域的知识至关重要，但AI可以帮助将设计转换为代码（如迁移脚本或ORM模型）。此外，如果你不确定你的模式，你可以与AI一起头脑风暴。
- en: 'For example, say your app is expanding beyond to-do lists to become a full
    project-management tool. You need to design several tables: Projects, Tasks, Users,
    and so on. You could ask, “What data models would I need for a simple project
    management app with users, projects, and tasks? Include relationships.” The AI
    might respond with something like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的应用程序正在从待办事项列表扩展到成为完整的项目管理工具，你需要设计几个表：项目、任务、用户等。你可能想知道：“对于一个简单的项目管理应用程序，我需要哪些数据模型，包括用户、项目和任务？包括关系。”AI可能会这样回答：
- en: User (id, name, email, etc.)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户（id, name, email等）
- en: Project (id, name, owner_id referencing User)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目（id, name, owner_id引用用户）
- en: Task (id, description, project_id, assigned_to (User), status, etc.)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务（id, description, project_id, assigned_to（用户），状态等）
- en: It might not be exactly what you want, but it gives you a starting point. You
    confirm or tweak these design ideas, then implement them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是你想要的，但它为你提供了一个起点。你确认或调整这些设计想法，然后实施它们。
- en: Using an ORM
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ORM
- en: 'If you use an ORM like Prisma, Entity Framework, or SQLAlchemy, you can have
    the AI generate model classes or schema definitions:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Prisma、Entity Framework或SQLAlchemy这样的ORM，你可以让AI生成模型类或模式定义：
- en: 'Using Sequelize (for Node), define models for User, Project, Task with associations:
    One User has many Projects, Project belongs to User; Project has many Tasks, Task
    belongs to Project; Task can be assigned to a User (many-to-one).'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用Sequelize（用于Node），定义用户、项目、任务模型及其关联：一个用户有多个项目，项目属于用户；项目有多个任务，任务属于项目；任务可以被分配给一个用户（多对一）。
- en: The AI would then write JS/TS code to define those Sequelize models and associations,
    which you can then integrate into your codebase. It might also suggest foreign
    keys or cascade rules if it’s familiar with them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 AI 将编写 JS/TS 代码来定义这些 Sequelize 模型和关联，你可以将其集成到你的代码库中。如果它熟悉这些，它还可能建议外键或级联规则。
- en: 'If you aren’t using an ORM and you’re writing raw SQL migrations, you could
    even have the AI draft migration scripts:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用 ORM 并且正在编写原始 SQL 迁移，AI 甚至可以起草迁移脚本：
- en: Write an SQL script to create tables for users, projects, tasks with appropriate
    foreign keys.
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个 SQL 脚本以创建用户、项目、任务表，并包含适当的外键。
- en: It will output an SQL DDL script, which you can review for correctness and run.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它将输出一个 SQL DDL 脚本，你可以审查其正确性并运行。
- en: Database Queries
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库查询
- en: 'When integrating the database in your code, you might need queries more complex
    than simple CRUD. Suppose you want to get all projects, along with their tasks
    and the user assigned to each task—that’s a join across Project, Task, User. You
    could prompt:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当在代码中集成数据库时，你可能需要比简单的 CRUD 更复杂的查询。假设你想要获取所有项目，包括它们的任务以及每个任务分配的用户——这是一个跨越 Project、Task、User
    的连接。你可以提示：
- en: Write an SQL query to retrieve projects with their tasks and each task’s assigned
    user name.
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个 SQL 查询以检索包含其任务以及每个任务分配的用户名的项目。
- en: The AI could produce an SQL join query for you.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: AI 可以为你生成一个 SQL 连接查询。
- en: 'Or if you’re using an ORM:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果你使用 ORM：
- en: Using Sequelize, fetch all projects with associated tasks and the user for each
    task.
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 Sequelize，获取所有包含相关任务及其每个任务的用户的全部项目。
- en: 'You could expect the code to come with something to load related data, like:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望代码中包含一些用于加载相关数据的操作，例如：
- en: '[PRE4]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Checking AI-Generated Queries
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 AI 生成的查询
- en: Database operations require careful verification to ensure the AI-generated
    code aligns with your actual schema and maintains data integrity. The AI cannot
    automatically know your specific table names, field names, or relationships unless
    you provide this information explicitly in your prompt. Even when models have
    conversation memory, you should include schema details in each complex database-related
    prompt to ensure accuracy. This explicit approach prevents the common issue of
    AI-generated queries that reference generic field names like `user_id` when your
    schema actually uses `userId` or `customer_ref`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库操作需要仔细验证以确保 AI 生成的代码与你的实际模式相匹配并保持数据完整性。AI 无法自动知道你的特定表名、字段名或关系，除非你在提示中明确提供这些信息。即使模型具有对话记忆，你也应在每个复杂的数据库相关提示中包含模式细节以确保准确性。这种明确的方法可以防止
    AI 生成的查询引用通用的字段名，如 `user_id`，而你的模式实际上使用 `userId` 或 `customer_ref`。
- en: Performance considerations often require human oversight. While AI models understand
    basic database concepts like primary keys and joins, they may not automatically
    suggest performance optimizations such as adding indexes on frequently queried
    fields or considering query execution plans. Review generated queries for efficiency,
    particularly for operations that will run frequently or against large datasets.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 性能考虑通常需要人工监督。虽然 AI 模型理解基本数据库概念，如主键和连接，但它们可能不会自动建议性能优化，例如在频繁查询的字段上添加索引或考虑查询执行计划。审查生成的查询以检查效率，特别是对于将频繁运行或针对大型数据集的操作。
- en: 'Data consistency rules represent another critical area requiring explicit specification.
    When implementing delete operations, clearly define the cascading behavior you
    expect. For example, when deleting a `Project` record, you must decide whether
    the database should automatically delete associated `Task` records through cascading
    deletes or whether your application logic should handle this cleanup. Communicate
    these business rules clearly to the AI:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 数据一致性规则代表另一个需要明确指定的关键领域。在实施删除操作时，明确定义你期望的级联行为。例如，当删除一个 `Project` 记录时，你必须决定数据库是否应该自动通过级联删除删除相关的
    `Task` 记录，或者是否由你的应用程序逻辑处理此清理。向 AI 明确传达这些业务规则：
- en: When a project is deleted, configure the database to cascade delete all related
    tasks.
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当项目被删除时，配置数据库以级联删除所有相关任务。
- en: 'Or alternatively:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: When deleting a project, first check for existing tasks and prevent deletion
    if any exist.
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当删除项目时，首先检查是否存在现有任务，并在存在任何任务时阻止删除。
- en: The AI can implement either approach effectively when given clear direction.
    For cascade deletes, it might generate foreign key constraints with `ON DELETE
    CASCADE`.  For application-level handling, it could produce code that queries
    for related records before permitting deletion. The key lies in explicitly stating
    your data-integrity requirements rather than assuming the AI will infer the appropriate
    behavior for your specific domain.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当给出明确的指示时，AI可以有效地实施任何一种方法。对于级联删除，它可能会生成带有`ON DELETE CASCADE`的外键约束。对于应用级别的处理，它可能生成在允许删除之前查询相关记录的代码。关键在于明确地说明你的数据完整性要求，而不是假设AI会推断出适合你特定领域的适当行为。
- en: 'Full Stack Integration: Marrying Frontend and Backend'
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全栈集成：将前端和后端结合
- en: Now that you’ve built both your frontend and backend with AI help, the next
    challenge is integrating them into a seamless web application. This involves making
    sure that the API endpoints are called correctly from the frontend, the data flows
    properly, and the overall system is coherent.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经使用AI的帮助构建了前端和后端，下一个挑战是将它们集成到一个无缝的Web应用中。这包括确保从前端正确调用API端点，数据正确流动，以及整个系统的一致性。
- en: Aligning Frontend and Backend Contracts
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对齐前端和后端合约
- en: 'This is crucial: the frontend expects to receive data in a certain shape, so
    what the backend sends should match that expectation. If you let AI work on each
    end in isolation, small mismatches can occur (maybe the backend returns `{ success:
    true, data: [...] }`, but the frontend expects to receive the array directly).
    To avoid this, you can explicitly instruct the AI on the response format to use
    when coding both sides. Alternately, once both are done, test an end-to-end call:
    for instance, open the web app and see if the list loads. If it doesn’t, check
    the browser console against the server logs.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '这非常重要：前端期望以特定的形状接收数据，因此后端发送的数据应与这种期望相匹配。如果你让AI在两端独立工作，可能会出现小的不匹配（比如后端返回`{ success:
    true, data: [...] }`，但前端期望直接接收数组）。为了避免这种情况，你可以明确指示AI在编码两端时使用的响应格式。或者，一旦完成，进行端到端调用测试：例如，打开Web应用并查看列表是否加载。如果没有加载，请检查浏览器控制台与服务器日志。'
- en: 'I often use the AI to adjust one side to match the other:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常使用AI来调整一边以匹配另一边：
- en: 'If the backend returns slightly different JSON key names than what the frontend
    expects and you notice a bug, you can say to the AI (on either side):'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果后端返回的JSON键名与前端期望的略有不同，并且你注意到一个错误，你可以对AI（任一端）说：
- en: Modify the code to use ‘tasks’ (plural) instead of ‘taskList’ (singular) in
    the JSON.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修改代码，在JSON中使用复数形式的“tasks”而不是单数形式的“taskList”。
- en: If the frontend is sending form data as form-encoded but the backend expects
    JSON, you can ask the AI to convert that, maybe by using `JSON.stringify` on the
    frontend or adding `body-parser` on the backend.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果前端以表单编码的形式发送表单数据，但后端期望JSON格式，你可以要求AI进行转换，比如在前端使用`JSON.stringify`或在后端添加`body-parser`。
- en: Real-Time Collaboration with AI
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与AI实时协作
- en: 'AI-augmented IDEs that hold the context of the whole project, like Cline or
    Cursor, can be especially helpful during this integration phase. You could open
    the frontend and backend files side by side in your IDE-based tool and prompt:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有整个项目上下文的AI增强IDE，如Cline或Cursor，在集成阶段特别有帮助。你可以在基于IDE的工具中并排打开前端和后端文件，并提示：
- en: Ensure that the frontend fetch from /api/to-dos matches the Express route’s
    expected request/response. Fix any discrepancies.
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确保前端从/api/to-dos获取的数据与Express路由预期的请求/响应匹配。修复任何差异。
- en: The AI might then harmonize the content (like adding await response.json() in
    the frontend if it was missing or adjusting the JSON structure).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，AI可能会使内容和谐（例如，如果前端缺少`await response.json()`，则添加或在JSON结构中调整）。
- en: State management and sync
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态管理和同步
- en: 'In a full stack app, consider implementing things like loading states and error
    handling on the frontend for failed API calls for a professional result. You might
    use prompts like:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在全栈应用中，考虑在前端实现加载状态和错误处理等功能，以应对失败的API调用，从而得到专业的结果。你可能需要使用以下提示：
- en: 'Add loading indicators: when the React component is fetching tasks, show a
    ‘Loading...’ text until data is loaded.'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 添加加载指示器：当React组件正在获取任务时，显示“加载中...”文本，直到数据加载完成。
- en: 'Or:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: 'Handle errors: if the API call fails (non-200 response), show an error message
    on the UI.'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 处理错误：如果API调用失败（非200响应），在UI上显示错误消息。
- en: It will add the `isLoading` state and conditional rendering or implement a try/catch
    around `fetch` to catch errors and display a message. This kind of polish makes
    your app *feel* robust.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加`isLoading`状态和条件渲染，或者在`fetch`周围实现try/catch来捕获错误并显示消息。这种润色让你的应用*感觉*更稳健。
- en: WebSockets and advanced integrations
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WebSockets和高级集成
- en: 'If your app requires real-time updates (like using WebSockets or SSE), you
    might prompt something like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用需要实时更新（如使用WebSockets或SSE），你可能需要提示如下内容：
- en: Set up a WebSocket using Socket.io. When a new task is created on the server,
    broadcast it to all connected clients. Modify the frontend to listen for new tasks
    and add them to the list in real time.
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用Socket.io设置WebSocket。当服务器上创建新任务时，将其广播给所有已连接的客户端。修改前端以监听新任务并在实时将其添加到列表中。
- en: This is complex, but an AI might generate the server-side Socket.io setup (like
    adding `io.on('connection', ...)` and emitting an event upon creation of a new
    task), as well as client-side code to connect and listen for that event. You would
    need to integrate this carefully, but it’s quite astonishing that these descriptions
    can lead to working real-time code. If it doesn’t work perfectly off the bat,
    iterative prompting and testing can get it there.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这很复杂，但AI可能会生成服务器端Socket.io设置（如添加`io.on('connection', ...)`并在创建新任务时触发事件），以及客户端代码来连接并监听该事件。你需要仔细集成这些代码，但令人惊讶的是，这些描述可以引导生成实际的工作实时代码。如果一开始不完美，迭代提示和测试可以使其达到预期效果。
- en: 'Example: full stack flow with AI'
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：使用AI的全栈流程
- en: 'To illustrate, let’s imagine you’re building a simple contact-manager web app:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，让我们想象你正在构建一个简单的联系人管理器Web应用：
- en: You scaffold a React frontend and a Node/Express backend, as you did earlier
    in the chapter.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你搭建React前端和Node/Express后端，就像你在本章前面所做的那样。
- en: 'First, for the frontend, prompt for a `ContactList` and a `ContactForm` component.
    Then prompt to add API calls:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，对于前端，提示`ContactList`和`ContactForm`组件。然后提示添加API调用：
- en: In ContactList, fetch contacts from */api/contacts* on mount.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在ContactList中，在挂载时从*/api/contacts*获取联系人。
- en: ''
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: In ContactForm, on submit, send a `POST` to */api/contacts* with the form data,
    then update the list of contacts on success.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在ContactForm中，提交时，将表单数据通过`POST`发送到*/api/contacts*，然后在成功后更新联系人列表。
- en: For the backend, you may want to use an in-memory array or integrate a database
    first. Then prompt for Express routes `GET /api/contacts` (to return a list) and
    `POST /api/contacts` (to add a contact to the database or memory).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于后端，你可能想先使用内存数组或集成数据库。然后提示Express路由`GET /api/contacts`（返回列表）和`POST /api/contacts`（将联系人添加到数据库或内存中）。
- en: 'Try adding a contact via the UI. If it shows up in the list, great. If not,
    debug. Maybe the `POST` route didn’t return the new contact properly or the form
    code didn’t refresh the list. Identify the gap and prompt the AI to fix it:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试通过UI添加联系人。如果它在列表中显示，那就太好了。如果没有，进行调试。可能是`POST`路由没有正确返回新联系人，或者表单代码没有刷新列表。确定差距，并提示AI修复它：
- en: After adding a contact, the backend should return the new contact object in
    the response, and the frontend should append it to the list without requiring
    a full reload.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 添加联系人后，后端应在响应中返回新的联系人对象，并且前端应将其附加到列表中，无需完全重新加载。
- en: This might lead the AI to adjust the backend response and frontend state logic
    to push the new contact (maybe using React state update).
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可能会导致AI调整后端响应和前端状态逻辑，以推送新联系人（可能使用React状态更新）。
- en: Implement edit and delete functions similarly, each time letting AI handle the
    routine parts and focusing your input on *what the feature should do*.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地实现编辑和删除功能，每次都让AI处理常规部分，并将你的输入集中在*功能应该做什么*上。
- en: Doing all this manually could easily amount to a week or two of work for a junior
    dev but could be done in a day or two with an AI codeveloper, given that a lot
    of template code and wiring is automated.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果手动完成所有这些工作，对于一个初级开发者来说可能需要一周或两周的时间，但使用AI代码开发者可以在一天或两天内完成，因为许多模板代码和连接都是自动化的。
- en: Optimizing AI-human collaboration in full stack development
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化全栈开发中的AI-人类协作
- en: 'When working through an entire stack, it’s useful to establish a productive
    rhythm with your AI assistant. Here are some strategies to optimize your collaboration:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当与AI助手一起处理整个堆栈时，建立高效的工作节奏很有用。以下是一些优化协作的策略：
- en: Use the AI for boilerplate; write any custom logic yourself
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AI处理模板代码；自己编写任何自定义逻辑
- en: Identify which parts of the code are mundane and which are the unique core logic.
    Let the AI generate a CRUD API or a standard component—but if there’s a particularly
    tricky piece of logic, maybe a proprietary algorithm or a specific business rule
    that is easier to implement directly, do that part manually, then ask the AI to
    review or test it. Think of it as delegating repetitive tasks to the AI, while
    you handle the novel ones.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 识别代码中哪些部分是平凡的，哪些是独特的核心逻辑。让AI生成CRUD API或标准组件——但如果有一段特别棘手的逻辑，可能是专有算法或特定的业务规则，直接实现可能更容易，那么手动完成这部分，然后让AI进行审查或测试。将其视为将重复性任务委托给AI，而你处理新颖的任务。
- en: Use AI to tackle your to-do list one item at a time
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AI逐项处理你的待办事项列表
- en: 'As you develop, keep track of tasks (like features to add and bugs to fix).
    Then explain each task to the AI, one by one, and let it propose a solution. For
    example, let’s say you have a note that reads “Implement password hashing on user
    registration.” Try a prompt like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，跟踪任务（如要添加的功能和要修复的错误）。然后逐一向AI解释每个任务，并让它提出解决方案。例如，假设你有一个笔记写着“在用户注册时实现密码散列。”尝试这样的提示：
- en: Add password hashing using bcrypt in the `POST /api/register` route before saving
    the user.
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在将用户保存之前，在`POST /api/register`路由中使用bcrypt添加密码散列。
- en: This targeted, systematic approach helps ensure you don’t forget anything.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这种有针对性的、系统性的方法有助于确保你不会忘记任何东西。
- en: Prompt AI to improve code quality as you go
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你改进代码质量，提示AI
- en: After achieving functionality, you might prompt, “Refactor this code for better
    readability” or “Optimize this function.” The AI can often make the code cleaner
    or suggest performance improvements, like an assistant doing a second pass for
    polish under your supervision. Be sure to verify that any changes still pass your
    tests.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现功能后，你可以提示“重构此代码以提高可读性”或“优化此函数”。AI通常可以使代码更干净或提出性能改进，就像助手在你的监督下进行第二次润色一样。务必验证任何更改是否仍然通过你的测试。
- en: Use AI for cross-checking
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AI进行交叉检查
- en: 'If you’re uncertain about your design approach, ask the AI:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对自己的设计方法不确定，请询问AI：
- en: Is using an array to store contacts in memory fine or should I use a database?
    What are the pros and cons?
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用数组在内存中存储联系人是否可以，或者我应该使用数据库？有哪些优缺点？
- en: 'While you likely know the answer (use a database for persistence), it’s like
    bouncing ideas off a colleague. Sometimes the AI might mention a consideration
    you hadn’t thought of:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能知道答案（使用数据库进行持久化），但这就像与同事讨论想法一样。有时AI可能会提到你未曾考虑过的考虑因素：
- en: If there are multiple server instances, an in-memory store won’t sync across
    them.
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果有多个服务器实例，内存存储无法在它们之间同步。
- en: Use AI to coordinate with your team
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AI与你的团队协调
- en: 'If you’re working in a team, not everyone may be using the AI directly. In
    that case, make sure to ask the AI to document what you did. Also, it’s good to
    communicate your approach to the team: “I used an AI to generate these controllers
    quickly. I’ve checked them, but keep an eye out for any unconventional patterns.”
    Encourage a code-review culture in which everyone reviews AI-written code just
    like they would any other code to catch any quirks.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个团队中工作，可能不是每个人都直接使用AI。在这种情况下，请确保让AI记录你所做的工作。此外，向团队传达你的方法也是好的：“我使用AI快速生成这些控制器。我已经检查过它们，但请注意任何不寻常的模式。”鼓励代码审查文化，让每个人都像审查其他代码一样审查AI编写的代码，以捕捉任何怪癖。
- en: Real-world teams that adopt AI (like those at [Snyk](https://oreil.ly/8Dmn7))
    report that it can boost productivity, but they also stress keeping a human in
    the loop for validation. In one [2024 survey by GitHub](https://oreil.ly/oivAx),
    97% of developers reported using AI coding tools at work in some capacity.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 采用AI的现实世界团队（如[Snyk](https://oreil.ly/8Dmn7)的团队）报告称，它可以提高生产力，但他们也强调在验证过程中保持人类参与。在GitHub于2024年进行的一项[调查](https://oreil.ly/oivAx)中，97%的开发者报告称在工作中以某种形式使用AI编码工具。
- en: Testing and Validation for AI-Generated Web Applications
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对AI生成的Web应用程序进行测试和验证
- en: 'After building your web app with AI help, test thoroughly to ensure everything
    works as intended and to catch issues that you or the AI might have introduced.
    Here’s how you can approach testing in this AI-assisted context:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用AI帮助构建你的Web应用程序后，彻底测试以确保一切按预期工作，并捕捉到你或AI可能引入的问题。以下是在这种AI辅助环境中进行测试的方法：
- en: Unit tests
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'For backend logic, write unit tests for critical functions (like a function
    that calculates something or validates input). If the AI wrote the function, writing
    a test for it can reveal any hidden bugs. You can even have the AI generate these
    tests, as mentioned. Be cautious, though: AI-generated tests are sometimes trivial
    or assume an implementation, so you may need to guide it to test edge cases:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后端逻辑，为关键函数（如计算某些内容的函数或验证输入的函数）编写单元测试。如果 AI 编写了该函数，为其编写测试可以揭示任何隐藏的错误。你甚至可以让
    AI 生成这些测试，如前所述。但请注意：AI 生成的测试有时可能是微不足道的或假设了实现，因此你可能需要引导它测试边缘情况：
- en: Write tests for the password strength function, including edge cases like empty
    password, very long password, password with special chars, etc.
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为密码强度函数编写测试，包括空密码、非常长的密码、包含特殊字符的密码等边缘情况。
- en: Integration tests
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'Test the API endpoints with something like Supertest (for Node) or direct HTTP
    calls. Check that each endpoint returns the expected results. AI can help you
    scaffold these:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似 Supertest（用于 Node）或直接 HTTP 调用的工具测试 API 端点。检查每个端点是否返回预期的结果。AI 可以帮助你构建这些：
- en: Write integration tests for the /api/to-dos endpoints using Jest and Supertest.
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 Jest 和 Supertest 为 `/api/to-dos` 端点编写集成测试。
- en: It might produce tests that start the app, hit the endpoints, and assert on
    responses.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会生成启动应用、击中端点并对响应进行断言的测试。
- en: Frontend tests
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 前端测试
- en: 'Web UI testing can be done with tools like Jest (for component logic) and Cypress
    or Playwright for end-to-end UI tests. You can certainly ask AI to generate a
    Cypress test scenario:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Web UI 测试可以使用 Jest（用于组件逻辑）和 Cypress 或 Playwright 进行端到端 UI 测试。你当然可以要求 AI 生成一个
    Cypress 测试场景：
- en: Write a Cypress test that loads the app, adds a new to-do via the form, and
    checks that it appears in the list.
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个 Cypress 测试，加载应用，通过表单添加一个新的待办事项，并检查它是否出现在列表中。
- en: You’ll get a test script, which you can run. This is quite powerful—you quickly
    get end-to-end test coverage by leveraging the AI to script user interactions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得一个测试脚本，可以运行。这非常强大——通过利用 AI 编写用户交互，你可以快速获得端到端测试覆盖率。
- en: Manual tests
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试
- en: 'Whatever automated tests you run, always do some manual exploratory testing,
    too. Click around the web app yourself (or have QA do it, if you’re working in
    a team). The AI might not anticipate every real-world scenario: for example, maybe
    using the browser Back button breaks some state, or a particular sequence of actions
    causes a glitch. As you find bugs, fix them or ask the AI to help fix them. Manual
    testing is also important for UI/UX judgment—does the app feel good to use? Are
    there any awkward flows? The AI won’t know how to judge these subjective UX issues,
    so human feedback is key.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你运行什么自动化测试，都要进行一些手动探索性测试。亲自点击网页应用（或者如果你在一个团队中工作，让 QA 做这件事）。AI 可能无法预见每一个现实世界场景：例如，可能使用浏览器的后退按钮会破坏某些状态，或者特定的动作序列会导致故障。当你发现错误时，修复它们或要求
    AI 帮助修复。手动测试对于 UI/UX 判断也很重要——应用是否易于使用？是否存在任何不自然的流程？AI 无法判断这些主观的 UX 问题，因此人类反馈至关重要。
- en: Code review
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查
- en: If you’re working with others, have them review the AI-generated code. Fresh
    eyes can catch things you might have glossed over—they might spot a security oversight
    or simply suggest a more idiomatic way to write something. Teams using AI often
    maintain normal code-review processes, just with [more focus](https://oreil.ly/O5Dbj)
    on reviewing for subtle bugs or security issues that an AI might inadvertently
    introduce.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你与他人合作，让他们审查 AI 生成的代码。新视角可能会发现你可能忽略的事情——他们可能会发现安全疏忽，或者只是建议一种更符合习惯的编写方式。使用
    AI 的团队通常保持正常的代码审查流程，只是更加关注审查 AI 可能无意中引入的微妙错误或安全问题。
- en: Security audit
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 安全审计
- en: '[Chapter 8](ch08.html#ch08_security_maintainability_and_reliability_1752630044621528)
    will dive into security, but even at development time, it’s worth scanning your
    code for known vulnerability patterns.  There are automated tools you can run,
    like linters and [Static Application Security Testing](https://oreil.ly/T531z)
    (SAST) tools, or you can prompt the AI:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 8 章](ch08.html#ch08_security_maintainability_and_reliability_1752630044621528)
    将深入探讨安全，但即使在开发时间，扫描代码以查找已知漏洞模式也是值得的。你可以运行自动化工具，如代码检查器和 [静态应用程序安全测试](https://oreil.ly/T531z)（SAST）工具，或者你可以提示
    AI：'
- en: Review the Express app code and list any potential security vulnerabilities
    or best practice violations.
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 审查 Express 应用代码，并列出任何潜在的安全漏洞或最佳实践违规。
- en: The AI might flag some surprising things, like “You are not sanitizing user
    input here” or “You should set up CORS properly.” Use that as a checklist for
    hardening the app.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: AI可能会标记一些令人惊讶的事情，比如“你在这里没有对用户输入进行清理”或“你应该正确设置CORS。”将这些用作加固应用程序的清单。
- en: 'One interesting effect of using AI is that you may write tests you wouldn’t
    have otherwise, because the AI makes it so easy to create them. This can actually
    lead to *more* robust code in the end. If you adopt a practice of generating tests
    immediately after generating features (essentially AI-assisted test-driven development,
    or at least post hoc tests), you ensure that the rapid development doesn’t compromise
    quality. Think of it like this: since the AI saved you time writing code, invest
    some of that saved time into writing and running tests.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AI的一个有趣的效果是，你可能会编写你原本不会编写的测试，因为AI使创建它们变得如此简单。这实际上可能导致最终代码的*更*健壮。如果你在生成功能后立即生成测试（本质上是一种AI辅助的测试驱动开发，或者至少是事后测试），你确保了快速开发不会影响质量。想想看：既然AI帮你节省了编写代码的时间，就把这部分节省的时间投资到编写和运行测试上。
- en: AI can suggest insecure code if the user isn’t careful. For example, earlier
    AI versions might generate SQL queries that are vulnerable to injection attacks
    if not specifically prompted to avoid that. By testing and reviewing, you catch
    these issues. [One study](https://oreil.ly/U3b8H) found that developers using
    AI assistance tended to be overconfident in their code’s security, even when it
    was worse than it would’ve been if written manually.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户不小心，AI可能会建议不安全的代码。例如，早期的AI版本可能会生成易受注入攻击的SQL查询，除非特别提示避免这种情况。通过测试和审查，你可以捕捉到这些问题。[一项研究](https://oreil.ly/U3b8H)发现，使用AI辅助的开发者往往对自己的代码安全性过于自信，即使它们比手动编写的代码更差。
- en: Never skip validation just because an AI wrote the code. Assume it can have
    bugs, just like any human-written code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 不要因为代码是由AI编写的就跳过验证。假设它可能存在错误，就像任何由人类编写的代码一样。
- en: Examples of Successful AI-Built Web Projects
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成功的AI构建网络项目示例
- en: Let’s highlight a couple of examples (composites drawn from various reports)
    where AI assistance played a significant role in delivering real web applications.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们突出一些例子（从各种报告中抽取的复合例子），在这些例子中，AI辅助在交付真实网络应用中发挥了重要作用。
- en: Ecommerce site by a solo developer
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由独立开发者创建的电子商务网站
- en: A solo developer wanted to create a small ecommerce web app to sell custom T-shirts
    but had limited time. He used GPT, through an IDE extension, to build the entire
    stack. He prompted the AI to generate a React frontend with product listings,
    a cart, and checkout pages, as well as a Node.js backend with endpoints for products
    and orders. He used Stripe for payments, integrating it by asking the AI to help
    with Stripe’s API. After working on it in the evenings for two weeks, he had a
    functioning site.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一个独立开发者想创建一个小的电子商务网络应用来销售定制T恤，但时间有限。他通过IDE扩展使用了GPT来构建整个堆栈。他提示AI生成一个具有产品列表、购物车和结账页面的React前端，以及一个具有产品和订单端点的Node.js后端。他使用Stripe进行支付，并通过请求AI帮助集成Stripe的API来集成它。在连续两周的晚上工作后，他拥有了一个功能齐全的网站。
- en: This developer reported that AI had done probably 70% of the coding, especially
    the repetitive UI parts and form handling, while he focused on configuring Stripe
    correctly and fine-tuning the UI for branding. In the end, customers could browse
    products, add them to the cart, and purchase them—all in a system built largely
    via vibe coding. It also highlights that external service integration (like Stripe)
    is feasible with AI guidance, as long as documentation is available for the model
    to draw from or you provide it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 该开发者报告称，AI可能完成了大约70%的编码工作，特别是重复的UI部分和表单处理，而他则专注于正确配置Stripe和微调UI以适应品牌。最终，客户可以在一个主要通过vibe编码构建的系统内浏览产品、将它们添加到购物车并购买——所有这些都在一个系统中完成。这也突出了，在外部服务集成（如Stripe）方面，只要有模型可以从中获取的文档或你提供它，AI指导是可行的。
- en: Internal company dashboard
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 内部公司仪表板
- en: A product manager with some coding skills used an AI pair programmer to create
    an internal analytics dashboard for her team. Normally, she would have had to
    wait for engineering resources, but using a tool like Replit’s Ghostwriter or
    GitHub Copilot in a web project, she managed to build a basic web app herself.
    The AI helped with setting up a simple Flask backend to query their database (with
    safe read-only credentials) and a Vue.js frontend to display graphs (using a charting
    library). She described what each chart should show (“total sign-ups over time,”
    “active users by region”), and the AI wrote the SQL queries and chart code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一位具备一些编码技能的产品经理使用人工智能配对程序员为她团队创建了一个内部分析仪表板。通常，她需要等待工程资源，但通过在Web项目中使用Replit的Ghostwriter或GitHub
    Copilot这样的工具，她设法自己构建了一个基本的Web应用程序。人工智能帮助设置了简单的Flask后端来查询他们的数据库（使用安全的只读凭证）和一个Vue.js前端来显示图表（使用图表库）。她描述了每个图表应该显示的内容（“随时间推移的总注册量”，“按地区活跃用户”），然后人工智能编写了SQL查询和图表代码。
- en: The whole process took a couple of weeks of tinkering and testing, but eventually
    she delivered a working dashboard. The code quality wasn’t enterprise grade, but
    since it was internal, it was fine. More importantly, she empowered her team with
    a tool in a fraction of the time. This example illustrates how AI tools can enable
    nonspecialist programmers to produce useful web apps, unblocking tasks that might
    otherwise sit in a backlog. It’s an example of the “unbundling of the programmer”
    that I’ll discuss in [Chapter 10](ch10.html#ch10_autonomous_background_coding_agents_1752630045087844),
    which is all about how individuals can create personal or team-specific software
    more easily now.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程花费了几个星期的调试和测试，但最终她交付了一个可工作的仪表板。代码质量不是企业级，但由于它是内部的，所以没问题。更重要的是，她用极短的时间为团队提供了一种工具。这个例子说明了人工智能工具如何使非专业程序员能够制作出有用的Web应用程序，解开可能否则会积压在待办事项中的任务。这是一个“程序员解绑”的例子，我将在[第10章](ch10.html#ch10_autonomous_background_coding_agents_1752630045087844)中讨论，该章节全部关于个人或团队如何更容易地创建个人或特定团队的软件。
- en: Startup minimum viable product (MVP)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 创业最小可行产品（MVP）
- en: 'A small startup (just two cofounders: one business, one technical) needed an
    MVP web application to show to investors. The technical cofounder used vibe coding
    extensively to build an MVP in record time. Using an AI assistant, he scaffolded
    a modern web app using Next.js for the SSR React frontend and a simple Node API.
    He leveraged AI to implement features like social login (the AI wrote the OAuth
    flows), image uploads (the AI integrated with a cloud-storage API), and an AI-based
    feature within the product itself. They even used the AI to help integrate an
    NLP model from an API. In a few months, one developer achieved what might normally
    take a small team four to six months. The result was a somewhat hacky but functioning
    product that they could demo, and they could even onboard beta users onto the
    platform.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小型创业公司（只有两个联合创始人：一个业务，一个技术）需要一个MVP Web应用程序向投资者展示。技术联合创始人广泛使用vibe编码在创纪录的时间内构建了一个MVP。使用人工智能助手，他使用Next.js构建了一个现代Web应用程序，用于SSR
    React前端和一个简单的Node API。他利用人工智能实现了社交登录（人工智能编写了OAuth流程）、图片上传（人工智能与云存储API集成）以及产品本身中的基于人工智能的功能。他们甚至使用人工智能帮助集成来自API的自然语言处理模型。在几个月内，一位开发者完成了通常需要一个小团队四到六个月才能完成的工作。结果是虽然有些简陋但功能齐全的产品，他们可以进行演示，甚至可以将测试用户引入平台。
- en: When the cofounders later hired more devs to polish the product, the new devs
    found the AI-written code to be mostly understandable, though they did refactor
    significant portions for scalability. This underlines that AI can get you to the
    first stage quickly, but you might need to invest in quality as you move to the
    next stages.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当联合创始人后来雇佣更多开发者来完善产品时，新开发者发现人工智能编写的代码大部分是可以理解的，尽管他们确实重构了很大一部分代码以提高可扩展性。这表明人工智能可以帮助你快速达到第一阶段，但当你进入下一阶段时，你可能需要投资于质量。
- en: These stories, while anecdotal, align with emerging patterns in the industry.
    In web development specifically, which often involves wiring many components together,
    the productivity boost is very tangible. [Microsoft](https://oreil.ly/QLunu) and
    [others](https://oreil.ly/BNVrB) reported studies finding that developers with
    AI could complete tasks significantly faster than those without.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这些故事虽然只是轶事，但与行业中的新兴模式相吻合。特别是在网络开发领域，这通常涉及将许多组件连接起来，生产力的提升是非常明显的。[微软](https://oreil.ly/QLunu)和[其他人](https://oreil.ly/BNVrB)报告的研究发现，使用人工智能的开发者能够比没有使用人工智能的开发者更快地完成任务。
- en: However, there have also been cautionary tales. For instance, a developer might
    deploy an AI-generated web app with a security flaw because they don’t fully understand
    the code. This risk reinforces why testing and review are crucial.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一些警示故事。例如，一个开发者可能因为不完全理解代码而部署了一个存在安全漏洞的人工智能生成的Web应用程序。这种风险强化了为什么测试和审查至关重要的原因。
- en: In conclusion, building web applications with AI assistance is becoming a mainstream
    approach. It doesn’t remove the need for skilled developers; rather, it augments
    them. The developers still plan the architecture, ensure correctness, and handle
    the complex or novel aspects of the code, while the AI handles the repetitive
    boilerplate code that glues everything together. The end-to-end workflow we walked
    through—from scaffolding to frontend to backend to testing—demonstrates that practically
    every step of web development can be accelerated with AI, as long as you apply
    your human judgment and expertise along the way.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在人工智能辅助下构建Web应用程序正成为一种主流方法。这并不是要消除对熟练开发者的需求；相反，它是增强他们的能力。开发者仍然负责规划架构、确保正确性，并处理代码的复杂或新颖方面，而人工智能则处理将一切粘合在一起的重复性模板代码。我们走过的端到端工作流程——从脚手架到前端再到后端到测试——证明了只要你在过程中应用你的判断力和专业知识，实际上Web开发的每一步都可以通过人工智能来加速。
- en: Summary and Next Steps
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要及下一步行动
- en: In this chapter, you’ve seen how vibe coding extends to full-scale web application
    development. By treating the AI as an always available pair programmer, you can
    tackle frontend and backend tasks in parallel, generate components and APIs from
    natural descriptions, and iteratively refine a prototype application to production
    quality. The keys to success include clearly communicating your intent (so the
    AI knows what you want at each step), carefully verifying (to catch issues in
    the AI output), and leveraging the AI not just to generate code but for things
    like brainstorming schema designs and writing tests.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经看到了vibe编码如何扩展到全规模Web应用程序开发。通过将人工智能视为始终可用的配对程序员，您可以并行处理前端和后端任务，从自然描述中生成组件和API，并迭代地改进原型应用程序以达到生产质量。成功的关键包括清楚地传达您的意图（以便人工智能知道每一步您想要什么），仔细验证（以捕捉人工智能输出中的问题），并利用人工智能不仅生成代码，还用于诸如头脑风暴架构设计、编写测试等活动。
- en: This chapter also explored how a developer can effectively be a full stack engineer,
    augmented by AI bridging gaps in their knowledge by suggesting code in areas they
    are less familiar with. This greatly reduces development time for common features
    and democratizes development in some ways, enabling people to create custom web
    solutions without large teams (a theme I’ll revisit in [Chapter 10](ch10.html#ch10_autonomous_background_coding_agents_1752630045087844)).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还探讨了开发者如何通过人工智能来有效地成为全栈工程师，人工智能通过在开发者不太熟悉的部分建议代码来弥合他们的知识差距。这大大减少了常见功能的开发生命周期，并在某些方面实现了开发的民主化，使人们能够在没有大型团队的情况下创建定制的Web解决方案（我将在[第10章](ch10.html#ch10_autonomous_background_coding_agents_1752630045087844)中再次探讨这一主题）。
- en: AI doesn’t replace understanding the requirements or ensuring quality; it accelerates
    execution.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能并不能取代理解需求或确保质量；它加速了执行。
- en: Now that your web application is up and running, the next concern is making
    sure it is secure, reliable, and maintainable. [Chapter 8](ch08.html#ch08_security_maintainability_and_reliability_1752630044621528)
    dives into the challenges of security and reliability in AI-generated codebases,
    identifying common vulnerabilities that might slip in, how to audit for and fix
    them, and best practices (like the ones we’ve started applying here with tests
    and reviews) to ensure that moving fast with AI doesn’t break things. Essentially,
    we’ll shift from building to hardening—making sure your vibe-coded software stands
    up to real-world conditions and threats.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的Web应用程序已经上线并运行，接下来的关注点是确保它是安全的、可靠的和可维护的。[第8章](ch08.html#ch08_security_maintainability_and_reliability_1752630044621528)深入探讨了人工智能生成代码库中的安全和可靠性挑战，确定了可能遗漏的常见漏洞，如何审计和修复它们，以及最佳实践（如我们在这里开始应用的测试和审查），以确保快速使用人工智能不会破坏事物。本质上，我们将从构建转向加固——确保您的vibe编码软件能够经受住现实世界的条件和威胁。
