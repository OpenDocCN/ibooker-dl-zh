- en: Chapter 8\. Authentication and Authorization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章\. 认证和授权
- en: So far, you’ve built GenAI services that can interact with databases, stream
    model responses, and handle concurrent users.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经构建了可以与数据库交互、流式传输模型响应和处理并发用户的 GenAI 服务。
- en: Your services are now up and running, but since they’re not protected from attackers
    or malicious users, deploying them to production may prove problematic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您的服务现在已启动并运行，但由于它们没有受到攻击者或恶意用户的保护，部署到生产环境可能会遇到问题。
- en: In this chapter, you’ll learn how to secure your services with an authentication
    layer and implement authorization guards to protect sensitive resources from nonprivileged
    users.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何通过认证层来保护您的服务，并实现授权守卫以保护敏感资源免受非特权用户的侵害。
- en: To achieve this, we’re going to explore various authentication and authorization
    patterns then implement JWT and identity-based authentication with role-based
    access control.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将探索各种认证和授权模式，然后实现 JWT 和基于身份的认证以及基于角色的访问控制。
- en: Authentication and Authorization
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证和授权
- en: Before talking about authentication methods, let’s briefly clarify that authentication
    and authorization are two separate concepts that are often interchangeably used
    by mistake.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论认证方法之前，让我们简要澄清认证和授权是两个不同的概念，它们经常被错误地互换使用。
- en: According to the OWASP definition:^([1](ch08.html#id970))
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 OWASP 的定义：^([1](ch08.html#id970))
- en: '*Authentication* is the process of verifying that an individual, entity, or
    website is who or what it claims to be by determining the validity of one or more
    authenticators (like passwords, fingerprints, or security tokens) that are used
    to back up this claim.'
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*认证* 是通过确定一个或多个认证者（如密码、指纹或安全令牌）的有效性来验证个人、实体或网站是否是其声明的身份的过程。'
- en: 'On the other hand, the National Institute of Standards and Technology (NIST)
    defines authorization as:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，美国国家标准与技术研究院（NIST）将授权定义为：
- en: A process for verifying that a requested action or service is approved for a
    specific entity.
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一种验证请求的操作或服务是否被特定实体批准的过程。
- en: While authentication is about verifying the identity, authorization focuses
    on verifying permissions of an identity to access or mutate resources.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然认证是关于验证身份，但授权侧重于验证身份访问或修改资源的权限。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: An analogy that might clarify this distinction is passing through passport control
    at an airport. Authentication is like presenting your passport at immigration,
    while authorization is like having the right visa to enter a country, specifying
    the duration of your stay and permitted activities once you enter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能有助于阐明这种区别的类比是在机场通过护照控制。认证就像在移民局出示护照，而授权就像拥有进入一个国家的正确签证，一旦进入，它将指定您的停留时间和允许的活动。
- en: Let’s discuss authentication methods in more detail before diving into authorization
    later in the chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面讨论授权之前，让我们更详细地讨论认证方法。
- en: Authentication Methods
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证方法
- en: There are several authentication mechanisms that you can implement in your GenAI
    services to secure them by identity verification.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在您的 GenAI 服务中实施几种认证机制，通过身份验证来确保它们的安全。
- en: 'Depending on your security requirements, application environment, budget, and
    project timelines, you may decide to adopt one or more of the following authentication
    mechanisms:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的安全要求、应用环境、预算和项目时间表，您可能决定采用以下一个或多个认证机制：
- en: Basic
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基本认证
- en: Requiring the use of credentials such as username and password to verify identity.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要求使用用户名和密码等凭证来验证身份。
- en: JSON Web Tokens (JWT)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Tokens (JWT)
- en: Requiring the use of *access tokens* to verify identity. You can think of access
    tokens like cinema tickets that dictate whether you can access the screens and
    which screen you’re visiting and where you’re sitting.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要求使用 *访问令牌* 来验证身份。您可以将访问令牌想象成电影院的门票，它规定了您是否可以进入放映厅以及您将访问哪个放映厅以及您将坐在哪里。
- en: OAuth
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth
- en: Verifying an identity via an identity provider using the *OAuth2* standard.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *OAuth2* 标准通过身份提供者验证身份。
- en: Key-based
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 基于密钥
- en: Using a private and public key pair to authenticate an identity. Instead of
    tokens, the authorization server issues a public key to the client and stores
    a copy of a linked private key that it can use later for verification.^([2](ch08.html#id971))
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一对私钥和公钥来验证身份。与令牌不同，授权服务器向客户端颁发一个公钥，并存储一个链接的私钥副本，它可以在以后用于验证.^([2](ch08.html#id971))
- en: '[Figure 8-1](#authentication_methods) shows the data flow of the aforementioned
    authentication methods in more detail.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-1](#authentication_methods)更详细地显示了上述认证方法的数据流。'
- en: '![bgai 0801](assets/bgai_0801.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0801](assets/bgai_0801.png)'
- en: Figure 8-1\. Authentication methods
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-1\. 认证方法
- en: Being aware of authentication mechanisms, it can still be challenging to decide
    on the method to adopt when addressing your security requirements. To assist with
    the selection task, [Table 8-1](#authentication_methods_comparison) compares the
    aforementioned authentication methods.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解认证机制，但在解决您的安全需求时，选择采用的方法仍然可能具有挑战性。为了帮助选择任务，[表8-1](#authentication_methods_comparison)比较了上述认证方法。
- en: Table 8-1\. Comparison of authentication methods
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-1\. 认证方法比较
- en: '| Type | Benefits | Limitations | Use cases |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 优点 | 缺点 | 用例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Basic |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 基本认证 |'
- en: Simplicity
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单性
- en: Fast to implement
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速实现
- en: Easy to understand
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于理解
- en: '| Sends credentials in plain text |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 以明文发送凭证 |'
- en: Prototypes
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型
- en: Internal or nonproduction environments
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部或非生产环境
- en: '|'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Token |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 令牌 |'
- en: Scalability
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Decoupling facilitates implementation of microservice architectures
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦有助于实现微服务架构
- en: Tokens can be signed and encrypted for higher security
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌可以签名和加密以提高安全性
- en: Highly customizable
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度可定制
- en: Self-contained reducing database round-trips
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自包含减少数据库往返次数
- en: Can be passed in HTTP headers
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过HTTP头传递
- en: '|'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Constant need to regenerate short-lived tokens
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要不断重新生成短期令牌
- en: Complexity of client-side token storage
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端令牌存储的复杂性
- en: Tokens can get large, consuming excess bandwidth
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌可能变得很大，消耗过多的带宽
- en: Stateless tokens can make multi-step applications hard to implement
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态令牌可能使多步骤应用难以实现
- en: Client-side misconfigurations can compromise tokens
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端配置错误可能使令牌受到损害
- en: '|'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Single-page and mobile applications
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单页和移动应用
- en: Applications requiring custom authentication flows
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要自定义认证流程的应用
- en: REST APIs
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST API
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| OAuth |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| OAuth |'
- en: Delegates authentication to external providers
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将认证委托给外部提供者
- en: Based on a standard (OAuth2) and battle-tested for enterprise scenarios
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于标准（OAuth2）并在企业场景中得到实战检验
- en: Access to external resources on behalf of the user
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表用户访问外部资源
- en: '|'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Complex to understand and implement
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以理解和实现
- en: Each identity provider may implement the OAuth flow slightly differently
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个身份提供者可能对OAuth流程的实现略有不同
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Applications requiring user data from external identity providers such as GitHub,
    Google, or Microsoft
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要从GitHub、Google或Microsoft等外部身份提供者获取用户数据的应用
- en: Enterprise applications that require SSO with their own identity provider(s)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要与自己的身份提供者（们）进行SSO的企业应用
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Key-based |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 基于密钥 |'
- en: Similar authentication mechanism to Secure Shell (SSH) access
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与安全壳（SSH）访问类似的认证机制
- en: '|'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Managing and keeping private keys secure can be complex
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理和保持私钥安全可能很复杂
- en: Compromised keys can create security risks
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被泄露的密钥可能造成安全风险
- en: Scalability issues
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性问题
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Small applications
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型应用
- en: Applications within internal environments
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部环境中的应用
- en: '|'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: You should now feel confident in deciding the appropriate authentication mechanism
    to adopt. In the next section, you’re going to implement basic, JWT, and OAuth
    authentication for your GenAI to fully understand the underlying components and
    their interactions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该对选择适当的认证机制充满信心。在下一节中，您将为您的人工智能实现基本、JWT和OAuth认证，以全面了解其底层组件及其交互。
- en: Basic Authentication
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本认证
- en: In basic authentication, the client provides a username and password when making
    a request to access resources from the server. It is the simplest technique as
    it won’t require cookies, session identifiers, or any login forms to be implemented.
    Because of its simplicity, basic authentication is ideal for sandbox environments
    and when prototyping. However, avoid using it in production environments as it
    transmits usernames and passwords in plain text on every request, making it highly
    vulnerable to interception attacks.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本认证中，客户端在从服务器请求访问资源时提供用户名和密码。这是最简单的技术，因为它不需要实现cookies、会话标识符或任何登录表单。由于其简单性，基本认证非常适合沙盒环境和原型设计。然而，避免在生产环境中使用它，因为它在每次请求中都以明文形式传输用户名和密码，使其非常容易受到拦截攻击。
- en: To perform an authenticated request via basic authentication, you must add an
    `Authorization` header with a value of `Basic <credentials>` for the server to
    successfully authenticate it. The `<credentials>` value must be a *Base64* encoding
    of the username and password joined by a single colon (i.e., `base64.encode(ali:secretpassword)`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过基本身份验证执行认证请求，您必须添加一个值为`Basic <credentials>`的`Authorization`头，以便服务器能够成功认证它。`<credentials>`值必须是用户名和密码通过单个冒号连接的*Base64*编码（即`base64.encode(ali:secretpassword)`）。
- en: In FastAPI, you can protect an endpoint with basic authentication, as shown
    in [Example 8-1](#basic_authentication_endpoint).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在FastAPI中，您可以使用基本身份验证保护端点，如[示例8-1](#basic_authentication_endpoint)所示。
- en: Example 8-1\. Implementing basic authentication in FastAPI
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例8-1\. 在FastAPI中实现基本身份验证
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO1-1)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_authentication_and_authorization_CO1-1)'
- en: FastAPI has implemented several HTTP security mechanisms including `HTTP​Ba⁠sic`
    that can leverage the FastAPI’s dependency injection system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI实现了多个HTTP安全机制，包括可以利用FastAPI依赖注入系统的`HTTPBasic`。
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO1-2)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_authentication_and_authorization_CO1-2)'
- en: Use the `secrets` built-in library to compare the provided username and password
    with the server’s values. Using `secrets.compare_digest()` ensures the duration
    of checking operations remain consistent no matter what the inputs are to avoid
    *timing attacks*.^([3](ch08.html#id972))
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的`secrets`库比较提供的用户名和密码与服务器上的值。使用`secrets.compare_digest()`确保检查操作的持续时间保持一致，无论输入是什么，以避免*时间攻击*。^([3](ch08.html#id972))
- en: Note that `secrets.compare_digest()` can only accept byte or string inputs containing
    ASCII characters (i.e., English-only characters). To handle other characters,
    you will need to encode the inputs with `UTF-8` to bytes first before performing
    the credential checks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`secrets.compare_digest()`只能接受包含ASCII字符（即仅英文字符）的字节或字符串输入。要处理其他字符，您需要先将输入编码为`UTF-8`字节，然后再执行凭证检查。
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO1-4)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_authentication_and_authorization_CO1-4)'
- en: Return a standardized authorization `HTTPException` compliant with security
    standards that browsers understand so that they show the login prompt again to
    the user. The exception message must be generic to avoid leaking any sensitive
    information, such as the existence of a user account, to attackers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 返回符合安全标准的标准化授权`HTTPException`，以便浏览器能够再次向用户显示登录提示。异常消息必须是通用的，以避免向攻击者泄露任何敏感信息，例如用户账户的存在。
- en: '[![4](assets/4.png)](#co_authentication_and_authorization_CO1-5)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_authentication_and_authorization_CO1-5)'
- en: Using the `HTTPBasic` with `Depends()` returns the `HTTPBasicCredentials` object
    that contains the provided username.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HTTPBasic`与`Depends()`一起返回包含提供的用户名的`HTTPBasicCredentials`对象。
- en: Injecting a security dependency to any FastAPI endpoint will protect it with
    the implemented authentication. You can experience this yourself now by visiting
    the `/docs` page and sending a request to the `/users/me` endpoint.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将安全依赖注入到任何FastAPI端点将使用实现的身份验证来保护它。你现在可以通过访问`/docs`页面并向`/users/me`端点发送请求来亲自体验这一点。
- en: The endpoint will show a *lock* icon in front of it, and you should see a sign-in
    alert when making a request, asking you to provide credentials, as you can see
    in [Figure 8-2](#basic_authentication).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 端点在其前面将显示一个*锁*图标，当您发起请求时，您应该看到一个登录警报，要求您提供凭证，正如您在[图8-2](#basic_authentication)中看到的那样。
- en: '![bgai 0802](assets/bgai_0802.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0802](assets/bgai_0802.png)'
- en: Figure 8-2\. Basic authentication in FastAPI
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-2\. FastAPI中的基本身份验证
- en: Well done! In 25 lines of code, you managed to implement a basic form of authentication
    to protect an endpoint. You can now use basic authentication in your own prototypes
    and development servers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！在25行代码中，你成功实现了基本身份验证来保护端点。现在你可以在自己的原型和开发服务器中使用基本身份验证。
- en: Bear in mind, you should avoid adopting the basic authentication mechanism in
    production-grade GenAI services. A better and more secure alternative for public-facing
    services is *JWT authentication*. It eliminates the need for server-side sessions
    by storing all authentication details within a token. It also maintains data integrity
    and works across different domains with a widely accepted standard.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在生产级别的 GenAI 服务中，您应该避免采用基本的认证机制。对于面向公众的服务，*JWT 认证* 是一个更好且更安全的替代方案。它通过在令牌中存储所有认证细节来消除服务器端会话的需求。它还维护数据完整性，并支持跨不同域的广泛接受的标准。
- en: JSON Web Tokens (JWT) Authentication
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON Web Tokens (JWT) 认证
- en: Now that you’re more familiar with basic concepts of authentication, let’s implement
    a more complex but secure JWT authentication layer to your FastAPI service. As
    part of this, you’ll also refactor your existing endpoints to combine them under
    a separate resource API router to group, name, tag, and protect multiple endpoints
    at once.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您对认证的基本概念更加熟悉，让我们为您的 FastAPI 服务实现一个更复杂但更安全的 JWT 认证层。作为此过程的一部分，您还需要重构现有的端点，将它们组合在一个单独的资源
    API 路由器下，以便一次性对多个端点进行分组、命名、标记和保护。
- en: What is JWT?
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是 JWT？
- en: JWTs are a URL-safe and compact way of asserting claims between applications
    via tokens.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 是一种通过令牌在应用程序之间断言声明的 URL 安全且紧凑的方式。
- en: 'These tokens consist of three parts:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些令牌由三个部分组成：
- en: Headers
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 头部
- en: Specify the token type and signing algorithm in addition to the datetime and
    the issuing authority.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了日期时间和发行机构外，还需要指定令牌类型和签名算法。
- en: Payload
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有效载荷
- en: Specify the body of the token representing the claims on the resource alongside
    additional metadata.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 指定表示资源上声明的令牌主体以及附加元数据的内容。
- en: Signature
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 签名
- en: The function that creates the token will also sign it using the *encoded payload*,
    *encoded headers*, a *secret*, and the signing algorithm.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 创建令牌的函数将使用 *编码后的有效载荷*、*编码后的头部*、一个 *密钥* 和签名算法来对令牌进行签名。
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `base64` encoding algorithm is often used to encode and decode data for
    compactness and URL safety.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`base64` 编码算法常用于对数据进行编码和解码，以实现紧凑性和 URL 安全性。'
- en: '[Figure 8-3](#jwt) shows what a typical JWT looks like.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-3](#jwt) 展示了一个典型的 JWT 的样子。'
- en: '![bgai 0803](assets/bgai_0803.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0803](assets/bgai_0803.png)'
- en: 'Figure 8-3\. JWT components (Source: [jwt.io](https://jwt.io))'
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-3\. JWT 组件（来源：[jwt.io](https://jwt.io))
- en: JWTs are secure, compact, and convenient since they can hold all the information
    needed to perform user authentication, avoiding the need for multiple database
    round-trips. In addition, due to their compactness, you can transfer them across
    the network using the HTTP `POST` body, headers, or URL parameters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 是安全的、紧凑的，并且方便，因为它们可以包含执行用户认证所需的所有信息，避免了多次数据库往返的需求。此外，由于它们的紧凑性，您可以通过 HTTP
    `POST` 主体、头部或 URL 参数在网络中传输它们。
- en: Getting started with JWT authentication
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始使用 JWT 认证
- en: 'To get started with implementing the JWT authentication mechanism in FastAPI,
    you need to install the `passlib` and `python-jose` dependencies:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 FastAPI 中实现 JWT 认证机制，您需要安装 `passlib` 和 `python-jose` 依赖项：
- en: '[PRE1]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the dependencies installed, you will then need tables in the database to
    store the generated users and associated token data. For data persistence, let’s
    migrate the database to create the `users` and `tokens` tables, as shown in [Figure 8-4](#erd).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了依赖项之后，您还需要在数据库中创建表来存储生成的用户和相关令牌数据。为了数据持久性，让我们将数据库迁移以创建 `users` 和 `tokens`
    表，如图 8-4 所示。
- en: '![bgai 0804](assets/bgai_0804.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0804](assets/bgai_0804.png)'
- en: Figure 8-4\. Entity relationship diagram of `users` and `tokens` tables
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-4\. `users` 和 `tokens` 表的实体关系图
- en: If you look at [Figure 8-4](#erd), you will spot that the `tokens` table has
    a one-to-many relationship with the `users` table. You can use the token records
    to track successful login attempts for each user and to revoke access if needed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看 [图 8-4](#erd)，您将注意到 `tokens` 表与 `users` 表之间存在一对一的关系。您可以使用令牌记录来跟踪每个用户的成功登录尝试，并在需要时撤销访问权限。
- en: Next, let’s define the required SQLAlchemy models and Pydantic schemas for database
    queries and data validation, as shown in Examples [8-2](#user_models) and [8-3](#users_schema).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义所需的 SQLAlchemy 模型和 Pydantic 架构，用于数据库查询和数据验证，如示例 [8-2](#user_models)
    和 [8-3](#users_schema) 所示。
- en: Example 8-2\. Declare user SQLAlchemy ORM models
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-2\. 声明用户 SQLAlchemy ORM 模型
- en: '[PRE2]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will be using the ORM models at the data access layer while the Pydantic
    schemas will validate incoming and outgoing authentication data at the endpoint
    layer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据访问层使用 ORM 模型，而在端点层，Pydantic 架构将验证传入和传出的认证数据。
- en: Example 8-3\. Declare user Pydantic schemas with username and password field
    validators
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-3\. 声明包含用户名和密码字段验证器的用户 Pydantic 架构
- en: '[PRE3]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO2-1)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_authentication_and_authorization_CO2-1]'
- en: Validate both username and password to enforce higher security requirements.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 验证用户名和密码，以强制执行更高的安全要求。
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO2-3)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_authentication_and_authorization_CO2-3]'
- en: Allow Pydantic to read SQLAlchemy ORM model attributes instead of having to
    manually populate Pydantic schemas from SQLAlchemy models.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 Pydantic 读取 SQLAlchemy ORM 模型属性，而不是手动从 SQLAlchemy 模型填充 Pydantic 架构。
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO2-4)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_authentication_and_authorization_CO2-4]'
- en: Use inheritance to declare several Pydantic schemas based on a user base model.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承来声明基于用户基础模型的多个 Pydantic 架构。
- en: '[![4](assets/4.png)](#co_authentication_and_authorization_CO2-5)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_authentication_and_authorization_CO2-5]'
- en: Create a separate schema that accepts the `hashed_password` field to be used
    only for creating new user records during the registration process. All other
    schemas must skip storing this field to eliminate the risk of password leakage.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个单独的架构，该架构仅接受 `hashed_password` 字段，用于在注册过程中创建新的用户记录。所有其他架构都必须跳过存储此字段，以消除密码泄露的风险。
- en: Creating the token models and schemas is fairly similar, as you can see in [Example 8-4](#token_models).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建令牌模型和架构的过程相当相似，如示例 8-4 所示。
- en: Example 8-4\. Declare token ORM models and Pydantic schemas
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-4\. 声明令牌 ORM 模型和 Pydantic 架构
- en: '[PRE4]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, let’s auto-generate a migration file using the `alembic revision --autogenerate
    -m "create users and tokens tables` command so that you can specify the details
    of both tables by following [Example 8-5](#users_migration).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `alembic revision --autogenerate -m "create users and tokens tables"`
    命令自动生成迁移文件，以便您可以通过遵循示例 8-5 来指定两个表的具体细节。
- en: Example 8-5\. Database migration to create the `users` and `tokens` tables
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-5\. 数据库迁移以创建 `users` 和 `tokens` 表
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO3-1)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_authentication_and_authorization_CO3-1]'
- en: Automatically generate universally unique identifiers (UUIDs) in the database
    layer for user and token records to prevent attackers from guessing identifiers
    of sensitive resources (i.e., user or token records).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库层自动生成全局唯一标识符（UUIDs）用于用户和令牌记录，以防止攻击者猜测敏感资源（即用户或令牌记录）的标识符。
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO3-2)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_authentication_and_authorization_CO3-2]'
- en: Avoid storing raw password strings in the database to reduce security vulnerabilities.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在数据库中存储原始密码字符串，以减少安全漏洞。
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO3-3)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_authentication_and_authorization_CO3-3]'
- en: Add the ability to enable or disable account access.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 添加启用或禁用账户访问的能力。
- en: '[![4](assets/4.png)](#co_authentication_and_authorization_CO3-4)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_authentication_and_authorization_CO3-4]'
- en: Add the ability to specify user roles such as `USER` and `ADMIN` for managing
    access levels of an account. Authorization checks will use the `role` field to
    manage access of privileged resources.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 添加指定用户角色（如 `USER` 和 `ADMIN`）的能力，以管理账户的访问级别。授权检查将使用 `role` 字段来管理特权资源的访问。
- en: '[![5](assets/5.png)](#co_authentication_and_authorization_CO3-5)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)[#co_authentication_and_authorization_CO3-5]'
- en: Auto-timestamp user creation and updates for monitoring and security purposes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 自动记录用户创建和更新时间戳，以进行监控和安全目的。
- en: '[![6](assets/6.png)](#co_authentication_and_authorization_CO3-6)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png)[#co_authentication_and_authorization_CO3-6]'
- en: Add a unique constraint and a secondary index on the email field to optimize
    user queries by email and eliminate the possibility of creating duplicate email
    accounts.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子邮件字段上添加唯一约束和二级索引，以优化通过电子邮件的用户查询并消除创建重复电子邮件账户的可能性。
- en: '[![7](assets/7.png)](#co_authentication_and_authorization_CO3-8)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![7](assets/7.png)[#co_authentication_and_authorization_CO3-8]'
- en: Tokens must expire after a short period of time to reduce the time window that
    exposed tokens may be misused by attackers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌必须在短时间内过期，以减少暴露的令牌可能被攻击者滥用的时间窗口。
- en: '[![8](assets/8.png)](#co_authentication_and_authorization_CO3-9)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![8](assets/8.png)[#co_authentication_and_authorization_CO3-9]'
- en: Add the ability to disable tokens that should no longer be valid for either
    being exposed or if a user has logged out.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 添加禁用令牌的功能，这些令牌不再有效，无论是由于泄露还是用户登出。
- en: '[![9](assets/9.png)](#co_authentication_and_authorization_CO3-10)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_authentication_and_authorization_CO3-10)'
- en: Track the token creation and update times for monitoring and security.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪令牌的创建和更新时间，以进行监控和安全。
- en: '[![10](assets/10.png)](#co_authentication_and_authorization_CO3-11)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_authentication_and_authorization_CO3-11)'
- en: Create secondary indexes on `user_id` and `ip_address` fields to optimize token
    queries by these fields.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`user_id`和`ip_address`字段上创建二级索引，以优化通过这些字段进行的令牌查询。
- en: Now, run the `alembic upgrade head` command to execute the migration in [Example 8-5](#users_migration)
    against your database and create both `users` and `tokens` tables.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`alembic upgrade head`命令，在[示例8-5](#users_migration)中对您的数据库执行迁移，并创建`users`和`tokens`表。
- en: With the ORM models and Pydantic schemas declared, you can focus on the core
    authentication mechanism logic.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明ORM模型和Pydantic模式后，您可以专注于核心认证机制逻辑。
- en: '[Figure 8-5](#jwt_architecture) shows the architecture of the JWT authentication
    system you’re going to implement in your FastAPI GenAI service.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-5](#jwt_architecture)显示了您将在FastAPI GenAI服务中实现的JWT认证系统的架构。'
- en: '![bgai 0805](assets/bgai_0805.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0805](assets/bgai_0805.png)'
- en: Figure 8-5\. JWT authentication system architecture
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-5\. JWT认证系统架构
- en: In the following code examples, you will see how to implement the core authentication
    flows starting with user registration and JWT generation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，您将看到如何实现核心认证流程，从用户注册和JWT生成开始。
- en: Hashing and salting
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 散列和盐值
- en: The first step after creating the `users` and `tokens` tables in the database
    is to store new users in the database upon registration. However, you should avoid
    storing passwords in plain form, because if the database is compromised, the attackers
    will have every user’s credential.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中创建`users`和`tokens`表后的第一步是在注册时将新用户存储在数据库中。然而，您应该避免以明文形式存储密码，因为如果数据库被入侵，攻击者将拥有每个用户的凭证。
- en: Instead, the authentication mechanism will leverage a *hashing algorithm* that
    converts plain passwords into an encoded string that can’t be decoded back into
    its original form. Since the decoding process isn’t reversible, cryptographic
    hashing algorithms differ from standard encoding/decoding functions such as Base64.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，认证机制将利用一种*散列算法*，将明文密码转换为无法解码回原始形式的编码字符串。由于解码过程是不可逆的，因此加密散列算法与Base64等标准编码/解码函数不同。
- en: While storing hashed passwords is more secure than storing plain passwords,
    it doesn’t provide enough protection. If such a database of hashed passwords falls
    into the hands of attackers, they can use a precomputed hash tables—​commonly
    referred to as *rainbow tables*. Attackers can use rainbow tables to brute-force
    their way into your system by recovering plaintext passwords. To protect against
    these brute-force attacks, you also need to introduce an element of randomness
    to your hashing process using a technique termed *salting*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存储散列密码比存储明文密码更安全，但它不足以提供足够的保护。如果这样的散列密码数据库落入攻击者手中，他们可以使用预计算的散列表——通常称为*彩虹表*。攻击者可以使用彩虹表通过恢复明文密码来暴力破解您的系统。为了防止这些暴力破解攻击，您还需要在散列过程中引入随机性元素，使用称为*盐值*的技术。
- en: With salts, the cryptographic hashing algorithm produces different hashed passwords,
    even though the users may register with common, compromised, or duplicate passwords.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用盐值，加密散列算法即使在用户使用常见、受损或重复密码注册的情况下，也会产生不同的散列密码。
- en: Warning
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Password hashing with a random salt protects against brute-force attacks using
    rainbow tables. However, it doesn’t protect against *password spraying*, where
    attackers use a database of common passwords, or *credential stuffing*, where
    attackers enumerate on a list of compromised passwords.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用随机盐值的密码散列可以防止使用彩虹表的暴力破解攻击。然而，它不能防止*密码喷射*，其中攻击者使用常见密码的数据库，或者*凭证填充*，其中攻击者遍历受损密码的列表。
- en: During salting, the hashing function generates a random salt that appends to
    the plain password prior to hashing and then generates a hashed password.^([4](ch08.html#id982))
    Before storing the hashed password in the database, the salt is prefixed to the
    hashed password for later retrieval during verification.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在加盐过程中，哈希函数生成一个随机盐，将其附加到哈希前的明文密码上，然后生成一个哈希密码.^([4](ch08.html#id982)) 在将哈希密码存储到数据库之前，盐被添加到哈希密码的前面，以便在验证时检索。
- en: When registered users try to log in, they have to supply the same password they
    used to create their account. During the password verification process, the password
    that the user provides is hashed using the same salt that was used during registration
    which is retrieved from the database. If the generated hashed password is exactly
    identical to the hashed password in the database, then the user is authenticated.
    Otherwise, you can safely assume that wrong credentials have been supplied.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当注册用户尝试登录时，他们必须提供他们创建账户时使用的相同密码。在密码验证过程中，用户提供的密码使用在注册期间使用的相同盐进行哈希，该盐从数据库中检索。如果生成的哈希密码与数据库中的哈希密码完全相同，则用户被认证。否则，你可以安全地假设提供了错误的凭证。
- en: The salting and hashing are powerful techniques that prevent attackers from
    brute-forcing their way into your system with rainbow tables. You can see the
    full hashing and salting process in [Figure 8-6](#password_hashing).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 加盐和哈希是强大的技术，可以防止攻击者使用彩虹表强行进入你的系统。你可以在[图 8-6](#password_hashing)中看到完整的哈希和加盐过程。
- en: '![bgai 0806](assets/bgai_0806.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0806](assets/bgai_0806.png)'
- en: Figure 8-6\. Password hash salting mechanism
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-6\. 密码哈希加盐机制
- en: The password service shown in [Figure 8-6](#password_hashing) is implemented
    as `PasswordService` in [Example 8-6](#password_service).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-6](#password_hashing) 中所示的密码服务在[示例 8-6](#password_service)中实现为 `PasswordService`。'
- en: Example 8-6\. Implement a password service
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-6\. 实现密码服务
- en: '[PRE6]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO4-1)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_authentication_and_authorization_CO4-1]'
- en: Create an `AuthService` with a secret and password context managed by the `bcrypt`
    library that will handle all the user password hashing and verification.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有秘密和由 `bcrypt` 库管理的密码上下文的 `AuthService`，该服务将处理所有用户密码的哈希和验证。
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO4-2)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_authentication_and_authorization_CO4-2]'
- en: Use `bcrypt`’s cryptography algorithm and application secret to hash and verify
    passwords.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `bcrypt` 的密码学算法和应用程序密钥来哈希和验证密码。
- en: The `bcrypt` cryptographic library provides the core functionality of the `Password​Ser⁠vice`
    for hashing and verifying passwords. Using this service, requests can now be authenticated.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`bcrypt` 密码学库为 `PasswordService` 提供了哈希和验证密码的核心功能。使用此服务，现在可以认证请求。'
- en: If a request can’t be authenticated, you will also need to raise authorization-related
    exceptions, as shown in [Example 8-7](#auth_exceptions).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求无法认证，你还需要抛出与授权相关的异常，如[示例 8-7](#auth_exceptions)所示。
- en: Example 8-7\. Create authentication exceptions
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-7\. 创建认证异常
- en: '[PRE7]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The two most common authorization HTTP exceptions you will raise are related
    to unauthorized access or bad requests due to using already used usernames.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你最常遇到的两个授权 HTTP 异常与未经授权访问或由于使用已使用的用户名导致的错误请求有关。
- en: Once you have checked a user’s identity via their credentials, you will need
    to issue them an *access token*. These tokens should be short-lived to reduce
    the time-window that an attacker can use the token to access resources if the
    token is stolen.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过凭证验证了用户的身份，你需要为他们颁发一个*访问令牌*。这些令牌应该是短暂的，以减少攻击者如果令牌被盗，可以使用令牌访问资源的时间窗口。
- en: To reduce the size footprints of the tokens and protect against *token forgery*,
    the token service will sign (using a secret) and encode the token payloads with
    an encoding such as Base64. The payload will normally contain the user’s details
    such as their ID, role, issuance system, and expiry dates.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少令牌的大小并防止*令牌伪造*，令牌服务将使用（一个秘密）对令牌有效载荷进行签名并使用如 Base64 之类的编码进行编码。有效载荷通常包含用户的详细信息，例如他们的
    ID、角色、发行系统和过期日期。
- en: The token service can also decode the payload of received tokens and check their
    validity during the authentication process.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌服务还可以在认证过程中解码接收到的令牌并检查其有效性。
- en: Finally, the token service will also require database access to store and retrieve
    tokens to perform its functions. Therefore, it should inherit a `TokenRepository`,
    as shown in [Example 8-8](#token_repository).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，令牌服务还需要数据库访问来存储和检索令牌以执行其功能。因此，它应该继承`TokenRepository`，如[示例 8-8](#token_repository)所示。
- en: Example 8-8\. Implementing token repository
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-8\. 实现令牌仓库
- en: '[PRE8]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the `TokenRepository` implemented, you can now develop the `TokenService`,
    as shown in [Example 8-9](#token_service).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了`TokenRepository`之后，您现在可以开发`TokenService`，如[示例 8-9](#token_service)所示。
- en: Example 8-9\. Implement a token service by inheriting the token repository
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-9\. 通过继承令牌仓库实现令牌服务
- en: '[PRE9]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO5-1)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_authentication_and_authorization_CO5-1]'
- en: Implement a `TokenService` for issuing and checking authentication tokens. Configurations
    are shared across all instances of the service.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个`TokenService`以发行和检查身份验证令牌。配置在服务的所有实例之间共享。
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO5-2)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_authentication_and_authorization_CO5-2]'
- en: Generate access tokens based on data provided to the token service with expiry
    dates.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 根据提供给令牌服务的提供的数据生成带有过期日期的访问令牌。
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO5-3)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_authentication_and_authorization_CO5-3]'
- en: Create a token record in the database and get a unique identifier.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中创建一个令牌记录并获取一个唯一的标识符。
- en: '[![4](assets/4.png)](#co_authentication_and_authorization_CO5-4)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_authentication_and_authorization_CO5-4]'
- en: The access token must expire within an hour, so the `exp` calculated field will
    be used to check token validity.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌必须在小时内过期，因此将使用计算字段`exp`来检查令牌的有效性。
- en: '[![5](assets/5.png)](#co_authentication_and_authorization_CO5-5)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)[#co_authentication_and_authorization_CO5-5]'
- en: Encode the generated token into an encoded string using the `base64` algorithm.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`base64`算法将生成的令牌编码为编码字符串。
- en: Now that you have a `PasswordService` and a `TokenService`, you can complete
    the core JWT authentication mechanism with a dedicated higher-level `AuthService`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了`PasswordService`和`TokenService`，您可以使用专门的更高层次的`AuthService`来完成核心JWT身份验证机制。
- en: '[Example 8-10](#auth_service) shows the implementation of the `AuthService`
    class that contains several dependency functions for registering users, issuing
    access tokens, and protecting your API routes.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-10](#auth_service)显示了包含用于注册用户、发行访问令牌和保护API路由的几个依赖函数的`AuthService`类的实现。'
- en: Example 8-10\. Implement an auth service to handle higher-level authentication
    logic
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-10\. 实现一个处理高级身份验证逻辑的认证服务
- en: '[PRE10]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO6-1)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_authentication_and_authorization_CO6-1]'
- en: The core authentication logic of the application that verifies whether a user
    exists and their password credentials. Returns `False` if any checks fail.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的核心身份验证逻辑，验证用户是否存在以及他们的密码凭据。如果任何检查失败，则返回`False`。
- en: You can now use the `AuthService` to register and authenticate users using their
    credentials. Refer to [Example 8-11](#auth_controllers) to see how the `AuthService`
    is used to create the required dependencies for a dedicated authentication router.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用`AuthService`来使用其凭据注册和验证用户。参考[示例 8-11](#auth_controllers)以了解如何使用`AuthService`创建专用身份验证路由所需的相关依赖项。
- en: Example 8-11\. Implement authentication controllers to enable login and registration
    functionality
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-11\. 实现身份验证控制器以启用登录和注册功能
- en: '[PRE11]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO7-1)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_authentication_and_authorization_CO7-1]'
- en: Create an instance of the `AuthService` and declare reusable annotated dependencies.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`AuthService`的实例并声明可重用的注解依赖项。
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO7-2)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_authentication_and_authorization_CO7-2]'
- en: Create a separate API router for authentication endpoints.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为身份验证端点创建一个单独的API路由器。
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO7-3)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_authentication_and_authorization_CO7-3]'
- en: Implement endpoints for registering users, user login (token issuance), user
    logout (token revocation), and password reset.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 实现注册用户、用户登录（令牌发行）、用户注销（令牌撤销）和密码重置的端点。
- en: '[![4](assets/4.png)](#co_authentication_and_authorization_CO7-5)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_authentication_and_authorization_CO7-5]'
- en: Since the `LogoutUserDep` dependency won’t return anything, inject it within
    the dependency array of the router.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`LogoutUserDep`依赖项不会返回任何内容，因此请在路由器的依赖项数组中注入它。
- en: Once you have a dedicated authentication router, create a separate resource
    router to group all your resource endpoints within. With both routers, you can
    now add them to your FastAPI app, as shown in [Example 8-12](#routers), to complete
    the JWT authentication work.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有一个专门的认证路由器，创建一个单独的资源路由器来分组您所有的资源端点。有了这两个路由器，您现在可以将它们添加到您的FastAPI应用中，如[示例8-12](#routers)所示，以完成JWT身份验证工作。
- en: Example 8-12\. Refactor FastAPI application to use routers
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例8-12.重构FastAPI应用程序以使用路由器
- en: '[PRE12]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO8-1)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)(#co_authentication_and_authorization_CO8-1)'
- en: Refactor existing endpoints to be grouped under a separate API router named
    the resource router.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有端点重构为在名为资源路由器的单独API路由器下分组。
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO8-2)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)(#co_authentication_and_authorization_CO8-2)'
- en: Add both auth and resource routers to the FastAPI `app` router.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将认证和资源路由器添加到FastAPI的`app`路由器。
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO8-3)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)(#co_authentication_and_authorization_CO8-3)'
- en: Protect the resource endpoints by injecting the `AuthenticateUserDep` dependency
    at the router level. Requests must now include an `Authorization` header with
    a bearer token to be authenticated with the resource router.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在路由器级别注入`AuthenticateUserDep`依赖项来保护资源端点。现在，请求必须包含一个带有承载令牌的`Authorization`头才能通过资源路由器进行身份验证。
- en: Massive congratulations! You now have a fully working GenAI service protected
    by JWT authentication, which can be deployed to production with some additional
    work.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 热烈祝贺！您现在拥有了一个完全工作的GenAI服务，该服务由JWT身份验证保护，并且可以通过一些额外的工作部署到生产环境中。
- en: In the next section, you’ll learn a few ideas on additional enhancements you
    can make to the system to tighten the security of your JWT authentication system.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解一些关于如何增强系统以加强JWT身份验证系统安全性的想法。
- en: Authentication flows
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 身份验证流程
- en: You will need to handle several authentication flows to fully implement a usable
    JWT authentication system.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要处理几个身份验证流程，才能完全实现一个可用的JWT身份验证系统。
- en: 'The *core* authentication flows include the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*核心*身份验证流程包括以下内容：'
- en: User registration
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 用户注册
- en: New users will want to register a new account by providing their emails and
    a secure password. Your authentication logic may check for password strength,
    no existing users with the same email, and that the user reconfirms the password
    and email. You should also avoid storing the user’s raw password in the database.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 新用户将通过提供他们的电子邮件和一个安全的密码来注册一个新账户。您的身份验证逻辑可能会检查密码强度、没有与相同电子邮件地址存在的现有用户，以及用户重新确认密码和电子邮件。您还应该避免在数据库中存储用户的原始密码。
- en: User login
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 用户登录
- en: On each user login, your system can generate, store, and provide a unique temporary
    access token (i.e., JWT) if a user supplies their correct credentials. Your protected
    resource server routers should reject any incoming requests that don’t contain
    a valid JWT. Valid JWTs can be verified through their signature and checked against
    the valid tokens specified in the database.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个用户登录时，如果用户提供了正确的凭据，您的系统可以生成、存储并提供一个唯一的临时访问令牌（即JWT）。您的受保护资源服务器路由器应拒绝任何不包含有效JWT的传入请求。有效的JWT可以通过其签名进行验证，并与数据库中指定的有效令牌进行核对。
- en: User logout
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 用户注销
- en: When the user logs out, your system can revoke the currently issued token and
    prevent future malicious login attempts with the current token.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户注销时，您的系统可以吊销当前颁发的令牌，并防止使用当前令牌进行未来的恶意登录尝试。
- en: 'In addition to the core flows, you should also consider *secondary* flows to
    implement a production-ready authentication system. These flows could be used
    for:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 除了核心流程之外，您还应该考虑*次要*流程来实现一个生产就绪的身份验证系统。这些流程可以用于：
- en: Verifying identity
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 验证身份
- en: To prevent spambots from registering active accounts in your system and consuming
    server resources, you will want some form of user verification mechanism in place.
    For instance, add email verification by integrating an emailing server to your
    authentication system.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止垃圾邮件机器人注册您的系统中的活动账户并消耗服务器资源，您将需要在系统中实施某种用户验证机制。例如，通过将电子邮件服务器集成到您的身份验证系统中添加电子邮件验证。
- en: Resetting passwords
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 重置密码
- en: Users can forget their passwords at any time. You will want to implement a flow
    for users to reset their passwords. If a user resets their password, all active
    tokens in the database against their user account must be revoked.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 用户随时可能忘记他们的密码。您将希望实现一个流程，让用户可以重置他们的密码。如果用户重置了密码，数据库中针对其用户账户的所有活动令牌都必须被吊销。
- en: Forcing logout
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 强制注销
- en: Revoke all previously generated access tokens of a user on all clients to prevent
    stolen tokens from being used to access the system.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有客户端中撤销用户的先前生成的所有访问令牌，以防止被盗令牌被用于访问系统。
- en: Disabling user accounts
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用用户账户
- en: Administrators or users may want to disable their accounts to prevent future
    login attempts.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员或用户可能希望禁用他们的账户以防止未来的登录尝试。
- en: Deleting user accounts
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 删除用户账户
- en: This is required if users would like to remove their accounts from your systems.
    Depending on your data storage requirements, you may want to delete personally
    identifiable information while keeping other associated data.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户希望从您的系统中删除他们的账户，这是必需的。根据您的数据存储需求，您可能希望在保留其他相关数据的同时删除个人身份信息。
- en: Blocking successive login attempts
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止连续登录尝试
- en: Temporarily disable an account that has had multiple failed login attempts within
    a short time span.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在短时间内多次失败登录尝试的账户暂时禁用。
- en: Providing refresh tokens
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 提供刷新令牌
- en: Generate both short-lived *access* tokens and long-lived *refresh* tokens. Since
    access tokens can expire frequently to reduce the window of opportunity for attackers
    to use a stolen token, clients can reuse their refresh token to request new access
    tokens. This removes the need for frequent logins while maintaining security of
    the system against attackers.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 生成短期*访问*令牌和长期*刷新*令牌。由于访问令牌可以频繁过期以减少攻击者使用被盗令牌的机会，客户端可以重复使用他们的刷新令牌来请求新的访问令牌。这消除了频繁登录的需求，同时保持系统对攻击者的安全性。
- en: Two-factor authentication (2FA) or multifactor authentication (MFA)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 双因素认证（2FA）或多重因素认证（MFA）
- en: You can secure your system against exposed password-protected accounts by requiring
    2FA or MFA as an additional protection layer. 2FA/MFA examples include SMS/email
    verification, one-time passwords (OTPs), or randomly generated number sequences
    from a paired authentication app as a second login step before an access token
    can be generated.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过要求使用2FA或MFA作为额外的保护层来保护您的系统免受暴露的密码保护账户的影响。2FA/MFA示例包括短信/电子邮件验证、一次性密码（OTPs）或从配对的身份验证应用程序中随机生成的数字序列，作为在生成访问令牌之前的第二个登录步骤。
- en: Warning
  id: totrans-269
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The aforementioned list is not exhaustive. You may want to check out [“OWASP
    Top 10 Web Applications Security Risks”](https://oreil.ly/xAGfn) and [“OWASP Authentication
    Cheat Sheet”](https://oreil.ly/oSyuz) for the full list of considerations when
    implementing your own JWT authentication from scratch.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表并不全面。您可能想查看[“OWASP Top 10 Web Applications Security Risks”](https://oreil.ly/xAGfn)和[“OWASP
    Authentication Cheat Sheet”](https://oreil.ly/oSyuz)，以获取在从头开始实现自己的JWT身份验证时需要考虑的完整列表。
- en: In addition to following the OWASP top 10 guidelines, you should use security
    mechanisms such as *rate limiting*, *geo/IP-tracking*, and *account lockouts*
    to defend against various attacks.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 除了遵循OWASP顶级10指南外，您还应该使用诸如*速率限制*、*地理/IP跟踪*和*账户锁定*等安全机制来防御各种攻击。
- en: You can also consider using third-party authentication providers (such as Okta/Auth0,
    Firebase Auth, KeyCloak, Amazon Cognito, etc.) that include these security features
    in their services.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以考虑使用包含这些安全功能的服务第三方身份验证提供者（如Okta/Auth0、Firebase Auth、KeyCloak、Amazon Cognito等）。
- en: While credentials-based authentication using JWTs can be considered a production-ready
    authentication system and be further enhanced with MFA systems in place, the mechanism
    has its own limitations. For instance, as previously mentioned, requiring credentials
    and storing hashed passwords in a database can retain security risks if attackers
    leverage password spraying or credential stuffing brute-force attacks.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基于JWT的基于凭证的认证可以被认为是一个生产就绪的认证系统，并且可以通过实施MFA系统进一步增强，但这种机制有其自身的局限性。例如，如前所述，要求凭证和在数据库中存储散列密码可能会保留安全风险，如果攻击者利用密码喷射或凭证填充暴力攻击。
- en: In addition, if you require access to user resources external to your system,
    you will need to implement additional mechanisms to verify your application’s
    identity to external identity providers. Since this remains a common need in many
    applications and services, a protocol called OAuth has been developed to facilitate
    the whole process.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您需要访问系统外部的用户资源，您将需要实施额外的机制来验证您的应用程序身份以外部身份提供者。由于这在许多应用程序和服务中仍然是一个常见需求，因此已经开发了一个名为OAuth的协议来简化整个过程。
- en: Let’s explore how you can use OAuth authentication to add more login options
    for users and access external user resources. This can enhance the performance
    of your GenAI services and generate higher-quality outputs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨如何使用OAuth身份验证为用户提供更多登录选项并访问外部用户资源。这可以提高您的GenAI服务的性能并生成更高品质的输出。
- en: Implementing OAuth Authentication
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现OAuth身份验证
- en: We touched upon the concept of OAuth authentication via identity providers earlier
    in this chapter.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章 earlier 提到了通过身份提供者进行OAuth身份验证的概念。
- en: OAuth is an open standard for access delegation, often used to grant websites
    or applications limited access to user information without exposing passwords.
    It allows you to authenticate users using identity providers such as Google, Facebook,
    etc., and grants your application access to user resources like calendars, files,
    social feeds, etc., on external services.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth是一个开放标准，用于访问委派，通常用于在不暴露密码的情况下授予网站或应用程序对用户信息的有限访问。它允许您使用Google、Facebook等身份提供者进行用户身份验证，并授予您的应用程序访问外部服务上的用户资源（如日历、文件、社交动态等）的权限。
- en: By using OAuth, you can simplify the implementation of authentication in your
    app by leveraging existing identity providers instead of creating your own authentication
    mechanisms such as JWT.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用OAuth，您可以通过利用现有的身份提供者而不是创建自己的身份验证机制（如JWT）来简化您应用程序中身份验证的实现。
- en: '*Identity providers* (IDPs) are platforms that enable other applications, such
    as your GenAI service, to integrate with and rely on their identity and authentication
    systems to access resources on behalf of users via a standardized process. The
    IDP authenticates users and issues security tokens that assert the user’s identity
    and other attributes. GitHub, Google, Microsoft 365, Apple, Meta, and LinkedIn
    are only a handful of hundreds of identity providers.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份提供者**（IDP）是使其他应用程序（如您的GenAI服务）能够集成并依赖其身份和身份验证系统以代表用户通过标准化流程访问资源的平台。IDP验证用户并颁发安全令牌，这些令牌声明用户的身份和其他属性。GitHub、Google、Microsoft
    365、Apple、Meta和LinkedIn只是数百个身份提供者中的一小部分。'
- en: The protocol powering this entire flow under the hood is *OAuth 2.0*, an authorization
    framework giving applications limited access to another service on behalf of a
    user.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后推动整个流程的协议是**OAuth 2.0**，这是一个授权框架，允许应用程序代表用户有限地访问另一个服务。
- en: Using this approach, your application can redirect users to identity provider
    platforms so that users can grant limited timed access to their accounts on those
    platforms. After the user gives consent, your application can perform operations
    on their behalf on their resources like calendars or read their profile information
    including personally identifiable information such as emails or images.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，您的应用程序可以将用户重定向到身份提供者平台，以便用户可以授予对这些平台上账户的有限时间访问权限。在用户同意后，您的应用程序可以代表他们在日历等资源上执行操作或读取他们的个人资料信息，包括电子邮件或图像等个人信息。
- en: As a result, OAuth authentication is often used to verify the identity of users
    as you trust the external platform/identity provider’s authentication process.
    Therefore, this approach reduces the burden of storing and securing user credentials
    in your system, which can be prone to brute-force attacks on weak or compromised
    passwords.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，OAuth身份验证通常用于验证用户的身份，因为您信任外部平台/身份提供者的身份验证过程。因此，这种方法可以减少在您的系统中存储和确保用户凭证的负担，这可能会受到弱密码或受损密码的暴力攻击。
- en: 'In this section, you’re going to implement a variant of OAuth based on the
    *authorization code flow* that’s commonly used in modern applications. The step-by-step
    process is as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将实现一个基于现代应用程序中常用**授权码流**的OAuth变体。步骤如下：
- en: The user clicks the login button in your application to start the authentication
    flow.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户点击您应用程序中的登录按钮以启动身份验证流程。
- en: The user is redirected to the identity provider’s login page, and your application
    supplies a client ID and secret to the identity provider to identify itself.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户被重定向到身份提供者的登录页面，您的应用程序向身份提供者提供客户端ID和密钥以识别自身。
- en: The user logs into their account and is presented with a consent screen like
    the one shown in [Figure 8-7](#oauth2_consent_screen) presenting them the scopes
    (i.e., permissions) that your application is requesting on their behalf.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户登录到他们的账户，并显示一个类似于[图8-7](#oauth2_consent_screen)的同意屏幕，展示您的应用程序代表他们请求的权限（即，权限）。
- en: '![bgai 0807](assets/bgai_0807.png)'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![bgai 0807](assets/bgai_0807.png)'
- en: Figure 8-7\. Example consent screen
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-7\. 示例同意屏幕
- en: The user grants all, some, or none of the requested scopes.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户授予所有、部分或没有任何请求的权限范围。
- en: If consent is not rejected by the user (i.e., the resource owner), the identity
    provider’s authorization server issues your application a *grant code* to an endpoint
    that you provide called the *redirect URI*. If your redirect URI is not previously
    approved with the identity provider, the identity provider will reject to issue
    a grant code here.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户没有拒绝同意（即，资源所有者），身份提供者的授权服务器会向你的应用程序提供一个 *授权码* 到你提供的端点，称为 *重定向 URI*。如果你的重定向
    URI 之前没有被身份提供者批准，身份提供者将拒绝在此颁发授权码。
- en: After your application receives a grant code associated with the user session,
    permitted scopes, and your application’s client ID, it can exchange this grant
    code with the authorization server for a *short-lived access token* and a *longer-lived
    refresh token*. You can use the refresh token to request new access tokens without
    having to restart the whole authentication process.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的应用程序收到与用户会话、允许的权限范围和你的应用程序客户端 ID 相关的授权码后，它可以与授权服务器交换这个授权码，以获得一个 *短期访问令牌*
    和一个 *长期刷新令牌*。你可以使用刷新令牌来请求新的访问令牌，而无需重新启动整个认证过程。
- en: Your application can now use this access token to access the provider’s resource
    server to perform operations on behalf of the user on their resources. As a result,
    you can authenticate the user via the identity provider to resources on your system.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的应用程序现在可以使用这个访问令牌来访问提供者的资源服务器，代表用户在其资源上执行操作。因此，你可以通过身份提供者对你的系统上的资源进行用户认证。
- en: Tip
  id: totrans-294
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Through the OAuth process, the authorization server may also issue a *state*
    parameter or *CSRF token*, which your application must supply as it communicates
    with the identity provider’s servers. The purpose of the state parameter or CSRF
    token is to protect against cross-site request forgery (CSRF) attacks.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 OAuth 流程，授权服务器还可能颁发一个 *状态参数* 或 *CSRF 令牌*，你的应用程序在与身份提供者的服务器通信时必须提供。状态参数或 CSRF
    令牌的目的是为了防止跨站请求伪造 (CSRF) 攻击。
- en: With CSRF, attackers may steal an authenticated session to forge authenticated
    requests to the resource servers without the user’s knowledge.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CSRF 中，攻击者可能会窃取一个认证会话，以在用户不知情的情况下伪造对资源服务器的认证请求。
- en: '[Figure 8-8](#oauth2) shows the full OAuth authentication flow.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-8](#oauth2) 展示了完整的 OAuth 认证流程。'
- en: '![bgai 0808](assets/bgai_0808.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0808](assets/bgai_0808.png)'
- en: Figure 8-8\. OAuth authentication flow
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-8\. OAuth 认证流程
- en: Now that you have a high-level overview of the OAuth authentication flow, let’s
    implement it inside FastAPI with an identity provider such as GitHub to fully
    understand the underlying mechanisms.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对 OAuth 认证流程有了高层次的理解，让我们在 FastAPI 中使用 GitHub 这样的身份提供者来实现它，以便完全理解其底层机制。
- en: OAuth Authentication with GitHub
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GitHub 的 OAuth 认证
- en: The first step to setting up the OAuth authentication is to create a set of
    client ID and secret credentials within GitHub so that their systems can identify
    your application.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 OAuth 认证的第一步是在 GitHub 中创建一组客户端 ID 和密钥凭据，以便他们的系统可以识别你的应用程序。
- en: You can generate a client ID and secret from GitHub by visiting the developer
    settings under your GitHub profile and creating an OAuth application.^([5](ch08.html#id994))
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问 GitHub 个人资料下的开发者设置并创建 OAuth 应用来从 GitHub 生成客户端 ID 和密钥.^([5](ch08.html#id994))
- en: With your new application client ID and secret, you can now redirect users to
    the GitHub authorization server from your application by following [Example 8-13](#oauth_redirect).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你新的应用程序客户端 ID 和密钥，你现在可以通过你的应用程序重定向用户到 GitHub 授权服务器，按照 [示例 8-13](#oauth_redirect)
    进行操作。
- en: Example 8-13\. Redirect users to the GitHub authorization server to start the
    OAuth process
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-13\. 将用户重定向到 GitHub 授权服务器以启动 OAuth 流程
- en: '[PRE13]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO9-1)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_authentication_and_authorization_CO9-1)'
- en: Redirect user to the GitHub authorization server to log into their account while
    supplying your application credentials, a requested scope, and a CSRF state value
    to prevent against CSRF attacks.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户重定向到 GitHub 授权服务器以登录他们的账户，同时提供你的应用程序凭据、请求的权限范围和 CSRF 状态值，以防止 CSRF 攻击。
- en: As you can see in [Example 8-13](#oauth_redirect), the scope of the request
    is the user, meaning that once users log into their GitHub account, they will
    be presented with a consent screen for your application to be granted access to
    their user profile.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [示例 8-13](#oauth_redirect) 所示，请求的范围是用户，这意味着一旦用户登录他们的 GitHub 账户，他们就会看到一个同意屏幕，以便你的应用程序获得访问其用户资料的权限。
- en: Now that you have a backend endpoint redirecting requests to the GitHub authorization
    server, you can put a button in your client-side application to hit this endpoint
    and start the OAuth process with GitHub (see [Example 8-14](#oauth_client)).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个后端端点将请求重定向到 GitHub 授权服务器，你可以在客户端应用程序中添加一个按钮来调用此端点，并开始与 GitHub 的 OAuth
    流程（见 [示例 8-14](#oauth_client)）。
- en: Example 8-14\. Adding a GitHub login button to the Streamlit client-side application
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-14\. 将 GitHub 登录按钮添加到 Streamlit 客户端应用程序
- en: '[PRE14]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You now have implemented the redirect flow that starts the OAuth authentication
    process with GitHub as the identity provider.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经实现了以 GitHub 作为身份提供者的 OAuth 认证过程的重定向流程。
- en: When users log into their GitHub account, GitHub will show them a consent screen
    similar to [Figure 8-7](#oauth2_consent_screen).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录他们的 GitHub 账户时，GitHub 将显示一个类似于 [图 8-7](#oauth2_consent_screen) 的同意屏幕。
- en: If the user accepts the consent, GitHub will redirect the user back to your
    application with a grant code and a state. You should check whether the state
    matches the previously generated state.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户接受同意，GitHub 将带着授权代码和状态将用户重定向回你的应用程序。你应该检查状态是否与之前生成的状态匹配。
- en: Warning
  id: totrans-316
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If the states do not match, a third party has made the request, and you should
    stop the process.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态不匹配，第三方已发起请求，你应该停止该过程。
- en: Once you have the grant code, you can send this to the GitHub authorization
    to exchange it for an access token, as shown in [Example 8-15](#oauth_exchange).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了授权代码，你可以将其发送给 GitHub 授权以交换访问令牌，如 [示例 8-15](#oauth_exchange) 所示。
- en: Example 8-15\. Exchanging grant code with an access token while protecting against
    CSRF attacks
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-15\. 在防止 CSRF 攻击的同时交换授权代码和访问令牌
- en: '[PRE15]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can now add a new endpoint that accepts requests from the GitHub authorization
    server. This callback endpoint should have a CSRF protection to guard against
    third parties impersonating the authorization server. If the request from GitHub
    is forged, the state parameter provided and the one stored in the request session
    won’t match.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以添加一个新的端点，该端点接受来自 GitHub 授权服务器的请求。此回调端点应具有 CSRF 保护，以防止第三方冒充授权服务器。如果来自 GitHub
    的请求是伪造的，提供的状态参数和存储在请求会话中的状态将不匹配。
- en: '[Example 8-16](#oauth_callback) shows the callback endpoint implementation.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-16](#oauth_callback) 展示了回调端点的实现。'
- en: Example 8-16\. Implement callback endpoint to get access token while protecting
    against CSRF attacks
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-16\. 在防止 CSRF 攻击的同时实现回调端点以获取访问令牌
- en: '[PRE16]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In [Example 8-16](#oauth_callback), you are using the request session for CSRF
    protection, but this won’t work without adding the Starlette’s `SessionMiddlware`
    first to maintain a secure user session that’s only mutable on the server side,
    as shown in [Example 8-17](#oauth_session).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 8-16](#oauth_callback) 中，你正在使用请求会话进行 CSRF 保护，但如果不首先添加 Starlette 的 `SessionMiddleware`，则这不会起作用，以维护一个仅在服务器端可变的、安全的用户会话，如
    [示例 8-17](#oauth_session) 所示。
- en: Example 8-17\. Add a session middleware to manage session state for protecting
    against CSRF attacks
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-17\. 添加会话中间件以管理会话状态以防止 CSRF 攻击
- en: '[PRE17]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Warning
  id: totrans-328
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Avoid relying on HTTP *cookies* to store and read the `state` between request
    sessions as cookies can be read and manipulated by third parties. Never trust
    any data that comes from the client.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 避免依赖 HTTP **cookies** 来存储和读取请求会话之间的 `state`，因为 cookies 可以被第三方读取和操作。永远不要信任来自客户端的数据。
- en: By writing the unique `state` to the session in [Example 8-13](#oauth_redirect)
    and comparing it with the `state` value in the incoming request query parameters,
    you can then confirm the identity of the request.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 [示例 8-13](#oauth_redirect) 中将唯一的 `state` 写入会话，并将其与传入请求查询参数中的 `state` 值进行比较，你可以确认请求的身份。
- en: In this case, the requester is the GitHub authorization server sending you a
    grant `code`. Once you receive the grant `code`, you then exchange it with the
    GitHub authorization server for an access token.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，请求者是 GitHub 授权服务器，它向你发送一个授权 `code`。一旦你收到授权 `code`，你就可以将其与 GitHub 授权服务器交换以获取访问令牌。
- en: Tip
  id: totrans-332
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: The process shown in the OAuth-related code examples can also be implemented
    with the open source `authlib` package for simpler implementation, as the package
    handles most of the work for you.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OAuth 相关的代码示例中展示的过程也可以使用开源的 `authlib` 包来实现，以简化实现过程，因为这个包为你处理了大部分工作。
- en: Finally, you can use the access token you received from the authorization server
    to fetch user information such as their name, email, and profile image to register
    their identity in your application.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用从授权服务器收到的访问令牌来获取用户信息，例如他们的姓名、电子邮件和简介图片，以在应用程序中注册他们的身份。
- en: '[Example 8-18](#oauth_user_info) demonstrates how to implement an endpoint
    that returns the user info from GitHub if the request supplies an access token
    as part of the request’s authorization header.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-18](#oauth_user_info) 展示了如何实现一个端点，当请求包含在请求的授权头中的访问令牌时，从 GitHub 返回用户信息。'
- en: Warning
  id: totrans-336
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Ideally, you should avoid sharing the user’s GitHub access token with the user’s
    browser. If the token is stolen, your application is responsible for compromising
    the user’s GitHub account.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该避免将用户的 GitHub 访问令牌与用户的浏览器共享。如果令牌被盗，你的应用程序将负责损害用户的 GitHub 账户。
- en: Instead, create and share your own short-lived access token tied to the GitHub
    access token to authenticate the user with your application. If your application
    token is stolen, you avoid compromising user accounts beyond the scope of your
    application.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，创建并共享与 GitHub 访问令牌关联的短期访问令牌，以使用你的应用程序验证用户。如果你的应用程序令牌被盗，你将避免超出你应用程序范围的用户账户受到损害。
- en: Example 8-18\. Use access token to get user information from GitHub resource
    servers
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-18\. 使用访问令牌从 GitHub 资源服务器获取用户信息
- en: '[PRE18]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Congratulations! You should now have a working authentication system that leverages
    OAuth2 to authenticate users.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在应该已经拥有了一个利用 OAuth2 进行用户身份验证的工作认证系统。
- en: OAuth2 Flow Types
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth2 流程类型
- en: The OAuth2 flow that you just implemented was the *authorization code flow*
    (ACF). However, there are other flows that you can choose depending on the use
    case. The identity provider documentation may present you with solutions for various
    flows, which can feel overwhelming if you’re not aware of these use cases.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚实现的 OAuth2 流程是 *授权码流程*（ACF）。然而，根据不同的使用场景，你还可以选择其他流程。身份提供者文档可能会为你提供各种流程的解决方案，如果你不了解这些使用场景，可能会感到不知所措。
- en: Authorization code flow
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 授权码流程
- en: The authorization code flow is the common approach for applications that leverage
    servers and backend APIs such as FastAPI, using code grants to issue access tokens.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 授权码流程是使用服务器和后端 API（如 FastAPI）的应用程序的常见方法，使用代码授权来颁发访问令牌。
- en: A more secure variant of ACF leverages *proof key for exchange* (PKCE, pronounced
    “pixie”). You can use the ACF-PKCE flow where you cannot protect the authorization
    code from being stolen—for instance, on mobile devices.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ACF 的一个更安全的变体利用 *交换证明密钥*（PKCE，发音为“pixie”）。你可以在无法保护授权码不被窃取的情况下使用 ACF-PKCE 流程——例如，在移动设备上。
- en: During the ACF-PKCE flow, you add a hashed secret called the `code_challenge`
    when sending the initial request to the identity provider. Then you present the
    unhashed secret `code_verifier` again to exchange the authorization code for an
    access token.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ACF-PKCE 流程中，你会在向身份提供者发送初始请求时添加一个称为 `code_challenge` 的哈希密钥。然后你再次展示未哈希的密钥 `code_verifier`
    以交换授权码获取访问令牌。
- en: In essence, PKCE protects against *authorization code interception* attacks—shown
    in [Figure 8-10](#oauth_interception_attack)—by adding a layer of verification
    during the token exchange process.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，PKCE 通过在令牌交换过程中添加一层验证来防止 *授权码拦截* 攻击——如 [图 8-10](#oauth_interception_attack)
    所示。
- en: '![bgai 0810](assets/bgai_0810.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0810](assets/bgai_0810.png)'
- en: Figure 8-10\. OAuth2 authorization code interception attack on a mobile device
  id: totrans-350
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-10\. 移动设备上的 OAuth2 授权码拦截攻击
- en: Implicit flow
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式流程
- en: For single-page applications (SPAs) where there is no separate backend, you
    can also use the *implicit flow*, which skips the authorization grant code to
    directly get an access token. Implicit flow is less secure than the previous flow
    but enhances the user experience.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有独立后端的单页应用程序（SPAs），你也可以使用 *隐式流程*，该流程跳过授权码直接获取访问令牌。隐式流程比之前的流程安全性较低，但增强了用户体验。
- en: Client credentials flow
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端凭证流程
- en: If you’re building a backend service for machine-to-machine communication and
    where no browsers will be involved, then you can use the *client credentials flow*.
    Here you can exchange your client ID and secret for an access token to access
    your own resources on the identity provider servers (i.e., you won’t have access
    on behalf of other users).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建用于机器到机器通信的后端服务，并且没有浏览器参与，那么你可以使用*客户端凭证流*。在这里，你可以用你的客户端ID和密钥交换访问令牌，以访问身份提供者服务器上的资源（即，你不会代表其他用户访问）。
- en: Resource owner password credentials flow
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源所有者密码凭证流
- en: '*Resource owner password credentials flow* is like the client credentials flow
    but uses a username and password of the user to get an access token. As the credentials
    are being exchanged directly with the authorization server, you should avoid using
    this flow as much as possible.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*资源所有者密码凭证流*类似于客户端凭证流，但使用用户的用户名和密码来获取访问令牌。由于凭证是直接与授权服务器交换的，因此应尽可能避免使用此流。'
- en: Device authorization flow
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备授权流
- en: Finally, there is the *device authorization flow* that’s mostly used for devices
    with limited input capabilities, such as when you log into your Apple TV account
    on your smart TV by scanning a QR code and using a web browser from your phone.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有*设备授权流*，主要用于输入能力有限的设备，例如，当你通过扫描QR码并使用手机上的网络浏览器登录你的智能电视上的Apple TV账户时。
- en: '[Table 8-2](#oauth_flows_comparison) compares the various flows to help you
    select the right option for your own use case, based on your specific requirements
    and constraints.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '[表8-2](#oauth_flows_comparison)比较了各种流，以帮助您根据您特定的需求和限制选择适合您自己用例的正确选项。'
- en: Table 8-2\. Comparison of OAuth2 authorization flows
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-2\. OAuth2授权流比较
- en: '| Flow | Description | Considerations | Use cases |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| 流 | 描述 | 考虑因素 | 用例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Authorization code flow (including PKCE) | Get the authorization code via
    a user login and exchange for an access token. |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| 授权码流（包括PKCE） | 通过用户登录获取授权码，并交换以获取访问令牌。 |'
- en: Provider’s access token must be securely stored and never exposed to the browser.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者的访问令牌必须安全存储，并且永远不要暴露给浏览器。
- en: Use ACF-PKCE flow if possible for enhanced security.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能，使用ACF-PKCE流以增强安全性。
- en: '|'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Server-side applications and web applications with a backend server that can
    securely handle the client secret and access tokens.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端应用程序和具有后端服务器且可以安全处理客户端密钥和访问令牌的Web应用程序。
- en: Mobile applications if using a PKCE token as client credentials can’t be securely
    stored.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用PKCE令牌作为客户端凭证无法安全存储，则不适用于移动应用程序。
- en: '|'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Implicit flow | Get an access token without an authorization code. |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 隐式流 | 不使用授权码获取访问令牌。 |'
- en: Less secure as the access token is exposed to the browser.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性较低，因为访问令牌暴露给浏览器。
- en: Use when using the authorization code flow is not possible.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当无法使用授权码流时使用。
- en: '| Single-page applications (SPAs) where user experience is prioritized over
    security, when prototyping, or where the authorization code flow is not possible.
    |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 单页应用程序（SPA） | 当用户体验优先于安全性、原型设计或授权码流不可用时。 |'
- en: '| Client credentials flow | The client directly exchanges its client credentials
    (client ID and client secret) for an access token. | No user interaction involved,
    meant for scenarios where the client is acting on its own behalf. Ensure secure
    storage of client credentials. | Server-to-server applications. |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 客户端凭证流 | 客户端直接交换其客户端凭证（客户端ID和客户端密钥）以获取访问令牌。 | 不涉及用户交互，适用于客户端代表自身行动的场景。确保安全存储客户端凭证。
    | 服务器到服务器应用程序。 |'
- en: '| Resource owner password credentials flow | Exchange user’s username and password
    directly for an access token. |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| 资源所有者密码凭证流 | 直接交换用户的用户名和密码以获取访问令牌。 |'
- en: High security risk as user’s credentials are handled directly.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全风险高，因为用户的凭证是直接处理的。
- en: Only use in legacy systems where other flows are not supported.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在不支持其他流的传统系统中使用。
- en: '| Legacy applications or highly trusted environments. |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| 旧版应用程序或高度信任的环境。 |'
- en: '| Device authorization flow | Visit a URL on another device to enter a code
    for an access token. | Requires a second device with a web browser for the user
    to authenticate. | Devices with limited input capabilities, like smart TVs, gaming
    consoles, or IoT devices. |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| 设备授权流 | 访问另一台设备上的URL以输入代码以获取访问令牌。 | 需要一个带有网络浏览器的第二台设备供用户进行身份验证。 | 输入能力有限的设备，如智能电视、游戏机或物联网设备。
    |'
- en: You should now feel more confident in securing your application with a variety
    of commercial identity verification mechanisms, including the various OAuth2 flows
    that leverage external IDPs.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该更有信心使用各种商业身份验证机制来保护你的应用程序，包括利用外部IDP的各种OAuth2流程。
- en: Authentication forms the first step to securing your services by identifying
    who the users of your system are.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是识别你的系统用户并确保你的服务安全的第一步。
- en: 'A question remains: what should happen when a user is logged into your services?
    Can they fetch data, interact with models, and mutate resources as they please,
    or would you rather control their interactions in your services?'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一个问题：当用户登录到你的服务时，会发生什么？他们可以随意获取数据、与模型交互和修改资源，还是你更希望控制他们在服务中的交互？
- en: These are problems that an authorization system will tackle, which we will talk
    about next.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是授权系统将要解决的问题，我们将在下一节中讨论。
- en: Authorization
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: So far, we’ve been covering various authentication mechanisms including the
    basic, token-based (JWT), and OAuth2 for securing your applications.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在介绍各种认证机制，包括基本的、基于令牌的（JWT）和OAuth2，以保护你的应用程序。
- en: As mentioned earlier, authentication systems identify and verify actors, whereas
    the authorization systems enforce *permissions* in an application (i.e., who can
    do what on which resource).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，认证系统识别和验证行为者，而授权系统则在一个应用程序中执行*权限*（即谁可以在哪个资源上做什么）。
- en: 'In this section, you’re going to learn about the authorization system that
    takes into account the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解考虑以下内容的授权系统：
- en: The *actor* (i.e., the user or a third-party service acting on behalf of the
    user)
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*行为者*（即代表用户或第三方服务执行的用户）'
- en: The *action* being undertaken
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在进行的*动作*
- en: The impact of the action on *resources*
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动对*资源*的影响
- en: In essence, an authorization system can be compared to a function that accepts
    three inputs—*actor*, *action*, *resource*—and returns a *Boolean decision* to
    *allow* or *deny* a request. To implement the authorization function, you will
    require *authorization data* such as user attributes, relationships (like team/group/org
    memberships), resource ownership, roles, and permissions passed through a set
    of *abstract rules* to determine the Boolean allow/deny decisions.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，授权系统可以比作一个接受三个输入——*行为者*、*动作*、*资源*——并返回一个*布尔决策*以*允许*或*拒绝*请求的函数。要实现授权函数，你需要*授权数据*，例如用户属性、关系（如团队/组/组织成员资格）、资源所有权、角色和权限，通过一系列*抽象规则*来确定布尔允许/拒绝决策。
- en: Once a decision is made, you can *enforce* the authorization by either allowing
    actions (such as fetching or mutating resources) or denying requests (such as
    sending 403 Forbidden responses, redirecting users, hiding resources, locking
    accounts, etc.).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦做出决定，你可以通过允许操作（如获取或修改资源）或拒绝请求（如发送403禁止响应、重定向用户、隐藏资源、锁定账户等）来*执行*授权。
- en: On the surface level, implementing authorization can be simple. Using a few
    conditional statements, you can check whether a user has permissions to perform
    an action. However, this naive approach can get complex to manage as the number
    of places you need to implement authorization steps increases. This issue becomes
    worse as you make changes to the logic across the application, making the system
    complex and adding finer controls. You may end up duplicating logic or making
    future changes more difficult, and the authorization rules may deeply be interwoven
    in your application logic, making separation from the rest of the application
    more challenging.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在表面层面上，实现授权可能很简单。使用几个条件语句，你可以检查用户是否有权限执行某个操作。然而，随着你需要实施授权步骤的地方数量增加，这种简单的方法可能会变得难以管理。当你对应用程序中的逻辑进行更改时，这个问题会变得更糟，使系统变得复杂，并增加了更精细的控制。你可能会重复逻辑或使未来的更改更加困难，授权规则可能会深深地嵌入到你的应用程序逻辑中，使得与应用程序其他部分的分离变得更加具有挑战性。
- en: In such cases, authorization models can be useful to help you navigate the complexity
    of managing authorization decisions and enforcements in your applications.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，授权模型可以用来帮助你导航在应用程序中管理授权决策和执行复杂性。
- en: Authorization Models
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权模型
- en: 'There are a few common *authorization models* that you can learn to make structuring
    and implementing an authorization system easier:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种常见的*授权模型*你可以学习，以使构建和实现授权系统变得更加容易：
- en: Role-based access control (RBAC)
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 基于角色的访问控制（RBAC）
- en: Authorization is based on the roles assigned to users, where each role has specific
    permissions. For instance, administrators can access every available GenAI model,
    bypassing authorization rules enforced on users.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 授权是基于分配给用户的角色进行的，其中每个角色都有特定的权限。例如，管理员可以访问所有可用的 GenAI 模型，绕过对用户实施的授权规则。
- en: Relationship-based access control (ReBAC)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 基于关系的访问控制 (ReBAC)
- en: Authorization is determined by the relationships between entities, such as user-to-user
    (i.e., follower, friend, connection) or user-to-resource (i.e., group, team, org)
    relationships. For instance, this could authorize a user who is a member of a
    team to access premium models purchased by that team.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 授权是由实体之间的关系决定的，例如用户到用户（例如，关注者、朋友、联系）或用户到资源（例如，组、团队、组织）关系。例如，这可以授权一个团队成员访问该团队购买的付费模型。
- en: Attribute-based access control (ABAC)
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的访问控制 (ABAC)
- en: Authorization decisions are made based on attributes of users, resources, and
    the environment, allowing for fine-grained access control. For instance, a conversation
    with a *public* attribute is viewable by everyone, and a user with a *paid* attribute
    can access premium GenAI models.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 授权决策是基于用户、资源和环境的属性进行的，从而实现了细粒度的访问控制。例如，具有*公共*属性的对话可以被每个人查看，而具有*付费*属性的用户可以访问高级
    GenAI 模型。
- en: RBAC is the simplest authorization model but won’t provide the enhanced granular
    controls and flexibility of other authorization models. ABAC controls provide
    more fine-grained access control and can override both ReBAC and RBAC rules. Furthermore,
    ReBAC can also override or extend RBAC controls.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC 是最简单的授权模型，但不会提供其他授权模型提供的增强细粒度控制和灵活性。ABAC 控制提供了更细粒度的访问控制，并且可以覆盖 ReBAC 和
    RBAC 规则。此外，ReBAC 还可以覆盖或扩展 RBAC 控制。
- en: '[Table 8-4](#authorization_methods_comparison) compares the three authorization
    models.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-4](#authorization_methods_comparison) 比较了三种授权模型。'
- en: Table 8-4\. Comparison of authorization methods
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-4\. 授权方法比较
- en: '| Type | Benefits | Limitations | Use cases |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 优点 | 局限性 | 用例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Role-based (RBAC) | Simplifies management | Limited flexibility | Enterprise
    environments, access control, financial systems, healthcare systems |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| 基于角色的 (RBAC) | 简化管理 | 灵活性有限 | 企业环境、访问控制、金融系统、医疗系统 |'
- en: '| Relationship-based (ReBAC) | Fine-grained control | Needs relationship data
    from various sources with complex permission evaluations | Social networks, collaborative
    platforms, content-sharing applications, project management tools |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| 基于关系的 (ReBAC) | 细粒度控制 | 需要从各种来源获取关系数据，并进行复杂的权限评估 | 社交网络、协作平台、内容共享应用、项目管理工具
    |'
- en: '| Attribute-based (ABAC) | Highly flexible | Needs attribute data from various
    sources with complex permission evaluations | Dynamic environments, cloud services,
    IoT systems, regulatory compliance, personalized user experiences |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| 基于属性的 (ABAC) | 高度灵活 | 需要从各种来源获取属性数据，并进行复杂的权限评估 | 动态环境、云服务、物联网系统、法规遵从性、个性化用户体验
    |'
- en: These three authorization models also have a hierarchical relationship, as demonstrated
    in [Figure 8-11](#authorization_models).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种授权模型之间也存在层次关系，如[图 8-11](#authorization_models)所示。
- en: '![bgai 0811](assets/bgai_0811.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0811](assets/bgai_0811.png)'
- en: Figure 8-11\. Authorization models
  id: totrans-413
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-11\. 授权模型
- en: Let’s now discuss each authorization model in detail, starting with the RBAC
    model.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在详细讨论每种授权模型，从 RBAC 模型开始。
- en: Role-Based Access Control
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于角色的访问控制
- en: Using *roles* is a widely adopted model for implementing authorization in applications
    due to their simplicity.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其简单性，使用*角色*是实现应用程序授权的广泛采用模型。
- en: Roles are straightforward to understand. They normally correspond to whom the
    user is and what they want to do in the application. Sometimes authorization roles
    can directly map to roles in your organization’s hierarchy.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 角色易于理解。它们通常对应于用户在应用程序中的身份和他们想要做什么。有时授权角色可以直接映射到您组织层次结构中的角色。
- en: You can group permissions under a role that can then be *assigned* to users
    to grant user those permissions. A *permission* specifies the action that a user
    can take on resources, such as if the user can interact with the paid LLM model
    provided by your service.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在一个角色下分组权限，然后可以将这些权限*分配*给用户，以授予用户这些权限。*权限*指定用户可以在资源上执行的操作，例如用户是否可以与您服务提供的付费
    LLM 模型交互。
- en: For better administrative and user experience, you can create multiple roles
    with preset permissions to reduce decision fatigue when setting user permissions.
    Instead of having to set a vast number of permissions, you can assign a few predefined
    roles.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的管理者和用户体验，您可以创建多个具有预设权限的角色，以减少设置用户权限时的决策疲劳。您不必设置大量权限，而只需分配几个预定义的角色。
- en: A common starting point for many commercial services is user and administrator
    roles. While a member can access the core functionality of the application such
    as interacting with GenAI models, and reading and writing resources, they won’t
    be able to view data of other users or manage roles. On the other hand, administrators
    can assign and remove roles, view and mutate every resource, or disable and enable
    accounts. Administrators may also have access to early features such as GenAI
    models that normal users can’t access yet, as shown in [Figure 8-12](#rbac_example).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 许多商业服务的共同起点是用户和管理员角色。虽然成员可以访问应用程序的核心功能，例如与GenAI模型交互、读取和写入资源，但他们无法查看其他用户的数据或管理角色。另一方面，管理员可以分配和移除角色、查看和修改每个资源，或启用和禁用账户。管理员还可以访问早期功能，例如GenAI模型，这些功能普通用户目前还无法访问，如图[图8-12](#rbac_example)所示。
- en: '![bgai 0812](assets/bgai_0812.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0812](assets/bgai_0812.png)'
- en: Figure 8-12\. RBAC example where only administrators have access to image-based
    GenAI models
  id: totrans-422
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-12\. 只有管理员可以访问基于图像的GenAI模型的RBAC示例
- en: You can implement a simple RBAC authorization model to control the GenAI services
    that your users can access, as shown in [Example 8-19](#rbac).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以实施一个简单的RBAC授权模型来控制用户可以访问的GenAI服务，如图[示例8-19](#rbac)所示。
- en: Example 8-19\. Implementing RBAC using FastAPI dependencies
  id: totrans-424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例8-19\. 使用FastAPI依赖项实现RBAC
- en: '[PRE19]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_authentication_and_authorization_CO10-1)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_authentication_and_authorization_CO10-1]'
- en: Implement the `is_admin` authorization dependency guard on top of the `Auth​Ser⁠vice.get_current_user`
    dependency. Mark the function as `async` since the child dependency is performing
    an async operation against the database.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AuthService.get_current_user`依赖项之上实现`is_admin`授权依赖项保护。由于子依赖项正在对数据库执行异步操作，因此将函数标记为`async`。
- en: '[![2](assets/2.png)](#co_authentication_and_authorization_CO10-3)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_authentication_and_authorization_CO10-3]'
- en: Use the authorization guard dependency to deny access to the image generation
    service for nonadmin authenticated users.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 使用授权保护依赖项拒绝非管理员认证用户对图像生成服务的访问。
- en: '[![3](assets/3.png)](#co_authentication_and_authorization_CO10-2)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_authentication_and_authorization_CO10-2]'
- en: Nonadmin authenticated users can still access other resource controllers since
    the router is secured by an authentication guard dependency.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 非管理员认证用户仍然可以访问其他资源控制器，因为路由器由认证保护依赖项保护。
- en: Using the same logic shown in [Example 8-19](#rbac), you can construct varying
    system prompt templates or use different model variants fine-tuned to each role.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[示例8-19](#rbac)中显示的相同逻辑，您可以构建不同的系统提示模板或使用针对每个角色微调的不同模型变体。
- en: Warning
  id: totrans-433
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Bear in mind that implementing authorization at the application layer is more
    secure than delegating it to the GenAI model. LLMs and other GenAI models can
    be vulnerable to *prompt injection* attacks where an attacker manipulates the
    input to the model to bypass system instructions to produce unauthorized and harmful
    outputs.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在应用层实现授权比将其委托给GenAI模型更安全。LLM和其他GenAI模型可能容易受到*提示注入*攻击，攻击者通过操纵模型的输入来绕过系统指令，从而产生未经授权和有害的输出。
- en: Future versions of LLMs and other GenAI models may mitigate prompt injection
    risks by enforcing custom authorization rules internally using extensions like
    the *control neural network (ControlNet)* in Stable Diffusion models.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: LLM和其他GenAI模型的未来版本可能会通过使用扩展（如Stable Diffusion模型中的*控制神经网络（ControlNet）*）在内部强制执行自定义授权规则来减轻提示注入风险。
- en: To create more complex RBAC authorization logic than the one shown in [Example 8-19](#rbac),
    you can implement *subdependencies* or an *abstract dependency*. Both approaches
    will leverage FastAPI’s powerful *hierarchical dependency graphs* as authorization
    guards to enforce permissions in your GenAI service.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建比[示例8-19](#rbac)中显示的更复杂的RBAC授权逻辑，您可以实现*子依赖项*或*抽象依赖项*。这两种方法都将利用FastAPI强大的*分层依赖图*作为授权保护来强制执行您的GenAI服务中的权限。
- en: As an example, if you add new roles in the future that inherit a subset of permissions
    of another role (i.e., moderators and admins), then you can follow either of the
    approaches shown in [Figure 8-13](#complex_rbac_approaches).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您将来添加新的角色，这些角色继承另一个角色的部分权限（例如，版主和管理员），那么您可以遵循[图8-13](#complex_rbac_approaches)中显示的任何一种方法。
- en: '![bgai 0813](assets/bgai_0813.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0813](assets/bgai_0813.png)'
- en: Figure 8-13\. Approaches for implementing complex RBAC models
  id: totrans-439
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-13\. 实施复杂RBAC模型的方案
- en: You can implement complex RBAC authorization logic using abstract dependencies,
    as shown in [Example 8-20](#complex_rbac_abstract).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用抽象依赖来实现复杂RBAC授权逻辑，如[示例8-20](#complex_rbac_abstract)所示。
- en: Example 8-20\. Implementing complex RBAC authorization using abstract dependencies
  id: totrans-441
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例8-20\. 使用抽象依赖实现复杂RBAC授权
- en: '[PRE20]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In summary, RBAC simplifies permission management by assigning permissions to
    roles rather than individuals, making it easier to manage and audit. It is scalable
    and efficient for organizations with well-defined roles and responsibilities.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，RBAC通过将权限分配给角色而不是个人来简化权限管理，这使得管理和审计更加容易。对于具有明确角色和职责的组织，RBAC可扩展且高效。
- en: However, RBAC can lead to role explosion when many granular roles are necessary,
    making it hard to manage. It also lacks the flexibility to handle complex hierarchical
    relationships like teams and groups alongside setting dynamic permissions based
    on attributes like user preferences, time, and privacy settings, which limits
    its granularity compared to ReBAC or ABAC.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当需要许多细粒度角色时，RBAC可能导致角色爆炸，这使得管理变得困难。它还缺乏灵活性来处理像团队和组这样的复杂层次关系，同时根据用户偏好、时间和隐私设置等属性设置动态权限，这限制了其与ReBAC或ABAC相比的粒度。
- en: Relationship-Based Access Control
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于关系的访问控制
- en: '*Relationship-based access control* is an extension of RBAC with a focus on
    relationships between resources and users.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于关系的访问控制*是RBAC的扩展，侧重于资源和用户之间的关系。'
- en: With this mode, instead of just setting roles at the user level across the entire
    application, you must set roles and permissions at the resource level. This means
    you will have to confirm the actions each role can take on every resource type.
    For example, instead of assigning a “moderator” role to a user that grants access
    to all resources (i.e., conversations, teams, users, etc.), you would assign specific
    permissions to the moderator role for each resource. A moderator might have read
    and delete permissions on the conversation resource but only read permission on
    the team resource.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模式，您必须在资源级别设置角色和权限，而不是在整个应用程序的用户级别设置角色。这意味着您将不得不确认每个角色可以在每种资源类型上执行的操作。例如，您不会将“版主”角色分配给一个可以访问所有资源的用户（即，对话、团队、用户等），而是为每个资源分配特定的权限。版主可能对对话资源具有读取和删除权限，但对团队资源只有读取权限。
- en: This model allows you to create authorization policies based on hierarchical
    and nested structures within your data and be visualized as graphs where nodes
    can be represented as resources/identities and edges as relationships.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型允许您根据数据中的层次和嵌套结构创建授权策略，并将其可视化成图，其中节点可以表示为资源/身份，边表示为关系。
- en: Since you can create authorization rules based on relationships, this can save
    you lots of time setting permissions at an instance level. As an example, instead
    of sharing every private LLM conversation in your app one by one, you can group
    them under a team or a folder and share the folder or add members to the team
    instead. In ReBAC, children instances can inherit parent’s permissions, as shown
    in [Figure 8-14](#rebac_example). It’s the same for related instances if needed.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您可以根据关系创建授权规则，这可以节省您在实例级别设置权限的大量时间。例如，您不必逐个共享应用程序中的每个私有LLM对话，而是可以将它们分组到团队或文件夹中，然后共享文件夹或添加成员到团队。在ReBAC中，子实例可以继承父实例的权限，如[图8-14](#rebac_example)所示。如果需要，相关实例也是如此。
- en: '![bgai 0814](assets/bgai_0814.png)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0814](assets/bgai_0814.png)'
- en: Figure 8-14\. Example ReBAC where a user can see the team’s private conversations
    and threads
  id: totrans-451
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-14\. 用户可以看到团队私密对话和线程的示例ReBAC
- en: The example shown in [Figure 8-14](#rebac_example) demonstrates both organization
    and hierarchical relationships between users (i.e., teams and members) and resources
    (conversations and threads).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图8-14](#rebac_example)所示示例演示了用户（即团队和成员）与资源（对话和线程）之间的组织和层次关系。
- en: Tip
  id: totrans-453
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you decide to adopt the ReBAC model, I recommend visually mapping out the
    relationships between resources and identities in your application.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定采用ReBAC模型，我建议在应用程序中直观地映射资源与身份之间的关系。
- en: This work includes mapping out *policies* (i.e., rules), *resources* and available
    *actions* on them, *resource-level roles*, and *relationships* between entities.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这项工作包括绘制*策略*（即规则）、*资源*及其上可用的*操作*、*资源级别角色*以及实体之间的*关系*。
- en: A big problem that ReBAC solves by extending RBAC is the explosion of roles
    within the RBAC model by combining relationships with roles. It is ideal for managing
    permissions in complex hierarchical structures and allows for reverse queries,
    enabling efficient permission definitions using teams and groups. However, ReBAC
    can be complex to implement and maintain, resource-intensive, difficult to audit,
    and not as fine-grained as ABAC for dynamic permissions based on attributes like
    time or location.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ReBAC通过结合关系与角色扩展RBAC，解决了RBAC模型中角色爆炸的问题。它非常适合管理复杂层次结构中的权限，并允许进行反向查询，通过使用团队和组实现高效的权限定义。然而，ReBAC的实施和维护可能很复杂，资源密集，审计困难，并且对于基于属性（如时间或位置）的动态权限来说，不如ABAC细粒度。
- en: Attribute-Based Access Control
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于属性的访问控制
- en: '*Attribute-based access control* authorization model expands basic RBAC roles
    by setting access control rules based on *conditions applied to attributes* to
    implement more granular policies. As an example, ABAC can prevent users from uploading
    sensitive documents into your RAG-enabled services if the document contains *personally
    identifiable information (PII)* (i.e., `upload.has_pii=true`).'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于属性的访问控制*授权模型通过根据*应用于属性的*条件设置访问控制规则来扩展基本的RBAC角色，以实现更细粒度的策略。例如，ABAC可以防止用户将包含*个人可识别信息（PII）*（即`upload.has_pii=true`）的敏感文件上传到你的RAG启用服务。'
- en: Another example of ABAC can be seen in SaaS applications like ChatGPT where
    only paid users have access to the service’s premium GenAI models (see [Figure 8-15](#abac_example)).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: ABAC的另一个例子可以在SaaS应用程序（如ChatGPT）中看到，其中只有付费用户才能访问服务的付费GenAI模型（见[图8-15](#abac_example)）。
- en: '![bgai 0815](assets/bgai_0815.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0815](assets/bgai_0815.png)'
- en: Figure 8-15\. ABAC example where only paid users have access to premium GenAI
    models
  id: totrans-461
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-15\. 只有付费用户才能访问高级GenAI模型的ABAC示例
- en: Since the freedom to set policies based on attributes is infinite, the ABAC
    model allows for significantly fine-grained authorization policies. However, ABAC
    can be cumbersome for managing hierarchical structures, making it challenging
    to determine which users have access to a specific resource. For example, if you
    have a policy that grants access based on attributes like user role, data sensitivity
    level, and project membership, determining all users who can access a specific
    dataset requires evaluating these attributes for every user.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基于属性的设置策略的自由度是无限的，ABAC模型允许实现显著细粒度的授权策略。然而，ABAC在管理层次结构时可能会变得繁琐，这使得确定哪些用户可以访问特定资源变得具有挑战性。例如，如果你有一个基于用户角色、数据敏感级别和项目成员资格等属性授予访问权限的策略，确定所有可以访问特定数据集的用户需要评估每个用户的这些属性。
- en: While less complicated than ReBAC, ABAC can still be challenging to implement,
    in particular in large and complex applications that support a large number of
    roles, users, and attributes.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然比ReBAC简单，但ABAC在实现上仍然可能具有挑战性，尤其是在支持大量角色、用户和属性的大型且复杂的应用程序中。
- en: Hybrid Authorization Models
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合授权模型
- en: If you’ve worked with larger applications in the past, you will notice that
    they combine features of the RBAC, ReBAC, and ABAC authorization models. For instance,
    administrators may have access to any resource and user management/authentication
    features (RBAC), and users can share their private resources by setting visibility
    attribute to `public` (ABAC) and can add members to their team for collaborating
    on private resources.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前曾与大型应用程序合作过，你会注意到它们结合了RBAC、ReBAC和ABAC授权模型的功能。例如，管理员可能可以访问任何资源和管理/身份验证功能（RBAC），而用户可以通过将可见性属性设置为`public`（ABAC）来共享他们的私有资源，并且可以向他们的团队添加成员以协作处理私有资源。
- en: 'A hybrid approach combining RBAC, ReBAC, and ABAC models may give you the strengths
    of all the authorization models:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 结合RBAC、ReBAC和ABAC模型的混合方法可能会给你所有授权模型的优势：
- en: RBAC simplifies permission management by assigning roles to users, making it
    easy to manage and audit.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RBAC通过将角色分配给用户简化了权限管理，使得管理和审计变得容易。
- en: ReBAC is perfect for managing hierarchical relationships and reverse queries,
    making it suitable for complex hierarchical structures.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReBAC 适用于管理层次关系和反向查询，使其适合复杂的层次结构。
- en: ABAC provides fine-grained control based on user and resource attributes, allowing
    for dynamic and context-aware permissions.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ABAC 基于用户和资源属性提供细粒度控制，允许动态和上下文感知的权限。
- en: '[Figure 8-16](#authorization_hybrid) demonstrates the hybrid authorization
    model.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-16](#authorization_hybrid) 展示了混合授权模型。'
- en: '![bgai 0816](assets/bgai_0816.png)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0816](assets/bgai_0816.png)'
- en: Figure 8-16\. Hybrid authorization model based on roles, relationships, and
    attributes
  id: totrans-472
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-16\. 基于角色、关系和属性的混合授权模型
- en: To implement the hybrid authorization combining RBAC, ReBAC, and ABAC models,
    you can follow [Example 8-21](#rbac_rebac_abac).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现结合 RBAC、ReBAC 和 ABAC 模型的混合授权，您可以遵循 [示例 8-21](#rbac_rebac_abac)。
- en: Example 8-21\. Implementing the hybrid authorization model combining RBAC, ReBAC,
    and ABAC
  id: totrans-474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-21\. 实现 RBAC、ReBAC 和 ABAC 混合授权模型
- en: '[PRE21]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you define rules and permissions based on each authorization model, you also
    may decide to bypass rules if certain conditions are met. This can lead to complex
    logic and create a maintenance burden on your application code.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 根据每个授权模型定义规则和权限时，您也可能决定在满足某些条件的情况下绕过规则。这可能导致逻辑复杂，并在您的应用程序代码中增加维护负担。
- en: Since implementing a hybrid model can be complex, you may consider developing
    a separate authorization service to eliminate the need for significant code changes
    with volatile permissions that change frequently.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实现混合模型可能很复杂，您可能考虑开发一个独立的授权服务，以消除频繁变化的权限带来的重大代码更改需求。
- en: Using an external system for authorization decisions allows your application’s
    authorization logic to remain consistent, as shown in [Figure 8-17](#authz_separate).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外部系统进行授权决策可以使您的应用程序的授权逻辑保持一致，如图 8-17 所示。
- en: '![bgai 0817](assets/bgai_0817.png)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0817](assets/bgai_0817.png)'
- en: Figure 8-17\. Separating the authorization service from the GenAI service
  id: totrans-480
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-17\. 将授权服务与 GenAI 服务分离
- en: '[Example 8-22](#authorization_separate_example) shows how to develop a separate
    authorization system.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-22](#authorization_separate_example) 展示了如何开发一个独立的授权系统。'
- en: Example 8-22\. Using an authorization service with the GenAI service
  id: totrans-482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-22\. 使用 GenAI 服务与授权服务
- en: '[PRE22]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see in [Example 8-22](#authorization_separate_example), using an
    external system to authorize user actions on resources helps you and your team
    to modularize authorization logic with more complex and volatile permission requirements.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [示例 8-22](#authorization_separate_example) 所示，使用外部系统授权对资源进行用户操作可以帮助您和您的团队以更复杂和易变的权限要求模块化授权逻辑。
- en: However, since developing a complex external authorization service from scratch
    can take a lot of your time, you may want to consider using authorization providers
    (such as Oso, Permify, Okta/Auth0, etc.) with your authentication.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于从头开始开发复杂的外部授权服务需要大量时间，您可能希望考虑使用与您的认证一起使用的授权提供者（如 Oso、Permify、Okta/Auth0
    等）。
- en: Summary
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about both authentication and authorization mechanisms
    to secure your GenAI services.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了认证和授权机制，以保护您的 GenAI 服务。
- en: Earlier in the chapter, you were introduced to several authentication methods,
    including basic, token-based, OAuth, and key-based authentication. To gain hands-on
    experience, you implemented several authentication systems from scratch in your
    FastAPI service, which helped you understand the underlying mechanisms. This included
    managing user passwords, creating and using JWT access tokens, and implementing
    authentication flows for user verification. Additionally, you learned how to integrate
    your services with identity providers like GitHub using the OAuth2 standard to
    authenticate users and access external user resources in your application.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期，您已经接触到了几种认证方法，包括基本认证、基于令牌的认证、OAuth 和基于密钥的认证。为了获得实践经验，您在 FastAPI 服务中从头开始实现了几个认证系统，这有助于您理解底层机制。这包括管理用户密码、创建和使用
    JWT 访问令牌，以及实现用户验证的认证流程。此外，您还学习了如何使用 OAuth2 标准将您的服务与身份提供者（如 GitHub）集成，以对用户进行认证并访问应用程序中的外部用户资源。
- en: While you were building the authentication system, you also learned about attack
    vectors such as credential stuffing, password spraying, cross-site request forgery,
    open redirect, and phishing attacks.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建认证系统时，你也了解了诸如凭证填充、密码喷射、跨站请求伪造、开放重定向和钓鱼攻击等攻击向量。
- en: Furthermore, you explored authorization systems that determine and enforce access
    levels based on authorization data and logic. You learned how authorization systems
    can become complex and how different models, including RBAC, ReBAC, and ABAC,
    can assist in managing permissions in your applications.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还探索了基于授权数据和逻辑确定和执行访问级别的授权系统。你学习了授权系统如何变得复杂，以及包括RBAC、ReBAC和ABAC在内的不同模型如何帮助你管理应用程序中的权限。
- en: In the next chapter, you will focus on testing, including writing unit, integration,
    end-to-end, and regression tests. You’ll be introduced to concepts like testing
    boundaries, coverage, mocking, patching, parameterization, isolation, and idempotency,
    which will help you write maintainable and effective tests as your applications
    grow in complexity. Specifically, you’ll learn how to test GenAI services that
    use probabilistic models and interface with asynchronous systems.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将专注于测试，包括编写单元测试、集成测试、端到端测试和回归测试。你将介绍测试边界、覆盖率、模拟、修补、参数化、隔离和幂等性等概念，这些概念将帮助你编写可维护和有效的测试，随着你的应用程序复杂性的增长。具体来说，你将学习如何测试使用概率模型并与异步系统交互的GenAI服务。
- en: ^([1](ch08.html#id970-marker)) Open Worldwide Application Security Project is
    an online community that produces resources on system software and web application
    security.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.html#id970-marker)) Open Worldwide Application Security Project是一个在线社区，它提供关于系统软件和Web应用安全资源的制作。
- en: ^([2](ch08.html#id971-marker)) Key-based authentication won’t be discussed further
    as it involves complex cryptographic principles that are beyond the scope of this
    chapter.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch08.html#id971-marker)) 基于密钥的认证将不再进一步讨论，因为它涉及到超出本章范围的复杂加密原理。
- en: ^([3](ch08.html#id972-marker)) In a *timing attack*, attackers try to guess
    passwords by comparing and analyzing elapsed password evaluation times with the
    password length. Therefore, to prevent timing attacks, cryptographic algorithms
    must check passwords within a constant time span.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch08.html#id972-marker)) 在*时间攻击*中，攻击者通过比较和分析密码评估时间与密码长度来猜测密码。因此，为了防止时间攻击，加密算法必须在恒定的时间范围内检查密码。
- en: ^([4](ch08.html#id982-marker)) Typical salt lengths include 16 bytes (128 bits)
    for balancing performance and security, or 32 bytes (256 bits) for securing sensitive
    systems. You can use cryptographic libraries such as `passlib` to generate these
    salts correctly.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch08.html#id982-marker)) 常见的盐长度包括16字节（128位）以平衡性能和安全，或者32字节（256位）以保护敏感系统。你可以使用如`passlib`这样的加密库来正确生成这些盐。
- en: ^([5](ch08.html#id994-marker)) For up-to-date instructions, please visit [the
    GitHub documentation](https://oreil.ly/tWg6w).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch08.html#id994-marker)) 对于最新的说明，请访问[GitHub文档](https://oreil.ly/tWg6w)。
