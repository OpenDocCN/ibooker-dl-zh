- en: 12 Future directions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 未来方向
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using prompt patterns to write and explain code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用提示模式编写和解释代码
- en: Current limitations and future directions of generative AI tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成式AI工具的当前局限性和未来方向
- en: In this final chapter, we want to give you a glimpse of the creative ways people
    are currently using generative AI tools such as GitHub Copilot and ChatGPT. For
    example, it’s possible to make Copilot Chat ask you the questions, rather than
    the other way around. And it’s possible to make Copilot take on a different persona
    to be even more helpful to your current programming task. We’re going to keep
    this brief, and it’s not clear how much of this will become standard practice,
    but we want to take this opportunity to demonstrate the power of being creative
    with these new tools. We’ll also talk about some of the current limitations of
    generative AI tools (you’ve seen some of them already in this book!) and offer
    our thoughts on what may be next.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章的最后，我们希望让你一窥人们目前正在使用生成式AI工具（如GitHub Copilot和ChatGPT）的创造性方式。例如，可以使得Copilot
    Chat向你提问，而不是反过来。还可以让Copilot扮演不同的角色，以更好地帮助你完成当前的编程任务。我们将简要介绍，目前还不清楚这将成为多少标准做法，但我们想借此机会展示这些新工具的创造力。我们还将讨论一些生成式AI工具的当前局限性（你已经在本书中看到了一些！），并分享我们对未来可能性的看法。
- en: 12.1 Prompt patterns
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 提示模式
- en: Throughout the book, we’ve conveyed why programming directly in Python is a
    very different experience compared to programming using Copilot. Rather than writing
    code, our focus shifts to writing prompts and interacting with the generated code
    to determine whether or not it’s correct, and then fixing it if needed. But along
    with those differences, there are surprising similarities between coding without
    Copilot and coding with Copilot.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们阐述了为什么直接在Python中编程与使用Copilot编程相比有着非常不同的体验。我们关注的焦点不是编写代码，而是编写提示并与生成的代码交互，以确定其是否正确，并在需要时进行修复。但伴随着这些差异，没有Copilot的编码与有Copilot的编码之间也存在令人惊讶的相似之处。
- en: 'When programmers write code, they don’t start from scratch each time they write
    a new program. Researchers and programmers have created catalogs of design *patterns*,
    that is, general-purpose ways of organizing programs to make them easier to write,
    debug, and extend. The most famous such catalog is a book called *Design Patterns:
    Elements of Reusable Object-Oriented Software* [1], also known as the “Gang of
    Four book” because it was written by four authors. It requires familiarity with
    object-oriented programming, which we haven’t taught in this book, so we don’t
    recommend picking up that book quite yet. Just know that thousands of programmers
    have saved thousands of hours using the patterns in this book and not reinventing
    the wheel.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员编写代码时，他们不会每次编写新程序时都从头开始。研究人员和程序员已经创建了设计**模式**的目录，即组织程序以使其更容易编写、调试和扩展的通用方法。最著名的此类目录是一本名为《设计模式：可重用面向对象软件元素》的书[1]，也被称为“四人帮”书，因为它是由四位作者共同撰写的。它需要熟悉面向对象编程，而我们在这本书中没有教授，所以我们不建议你马上拿起那本书。只需知道，成千上万的程序员已经通过使用这本书中的模式节省了数千小时，而没有重新发明轮子。
- en: 'As just one example of a design pattern, suppose that you’re writing a computer
    game where a human player plays against the computer. You want to implement several
    AI opponents of varying difficulties (e.g., beginner, intermediate, advanced,
    and expert) to provide different skill levels of opponents for the human. Each
    AI opponent will have its own code for determining its behavior. It would be possible
    to use `if` conditions to determine what the AI opponent should do:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以设计模式的一个例子来说明，假设你正在编写一个电脑游戏，其中人类玩家与电脑对战。你希望实现几个不同难度（例如，初学者、中级、高级和专家）的AI对手，为人类提供不同技能水平的对手。每个AI对手都将有自己的代码来决定其行为。使用`if`条件确定AI对手应该做什么是可能的：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The downside to doing it that way, though, is organizational. We’d have all
    the AI code for the various AI opponents in the same place. We know from what
    we’ve learned in this book that huge functions like that aren’t easy to design
    and test.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但那样做的缺点是组织上的。我们会把所有AI代码放在同一个地方。我们从这本书中学到的知识告诉我们，像那样的大型函数不容易设计和测试。
- en: The clean way to organize this kind of program is using a pattern called the
    *strategy pattern*. We’re not going to go into details of that pattern here, but
    the important thing is that people have documented this pattern [1] for others
    to use. The pattern documentation tells you its intent (purpose), motivation for
    why we would use it, the structure of the code needed to implement it, and example
    code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 组织这类程序的干净方式是使用一种称为*策略模式*的模式。我们不会在这里详细介绍该模式，但重要的是，人们已经为他人使用记录了这种模式[1]。模式文档会告诉你其意图（目的）、我们为什么要使用它的动机、实现它所需的代码结构以及示例代码。
- en: Researchers are beginning to catalog patterns that can be used with generative
    AI tools like GitHub Copilot and ChatGPT [2]. They’re called *prompt patterns*,
    and similar to design patterns, they tell you how to construct a prompt to achieve
    a desired goal. The documentation for each of these patterns is similar to the
    documentation for design patterns, but rather than example code, we get example
    prompts that we can use.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员开始整理可用于GitHub Copilot和ChatGPT等生成AI工具的模式。它们被称为*提示模式*，类似于设计模式，它们告诉你如何构建一个提示以实现一个期望的目标。每个这些模式的文档与设计模式的文档类似，但与示例代码不同，我们得到的是我们可以使用的示例提示。
- en: 'In this book, we’ve spent most of our time on two types of AI responses: generating
    code (by pressing Tab in VS Code) and explaining code (by using Copilot Chat).
    The new prompt patterns that are emerging can help generative AI tools go beyond
    these to help with other code-related tasks.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们大部分时间都在关注两种类型的AI响应：生成代码（通过在VS Code中按Tab键）和解释代码（通过使用Copilot Chat）。新兴的提示模式可以帮助生成AI工具超越这些，帮助处理其他与代码相关的任务。
- en: 'To give you a flavor of the state of the art in prompt patterns, we’ll sample
    a couple of them here. For many more, we encourage you to check the catalog of
    prompt patterns that we’ve used [2]. Be warned, though: we’re referring you to
    an academic paper, rather than a beginner’s guide because we’re not aware of any
    beginner’s guides at this time (this is still new stuff).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你了解提示模式的前沿状态，我们将在这里采样几个。对于更多，我们鼓励你查看我们使用的提示模式目录[2]。但请注意：我们正在引用一篇学术论文，而不是入门指南，因为我们目前不知道有任何入门指南（这还是新事物）。
- en: Copilot Chat may not engage in these prompt patterns
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Copilot Chat可能不会参与这些提示模式
- en: At the time of writing, Copilot Chat refuses to engage in some of the cataloged
    prompt patterns, claiming that they are unrelated to programming assistance. While
    some may be less specifically related to programming, they are all designed to
    help programmers. Unlike ChatGPT, Copilot has been designed to try to always stay
    squarely on the topic of programming. If you decide to explore the variety of
    patterns further, you may wish to do so using ChatGPT when your interaction with
    Copilot isn’t productive.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Copilot Chat拒绝参与一些已记录的提示模式，声称它们与编程辅助无关。虽然其中一些可能不太具体地与编程相关，但它们都是为了帮助程序员设计的。与ChatGPT不同，Copilot被设计成始终试图专注于编程主题。如果你决定进一步探索各种模式，你可能希望在无法与Copilot有效互动时使用ChatGPT。
- en: 12.1.1 Flipped interaction pattern
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 交互模式反转
- en: To this point, we’ve been the one requesting code and asking questions, and
    Copilot has been the one answering. But it’s possible to flip the script so that
    Copilot does the asking and we do the answering. This is called the *flipped interaction
    pattern*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直是请求代码和提问的人，而Copilot一直是回答的人。但我们可以反转脚本，让Copilot提问，我们回答。这被称为*交互模式反转*。
- en: 'The intent of this pattern is to help us interact with the AI when we don’t
    know what information it needs to perform a task. The motivation is that the AI
    may know what to ask us to get to its goal faster than if we provided incomplete
    or unhelpful information. The structure of our prompt will look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的目的是在我们不知道AI需要什么信息来完成任务时，帮助我们与之互动。动机是，AI可能知道如何更快地通过询问我们达到其目标，而不是如果我们提供不完整或不帮助的信息。我们的提示结构将看起来像这样：
- en: I would like you to ask me questions to achieve X. You should ask questions
    until we achieve this goal, where X is the goal we’d like to achieve.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你问我问题以达到X。你应该继续提问，直到我们达到这个目标，其中X是我们想要达到的目标。
- en: This structure isn’t meant to precisely dictate the prompt that we should use.
    Rather, it cues us to the key ideas that we need to convey in the prompt. Here,
    for example, the key ideas are that we want Copilot to ask the questions and that
    we don’t want it to stop until our goal has been achieved.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构并不是为了精确地规定我们应该使用的提示。相反，它提示我们需要在提示中传达的关键思想。例如，这里的关键思想是我们希望Copilot提问，并且我们希望它在我们达到目标之前不要停止。
- en: In chapter 3, we wrote a function to keep asking the user for a password until
    they typed a strong password. Suppose we weren’t sure how to design this function.
    We could ask Copilot to design it for us by providing a code prompt, but then
    it might make decisions that we don’t agree with. Instead, we can have Copilot
    ask us the questions. Let’s use Copilot Chat to do this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们编写了一个函数，不断询问用户输入密码，直到他们输入了一个强大的密码。假设我们不确定如何设计这个函数。我们可以通过提供代码提示让Copilot为我们设计它，但这样它可能会做出我们不认同的决定。相反，我们可以让Copilot提问。让我们使用Copilot
    Chat来做这件事。
- en: LPHumanI would like a Python function that keeps asking the user for a password
    until they provide a strong password. Ask me questions one at a time until you
    can write that Python function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman我想要一个Python函数，它会不断询问用户输入密码，直到他们提供了一个强大的密码。在你能写出那个Python函数之前，一次问我一个问题。
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Sure, I’d be happy to help
    you write a Python function that keeps asking the user for a strong password!
    Here are some questions to get started:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 当然，我很乐意帮助你编写一个不断询问用户输入强大密码的Python函数！以下是一些开始的问题：'
- en: What do you consider to be a strong password?
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为什么是一把强大的密码？
- en: Should the function have any input parameters?
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数应该有任何输入参数吗？
- en: What should the function return?
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数应该返回什么？
- en: Should the function have any side effects, such as printing messages to the
    console?
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数应该有任何副作用，比如打印消息到控制台吗？
- en: Should the function have any error handling, such as handling invalid input
    from the user?
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数应该有任何错误处理，比如处理用户无效的输入吗？
- en: Copilot failed to follow our instruction to “Ask me questions one at a time.”
    Let’s remind it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot未能遵循我们“一次问一个问题”的指示。让我们提醒它。
- en: LPHumanAsk me the questions one at a time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman一次问我一个问题。
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Sure, let’s start with the
    first question:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 当然，让我们从第一个问题开始：'
- en: What do you consider to be a strong password?
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为什么是一把强大的密码？
- en: Now we can start answering the questions. Copilot will use the answers to these
    questions to write the code for us.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始回答这些问题。Copilot将使用这些答案为我们编写代码。
- en: LPHumanThe password must have at least one uppercase character, at least one
    number, and at least one punctuation mark.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman密码必须至少包含一个大小写字母，至少一个数字和一个标点符号。
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Great, thanks for letting me
    know! Here’s the next question:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 很好，感谢你告诉我！接下来是下一个问题：'
- en: 2\. Should the function have any input parameters?
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 函数应该有任何输入参数吗？
- en: LPHumanI don’t know. What would they be used for?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman我不知道。它们会被用来做什么？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Input parameters are used to
    pass data into a function so that the function can perform some operation on that
    data. For example, if we want to write a function that adds two numbers together,
    we would need to pass those two numbers into the function as input parameters.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 输入参数用于将数据传递给函数，以便函数可以对数据进行某些操作。例如，如果我们想编写一个将两个数字相加的函数，我们需要将这两个数字作为输入参数传递给函数。'
- en: In the case of our password function, we might want to pass in some parameters
    that define the requirements for a strong password. For example, we might want
    to pass in the minimum length of the password, the required number of uppercase
    characters, the required number of numbers, and the required number of punctuation
    characters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的密码函数的情况下，我们可能想要传递一些参数来定义强大密码的要求。例如，我们可能想要传递密码的最小长度、所需的大小写字母数量、所需的数字数量和所需的标点符号数量。
- en: Alternatively, we could hard-code these requirements into the function itself,
    but using input parameters would make the function more flexible and reusable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将这些要求硬编码到函数本身中，但使用输入参数会使函数更加灵活和可重用。
- en: LPHumanPlease hard-code them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman请将它们硬编码。
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Sure, we can hard-code the
    password requirements into the function itself. Here’s the next question:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 当然，我们可以将密码要求硬编码到函数本身中。这是下一个问题：'
- en: 3\. What should the function return?
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 函数应该返回什么？
- en: LPHumanIt should return the user’s strong password.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman该函数应返回用户的强密码。
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Great, thanks for letting me
    know! Here’s the next question:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 很好，感谢你告诉我！这是下一个问题：'
- en: 4\. Should the function have any side effects, such as printing messages to
    the console?
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 函数是否应该有任何副作用，例如向控制台打印消息？
- en: We’ll stop here as we don’t think it’s interesting to read our full interaction.
    We continued our conversation with Copilot and answered questions 4 and 5, and
    Copilot had the information it needed to write the code we wanted. The code we
    ultimately received, after answering all five questions, is shown in the following
    listing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里停止，因为我们认为阅读完整的交互并不有趣。我们继续与Copilot交谈并回答了问题 4 和 5，Copilot拥有了编写我们想要的代码所需的信息。在回答了所有五个问题后，我们最终收到的代码如下所示。
- en: Listing 12.1 Function designed via the flipped interaction pattern
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.1 通过翻转交互模式设计的函数
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#1 There’s no way to make this True condition False!'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 没有办法使这个 True 条件变为 False！'
- en: '#2 If there’s no uppercase character in the password'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 如果密码中没有大写字母'
- en: '#3 If there’s no digit character in the password'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 如果密码中没有数字字符'
- en: '#4 If there’s no punctuation character in the password'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 如果密码中没有标点符号'
- en: '#5 This is how we get out of the “while True” loop.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 这就是我们退出“while True”循环的方法。'
- en: In our `while` loops to this point, we’ve always used a loop condition that
    we hope eventually becomes `False` (otherwise, we’d have an infinite loop). For
    example, we could imagine having a loop that says, in effect, “while the password
    is not valid.” But here, the code is using `while True`, and `True` is a condition
    that can never become `False`. There must be some other way out of the loop—and
    there is! We get out of the loop through a `return` statement when the password
    is valid. That is, instead of “while the password is not valid,” the logic here
    is “loop forever; if the password is valid, stop looping.” The `while True` form
    of `while` loops is a common alternative structure to the style that we’ve seen
    throughout the book.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的 `while` 循环中，我们始终使用一个我们希望最终变为 `False` 的循环条件（否则，我们会遇到无限循环）。例如，我们可以想象有一个循环，实际上说的是，“当密码无效时继续循环。”但在这里，代码使用的是
    `while True`，而 `True` 是一个永远不会变为 `False` 的条件。必须有一种其他方式退出循环——确实有！当密码有效时，我们通过 `return`
    语句退出循环。也就是说，这里的逻辑是“永远循环；如果密码有效，停止循环。”`while True` 形式的 `while` 循环是本书中看到的一种常见替代结构。
- en: This code does a good job of implementing our task. It starts with some `print`
    calls to tell the user the rules for strong passwords. It also tells the user
    what’s wrong with their password if, in fact, it isn’t strong. It keeps looping
    until the user enters a strong password. And, when we eventually have a strong
    password from the user, we return it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很好地实现了我们的任务。它开始时通过一些 `print` 调用来告诉用户强密码的规则。如果用户的密码实际上不强，它还会告诉用户密码有什么问题。它持续循环，直到用户输入一个强密码。当我们最终从用户那里得到一个强密码时，我们返回它。
- en: Now, we already knew how to write this function because of our work in chapter
    3\. And your Python knowledge by this point is sufficiently strong that you can
    cut to the chase and write the function signature for Copilot to write the code
    as we’ve been doing throughout the book. But for tasks with which you’re less
    familiar and may not know where to start, this flipped interaction pattern may
    help.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经知道了如何编写这个函数，因为我们已经在第 3 章的工作中做到了这一点。而且，到这一点，你的 Python 知识已经足够强大，你可以直接跳到编写函数签名，让
    Copilot 编写代码，就像我们在整本书中做的那样。但对于你不太熟悉且可能不知道从何开始的任务，这种翻转交互模式可能会有所帮助。
- en: 12.1.2 Persona pattern
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 个性模式
- en: 'The intent of this pattern is to have the AI take on a particular persona or
    point of view. Why would we ever be motivated to do this? Well, here’s an example:
    say you’re a student in an introductory Python programming course. Your instructor
    is using Copilot as part of the course, but they are disallowing some Python features
    that they feel detract from learning introductory Python. You could ask Copilot
    to take on the persona of that instructor and then help you check your code to
    find and, if necessary, remove any disallowed Python features. The structure of
    our prompt will look like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的目的是让 AI 扮演一个特定的角色或观点。我们为什么会想要这样做呢？好吧，这里有一个例子：假设你是一名入门级 Python 编程课程的学生。你的讲师正在课程中使用
    Copilot，但他们禁止了一些他们认为会妨碍入门级 Python 学习的 Python 特性。你可以要求 Copilot 扮演那个讲师的角色，然后帮助你检查代码，以找到并（如果需要）移除任何不允许的
    Python 特性。我们的提示结构将如下所示：
- en: From now on, act as persona X. Provide outputs that persona X would create.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，扮演角色 X。提供角色 X 会创建的输出。
- en: We’ll fill in X with a particular persona. Let’s try this with our introductory
    programming instructor persona. We’ll ask Copilot to play the part, disallowing
    a list of more advanced Python concepts. (Don’t worry if you’ve never heard of
    these!)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用特定的角色来填充 X。让我们尝试使用我们的入门级编程讲师角色。我们将要求 Copilot 扮演这个角色，禁止一系列更高级的 Python 概念。（如果你从未听说过这些，请不要担心！）
- en: 'LPHumanFrom now on, act as an introductory Python programming instructor. In
    the course that you’re teaching, the following Python features aren’t allowed:
    list comprehensions, generators, “lambda”, and the “any” function. I will provide
    code, and you’ll review the code for any Python features that aren’t allowed and
    suggest how to rewrite the code to not use those features.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman 从现在起，扮演一个入门级 Python 编程讲师的角色。在你教授的课程中，以下 Python 特性是不允许的：列表推导式、生成器、“lambda”以及“any”函数。我会提供代码，你需要检查代码中是否有不允许的
    Python 特性，并提出如何重写代码以避免使用这些特性。
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Sure, I can do that! Please
    provide the code you would like me to review.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 当然，我可以做到！请提供你希望我审查的代码。'
- en: Let’s feed it the `get_strong_password` function from the previous section.
    It uses the `any` function, and by our persona rules, that function isn’t allowed.
    Here’s our original code and what Copilot does in response.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给它提供上一节中的 `get_strong_password` 函数。它使用了 `any` 函数，根据我们的角色规则，这个函数是不允许的。以下是我们的原始代码以及
    Copilot 的响应。
- en: '**LPHuman**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**LPHuman**'
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot The `get_strong_password` function
    uses the `any` function, which is not allowed in your course. Here’s a modified
    version of the function that does not use the `any` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot `get_strong_password` 函数使用了
    `any` 函数，这在你的课程中是不允许的。下面是修改后的函数版本，它没有使用 `any` 函数：'
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 The loop that replaces “any”'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 替换“any”的循环'
- en: This version of the function uses a `for` loop to iterate over each character
    in the password and check if it meets the requirements. This approach is more
    verbose than using the `any` function, but it does not use the disallowed Python
    features.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的函数使用 `for` 循环遍历密码中的每个字符并检查它是否符合要求。这种方法比使用 `any` 函数更冗长，但它没有使用不允许的 Python
    特性。
- en: As Copilot Chat indicated, this program doesn’t use the `any` function. Copilot
    has rewritten the program to avoid that function, thereby following the rules
    set by our Python programming persona.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Copilot Chat 所示，这个程序没有使用 `any` 函数。Copilot 已经重写了程序以避免使用该函数，从而遵循了我们 Python 编程角色的规则。
- en: The `any` function returns `True` if one or more values in its argument are
    true, and `False` if all values in its argument are false. Behind the scenes,
    `any` must be looking at each value to check whether it’s true or false. Sounds
    like a loop, right? Indeed, a loop is exactly what Copilot has used here to replace
    the `any` function calls.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`any` 函数在其参数中有一个或多个值为真时返回 `True`，如果所有值都为假，则返回 `False`。在幕后，`any` 必须查看每个值以检查它是否为真或假。听起来像是一个循环，对吧？确实，Copilot
    就是用一个循环来替换这里的 `any` 函数调用的。'
- en: 12.2 Limitations and future directions
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 局限性和未来方向
- en: In our experience working with Copilot (and students) and reading the research
    literature published while we were writing this book, we’ve observed some limitations
    and future possibilities of generative AI models that we wanted to share.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们与 Copilot（以及学生）合作并阅读我们撰写本书期间发表的研究文献的过程中，我们观察到了一些生成式 AI 模型的局限性和未来可能性，我们希望与大家分享。
- en: 12.2.1 Where Copilot (currently) struggles
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 Copilot（目前）的挑战
- en: 'We found that Copilot struggles in three different types of scenarios: contrived
    problems, ill-defined problems, and large tasks.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现Copilot在三种不同类型的场景中存在挑战：虚构问题、不明确问题和大型任务。
- en: Contrived problems
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 虚构问题
- en: 'Shortly after ChatGPT and GitHub Copilot took the world by storm, programming
    instructors feverishly worked to find types of tasks that these tools couldn’t
    do well. One early proposal was to use contrived tasks: tasks made obscure and
    convoluted in an attempt to misdirect tools like Copilot to have them generate
    incorrect code. To us, such tasks seem wholly uninteresting and unfair to students,
    and their use seems to be a last-ditch attempt to retain the previous style of
    programming courses without acknowledging the disruption wrought by tools like
    Copilot. Our sense is that these contrived tasks will eventually be solved by
    Copilot as the models continue to improve, but even if they aren’t, these types
    of problems aren’t generally important to solve anyway.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在ChatGPT和GitHub Copilot风靡全球之后不久，编程教师们急忙寻找这些工具无法很好地完成的任务类型。一个早期的建议是使用虚构任务：通过使任务变得晦涩和复杂来试图误导像Copilot这样的工具生成错误的代码。对我们来说，这类任务似乎完全无趣，而且对学生来说也不公平，它们的用途似乎是一种最后的努力，试图在不承认Copilot等工具造成的破坏的情况下保留之前的编程课程风格。我们的感觉是，随着模型的持续改进，这些虚构任务最终会被Copilot解决，但即使它们没有被解决，这类问题通常也不是必须解决的。
- en: Ill-defined problems
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不明确的问题
- en: An ill-defined problem is a problem that hasn’t been precisely specified, meaning
    we don’t exactly know or haven’t decided what we should do in all cases. For example,
    asking Copilot for a function to determine whether a password is strong is ill-defined
    until we define what we mean by “strong password.” Your first thought may be that
    Copilot can’t possibly get better at solving these kinds of problems. After all,
    if we struggle to precisely specify the behavior we want, how are we going to
    communicate the required behavior to Copilot? Ill-defined problems are certainly
    challenging for Copilot, but they aren’t impossible. Remember the flipped interaction
    prompt pattern that we discussed earlier in the chapter? Perhaps, one day soon,
    Copilot will automatically switch into that mode when it doesn’t have enough precision
    from you to solve the problem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不明确的问题是指那些没有精确指定的问题，这意味着我们并不确切知道或在所有情况下都没有决定我们应该做什么。例如，向Copilot请求一个函数来决定密码是否强大，直到我们定义了“强密码”的含义，这个问题才是不明确的。你可能会想，Copilot不可能在这些类型的问题上变得更好。毕竟，如果我们难以精确指定我们想要的行为，我们如何将所需的行为传达给Copilot呢？不明确的问题对Copilot来说确实具有挑战性，但它们并不是不可能解决的。记得我们在本章前面讨论过的翻转交互提示模式吗？也许，不久的将来，Copilot会自动切换到那种模式，当你没有足够精确的信息来解决问题时。
- en: Large tasks
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 大型任务
- en: We’ve spent a lot of time throughout the book teaching you how to design small
    functions and how to organize those functions using top-down design to solve large
    problems. We did this because Copilot struggles when given a monolithic task to
    solve. Is this an inherent limitation of tools like Copilot, or can AI get past
    it? We don’t know. Right now, Copilot struggles with problem decomposition, and
    even if it could get that right, probabilities aren’t in its favor. Specifically,
    it has a higher probability of getting something wrong the more code it writes.
    For example, if it needs to write 20 functions to solve a task with each function
    averaging 10 lines, it’s almost certainly going to make a mistake somewhere. But
    it’s also foolish to bet against these systems. With advancements in how Copilot
    learns, perhaps this isn’t that far off after all.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整本书中花了大量时间教你如何设计小型函数，以及如何使用自顶向下的设计来组织这些函数以解决大型问题。我们这样做是因为当给Copilot一个单一的任务来解决时，Copilot会感到困难。这是像Copilot这样的工具的固有局限性，还是AI可以克服它？我们不知道。目前，Copilot在问题分解方面存在困难，即使它能够正确地做到这一点，概率也不利于它。具体来说，它编写代码越多，出错的可能性就越高。例如，如果它需要编写20个函数来解决一个任务，每个函数平均有10行代码，它几乎肯定会在某个地方犯错误。但反对这些系统也是不明智的。随着Copilot学习方式的进步，也许这一切并没有想象中那么遥远。
- en: 12.2.2 Is Copilot a new programming language?
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 Copilot是一种新的编程语言吗？
- en: When we write computer code in a language like Python, there’s a compiler behind
    the scenes converting the Python to an assembly code or machine code that the
    computer can understand. There was a time when programmers wrote code in an old
    computer language like Fortran or C, ran the compiler to produce code in assembly
    language, and then checked the assembly code to make sure it was correct. We weren’t
    around then, and it probably didn’t happen that much, but we can understand why
    programmers didn’t trust compilers back then. Compilers were a new technology,
    and it took time to work out the bugs. In addition, the code output from compilers
    was probably fairly inefficient compared to handwritten assembly. But after decades
    of improvements both to correctness and efficiency (compiler optimizations are
    a really exciting and interesting topic for anyone curious!), very few programmers
    ever look at the output of compilers. Could there be a point when humans simply
    use large language models (LLMs) as the primary interface to computers and don’t
    spend much time examining the code they produce? Let’s think about both possible
    answers to this question.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用Python这样的语言编写计算机代码时，背后有一个编译器将Python转换为计算机可以理解的汇编代码或机器代码。曾经有一段时间，程序员用Fortran或C这样的老式计算机语言编写代码，运行编译器生成汇编语言的代码，然后检查汇编代码以确保它是正确的。我们当时不在场，这可能没有发生很多，但我们能理解为什么当时的程序员不相信编译器。编译器是一种新技术，需要时间来修复错误。此外，编译器输出的代码可能比手写的汇编代码效率低。但是，经过几十年的改进，无论是在正确性还是效率上（编译器优化对任何好奇的人来说都是一个真正令人兴奋和有趣的话题！），很少有程序员会查看编译器的输出。有没有可能有一天，人类仅仅使用大型语言模型（LLMs）作为与计算机的主要接口，并且花很少的时间检查他们产生的代码？让我们思考这个问题的两种可能的答案。
- en: Why LLMs may not replace programming languages
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么大型语言模型（LLMs）可能不会取代编程语言
- en: There are reasons to think LLMs won’t become the primary interface for humans
    to program computers. The principle one is that LLMs aren’t a stringent programming
    language. We trust compilers because there’s a programming language specification
    for each programming language and there’s a specified, exact behavior expected
    from each line of code. LLMs don’t have this. It’s just someone writing English
    or another natural language to an LLM. The LLM isn’t bound to interpret the natural
    language in a particular way. It doesn’t have to output the answer based on any
    rigorous specification. And, randomness and nondeterminism make it so the answer
    it gives us could vary or be wrong! Compilers are deterministic and by now are
    a mature, trusted technology. They don’t face these problems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有理由相信LLMs不会成为人类编程计算机的主要接口。最主要的原因是LLMs不是一个严格的编程语言。我们信任编译器，因为每种编程语言都有一个规范，并且每行代码都有预期的确切行为。LLMs没有这个。这只是有人用英语或其他自然语言向LLM写作。LLM并不一定要以特定方式解释自然语言。它不需要根据任何严格的规范输出答案。而且，随机性和非确定性使得它给出的答案可能会变化或错误！编译器是确定性的，到目前为止，编译器是一种成熟、可信的技术。它们不面临这些问题。
- en: Why LLMs may replace programming languages
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么大型语言模型（LLMs）可能会取代编程语言
- en: There are also reasons to believe that, like compilers, LLMs will get better
    and become our primary programming interface. In fact, for data science, this
    is already starting to happen.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 也有理由相信，就像编译器一样，LLMs会变得更好，并成为我们的主要编程接口。事实上，对于数据科学来说，这已经开始发生了。
- en: 'As we’ve learned throughout the book, a key challenge to working with Copilot
    is determining whether the generated code is correct. In a sense, it isn’t fair
    to nonprogrammers: we give Copilot natural language (our preference), and it gives
    us back code that’s not in a natural language (the computer’s preference). It
    would be nice if we could “skip the code” and use natural language not only to
    communicate with Copilot but to receive our answer.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在整本书中学到的，与Copilot一起工作的一个关键挑战是确定生成的代码是否正确。从某种意义上说，这对非程序员来说并不公平：我们给Copilot自然语言（我们的偏好），而它给我们回的是非自然语言的代码（计算机的偏好）。如果能“跳过代码”，不仅用自然语言与Copilot沟通，还能得到我们的答案，那就太好了。
- en: Researchers are beginning to explore this possibility in restricted domains
    of interest to millions of computer users. As one example, let’s think about data
    science. Data scientists make sense of data by exploring the data, visualizing
    the data, and using data to make predictions. Much of what they do involves manipulating
    data in constrained, well-understood ways, such as merging spreadsheets, cleaning
    particular columns of data, or conducting analyses such as clustering the data
    into meaningful categories or simplifying data to focus only on its core underlying
    structure. Data scientists who use Python use many libraries to work with their
    data, but one extremely popular library is called pandas.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员开始探索在数百万计算机用户感兴趣的受限领域内这一可能性。以数据科学为例，数据科学家通过探索数据、可视化数据和使用数据来做出预测来理解数据。他们所做的大部分工作都涉及以约束和易于理解的方式操作数据，例如合并电子表格、清理特定列的数据或进行诸如将数据聚类到有意义的类别或简化数据以仅关注其核心基础结构的分析。使用
    Python 的数据科学家使用许多库来处理他们的数据，但一个极其流行的库叫做 pandas。
- en: 'Researchers have successfully “skipped the code” in this context of doing data
    science with pandas [3]. Here’s how it works:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员已经在这个使用 pandas 进行数据科学的环境中“跳过了代码”[3]。以下是它是如何工作的：
- en: The user expresses their intent in a natural language such as English.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户以自然语言（如英语）表达他们的意图。
- en: The AI generates Python code and runs it to get the result (e.g., a table of
    results for an analysis or a new spreadsheet) for the user. Importantly, the user
    doesn’t see this Python code.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 人工智能生成 Python 代码并运行以获取结果（例如，分析结果表格或新的电子表格）供用户使用。重要的是，用户看不到这段 Python 代码。
- en: 'The AI converts the code back to natural language and presents that (not the
    Python code!) back to the user. The natural language that the user gets back is
    in a consistent format that can be reliably interpreted by the AI. The researchers
    describe the purpose of the response from the AI like this: “This is how you should
    ask the system to do what the system thinks you just asked it to do.” The response
    helps the user understand the capabilities of the AI and the types of queries
    that are effective.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 人工智能将代码转换回自然语言，并将转换后的内容（而不是 Python 代码！）呈现给用户。用户收到的自然语言格式一致，可以被人工智能可靠地解释。研究人员这样描述人工智能响应的目的：“这就是你应该向系统提出你刚刚要求系统做的事情。”这个响应有助于用户了解人工智能的能力和有效的查询类型。
- en: The user can edit the natural language from step 3 if it’s not correct. If the
    user makes an edit, they can submit the new prompt, which repeats the cycle.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第 3 步的自然语言不正确，用户可以编辑。如果用户进行了编辑，他们可以提交新的提示，这会重复循环。
- en: 'An example provided by the researchers clarifies this process [3]. Suppose
    we have a spreadsheet with one astronaut per row. Each row has three relevant
    columns: the astronaut’s name, their total time in space, and a comma-separated
    list of missions that they participated in. We want to calculate the average mission
    length for each astronaut.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员提供的一个例子阐明了这个过程[3]。假设我们有一个电子表格，每行代表一名宇航员。每行有三个相关列：宇航员的名字、他们在太空中的总时间以及他们参与的以逗号分隔的任务列表。我们希望计算每位宇航员的平均任务长度。
- en: 'In step 1, the user writes a prompt like “calculate average mission length.”
    In step 2, the AI generates code corresponding to that prompt. It runs the code
    and adds a new column to the user’s spreadsheet containing the average mission
    length. In step 3, the AI converts the code to a list of tasks in natural language,
    such as the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，用户编写一个提示，如“计算平均任务长度”。在第 2 步中，人工智能生成与该提示相对应的代码。它运行代码，并在用户的电子表格中添加一个包含平均任务长度的新的列。在第
    3 步中，人工智能将代码转换为自然语言任务列表，如下所示：
- en: Create column “Mission Length.”
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建“任务长度”列。
- en: Column “Space Flight(hr)” divided by (count “,” from column “Missions” + 1).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “太空飞行时间（小时）”列除以（从“任务”列中“，”的数量加 1）。
- en: In step 4, the user can edit the natural language from step 3 and resubmit the
    updated tasks to the AI. Might we be able to “skip the code” in the far broader
    area of “Python programming” rather than the more restricted setting of “data
    science with pandas”? It’s too early to tell. Data manipulation has the benefit
    of working in a visual medium, with spreadsheets and graphs that can be directly
    presented to the user, who may be able to discern whether the analysis looks correct
    or if further prompt engineering is needed. Such visual representations aren’t
    readily apparent for general-purpose programming.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，用户可以编辑第3步的自然语言，并将更新后的任务重新提交给AI。我们是否能够在“Python编程”这个更广泛的领域“跳过代码”，而不是在“使用pandas的数据科学”这个更受限的环境中呢？现在还言之过早。数据处理的好处在于可以在视觉媒介中工作，使用电子表格和图表可以直接展示给用户，用户可能能够判断分析是否正确，或者是否需要进一步的提示工程。这样的视觉表示对于通用编程来说并不明显。
- en: Still, we can imagine a new era where humans continue to perform important tasks
    like problem decomposition, specifying program behavior, writing tests, designing
    algorithms, and so on but where the programming of functions is entirely done
    using LLMs. The human tells the AI tool what the program is required to do and
    provides the test cases, and the AI generates the code. The human can then check
    that the program works properly without ever needing to see the code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们可以想象一个新时代，在这个时代，人类继续执行重要的任务，如问题分解、指定程序行为、编写测试、设计算法等，但函数编程完全由LLM（大型语言模型）完成。人类告诉AI工具程序需要做什么，并提供测试用例，然后AI生成代码。人类可以检查程序是否正常工作，而无需查看代码。
- en: 'For another take on whether LLMs will replace programming languages, we recommend
    the blog post written by Chris Lattner [4], a programming and compiler expert.
    Lattner argues that, at least in the short term and possibly longer, programming
    languages won’t go away because the code from LLMs can be subtly wrong. So, if
    programming languages are sticking around for a while, the question is: Which
    programming languages should we be using? Lattner says, “The best language for
    an LLM is one that is highly usable and easy to read for humans, but whose implementation
    can scale to many different use cases and applications” [4]. Do existing languages
    meet this goal? Can we do better by designing a programming language that’s easier
    to read than, say, Python? Stay tuned!'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于LLM是否会取代编程语言的另一种看法，我们推荐阅读Chris Lattner（编程和编译器专家）撰写的博客文章[4]。Lattner认为，至少在短期内，甚至可能是更长的时间内，编程语言不会消失，因为LLM生成的代码可能会存在细微的错误。因此，如果编程语言还会存在一段时间，那么问题是：我们应该使用哪种编程语言？Lattner说：“最适合LLM的语言是那种对人类来说高度可用且易于阅读，但其实现可以扩展到许多不同的用例和应用程序的语言”
    [4]。现有的语言是否满足这个目标？我们能否通过设计一种比Python更容易阅读的编程语言来做得更好？请继续关注！
- en: OK, so maybe programming languages go away, or maybe they don’t; maybe they
    change. Regardless, do we need to worry about programmer jobs? We think not. Anyone
    who has worked at a software company will tell you that writing code isn’t the
    only or even main thing that programmers do with their time. Programmers also
    meet with clients to determine what they need. They specify what programs do and
    how they fit together. They check systems for performance and security concerns.
    They work with other teams to coordinate the design of huge pieces of software.
    If the writing code step gets easier, maybe we just get more useful software.
    That’s what happened when we got high-level languages. No one is going to code
    the next killer app in assembly! Compilers improve how we make software. Used
    thoughtfully, we think LLMs can do this too.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，也许编程语言会消失，也许不会；也许它们会改变。无论如何，我们是否需要担心程序员的工作？我们认为不需要。任何在软件公司工作过的人都会告诉你，编写代码并不是程序员用他们时间做的唯一或甚至主要的事情。程序员还会与客户会面，确定他们的需求。他们指定程序的功能以及它们如何组合。他们会检查系统的性能和安全问题。他们与其他团队合作，协调大型软件的设计。如果编写代码的步骤变得更容易，也许我们只是得到了更多有用的软件。这就是当我们得到高级语言时发生的事情。没有人会使用汇编语言编写下一个杀手级应用！编译器改善了我们的软件制作方式。如果我们明智地使用LLM，我们认为LLM也能做到这一点。
- en: An exciting future
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个令人兴奋的未来
- en: Although we’re partially unsure of what’s to come, it’s clear LLMs are going
    to dramatically change the future of programming. Perhaps, for now, they are just
    aids to help software engineers write better code. Perhaps five years from now,
    however, the majority of software will be written by LLMs and only a small subset
    of software engineers will be writing code from scratch. Whichever outcome proves
    true, changes are coming fast, and they’ll likely lead to more people being able
    to write software to meet their needs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们对未来部分不确定，但很清楚，LLMs将极大地改变编程的未来。也许，现在它们只是帮助软件工程师编写更好代码的辅助工具。也许五年后，然而，大多数软件将由LLMs编写，只有一小部分软件工程师会从头开始编写代码。无论哪种结果证明是正确的，变化正在迅速发生，它们可能会使更多的人能够编写满足他们需求的软件。
- en: 'As of writing, we already have some insights into how these tools are being
    used. In one survey, 92% of software developers reported using these tools on
    a regular basis [5]. Recent studies have found evidence that developers who use
    these tools are more productive than without the tools [6]. In one particularly
    interesting research study conducted at UC San Diego, researchers found that professional
    developers use these tools in two ways: acceleration and exploration [7]. In the
    acceleration phase, developers use these tools to help generate code faster than
    if they wrote it themselves. In the exploration phase, developers use these tools
    to help them find libraries that may be helpful or to understand the existing
    codebase. These findings align with what we’ve been learning in this book, and
    we look forward to the research to come.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对如何使用这些工具有一些见解。在一项调查中，92%的软件开发者表示他们定期使用这些工具[5]。最近的研究发现，使用这些工具的开发者比不使用工具的开发者更有效率[6]。在加州大学圣地亚哥分校进行的一项特别有趣的研究中，研究人员发现，专业开发者使用这些工具的方式有两种：加速和探索[7]。在加速阶段，开发者使用这些工具来帮助他们比如果自己编写代码更快地生成代码。在探索阶段，开发者使用这些工具来帮助他们找到可能有所帮助的库或理解现有的代码库。这些发现与我们在这本书中学到的东西相一致，我们期待未来的研究。
- en: More than anything else, we hope that you’re now able to make your own, informed
    decision on how you’ll use LLMs to program and what LLMs may mean for the future
    of programming. At times like these, with some fervently proclaiming, “Programming
    is over!” and others equally fervently proclaiming, “Programming won’t change
    much at all!” [8], it’s important for us to be able to weigh the arguments ourselves
    and the ways that this change may affect us and everyone else. Can these tools
    help us? We think so. We should therefore use them, but use them responsibly.
    Are there concerns? Again, we think so, as we’ve discussed throughout the book.
    We should take steps, such as testing and debugging, to mitigate those concerns.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们希望你现在能够根据自己的判断来决定如何使用大型语言模型（LLMs）进行编程，以及LLMs可能对编程的未来意味着什么。在这样的时刻，有些人热情地宣称，“编程已经结束了！”而另一些人同样热情地宣称，“编程不会发生太大的变化！”[8]，对我们来说，能够自己权衡这些论点以及这种变化可能对我们以及其他人产生的影响是很重要的。这些工具能帮助我们吗？我们认为可以。因此，我们应该使用它们，但也要负责任地使用。有没有担忧？同样，我们认为有，正如我们在整本书中讨论的那样。我们应该采取一些措施，比如测试和调试，来减轻这些担忧。
- en: The approach to teaching programming that we’ve taken in this book is new. Teachers
    and professors like us have just begun incorporating tools like Copilot into programming
    courses [9], though we’re still working on the balance between when we want learners
    to use Copilot and when we don’t. No matter the balance that programmers choose
    to learn programming, we want to stress to you that you’ve learned absolutely
    essential skills that everyone needs to create good software, whether you’re writing
    code occasionally at work to automate tedious tasks or you’re planning to become
    a professional software engineer. You have a strong foundation going forward,
    wherever your path may take you.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们采用的编程教学方法是新的。像我们这样的教师和教授刚刚开始将像Copilot这样的工具融入编程课程[9]，尽管我们仍在努力平衡我们希望学习者何时使用Copilot以及何时不使用Copilot。无论程序员选择何种平衡来学习编程，我们都要强调，你已经学习了每个人都需要的基本技能，无论是你偶尔在工作时编写代码来自动化繁琐的任务，还是你计划成为一名专业的软件工程师。你有一个强大的基础，无论你的道路如何。
- en: 12.3 Exercises
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 练习
- en: Explain how the persona pattern can be used to enforce coding standards in a
    company. For example, a company may ask its employees to always use camel case
    (e.g., xVal, ZValOut). Provide an example of a prompt you could use to have GitHub
    Copilot act as a manager enforcing specific coding standards.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释如何使用人格模式来加强公司中的编码标准。例如，公司可能要求其员工始终使用驼峰命名法（例如，xVal、ZValOut）。提供一个提示示例，让GitHub
    Copilot扮演一个经理的角色，执行特定的编码标准。
- en: 'You want to create a Python function that generates a username based on a user’s
    preferred username and full name. The function should follow these rules:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想创建一个Python函数，该函数根据用户的首选用户名和全名生成用户名。该函数应遵循以下规则：
- en: If the preferred username is available (i.e., not already taken), use it.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果首选用户名可用（即尚未被占用），请使用它。
- en: If the preferred username is taken, generate a new username by appending a single
    digit (e.g., 1, 2, 3, … . ) to the preferred username.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果首选用户名已被占用，通过在首选用户名后附加单个数字（例如，1、2、3、……）来生成新的用户名。
- en: If the generated usernames are also taken, use the user’s full name to generate
    a username by combining parts of their first and last name.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果生成的用户名也被占用，使用用户的全名通过组合他们的姓氏和名字的部分来生成用户名。
- en: The function should keep asking for a new preferred username if the generated
    usernames are also taken.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果生成的用户名也被占用，函数应继续请求新的首选用户名。
- en: Which interaction pattern (flipped interaction pattern or persona pattern) would
    you use to design this function with the help of GitHub Copilot? Justify your
    choice, and outline how you would start the interaction.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你会使用哪种交互模式（翻转交互模式或人格模式）来帮助GitHub Copilot设计这个功能？请证明你的选择，并概述你将如何开始交互。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A prompt pattern is a template to help us construct a prompt to meet a given
    goal.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示模式是一个模板，帮助我们构建一个提示以实现既定目标。
- en: 'The flipped interaction pattern flips the script: rather than posing questions
    to the LLM, the LLM poses questions to us.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 翻转交互模式翻转了剧本：不是向LLM提出问题，而是LLM向我们提出问题。
- en: The flipped interaction pattern is useful when we don’t know how to effectively
    prompt the LLM.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们不知道如何有效地提示LLM时，翻转交互模式很有用。
- en: The persona pattern is used to have the AI take on a particular persona, such
    as “introductory programming instructor,” or a specific point of view.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人格模式用于让AI承担特定的角色，例如“入门级编程讲师”或特定的观点。
- en: The persona pattern is useful when we want the LLM to respond from a given perspective.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们希望LLM从给定视角回应时，人格模式很有用。
- en: Copilot currently struggles with tasks that are contrived, not well defined,
    or large.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot目前在处理设计、定义不明确或规模较大的任务时存在困难。
- en: Some believe that LLMs will replace programming languages; others believe that
    programming languages are here to stay.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些人认为LLM将取代编程语言；另一些人认为编程语言将永远存在。
- en: LLMs are helping people perform data science tasks without those people ever
    seeing the underlying programming language code.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLM正在帮助人们执行数据科学任务，而这些人们从未见过底层编程语言代码。
- en: It may be that programming languages themselves aren’t replaced, but that the
    leading languages will be developed to be more readable than today’s languages.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能编程语言本身不会被取代，但主导语言将被开发得比今天的语言更易读。
