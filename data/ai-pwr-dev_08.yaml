- en: 6 Testing, assessing, and explaining with large language models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 使用大型语言模型进行测试、评估和解释
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Drafting unit tests with ease
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松起草单元测试
- en: Generating integration tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成集成测试
- en: Determining code quality and coverage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定代码质量和覆盖率
- en: Assessing software complexity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估软件复杂性
- en: Translating code and text
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 翻译代码和文本
- en: 'This chapter will explore a critical aspect of software engineering: testing.
    The act of testing software serves multiple essential purposes. First and foremost,
    it aids in the identification of bugs, errors, and problems that can potentially
    affect the software’s functionality, usability, or performance. Furthermore, it
    ensures that the software adheres to the required quality standards. By conducting
    thorough tests, we can verify whether the software meets the specified requirements,
    functions as intended, and produces the expected outcomes. Through comprehensive
    testing, developers can evaluate software’s reliability, accuracy, efficiency,
    security, and compatibility across various platforms and environments. Detecting
    and resolving software defects early in the development process can result in
    significant time and cost savings.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨软件工程的一个关键方面：测试。测试软件的行为具有多个基本目的。首先，它有助于识别可能影响软件功能、可用性或性能的缺陷、错误和问题。此外，它确保软件符合所需的质量标准。通过进行彻底的测试，我们可以验证软件是否满足指定的要求，是否按预期运行，并产生预期的结果。通过全面的测试，开发者可以评估软件在各种平台和环境中的可靠性、准确性、效率、安全性和兼容性。在开发早期阶段发现并解决软件缺陷可以显著节省时间和成本。
- en: Once we have finished formulating our tests, we will evaluate the quality of
    our code. You will be introduced to several metrics that are helpful in assessing
    software quality and complexity. Additionally, if we need clarification on the
    purpose of our code or are reviewing it for the first time, we will seek an explanation
    to ensure thorough understanding.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了测试的制定，我们将评估我们代码的质量。你将了解到一些有助于评估软件质量和复杂性的指标。此外，如果我们需要澄清代码的目的，或者是我们第一次审查它，我们将寻求解释以确保彻底理解。
- en: 6.1 Testing, testing … one, two, three types
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 测试，测试……一、二、三类型
- en: Testing plays a vital role in software engineering; therefore, we will explore
    various types of testing in detail. These include unit tests, integration tests,
    and behavior tests. To start, we will use Copilot Chat to help us create a *unit
    test*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在软件工程中扮演着至关重要的角色；因此，我们将详细探讨各种测试类型。这包括单元测试、集成测试和行为测试。首先，我们将使用Copilot Chat来帮助我们创建一个*单元测试*。
- en: Definition A *unit test* focuses on testing individual components or units of
    code to ensure that they function correctly in isolation. Developers usually run
    unit tests to help identify bugs and problems in specific software units.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 A *单元测试*专注于测试单个组件或代码单元，以确保它们在独立的情况下能正确运行。开发者通常运行单元测试来帮助识别特定软件单元中的错误和问题。
- en: 6.1.1 Unit testing
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 单元测试
- en: In this section, we will create unit tests to test our software components.
    Several unit-testing frameworks are available for Python. Each has unique features
    and is suitable for different scenarios. We will examine each of them briefly
    before settling on a specific framework based on the recommendation provided by
    our AI tool.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建单元测试来测试我们的软件组件。Python有多种单元测试框架可供选择。每个框架都有其独特的功能，适用于不同的场景。在根据我们的AI工具提供的推荐选择一个特定的框架之前，我们将简要地检查每个框架。
- en: The first framework is `unittest`. This is Python’s standard library for creating
    unit tests. It comes bundled with Python and doesn’t need to be installed separately.
    `unittest` provides a rich set of assertions and is great for writing simple to
    complex test cases, but it can be verbose. It is a good choice for writing basic
    unit tests, especially if you don’t want to introduce additional dependencies
    in your project. It’s useful in any scenario where you need to confirm the functionality
    of individual units of code in isolation from the rest of the system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个框架是`unittest`。这是Python创建单元测试的标准库。它随Python一起提供，无需单独安装。`unittest`提供了一套丰富的断言，非常适合编写简单到复杂的测试用例，但它可能会很冗长。对于编写基本的单元测试来说，这是一个不错的选择，尤其是如果你不想在你的项目中引入额外的依赖项。它在任何需要独立于系统其他部分确认代码单元功能的情况下都很有用。
- en: Next, let’s examine `pytest`. It is a popular third-party library that can be
    used for unit testing, although it’s versatile enough to handle more than just
    unit tests. It requires less boilerplate code than `unittest` and has powerful
    features like fixtures for setup and teardown, parameterized testing, and the
    ability to run `unittest` and `nose` test suites. p`ytest` is great for both simple
    and complex unit test cases. It’s also useful for functional and integration tests.
    If you value simplicity and ease of use, and your project is not restricted to
    using only the Python standard library, `pytest` is an excellent choice.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来检查 `pytest`。这是一个流行的第三方库，可用于单元测试，尽管它足够灵活，可以处理不仅仅是单元测试。它比 `unittest` 需要更少的样板代码，并具有强大的功能，如设置和清理的
    fixtures、参数化测试以及运行 `unittest` 和 `nose` 测试套件的能力。`pytest` 对于简单和复杂的单元测试案例都很好。它也适用于功能性和集成测试。如果你重视简单性和易用性，并且你的项目不受限于仅使用
    Python 标准库，`pytest` 是一个极佳的选择。
- en: '`nose2` is the successor to the deprecated `nose` testing framework. It extends
    `unittest` and makes testing easier. It’s known for its test discovery feature,
    which automatically finds your project’s tests so you don’t have to manually list
    them. `nose2` is good for larger projects where test discovery can save time.
    Like `pytest`, it can run `unittest` test suites, so it’s also a good choice if
    you’re migrating from `unittest` but want to keep your existing tests.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose2` 是已弃用的 `nose` 测试框架的继任者。它扩展了 `unittest` 并使测试更加容易。它以其测试发现功能而闻名，该功能可以自动找到你的项目测试，这样你就不必手动列出它们。`nose2`
    对于可以节省时间的较大项目来说是个不错的选择。像 `pytest` 一样，它可以运行 `unittest` 测试套件，所以如果你从 `unittest` 迁移但想保留现有的测试，它也是一个很好的选择。'
- en: Finally, there is `doctest`. This is another module that’s part of the Python
    standard library. It’s not a full-featured testing framework like the others,
    but it allows you to write tests directly in your docstrings. `doctest` is best
    suited for simple cases where you want to demonstrate how to use a function or
    module and confirm that the example code works as expected. It’s a great way to
    ensure that your documentation stays up to date with your code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有 `doctest`。这是 Python 标准库的一部分模块。它不是一个像其他模块那样功能齐全的测试框架，但它允许你直接在你的文档字符串中编写测试。`doctest`
    最适合于简单的案例，其中你想要展示如何使用一个函数或模块，并确认示例代码按预期工作。这是一种确保你的文档与代码保持同步的绝佳方式。
- en: Copilot Chat recommended that we use `unittest`, so we will. You might try to
    ask it yourself and see if it reaches a different conclusion, which it may, depending
    on how you frame the question.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot Chat 建议我们使用 `unittest`，因此我们将这样做。你可以尝试自己询问它，看看是否会得出不同的结论，这可能是可能的，这取决于你如何构建问题。
- en: First we will define test cases by creating classes that inherit from the `unittest.TestCase`
    class. In writing our first unit test, we will uncover a rather pernicious bug
    that has thus far eluded us; we will get to that shortly. Finally, we are going
    to test the correctness of the `DepartmentStatisticsVisitor` class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过创建继承自 `unittest.TestCase` 类的类来定义测试案例。在编写我们的第一个单元测试时，我们将揭示一个迄今为止一直困扰我们的相当有害的错误；我们很快就会达到这一点。最后，我们将测试
    `DepartmentStatisticsVisitor` 类的正确性。
- en: We start with a prompt asking Copilot Chat to create a unit test for `DepartmentStatisticsVisitor`.
    The response will be a reminder of the importance of context. Copilot Chat, given
    that we began a new chat session, will attempt to create this unit test, but it
    lacks the definition of any of our classes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先向 Copilot Chat 发送一个提示，要求它为 `DepartmentStatisticsVisitor` 创建一个单元测试。响应将是一个关于上下文重要性的提醒。由于我们开始了一个新的聊天会话，Copilot
    Chat 将尝试创建这个单元测试，但它缺少我们任何类的定义。
- en: Listing 6.1 First attempt to define a unit test
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 第一次尝试定义单元测试
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We proceed by inputting definitions into Copilot Chat so that it can refine
    the test case. We can tell it more about the visitor class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向 Copilot Chat 输入定义来继续进行，以便它可以细化测试案例。我们可以更多地了解访客类：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With this updated information, Copilot Chat can better estimate how our unit
    test should function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些更新的信息，Copilot Chat 可以更好地估计我们的单元测试应该如何工作。
- en: Listing 6.2 The result of a unit test prompt
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 单元测试提示的结果
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The unit test is close to what we need; however, the definition of `Asset` is
    incorrect. We can enter the proper definition from our asset.py class, and Copilot
    Chat will continue to refine the unit test.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试接近我们需要的；然而，`Asset` 的定义是不正确的。我们可以从我们的 asset.py 类中输入正确的定义，然后 Copilot Chat
    将继续细化单元测试。
- en: Listing 6.3 Next attempt to define a unit test, with `Asset` definition
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 下一次尝试定义单元测试，包含 `Asset` 定义
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is closer. We also need to remind Copilot Chat that the `Asset` class has
    a class called `FundingDetails`. Let’s provide the definition of `FundingDetails`
    and inform Copilot Chat that it should be part of `Asset`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这更接近了。我们还需要提醒Copilot Chat，`Asset`类有一个名为`FundingDetails`的类。让我们提供`FundingDetails`的定义，并告知Copilot
    Chat它应该是`Asset`的一部分。
- en: Listing 6.4 Third attempt at a unit test, which comes reasonably close
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.4 第三次尝试单元测试，相当接近
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All that remains is to manually update the `import` statements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是手动更新`import`语句。
- en: 'NOTE Let this exercise be a cautionary tale in the usage of large language
    models: coercing them to behave with respect to highly focused tasks can be very
    challenging, to the point of not being worth the effort. In the real world, no
    one will blame you for abandoning the prompt engineering and going back to just
    coding out this test. However, with some persistence, you can build a template
    library that you can use to build a suite of unit tests for similarly shaped classes.
    Also note that Copilot Chat can and will generate a test for the file in the editor
    window if you instruct it to Generate (a) unit test for my code, but it will mock
    all objects/properties that are not directly part of the class under test. Depending
    on what you are attempting to test, the utility of this feature may be questionable.
    Another common problem specific to Python is that the indentation is frequently
    incorrect with code copied from Copilot Chat.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：让这个练习成为一个关于大语言模型使用的警示故事：强迫它们在高度专注的任务上表现良好可能非常具有挑战性，以至于不值得付出努力。在现实世界中，没有人会责怪你放弃提示工程，转而只编写这个测试的代码。然而，只要有足够的坚持，你可以构建一个模板库，用于为类似形状的类构建一系列单元测试。此外，请注意，如果你指示Copilot
    Chat生成（一个）针对我的代码的单元测试，Copilot Chat可以在编辑器窗口中生成测试文件，但它将模拟所有不属于测试类直接部分的对象/属性。根据你试图测试的内容，这个功能的实用性可能会有疑问。Python的一个常见问题特指，从Copilot
    Chat复制的代码中，缩进经常是不正确的。
- en: When we attempt to run this test, we discover that there is a *circular dependency*
    between the visitor, asset, funding details, and depreciation strategy. A circular
    dependency is a situation in which two or more modules or components depend on
    each other directly or indirectly. In our case, when Python tries to instantiate
    `Asset`, it loads the definition of `FundingDetails`. We can fix this by moving
    away from a direct instantiation or reference to the `FundingDetails` class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试运行这个测试时，我们发现访问者、资产、资金详情和折旧策略之间存在*循环依赖*。循环依赖是指两个或多个模块或组件直接或间接地相互依赖的情况。在我们的案例中，当Python尝试实例化`Asset`时，它会加载`FundingDetails`的定义。我们可以通过避免直接实例化或引用`FundingDetails`类来解决这个问题。
- en: Listing 6.5 Updated `Asset`, no direct reference to `FundingDetails`
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5 更新的`Asset`，没有直接引用`FundingDetails`
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We need to do the same for the `FundingDetails` class. It should not directly
    reference the `DepreciationStrategy` class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对`FundingDetails`类做同样的事情。它不应该直接引用`DepreciationStrategy`类。
- en: Listing 6.6 `FundingDetails`, no direct ref to `DepreciationStrategy`
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.6 `FundingDetails`，没有直接引用`DepreciationStrategy`
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we’ve seen, we were able to create a unit test using Copilot Chat. However,
    we would likely have been able to create it more easily if we had written it without
    Copilot. The tool is surprisingly good at providing guidance as to when and how
    to test your code, but the implementation (at least currently) leaves something
    to be desired.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们能够使用Copilot Chat创建一个单元测试。然而，如果我们没有使用Copilot编写它，我们可能会更容易地创建它。这个工具在提供关于何时以及如何测试你的代码的指导方面非常出色，但（至少目前）其实现还有待提高。
- en: 'In the real world, we would continue to add unit tests to build up a substantial
    body of tests. How many tests is *substantial*, you ask? We will explore this
    shortly. However, we first turn our attention to the next type of test: the *integration
    test*.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我们会继续添加单元测试，以构建一个庞大的测试库。你可能会问，有多少测试才算得上是“庞大”？我们很快就会探讨这个问题。然而，我们首先将注意力转向下一类测试：*集成测试*。
- en: Definition *Integration testing* involves testing the interaction between different
    components or modules of the software to ensure that they work together seamlessly.
    It verifies that the integrated system functions as expected and detects any inconsistencies
    or communication problems between modules.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*集成测试*涉及测试软件的不同组件或模块之间的交互，以确保它们能够无缝地协同工作。它验证集成系统按预期工作，并检测模块之间的一致性或通信问题。
- en: 6.1.2 Integration testing
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 集成测试
- en: In this section, we will develop an integration test that will allow us to test
    the end-to-end system. Fortunately, `fastapi` comes with its own test client,
    which will aid us in creating this test.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个集成测试，这将使我们能够测试端到端系统。幸运的是，`fastapi`自带其自己的测试客户端，这将帮助我们创建这个测试。
- en: We begin by copying in the definition of `AssetController` into the Copilot
    Chat window. We can then ask Copilot Chat how to create an integration test for
    this controller. Given that we included the routes in the definition, Copilot
    Chat should be able to provide us with accurate integration tests. We need to
    specify that we will use the `InMemoryAssetRepository` class or fix this after
    the test has been generated.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`AssetController`的定义复制到Copilot Chat窗口中。然后我们可以询问Copilot Chat如何为这个控制器创建集成测试。鉴于我们在定义中包含了路由，Copilot
    Chat应该能够为我们提供准确的集成测试。我们需要指定我们将使用`InMemoryAssetRepository`类，或者测试生成后修复这个问题。
- en: Listing 6.7 Copilot Chat-generated integration test of `AssetController`
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 Copilot Chat生成的`AssetController`集成测试
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will now turn our attention to the final type of testing that we’ll examine:
    *behavior testing*.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将关注我们将要检查的最后一种测试类型：*行为测试*。
- en: Definition *Behavior testing* focuses on the behavior of a system as a whole
    from the perspective of an end user. It is typically used to test the functionality
    of a system and to ensure that the system meets the requirements and specifications
    defined for it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *行为测试*侧重于从最终用户的角度看整个系统的行为。它通常用于测试系统的功能，并确保系统满足为其定义的要求和规范。
- en: 6.1.3 Behavior testing
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 行为测试
- en: In a sense, all testing is behavior testing, as tests verify the behavior of
    the system. However, behavior testing is unique in some respects. Let’s summarize
    the different types of testing that we have encountered thus far and contrast
    them against behavior tests.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，所有测试都是行为测试，因为测试验证了系统的行为。然而，行为测试在某些方面是独特的。让我们总结一下迄今为止我们所遇到的不同类型的测试，并将它们与行为测试进行对比。
- en: Unit testing focuses on testing individual units or components of a system in
    isolation, typically using automated tests. Unit tests are designed to test the
    functionality of individual functions or methods and to ensure that they behave
    correctly under a variety of conditions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试侧重于在隔离状态下测试系统的单个单元或组件，通常使用自动化测试。单元测试旨在测试单个函数或方法的功能，并确保它们在各种条件下表现正确。
- en: Integration testing, on the other hand, focuses on testing the interactions
    between different components or units of a system. Integration testing is typically
    used to test the interfaces between different components or units and to ensure
    that they work together correctly. Integration testing can be performed manually
    or using automated tests, and it typically involves testing the interactions between
    different components or units of a system rather than the system as a whole.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，集成测试侧重于测试系统不同组件或单元之间的交互。集成测试通常用于测试不同组件或单元之间的接口，并确保它们能够正确地协同工作。集成测试可以是手动执行或使用自动化测试，通常涉及测试系统不同组件或单元之间的交互，而不是整个系统。
- en: Behavioral testing focuses on defining the behavior of the software in terms
    of user stories or scenarios. These scenarios are written in a specific format
    called *given-when-then* (GWT) and are used to drive the development process.
    The GWT format describes the preconditions (given), the actions (when), and the
    expected outcomes (then) of a particular scenario.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 行为测试侧重于从最终用户的角度定义软件的行为，以用户故事或场景的形式。这些场景以特定的格式编写，称为*给定-当-然后*（GWT），并用于驱动开发过程。GWT格式描述了特定场景的先决条件（给定）、操作（当）和预期结果（然后）。
- en: As we progress with our testing, we may find that some behaviors or components
    are difficult to set up in our test. Additionally, it may be tricky to isolate
    the behavior of a particular object or module and test the interactions between
    different objects. To address this limitation, we can use a *mock object*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们测试的进行，我们可能会发现某些行为或组件在我们的测试中难以设置。此外，隔离特定对象或模块的行为并测试不同对象之间的交互可能很棘手。为了解决这一限制，我们可以使用*模拟对象*。
- en: Definition A *mock object* is a test double that simulates the behavior of a
    real object in a controlled way. Mock objects can also be used to simulate error
    conditions or edge cases that are difficult to reproduce with real objects. They
    can be created manually using a mocking library such as `unittest.mock` or `pytest-mock`.
    These libraries provide functions and classes for creating and configuring mock
    objects. Mock objects can be configured to return specific values or raise specific
    exceptions when their methods are called. They can also be used to record the
    calls made to their methods so that you can verify that the correct methods were
    called with the correct parameters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 A *模拟对象* 是一种测试替身，以受控的方式模拟真实对象的行为。模拟对象还可以用来模拟难以用真实对象复现的错误条件或边缘情况。它们可以通过使用如
    `unittest.mock` 或 `pytest-mock` 这样的模拟库手动创建。这些库提供了创建和配置模拟对象的函数和类。模拟对象可以被配置为在调用其方法时返回特定值或引发特定异常。它们还可以用来记录对其方法的调用，以便您可以验证是否以正确的参数调用了正确的方法。
- en: 'We will incorporate mock objects into the prompt to create a behavior test
    for `AssetManager`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把模拟对象纳入提示中，为 `AssetManager` 创建一个行为测试：
- en: '|'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![logo-NC](../Images/logo-NC.png)'
- en: '| We have a class called AssetManager. AssetManager''s constructor takes two
    classes BaseRepository and AssetLocationMediator. The BaseRepository is a repository
    in which Assets are stored. We want to use InMemoryAssetRepository, which is a
    subclass of BaseRepository that stores the Assets in memory. Use a mock object
    for AssetLocationMediator. The AssetManager stores Assets using the method create
    and gets all of the Assets using the method get_assets. An asset has 10 required
    positional arguments: ''id'', ''name'', ''status'', ''category'', ''cost'', ''useful_life'',
    ''salvage_value'', ''purchase_date'', ''locations'', and ''funding_details''.
    Use named parameters to make it clear which param is going where. Create a BDD
    script that will add two Assets to the AssetManager, confirming that all Assets
    cost $4000.00\. This should be implemented in Python. Take it step by step, telling
    us the tools and libraries you will use. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 我们有一个名为 AssetManager 的类。AssetManager 的构造函数接受两个类 BaseRepository 和 AssetLocationMediator。BaseRepository
    是一个存储资产的仓库。我们想使用 InMemoryAssetRepository，它是 BaseRepository 的一个子类，用于在内存中存储资产。为
    AssetLocationMediator 使用模拟对象。AssetManager 使用 create 方法存储资产，并使用 get_assets 方法获取所有资产。一个资产有
    10 个必需的位置参数：''id''、''name''、''status''、''category''、''cost''、''useful_life''、''salvage_value''、''purchase_date''、''locations''
    和 ''funding_details''。使用命名参数来清楚地说明哪个参数去哪里。创建一个 BDD 脚本，将两个资产添加到 AssetManager 中，确认所有资产的成本为
    $4000.00。这应该用 Python 实现。一步一步地告诉我们你将使用哪些工具和库。 |'
- en: Copilot Chat tells us that we need to create a new file (a *feature file*) called
    `asset_manager.feature`. In this file, we will define `AssetManager`’`s` attributes
    (and any supporting classes). For example, the feature file defines a scenario
    that adds two assets to `AssetManager`, confirms that the total cost of all assets
    is $4,000.00, and mocks the `AssetLocationMediator` class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot Chat 告诉我们，我们需要创建一个新的文件（一个 *feature 文件*），名为 `asset_manager.feature`。在这个文件中，我们将定义
    `AssetManager` 的属性（以及任何支持类）。例如，该特征文件定义了一个场景，向 `AssetManager` 添加两个资产，确认所有资产的总成本为
    $4,000.00，并模拟 `AssetLocationMediator` 类。
- en: Listing 6.8 `asset_manager.feature` file according to Copilot Chat
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Copilot Chat 列出 6.8 的 `asset_manager.feature` 文件
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We need to create a directory called features at the root of our project and
    place this file in that directory. Additionally, we need to add a subdirectory
    called steps. Next we create a new Python file called steps.py and place it in
    the steps directory. This Python file defines the step implementations for the
    scenario in the feature file. The `AssetManager`, `InMemoryAssetRepository`, `AssetLocationMediator`,
    and `Asset` classes are imported, and six functions are defined to correspond
    to the steps in the scenario. These functions use the context object to store
    and retrieve data between steps. The `Mock` class from the `unittest.mock` library
    is used to create a mock object for the `AssetLocationMediator` class. The `Asset`
    class is instantiated using named parameters to clarify which parameter belongs
    to which attribute. If we ask Copilot Chat for the contents of the steps.py file,
    we will see output similar to the following listing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在项目的根目录下创建一个名为 features 的目录，并将此文件放置在该目录中。此外，我们还需要添加一个名为 steps 的子目录。接下来，我们创建一个名为
    steps.py 的新 Python 文件，并将其放置在 steps 目录中。这个 Python 文件定义了特征文件中场景的步骤实现。导入了 `AssetManager`、`InMemoryAssetRepository`、`AssetLocationMediator`
    和 `Asset` 类，并定义了六个函数来对应场景中的步骤。这些函数使用上下文对象在步骤之间存储和检索数据。`unittest.mock` 库中的 `Mock`
    类用于为 `AssetLocationMediator` 类创建一个模拟对象。使用命名参数实例化 `Asset` 类，以明确哪个参数属于哪个属性。如果我们向
    Copilot Chat 请求 steps.py 文件的內容，我们将看到类似于以下列表的输出。
- en: Listing 6.9 Implementation details for behavior test defined in steps.py
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.9 steps.py 中定义的行为测试的实现细节
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you do not have it installed already, you need to install the `behave` library
    using pip: `pip install behave`. Additionally, add it to the requirements.txt
    file to ensure that it will be pulled in when we later build a deployable version
    of this application. We run the behavior test by issuing the following command
    from the root directory of our project.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装它，你需要使用 pip 安装 `behave` 库：`pip install behave`。此外，将其添加到 requirements.txt
    文件中，以确保在稍后构建可部署版本的应用程序时将其拉入。我们从项目的根目录运行行为测试，使用以下命令。
- en: Listing 6.10 Running the behavior test, and the resulting output
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.10 运行行为测试及其输出结果
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this section, we have laid a foundation for good software development by
    using three types of tests: unit, integration, and behavior. Some may quibble
    that it came very late in the development lifecycle of this project, and they
    would not be wrong. In the real world, we develop our tests as we develop our
    code. Some may argue that we need to build our tests *before* our code. You may
    or may not hold this belief, but either way, you need to test early and test often.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过使用三种类型的测试：单元测试、集成测试和行为测试，为良好的软件开发奠定了基础。有些人可能会挑剔地说，这在这个项目的开发周期中来得非常晚，他们并不错。在现实世界中，我们随着代码的开发来开发我们的测试。有些人可能会争论说，我们需要在代码之前构建我们的测试。你可能或可能不持有这种信念，但无论如何，你需要尽早测试，并且经常测试。
- en: In the next section, we dive into some metrics that can be used to determine
    the overall quality of our software, and we will ask Copilot to help us assess
    the quality of our code thus far.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入研究一些可以用来确定我们软件整体质量的指标，并且我们将请求 Copilot 帮助我们评估到目前为止的代码质量。
- en: 6.2 Assessing quality
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 评估质量
- en: Understanding the performance, reliability, maintainability, and overall quality
    of software applications is a crucial aspect of software engineering. This section
    delves into the fascinating and intricate domain of software quality metrics—the
    quantitative standards and benchmarks that guide our understanding of the quality
    of a software system.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 理解软件应用的性能、可靠性、可维护性和整体质量是软件工程的一个关键方面。本节深入探讨了软件质量指标的迷人而复杂的领域——这些是指导我们理解软件系统质量的定量标准和基准。
- en: Software quality metrics are essential tools that allow stakeholders—developers,
    testers, managers, and users—to assess a software product’s state, identifying
    its strengths and areas for improvement. They provide an empirical foundation
    for various processes such as product development, testing, debugging, maintenance,
    and improvement initiatives. By quantifying specific characteristics of the software,
    these metrics provide a tangible means to understand the otherwise abstract concept
    of software quality.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 软件质量指标是允许利益相关者——开发者、测试人员、经理和用户——评估软件产品状态的必要工具，确定其优势和改进领域。它们为产品开发、测试、调试、维护和改进计划等过程提供了经验基础。通过量化软件的特定特征，这些指标提供了理解软件质量这一抽象概念的有形手段。
- en: In this section, we explore several important categories of software quality
    metrics, including product metrics, process metrics, and project metrics. We’ll
    analyze their significance, methodologies for their calculation, and how they
    can be effectively utilized to evaluate and enhance software quality. This exploration
    will include both static metrics, which are applied to the static software system,
    and dynamic metrics, which assess the system’s behavior during execution.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨几个重要的软件质量指标类别，包括产品指标、过程指标和项目指标。我们将分析它们的含义、计算方法以及如何有效地利用它们来评估和提升软件质量。这次探索将包括静态指标，这些指标应用于静态软件系统，以及动态指标，这些指标评估系统在执行过程中的行为。
- en: Software quality metrics not only contribute to the technical soundness of a
    software system but also help ensure customer satisfaction, profitability, and
    long-term business success. Therefore, developing an understanding of these metrics
    is invaluable to anyone involved in the field of software development, from engineers
    and project managers to executives and software users.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 软件质量指标不仅有助于确保软件系统的技术稳定性，还有助于确保客户满意度、盈利能力和长期商业成功。因此，对软件开发领域中的任何人来说，了解这些指标都是非常有价值的，从工程师和项目经理到高管和软件用户。
- en: We will examine a few common measures of complexity and maintainability of the
    class or code. Complex software can be difficult to comprehend, which makes it
    challenging for developers, particularly new ones, to grasp how different parts
    of the software interact with each other. This can slow down the onboarding process
    and development time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查几个关于类或代码复杂性和可维护性的常见指标。复杂的软件可能难以理解，这使得开发者，尤其是新开发者，难以掌握软件的不同部分是如何相互作用的。这可能会减缓入职过程和开发时间。
- en: 'Complex code often leads to more maintenance: modifications or bug fixes can
    take longer because it’s harder to predict the effects of changing a single piece
    of the system. This can result in higher costs over the software’s lifecycle.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的代码往往会导致更多的维护：修改或错误修复可能需要更长的时间，因为更难预测改变系统单个部分的影响。这可能导致软件生命周期中的成本更高。
- en: Complex software also tends to be more error-prone. Because it’s harder to understand,
    developers are more likely to introduce bugs when making changes. Also, complex
    code can have many interdependencies, and a change in one area may have unexpected
    effects elsewhere.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的软件也往往更容易出错。因为它更难理解，所以在进行更改时，开发者更有可能引入错误。此外，复杂的代码可能有许多相互依赖性，一个区域的更改可能会在别处产生意外的效果。
- en: The more complex the software, the more test cases are required to achieve thorough
    testing. It may also be harder to write these test cases due to the complexity
    of the logic involved.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 软件越复杂，需要更多的测试用例才能实现彻底的测试。由于涉及逻辑的复杂性，编写这些测试用例可能也更困难。
- en: Writing simple and maintainable code should be one of our highest priorities.
    Observing the change in the metric that accompanies our code should aid us in
    this endeavor. Toward this objective, the first metric that we can (and should)
    use is *cyclomatic complexity*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 编写简单且易于维护的代码应该是我们最高的优先事项之一。观察伴随我们的代码的指标变化应该有助于我们实现这一目标。为此，我们可以（并且应该）使用的第一个指标是*循环复杂度*。
- en: Definition *Cyclomatic complexity* is a metric that quantifies the number of
    independent paths through a software module. It measures the complexity of decision-making
    in the code, including loops, conditionals, and branches. A higher cyclomatic
    complexity value indicates increased complexity and suggests the potential for
    more bugs and challenges in understanding and maintaining the code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*循环复杂度*是一个衡量软件模块中独立路径数量的指标。它衡量代码中决策的复杂度，包括循环、条件和分支。较高的循环复杂度值表示更高的复杂度，并暗示代码在理解和维护方面可能存在更多错误和挑战。
- en: 'Enter the following prompt anywhere in the file department_visitor.py. Copilot
    will immediately output the answer:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件department_visitor.py的任何地方输入以下提示。Copilot将立即输出答案：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Copilot tells us that the complexity of this class is 1\. You may or may not
    be aware of the meaning of this value. If the latter, you can ask Copilot to elaborate:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot告诉我们这个类的复杂度是1。你可能或可能不知道这个值的含义。如果不知道，你可以要求Copilot进行详细说明：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Copilot informs us that cyclomatic complexity is good if it is low. Intuitively,
    this makes sense. Code with low complexity means it is simpler to understand and
    therefore reason about. It is likely easier to maintain as well. Next we will
    explore the *Halstead complexity measures.*
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot告诉我们，如果圈复杂度低，那么它是好的。直观上，这很有道理。低复杂度的代码意味着它更容易理解，因此更容易推理。它也更有可能更容易维护。接下来，我们将探索*霍尔斯特德复杂度度量*。
- en: Definition *Halstead complexity measures* assess the complexity of a software
    program based on the number of unique operators and operands used in the code.
    These measures include metrics such as program length (N1), program vocabulary
    (n1), volume (V), difficulty (D), effort (E), and others. These metrics provide
    insights into the size and cognitive complexity of the code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *霍尔斯特德复杂度度量* 基于代码中使用的唯一操作符和操作数的数量来评估软件程序的复杂度。这些度量包括程序长度（N1）、程序词汇（n1）、体积（V）、难度（D）、努力（E）等指标。这些指标提供了对代码大小和认知复杂度的洞察。
- en: 'Similar to last time, we will start with a prompt asking Copilot to determine
    the Halstead complexity measure for our visitor class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与上次类似，我们将从一个提示开始，要求Copilot确定我们的访客类的霍尔斯特德复杂度度量：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You may want to continue this Q&A session for a while to see what information
    can be gleaned from Copilot. Once you are ready to continue, there is one more
    metric to explore: the *maintainability index.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想继续这个问答会话一段时间，看看可以从Copilot中获取哪些信息。一旦你准备好继续，还有一个指标要探索：*可维护性指数*。
- en: Definition The *maintainability index* is a composite metric that combines several
    factors, including cyclomatic complexity, lines of code, and Halstead complexity
    measures, to provide an overall measure of software maintainability. A higher
    maintainability index suggests easier maintenance and potentially lower complexity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *可维护性指数* 是一个综合指标，它结合了多个因素，包括圈复杂度、代码行数和霍尔斯特德复杂度度量，以提供一个软件可维护性的总体度量。更高的可维护性指数表明维护更容易，并且可能具有更低的复杂性。
- en: 'Start a similar discussion for the maintainability index in the visitor file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在访客文件中开始一个类似的关于可维护性指数的讨论：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we get a low maintainability index, we can refactor to reduce this number.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到一个低的可维护性指数，我们可以重构以减少这个数字。
- en: 'A metric is useful in that it gives us a nail to hang our hat on; that is,
    we can take that measure and perform some action to improve it. Metrics move us
    beyond pure aesthetics or the subjectivity of an individual. A metric is real,
    actionable data. But Copilot has (at least) one more trick up its proverbial sleeve.
    Copilot is capable of doing more than just writing and assessing our code: it
    can also address the code’s flaws. Let’s bug hunt.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个指标是有用的，因为它给我们提供了一个挂帽子的钉子；也就是说，我们可以采取这个度量并执行一些操作来改进它。指标使我们超越了纯粹的美学或个人的主观性。一个指标是真实、可操作的数据。但是Copilot还有（至少）一个众所周知的技巧。Copilot不仅能够编写和评估我们的代码，它还可以解决代码的缺陷。让我们开始捕捉错误。
- en: 6.3 Hunting for bugs
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 捕捉错误
- en: 'In this section, we will use an elementary (albeit contrived) example to demonstrate
    how we can use Copilot to find and fix problems in our code. This code is supposed
    to loop a the list of integers and calculate the sum. However, there is a “blink
    and you’ll miss it” bug: the sum is assigned the value of `i` rather than adding
    the value of `i` to the running total.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一个基本的（尽管是人为设计的）示例来展示我们如何使用Copilot来查找和修复代码中的问题。这段代码本应遍历整数列表并计算总和。然而，存在一个“一闪而过”的错误：总和被分配了`i`的值，而不是将`i`的值添加到运行总和中。
- en: Listing 6.11 Looping over a list of integers and calculating the sum
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.11 遍历整数列表并计算总和
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To debug this problem, we will introduce a new tool: Copilot Labs. Prior to
    Copilot Chat, Copilot Labs was the only means by which certain features were available
    in an IDE (specifically, Visual Studio Code). For example, we need to use Copilot
    Labs to find and fix bugs. The main advantage that Copilot Labs still offers today
    is that it can access the highlighted contents of your editor pane. This feature
    allows Copilot Labs to operate directly on the editable code in your IDE.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试这个问题，我们将引入一个新的工具：Copilot Labs。在Copilot Chat之前，Copilot Labs是唯一在IDE（特别是Visual
    Studio Code）中提供某些功能的手段。例如，我们需要使用Copilot Labs来查找和修复错误。Copilot Labs今天仍提供的主要优势是它可以访问你的编辑器面板中的高亮内容。这个功能使得Copilot
    Labs可以直接在你的IDE中的可编辑代码上操作。
- en: Once you install the extension into your IDE, you should see a Copilot Labs
    toolkit on the left side of the IDE, as shown in figure 6.1\. If you need a reminder
    about how to install an extension into your IDE, see appendices A–C for instructions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将扩展程序安装到你的IDE中，你应该在IDE的左侧看到Copilot Labs工具箱，如图6.1所示。如果你需要关于如何将扩展程序安装到IDE的提醒，请参阅附录A-C中的说明。
- en: '![](../Images/CH06_F01_Crocker2.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F01_Crocker2.png)'
- en: Figure 6.1 The Copilot Labs toolkit menu, which includes options for finding
    and fixing bugs. The toolkit also provides facilities to enhance your code as
    well as document it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 Copilot Labs工具箱菜单，包括查找和修复错误的选项。工具箱还提供了增强和记录代码的功能。
- en: We will temporarily change the contents of the main.py file to the code listed
    in listing 6.11\. Once you have made this change, highlight the code and click
    the Fix Bug button in the Copilot Labs toolkit. You should see output like that
    in figure 6.2\. Copilot Labs was able to determine the problem in this code and
    provides a suggestion as to how to fix it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将临时更改main.py文件的内容为列表6.11中列出的代码。一旦你做了这个更改，突出显示代码并点击Copilot Labs工具箱中的修复错误按钮。你应该看到如图6.2所示的输出。Copilot
    Labs能够确定这段代码中的问题，并提供有关如何修复的建议。
- en: '![](../Images/CH06_F02_Crocker2.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F02_Crocker2.png)'
- en: Figure 6.2 Copilot Labs, using the GPT model, has identified the bug and how
    to address it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 使用GPT模型的Copilot Labs已经识别出错误及其解决方法。
- en: Alternatively, you could copy this code into ChatGPT and ask it to find the
    bug. However, it is arguable that doing so is less convenient as you would have
    to know there was a bug in your code before asking ChatGPT to fix it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以将此代码复制到ChatGPT中，并要求它找出错误。然而，这样做可能不太方便，因为你必须在请求ChatGPT修复之前知道代码中存在错误。
- en: 6.4 Covering code
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 代码覆盖率
- en: '*Code coverage* is a measure of how much of your code is being exercised by
    your tests. It is typically expressed as a percentage and represents the proportion
    of your code that your tests execute.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码覆盖率*是衡量你的代码被测试执行程度的指标。它通常以百分比的形式表示，代表你的代码中由测试执行的代码比例。'
- en: Code coverage can be used as a metric to evaluate the effectiveness of your
    tests. If your code coverage is low, it may indicate that parts of your code are
    not being tested, which can lead to uncaught bugs and other problems. Alternatively,
    with high code coverage, you can rest assured that your code is well-tested. This
    does not guarantee that your code is bug-free, but it should give you a high degree
    of confidence that if there are bugs, they will be caught in a test.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率可以用作衡量测试有效性的指标。如果你的代码覆盖率低，可能表明你的代码中某些部分没有被测试，这可能导致未捕获的错误和其他问题。另一方面，如果代码覆盖率较高，你可以放心，你的代码经过了良好的测试。这并不保证你的代码没有错误，但它应该给你一个高度信心，即如果有错误，它们将在测试中被捕获。
- en: To determine the code coverage in our Python project, we will use the code coverage
    tool provided in the `coverage` library. The `coverage` library works by instrumenting
    our code to collect coverage data as it runs. It can collect coverage data for
    any Python code, including tests, scripts, and modules. By using a code coverage
    tool like `coverage`, we can better understand how much of our code is being exercised
    by our tests and identify areas of our code that may need more testing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定我们的Python项目的代码覆盖率，我们将使用`coverage`库中提供的代码覆盖率工具。`coverage`库通过在代码运行时对其进行仪器化来收集覆盖率数据。它可以收集任何Python代码的覆盖率数据，包括测试、脚本和模块。通过使用像`coverage`这样的代码覆盖率工具，我们可以更好地了解我们的代码中有多少部分被测试执行，并识别可能需要更多测试的代码区域。
- en: 'First, let’s install `coverage` using pip: `pip install coverage`. Next, let’s
    run our tests with coverage: `coverage run -m pytest`. This runs your tests and
    collects coverage data.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用pip安装`coverage`：`pip install coverage`。接下来，让我们使用覆盖率运行我们的测试：`coverage
    run -m pytest`。这将运行你的测试并收集覆盖率数据。
- en: Now we will generate a coverage report (see figure 6.3). The coverage report
    shows the code coverage for each file in our project. We can create a text-based
    coverage report using the `coverage report` command or generate an HTML version
    of the report using the `coverage html` command. The HTML version of the report
    is in the htmlcov directory.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将生成一个覆盖率报告（见图6.3）。覆盖率报告显示了项目中每个文件的代码覆盖率。我们可以使用`coverage report`命令创建基于文本的覆盖率报告，或使用`coverage
    html`命令生成报告的HTML版本。报告的HTML版本位于htmlcov目录中。
- en: '![](../Images/CH06_F03_Crocker2.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F03_Crocker2.png)'
- en: Figure 6.3 The code coverage report showing the coverage for each file in our
    ITAM system project
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 显示我们 ITAM 系统项目每个文件覆盖率的代码覆盖率报告
- en: 'Code coverage of 70% is a good start. In the real world, we would continue
    working with our team and generative AI pals to bring this measure up into the
    high 90s. Now we will transition to a new topic: using generative AI to describe
    a code listing to us.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率 70% 是一个好的开始。在现实世界中，我们会继续与我们的团队和生成式 AI 伙伴合作，将这个指标提高到 90% 以上。现在，我们将过渡到新的主题：使用生成式
    AI 向我们描述代码列表。
- en: 6.5 Transliterating code—from code to descriptions
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 从代码到描述的翻译
- en: 'Often, we are handed existing source code. Determining the exact entry point
    of this code, the purpose of the code, and the overall structure of a brownfield
    project can be challenging. Fortunately, this is one of the areas in which generative
    AIs truly excel: translating code into textual descriptions.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会收到现有的源代码。确定这段代码的确切入口点、代码的目的以及棕色地带项目的整体结构可能具有挑战性。幸运的是，这是生成式 AI 真正擅长的领域之一：将代码翻译成文本描述。
- en: 'To begin, we will copy the (buggy) code from the previous section into the
    Copilot Chat dialog box, prefixed with the following prompt (see figure 6.4):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从上一章节复制（有缺陷的）代码到 Copilot Chat 对话框中，前面加上以下提示（见图 6.4）：
- en: '|'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/logo-NC.png)'
- en: '| What does this code do? |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 这段代码做什么？ |'
- en: '![](../Images/CH06_F04_Crocker2.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F04_Crocker2.png)'
- en: Figure 6.4 The buggy code from the last section with a prompt asking Copilot
    Chat to explain this code to us
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 上次章节中的有缺陷的代码，提示 Copilot Chat 向我们解释此代码
- en: What is striking about the explanation in figure 6.5 is that Copilot Chat detects
    a bug in the code and offers suggestions for how to fix it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 中的解释引人注目的是，Copilot Chat 在代码中检测到一个错误，并提供了修复建议。
- en: '![](../Images/CH06_F05_Crocker2.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F05_Crocker2.png)'
- en: Figure 6.5 Copilot Chat explains the code’s purpose, identifies the bug, and
    suggests a fix.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 Copilot Chat 解释代码的目的，识别错误，并提出修复建议。
- en: 'Next we will ask it something more challenging: to explain the behavior test
    from listing 6.9 into the Copilot Chat window, and ask it what this class does.
    You will likely receive a response similar to the following.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将提出更具挑战性的问题：将列表 6.9 中的行为测试解释到 Copilot Chat 窗口中，并询问它这个类的作用。你可能会收到以下类似的回复。
- en: Listing 6.12 Copilot Chat explaining the behavior test we wrote earlier
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.12 Copilot Chat 解释我们之前编写的测试行为
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 6.6 Translating from one language to another
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 从一种语言翻译到另一种语言
- en: As remote as this may seem, you may find yourself looking through a code base
    written in a programming language with which you have only a passing familiarity.
    Alternatively, you may pine for a specific function from another language to be
    available in your current language. For example, what would the `Asset` and `FundingDetails`
    classes look like if they were rewritten in JavaScript? Well, let’s ask Copilot
    Chat.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这听起来可能很遥远，但你可能会发现自己正在查看一个用你只有肤浅了解的编程语言编写的代码库。或者，你可能渴望某个特定功能能在你当前的语言中使用。例如，如果将
    `Asset` 和 `FundingDetails` 类用 JavaScript 重新编写，它们会是什么样子？好吧，让我们问问 Copilot Chat。
- en: Listing 6.13 `Asset` and `FundingDetails` translated to JavaScript.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.13 将 `Asset` 和 `FundingDetails` 翻译成 JavaScript。
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You may think that translating a class or two is too easy. Well, we will attempt
    something more complex:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为翻译一个或两个类太简单了。好吧，我们将尝试更复杂的事情：
- en: '|'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/logo-NC.png)'
- en: '| What would the AssetManager behavior test look like if written in JavaScript?
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 如果用 JavaScript 编写，AssetManager 的行为测试会是什么样子？ |'
- en: Listing 6.14 `AssetManager` behavior test translated into JavaScript
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.14 将 `AssetManager` 行为测试翻译成 JavaScript
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Additionally, you may wish to have GPT rewrite the code in idiomatic JavaScript.
    You need only say
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能希望让 GPT 将代码重写为地道的 JavaScript。你只需要说
- en: '|'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/logo-NC.png)'
- en: '| Write AssetManager in idiomatic JavaScript |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 用地道的 JavaScript 编写 AssetManager |'
- en: Copilot Chat will inform you that it will define the `AssetManager` class using
    the class syntax introduced in ES6.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot Chat 会告诉你它将使用 ES6 中引入的类语法来定义 `AssetManager` 类。
- en: Listing 6.15 `AssetManager` class rewritten in idiomatic JavaScript
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.15 用地道的 JavaScript 重新编写的 `AssetManager` 类
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here’s an example of what the `AssetManager` behavior test might look like in
    JavaScript using the Jest testing framework (which Copilot Chat included without
    our suggestion).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 Jest 测试框架（Copilot Chat 没有建议就包含了）的 `AssetManager` 行为测试的例子。
- en: Listing 6.16 `AssetManager` behavior test in idiomatic JavaScript
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.16 `AssetManager`行为测试的惯用JavaScript
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we use the Jest testing framework to define a set of behavior
    tests for the `AssetManager` class. We are using the `describe` library to determine
    test suites and individual tests.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用Jest测试框架为`AssetManager`类定义一组行为测试。我们使用`describe`库来确定测试套件和单个测试。
- en: In each test, we create an instance of the `AssetManager` class and perform
    some operation on it, such as adding or removing an asset. We then use the `expect`
    function to make assertions about the behavior of the `AssetManager` class, such
    as checking that an asset was added to the asset list or that an asset was removed
    from the asset list. Note that the syntax for defining classes and constructors
    is slightly different in JavaScript than in Python, and we are using the required
    function to import the `AssetManager` and `Asset` classes from their respective
    modules.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试中，我们创建一个`AssetManager`类的实例并在其上执行一些操作，例如添加或删除资产。然后我们使用`expect`函数对`AssetManager`类的行为进行断言，例如检查资产是否添加到资产列表或资产是否从资产列表中删除。请注意，JavaScript中定义类和构造函数的语法与Python略有不同，我们使用所需的函数从各自的模块中导入`AssetManager`和`Asset`类。
- en: 'Finally, time for the big finale: we will start a new ChatGPT 4.0 session and
    paste in our Mermaid diagram from chapter 3\. Lead with this prompt:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候进入高潮部分了：我们将开始一个新的ChatGPT 4.0会话，并将第3章中的Mermaid图表粘贴进来。以下是一个提示：
- en: '|'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![logo-NC](../Images/logo-NC.png)'
- en: '| Here is a mermaid diagram of my application. Please implement in Golang.
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 这里是我的应用程序的Mermaid图表。请用Golang实现。|'
- en: Marvel as it returns the code, rendered in Golang.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 惊讶地看到它返回的代码，是用Golang渲染的。
- en: Listing 6.17 `Asset` class rewritten in idiomatic Golang
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.17 `Asset`类用惯用Golang重写
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, tell it to switch to Java.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，告诉它切换到Java。
- en: Listing 6.18 `Asset` class rewritten in idiomatic Java
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.18 `Asset`类用惯用Java重写
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Unit testing focuses on testing individual components or units of code to identify
    bugs and problems in specific units. Unit tests will be the most numerous in your
    codebase.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试专注于测试单个组件或代码单元以识别特定单元中的错误和问题。单元测试将在你的代码库中最为常见。
- en: Integration testing tests the interaction between different components or modules
    of the software to ensure seamless integration and detect communication problems.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试测试软件的不同组件或模块之间的交互，以确保无缝集成并检测通信问题。
- en: Behavior testing tests a system’s functionality from an end user’s perspective,
    ensuring that it meets requirements and specifications.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为测试从最终用户的角度测试系统的功能，确保它符合需求和规范。
- en: 'Mock objects simulate the behavior of natural objects in a controlled way and
    are useful for testing and simulating error conditions. Mock objects are especially
    good at mimicking parts of the system that are needed for the test to run but
    are outside the scope of the test: for example, if your class has a constructor
    argument for a database, but you do not want to test the database directly because
    the data may change, causing your test to be inconclusive, nonrepeatable, or nondeterministic.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟对象以受控的方式模拟自然对象的行为，对于测试和模拟错误条件非常有用。模拟对象特别擅长模仿测试所需但不在测试范围内的系统部分：例如，如果你的类有一个数据库构造函数参数，但你不想直接测试数据库，因为数据可能会变化，导致你的测试结果不确定、不可重复或非确定性。
- en: Cyclomatic complexity measures the number of independent paths through a software
    module, indicating complexity and potential for bugs.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圈复杂度衡量软件模块中独立路径的数量，表明复杂性和潜在的错误。
- en: Halstead complexity measures assess software complexity based on unique operators
    and operands, providing insights into code size and cognitive complexity.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Halstead复杂性度量基于独特的操作符和操作数来评估软件复杂性，提供了对代码大小和认知复杂性的见解。
- en: The maintainability index combines factors like cyclomatic complexity, lines
    of code, and Halstead measures to evaluate software maintainability.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性指数结合了圈复杂度、代码行数和Halstead度量等因素，以评估软件的可维护性。
- en: Code coverage is a metric for evaluating test effectiveness, indicating the
    extent to which code is tested and the potential for uncaught bugs. Generally,
    higher is better.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码覆盖率是评估测试有效性的指标，表明代码被测试的程度和未捕获错误的潜在可能性。通常，越高越好。
- en: Large language models allow you to navigate code in an unfamiliar programming
    language or translate features from another language in the current or preferred
    one.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型语言模型允许你在不熟悉的编程语言中导航代码，或者将另一种语言中的功能翻译到当前或首选语言中。
