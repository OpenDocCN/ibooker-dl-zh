- en: Chapter 2\. Getting Started with FastAPI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 快速入门 FastAPI
- en: By the end of this chapter, you should feel comfortable using the FastAPI web
    framework, setting up FastAPI projects, and articulating your tech stack decisions
    for building GenAI services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够熟练地使用 FastAPI 网络框架，设置 FastAPI 项目，并阐述你为构建 GenAI 服务所做的技术栈决策。
- en: Introduction to FastAPI
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FastAPI 简介
- en: '[FastAPI](https://oreil.ly/2xcoR) is an asynchronous gateway interface (ASGI)
    web framework that enables you to build lean APIs and backend web servers. Being
    an ASGI framework means that it can leverage concurrency to process web requests.
    It is [fast comparable to modern frameworks](https://oreil.ly/tgwEJ) but also
    ships with strong [Swagger/OpenAPI integrations for auto-documentation](https://oreil.ly/WlwOC),
    alongside built-in data validation and serialization features via [Pydantic](https://oreil.ly/5-EmU).^([1](ch02.html#id507))
    Effectively, FastAPI is a wrapper over the [Starlette framework](https://oreil.ly/tyKtQ),
    built by Encode, the same people who built the Django REST framework. It is light-weight
    and has a similar development experience.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[FastAPI](https://oreil.ly/2xcoR) 是一个异步网关接口（ASGI）网络框架，它使你能够构建精简的 API 和后端网络服务器。作为一个
    ASGI 框架，这意味着它可以利用并发来处理网络请求。它与现代框架相比速度很快（[https://oreil.ly/tgwEJ](https://oreil.ly/tgwEJ)），并且还提供了强大的
    [Swagger/OpenAPI 集成，用于自动文档](https://oreil.ly/WlwOC)，以及通过 [Pydantic](https://oreil.ly/5-EmU)
    提供的内置数据验证和序列化功能。[1](ch02.html#id507) 实际上，FastAPI 是 Encode 构建的 [Starlette 框架](https://oreil.ly/tyKtQ)的包装器，Encode
    同样是构建 Django REST 框架的人。它轻量级，具有类似的开发生态。'
- en: Before we discuss FastAPI in more detail, let’s set up your development environment
    with a running FastAPI application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地讨论 FastAPI 之前，让我们设置你的开发环境，并运行一个 FastAPI 应用程序。
- en: Setting Up Your Development Environment
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置你的开发环境
- en: Throughout the rest of this chapter, I will guide you through the installation
    process of FastAPI and its essential dependencies, enabling you to set up a basic
    web server. We will also install a selection of formatters, loggers, and linters
    that you can set up to enhance your development workflow.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我将指导你安装 FastAPI 及其基本依赖项的过程，使你能够设置一个基本的网络服务器。我们还将安装一系列格式化程序、记录器和代码检查器，你可以设置它们以增强你的开发工作流程。
- en: Warning
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Code examples in this book have been tested against Python 3.11\. Running code
    examples with other Python versions may result in issues. Furthermore, some deployment
    environments and package dependencies may not support the latest versions of Python.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码示例已针对 Python 3.11 进行测试。使用其他 Python 版本运行代码示例可能会导致问题。此外，一些部署环境和包依赖可能不支持
    Python 的最新版本。
- en: You can now get started with setting up your FastAPI project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以开始设置你的 FastAPI 项目了。
- en: Installing Python, FastAPI, and Required Packages
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Python、FastAPI 和所需包
- en: 'If you’re on Windows, you can use `conda` to create a virtual Python environment:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Windows 系统上，可以使用 `conda` 创建一个虚拟 Python 环境：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you’re on a macOS or a Linux system, you can create a virtual Python environment
    using `venv`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 macOS 或 Linux 系统，你可以使用 `venv` 创建一个虚拟 Python 环境：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`venv` creates your virtual environment in the `.venv` folder that you can
    activate by using this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`venv` 会将你的虚拟环境创建在 `.venv` 文件夹中，你可以通过以下方式激活它：'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the environment is activated, you can install the core packages needed
    to run the FastAPI server and serve requests from the OpenAI API:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 环境激活后，你可以安装运行 FastAPI 服务器和从 OpenAI API 处理请求所需的核心包：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `uvicorn` package is the bare-bones web server that FastAPI runs on. `fastapi`
    will also install its dependency packages such as `starlette` and `pydantic`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`uvicorn` 包是 FastAPI 运行的裸骨网络服务器。`fastapi` 也会安装其依赖包，例如 `starlette` 和 `pydantic`。'
- en: Creating a Simple FastAPI Web Server
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的 FastAPI 网络服务器
- en: Once FastAPI and its dependencies are installed, you are ready to start your
    own web server. To create a simple web server that has one endpoint in FastAPI,
    all you have to write is 15 lines of code. Create a *main.py* file in the root
    of your directory, as shown in [Example 2-1](#simple_fastapi_web_server).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 FastAPI 及其依赖项后，你就可以开始创建自己的网络服务器了。要创建一个在 FastAPI 中只有一个端点的简单网络服务器，你只需要编写 15
    行代码。在你的目录根目录下创建一个 *main.py* 文件，如[示例 2-1](#simple_fastapi_web_server) 所示。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For simplicity, [Example 2-1](#simple_fastapi_web_server) uses the OpenAI API.
    To run the code, you can get an API key from [OpenAI](https://oreil.ly/SZsuD),
    which requires a credit card. However, rest assured that other code examples in
    this book will use open source models as much as possible.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，[示例2-1](#simple_fastapi_web_server) 使用了OpenAI API。要运行代码，您可以从 [OpenAI](https://oreil.ly/SZsuD)
    获取API密钥，这需要一张信用卡。然而，请放心，本书中的其他代码示例将尽可能使用开源模型。
- en: Example 2-1\. Starter code for a simple FastAPI web server serving GPT-4o requests
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-1\. 简单FastAPI网络服务器启动代码，用于处理GPT-4o请求
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_getting_started_with_fastapi_CO1-1)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_getting_started_with_fastapi_CO1-1)'
- en: Create a FastAPI application object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个FastAPI应用程序对象。
- en: '[![2](assets/2.png)](#co_getting_started_with_fastapi_CO1-2)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_getting_started_with_fastapi_CO1-2)'
- en: You will need an [API key](https://oreil.ly/PP0nN) to use the OpenAI API.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用 [API密钥](https://oreil.ly/PP0nN) 来使用OpenAI API。
- en: '[![3](assets/3.png)](#co_getting_started_with_fastapi_CO1-3)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_getting_started_with_fastapi_CO1-3)'
- en: Use the `@app.get` decorator to create a `GET` endpoint on the `/chat` path.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@app.get` 装饰器在 `/chat` 路径上创建一个 `GET` 端点。
- en: '[![4](assets/4.png)](#co_getting_started_with_fastapi_CO1-5)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_getting_started_with_fastapi_CO1-5)'
- en: Make an API call to the OpenAI Completions API to generate a response from the
    `gpt-4o` model.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用OpenAI Completions API向 `gpt-4o` 模型发送API调用以生成响应。
- en: '[![5](assets/5.png)](#co_getting_started_with_fastapi_CO1-6)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_getting_started_with_fastapi_CO1-6)'
- en: Any data returned by the decorated function will be returned when you hit the
    root endpoint.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击根端点时，装饰函数返回的任何数据都将被返回。
- en: You can now start the server using the `fastapi dev` command, as shown here:^([2](ch02.html#id511))
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用 `fastapi dev` 命令启动服务器，如此处所示:^([2](ch02.html#id511))
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Your web server is now accessible from `http://127.0.0.1:8000` with two exposed
    endpoints at the root `/` and `/chat` routes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您的网络服务器现在可以通过 `http://127.0.0.1:8000` 访问，根目录 `/` 和 `/chat` 路由暴露了两个端点。
- en: 'If you visit `http://127.0.0.1:8000` in your browser, you should see the `{"status":
    "healthy"}` message. Also, when you visit `http://127.0.0.1:8000/chat`, you should
    see an inspirational message from OpenAI’s `gpt-4o` model.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您在浏览器中访问 `http://127.0.0.1:8000`，您应该看到 `{"status": "healthy"}` 消息。此外，当您访问
    `http://127.0.0.1:8000/chat` 时，您应该看到来自OpenAI的 `gpt-4o` 模型的鼓舞人心的信息。'
- en: Congratulations. You now have a fully working bare-bones generative AI service.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您。现在您已经拥有了一个完全工作的裸骨生成式AI服务。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: As you started the server in a dev model using the `fastapi dev` command, a
    file watcher process is listening for changes in your project and auto-updates
    the service as you update the code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您使用 `fastapi dev` 命令以开发模式启动了服务器，因此一个文件监视器进程正在监听您项目中的更改，并在您更新代码时自动更新服务。
- en: Feel free to change the default prompt and refresh the browser to see your changes
    reflected in real time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 随意更改默认提示并刷新浏览器，以实时查看您的更改。
- en: The `app` object—which is created from the `FastAPI` class—converts your Python
    function with a decorator into a Hypertext Transfer Protocol (HTTP) endpoint.
    You can trigger both endpoints by sending an HTTP request.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `FastAPI` 类创建的 `app` 对象将您的Python函数与装饰器转换为超文本传输协议（HTTP）端点。您可以通过发送HTTP请求触发这两个端点。
- en: Under the hood, the `uvicorn` package takes the `app` object and starts a web
    server running your FastAPI service.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，`uvicorn` 包接收 `app` 对象并启动一个运行FastAPI服务的网络服务器。
- en: In addition to getting a simple web server out of the box, you also get API
    documentation automatically generated for you. The documentation follows the OpenAPI
    standard and includes an `openapi.json` specification of your web service and
    a Swagger documentation page built from the same specification file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了获得一个简单的网络服务器之外，您还会自动获得为您生成的API文档。该文档遵循OpenAPI标准，包括您的网络服务的 `openapi.json` 规范和一个由同一规范文件构建的Swagger文档页面。
- en: You can access the auto-generated docs page by going to the `/docs` route of
    your server via `http://localhost:8000/docs`; you’ll see a page similar to [Figure 2-1](#swagger_docs).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问服务器的 `/docs` 路由来访问自动生成的文档页面，通过 `http://localhost:8000/docs`；您将看到一个类似于
    [图2-1](#swagger_docs) 的页面。
- en: '![bgai 0201](assets/bgai_0201.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0201](assets/bgai_0201.png)'
- en: Figure 2-1\. Auto-generated Swagger documentation of the API
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-1\. API自动生成的Swagger文档
- en: From the Swagger docs page, you can send requests to your API to quickly test
    an endpoint. The docs page will also take care of sending the correct request
    headers, methods, and parameters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Swagger 文档页面，您可以发送请求到您的 API，以快速测试一个端点。该文档页面还将负责发送正确的请求头、方法和参数。
- en: What I love about the Swagger docs page is that you can quickly iterate over
    various implementations using the user interface, which can be quicker than writing
    tests when iterating over the design of your APIs. However, this does not replace
    the traditional testing that can check every endpoint when you make changes. As
    your application grows, it is still worth writing tests. Once your endpoint signatures
    are further established, you can write `pytest` tests to systematically test your
    web service from end to end.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢 Swagger 文档页面的地方在于，您可以使用用户界面快速迭代各种实现，这比迭代您的 API 设计时编写测试要快。然而，这并不能取代您在更改时检查每个端点的传统测试。随着您的应用程序的增长，编写测试仍然值得。一旦您的端点签名进一步确立，您就可以编写
    `pytest` 测试，以系统地从端到端测试您的网络服务。
- en: In addition to auto-documentation, FastAPI ships with auto-serialization and
    validation of data. In [Example 2-1](#simple_fastapi_web_server), we returned
    a dictionary in the root controller as you visited `http://localhost:8000`. There
    is a bit of magic that must happen for data to show up in your browser. The data
    must first be serialized from a Python object such as a dictionary or a list into
    a JavaScript Object Notation (JSON) string first. Afterward, it’s transferred
    over the web and deserialized back into a JavaScript object by your browser client
    once transmission is completed. This is effectively how applications around the
    web “talk” to each other.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自动文档之外，FastAPI 还提供了数据的自动序列化和验证。在 [示例 2-1](#simple_fastapi_web_server) 中，我们在根控制器中返回了一个字典，就像您访问
    `http://localhost:8000` 一样。为了让数据出现在您的浏览器中，必须发生一些魔法。数据必须首先从字典或列表等 Python 对象序列化为
    JavaScript 对象表示法 (JSON) 字符串。然后，它通过网络传输，并在传输完成后由您的浏览器客户端反序列化为 JavaScript 对象。这就是网络上的应用程序如何“交谈”的有效方式。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Serialization is required when using HTTP for data transmissions, as only text
    or binary data can be transferred via HTTP.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 HTTP 进行数据传输时需要序列化，因为只有文本或二进制数据可以通过 HTTP 传输。
- en: Now that you have a working FastAPI server, let’s look at FastAPI’s features
    and benefits that you can use in your project.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有一个工作的 FastAPI 服务器，让我们看看 FastAPI 的特性和优势，您可以在您的项目中使用它们。
- en: FastAPI Features and Advantages
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FastAPI 特性和优势
- en: You want a suitable web framework that allows you to effortlessly create your
    generative AI services, without any unnecessary struggles. This framework should
    include all the essential elements for security, authentication, and performance,
    while still granting you the flexibility to incorporate any additional features
    and integrations required as your application grows in complexity.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个合适的网络框架，它允许您轻松地创建您的生成式 AI 服务，而无需任何不必要的麻烦。这个框架应该包括所有安全、身份验证和性能的基本元素，同时仍然赋予您灵活性，以根据您的应用程序复杂性的增长添加任何额外的功能和集成。
- en: FastAPI can meet most of these criteria, as it hosts several features and advantages
    out of the box. However, as you’ll learn more about [FastAPI limitations](#fastapi_limitations)
    later in this chapter, advanced use cases like resource-intensive AI workloads
    may require specialized web frameworks or solutions, as will be discussed in [Chapter 3](ch03.html#ch03).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 可以满足这些标准中的大多数，因为它自带了几个特性和优势。然而，正如您在本章后面将了解到的那样，[FastAPI 的局限性](#fastapi_limitations)，像资源密集型
    AI 工作负载这样的高级用例可能需要专门的网络框架或解决方案，正如将在 [第 3 章](ch03.html#ch03) 中讨论的那样。
- en: For now, let’s review FastAPI’s features and benefits before discussing its
    limitations in the context of building generative AI services.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在讨论构建生成式 AI 服务时 FastAPI 的局限性的背景下，让我们先回顾 FastAPI 的特性和优势。
- en: Inspired by Flask Routing Pattern
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受 Flask 路由模式的启发
- en: In both Flask and FastAPI, you can create any route by decorating a function
    with a specialized decorator. You can then configure the routes to accept and
    validate headers, cookies, body, path, and query parameters to support your implementation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flask 和 FastAPI 中，您可以通过使用专门的装饰器来装饰一个函数来创建任何路由。然后，您可以配置路由以接受和验证头信息、cookie、正文、路径和查询参数，以支持您的实现。
- en: Handling Asynchronous and Synchronous Operations
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异步和同步操作
- en: When building services, your service must be able to handle multiple requests
    by several users to increase usage efficiency as demand scales. FastAPI can seamlessly
    [handle both synchronous and asynchronous functions in your application](https://oreil.ly/gNYMg)
    to enable concurrency from the get-go.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建服务时，您的服务必须能够处理多个用户请求，以增加使用效率，并随着需求的增加而扩展。FastAPI 可以无缝 [处理您应用程序中的同步和异步函数](https://oreil.ly/gNYMg)，从而从一开始就启用并发。
- en: As we will discuss in detail in [Chapter 5](ch05.html#ch05), if you define an
    asynchronous route using `async def`, FastAPI will run it on the main thread on
    the main event loop. On the other hand, if you define a synchronous route (not
    declared with the `async` keyword), FastAPI will run it on a *thread worker* for
    handling concurrent workloads.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在 [第 5 章](ch05.html#ch05) 中详细讨论的那样，如果您使用 `async def` 定义异步路由，FastAPI 将在主线程的主事件循环上运行它。另一方面，如果您定义同步路由（未使用
    `async` 关键字声明），FastAPI 将在 *线程工作者* 上运行它以处理并发工作负载。
- en: Warning
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: There is additional overhead to running threaded operations compared to running
    them asynchronously. Therefore, having many synchronous routes can still limit
    the scalability of your application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与异步运行相比，运行线程操作有额外的开销。因此，拥有许多同步路由仍然可能限制您应用程序的可扩展性。
- en: As a result, concurrent requests won’t block the main server thread. This is
    particularly useful when dealing with input/output operations, such as querying
    databases, exchanging data with a graphical processing units (GPU),^([3](ch02.html#id527))
    or making HTTP requests.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，并发请求不会阻塞主服务器线程。这在处理输入/输出操作时尤其有用，例如查询数据库、与图形处理单元（GPU）交换数据，^([3](ch02.html#id527))
    或发送 HTTP 请求。
- en: Built-In Support for Background Tasks
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置后台任务支持
- en: You can build routes capable of handling long-running tasks (e.g., sending emails)
    without the need of external libraries (e.g., `celery`). FastAPI includes a [background
    tasks feature](https://oreil.ly/aO6ml)^([4](ch02.html#id530)) for working with
    systems that need time to process data but you don’t want them to delay returning
    the responses to requests.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以构建能够处理长时间运行的任务（例如，发送电子邮件）的路由，而无需外部库（例如，`celery`）。FastAPI 包含一个 [后台任务功能](https://oreil.ly/aO6ml)^([4](ch02.html#id530))，用于处理需要时间处理数据但不想延迟响应请求的系统。
- en: Not all tasks can be responded to within the patience tolerance of your users.
    You do not want to keep them waiting while the process is continuing to finish.
    You can hand off the long-running operation to a background task running on a
    separate thread, after you respond to the client. As a response, you can then
    let clients know that your service has accepted and queued their request to process
    it in the background.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有任务都能在用户的耐心容忍度内得到响应。您不希望他们在处理过程继续完成时等待。您可以在响应客户端后，将长时间运行的操作交给在单独线程上运行的背景任务。作为回应，您可以通知客户端，您的服务已接受并将他们的请求排队以在后台处理。
- en: As an example, in GenAI services you can use background tasks to process large
    uploaded documents into a vector database without blocking the server. This allows
    the server to handle other requests while the document processing happens in the
    background.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 GenAI 服务中，您可以使用后台任务将大型上传文档处理成向量数据库，而不会阻塞服务器。这允许服务器在后台处理文档时处理其他请求。
- en: You’ll learn how to build such a system in [Chapter 5](ch05.html#ch05).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在 [第 5 章](ch05.html#ch05) 中学习如何构建这样的系统。
- en: Custom Middleware and CORS Support
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义中间件和 CORS 支持
- en: FastAPI enables you to add [middleware components](https://oreil.ly/uvlLC) to
    your app router to intercept the communication between your API endpoints and
    the clients. Each middleware, sitting in front of your endpoints, allows you to
    access the request and response objects to modify them as needed. You can add
    logic around how requests should be processed before they’re handed off to the
    route handlers. Once the response is generated, you can then perform operations
    on the response—such as modifying headers, logging operations, and setting cookies—before
    sending it off to the client.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 允许您向您的应用程序路由器添加 [中间件组件](https://oreil.ly/uvlLC)，以拦截您的 API 端点和客户端之间的通信。每个中间件都位于您的端点之前，允许您访问请求和响应对象并根据需要修改它们。您可以在将请求交给路由处理程序之前添加逻辑来处理请求。一旦生成响应，您就可以在将其发送到客户端之前对响应执行操作——例如修改头部、记录操作和设置cookie。
- en: A common pattern in backend development is to use middleware to [add extra headers
    to a response](https://oreil.ly/Yfsqg), perform basic checks on incoming requests,
    support [CORS requests](https://oreil.ly/6u1dI), [log and monitor communications](ch03.html#middleware_monitoring),
    and much more. You can even take advantage of third-party and [custom middleware](https://oreil.ly/AJKJt).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 后端开发中的一种常见模式是使用中间件来[向响应添加额外的头信息](https://oreil.ly/Yfsqg)，对传入的请求进行基本检查，支持[CORS
    请求](https://oreil.ly/6u1dI)，[记录和监控通信](ch03.html#middleware_monitoring)，以及更多。你甚至可以利用第三方和[自定义中间件](https://oreil.ly/AJKJt)。
- en: Freedom to Customize Any Service Layer
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自由定制任何服务层
- en: There are times when you may want to break away from the limitations of your
    current web framework. FastAPI provides a solution to this by allowing you to
    define custom classes that inherit base classes of Starlette—the underlying web
    framework. For instance, you can [override default exception handlers](https://oreil.ly/qgvgO),
    add [custom ASGI middleware](https://oreil.ly/1A8OD), or even [create custom responses](https://oreil.ly/jLXUf).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能想要摆脱当前 Web 框架的限制。FastAPI 通过允许你定义继承自 Starlette 基类（底层 Web 框架）的定制类来解决这个问题。例如，你可以[重写默认异常处理器](https://oreil.ly/qgvgO)，添加[自定义
    ASGI 中间件](https://oreil.ly/1A8OD)，或者甚至[创建自定义响应](https://oreil.ly/jLXUf)。
- en: With the power of Pydantic or [FastAPI’s encoders](https://oreil.ly/MJmqJ),
    you can also effortlessly create your own [custom serializers](https://oreil.ly/UnzRk)
    to adjust how datetime objects are handled.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Pydantic 或 [FastAPI 的编码器](https://oreil.ly/MJmqJ)的力量，你也可以轻松地创建自己的[自定义序列化器](https://oreil.ly/UnzRk)，以调整处理
    datetime 对象的方式。
- en: This enables you to implement features according to your preferences without
    having to struggle against FastAPI.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得你可以根据你的偏好实现功能，而无需与 FastAPI 奋斗。
- en: Data Validation and Serialization
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据验证和序列化
- en: For applications that handle large amounts of data, it is important that the
    data you are about to process is clean and in a known format.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理大量数据的应用程序，确保你即将处理的数据是干净且格式已知的是非常重要的。
- en: As the complexity of your service grows, you will want to perform data validation
    and serialization. In FastAPI, you can use Pydantic to automatically serialize
    common data types (e.g., lists, dictionaries, primitives) when returning them
    in API routes. You can also define your own Pydantic schemas for request and response
    data to perform stricter data validation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的服务复杂性的增长，你将想要执行数据验证和序列化。在 FastAPI 中，你可以使用 Pydantic 在 API 路由返回时自动序列化常见数据类型（例如，列表、字典、原语）。你还可以为请求和响应数据定义自己的
    Pydantic 模式，以执行更严格的数据验证。
- en: For instance, you can validate a user’s password on account creation to match
    your security policies, as shown in [Example 2-2](#data_validation).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以在创建账户时验证用户的密码，以匹配你的安全策略，如[示例 2-2](#data_validation)所示。
- en: Example 2-2\. Validating user passwords in FastAPI using a Pydantic schema
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-2\. 在 FastAPI 中使用 Pydantic 模式验证用户密码
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_getting_started_with_fastapi_CO2-1)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_getting_started_with_fastapi_CO2-1)'
- en: Define a Pydantic model with custom data validation on the `password` field.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`password`字段上定义具有自定义数据验证的 Pydantic 模型。
- en: '[![2](assets/2.png)](#co_getting_started_with_fastapi_CO2-2)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_getting_started_with_fastapi_CO2-2)'
- en: Raise a `ValueError` if any of the password policies are not met.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何密码策略未得到满足，则抛出`ValueError`。
- en: This enables you to catch, handle, and protect your services from data issues
    that are not captured by static type checkers like `mypy`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得你可以捕获、处理并保护你的服务免受静态类型检查器（如 `mypy`）未捕获的数据问题。
- en: Pydantic validators also allow you to validate more complex data types at runtime
    like emails, URLs, UUIDs, and more. [Chapter 4](ch04.html#ch04) will go into more
    detail on how to perform data validation using Pydantic.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 验证器还允许你在运行时验证更复杂的数据类型，如电子邮件、URL、UUID 等。[第 4 章](ch04.html#ch04)将更详细地介绍如何使用
    Pydantic 进行数据验证。
- en: Rich Ecosystem of Plug-Ins
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丰富的插件生态系统
- en: Plug-ins are Python packages that hook into FastAPI internals and existing features.
    They are similar to any other Python package you install and import into your
    scripts, and they require minimal configurations after installation. Integrating
    them means extending the functionalities of your service without having to deal
    with order of integrations or compatibility issues. You can also remove them without
    breaking your app.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是钩入FastAPI内部和现有功能的Python包。它们类似于您安装并导入脚本中的任何其他Python包，并且安装后需要最少的配置。集成它们意味着在不处理集成顺序或兼容性问题的情况下扩展您服务的功能。您也可以在不破坏应用程序的情况下移除它们。
- en: Some well-known plug-ins include FastAPI Filters, Auth Users, Rate Limiting
    and several others, which you can view at the [Awesome FastAPI GitHub repository](https://oreil.ly/nKbvP).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一些知名的插件包括FastAPI过滤器、认证用户、速率限制等，您可以在[Awesome FastAPI GitHub仓库](https://oreil.ly/nKbvP)中查看。
- en: Automatic Documentation
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动文档
- en: With FastAPI, Swagger UI documentation is auto-generated for you to view and
    test any routes you create, as you saw in [Figure 2-1](#swagger_docs). During
    development, having an interactive docs page allows for easier and faster debugging
    and prototyping of your routes until you build and maintain your own test suites.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FastAPI，Swagger UI文档会自动为您生成，以便您查看和测试您创建的任何路由，正如您在[图2-1](#swagger_docs)中看到的。在开发期间，拥有一个交互式文档页面可以更容易、更快地调试和原型设计您的路由，直到您构建和维护自己的测试套件。
- en: As you build new endpoints, you may often want to revisit the `/docs` page to
    test them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建新的端点时，您可能经常想要重新访问`/docs`页面来测试它们。
- en: You can configure a redirect from the base URL `/` to the `/docs` endpoint to
    facilitate quicker access to the documentation page, as shown in [Example 2-3](#setting_up_redirect).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置从基URL`/`到`/docs`端点的重定向，以方便快速访问文档页面，如[示例2-3](#setting_up_redirect)所示。
- en: Example 2-3\. Setting up redirect to the auto-generated docs page
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-3. 设置自动生成文档页面的重定向
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_getting_started_with_fastapi_CO3-1)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)(#co_getting_started_with_fastapi_CO3-1)'
- en: Set up a handler for the base root handler, but don’t include it in OpenAPI
    specifications and the documentation page.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 设置基础根处理器的处理程序，但不要将其包含在OpenAPI规范和文档页面中。
- en: '[![2](assets/2.png)](#co_getting_started_with_fastapi_CO3-2)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)(#co_getting_started_with_fastapi_CO3-2)'
- en: Return a redirect response to the `/docs` page with a redirection status code
    for the browsers to perform the redirect.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个重定向响应到`/docs`页面，带有重定向状态码，以便浏览器执行重定向。
- en: With [Example 2-3](#setting_up_redirect) implemented, you can access the `/docs`
    page during local development whenever you visit the base URL `/` of the service.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现[示例2-3](#setting_up_redirect)，您可以在访问服务的基URL`/`时访问`/docs`页面。
- en: In production, unless your API is public, disable this redirection and hide
    the `/docs` routes by default for enhanced security.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，除非您的API是公开的，否则禁用此重定向，并默认隐藏`/docs`路由以提高安全性。
- en: Warning
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If your API is publicly accessible in production, you may expose unsecured endpoints
    and sensitive information about your API. Therefore, it is [best practice to turn
    off the documentation page](https://oreil.ly/Dk45G).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的API在生产环境中公开访问，您可能会暴露未受保护的端点和关于API的敏感信息。因此，[关闭文档页面是最佳实践](https://oreil.ly/Dk45G)。
- en: Instead, you can show the `/docs` page explicitly on selected environments only.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以在选定的环境中显式显示`/docs`页面。
- en: For public APIs, you can set the root handler `/` to return your API version
    instead of redirecting to the `/docs` page.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于公开API，您可以将根处理程序`/`设置为返回您的API版本，而不是重定向到`/docs`页面。
- en: Dependency Injection System
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入系统
- en: Another powerful component of FastAPI is its [dependency injection system](https://oreil.ly/eAIwR)
    based on a development pattern called *inversion of control*. Using this pattern,
    you break down a function into a series of functions that you inject into other
    functions as *dependencies*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI的另一个强大组件是其基于称为*控制反转*的开发模式的依赖注入系统。[Example 2-3](#setting_up_redirect)实现了，您可以在本地开发期间访问`/docs`页面，无论何时访问服务的基URL`/`。
- en: In addition to helping structure your application logic, dependencies can help
    you reduce duplication. They let you share and reuse logic across your API, reuse
    open database connections, enforce security such as authentication or authorization
    requirements, and much more.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了帮助结构化您的应用程序逻辑外，依赖项还可以帮助您减少重复。它们允许您在API中共享和重用逻辑，重用公开数据库连接，强制执行安全措施，如身份验证或授权要求，等等。
- en: For example, you can specify common query parameters across API routes (e.g.,
    for pagination and filtering), as shown in [Example 2-4](#dependency_pagination).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以在 API 路由中指定常见的查询参数（例如，用于分页和过滤），如[示例 2-4](#dependency_pagination)所示。
- en: Example 2-4\. Reducing duplication using a pagination dependency
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-4\. 使用分页依赖项减少重复
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In FastAPI, dependencies are also cached within *the context of a single request*
    to prevent duplicate computations. This means a dependency function is executed
    only once per request, and its result is reused for the duration of that request
    if needed again. However, in a new request, the dependency function is executed
    again.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FastAPI 中，依赖项也缓存于单个请求的上下文中，以防止重复计算。这意味着依赖函数在每个请求中只执行一次，如果需要再次使用，则在整个请求期间重用其结果。然而，在新的请求中，依赖函数将再次执行。
- en: Having to manage database connections or checking user credentials in every
    route handler is tedious and violates the *Don’t Repeat Yourself* (DRY) principles
    of programming. Another great use case of the dependency injection system is when
    you create a database connection and want to reuse that connection to perform
    multiple fetch requests while processing a single request.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个路由处理器中管理数据库连接或检查用户凭证是繁琐的，并且违反了编程的“不要重复自己”（DRY）原则。依赖注入系统的另一个很好的用例是在创建数据库连接并希望重用该连接以在处理单个请求时执行多个获取请求时。
- en: You can create dependencies for your route controller functions, as shown in
    [Example 2-5](#fastapi_dependency).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为您的路由控制器函数创建依赖项，如[示例 2-5](#fastapi_dependency)所示。
- en: Example 2-5\. Dependency injection in FastAPI
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-5\. FastAPI 中的依赖注入
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_getting_started_with_fastapi_CO4-1)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)(#co_getting_started_with_fastapi_CO4-1)'
- en: Implement a function to create and manage a database session, which can be used
    as a dependency in route handlers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个创建和管理数据库会话的函数，该函数可以用作路由处理器的依赖项。
- en: '[![2](assets/2.png)](#co_getting_started_with_fastapi_CO4-2)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)(#co_getting_started_with_fastapi_CO4-2)'
- en: Yield the open database session, making it available for any function that depends
    on `get_db`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 产生开放的数据库会话，使其对任何依赖于 `get_db` 的函数可用。
- en: '[![3](assets/3.png)](#co_getting_started_with_fastapi_CO4-3)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)(#co_getting_started_with_fastapi_CO4-3)'
- en: Close the database session after the request is processed, preventing resource
    leaks.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求处理完毕后关闭数据库会话，以防止资源泄露。
- en: '[![4](assets/4.png)](#co_getting_started_with_fastapi_CO4-4)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)(#co_getting_started_with_fastapi_CO4-4)'
- en: Inject the `get_db` dependency into the route handler to create and reuse the
    same database session during the request lifecycle. FastAPI will also automatically
    expose parameters within dependencies on your endpoint.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `get_db` 依赖项注入到路由处理器中，以在请求生命周期中创建和重用相同的数据库会话。FastAPI 还会自动在您的端点中公开依赖项内的参数。
- en: '[![5](assets/5.png)](#co_getting_started_with_fastapi_CO4-5)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)(#co_getting_started_with_fastapi_CO4-5)'
- en: Reuse the injected database session to perform multiple database operations
    within a single request to return a user’s messages.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 重复使用注入的数据库会话，在单个请求中执行多个数据库操作，以返回用户的消息。
- en: As shown in [Example 2-5](#fastapi_dependency), you can inject these dependencies
    into other functions by passing them as parameters to `Depends()` for FastAPI
    to evaluate and cache your function outputs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 2-5](#fastapi_dependency)所示，您可以通过将它们作为参数传递给 `Depends()` 来将这些依赖项注入到其他函数中，以便
    FastAPI 评估和缓存您的函数输出。
- en: Here you define a utility function for creating a database session and then
    use it as a dependency of the `get_current_user_messages` function to inject the
    created database session.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您定义了一个用于创建数据库会话的实用函数，然后将其用作 `get_current_user_messages` 函数的依赖项，以注入创建的数据库会话。
- en: This dependency system is just one of many other features that ship with FastAPI
    that speed up and ease the process of building backend services.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖系统只是 FastAPI 随附的许多其他功能之一，这些功能可以加快并简化构建后端服务的流程。
- en: Lifespan Events
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期事件
- en: '[FastAPI’s lifespan events](https://oreil.ly/Cn2DB) are excellent for handling
    initialization and cleanup of your service when you need to set up resources that
    can be shared between requests.^([5](ch02.html#id554)) During server startup,
    you can create database connection pools or load GenAI models into memory for
    reuse across requests. Afterward, before server shutdown, you can clean up by
    unloading AI models, closing connection pools, deleting temporary artifacts, and
    logging events.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[FastAPI的生命周期事件](https://oreil.ly/Cn2DB)在处理服务的初始化和清理方面非常出色，尤其是在您需要设置可以在请求之间共享的资源时。在服务器启动时，您可以创建数据库连接池或将GenAI模型加载到内存中以便在请求之间重复使用。之后，在服务器关闭之前，您可以卸载AI模型、关闭连接池、删除临时工件并记录事件。'
- en: By using lifespan events, your FastAPI service performs long-running operations
    like model loading at the start, before serving requests, and keeps it loaded
    for reuse among requests. During server shutdown, you can then gracefully finish
    all remaining and queued requests before running any cleanup operations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用生命周期事件，您的FastAPI服务在启动时执行长时间运行的操作，如模型加载，在处理请求之前，并保持加载状态以便在请求之间重复使用。在服务器关闭时，您可以在运行任何清理操作之前优雅地完成所有剩余的和排队的请求。
- en: Security and Authentication Components
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全和身份验证组件
- en: As with any other framework, you will need security and authentication components
    to secure your service. FastAPI doesn’t lock you in a specific implementation
    of the security and authentication layer. It gives you a set of [security components](https://oreil.ly/zlAgl)
    so you can protect your services based on your own needs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他框架一样，您将需要安全和身份验证组件来保护您的服务。FastAPI不会将您锁定在特定的安全和身份验证层实现中。它提供了一套[安全组件](https://oreil.ly/zlAgl)，以便您可以根据自己的需求保护您的服务。
- en: You’ll learn how to implement an authentication layer from scratch for your
    GenAI services in [Chapter 8](ch08.html#ch08).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在第8章（关于为GenAI服务从头实现身份验证层）中学习如何实现。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you don’t want to implement an authentication layer from scratch, then you
    can also reach out for third-party plug-ins like [FastAPI Users](https://oreil.ly/eEtMe)
    that automatically take care of that for you.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想从头开始实现身份验证层，那么您也可以寻求第三方插件的帮助，例如[FastAPI Users](https://oreil.ly/eEtMe)，它可以自动为您处理这些工作。
- en: You can also integrate with third-party authentication providers for [single
    sign-on flows in FastAPI](https://oreil.ly/vIqCd) in enterprise environments.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在企业环境中将第三方身份验证提供商集成到FastAPI的[单点登录流程](https://oreil.ly/vIqCd)中。
- en: Bidirectional Web Socket, GraphQL, and Custom Response Support
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双向WebSocket、GraphQL和自定义响应支持
- en: When building services, you will often need to move beyond the standard *REST*
    *endpoints*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建服务时，您通常会需要超越标准的*REST* *端点*。
- en: If you’re building a chat application, you may also need real-time client-server
    communication or longer-duration connections where data is streamed in a direction.
    WebSocket (WS) and server-sent events (SSE) endpoints can help you stream generative
    model outputs to the clients, as you will see in [Chapter 6](ch06.html#ch06) on
    real-time communication with AI services.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建聊天应用，您可能还需要实时客户端-服务器通信或长时间连接，其中数据以特定方向流式传输。WebSocket (WS) 和服务器发送事件 (SSE)
    端点可以帮助您将生成模型输出流式传输到客户端，正如您将在第6章（关于与AI服务的实时通信）中看到的。
- en: In other cases, you may want to use [GraphQL in FastAPI](https://oreil.ly/SL62a)
    to expose endpoints that can return dynamic schemas based on the request. FastAPI
    can use the [`strawberry` package](https://oreil.ly/wIzvi)^([6](ch02.html#id561))
    to leverage GraphQL in using dynamic schemas for your API service so that clients
    can select fields they want from a resource to avoid over-fetching data from your
    service. However, we won’t be covering GraphQL usage in this book.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，您可能希望使用[FastAPI中的GraphQL](https://oreil.ly/SL62a)来公开可以基于请求返回动态模式的端点。FastAPI可以使用`strawberry`包^([6](ch02.html#id561))来利用GraphQL在API服务中使用动态模式，以便客户端可以从资源中选择他们想要的字段，从而避免从您的服务中过度获取数据。然而，我们不会在本书中涵盖GraphQL的使用。
- en: Modern Python and IDE Integration with Sensible Defaults
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代Python和IDE集成，具有合理的默认设置
- en: Since the FastAPI tech stack is built on modern Python (e.g., with type annotations
    and doc-strings), all IDE linters and formatters can natively check and format
    your codebase. The defaults are also sufficient to get you started by importing
    and instantiating the FastAPI class. Because everything ties neatly with modern
    IDE and Python features, anyone can easily get started building, testing, debugging,
    and deploying their own FastAPI services.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 FastAPI 技术栈建立在现代 Python（例如，使用类型注解和文档字符串）之上，所有 IDE 检查器和格式化工具都可以原生地检查和格式化你的代码库。默认设置也足够让你通过导入和实例化
    FastAPI 类开始。因为所有东西都与现代 IDE 和 Python 功能紧密相连，任何人都可以轻松开始构建、测试、调试和部署自己的 FastAPI 服务。
- en: FastAPI Project Structures
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FastAPI 项目结构
- en: Often when you are working on a real-world project, you will end up building
    services that will span multiple modules, packages, and nested directories. The
    decision on how to structure your project is going to be totally up to you.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通常当你在一个现实世界项目中工作时，你最终会构建跨越多个模块、包和嵌套目录的服务。如何结构化你的项目将完全取决于你。
- en: This is where most people will struggle and end up with a codebase too overwhelming
    to navigate. You will end up frustrated, having to understand the codebase and
    project structure before you can contribute to it. At some point, the complexity
    will grow so much that you will dread touching the project again.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是大多数人会感到困难并最终得到一个过于复杂难以导航的代码库的地方。你将感到沮丧，不得不在能够为项目做出贡献之前理解代码库和项目结构。在某个时候，复杂性会增长到如此程度，以至于你将害怕再次接触这个项目。
- en: Some files will end up too large to read with bloated functions, or there will
    be too many files scattered all over the place. You may also end up having millions
    of import errors or circular dependencies breaking your application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文件可能会因为臃肿的函数而变得难以阅读，或者会有太多的文件散布在各个地方。你也可能会遇到数百万个导入错误或循环依赖破坏你的应用程序。
- en: Learning to structure larger applications will be even more important when working
    with generative AI models. These models often need dependencies and additional
    utility functions to support them. Therefore, you will have to add a layer of
    complexity for your models on top of existing applications layers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当与生成式 AI 模型一起工作时，学习如何结构化大型应用将变得更加重要。这些模型通常需要依赖项和额外的实用函数来支持它们。因此，你将不得不在现有应用程序层之上为你的模型添加一层复杂性。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Compared to opinionated frameworks such as Django, you need to follow good practices
    for having success with larger projects in nonopinionated frameworks such as FastAPI.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与像 Django 这样的有观点的框架相比，在非观点框架如 FastAPI 中成功处理大型项目需要遵循良好的实践。
- en: Over the past few years working with FastAPI and data science applications,
    I have seen many developers come up with their own cookie-cutter templates for
    starting FastAPI projects. Some even recommend following a structure popularized
    by the Netflix Dispatch FastAPI project for larger API applications that has inspired
    other templates.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年与 FastAPI 和数据科学应用合作的过程中，我看到了许多开发者为自己的 FastAPI 项目创造了各自的模板。有些人甚至推荐遵循 Netflix
    Dispatch FastAPI 项目推广的结构，该结构为大型 API 应用程序提供了灵感，并启发了其他模板。
- en: When it comes to building real-world applications, you must do everything you
    can to keep the codebase as structured as possible. This is for your own benefit—to
    help you and others in your team in understanding the code in the future.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到构建现实世界应用时，你必须尽你所能使代码库尽可能有结构。这是为了你自己的利益——帮助你和你团队中的其他人未来理解代码。
- en: You know you have a good project structure if you can find any function or component
    within your codebase. If you start questioning the purpose of a directory or spending
    hours searching for a piece of code, then your project structure might be unclear
    and too complex to understand.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能在你的代码库中找到任何函数或组件，你就知道你有一个好的项目结构。如果你开始质疑目录的目的，或者花费数小时寻找一段代码，那么你的项目结构可能不够清晰，过于复杂难以理解。
- en: 'In these instances, you can refer to a few common project structures that have
    recently become popular in the FastAPI community. There are a few project structures
    you can adopt: flat, nested, and modular.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，你可以参考一些最近在 FastAPI 社区中变得流行的常见项目结构。你可以采用以下几种项目结构：扁平、嵌套和模块化。
- en: Let us take a detailed look at each one.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一详细地看看每一个。
- en: Flat Structure
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扁平结构
- en: A flat structure is one in which the application files remain at the root of
    your project with no nested directories. You may group all your files under a
    single directory for better organization.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 扁平结构是一种应用文件保持在项目根目录，没有嵌套目录的结构。你可以将所有文件分组在单个目录下，以获得更好的组织。
- en: The main idea here is to keep all similar code in modules and placed together
    near the root of your project. For instance, put all your database models in *models.py*
    or your endpoints in *routes.py*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要思想是将所有类似代码放在模块中，并放置在项目根目录附近。例如，将所有数据库模型放在 *models.py* 中，或者将端点放在 *routes.py*
    中。
- en: By far, the most common project structure is flat due to its simplicity and
    ease of use. This structure is often great for building the first version of a
    service or a tiny microservices. [Example 2-6](#flat_structure) is what the structure
    could look like.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最常见的项目结构是扁平的，因为它简单易用。这种结构通常非常适合构建服务或微服务的第一个版本。[示例 2-6](#flat_structure)
    展示了这种结构可能的样子。
- en: Example 2-6\. A flat FastAPI project structure
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-6\. 扁平 FastAPI 项目结构
- en: '[PRE10]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can see in the structure shown in [Example 2-6](#flat_structure) that you
    have a few files that contain the core of your application logic. If you are building
    a microservice with FastAPI, by definition, you will want to maintain a flat structure
    for simplicity.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [示例 2-6](#flat_structure) 中看到的结构中看到，你有几个包含应用程序核心逻辑的文件。如果你使用 FastAPI 构建微服务，根据定义，你将希望为了简单起见保持扁平结构。
- en: The simplicity of the flat structure allows you to focus on the development
    rather than the structure. There are few files to worry about. You also don’t
    need to care about coupling, decomposition, or reuse as there are few lines of
    codes to deal with.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 扁平结构的简单性让你可以专注于开发而不是结构。要担心的问题文件很少。你也不必担心耦合、分解或重用，因为要处理的代码行数很少。
- en: On the other hand, the flat structure will be hard to maintain as your project
    grows in complexity. At this point, it makes sense to break down the global Python
    modules into packages of their own using the nested structure.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，随着项目复杂性的增加，扁平结构将难以维护。在这种情况下，使用嵌套结构将全局 Python 模块分解成各自的包是有意义的。
- en: Nested Structure
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套结构
- en: The nested structure groups similar modules into packages—effectively creating
    a nested structure and hierarchy of modules. You group all modules under a package
    that are similar in nature irrespective of the feature they support. These are
    loosely coupled modules that contain similar logic for different entities in your
    project. For instance, the `models` package may contain `users` and `profiles`
    database models.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套结构将类似模块分组到包中——有效地创建了一个嵌套的模块结构和层次。你将所有在性质上相似、无论它们支持什么功能的模块分组到一个包中。这些是松散耦合的模块，它们包含不同实体中相似逻辑。例如，`models`
    包可能包含 `users` 和 `profiles` 数据库模型。
- en: The nested structure is recommended for larger projects by the official FastAPI
    documentation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 官方 FastAPI 文档推荐使用嵌套结构来处理大型项目。
- en: You can see a project with nested structure in [Example 2-7](#nested_structure).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [示例 2-7](#nested_structure) 中看到一个具有嵌套结构的示例项目。
- en: Example 2-7\. Nested FastAPI project
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-7\. 嵌套 FastAPI 项目
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you add AI models and several external services and databases to your project,
    you can adopt a nested structure to manage the growing complexity.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向项目中添加 AI 模型和多个外部服务和数据库时，你可以采用嵌套结构来管理不断增长的复杂性。
- en: The main pitfall with this project structure is the ambiguous coupling of modules.
    Changes in one module can cascade into other modules, and it can become difficult
    to understand the cascading effect of new changes. Over time, it can be challenging
    to maintain and change the code without performing many updates everywhere else.
    This is referred to as *shotgun updates*. Shotgun updates in the context of software
    development are when it is challenging to maintain and change the code without
    performing many updates everywhere else.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种项目结构的主要缺点是模块之间的耦合不明确。一个模块的变化可能会级联到其他模块，这可能会使理解新变化级联效应变得困难。随着时间的推移，如果不进行许多其他地方的更新，维护和更改代码可能会变得具有挑战性。这被称为
    *散弹式更新*。在软件开发中，散弹式更新指的是在不进行许多其他地方的更新的情况下，维护和更改代码变得具有挑战性。
- en: If you expect difficulty managing module coupling or expecting to deal with
    a large application, I would recommend using a modular structure.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你预计管理模块耦合会有困难，或者预计要处理大型应用程序，我建议使用模块化结构。
- en: Modular Structure
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化结构
- en: The modular structure—popularized by the Netflix Dispatch FastAPI project—is
    similar to the nested structure because you can place multiple modules within
    a package and subpackages. However, the core difference is in how you organize
    your project.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化结构——由 Netflix Dispatch FastAPI 项目普及——类似于嵌套结构，因为你可以在包和子包中放置多个模块。然而，核心区别在于项目组织方式。
- en: In the modular structure, modules that are closely related and refer to a specific
    domain are grouped together. This approach differs from the previously mentioned
    nested structure. An example could be the `users` package that contains user schemas,
    database services, dependencies and routers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块化结构中，紧密相关并针对特定领域的模块被组合在一起。这种方法与之前提到的嵌套结构不同。一个例子是包含用户模式、数据库服务、依赖项和路由器的 `users`
    包。
- en: To understand this difference better, look at [Example 2-8](#modular_structure).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这种差异，请查看示例 2-8。
- en: Example 2-8\. Modular FastAPI project structure
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-8\. 模块化 FastAPI 项目结构
- en: '[PRE12]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In modular project structure like the one shown in [Example 2-8](#modular_structure),
    you bring together closely interconnected components based on a feature or a global
    system they implement (e.g., authentication, payment processing, notifications,
    etc.) or the resource they interact with (e.g., users, profiles, messages, etc).
    This kind of encapsulation eliminates any uncertainty regarding the couplings
    in your code, resulting in improved scalability and maintainability.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似于示例 2-8 中所示的模块化项目结构中，你将基于功能或它们实现的全球系统（例如，身份验证、支付处理、通知等）或它们交互的资源（例如，用户、个人资料、消息等）紧密相关的组件组合在一起。这种封装消除了代码耦合的任何不确定性，从而提高了可扩展性和可维护性。
- en: If you need to include more features, you can create a new package that contains
    all the necessary code. Similarly, if you need to modify or delete code, you can
    easily determine where the changes should be made and expect how they will impact
    other parts of the code. This is possible because the structure of the codebase
    is transparent and well-encapsulated, making it clear where different components
    are connected.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要包含更多功能，可以创建一个新的包，其中包含所有必要的代码。同样，如果需要修改或删除代码，可以轻松确定更改应在哪里进行，并预期它们将如何影响代码的其他部分。这是因为代码库的结构是透明的且封装良好的，使得不同组件的连接变得清晰。
- en: Progressive Reorganization of Your FastAPI Project
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐步重组你的 FastAPI 项目
- en: A modular codebase allows you to add and remove components with ease. You can
    also reuse components across different parts of your system to avoid repetition.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化代码库允许你轻松添加和删除组件。你还可以在不同部分的重用组件以避免重复。
- en: When you first start your project, modularity is not as important. You can get
    started with just a single or a few Python files to build your services easily.
    However, as soon as you introduce AI models, external services, and complex business
    logic, you will want to consider modularizing your codebase.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始项目时，模块化并不那么重要。你可以仅使用一个或几个 Python 文件轻松构建服务。然而，一旦引入 AI 模型、外部服务和复杂业务逻辑，你将希望考虑模块化你的代码库。
- en: You can achieve modularity by designing components of your system with re-usability
    and disposability in mind. Make sure the design of your modules and functions
    allow for usage in different environments and that you place them at the right
    place in your project directory. Selecting the best project structure is a matter
    of preference. However, you may be asking yourself, “Which project structure should
    I adopt for building generative AI services with FastAPI?”
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在设计系统组件时考虑可重用性和可处置性，可以实现模块化。确保你的模块和函数设计允许在不同环境中使用，并将它们放置在项目目录中的正确位置。选择最佳项目结构是个人偏好的问题。然而，你可能正在问自己，“我应该采用哪种项目结构来使用
    FastAPI 构建生成式 AI 服务？”
- en: 'I found that the best way to structure projects is to *progressively reorganize*
    your project from a flat to a modular structure as your service complexity grows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现，随着服务复杂性的增加，将项目从扁平结构逐步重组为模块化结构是最佳的项目结构方式：*逐步重组*。
- en: 1\. Flat
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 扁平结构
- en: If you are starting with a new project and the complexity of your system is
    not yet clear, you can focus on writing all your FastAPI code in a single file
    before worrying about the project structure. You then extract your code into several
    files under the root directory. This is the initial structure you will adopt when
    experimenting on the first version of your service from scratch.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在启动一个新项目，并且你系统的复杂性尚不明确，你可以在担心项目结构之前，将所有FastAPI代码写在一个文件中。然后，你将代码提取到根目录下的几个文件中。这是你在从头开始实验服务第一版时的初始结构。
- en: 2\. Nested
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 嵌套
- en: As the number of files in your codebase and service complexity grows, you can
    adopt the nested structure. You can search for files based on logical grouping
    (models, routers, schemas, etc.) and do not have to worry too much about logical
    couplings in your code. As you make changes, only a handful of files are affected.
    At this point, you have an AI microservice.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你代码库中文件数量和服务复杂性的增长，你可以采用嵌套结构。你可以根据逻辑分组（模型、路由器、模式等）搜索文件，而无需过多担心代码中的逻辑耦合。当你进行更改时，只有少数文件受到影响。此时，你有一个AI微服务。
- en: 3\. Modular
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 模块化
- en: As you move from a microservice to a full backend service, you will want to
    adopt a modular structure. There is now an increasing number of modules, features,
    and complexity. You start grouping your code into packages based on *areas of
    concern*. Your code is now handling requests, authentication, external systems,
    etc., while serving an AI model.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从微服务过渡到完整的后端服务时，你将希望采用模块化结构。现在模块、功能和复杂性越来越多。你开始根据*关注点*将代码分组到包中。现在你的代码正在处理请求、身份验证、外部系统等，同时提供AI模型。
- en: I suggest restructuring your project as outlined. However, you have the flexibility
    to adopt any organizational scheme that makes sense to you and allows you to recall
    the location and purpose of your files.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议按照概述重构你的项目。然而，你有灵活性采用任何对你有意义的组织方案，并允许你回忆起文件的位置和目的。
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember, if you cannot justify the file organization in your codebase to another
    developer, it is time to reconsider your existing structure.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你无法向其他开发者证明你的代码库中的文件组织是合理的，那么是时候重新考虑你现有的结构了。
- en: As you build your GenAI service, you will inevitably end up with a large codebase
    and a complex application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建你的GenAI服务时，你不可避免地会得到一个庞大的代码库和复杂的应用程序。
- en: Thinking about the structure of your large FastAPI application is only the first
    step in building production-grade services. In the next step, you will learn more
    about a software design pattern that helps you manage the complexity of your AI
    services. This is called the *onion*, or *layered*, application design pattern,
    which we will talk about next.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 思考你大型FastAPI应用程序的结构只是构建生产级服务的第一步。在下一步中，你将了解一种软件设计模式，它可以帮助你管理AI服务的复杂性。这被称为洋葱式，或分层，应用程序设计模式，我们将在下一节中讨论。
- en: Onion/Layered Application Design Pattern
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 洋葱/分层应用程序设计模式
- en: If you plan on building a fully featured backend service for generative AI,
    you will benefit to know more about the onion, or layered, application design
    pattern, which can be implemented within the nested and modular project structures.
    The purpose of this pattern is to create a separation of concerns between the
    different parts of your application to simplify the process of adding, removing,
    and modifying features.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划构建一个功能齐全的后端服务用于生成AI，那么了解洋葱式，或分层，应用程序设计模式将很有帮助，这种模式可以在嵌套和模块化项目结构中实现。这种模式的目的是在应用程序的不同部分之间创建关注点的分离，以简化添加、删除和修改功能的过程。
- en: The onion design pattern has also influenced web frameworks in other languages
    such as [Nest.js](https://nestjs.com).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 洋葱设计模式也影响了其他语言中的Web框架，如[Nest.js](https://nestjs.com)。
- en: The onion design consists of layers, each with a specific responsibility and
    dependency direction, shown in [Figure 2-3](#onion_design_pattern). The innermost
    layer contains the domain models and business logic, while the outer layers contain
    route handling (in an API service) or user-interfacing code (when serving HTML
    templates).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 洋葱式设计由多层组成，每层都有特定的责任和依赖方向，如图[2-3](#onion_design_pattern)所示。最内层包含领域模型和业务逻辑，而外层包含路由处理（在API服务中）或用户界面代码（在提供HTML模板时）。
- en: The pattern is called “onion” because the layers build upon each other, with
    the domain model at the center, surrounded by layers of increasing abstraction
    promoting testability, maintainability, and flexibility in maintaining your AI
    services. The core of the application (domain model and business logic) is at
    the inner layers, and all other layers depend inwardly on it. This approach helps
    to manage dependencies, promote separation of concerns, and facilitate a more
    testable and maintainable codebase.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式被称为“洋葱”，因为层是相互构建的，以领域模型为中心，周围是不断增高的抽象层，这些层促进了在维护你的 AI 服务时的可测试性、可维护性和灵活性。应用程序的核心（领域模型和业务逻辑）位于内层，所有其他层都向内依赖它。这种方法有助于管理依赖关系，促进关注点的分离，并促进更可测试和可维护的代码库。
- en: '![bgai 0203](assets/bgai_0203.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0203](assets/bgai_0203.png)'
- en: Figure 2-3\. Onion design pattern
  id: totrans-210
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3. 洋葱设计模式
- en: The main idea behind this pattern is the *dependency inversion principle*, which
    states that high-level modules should not directly depend on the implementation
    of low-level modules but declare what they need from low-level modules by leveraging
    the FastAPI dependency system. The dependency system can then inject the output
    of the low-level modules to avoid coupling between layers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式背后的主要思想是 *依赖倒置原则*，它指出高级模块不应直接依赖于低级模块的实现，而应通过利用 FastAPI 依赖系统声明它们从低级模块中需要什么。然后，依赖系统可以注入低级模块的输出，以避免层之间的耦合。
- en: 'To implement this software design, you break down your service as an onion
    consisting of layers that go deeper and deeper. Each layer (as you move from outer
    to inner layers) introduces components that are responsible for a set of tasks:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种软件设计，你将服务分解成一个洋葱，由层层深入的结构组成。每一层（从外层到内层）引入负责一组任务的组件：
- en: API routers
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: API 路由器
- en: Routers are responsible for grouping multiple controllers/route handlers to
    apply common logic across several controllers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器负责将多个控制器/路由处理程序分组，以便在多个控制器中应用通用逻辑。
- en: FastAPI provides the `APIRouter` class to help you with this.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 提供了 `APIRouter` 类来帮助你实现这一点。
- en: Controllers/route handlers
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器/路由处理程序
- en: Controllers are responsible for handling incoming *requests* and returning *responses*
    to the client via a logical execution of services or providers.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器负责处理传入的 *请求* 并通过服务的逻辑执行或提供者的方式向客户端返回 *响应*。
- en: Good controller design always uses dependencies to inject required data or logic
    required for its execution. See [Figure 2-4](#api_routers_controllers).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的控制器设计总是使用依赖关系来注入执行所需的数据或逻辑。参见[图 2-4](#api_routers_controllers)。
- en: '![bgai 0204](assets/bgai_0204.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0204](assets/bgai_0204.png)'
- en: Figure 2-4\. API routers and controllers
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-4. API 路由器和控制器
- en: Services/providers
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 服务/提供者
- en: Services are responsible for combining or orchestrating multiple internal operations
    to implement a business logic (services), while providers implement the interface
    with external systems.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 服务负责组合或编排多个内部操作以实现业务逻辑（服务），而提供者负责与外部系统实现接口。
- en: Services typically use repositories for data access to implement complex business
    logic rather than simple data retrieval and mutation operations. Each module of
    your application can have its own service.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 服务通常使用存储库来实现复杂业务逻辑，而不是简单的数据检索和变更操作，以进行数据访问。你的应用程序的每个模块都可以有自己的服务。
- en: Providers are similar to services but are specialized in interacting with external
    systems such as internal/third-party APIs. Examples of providers include clients
    for email servers, payment gateways, or other microservices.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者类似于服务，但专门用于与外部系统（如内部/第三方 API）交互。提供者的例子包括电子邮件服务器客户端、支付网关或其他微服务。
- en: Essentially, both providers and services support implementation of controller
    business logic by facilitating internal and external interactions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，提供者和服务都通过促进内部和外部交互来支持控制器业务逻辑的实现。
- en: 'Here is an example of how they work together within a route controller: the
    `users` database service fetches a user’s record by email and then uses that information
    with a payment gateway and email server clients (providers) for processing payments
    and sending confirmation emails.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个它们在路由控制器中如何协同工作的例子：`users` 数据库服务通过电子邮件获取用户记录，然后使用该信息与支付网关和电子邮件服务器客户端（提供者）一起处理支付并发送确认电子邮件。
- en: Repositories (data adapters)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库（数据适配器）
- en: A repository is a design pattern used when implementing the logic for data access
    and mutation operations with data sources (not to be confused with a Git repository).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库是在实现与数据源（不要与 Git 存储库混淆）的数据访问和变更操作逻辑时使用的设计模式。
- en: Repositories use object-relational mapping (ORM) or raw SQL commands to execute
    queries on your infrastructure like a database, or a memory store for retrieving
    or mutating data.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库使用对象关系映射（ORM）或原始 SQL 命令在数据库、内存存储等基础设施上执行查询，以检索或变更数据。
- en: You may implement an abstract interface in this layer to enforce consistent
    design across all your repositories—using the create, read, update, delete (CRUD)
    operations. See [Figure 2-5](#services_providers_repositories).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这一层实现一个抽象接口，以强制所有存储库保持一致的设计——使用创建、读取、更新、删除（CRUD）操作。参见[图 2-5](#services_providers_repositories)。
- en: '![bgai 0205](assets/bgai_0205.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0205](assets/bgai_0205.png)'
- en: Figure 2-5\. Services, providers, and repositories
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. 服务、提供者和存储库
- en: Schemas/models
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 架构/模型
- en: These are responsible for enforcing type-safety, structure, and validation logic
    on your data as it flows throughout your service.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些负责在数据流过你的服务时强制类型安全、结构和验证逻辑。
- en: 'You will also have components that span layers to support the whole application:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将有跨越层的组件来支持整个应用程序：
- en: Middleware
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件
- en: This handles requests and responses before and after they are passed to the
    application controllers/route handlers (see [Figure 2-6](#middlewares)).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理在请求和响应传递到应用程序控制器/路由处理程序之前和之后的情况（参见[图 2-6](#middlewares)）。
- en: '![bgai 0206](assets/bgai_0206.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0206](assets/bgai_0206.png)'
- en: Figure 2-6\. Middleware
  id: totrans-239
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-6\. 中间件
- en: Dependencies
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项
- en: These include reusable functions you define that can be injected into controllers
    to support a business logic. Dependencies can be cached and depend on other dependencies.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包括你定义的可重用函数，可以将它们注入到控制器中以支持业务逻辑。依赖项可以被缓存并依赖于其他依赖项。
- en: Pipes
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 管道
- en: These are data transformer functions that you can use across application layers.
    Examples include data aggregators, cleaners, parsers, translators, etc.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你可以在应用程序层之间使用的数据库转换函数。例如包括数据聚合器、清理器、解析器、翻译器等。
- en: Mappers
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 映射器
- en: These are data mappers from one schema into another, often passing data across
    layers such as from the `UserRequest` schema at a router layer to the `UserInDB`
    schema at the data access layer. See [Figure 2-7](#models_pipes_mappers).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是从一个模式映射到另一个模式的数据映射器，通常在跨层传递数据，例如从路由层的 `UserRequest` 模式到数据访问层的 `UserInDB`
    模式。参见[图 2-7](#models_pipes_mappers)。
- en: '![bgai 0207](assets/bgai_0207.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0207](assets/bgai_0207.png)'
- en: Figure 2-7\. Models, pipes, and mappers
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-7\. 模型、管道和映射器
- en: Exception filters
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 异常过滤器
- en: These consistently handle exceptions across the layers.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在各个层中一致地处理异常。
- en: Guards
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 守卫
- en: These secure and protect controllers from abuse. Authentication and authorization
    logic can be implemented as dependencies or middleware to act as guards (see [Figure 2-8](#guards)).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这些保护控制器免受滥用。身份验证和授权逻辑可以作为依赖项或中间件实现，作为守卫（参见[图 2-8](#guards)）。
- en: '![bgai 0208](assets/bgai_0208.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0208](assets/bgai_0208.png)'
- en: Figure 2-8\. Guards
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-8\. 守卫
- en: If you refer to the modular project structure shown in [Example 2-8](#modular_structure),
    you will now notice various elements of the onion design pattern in the modular
    project structure. Following this pattern can help you create a maintainable,
    testable, and scalable FastAPI generative AI service.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参考了[示例 2-8](#modular_structure)中展示的模块化项目结构，你现在会注意到模块化项目结构中洋葱设计模式的各个元素。遵循这个模式可以帮助你创建可维护、可测试和可扩展的
    FastAPI 可生成 AI 服务。
- en: In the upcoming chapters, you’ll use these patterns to build the GenAI service
    shown in [Figure 2-9](#genai_service).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将使用这些模式来构建[图 2-9](#genai_service)中展示的 GenAI 服务。
- en: '![bgai 0209](assets/bgai_0209.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 0209](assets/bgai_0209.png)'
- en: Figure 2-9\. Generative AI service you’ll build with FastAPI
  id: totrans-257
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-9\. 使用 FastAPI 构建的可生成 AI 服务
- en: Next, we will compare FastAPI with other frameworks.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将比较 FastAPI 与其他框架。
- en: Comparing FastAPI to Other Python Web Frameworks
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 FastAPI 与其他 Python Web 框架进行比较
- en: Most Python web frameworks can provide you with tools for building REST, GraphQL,
    WebSocket, and other types of endpoints.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Python Web 框架都能为你提供构建 REST、GraphQL、WebSocket 等类型端点的工具。
- en: These frameworks are either opinionated, such as Django (Python) and Nestjs
    (JavaScript), while others are not. Flask or FastAPI (Python) and Express (JavaScript)
    give you the option to architect your service however you like.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框架要么持有特定观点，如 Django（Python）和 Nestjs（JavaScript），要么不持有。Flask 或 FastAPI（Python）和
    Express（JavaScript）让您有选择如何构建服务的自由。
- en: Opinionated frameworks, such as Django (Python) and Nestjs (JavaScript), make
    decisions for you with certain assumptions about how you will be providing data
    to your components. Effectively, they provide structure while restricting what
    you are allowed to do. Opinionated frameworks are typically easier to use. On
    the other hand, nonopinionated frameworks such as Flask or FastAPI (Python) and
    Express (JavaScript) are more flexible but can give you too much freedom—many
    possibilities to achieve the same results.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 持有特定观点的框架，如 Django（Python）和 Nestjs（JavaScript），会根据您将如何向组件提供数据的某些假设为您做出决策。实际上，它们提供了结构，同时限制了您能做的事情。持有特定观点的框架通常更容易使用。另一方面，非持有特定观点的框架，如
    Flask 或 FastAPI（Python）和 Express（JavaScript），更加灵活，但可能会给您过多的自由——许多实现相同结果的可能性。
- en: Because nonopinionated frameworks such as FastAPI give you so much freedom in
    building services, you may feel some decision fatigue when choosing and integrating
    every single support package yourself. For instance, to work with a database,
    you will need to install and integrate several packages that work well together—one
    to access the database, one to migrate it, and another to act as an object relational
    mapper (ORM).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于非持有特定观点的框架，如 FastAPI，在构建服务时给您提供了如此多的自由，您在选择和集成每个支持包时可能会感到一些决策疲劳。例如，要处理数据库，您需要安装和集成几个能够良好协作的包——一个用于访问数据库，一个用于迁移它，另一个充当对象关系映射器（ORM）。
- en: While doing that, you may run into compatibility issues with older packages
    during integration. This makes working with nonopinionated frameworks difficult,
    and often you may decide to use an opinionated framework such as Django, which
    ships with a tightly integrated and excellent ORM system for interacting with
    databases.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在做这件事的时候，您可能会在集成过程中遇到与旧包的兼容性问题。这使得与非持有特定观点的框架一起工作变得困难，您通常会决定使用像 Django 这样的持有特定观点的框架，它附带了一个紧密集成且出色的
    ORM 系统，用于与数据库交互。
- en: Django is a battery-included framework that markets itself as the “Python web
    framework for developers with deadlines.” It ships with a fully integrated and
    feature-rich ORM system that takes care of your database migrations and data access
    needs when you provide the data models.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Django 是一个包含电池的框架，它将自己定位为“面向有截止日期的开发者的 Python 网络框架。”它附带了一个完全集成且功能丰富的 ORM 系统，当您提供数据模型时，它会处理您的数据库迁移和数据访问需求。
- en: Additionally, it provides you with an administration panel, a credentials-based
    user authentication and authorization system, and several web security features
    out of the box, so you do not have to build these yourself. It has also been around
    for a long time, fostering an active community that has produced excellent documentation,
    tutorials, and other resources for the framework. In Django version 4.2, support
    for async requests has also been introduced—allowing you to build concurrency
    into your services. Django expects you to adopt the MVC architecture, requiring
    you to define data models and views. These views become routes serving templated
    HTML files, JSON responses, or any HTTP response out of the box, even without
    relying on `django-rest-framework`. Controller layers then will contain the core
    data processing and business logic.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还为您提供了一个管理面板、基于凭证的用户身份验证和授权系统，以及一些开箱即用的网络安全功能，因此您无需自己构建这些功能。它已经存在很长时间了，培养了一个活跃的社区，该社区为该框架提供了优秀的文档、教程和其他资源。在
    Django 4.2 版本中，还引入了对异步请求的支持——允许您将并发性构建到您的服务中。Django 预期您采用 MVC 架构，需要您定义数据模型和视图。这些视图成为服务模板化
    HTML 文件、JSON 响应或任何 HTTP 响应的路由，即使不依赖于 `django-rest-framework`。控制器层将包含核心数据处理和业务逻辑。
- en: This makes Django an excellent choice for monolith *progressive web applications*
    (PWA) that deploy as a single backend with a frontend. However, as businesses
    move toward building specialized teams for developing backends and frontends,
    microservice architectural patterns are becoming more popular. With microservices,
    you want to separate your backend and frontend services, build APIs instead of
    PWAs, and focus on keeping your services as lean as possible. Using Django you
    can also build APIs, but you can end up with a heavy application that slows you
    down during development, deployment, and scaling services. That is why nonopinionated
    frameworks such as Flask are rising in popularity.^([7](ch02.html#id589))
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 Django 成为部署为单一后端与前端一起的*渐进式 Web 应用程序*（PWA）的绝佳选择。然而，随着企业向建立专门的后端和前端开发团队转变，微服务架构模式变得越来越流行。使用微服务，你希望将后端和前端服务分离，构建
    API 而不是 PWA，并专注于尽可能保持服务精简。使用 Django 你也可以构建 API，但最终可能会得到一个在开发、部署和扩展服务时拖慢你速度的重量级应用程序。这就是为什么无观点框架如
    Flask 正在变得越来越受欢迎.^([7](ch02.html#id589))
- en: Flask ships with as little code as practically possible for building web servers.
    In comparison to FastAPI, Flask does not come packaged with data validation, auto-documentation,
    and a dependency injection system. The mentioned features are often required for
    building any backend service that is becoming complex or requires integration
    with databases and external services.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 以尽可能少的代码构建 Web 服务器。与 FastAPI 相比，Flask 并未捆绑数据验证、自动文档化和依赖注入系统。这些功能通常对于构建任何变得复杂或需要与数据库和外部服务集成的后端服务是必需的。
- en: Note
  id: totrans-269
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A new web framework called Quart has tried to tackle this problem, which is
    a good contender to FastAPI. However, at the time of this writing, Quart is new,
    and compared to other frameworks it does not have a large community of users and
    documented resources to help if you get stuck on a problem.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 Quart 的新 Web 框架试图解决这个问题，它是 FastAPI 的有力竞争者。然而，在撰写本文时，Quart 仍然较新，与其他框架相比，它没有庞大的用户社区和文档资源来帮助你在遇到问题时。
- en: Furthermore, Flask was released in 2010 and implements a communication protocol
    called *Web Server Gateway Interface* (WSGI) for web serving, meaning that requests
    are processed synchronously in comparison to ASGI, which is asynchronous in nature.
    Additionally, Flask is not designed for handling a large number of simultaneous
    connections (like an asynchronous framework would). However, this does not limit
    the number of parallel requests the server can handle on its own. In production,
    you can employ various strategies (like worker processes or threads) to handle
    multiple requests concurrently. Also, because Flask implements WSGI, it does not
    support WebSocket endpoints, which are used for maintaining a persistent, bidirectional
    communication channel between a client and a server. This is because WSGI does
    not natively support WebSocket. However, you can install Flask extensions to integrate
    WebSocket support.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Flask 于 2010 年发布，并实现了名为 *Web 服务器网关接口*（WSGI）的通信协议，用于 Web 服务，这意味着与 ASGI（本质上是异步的）相比，请求是同步处理的。此外，Flask
    并未设计用于处理大量并发连接（如异步框架会做的那样）。然而，这并不限制服务器本身可以处理的并行请求数量。在生产环境中，你可以采用各种策略（如工作进程或线程）来并发处理多个请求。此外，由于
    Flask 实现了 WSGI，它不支持 WebSocket 端点，这些端点用于在客户端和服务器之间维护持久的双向通信通道。这是因为 WSGI 并未原生支持
    WebSocket。然而，你可以安装 Flask 扩展来集成 WebSocket 支持。
- en: Flask, relying on a WSGI server, will process each request synchronously, whereas
    FastAPI uses an event loop for concurrent workloads. Therefore, FastAPI is going
    to be much faster with input/output (I/O) heavy tasks—for instance, when communicating
    with an external API or data store, which would block an entire worker process
    in Flask.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 依赖于 WSGI 服务器，将同步处理每个请求，而 FastAPI 则使用事件循环来处理并发工作负载。因此，FastAPI 在处理输入/输出（I/O）密集型任务时将会更快——例如，当与外部
    API 或数据存储进行通信时，这可能会阻塞 Flask 中的整个工作进程。
- en: In essence, I recommend Django and other frameworks if you want to build PWA
    monoliths, and Flask or Quart for simple APIs and frameworks in other languages
    if you have more experience with them.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，如果你想要构建 PWA 单体，我推荐使用 Django 和其他框架；如果你在它们上更有经验，则可以使用 Flask 或 Quart 来构建简单的
    API 和其他语言的框架。
- en: However, if you’re building a backend service that requires AI model support,
    connection to external systems, and some level of business logic complexity, I
    recommend considering FastAPI as the web framework of choice.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你正在构建一个需要AI模型支持、连接外部系统以及一定程度的业务逻辑复杂性的后端服务，我建议考虑FastAPI作为首选的Web框架。
- en: FastAPI Limitations
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FastAPI的限制
- en: Given the aforementioned features and benefits, there are also several drawbacks
    and trade-offs you must consider if you are going to adopt FastAPI for your project.
    With AI use cases in mind, FastAPI falls short in several areas.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上述特性和优势，如果你打算在你的项目中采用FastAPI，你必须考虑一些缺点和权衡。考虑到AI用例，FastAPI在几个方面存在不足。
- en: Inefficient Model Memory Management
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型内存管理效率低下
- en: FastAPI does provide built-in mechanisms for sharing model memory between multiple
    instances or processes of the same container. This means when scaling web workers
    horizontally, you need to load a whole new model instance into the container’s
    memory. This creates a memory bottleneck and increases operational costs of high-traffic
    GenAI services.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI确实提供了内置机制，用于在相同容器的多个实例或进程之间共享模型内存。这意味着在水平扩展Web工作者时，你需要将整个新的模型实例加载到容器的内存中。这会创建内存瓶颈并增加高流量GenAI服务的运营成本。
- en: Limited Number of Threads
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程数量有限
- en: There is a limit to the number of threads that FastAPI creates on application
    startup in the internal thread pool.^([8](ch02.html#id601))
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI在应用启动时在内部线程池中创建的线程数量是有限的。[^([8](ch02.html#id601))]
- en: This means there is also a limit to how much you can scale a single instance
    of FastAPI, especially with AI workloads that have heavy I/O as well as CPU/GPU-intensive
    operations.^([9](ch02.html#id602))
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你能够扩展单个FastAPI实例的规模也是有限的，尤其是对于具有重I/O以及CPU/GPU密集型操作的AI工作负载。[^([9](ch02.html#id602))]
- en: Restricted to Global Interpreter Lock
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受限于全局解释器锁
- en: In Python, multithreading can produce unintuitive and often counterproductive
    results because of the *Global Interpreter Lock* (GIL).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，多线程可能会产生不直观且往往事与愿违的结果，这是由于*全局解释器锁*（GIL）的限制。
- en: FastAPI leverages multithreading via an internal thread pool to handle concurrent
    web requests hitting a synchronous route. However, even with asynchronous endpoints,
    the AI inference requests can still block the main event loop, preventing all
    other requests from being processed in the main web serving thread.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI通过内部线程池利用多线程来处理同时击中同步路由的并发Web请求。然而，即使有异步端点，AI推理请求仍然可以阻塞主事件循环，阻止所有其他请求在主Web服务线程中处理。
- en: This is because AI inference workloads are CPU/GPU intensive. Non-I/O operations,
    such as serving an expensive model or aggregating large amounts of data on a worker,
    will cause other threads to wait as Python currently is not using multiple cores
    for threading.^([10](ch02.html#id607)) Instead, as you’ll learn more in [Chapter 5](ch05.html#ch05),
    for these kinds of expensive compute operations, you’ll need to use multiprocessing
    or a process pool instead.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为AI推理工作负载是CPU/GPU密集型的。非I/O操作，例如提供昂贵的模型或在工作者上聚合大量数据，将导致其他线程等待，因为Python目前没有使用多个核心进行线程。[^([10](ch02.html#id607))]
    相反，正如你将在第5章中了解更多，对于这类昂贵的计算操作，你需要使用多进程或进程池。
- en: Lack of Support for Micro-Batch Processing Inference Requests
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺乏对微批处理推理请求的支持
- en: Deep learning frameworks provide support for vectorization so that inferences
    can be batched together, efficiently computed, and parallelized. Unfortunately,
    prediction requests can’t be batched together in FastAPI, and as a result, each
    compute-intensive model inference operation can block other requests.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习框架提供支持向量化，以便推理可以一起批量处理，高效计算并并行化。不幸的是，在FastAPI中，预测请求不能一起批量处理，因此，每个计算密集型模型推理操作都可能阻塞其他请求。
- en: When scaling services, a solution is to serve heavy models separately and use
    FastAPI to authenticate and manage the incoming and outgoing data.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展服务时，一种解决方案是分别提供重模型，并使用FastAPI进行身份验证和管理传入和传出的数据。
- en: Cannot Efficiently Split AI Workloads Between CPU and GPU
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无法在CPU和GPU之间有效地分割AI工作负载
- en: While the CPU mostly handles request transformation and validation operations,
    the GPU can run and parallelize compute-intensive model inference. In some specialized
    ML web frameworks (like BentoML), you can also efficiently split AI workloads
    between the CPU and GPU.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 CPU 主要处理请求转换和验证操作，但 GPU 可以运行并并行化计算密集型模型推理。在某些专门的ML Web框架（如BentoML）中，您也可以在CPU和GPU之间有效地分割AI工作负载。
- en: Note
  id: totrans-291
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When you split AI workloads across the CPU and GPU, data preparation and post-processing
    operations run on the CPU, while faster deep learning inference is performed on
    the GPU.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在CPU和GPU之间分割AI工作负载时，数据准备和后处理操作在CPU上运行，而更快的深度学习推理则在GPU上执行。
- en: Unfortunately, FastAPI can’t efficiently perform this split of the AI inference
    workload between these devices. This means your CPU can be blocked from processing
    requests even when inference processes are running on the GPU. As this is a big
    bottleneck when working with heavier models, it will require serving heavier models
    outside FastAPI for concurrent workloads.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，FastAPI无法在这些设备之间有效地分割AI推理工作负载。这意味着即使推理过程正在GPU上运行，CPU也可能被阻塞，无法处理请求。由于这在处理更重的模型时是一个大瓶颈，因此您可能需要在FastAPI之外提供更重的模型以处理并发工作负载。
- en: We’ll discuss solutions to this limitation in more detail in [Chapter 5](ch05.html#ch05).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第5章（[Chapter 5](ch05.html#ch05)）中更详细地讨论解决这个限制的方法。
- en: Dependency Conflicts
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖项冲突
- en: When you are deploying ML models, you will face unique challenges compared to
    deploying typical web applications. This is due to your model runtime’s deep coupling
    with native libraries and hardware. Each deployment environment can operate on
    distinct hardware and may require you to use specific versions of native libraries
    and containerization commands.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当您部署ML模型时，您将面临与部署典型Web应用程序相比独特的挑战。这是由于您的模型运行时与本地库和硬件的深度耦合。每个部署环境都可以在特定的硬件上运行，可能需要您使用特定版本的本地库和容器化命令。
- en: Lack of Support for Resource-Intensive AI Workloads
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺乏对资源密集型AI工作负载的支持
- en: Despite its incredible capabilities, FastAPI was developed before the rise of
    generative AI. As a result, it remains a general-purpose web framework with recent
    support for AI serving and ML workflows. However, for certain use cases, such
    as serving resource-intensive and complex billion-parameter models, it may be
    worth exploring other frameworks like *BentoML*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管FastAPI具有令人难以置信的能力，但它是在生成式AI兴起之前开发的。因此，它仍然是一个通用的Web框架，最近支持AI服务和ML工作流程。然而，对于某些用例，例如提供资源密集型和复杂的十亿参数模型，探索其他框架如
    *BentoML* 可能是值得的。
- en: In the following chapters, you’ll learn how to build your own GenAI service
    with FastAPI.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将学习如何使用FastAPI构建自己的GenAI服务。
- en: But before moving forward, let’s configure necessary Python tools like linters,
    formatters, and type checkers in your development environment for easier maintainability
    of your FastAPI project as we work on it together.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 但在继续之前，让我们配置开发环境中的必要Python工具，如linters、formatters和type checkers，以便在共同工作时更容易维护您的FastAPI项目。
- en: Setting Up a Managed Python Environment and Tooling
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置托管Python环境和工具
- en: To maintain a stable and reproducible development environment, you may want
    to manage your Python environment and dependencies.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持稳定和可重复的开发环境，您可能想要管理您的Python环境和依赖项。
- en: 'I recommend:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议：
- en: Using a *requirements.txt* file with `pip` for simpler projects
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pip` 的 `requirements.txt` 文件进行更简单的项目
- en: Using [uv](https://oreil.ly/Qxl7h) or [Conda](https://oreil.ly/Kfsc4) for `pip`-driven
    workflows
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 [uv](https://oreil.ly/Qxl7h) 或 [Conda](https://oreil.ly/Kfsc4) 进行 `pip` 驱动的流程
- en: Using [Poetry](https://oreil.ly/Rt04z) for more complex projects
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于更复杂的项目使用 [Poetry](https://oreil.ly/Rt04z)
- en: Aside from managing dependencies, Python also has several third-party packages
    that allow you to lint and format your codebase before shipping it into production.^([11](ch02.html#id618))
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 除了管理依赖项之外，Python还有几个第三方包，允许您在将代码库部署到生产之前对其进行lint和格式化.^([11](ch02.html#id618))
- en: It is best practice for professional Python developers to use these tools to
    catch bugs during development and before adding changes to the code repository.
    In fact, I recommend that you run code checks with these tools against your codebase
    frequently to prevent bugs from appearing in your services.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于专业的Python开发者来说，使用这些工具在开发期间和将更改添加到代码库之前捕获错误是一种最佳实践。实际上，我建议您经常使用这些工具对您的代码库进行代码检查，以防止错误出现在您的服务中。
- en: 'Here is a nonexhaustive list of Python packages that I recommend integrating
    into any project you start:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个非详尽的Python包列表，我推荐将其集成到任何你开始的项目中：
- en: Linters
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查器
- en: 'These tools analyze source code to flag programming errors, stylistic errors,
    and unused code snippets:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具分析源代码，以标记编程错误、风格错误和未使用的代码片段：
- en: '*Autoflake*: Removes unused imports and variables from code to improve readability'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Autoflake*：从代码中删除未使用的导入和变量以提高可读性'
- en: '*Flake8*: Checks against Python enhancement proposals (PEPs) and code styles'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Flake8*：检查Python增强提案（PEPs）和代码风格'
- en: Formatters
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化器
- en: 'These enable you to better see what you have written:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具可以帮助你更好地看到你所写的代码：
- en: '*isort*: Sorts imports in Python modules'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*isort*：对Python模块中的导入进行排序'
- en: '*Black*: Formats Python code for readability'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Black*：格式化Python代码以提高可读性'
- en: '*Ruff*: Rust-based linter and formatter that is extremely fast and can be used
    as a replacement for other tools such as `isort`, `black`, `flake8`, and possibly
    `bandit`^([12](ch02.html#id621))'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ruff*：基于Rust的代码检查器和格式化工具，速度极快，可以用作`isort`、`black`、`flake8`和其他工具（如`bandit`^([12](ch02.html#id621)）的替代品。'
- en: Loggers
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 记录器
- en: 'Used in parts of the code that gets complex to debug and monitor your application:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 用于调试和监控那些变得复杂的代码部分：
- en: '*Loguru*: Replacing Python’s built-in logger module'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Loguru*：替代Python内置的记录器模块'
- en: Scanners
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描器
- en: 'If you want confidence that you did not commit insecure code or passwords by
    chance:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望确保你没有意外提交不安全的代码或密码：
- en: '*Bandit*: Vulnerability scanning of your Python codebase with checking against
    common security issues such as hard-coded secrets'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Bandit*：使用常见安全问题的检查来扫描你的Python代码库中的漏洞'
- en: '*Safety*: Python dependency vulnerability scanner to detect packages with known
    vulnerabilities or malicious packages'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Safety*：Python依赖项漏洞扫描器，用于检测已知漏洞或恶意软件包'
- en: Type checkers
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器
- en: 'To catch those bugs that normal linters do not catch. Also, great if you want
    confidence that changes in your schemas did not break your application:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕捉那些普通代码检查器无法捕捉到的错误。如果你希望确保你的模式更改没有破坏你的应用程序，这也是一个不错的选择：
- en: '*Mypy*: A powerful static type checker that can help catch a lot of bugs in
    your code'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Mypy*：一个强大的静态类型检查器，可以帮助你在代码中捕捉到许多错误'
- en: '*Pylance*: A type checker that ships with Microsoft’s Python extension for
    VS Code'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pylance*：随Microsoft的VS Code Python扩展一起提供的类型检查器'
- en: As part of your development environment, it’s also worthwhile to use version
    control systems like Git to track codebase changes, manage different versions
    of your project, and manage code contributions from other developers.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 作为你的开发环境的一部分，使用版本控制系统如Git来跟踪代码库更改、管理项目不同版本以及管理其他开发者的代码贡献也是值得的。
- en: Tip
  id: totrans-331
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: When using Git, you can also add *.gitignore* files to help you manage files
    and directories that you want excluded from version control tracking.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Git时，你还可以添加*.gitignore*文件来帮助你管理你想要排除在版本控制跟踪之外的文件和目录。
- en: Integrated development environments (IDEs) such as VS Code or JetBrains Pycharm
    provide plug-ins for running these tools as you type or save your work. They often
    require some configuration, but once done, you will get auto-formatting and linting
    set up and ready before you begin. In any case, I recommend having a script or
    pre-commit hooks that lints, checks, and formats your code before you commit to
    your codebase or deploy it to production.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 集成开发环境（IDE）如VS Code或JetBrains PyCharm提供插件，可以在你键入或保存工作时运行这些工具。它们通常需要一些配置，但一旦完成，你就可以在开始之前设置好自动格式化和代码检查。
- en: Tip
  id: totrans-334
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: I’ve prepared a [FastAPI blank template](https://oreil.ly/j8lF7) that includes
    integrations with common tools that you can use as a foundation for your projects.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我准备了一个[FastAPI空白模板](https://oreil.ly/j8lF7)，其中包含与常见工具的集成，你可以将其用作项目的基础。
- en: These are fundamentals of Python programming and software engineering. They
    will become crucial when you start working with AI models that can produce probabilistic
    outputs as well as external services and databases that can change schemas at
    any time. Maintaining an AI application that changes schemas and prompts constantly
    without the aforementioned tools can definitively become a headache quite fast.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Python编程和软件工程的基础。当你开始与可以产生概率性输出的AI模型以及可以随时更改模式的第三方服务和数据库一起工作时，它们将变得至关重要。在没有上述工具的情况下，维护一个不断更改模式和提示的AI应用程序可能会很快变成一个头疼的问题。
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the FastAPI framework, including its capabilities
    and drawbacks compared to other frameworks.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了 FastAPI 框架，包括其与其他框架相比的特性和缺点。
- en: You also learned how to set up your own FastAPI project from scratch, alongside
    a set of tools you can use to improve your development experience.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了如何从头开始设置自己的 FastAPI 项目，以及一套你可以使用的工具来改善你的开发体验。
- en: Then you were introduced to several project structures you can adopt when building
    your own FastAPI service. As part of this, you learned more about the onion/layered
    software design pattern to help manage project complexity.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你被介绍了几种在构建自己的 FastAPI 服务时可以采用的工程结构。作为其中的一部分，你学习了洋葱/分层软件设计模式，以帮助管理项目复杂性。
- en: Finally, we covered tools you can use to manage your Python environments and
    help maintain your FastAPI codebase as it grows in complexity.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了你可以使用的工具来管理你的 Python 环境，并帮助维护随着复杂性增长而增长的 FastAPI 代码库。
- en: You should now be comfortable starting your own FastAPI projects and managing
    the project complexity as it evolves over time.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够舒适地开始自己的 FastAPI 项目，并随着项目随时间发展而管理项目复杂性。
- en: In the next chapter, you will learn how to implement your own GenAI features
    in FastAPI for generating text, image, audio, and video. You will understand the
    inner workings of each model and the role of FastAPI lifecycle system in model
    serving, while leveraging NVIDIA GPUs for inference tasks. Finally, you will be
    introduced to the FastAPI background tasks system to offload long-running inference
    operations.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何在 FastAPI 中实现自己的 GenAI 功能，用于生成文本、图像、音频和视频。你将了解每个模型的内部工作原理以及 FastAPI
    生命周期系统在模型服务中的作用，同时利用 NVIDIA GPU 进行推理任务。最后，你将介绍 FastAPI 的后台任务系统，以卸载长时间运行的推理操作。
- en: ^([1](ch02.html#id507-marker)) Large parts of Pydantic v2’s data validation
    logic have been rewritten in Rust for significant performance improvements.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#id507-marker)) Pydantic v2 的数据验证逻辑的大部分已经被用 Rust 重写，以实现显著的性能提升。
- en: ^([2](ch02.html#id511-marker)) The `fastapi dev` command searches your project
    directories for a FastAPI `app` object. If you’re having issues starting your
    FastAPI server, consult its documentation using `fastapi dev --help`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.html#id511-marker)) `fastapi dev` 命令会在你的项目目录中搜索 FastAPI `app` 对象。如果你在启动
    FastAPI 服务器时遇到问题，请使用 `fastapi dev --help` 咨询其文档。
- en: ^([3](ch02.html#id527-marker)) To perform model inference
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.html#id527-marker)) 执行模型推理
- en: ^([4](ch02.html#id530-marker)) Coming from the Starlette framework
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.html#id530-marker)) 来自 Starlette 框架
- en: ^([5](ch02.html#id554-marker)) FastAPI’s new lifespan events replace the deprecated
    startup/shutdown events in older versions.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.html#id554-marker)) FastAPI 的新生命周期事件取代了旧版本中已弃用的启动/关闭事件。
- en: ^([6](ch02.html#id561-marker)) An external dependency
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.html#id561-marker)) 外部依赖
- en: ^([7](ch02.html#id589-marker)) As is clear by their number of monthly downloads
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.html#id589-marker)) 如其每月下载量所示
- en: ^([8](ch02.html#id601-marker)) FastAPI relies on `AnyIO` (an asynchronous networking
    and concurrency library) to handle concurrency. `AnyIO` creates up to 40 threads
    by default on a dynamic internal thread pool and removes those that aren’t used
    for a while.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch02.html#id601-marker)) FastAPI 依赖于 `AnyIO`（一个异步网络和并发库）来处理并发。`AnyIO`
    默认在动态内部线程池中创建多达 40 个线程，并移除一段时间内未使用的线程。
- en: ^([9](ch02.html#id602-marker)) Unless you run the GPU operations in another
    process (via multiprocessing) and await the operations
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch02.html#id602-marker)) 除非你在另一个进程（通过多进程）中运行 GPU 操作并等待操作
- en: ^([10](ch02.html#id607-marker)) However, according to [PEP 703](https://oreil.ly/_bRzj),
    GIL will be made optional in CPython soon.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch02.html#id607-marker)) 然而，根据 [PEP 703](https://oreil.ly/_bRzj)，CPython
    将很快使 GIL（全局解释器锁）成为可选的。
- en: ^([11](ch02.html#id618-marker)) Refer to [Hypermodern’s GitHub repository](https://oreil.ly/6YWRN)
    for tooling examples.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch02.html#id618-marker)) 请参阅 [Hypermodern 的 GitHub 仓库](https://oreil.ly/6YWRN)
    以获取工具示例。
- en: ^([12](ch02.html#id621-marker)) You can use `ruff` for faster checks in CI/CD
    pipelines, unless your development environment or CI/CD pipeline is tightly integrated
    with the other tools.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch02.html#id621-marker)) 你可以使用 `ruff` 在 CI/CD 管道中进行更快的检查，除非你的开发环境或 CI/CD
    管道与其他工具紧密集成。
