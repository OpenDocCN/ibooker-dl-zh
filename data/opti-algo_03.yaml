- en: 3 Blind search algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 盲搜索算法
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Applying different graph types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用不同的图类型
- en: Graph search algorithms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图搜索算法
- en: Using graph traversal algorithms to find a path between two nodes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图遍历算法在两个节点之间找到路径
- en: Using blind search algorithms to find the shortest path between two nodes in
    a graph
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用盲搜索算法在图中的两个节点之间找到最短路径
- en: Solving a real-world routing problem using graph search algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图搜索算法解决现实世界的路由问题
- en: You were introduced to deterministic and stochastic algorithms in chapter 2\.
    In this chapter, we will focus on deterministic algorithms, specifically blind
    search algorithms, and their applications in exploring tree or graph structures
    and finding the shortest path between nodes. Using these algorithms, you can explore
    a maze from an initial state to a goal state, solve *n*-puzzle problems, figure
    out the distance between you and any other person on a social media graph, search
    a family tree to determine the exact relationship between any two related people,
    or find the shortest path between any origin (e.g., your home) and any destination.
    Blind search algorithms are important, as they are often more efficient and practical
    to use when dealing with simple, well-defined problems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，您已经介绍了确定性和随机性算法。在本章中，我们将重点关注确定性算法，特别是盲搜索算法，以及它们在探索树或图结构以及找到节点之间最短路径中的应用。使用这些算法，您可以从一个初始状态探索迷宫到目标状态，解决*n*-拼图问题，确定社交媒体图中您与其他任何人的距离，搜索家谱以确定任何两个相关人员的确切关系，或者找到任何起点（例如，您的家）和任何目的地之间的最短路径。盲搜索算法很重要，因为当处理简单、定义明确的问题时，它们通常更高效且实用。
- en: 3.1 Introduction to graphs
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 图的介绍
- en: A *graph* is a nonlinear data structure composed of entities known as *vertices*
    (or nodes) and the relationships between them, known as *edges* (or *arcs* or
    *links*). This data structure does not follow a sequential pattern, making it
    *nonlinear*, unlike arrays, stacks, or queues, which are linear structures.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*图*是一个由称为*顶点*（或节点）和它们之间的关系组成的非线性数据结构，称为*边*（或*弧*或*链接*）。这种数据结构不遵循顺序模式，因此是非线性的，与数组、栈或队列等线性结构不同。
- en: A graph can be represented mathematically by *G*, where *G* = (*V, E*). *V*
    represents the set of nodes or vertices, and *E* represents the set of edges or
    links. Various attributes can also be added as components to the edge tuple, such
    as edge length, capacity, or any other unique properties (e.g., road material).
    Graphs can be classified as undirected, directed, multigraph, acyclic, and hypergraphs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图可以用数学上的*G*表示，其中*G* = (*V, E*)。*V*表示节点或顶点的集合，*E*表示边或链接的集合。还可以将各种属性作为组件添加到边元组中，例如边长、容量或任何其他独特属性（例如，道路材料）。图可以分为无向、有向、多重图、无环和超图。
- en: An *undirected graph* is one where a set of nodes are connected using bidirectional
    edges. This means that the order of two connected nodes is not essential.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*无向图*是一个使用双向边连接节点集的图。这意味着两个连接节点的顺序不是必要的。
- en: NetworkX is a commonly used Python library for creating, manipulating, and studying
    the structure, dynamics, and functions of graphs and complex networks (see appendix
    A for more information about graph libraries). The following listing shows how
    you can use NetworkX to create an undirected graph.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX是一个常用的Python库，用于创建、操作和研究图和复杂网络的结构、动态和功能（有关图库的更多信息，请参阅附录A）。以下列表显示了如何使用NetworkX创建无向图。
- en: Listing 3.1 Creating an undirected graph using NetworkX
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 使用NetworkX创建无向图
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Generate a list of nodes from 0 to 4.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从0到4生成节点列表。
- en: ② Define a list of edges.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义边列表。
- en: The output of this code is shown in figure 3.1\. The actual layout you get might
    be different, but the connections among the vertices will be the same as shown
    here.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码的输出显示在图3.1中。您实际得到的布局可能不同，但顶点之间的连接将与这里显示的相同。
- en: '![](../Images/CH03_F01_Khamis.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F01_Khamis.png)'
- en: Figure 3.1 An undirected graph
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 无向图
- en: A *directed graph* is a graph in which a set of nodes are connected using directional
    edges. Directed graphs have many applications, such as representing flow constraints
    (e.g., one-way streets), relations (e.g., causal relationships), and dependencies
    (e.g., tasks that depend on the completion of other tasks). The following listing
    shows how to use NetworkX to create a directed graph.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**有向图**是一种使用方向边连接节点集的图。有向图有许多应用，例如表示流量约束（例如单向街道）、关系（例如因果关系）和依赖关系（例如依赖于其他任务完成的任务）。以下列表展示了如何使用NetworkX创建有向图。'
- en: Listing 3.2 Creating a directed graph using NetworkX
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 使用NetworkX创建有向图
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① DiGraph allows for directed edges.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ① DiGraph允许有向边。
- en: The code output is shown in figure 3.2\. Note the arrows indicating the edge
    directions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 代码输出显示在图3.2中。注意指示边方向的箭头。
- en: '![](../Images/CH03_F02_Khamis.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F02_Khamis.png)'
- en: Figure 3.2 A directed graph
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 一个有向图
- en: A *multigraph* is a graph in which multiple edges may connect the same pair
    of vertices. These edges are called *parallel edges*. Multigraphs can be used
    to represent complex relationships between nodes, such as multiple parallel roads
    between two locations in traffic routing, multiple capacities and demands in resource
    allocation problems, and multiple relationships between individuals in social
    networks, to name just a few. Unfortunately, NetworkX is not particularly good
    at visualizing multigraphs with parallel edges. This listing shows how you can
    use NetworkX in conjunction with the Matplotlib library to create a multigraph.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**多图**是一种可能连接相同顶点对的多条边的图。这些边称为**平行边**。多图可以用来表示节点之间的复杂关系，例如交通路由中两个位置之间的多条并行道路、资源分配问题中的多个容量和需求，以及社交网络中个人之间的多个关系，仅举几例。不幸的是，NetworkX在可视化具有平行边的多图方面并不特别擅长。以下列表展示了如何结合使用NetworkX和Matplotlib库创建多图。'
- en: Listing 3.3 Creating a multigraph using NetworkX
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 使用NetworkX创建多图
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Node positions are generated using the Kamada-Kawai path-length cost function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用Kamada-Kawai路径长度成本函数生成节点位置。
- en: ② Draw each edge one at a time, modifying the curvature of the edge based on
    its index (i.e., the second edge between nodes 0 and 1).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ② 逐个绘制每条边，根据其索引（即节点0和1之间的第二条边）修改边的曲率。
- en: ③ Draw nodes and node labels.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 绘制节点和节点标签。
- en: It is worth noting that `kamada_kawai_layout` attempts to position nodes on
    the space so that the geometric (Euclidean) distance between them is as close
    as possible to the graph-theoretic (path) distance between them. Figure 3.3 shows
    an example of a multigraph generated by this code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`kamada_kawai_layout`试图在空间中定位节点，使得它们之间的几何（欧几里得）距离尽可能接近它们之间的图论（路径）距离。图3.3展示了由该代码生成的多图示例。
- en: '![](../Images/CH03_F03_Khamis.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F03_Khamis.png)'
- en: Figure 3.3 Example of a multigraph. Notice the three parallel edges connecting
    nodes 0 and 1, as well as the two edges connecting nodes 3 and 4.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 多图示例。注意连接节点0和1的三条平行边，以及连接节点3和4的两条边。
- en: As the name implies, an *acyclic graph* is a graph without cycles. A *tree*,
    as a specialized case of a graph, is a connected graph with no cycles or self-loops.
    In graph theory, a connected graph is a type of graph in which there is a path
    between every pair of vertices. A *cycle*, also called a *self-loop* or a *circuit*,
    is an edge in a graph that connects a vertex (or node) to itself. In task scheduling,
    acyclic graphs can be used to represent the relationships between tasks where
    each node represents a task and each directed edge represents a precedence constraint.
    This constraint means that the task represented by the end node cannot start until
    the task represented by the start node is completed. We’ll discuss the assembly
    line balancing problem in chapter 6 as an example of scheduling problems.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，一个**无环图**是一个没有环的图。**树**作为图的特例，是一个没有环或自环的连通图。在图论中，一个连通图是一种图中每对顶点之间都存在路径的图。**环**，也称为**自环**或**回路**，是图中连接一个顶点（或节点）到自身的边。在任务调度中，无环图可以用来表示任务之间的关系，其中每个节点代表一个任务，每条有向边代表一个优先约束。这种约束意味着表示终点节点的任务不能开始，直到表示起点节点的任务完成。我们将在第6章中以装配线平衡问题作为调度问题的例子进行讨论。
- en: The following listing shows how you can use NetworkX to create and verify an
    acyclic graph. An example of an acyclic graph is shown in figure 3.4
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何使用NetworkX创建和验证无环图。图3.4展示了无环图的一个示例。
- en: Listing 3.4 Creating an acyclic graph using NetworkX
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 使用NetworkX创建无环图
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Check if the graph is acyclic.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ① 检查图是否无环。
- en: '![](../Images/CH03_F04_Khamis.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F04_Khamis.png)'
- en: Figure 3.4 An acyclic graph—no path cycles back to any starting node.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4无环图——没有路径会回到任何起始节点。
- en: A *hypergraph* is a generalization of a graph in which the generalized edges
    (called *hyperedges*) can join any number of nodes. Hypergraphs are used to represent
    complex networks because they can capture higher-order many-to-many relationships.
    They’re used in domains such as social media, information systems, computational
    geometry, computational pathology, and neuroscience. For example, a group of people
    working on a project can be represented by a hypergraph. Each person is represented
    by a node, and the project is represented by a hyperedge. The hyperedge connects
    all the people working on the project, regardless of how many people are involved.
    The hyperedge can also contain other attributes, such as the project’s name, the
    start and end dates, the budget, etc.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*超图*是图的推广，其中推广的边（称为*超边*）可以连接任意数量的节点。超图用于表示复杂网络，因为它们可以捕捉更高阶的多对多关系。它们被用于社交媒体、信息系统、计算几何、计算病理学和神经科学等领域。例如，一个在项目上工作的团队可以用超图来表示。每个人由一个节点表示，项目由一个超边表示。超边连接所有参与项目的人，无论涉及多少人。超边还可以包含其他属性，如项目的名称、开始和结束日期、预算等。'
- en: The following listing shows how you can use HyperNetX (HNX) to create a hypergraph.
    HNX is a Python library that enables us to model the entities and relationships
    found in complex networks as hypergraphs. Figure 3.5 shows an example of a hypergraph.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何使用HyperNetX（HNX）来创建超图。HNX是一个Python库，它使我们能够将复杂网络中发现的实体和关系建模为超图。图3.5展示了超图的一个示例。
- en: Listing 3.5 Creating a hypergraph using HyperNetX
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 使用HyperNetX创建超图
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① The data for the hypergraph comes as key-value pairs of hyperedge name/hyperedge
    node groups.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ① 超图的数据以超边名称/超边节点组的键值对形式提供。
- en: ② Create a hypergraph for the provided data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ② 为提供的数据创建超图。
- en: ③ Visualize the hypergraph.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 可视化超图。
- en: '![](../Images/CH03_F05_Khamis.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F05_Khamis.png)'
- en: Figure 3.5 An example of a hypergraph. Hyperedges can connect more than two
    nodes, such as hyperedge 0, which links nodes A, B, and G.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5超图的示例。超边可以连接超过两个节点，例如超边0，它连接节点A、B和G。
- en: Graphs can also be weighted or unweighted. In a *weighted graph*, a weight,
    or value, is assigned to each edge. For example, in the case of road networks,
    the edges could have weights that represent the cost of traversing the road. This
    weight could represent distance, time, or any other metric. In telecommunications
    networks, the weight might represent the cost of utilizing that edge or the strength
    of the connections between the communication devices.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图也可以是有权或无权的。在*加权图*中，每个边都分配一个权重或值。例如，在道路网络的情况下，边可以有代表穿越道路成本的权重。这个权重可以代表距离、时间或任何其他度量。在电信网络中，权重可能代表使用该边的成本或通信设备之间连接的强度。
- en: Listing 3.6 shows how you could create and visualize a weighted graph between
    telecommunication devices. The weights in this example represent the speed of
    connections between the devices in Mbps. Running this code generated the weighted
    graph in figure 3.6.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6展示了如何创建和可视化电信设备之间的加权图。在这个例子中，权重代表设备之间连接的速度，单位为Mbps。运行此代码生成了图3.6所示的加权图。
- en: Listing 3.6 Creating a weighted graph using NetworkX
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 使用NetworkX创建加权图
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① Create an empty weighted graph.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个空的加权图。
- en: ② Add nodes to the graph (representing devices).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ② 向图中添加节点（代表设备）。
- en: ③ Add weighted edges to the graph (representing connections).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 向图中添加加权边（代表连接）。
- en: ④ Get node position attributes from the graph.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 从图中获取节点位置属性。
- en: ⑤ Draw the graph.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 绘制图。
- en: '![](../Images/CH03_F06_Khamis.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F06_Khamis.png)'
- en: Figure 3.6 Example of a weighted graph
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6加权图的示例
- en: Graphs are everywhere. Search engines like Google see the internet as a giant
    graph where each web page is a node, and two pages are joined by an edge if there
    is a link from one page to the other. A social media platform like Facebook treats
    each user profile as a node on a social graph, and two nodes are said to be connected
    if they are each other’s friends or have social ties. The concept of “following”
    a user, such as on a platform like X (previously Twitter), can be represented
    by a directional edge, where user *A* can follow user *B*, but the reverse is
    not necessarily true. Table 3.1 shows the meanings of nodes and edges on different
    social media platforms.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图无处不在。搜索引擎如谷歌将互联网视为一个巨大的图，其中每个网页都是一个节点，如果从一个页面有链接指向另一个页面，则两个页面通过边连接。社交媒体平台如Facebook将每个用户资料视为社交图上的一个节点，如果两个节点互为好友或存在社交联系，则称它们是连接的。在像X（以前是Twitter）这样的平台上“关注”用户的概念可以通过一个有向边表示，其中用户*A*可以关注用户*B*，但反之不一定成立。表3.1显示了不同社交媒体平台上节点和边的含义。
- en: Table 3.1 Examples of graphs in the context of social media
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 社交媒体背景下的图示例
- en: '| Social media platform | Nodes | Edges | Type of edge |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 社交媒体平台 | 节点 | 边 | 边的类型 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Facebook | Users, groups, posts, and events | Friendship, group membership,
    messages, creation of posts, and reactions on posts | Undirected: a like, or react,
    or commentDirected: a friend request |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| Facebook | 用户、群组、帖子以及活动 | 友谊、群组成员、消息、发帖以及帖子上的反应 | 无向：点赞、评论或反应；有向：好友请求 |'
- en: '| X (previously Twitter) | Users, groups, unregistered persons, and posts |
    Following, group membership, messages, creation of posts, and reactions on posts
    | Undirected: a mention or a retweetDirected: the following relationship (when
    you follow a person, they do not automatically follow you back) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| X（以前是Twitter） | 用户、群组、未注册人员和帖子 | 关注、群组成员、消息、发帖以及帖子上的反应 | 无向：提及或转发；有向：关注关系（当你关注一个人时，他们不会自动回关你）
    |'
- en: '| LinkedIn | Users, groups, unregistered persons, posts, skills, and jobs |
    Connections, group membership, posting, reactions on posts, messages, endorsements,
    invitations, recommending jobs | Undirected: an endorsement or recommendationDirected:
    a connection |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 领英 | 用户、群组、未注册人员、帖子、技能和职位 | 联系、群组成员、发帖、帖子上的反应、消息、推荐、邀请、推荐职位 | 无向：推荐或推荐；有向：一个联系
    |'
- en: '| Instagram | Users, comments, containers for publishing posts, hashtags, media
    (e.g., photo, video, story, or album), and pages (Facebook page) | Relationships
    between users such as following, liking, and commenting | Undirected: a like or
    a commentDirected: a follow relationship |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| Instagram | 用户、评论、发布帖子的容器、标签、媒体（例如，照片、视频、故事或专辑）以及页面（Facebook页面） | 用户之间的关系，如关注、点赞和评论
    | 无向：点赞或评论；有向：关注关系 |'
- en: '| TikTok | Users, videos, hashtags, locations, and keywords | Relationships
    between users such as following, liking, and commenting | Undirected: a like or
    commentDirected: a follow relationship |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| TikTok | 用户、视频、标签、位置和关键词 | 用户之间的关系，如关注、点赞和评论 | 无向：点赞或评论；有向：关注关系 |'
- en: In a road network graph, the nodes represent landmarks such as intersections
    and points of interest (POI), and the edges represent the roads. In such a graph,
    most of the edges are directed, meaning that they have specific directions, and
    they may have additional information such as length, speed limit, capacity, etc.
    Each edge is a two-endpoint connection between two nodes, where the direction
    of the edge represents the direction of traffic flow. A *route* is a sequence
    of edges connecting the origin node to the destination node.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在道路网络图中，节点代表地标，如交叉口和兴趣点（POI），边代表道路。在这样的图中，大多数边都是有向的，这意味着它们有特定的方向，并且可能包含额外的信息，如长度、速度限制、容量等。每条边是两个节点之间的两端点连接，其中边的方向代表交通流的方向。*路线*是一系列连接起点节点和终点节点的边。
- en: OSMnx is a Python library developed to simplify the retrieving and manipulating
    of data from OpenStreetMap (OSM; openstreetmap.org). OSM is a crowdsourced geographic
    database of the world (see appendix B for more information about how to fetch
    data from open geospatial data sources). OSMnx lets you download filtered data
    from OSM and returns the network as a NetworkX graph data structure. It can also
    convert a text descriptor of a place into a NetworkX graph (see appendix A for
    more information about graph and mapping libraries). The following listing uses
    the University of Toronto as an example.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: OSMnx 是一个 Python 库，旨在简化从 OpenStreetMap (OSM; openstreetmap.org) 获取和操作数据。OSM
    是一个全球性的众包地理数据库（有关如何从开放地理空间数据源获取数据的更多信息，请参阅附录 B）。OSMnx 允许您从 OSM 下载过滤后的数据，并以 NetworkX
    图数据结构返回网络。它还可以将地点的文本描述符转换为 NetworkX 图（有关图和映射库的更多信息，请参阅附录 A）。以下列表以多伦多大学为例。
- en: Listing 3.7 University of Toronto example
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.7 多伦多大学示例
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① A graph_from_address can also take city names and mailing addresses as input.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ① graph_from_address 也可以接受城市名称和邮寄地址作为输入。
- en: Figure 3.7 shows an OSM map of the area around the St. George campus of the
    University of Toronto. The graph shows the edges and nodes of the road network
    surrounding the campus in downtown Toronto.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 显示了多伦多大学圣乔治校园周边的 OSM 地图。图中显示了多伦多市中心校园周边的道路网络节点和边。
- en: '![](../Images/CH03_F07_Khamis.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F07_Khamis.png)'
- en: Figure 3.7 St. George campus, University of Toronto
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 多伦多大学圣乔治校园
- en: While the map may look visually interesting, it lacks the context of surrounding
    geographic features. Let’s use the folium library (see appendix A) to create a
    base layer map with street names, neighborhood names, and even building footprints.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然地图可能看起来在视觉上很有趣，但它缺乏周围地理特征的上下文。让我们使用 folium 库（请参阅附录 A）创建一个带有街道名称、社区名称甚至建筑足迹的基础层地图。
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Figure 3.8 shows the road network surrounding the St. George campus.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 显示了圣乔治校园周边的道路网络。
- en: '![](../Images/CH03_F08_Khamis.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F08_Khamis.png)'
- en: Figure 3.8 Road network around St. George campus, University of Toronto
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 显示了多伦多大学圣乔治校园周边的道路网络。
- en: Suppose you want to get from one location to another on this campus. For example,
    imagine you’re starting at the King Edward VII equestrian statue near Queen’s
    Park in Toronto, and you need to cross the campus to attend a lecture at the Bahen
    Centre for Information Technology. Later in this chapter, you will see how you
    can calculate the shortest path between these two points.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想在这所校园内从一个地点到另一个地点。例如，想象您从多伦多皇后公园附近的国王爱德华七世骑马雕像出发，需要穿越校园去巴嫩信息技术中心参加讲座。在本章的后面部分，您将看到如何计算这两个点之间的最短路径。
- en: For now, let’s just plot these two locations on the map using the folium library.
    Figure 3.9 shows the folium map and markers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们仅使用 folium 库将这些两个地点绘制在地图上。图 3.9 显示了 folium 地图和标记。
- en: Listing 3.8 Plotting with folium
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 使用 folium 绘图
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① The GPS coordinates (latitude and longitude) of the University of Toronto
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ① 多伦多大学的 GPS 坐标（纬度和经度）
- en: ② The GPS coordinates of the equestrian statue as a source point
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ② 骑马雕像的 GPS 坐标作为源点
- en: ③ The GPS coordinates of the Bahen Centre for Information Technology as the
    destination
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 巴嫩信息技术中心的 GPS 坐标作为目的地
- en: ④ Create a map centered around a specified point.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建以指定点为中心的地图。
- en: ⑤ Add markers wih icons.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 添加带有图标的标记。
- en: '![](../Images/CH03_F09_Khamis.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F09_Khamis.png)'
- en: Figure 3.9 Visualizing points of interest using folium markers
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 使用 folium 标记可视化兴趣点
- en: The output of the code is interactive and allows for features such as zooming,
    panning, and even layer filtering (when enabled). Appendix A provides more details
    about map visualization libraries in Python.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出是交互式的，允许进行缩放、平移甚至图层过滤（当启用时）。附录 A 提供了有关 Python 中地图可视化库的更多详细信息。
- en: 3.2 Graph search
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 图搜索
- en: As I mentioned in chapter 2, search algorithms can be broadly classified into
    deterministic and stochastic algorithms. In *deterministic search*, the search
    algorithm follows a rigorous procedure, and its path and the values of both the
    design variables and the functions are repeatable. The algorithm will follow the
    same path for the same starting point whenever you run the program, whether it’s
    today or ten years in the future. In *stochastic search*, on the other hand, the
    algorithm always has some randomness, and the solution is not exactly repeatable.
    Each time you run the algorithm, you may get slightly different results.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在第二章中提到的，搜索算法可以广泛分为确定性和随机性算法。在*确定性搜索*中，搜索算法遵循严格的程序，其路径以及设计变量和函数的值是可重复的。无论您今天运行程序还是十年后运行，只要起始点相同，算法都会遵循相同的路径。另一方面，在*随机搜索*中，算法总是存在一些随机性，解决方案并不完全可重复。每次运行算法时，您可能会得到略微不同的结果。
- en: Based on the availability of information about the search space or domain knowledge
    (e.g., the distance from the current state to the goal), deterministic search
    algorithms can be broadly classified into *blind* (or *uninformed*) search and
    *informed* search, as illustrated in figure 3.10\. Some of these algorithms, such
    as Kruskal’s minimum spanning tree (MST) algorithm, will be covered in the next
    chapter. This chapter focuses on blind search algorithms. Blind search is a search
    approach where no information about the search space is needed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 根据搜索空间或领域知识（例如，从当前状态到目标的状态距离）的可用性，确定性搜索算法可以广泛分为*盲目*（或*无信息*）搜索和*信息*搜索，如图3.10所示。其中一些算法，如Kruskal的最小生成树（MST）算法，将在下一章中介绍。本章重点介绍盲目搜索算法。盲目搜索是一种不需要关于搜索空间信息的搜索方法。
- en: '![](../Images/CH03_F10_Khamis.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F10_Khamis.png)'
- en: Figure 3.10 Graph search methods
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 图搜索方法
- en: A blind search may conclude upon discovering the first solution, depending on
    the algorithm’s termination criteria. However, the search space may contain numerous
    valid but non-optimal solutions, so a blind search may return a solution that
    meets all the requirements but does so in a non-optimal way. An optimal solution
    can be found by running a blind search following an exhaustive search or brute-force
    strategy to find all the feasible solutions, which can then be compared to select
    the best one. This is similar to applying the British Museum algorithm, which
    finds a solution by checking all possibilities one by one. Given the fact that
    blind search treats every node in the graph or tree equally, this search approach
    is often referred to as a *uniform search*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 盲目搜索可能在发现第一个解决方案时结束，这取决于算法的终止条件。然而，搜索空间可能包含许多有效但非最优的解决方案，因此盲目搜索可能会返回一个满足所有要求但以非最优方式实现的解决方案。可以通过运行一个盲搜索，在穷举搜索或暴力搜索策略之后找到所有可行的解决方案，然后进行比较以选择最佳方案。这类似于应用大英博物馆算法，该算法通过逐一检查所有可能性来找到解决方案。鉴于盲目搜索对待图或树中的每个节点都是平等的，这种搜索方法通常被称为*均匀搜索*。
- en: 'Examples of blind search algorithms include, but are not limited to, the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 盲目搜索算法的例子包括但不限于以下内容：
- en: '*Breadth-first search* (BFS) is a graph traversal algorithm that builds the
    search tree by levels.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*广度优先搜索*（BFS）是一种图遍历算法，通过层次结构构建搜索树。'
- en: '*Depth-first search* (DFS) is a graph traversal algorithm that first explores
    nodes going through one adjacent to the root, then the next adjacent, until it
    finds a solution or it reaches a dead end.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深度优先搜索*（DFS）是一种图遍历算法，首先探索通过根节点的一个相邻节点，然后是下一个相邻节点，直到找到解决方案或达到死胡同。'
- en: '*Depth-limited search* (DLS) is a DFS with a predetermined depth limit.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深度限制搜索*（DLS）是一种具有预定深度限制的DFS。'
- en: '*Iterative deepening search* (IDS), or *iterative deepening depth-first search*
    (IDDFS), combines DFS’s space efficiency and BFS’s fast search by incrementing
    the depth limit until the goal is reached.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迭代加深搜索*（IDS），或*迭代加深深度优先搜索*（IDDFS），结合了DFS的空间效率和 BFS的快速搜索，通过增加深度限制直到达到目标。'
- en: '*Dijkstra’s algorithm* solves the single-source shortest-path problem for a
    weighted graph with non-negative edge costs.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Dijkstra算法*用于解决具有非负边成本的加权图的单源最短路径问题。'
- en: '*Uniform-cost* search (UCS) is a variant of Dijkstra’s algorithm that uses
    the lowest cumulative cost to find a path from the source to the destination.
    It is equivalent to the BFS algorithm if the path cost of all edges is the same.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一致代价*搜索（UCS）是迪杰斯特拉算法的一种变体，它使用最低的累积代价来找到从源到目的地的路径。如果所有边的路径代价相同，则它与BFS算法等价。'
- en: '*Bidirectional* search (BS) is a combination of forward and backward search.
    It searches forward from the start and backward from the goal simultaneously.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双向*搜索（BS）是正向搜索和反向搜索的结合。它同时从起点向前搜索，从目标向后搜索。'
- en: The following sections discuss graph traversal algorithms and shortest path
    algorithms, focusing on BFS, DFS, Dijkstra’s algorithm, UCS, and BS as examples
    of blind search approaches.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节讨论图遍历算法和最短路径算法，重点关注BFS、DFS、迪杰斯特拉算法、UCS和BS作为盲目搜索方法的例子。
- en: 3.3 Graph traversal algorithms
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 图遍历算法
- en: Graph traversal is the process of exploring the structure of a tree or a graph
    by visiting the nodes following a specific, well-defined rule. This category of
    graph search algorithms only seeks to find a path between two nodes without optimizing
    for the length of the final route.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图遍历是通过访问节点并遵循特定的、明确定义规则来探索树或图结构的过程。这类图搜索算法仅寻求找到两个节点之间的路径，而不优化最终路径的长度。
- en: 3.3.1 Breadth-first search
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 广度优先搜索
- en: Breadth-first search (BFS) is an algorithm where the traversal starts at a specified
    node (the source or starting node) and follows the graph layerwise, thus exploring
    all of the current node’s neighboring nodes (those directly connected to the current
    node). Then, if a result has not been found, the algorithm searches the next-level
    neighbor nodes. This algorithm finds a solution if one exists, assuming that a
    finite number of successors, or branches, always follow any node. Algorithm 3.1
    shows the BFS steps.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索（BFS）是一种算法，其遍历从指定的节点（源或起始节点）开始，逐层遍历图，从而探索当前节点的所有相邻节点（与当前节点直接相连的节点）。然后，如果没有找到结果，算法将搜索下一级相邻节点。如果存在解决方案，此算法可以找到解决方案，假设任何节点总是有有限数量的后继者或分支。算法3.1显示了BFS步骤。
- en: Algorithm 3.1 Breadth-first search (BFS)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 算法3.1 广度优先搜索（BFS）
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: BFS uses the queue as a data structure to maintain the states to be explored.
    A queue is a first in, first out (FIFO) data structure, where the node that has
    been sitting on the queue for the longest time is the next node to be expanded.
    BFS dequeues a state off the queue and then enqueues its successors back on the
    queue.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: BFS使用队列作为数据结构来维护要探索的状态。队列是一种先进先出（FIFO）数据结构，其中在队列上等待时间最长的节点是下一个要扩展的节点。BFS从队列中删除一个状态，然后将其后继者重新入队到队列中。
- en: 'Let’s consider the 8-puzzle problem (sometimes called the *sliding-block problem*
    or *tile-puzzle problem*). The puzzle consists of an area divided into a 3 × 3
    grid. The tiles are numbered 1 through 8, except for an empty (or blank) tile.
    The blank tile can be moved by swapping its position with any tile directly adjacent
    (up, down, left, right). The puzzle’s goal is to place the tiles so that they
    are arranged in order. Variations of the puzzle allow the empty tile to end up
    either at the first or last position. This problem is an example of a well-structured
    problem (WSP) with the following well-defined components:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑8数码问题（有时称为*滑动块问题*或*拼图问题*）。这个拼图由一个分成3×3网格的区域组成。瓷砖编号为1到8，除了一个空（或空白）瓷砖。空白瓷砖可以通过与其直接相邻的任何瓷砖交换位置来移动（上、下、左、右）。拼图的目的是将瓷砖排列成顺序。拼图的变体允许空白瓷砖最终位于第一个或最后一个位置。这个问题是一个具有以下明确定义组件的良好结构问题（WSP）的例子：
- en: States—Location of the blank and location of the eight tiles
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态—空白瓷砖的位置和八个瓷砖的位置
- en: Operator (successor)—Blank moves left, right, up, and down
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符（后继者）—空白瓷砖向左、右、上、下移动
- en: Goal—Match the state given by the goal state
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标—匹配给定的目标状态
- en: Solution/path—Sequence through state space
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案/路径—通过状态空间的状态序列
- en: Stopping criteria—An ordered puzzle (reaching the Goal state)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止标准—有序拼图（达到目标状态）
- en: Evaluation criteria—Number of steps or path cost (the path length)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估标准—步数或路径成本（路径长度）
- en: Figure 3.11 illustrates the BFS steps for solving the 8-puzzle problem and the
    search tree traversal order. In this figure, the state represents the physical
    configuration of the 8-puzzle problem, and each node in the search tree is a data
    structure that includes information about its parent, children, depth, and the
    cost of the path from the initial state to this node. Level 1 nodes are generated
    from left to right by moving the blank title left, up, and right respectively.
    Moving forward, level 2 nodes are generated by expanding the previously generated
    nodes in level 1, avoiding the previously explored nodes. We keep repeating this
    procedure to traverse all the possible nodes or until we hit the goal (the shaded
    grid). The number of steps to reach the goal will depend mainly on the initial
    state of the 8-puzzle board. The highlighted numbers show the order of traverse.
    As you can see, BFS progresses horizontally before it proceeds vertically.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11展示了使用BFS解决8个拼图问题的步骤和搜索树遍历顺序。在这个图中，状态代表8个拼图问题的物理配置，搜索树中的每个节点都是一个包含其父节点、子节点、深度和从初始状态到该节点的路径成本的数据结构。第1层节点通过分别向左、上、右移动空白标题从左到右生成。向前移动，第2层节点通过扩展第1层中先前生成的节点生成，避免先前探索的节点。我们重复执行此程序以遍历所有可能的节点或直到达到目标（阴影网格）。达到目标所需的步数主要取决于8个拼图板的初始状态。突出显示的数字显示了遍历的顺序。如您所见，BFS在垂直之前先水平前进。
- en: '![](../Images/CH03_F11_Khamis.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F11_Khamis.png)'
- en: Figure 3.11 Using BFS to solve the 8-puzzle problem
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 使用BFS解决8个拼图问题
- en: Listing 3.9 utilizes a generic BFS algorithm developed for this book, which
    can be found in the Optimization Algorithm Tools (optalgotools) Python package
    (see appendix A for installation instructions). The algorithm takes starting and
    goal states as inputs and returns a `solution` object. This `solution` object
    contains the actual result and some performance metrics, such as processing time,
    maximum space used, and the number of solution states explored. The `State` class
    and `visualize` function are defined in the complete listing available in the
    book’s GitHub repo. The `State` class helps manage some data structures and utility
    functions, and it will allow us to reuse this problem’s structure later with different
    algorithms.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9使用了为本书开发的通用BFS算法，该算法可在Optimization Algorithm Tools (optalgotools) Python包中找到（安装说明见附录A）。该算法以起始状态和目标状态作为输入，并返回一个`solution`对象。这个`solution`对象包含实际结果和一些性能指标，例如处理时间、最大空间使用量和已探索的解决方案状态数量。`State`类和`visualize`函数定义在书中GitHub仓库中可用的完整列表中。`State`类帮助管理一些数据结构和实用函数，并允许我们以后使用不同的算法重用此问题的结构。
- en: Listing 3.9 Solving the 8-puzzle problem using BFS
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9 使用BFS解决8个拼图问题
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① The BFS algorithm is imported from a library called optalgotools.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从名为optalgotools的库中导入BFS算法。
- en: ② See the State class in the complete listing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ② 请参阅完整列表中的State类。
- en: ③ Some boards are not solvable
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 有些拼图板是无法解决的
- en: ④ See the visualize function in the complete listing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 请参阅完整列表中的可视化函数。
- en: 'This is an example solution, given the preceding inputs:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例解决方案，基于前面的输入：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Figure 3.12 shows the state changes following the BFS algorithm.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12显示了BFS算法后的状态变化。
- en: '![](../Images/CH03_F12_Khamis.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F12_Khamis.png)'
- en: Figure 3.12 The step-by-step BFS solution using Python. BFS searches for a solution
    but does not consider optimality.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 使用Python逐步BFS解决方案。BFS寻找解决方案但不考虑最优性。
- en: To really understand how BFS works, let’s look at the steps involved in a simple
    path-planning problem. This problem finds a collision-free path for a mobile robot
    or autonomous vehicle from a start position to a given destination amidst a collection
    of obstacles.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解BFS是如何工作的，让我们看看简单路径规划问题中涉及的步骤。这个问题在障碍物中找到一个移动机器人或自主车辆从起始位置到指定目的地的无碰撞路径。
- en: 1\. Add the source node to the queue (figure 3.13).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 将源节点添加到队列中（图3.13）。
- en: '![](../Images/CH03_F13_Khamis.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F13_Khamis.png)'
- en: Figure 3.13 Solving the path-planning problem using BFS—step 1
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 使用BFS解决路径规划问题——步骤1
- en: 2\. The robot can only move to the south (S) node, as the east (E) and southeast
    (SE) nodes are obstructed (figure 3.14).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 机器人只能移动到南（S）节点，因为东（E）和东南（SE）节点被阻挡（图3.14）。
- en: '![](../Images/CH03_F14_Khamis.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F14_Khamis.png)'
- en: Figure 3.14 Solving the path-planning problem using BFS—step 2
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 使用BFS解决路径规划问题——步骤2
- en: 3\. Take S out (FIFO), and explore its neighboring nodes, S and SE, with E being
    an obstructed node (figure 3.15).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 取出 S（先进先出），并探索其相邻节点，S 和 SE，其中 E 是障碍节点（图 3.15）。
- en: '![](../Images/CH03_F15_Khamis.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F15_Khamis.png)'
- en: Figure 3.15 Solving the path-planning problem using BFS—step 3
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 使用 BFS 解决路径规划问题——第 3 步
- en: 4\. Take S out (FIFO), and explore its neighboring nodes, S and SE (figure 3.16).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 取出 S（先进先出），并探索其相邻节点，S 和 SE（图 3.16）。
- en: '![](../Images/CH03_F16_Khamis.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F16_Khamis.png)'
- en: Figure 3.16 Solving the path-planning problem using BFS—step 4
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 使用 BFS 解决路径规划问题——第 4 步
- en: 5\. Take SE out (FIFO), and explore its neighboring nodes, E and NE (figure
    3.17).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 取出 SE（先进先出），并探索其相邻节点，E 和 NE（图 3.17）。
- en: '![](../Images/CH03_F17_Khamis.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F17_Khamis.png)'
- en: Figure 3.17 Solving the path-planning problem using BFS—step 5
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 使用 BFS 解决路径规划问题——第 5 步
- en: 6\. The FIFO queue continues until the destination node is found (figure 3.18).
    For simplicity, assuming that the robot wants to reach node E shown in figure
    3.18, we can trace back up the tree to find the path from the source node to the
    goal, which will be Start-S-SE-E.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 先进先出队列继续，直到找到目标节点（图 3.18）。为了简单起见，假设机器人想要到达图 3.18 中所示的节点 E，我们可以沿着树向上追踪以找到从源节点到目标节点的路径，这将是从
    Start-S-SE-E。
- en: '![](../Images/CH03_F18_Khamis.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F18_Khamis.png)'
- en: Figure 3.18 Solving the path-planning problem using BFS—final routes for an
    intermediate goal node E and the final destination
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 使用 BFS 解决路径规划问题——中间目标节点 E 和最终目的地的最终路线
- en: In BFS, every node generated must remain in memory. The number of nodes generated
    is at most *O*(*b^d*), where *b* represents the maximum branching factor for each
    node (i.e., the number of children the node has) and *d* is the depth one must
    expand to reach the goal. In the previous example, with E as a goal node (*b*=2,
    *d*=3), the total number of traversed nodes is 2³=8, including the start node.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在广度优先搜索（BFS）中，每个生成的节点都必须保留在内存中。生成的节点数最多为 *O*(*b^d*)，其中 *b* 代表每个节点的最大分支因子（即节点拥有的子节点数），*d*
    是达到目标所需的扩展深度。在先前的例子中，以 E 作为目标节点（*b*=2，*d*=3），遍历的总节点数是 2³=8，包括起始节点。
- en: Aside from the algorithm’s ability to solve the problem at hand, algorithm efficiency
    is evaluated based on run time (time complexity), memory requirements, and the
    number of primitive operations required to solve the problem in the worst case.
    Examples of these primitive operations include, but are not limited to, expression
    evaluation, variable value assignment, array indexing, and method or function
    calls.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了算法解决当前问题的能力外，算法效率还基于运行时间（时间复杂度）、内存需求以及在最坏情况下解决问题所需的原始操作数。这些原始操作包括但不限于表达式评估、变量值赋值、数组索引和方法或函数调用。
- en: Big *O* notation
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 大 *O* 表示法
- en: Big *O* notation describes the performance or complexity of an algorithm, usually
    under the worst-case scenario. Big *O* notation helps us answer the question,
    “Will the algorithm scale?”
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 大 *O* 表示法描述了算法的性能或复杂度，通常是在最坏情况下。大 *O* 表示法帮助我们回答问题：“算法能否扩展？”
- en: To obtain the big *O* notation for a function f(*x*), if f(*x*) is a sum of
    several terms, the one with the largest growth rate is kept, and all others are
    omitted. Moreover, if f(*x*) is a product of several factors, any constants (terms
    in the product that do not depend on *x*) are omitted.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得函数 f(*x*) 的大 *O* 表示法，如果 f(*x*) 是几个项的和，则保留增长速度最快的那个项，其余的项被省略。此外，如果 f(*x*)
    是几个因子的乘积，则省略所有常数（乘积中不依赖于 *x* 的项）。
- en: 'As an example, let’s look at the ticket pricing problem presented in chapter
    1: *f*(*x*) = –20*x*² + 6200*x* – 350000. Assume that *x* is a vector with size
    *n* that represents *n* different ticket prices. This function is the sum of three
    terms, of which the one with the highest growth rate is the one with the largest
    exponent as a function of *x*, namely –20*x*². We can now apply the second rule:
    –20*x*² is a product of –20 and *x*², in which the first factor does not depend
    on *x*. Dropping this factor results in the simplified form *x*². Thus, we say
    that *f*(*x*) is a big *O* of *n*², where *n* is the size of the decision variable
    *x*. Mathematically we can write *f*(*x*) ∈ *O*(*n*²) (pronounced “order *n* squared”
    or “*O* of *n* squared”), which represents a quadratic complexity (i.e., the growth
    rate is proportional to the square of the size of the ticket price vector).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看第1章中提出的票价问题：*f*(*x*) = –20*x*² + 6200*x* – 350000。假设*x*是一个大小为*n*的向量，代表*n*个不同的票价。这个函数是三个项的和，其中增长最快的项是*x*的指数最大的项，即
    –20*x*²。现在我们可以应用第二个规则：–20*x*²是 –20 和 *x*² 的乘积，其中第一个因子不依赖于*x*。去掉这个因子后，得到简化的形式 *x*²。因此，我们说
    *f*(*x*) 是 *n*² 的 big *O*，其中 *n* 是决策变量 *x* 的大小。从数学上我们可以写成 *f*(*x*) ∈ *O*(*n*²*)（发音为“order
    *n* squared”或“*O* of *n* squared”），这代表二次复杂度（即，增长速率与票价向量大小的平方成正比）。
- en: Table 3.2 shows examples of algorithm complexities, and figure 3.19 shows examples
    of big *O* notations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2展示了算法复杂度的示例，图3.19展示了大 *O* 符号的示例。
- en: Table 3.2 Algorithm complexity
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2 算法复杂度
- en: '| Notation | Name | Effectiveness | Description | Examples |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 名称 | 有效性 | 描述 | 示例 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| *O*(1) | Constant | Excellent | Running time does not depend on the input
    size. As the input size grows, the number of operations is not affected. | Variable
    declarationAccessing an array elementRetrieving information from a hash-table
    lookupInserting and removing from a queuePushing and popping on a stack |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| *O*(1) | 常数 | 极佳 | 运行时间不依赖于输入大小。随着输入大小的增长，操作次数不受影响。 | 变量声明访问数组元素从哈希表查找中检索信息从队列中插入和删除在栈上推和弹
    |'
- en: '| *O*(log *n*) | Logarithmic | High | As the input size grows, the number of
    operations grows very slowly. Whenever *n* doubles or triples, etc., the running
    time increases by a constant. | Binary search |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| *O*(log *n*) | 对数 | 高 | 随着输入大小的增长，操作次数增长非常缓慢。每当*n*加倍或三倍等，运行时间增加一个常数。 | 二分查找
    |'
- en: '| O(*n^c*),0 < *c* < 1 | Fractional power or sublinear | High | As the input
    size grows, the number of operations is replicated in multiplication. | Testing
    graph connectednessApproximating the number of connected components in a graphApproximating
    the weight of the minimum spanning tree (MST) |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| O(*n^c*),0 < *c* < 1 | 分数幂或亚线性 | 高 | 随着输入大小的增长，操作次数在乘法中复制。 | 测试图连通性近似图中连通组件的数量近似最小生成树（MST）的权重
    |'
- en: '| *O*(*n*) | Linear | Medium | As the input size grows, the number of operations
    increases linearly. Whenever *n* doubles, the running time doubles. | Printing
    out an array’s elementsSimple searchKadane’s algorithm |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| *O*(*n*) | 线性 | 中等 | 随着输入大小的增长，操作次数线性增加。每当*n*加倍，运行时间也加倍。 | 打印数组元素简单搜索Kadane算法
    |'
- en: '| *O*(*n* log *n*) = *O*(log *n*!) | Linearithmic, loglinear, or quasilinear
    | Medium | As the input size grows, the number of operations increases slightly
    faster than linear. | Merge sortHeapsortTimsort |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| *O*(*n* log *n*) = *O*(log *n*!) | 线性对数，对数线性或准线性 | 中等 | 随着输入大小的增长，操作次数比线性增长略快。
    | 归并排序堆排序Tim排序 |'
- en: '| *O*(*n^c*),*c* > 1 | Polynomial or algebraic | Low | As the input size grows,
    the number of operations increases as the exponent increases. | Minimum spanning
    tree (MST)Matrix determinant |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| *O*(*n^c*),*c* > 1 | 多项式或代数 | 低 | 随着输入大小的增长，操作次数随指数增加而增加。 | 最小生成树（MST）矩阵行列式
    |'
- en: '| *O*(*n*²) | Quadratic | Low | Whenever *n* doubles, the running time increases
    fourfold. The quadratic function is practical for use only on small problems.
    | Selection sortBubble sortInsertion sort |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| *O*(*n*²) | 二次 | 低 | 当*n*加倍时，运行时间增加四倍。二次函数仅适用于小问题。 | 选择排序冒泡排序插入排序 |'
- en: '| *O*(*n*³) | Cubic | Low | Whenever *n* doubles, the running time increases
    eightfold. The cubic function is practical for use only on small problems. | Matrix
    multiplication |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| *O*(*n*³) | 立方 | 低 | 当*n*加倍时，运行时间增加八倍。立方函数仅适用于小问题。 | 矩阵乘法 |'
- en: '| *O*(*c^n*),*c* > 1 | Exponential | Very low | As the input size grows, the
    number of operations increases exponentially. It is slow and usually not appropriate
    for practical use. | Power setTower of HanoiPassword crackingBrute force search
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| *O*(*c^n*),*c* > 1 | 指数 | 非常低 | 随着输入大小的增长，操作次数呈指数增长。它很慢，通常不适用于实际应用。 | 力集汉诺塔密码破解暴力搜索
    |'
- en: '| *O*(*n*!) | Factorial | Extremely low | Extremely slow, as all possible permutations
    of the input data need to be checked. The factorial algorithm is even worse than
    the exponential function. | Traveling salesman problemPermutations of a string
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| *O*(*n*!) | 阶乘 | 非常低 | 非常慢，因为需要检查所有可能的输入数据排列。阶乘算法甚至比指数函数还要差。 | 旅行商问题字符串排列
    |'
- en: '![](../Images/CH03_F19_Khamis.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F19_Khamis.png)'
- en: Figure 3.19 Examples of big *O* notations
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 大*O*表示法的示例
- en: Assume a computer with a processor speed of one million operations per second
    is used to handle a problem of size *n* = 20,000. Table 3.3 shows the running
    time according to the big *O* notation of the algorithm used to solve this problem.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设使用每秒一百万次操作的计算机处理大小为*n* = 20,000的问题。表3.3显示了根据大*O*表示法显示的算法运行时间。
- en: Table 3.3 Algorithm complexity and the running time
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.3 算法复杂度和运行时间
- en: '| Big *O* | Running time |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 大*O* | 运行时间 |'
- en: '| --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| --- | ---'
- en: '| *O*(1) | 10^(-6) seconds |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| *O*(1) | 10^(-6)秒 |'
- en: '| *O*(log *n*) | 14 × 10^(-6) seconds |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| *O*(log *n*) | 14 × 10^(-6)秒 |'
- en: '| *O*(*n*) | 0.02 seconds |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| *O*(*n*) | 0.02秒 |'
- en: '| *O*(*n* log *n*) = *O*(log *n*!) | 0.028 seconds |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| *O*(*n* log *n*) = *O*(log *n*!) | 0.028秒 |'
- en: '| *O*(*n*²) | 6.66 minutes |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| *O*(*n*²) | 6.66分钟 |'
- en: '| *O*(*n*³) | 92.6 days |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| *O*(*n*³) | 92.6天 |'
- en: '| *O*(*c^n*), *c* = 2 | 1262.137 × 10^(6015) years |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| *O*(*c^n*), *c* = 2 | 1262.137 × 10^(6015)年 |'
- en: '| *O*(*n*!) | 5768.665 × 10^(77331) years (this is many orders of magnitude
    larger than the age of the universe, which is around 13.7 billion years) |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| *O*(*n*!) | 5768.665 × 10^(77331)年（这比宇宙的年龄大得多，宇宙年龄约为137亿年） |'
- en: For a huge workspace where the goal is deep, the number of nodes could expand
    exponentially and demand a large memory requirement. In terms of time complexity,
    for a graph G = (V, E), BFS has a running time of *O*(|*V*| + |*E*|), since each
    vertex is enqueued at most once and each edge is checked either once (for a directed
    graph) or at most twice (for an undirected graph). The time and space complexity
    of BFS is also defined in terms of a branching factor *b* and the depth of the
    shallowest goal *d*. Time complexity is *O*(*b^d*), and space complexity is also
    *O*(*b^d*).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个目标为深度的大工作空间，节点数量可能会呈指数增长，并需要大量的内存需求。在时间复杂度方面，对于图G = (V, E)，BFS的运行时间为*O*(|*V*|
    + |*E*|)，因为每个顶点最多入队一次，每条边要么检查一次（对于有向图），要么最多检查两次（对于无向图）。BFS的时间和空间复杂度也以分支因子*b*和最浅目标深度*d*来定义。时间复杂度为*O*(*b^d*)，空间复杂度也是*O*(*b^d*)。
- en: 'Let’s consider a graph with a constant branching factor *b* = 5, nodes of size
    1 KB, and a limit of 1,000 nodes scanned per second. The total number of nodes
    *N* is given by the following equation:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个具有常数分支因子*b* = 5，节点大小为1KB，每秒扫描1000个节点的图。节点总数*N*由以下方程给出：
- en: '|'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/CH03_F19_Khamis-EQ01.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F19_Khamis-EQ01.png)'
- en: '| 3.1 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 3.1 |'
- en: Table 3.4 shows the time and memory requirements to traverse this graph using
    BFS.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.4显示了使用BFS遍历此图的时间和内存需求。
- en: Table 3.4 BFS time and space complexity
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.4 BFS时间和空间复杂度
- en: '| Depth *d* | Nodes *N* | Time | Memory |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 深度*d* | 节点*N* | 时间 | 内存 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 2 | 31 | 31 ms | 31 KB |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 31 | 31毫秒 | 31KB |'
- en: '| 4 | 781 | 0.781 second | 0.78 MB |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 781 | 0.781秒 | 0.78MB |'
- en: '| 6 | 19,531 | 5.43 hours | 19.5 MB |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 19,531 | 5.43小时 | 19.5MB |'
- en: '| 8 | 488,281 | 56.5 days | 488 MB |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 488,281 | 56.5天 | 488MB |'
- en: '| 10 | 12,207,031 | 3.87 years | 12.2 GB |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 12,207,031 | 3.87年 | 12.2GB |'
- en: '| 12 | 305,175,781 | 96.77 years | 305 GB |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 305,175,781 | 96.77年 | 305GB |'
- en: '| 14 | 7,629,394,531 | 2,419.26 years | 7.63 TB |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 7,629,394,531 | 2,419.26年 | 7.63TB |'
- en: Next, we’ll take a look at the counterpart to the BFS algorithm, which searches
    deep into a graph first, rather than breadth-wise.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看BFS算法的对应算法，该算法首先深度搜索图，而不是广度搜索。
- en: 3.3.2 Depth-first search
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 深度优先搜索
- en: Depth-first search (DFS) is a recursive algorithm that uses the idea of backtracking.
    It involves exhaustive searches of all the nodes by first going as deep as possible
    into the graph. Then, when it reaches the last layer with no result (i.e., when
    a dead end is reached), it backtracks up a layer and continues the search. In
    DFS, the deepest nodes are expanded first, and nodes of equal depth are ordered
    arbitrarily. Algorithm 3.2 shows the DFS steps.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索（DFS）是一种递归算法，它使用回溯的思想。它涉及通过首先尽可能深入图中的所有节点来全面搜索所有节点。然后，当它达到没有结果的最后一层（即达到死胡同时），它会回溯一层并继续搜索。在DFS中，最深的节点首先扩展，深度相同的节点任意排序。算法3.2显示了DFS步骤。
- en: Algorithm 3.2 Depth-first search (DFS)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 算法3.2 深度优先搜索（DFS）
- en: '[PRE12]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you may have noticed, the only difference between DFS and BFS is in how the
    data structure works. Rather than working down layer by layer (FIFO), DFS drills
    down to the bottommost layer and moves its way back to the starting node, using
    a last in, first out (LIFO) data structure known as a *stack*. The stack contains
    the list of discovered nodes. The most recently discovered node is pushed onto
    the top of the LIFO stack. Subsequently, the next node to be expanded is popped
    from the top of the stack, and all of its successors are then added to the stack.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，DFS和BFS之间的唯一区别在于数据结构的工作方式。DFS不是按层向下工作（FIFO），而是钻到最底层，然后使用后进先出（LIFO）的数据结构（称为栈）返回到起始节点。栈包含已发现节点的列表。最近发现的节点被推到LIFO栈的顶部。随后，下一个要扩展的节点从栈顶弹出，然后将其所有后继节点添加到栈中。
- en: Figure 3.20 shows the DFS solution for the 8-puzzle problem we looked at before,
    based on moving the blank tile. As you can see, when the algorithm reaches a dead
    end or terminal node (such as node 7), it goes back to the last decision point
    (node 3) and proceeds with another alternative (node 8 and so on). In this example,
    a depth bound of 5 is placed to constrain the node expansion. This depth bound
    makes nodes 6, 7, 10, 11, 13, 14, 16, 17, 22, 23, 26, and 27 terminal nodes in
    the search tree (i.e., they have no successors).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20显示了基于移动空白瓷砖的我们之前看到的8个拼图问题的DFS解决方案。如您所见，当算法达到死胡同或终端节点（如节点7）时，它会回到最后一个决策点（节点3）并继续另一个替代方案（节点8等）。在这个例子中，深度界限设置为5，以限制节点扩展。这个深度界限使得节点6、7、10、11、13、14、16、17、22、23、26和27成为搜索树中的终端节点（即它们没有后继节点）。
- en: '![](../Images/CH03_F20_Khamis.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F20_Khamis.png)'
- en: Figure 3.20 Using DFS to solve the 8-puzzle problem
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 使用DFS解决8个拼图问题
- en: As you can see in listing 3.10, we only need to change the algorithm in the
    code to use DFS. I’ve also omitted the solution visualization, the reason for
    which you’ll see shortly. The `State` class is defined in the complete listing
    available in the book’s GitHub repo.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在列表3.10中看到的，我们只需要更改代码中的算法以使用DFS。我还省略了解决方案的可视化，原因您很快就会看到。《State》类在书中GitHub仓库的完整列表中定义。
- en: Listing 3.10 Solving the 8-puzzle problem using DFS
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.10 使用DFS解决8个拼图问题
- en: '[PRE13]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① Some puzzles are not
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ① 一些谜题并不
- en: ② The inputs for DFS are the same as for BFS.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ② DFS的输入与BFS相同。
- en: 'Here’s the output of this code run with the preceding inputs:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用前面输入运行此代码的输出：
- en: '[PRE14]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, DFS is not great when dealing with very deep graphs, where
    the solution may be located closer to the top. You can also see why I opted not
    to visualize the final solution: there are a lot more steps in the solution than
    we had in BFS! Because the solution to this problem is closer to the root node,
    the solution generated by DFS is a lot more convoluted (30 steps) than with BFS.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，DFS在处理非常深的图时并不出色，解决方案可能更接近顶部。您也可以看到为什么我选择不可视化最终解决方案：与BFS相比，解决方案中的步骤要多得多！因为此问题的解决方案更接近根节点，所以DFS生成的解决方案比BFS要复杂得多（30步）。
- en: 'Revisiting the path-planning problem, DFS can be used to generate an obstacle-free
    path from the start location to the destination as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾路径规划问题，DFS可以用来从起点生成到目的地的无障碍路径，如下所示：
- en: 1\. Add the source node to the stack (figure 3.21).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 将源节点添加到栈中（图3.21）。
- en: '![](../Images/CH03_F21_Khamis.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F21_Khamis.png)'
- en: Figure 3.21 Solving the path-planning problem using DFS—step 1
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 使用DFS解决路径规划问题——步骤1
- en: 2\. Explore the S node, as the E and SE nodes are obstructed (figure 3.22).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 探索S节点，因为E和SE节点被阻挡（图3.22）。
- en: '![](../Images/CH03_F22_Khamis.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F22_Khamis.png)'
- en: Figure 3.22 Solving the path-planning problem using DFS—step 2
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22 使用DFS解决路径规划问题——步骤2
- en: 3\. Take S out (LIFO), and explore its neighboring nodes, S and SE, as E is
    an obstructed node (figure 3.23).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 取出S（后进先出），并探索其相邻节点S和SE，因为E是一个阻塞节点（图3.23）。
- en: '![](../Images/CH03_F23_Khamis.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F23_Khamis.png)'
- en: Figure 3.23 Solving the path-planning problem using DFS—step 3
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23 使用DFS解决路径规划问题——步骤3
- en: 4\. Take SE out (LIFO), and explore its neighboring nodes, SW, S, E, and NE
    (figure 3.24).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 取出SE（后进先出），并探索其相邻节点SW、S、E和NE（图3.24）。
- en: '![](../Images/CH03_F24_Khamis.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F24_Khamis.png)'
- en: Figure 3.24 Solving the path-planning problem using DFS—step 4
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24 使用DFS解决路径规划问题——步骤4
- en: 5\. The next node to be expanded would be NE, and its successors would be added
    to the stack. The LIFO stack continues until the goal node is found. Once the
    goal is found, you can then trace back through the tree to obtain the path for
    the vehicle to follow (figure 3.25).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 下一个要扩展的节点将是NE，其后续节点将被添加到栈中。后进先出栈将继续，直到找到目标节点。一旦找到目标，就可以通过树回溯以获得车辆应遵循的路径（图3.25）。
- en: '![](../Images/CH03_F25_Khamis.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F25_Khamis.png)'
- en: Figure 3.25 Solving the path-planning problem using DFS—step 5
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.25 使用DFS解决路径规划问题——步骤5
- en: DFS usually requires considerably less memory than BFS. This is mainly because
    DFS does not always expand every single node at each depth. However, DFS could
    continue down an unbounded branch forever in the case of a search tree with infinite
    depth, even if the goal is not located on that branch.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: DFS通常比BFS需要的内存少得多。这主要是因为DFS并不总是在每个深度展开每个节点。然而，在具有无限深度的搜索树中，DFS可能会无限期地沿着一个无界分支向下继续，即使目标不在该分支上。
- en: One way to handle this problem is to use *constrained depth-first search*, where
    the search stops after reaching a certain depth. Time complexity of DFS is *O*(*b^d*)
    where *b* is the branching factor and *d* is the maximum depth of the search tree.
    This is terrible if *d* is much larger than *b*, but if solutions are found deep
    in the tree, it may be much faster than BFS. The space complexity of DFS is *O*(*bd*),
    which is linear space! This space complexity represents the maximum number of
    nodes to be stored in memory.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的方法之一是使用*约束深度优先搜索*，搜索在达到一定深度后停止。DFS的时间复杂度为*O*(*b^d*)，其中*b*是分支因子，*d*是搜索树的最大深度。如果*d*远大于*b*，这将是可怕的，但如果解决方案位于树的深处，它可能比BFS快得多。DFS的空间复杂度为*O*(*bd*)，这是线性空间！这种空间复杂度表示在内存中存储的最大节点数。
- en: Table 3.5 summarizes the differences between BFS and DFS.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.5总结了BFS和DFS之间的差异。
- en: Table 3.5 BFS versus DFS
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.5 BFS与DFS的比较
- en: '|  | Breadth-first search (BFS) | Depth-first search (DFS) |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|  | 广度优先搜索（BFS） | 深度优先搜索（DFS） |'
- en: '| --- | --- | --- |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Space complexity | More expensive | Less expensive. Requires only *O*(*d*)
    space, irrespective of the number of children per node. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 空间复杂度 | 更昂贵 | 更便宜。只需要*O*(*d*)空间，无论每个节点的子节点数量是多少。 |'
- en: '| Time complexity | More time efficient. A vertex at a lower level (closer
    to the root) is visited first before visiting a vertex that is at a higher level
    (far away from the root). | Less time efficient |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 时间复杂度 | 更高效。在访问较高层（远离根）的顶点之前，先访问较低层（靠近根）的顶点。 | 较低效 |'
- en: '| When it is preferred |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 何时更受欢迎 |'
- en: If the tree is very deep
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果树非常深
- en: If the branching factor is not excessive
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果分支因子不过度
- en: If the solution appears at a relatively shallow level (i.e., the solution is
    near the starting point in the tree)
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果解决方案出现在相对较浅的水平（即解决方案接近树的起点）
- en: 'Example: Search the British royal family tree for someone who died a long time
    ago, as they would be closer to the top of the tree (e.g., King George VI).'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：搜索英国王室家族树中很久以前去世的人，因为他们会接近树的顶部（例如，乔治六世国王）。
- en: '|'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If the graph or tree is very wide with too many adjacent nodes
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果图或树非常宽，有太多的相邻节点
- en: If no path is excessively deep
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有路径过于深入
- en: If solutions occur deeply in the tree (i.e., the target is far from the source)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果解决方案出现在树的深处（即目标远离源点）
- en: 'Example: Search the British royal family tree for someone who is still alive,
    as they would be near the bottom of the tree (e.g., Prince William).'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：搜索英国王室家族树中仍健在的人，因为他们会在树的底部附近（例如，威廉王子）。
- en: '|'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: In applications where the weights of the edges in a graph are all equal (e.g.,
    all length 1), the BFS and DFS algorithms outperform shortest path algorithms
    like Dijkstra’s in terms of time. Shortest path algorithms will be explained in
    the next section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用中，如果图中边的权重都相等（例如，所有长度为1），则BFS和DFS算法在时间上优于Dijkstra等最短路径算法。最短路径算法将在下一节中解释。
- en: 3.4 Shortest path algorithms
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 最短路径算法
- en: Suppose that you were looking for the quickest way to go from your home to work.
    Graph traversal algorithms like BFS and DFS may eventually get you to your destination,
    but they certainly do not optimize for the distance traveled. We’ll discuss Dijkstra’s
    algorithm, uniform-cost search (UCS), and bidirectional Dijkstra's search as examples
    of blind search algorithms that try to find the shortest path between a source
    node and a destination node.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在寻找从家到工作的最快路线。像BFS和DFS这样的图遍历算法最终可能带你到达目的地，但它们肯定不会优化旅行距离。我们将讨论Dijkstra算法、一致代价搜索（UCS）和双向Dijkstra搜索，作为尝试在源节点和目标节点之间找到最短路径的盲目搜索算法的例子。
- en: 3.4.1 Dijkstra’s search
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 Dijkstra搜索
- en: Dijkstra’s algorithm is a graph search algorithm that solves the single-source
    shortest path problem for a fully connected graph with non-negative edge path
    costs, producing a shortest-path tree. Dijkstra’s algorithm was published in 1959,
    and it’s named after Dutch computer scientist Edsger Dijkstra. This algorithm
    is the base of several other graph search algorithms that are commonly used to
    solve routing problems in popular navigation apps, as illustrated in figure 3.26\.
    The algorithm follows dynamic programming approaches where the problem is recursively
    divided into simple subproblems. Dijkstra’s algorithm is uninformed, meaning it
    does not need to know the target node beforehand and doesn’t use heuristic information.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法是一种图搜索算法，用于解决完全连接图的单源最短路径问题，具有非负边路径成本，生成最短路径树。Dijkstra算法于1959年发表，并以荷兰计算机科学家Edsger
    Dijkstra的名字命名。该算法是其他几个常用图搜索算法的基础，这些算法通常用于解决流行导航应用中的路由问题，如图3.26所示。该算法遵循动态规划方法，将问题递归地分解为简单的子问题。Dijkstra算法是无信息的，这意味着它不需要事先知道目标节点，也不使用启发式信息。
- en: '![](../Images/CH03_F26_Khamis.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图3.26 Dijkstra算法及其变体和扩展示例](../Images/CH03_F26_Khamis.png)'
- en: Figure 3.26 Dijkstra’s algorithm and examples of its variants and extensions
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.26 Dijkstra算法及其变体和扩展示例
- en: Algorithm 3.3 shows the steps of the original version of Dijkstra’s algorithm
    for finding the shortest path between a known single source node to all other
    nodes in the graph or tree.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 算法3.3展示了Dijkstra算法原始版本寻找图中已知单源节点到所有其他节点的最短路径的步骤。
- en: Algorithm 3.3 Dijkstra’s algorithm
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 算法3.3 Dijkstra算法
- en: '[PRE15]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Dijkstra’s algorithm and its variants presented in the code for this book are
    all modified to require a target node. This improves the processing time when
    working with large graphs (e.g., road networks).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 书中代码中提供的Dijkstra算法及其变体都进行了修改，要求指定目标节点。这提高了处理大型图（例如，道路网络）时的处理时间。
- en: Let’s look at how Dijkstra’s algorithm finds the shortest path between any two
    nodes in a graph. The priority queue is used to pop the element of the queue with
    the highest priority according to some ordering function (in this case, the shortest
    distance between the node and the source node).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Dijkstra算法是如何在图中找到任意两个节点之间的最短路径的。优先队列用于根据某种排序函数（在这种情况下，节点与源节点之间的最短距离）弹出队列中具有最高优先级的元素。
- en: '0\. Initial list, no predecessors: priority queue = {} (figure 3.27).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 0. 初始列表，没有前驱节点：优先队列 = {}（图3.27）。
- en: '![](../Images/CH03_F27_Khamis.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图3.27 使用Dijkstra算法寻找最短路径——步骤0](../Images/CH03_F27_Khamis.png)'
- en: Figure 3.27 Finding the shortest path using Dijkstra’s algorithm—step 0
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.27 使用Dijkstra算法寻找最短路径——步骤0
- en: 1\. The closest node to the source node is S, so add it to the priority queue.
    Update the cumulative distances (i.e., distances from the source node *S* to get
    to the node) and predecessors for A, C, and D. Priority queue = {S} (figure 3.28).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 源节点最近的节点是S，因此将其添加到优先队列中。更新A、C和D的累积距离（即从源节点S到达节点的距离）和前驱节点。优先队列 = {S}（图3.28）。
- en: '![](../Images/CH03_F28_Khamis.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图3.28 使用Dijkstra算法寻找最短路径——步骤1](../Images/CH03_F28_Khamis.png)'
- en: Figure 3.28 Finding the shortest path using Dijkstra’s algorithm—step 1
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.28 使用Dijkstra算法寻找最短路径——步骤1
- en: 2\. The next closest node is C, so add it to the priority queue. Update the
    distances and predecessors for A and D. Priority queue = {S, C} (figure 3.29).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 下一个最近的节点是 C，因此将其添加到优先队列中。更新 A 和 D 的距离和前驱节点。优先队列 = {S, C}（图3.29）。
- en: '![](../Images/CH03_F29_Khamis.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F29_Khamis.png)'
- en: Figure 3.29 Finding the shortest path using Dijkstra’s algorithm—step 2
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.29 使用迪杰斯特拉算法寻找最短路径——步骤2
- en: 3\. The next closest node is D, so add it to the priority queue. Update the
    distances and predecessor for B. Priority queue = {S, C, D} (figure 3.30).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 下一个最近的节点是 D，因此将其添加到优先队列中。更新 B 的距离和前驱节点。优先队列 = {S, C, D}（图3.30）。
- en: '![](../Images/CH03_F30_Khamis.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F30_Khamis.png)'
- en: Figure 3.30 Finding the shortest path using Dijkstra’s algorithm—step 3
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.30 使用迪杰斯特拉算法寻找最短路径——步骤3
- en: 4\. The next closest node to the source node is A, so add it to the priority
    queue. Priority queue = {S, C, D, A} (figure 3.31).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 次近的节点是 A，因此将其添加到优先队列中。优先队列 = {S, C, D, A}（图3.31）。
- en: '![](../Images/CH03_F31_Khamis.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F31_Khamis.png)'
- en: Figure 3.31 Finding the shortest path using Dijkstra’s algorithm—step 4
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.31 使用迪杰斯特拉算法寻找最短路径——步骤4
- en: 5\. The next step is to add the remaining node B to complete the search (figure
    3.32). Priority queue = {S, C, D, A, B}. All nodes are now added.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 下一步是将剩余的节点 B 添加以完成搜索（图3.32）。优先队列 = {S, C, D, A, B}。现在所有节点都已添加。
- en: '![](../Images/CH03_F32_Khamis.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F32_Khamis.png)'
- en: Figure 3.32 Finding the shortest path using Dijkstra’s algorithm—step 5
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.32 使用迪杰斯特拉算法寻找最短路径——步骤5
- en: Once the search is complete, you can choose your goal node and find the shortest
    path from the table. For example, if the goal node is A, the shortest path between
    S and A is S-C-A with length 9\. Likewise, if the goal node is B, the shortest
    path between S and B is S-C-D-B with a distance of 10.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索完成后，你可以选择目标节点并从表中找到最短路径。例如，如果目标节点是 A，则 S 和 A 之间的最短路径是 S-C-A，长度为 9。同样，如果目标节点是
    B，则 S 和 B 之间的最短路径是 S-C-D-B，距离为 10。
- en: Note that we can’t use Dijkstra's search on our 8-puzzle problem as Dijkstra's
    search requires knowledge of the entire problem space beforehand. While the problem
    has a finite number of possible states (exactly 9!/2), the scale of that solution
    space makes the Dijkstra's search not very feasible.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不能在我们的8数码问题中使用迪杰斯特拉搜索，因为迪杰斯特拉搜索需要事先了解整个问题空间。虽然该问题有有限数量的可能状态（正好是 9!/2），但该解决方案空间的规模使得迪杰斯特拉搜索不太可行。
- en: 3.4.2 Uniform-cost search (UCS)
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 均匀代价搜索（UCS）
- en: The uniform-cost search (UCS) algorithm is a blind search algorithm that uses
    the lowest cumulative cost to find a path from the origin to the destination.
    Essentially, the algorithm organizes nodes to be explored either by their cost
    (with the lowest cost as the highest priority) for minimization problems, or by
    their utility (with the highest utility as the highest priority) in the case of
    maximization problems.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 均匀代价搜索（UCS）算法是一种盲目搜索算法，它使用最低的累积成本从起点找到到终点的路径。本质上，该算法通过成本（最小化问题中最低成本为最高优先级）或效用（最大化问题中最高效用为最高优先级）来组织要探索的节点。
- en: As nodes are popped from the queue, we add the node’s children to the queue.
    If a child already exists in the priority queue, the priorities of both copies
    of the child are compared, and the lowest cost (the highest priority) in a minimization
    problem is accepted. This ensures that the path to each child is the shortest
    one available. We also maintain a visited list so we can avoid revisiting nodes
    that have already been popped from the queue. UCS behaves like BFS when all the
    edge costs in the graph are equal or identical. In this case, UCS will expand
    nodes in the same order as BFS—level by level or breadth-first. Algorithm 3.4
    shows the steps of the UCS algorithm.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 随着节点从队列中弹出，我们将节点的子节点添加到队列中。如果一个子节点已经在优先队列中存在，则比较两个子节点的优先级，并接受最小化问题中的最低成本（最高优先级）。这确保了到达每个子节点的路径是可用的最短路径。我们还维护一个已访问列表，以便我们可以避免重新访问已经从队列中弹出的节点。当图中的所有边成本相等或相同的时候，UCS
    的行为类似于 BFS。在这种情况下，UCS 将以 BFS 相同的顺序扩展节点——按层或广度优先。算法3.4展示了 UCS 算法的步骤。
- en: Algorithm 3.4 Uniform-cost search (UCS)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 算法3.4 均匀代价搜索（UCS）
- en: '[PRE16]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: UCS is a variant of Dijkstra’s algorithm that is useful for large graphs because
    it is less time-consuming and has fewer space requirements. Whereas Dijkstra's
    adds all nodes to the queue at the start with an infinite cost, UCS fills the
    priority queue gradually. For example, consider the problem of finding the shortest
    path between every node pair in a graph. As a graph’s size and complexity grows,
    it quickly becomes apparent that UCS is more efficient, as it does not require
    knowing the entire graph beforehand. Table 3.6 shows the difference in processing
    time between Dijkstra's and UCS on graphs of different sizes. These numbers were
    collected using the code in Comparison.ipynb, available in the book’s GitHub repo,
    on an Intel Core i9-9900K at 3.60 GHz without multiprocessing or multithreading.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: UCS是Dijkstra算法的一个变体，对于大型图非常有用，因为它耗时较少，空间要求也较少。与Dijkstra算法在开始时将所有节点以无限代价添加到队列中不同，UCS逐渐填充优先队列。例如，考虑在图中找到每对节点之间最短路径的问题。随着图的大小和复杂性的增长，很快就会明显看出UCS更有效率，因为它不需要事先知道整个图。表3.6显示了Dijkstra算法和UCS在不同大小图上的处理时间差异。这些数字是在没有多进程或多线程的情况下，在3.60
    GHz的Intel Core i9-9900K上使用Comparison.ipynb中的代码收集的，该代码可在书籍的GitHub仓库中找到。
- en: Table 3.6 UCS versus Dijkstra's
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.6 UCS与Dijkstra算法比较
- en: '| Graph size = &#124;V&#124; + &#124;E&#124; | Dijkstra time | Uniform-Cost
    Search (UCS) time |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 图大小 = |V| + |E| | Dijkstra时间 | 统一代价搜索(UCS)时间 |'
- en: '| --- | --- | --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 108 | 0.25 s | 0.14 s |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 108 | 0.25 s | 0.14 s |'
- en: '| 628 | 84.61 s | 58.23 s |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 628 | 84.61 s | 58.23 s |'
- en: '| 1,514 | 2,082.97 s | 1,360.98 s |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 1,514 | 2,082.97 s | 1,360.98 s |'
- en: Note that running UCS on our 8-puzzle problem requires a distance property for
    each state (this defaults to 1), and it generates decent results overall (around
    6.2 KB of space used and 789 states explored). It is important to note that because
    the edge lengths are all equal, UCS cannot prioritize new nodes to explore. Thus,
    the solution loses the advantage of shortest path algorithms, namely, the ability
    to optimize for a more compact solution. In the next chapter, you’ll see ways
    of calculating artificial distances between these states, ultimately generating
    solutions quickly and minimizing the number of steps required.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们的8数码问题上进行UCS搜索需要每个状态的距离属性（默认为1），并且总体上生成相当不错的结果（大约使用6.2 KB的空间和探索了789个状态）。重要的是要注意，因为边的长度都相等，UCS无法优先探索新节点。因此，解决方案失去了最短路径算法的优势，即优化更紧凑解决方案的能力。在下一章中，你将看到计算这些状态之间人工距离的方法，最终快速生成解决方案并最小化所需的步骤数。
- en: 3.4.3 Bidirectional Dijkstra's search
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3 双向Dijkstra搜索
- en: Bidirectional search simultaneously applies forward search and backward search.
    As illustrated in figure 3.33, it runs a search forward from the initial source
    state S→G and backward from the final goal state G→S until they meet.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 双向搜索同时应用正向搜索和反向搜索。如图3.33所示，它从初始源状态S→G正向搜索，并从最终目标状态G→S反向搜索，直到它们相遇。
- en: '![](../Images/CH03_F33_Khamis.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F33_Khamis.png)'
- en: Figure 3.33 Bidirectional Dijkstra
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.33 双向Dijkstra算法
- en: As shown in figure 3.33, the Dijkstra's search space is *C*[1] = 4*πr*², and
    the bidirectional Dijkstra's search space is represented by *C*[2] + *C*[3] =
    2*πr*². This means that we reduce the search space by about a factor of two. The
    following algorithm shows the steps of the bidirectional Dijkstra's algorithm.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如图3.33所示，Dijkstra搜索空间为*C*[1] = 4πr²，双向Dijkstra搜索空间由*C*[2] + *C*[3] = 2πr²表示。这意味着我们减少了大约两倍的搜索空间。以下算法显示了双向Dijkstra算法的步骤。
- en: Algorithm 3.5 Bidirectional Dijkstra's
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 算法3.5 双向Dijkstra算法
- en: '[PRE17]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This approach is more efficient because of the time complexities involved. For
    example, a BFS search with a constant branching factor *b* and depth *d* would
    have an overall *O*(*b^d*) space complexity. However, by running two BFS searches
    in opposite directions with only half the depth (*d*/2), the space complexity
    becomes *O*(*b^d*^(/2) + *b^d*^(/2)) or simply O(*b^d*^(/2)), which is significantly
    lower.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法由于涉及的时间复杂度更高，因此更有效率。例如，具有常数分支因子*b*和深度*d*的BFS搜索的整体空间复杂度为*O*(b^d*)。然而，通过以只有一半深度(*d*/2)运行两个相反方向的BFS搜索，空间复杂度变为*O*(b^d^(1/2)
    + b^d^(1/2))，或者简单地O(b^d^(1/2))，这显著降低了。
- en: Figure 3.34 shows the difference between the Dijkstra's and bidirectional Dijkstra's
    algorithms in exploring 50,841 nodes in the City of Toronto.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.34显示了在探索多伦多市50,841个节点时，Dijkstra算法和双向Dijkstra算法之间的差异。
- en: '![](../Images/CH03_F34_Khamis.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F34_Khamis.png)'
- en: Figure 3.34 Dijkstra's vs. bidirectional Dijkstra's—forward exploration from
    the left and backward exploration from the right
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.34 Dijkstra算法与双向Dijkstra算法——从左向右的前向探索和从右向左的后向探索
- en: 3.5 Applying blind search to the routing problem
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 将盲目搜索应用于路由问题
- en: 'Puzzle games and simple grid routing problems are nice for understanding how
    an algorithm works. However, it’s time we look at some real-world examples and
    outcomes of using these algorithms. For example, imagine that you are visiting
    the King Edward VII equestrian statue at Queen’s Park in Toronto when you suddenly
    remember you have a meeting at the Bahen Centre for Information Technology at
    the University of Toronto. I initially presented this problem when we first discussed
    road network graphs at the beginning of this chapter. There are a couple of assumptions
    we’ll make when considering this problem:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑谜题游戏和简单的网格路由问题有助于理解算法的工作原理。然而，是时候看看一些使用这些算法的真实世界示例和结果了。例如，想象一下，当你正在多伦多的皇后公园参观爱德华七世骑马雕像时，你突然想起你有一个在多伦多大学的信息技术中心（Bahen
    Centre）的会议。我最初在讨论本章开头道路网络图时提出了这个问题。在考虑这个问题时，我们将做出以下假设：
- en: You aren’t able to open a navigation app or call a friend for help, as your
    phone is out of battery power.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于你的手机电量耗尽，你无法打开导航应用或打电话求助。
- en: You know your destination is somewhere in Toronto, but you have no clue where
    it is with reference to your starting location. (In later chapters, you’ll learn
    how knowing your destination’s direction can help generate near-optimal solutions
    in a very short amount of time.)
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你知道你的目的地在多伦多某个地方，但你不知道它相对于你的起始位置在哪里。（在后面的章节中，你将学习到知道目的地方向如何在极短的时间内生成近似最优解。）
- en: Once you start using a rule for routing to your destination, you’ll stick to
    that rule.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你开始使用一条规则来规划你的目的地，你就会坚持这条规则。
- en: Let’s look at how we might be able to simulate our pathfinding skills using
    BFS, DFS, Dijkstra's, UCS, and bidirectional Dijkstra's. The code for this example
    is located in the book’s GitHub repo (Comparison.ipynb). Figures 3.35 to 3.37
    show the routes generated by these blind search algorithms.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何可能使用BFS、DFS、Dijkstra算法、UCS和双向Dijkstra算法来模拟我们的路径搜索技巧。这个示例的代码位于本书的GitHub仓库中（Comparison.ipynb）。图3.35至图3.37展示了这些盲目搜索算法生成的路径。
- en: '![](../Images/CH03_F35_Khamis.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图3.35](../Images/CH03_F35_Khamis.png)'
- en: Figure 3.35 Shortest path generated using BFS. BFS searches each layer first
    before moving to the next. This works best for graphs that are not very broad
    and that have a solution near the root node.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.35 使用BFS生成的最短路径。BFS在移动到下一层之前先搜索每一层。当图不是很宽且解决方案靠近根节点时，这种方法效果最佳。
- en: '![](../Images/CH03_F36_Khamis.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图3.36](../Images/CH03_F36_Khamis.png)'
- en: Figure 3.36 Shortest path generated using DFS. DFS searches as deep in the graph
    as possible before backtracking. This works best when the graph is not very deep
    and solutions are located further away from the root node.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.36 使用DFS生成的最短路径。DFS在回溯之前尽可能深入地搜索图。当图不是很深且解决方案位于根节点较远的地方时，这种方法效果最佳。
- en: '![](../Images/CH03_F37_Khamis.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图3.34](../Images/CH03_F37_Khamis.png)'
- en: Figure 3.37 Shortest path generated using Dijkstra’s, UCS, and bidirectional
    Dijkstra’s. All three of these algorithms will produce the same solution (the
    optimal routing) but will handle memory use and node exploration differently.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.37 使用Dijkstra算法、UCS和双向Dijkstra算法生成的最短路径。这三种算法都会产生相同的解决方案（最优路由），但它们在内存使用和节点探索方面会有不同的处理方式。
- en: It is worth noting that the `dijkstra_path` function in NetworkX uses Dijkstra’s
    method to compute the shortest weighted path between two nodes in a graph. Our
    optalgo- tools package also provides an implementation for different graph search
    algorithms such as BFS, DFS, Dijkstra's, UCS, and bidirectional Dijkstra's. The
    implementation of Dijkstra’s algorithm in optalgotools has been modified to work
    with our OSM data because graphs generated from maps will naturally have self-loops
    and parallel edges. Parallel edges may result in a route that is not the shortest
    available, as the route length depends heavily on which parallel edge was chosen
    when a particular path was generated. In figure 3.38, the shortest path from 0
    to 2 may be returned as having a length of 7 if the top edge connecting 0 and
    1 is chosen when calculating that path, versus a length of 3 when selecting the
    bottom edge.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，NetworkX中的`dijkstra_path`函数使用Dijkstra方法来计算图中两个节点之间的最短加权路径。我们的optalgo-tools包还提供了不同图搜索算法的实现，例如BFS、DFS、Dijkstra算法、UCS和双向Dijkstra算法。optalgotools中对Dijkstra算法的实现已经修改，以便与我们的OSM数据一起工作，因为从地图生成的图自然会有自环和并行边。并行边可能导致不是最短可用路径的路线，因为路线长度在很大程度上取决于在生成特定路径时选择了哪条并行边。在图3.38中，从0到2的最短路径可能返回长度为7，如果计算该路径时选择了连接0和1的顶部边，而选择底部边时长度为3。
- en: '![](../Images/CH03_F38_Khamis.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图3.38](../Images/CH03_F38_Khamis.png)'
- en: Figure 3.38 Parallel edges may be problematic because finding the shortest path
    depends on which parallel edge is selected during graph exploration.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.38 并行边可能存在问题，因为找到最短路径取决于在图探索过程中选择了哪条并行边。
- en: Self-loops also cause trouble for the original Dijkstra’s algorithm. If a graph
    contains a self-loop, the shortest path to a node might come from itself. At that
    point, we would be unable to generate a route (figure 3.39).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 自环也会给原始的Dijkstra算法带来麻烦。如果一个图中包含自环，到某个节点的最短路径可能来自该节点本身。在那个时刻，我们就无法生成一条路径（图3.39）。
- en: '![](../Images/CH03_F39_Khamis.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图3.39](../Images/CH03_F39_Khamis.png)'
- en: Figure 3.39 Self-loops may disrupt the chain of parent-child nodes, which prevents
    us from retracing the route after a solution has been found.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.39 自环可能会打断父子节点链，这阻止我们在找到解决方案后重新追踪路径。
- en: These two problems are generally easy but nontrivial to avoid. For parallel
    edges, we select the edge with the lowest weight (shortest length) and discard
    any other parallel edge. With self-loops, we can ignore the loop entirely, as
    negative-weight loops do not exist in most routing problems (a road cannot have
    a negative length), and positive-weight loops cannot be part of the shortest path.
    Additionally, the version of Dijkstra’s algorithm used in this book terminates
    upon finding the target node, as opposed to the traditional implementation, which
    ends only when the shortest path from the root node to all other nodes is found.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题通常容易解决但非同寻常，需要避免。对于并行边，我们选择权重最低（长度最短）的边，并丢弃任何其他并行边。对于自环，我们可以完全忽略该环，因为在大多数路由问题中不存在负权重环（道路的长度不能为负），而正权重环不能成为最短路径的一部分。此外，本书中使用的Dijkstra算法在找到目标节点时终止，而传统的实现方式只有在找到从根节点到所有其他节点的最短路径时才结束。
- en: Table 3.7 compares BFS, DFS, Dijkstra's, and UCS with regards to path length,
    process time, space required, and the number of explored nodes. As you can see
    from these results, Dijkstra’s, UCS, and the bidirectional Dijkstra’s algorithms
    produce optimal results, with varying degrees of time and space cost. While both
    BFS and DFS find feasible solutions in the shortest time, the solutions delivered
    are not optimal and, in the case of DFS, are not even plausible. On the other
    hand, DFS requires knowing the entire graph beforehand, which is costly and sometimes
    not very practical. Much of selecting an appropriate search algorithm for a specific
    problem involves determining the ideal balance between processing time and space
    requirements. In later chapters, we’ll look at algorithms that produce near-optimal
    solutions and that are often used when optimal solutions are either impossible
    or impractical to find. Note that all these solutions are feasible; they all produce
    a valid (if sometimes convoluted) path from point A to point B.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.7比较了BFS、DFS、Dijkstra算法和UCS在路径长度、处理时间、所需空间和已探索节点数方面的差异。从这些结果中可以看出，Dijkstra算法、UCS和双向Dijkstra算法产生最优结果，时间和空间成本各不相同。虽然BFS和DFS都能在最短时间内找到可行解，但提供的解不是最优的，在DFS的情况下甚至是不合理的。另一方面，DFS需要事先知道整个图，这既昂贵又不太实用。为特定问题选择合适的搜索算法很大程度上涉及确定处理时间和空间需求之间的理想平衡。在后面的章节中，我们将探讨产生近似最优解的算法，这些算法通常在最优解既不可能找到又不太实用时使用。请注意，所有这些解决方案都是可行的；它们都能从点A到点B产生一个有效（如果有时复杂）的路径。
- en: Table 3.7 Comparing BFS, DFS, Dijkstra's, and UCS, where *b* is the branching
    factor, *m* is the maximum depth of the search tree, *d* is the shallowest graph
    depth, *E* is the number of edges, and *V* is the number of vertices.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.7比较了BFS、DFS、Dijkstra算法和UCS，其中*b*是分支因子，*m*是搜索树的最大深度，*d*是最浅的图深度，*E*是边的数量，*V*是顶点的数量。
- en: '| Algorithm | Cost (meters) | Process time (s) | Space (bytes) | Explored nodes
    | Worst-case time | Worst-case space | Optimality |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 算法 | 成本（米） | 处理时间（秒） | 空间（字节） | 已探索节点 | 最坏情况时间 | 最坏情况空间 | 最优性 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| BFS | 955.962 | 0.015625 | 1,152 | 278 | *O*(*b^d*) | *O*(*b^d*) | No |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| BFS | 955.962 | 0.015625 | 1,152 | 278 | *O*(*b^d*) | *O*(*b^d*) | No |'
- en: '| DFS | 3347.482 | 0.015625 | 1,152 | 153 | *O*(*b^m*) | *O*(*bm*) | No |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| DFS | 3347.482 | 0.015625 | 1,152 | 153 | *O*(*b^m*) | *O*(*bm*) | No |'
- en: '| Dijkstra’s | 806.892 | 0.0625 | 3,752 | 393 | *O*(&#124;*E*&#124; + &#124;*V*&#124;
    log &#124;*V*&#124;) | *O*(&#124;*V*&#124;) | Yes |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| Dijkstra’s | 806.892 | 0.0625 | 3,752 | 393 | *O*(&#124;*E*&#124; + &#124;*V*&#124;
    log &#124;*V*&#124;) | *O*(&#124;*V*&#124;) | Yes |'
- en: '| UCS | 0.03125 | 592 | 393 | *O*((*b* + &#124;*E*&#124;) * *d*) | *O*(*b^d*)
    | Yes |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| UCS | 0.03125 | 592 | 393 | *O*((*b* + &#124;*E*&#124;) * *d*) | *O*(*b^d*)
    | Yes |'
- en: '| Bidirectional Dijkstra’s | 0.046875 | 3,752 | 282 | *O*(*b^d*^(/2)) | *O*(*b^d*^(/2))
    | Yes |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 双向Dijkstra’s | 0.046875 | 3,752 | 282 | *O*(*b^d*^(/2)) | *O*(*b^d*^(/2))
    | Yes |'
- en: In the next chapter, we will look at how search can be optimized if we utilize
    domain-specific knowledge instead of searching blindly. We’ll dive right into
    informed search methods and see how we can use these algorithms to solve minimum
    spanning tree and shortest path problems.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如果我们利用领域特定知识而不是盲目搜索，如何优化搜索。我们将直接深入研究信息搜索方法，看看我们如何使用这些算法来解决最小生成树和最短路径问题。
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Conventional graph search algorithms (blind and informed search algorithms)
    are deterministic search algorithms that explore a graph either for general discovery
    or for explicit search.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的图搜索算法（盲目和信息搜索算法）是确定性搜索算法，它们探索图是为了一般发现或显式搜索。
- en: A graph is a nonlinear data structure consisting of vertices and edges.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图是一种非线性数据结构，由顶点和边组成。
- en: Blind (uninformed) search is a search approach where no information about the
    search space is used.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盲（无信息）搜索是一种搜索方法，其中不使用关于搜索空间的信息。
- en: Breadth-first search (BFS) is a graph traversal algorithm that examines all
    the nodes in a search tree on one level before considering any of the nodes on
    the next level.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广度优先搜索（BFS）是一种图遍历算法，它在考虑下一层的节点之前，先检查搜索树同一层上的所有节点。
- en: Depth-first search (DFS) is a graph traversal algorithm that starts at the root
    or an initial node or vertex, follows one branch as far as possible, and then
    backtracks to explore other branches until a solution is found or all paths are
    exhausted.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度优先搜索（DFS）是一种图遍历算法，它从根节点或初始节点或顶点开始，尽可能跟随一条分支，然后回溯以探索其他分支，直到找到解决方案或所有路径都耗尽。
- en: Depth-limited search (DLS) is a constrained version of DFS with a predetermined
    depth limit, preventing it from exploring paths beyond a certain depth.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度限制搜索（DLS）是具有预定深度限制的DFS的约束版本，防止它探索超过一定深度的路径。
- en: Iterative deepening search (IDS), or iterative deepening depth-first search
    (IDDFS), combines DFS’s space efficiency and BFS’s fast search by incrementing
    the depth limit until the goal is reached.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代加深搜索（IDS），或迭代加深深度优先搜索（IDDFS），通过增加深度限制直到达到目标，结合了DFS的空间效率和BFS的快速搜索。
- en: Dijkstra’s algorithm solves the single-source shortest path problem for a weighted
    graph with non-negative edge costs.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dijkstra算法解决了加权图中具有非负边成本的单一源最短路径问题。
- en: Uniform-cost search (UCS) is a variant of Dijkstra’s algorithm that uses the
    lowest cumulative cost to find a path from the source to the destination. It is
    equivalent to the BFS algorithm if the path costs of all edges are the same.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广度优先搜索（UCS）是Dijkstra算法的一个变体，它使用最低的累积成本来找到从源到目的地的路径。如果所有边的路径成本相同，则它与BFS算法等价。
- en: Bidirectional search (BS) is a combination of forward and backward search. It
    searches forward from the start and backward from the goal simultaneously.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向搜索（BS）是正向搜索和反向搜索的结合。它同时从起点正向搜索和从目标反向搜索。
- en: Selecting a search algorithm involves determining the target balance between
    time complexity, space complexity, and prior knowledge of the search space, among
    other factors.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择搜索算法涉及确定目标平衡，包括时间复杂度、空间复杂度以及搜索空间的前知等因素。
