- en: 6 Testing and prompt engineering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 测试与提示工程
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding the importance of testing Copilot code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第3章中，我们首先开始看到测试Copilot生成的代码的重要性。对于任何编写软件的人来说，测试是一项基本技能，因为它能让你对代码的正常运行有信心。在本章中，我们将学习如何彻底测试我们的代码，以及如何通过修改我们的提示来帮助Copilot修复不工作的代码。
- en: Using closed-box versus open-box testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用封闭盒与开放盒测试
- en: Addressing errors by Copilot by modifying prompts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过修改提示来解决Copilot的错误
- en: Working through examples of testing Copilot-generated code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过测试Copilot生成的代码的示例
- en: In chapter 3, we first started to see the importance of testing the code produced
    by Copilot. Testing is an essential skill for anyone writing software because
    it gives you confidence that the code is functioning properly. In this chapter,
    we’ll learn how to test our code thoroughly and how to help Copilot fix code that
    doesn’t work by modifying our prompts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 理解测试Copilot代码的重要性
- en: Testing is an essential skill that you’ll need to learn how to do well on your
    own, so that you’re able to check that the code works correctly. Copilot can generate
    tests and has been improving in the quality of tests it produces, but we encourage
    you to hold off on using Copilot to generate tests just yet because you need to
    learn to do this well enough on your own to be able to verify that the tests Copilot
    produces are reasonable. This will be true of the next few chapters as well—problem
    decomposition, testing, and debugging are all skills that are essential to learn
    how to do on your own, before asking for Copilot’s help, as you need to know how
    to do it on your own to know if Copilot is doing something reasonable.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一项你需要学会如何独立做好的基本技能，这样你才能检查代码是否正确运行。Copilot可以生成测试，并且它在生成的测试质量上一直在改进，但我们鼓励你暂时不要使用Copilot来生成测试，因为你需要学会自己足够好地做这件事，以便能够验证Copilot生成的测试是否合理。这一点在接下来的几章中也将是真实的——问题分解、测试和调试都是在你请求Copilot的帮助之前必须学会的技能，因为你需要知道如何自己完成这些任务，才能知道Copilot是否在合理地做事。
- en: 6.1 Why it’s crucial to test code
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 为什么测试代码至关重要
- en: 'Back in chapter 3, we mentioned that you should test code to make sure it’s
    correct. Unfortunately, in our experience, beginning programmers seem to have
    an aversion to testing! Why? We think a couple of things are at play. The first
    is that there’s this well-documented problem nicknamed the *Superbug*, which is
    that humans, when first learning to code, think the computer can understand the
    intent of the code and respond accordingly [1]. Because they wrote the code and
    the code made sense to them, they find it hard to even imagine that the code might
    not work. The second problem is compounded on the first: if you think your code
    is right, testing can only bring you bad news. If you don’t test, you can’t find
    out if the code is wrong. It’s like the old saying about putting your head in
    the sand.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第3章，我们提到你应该测试代码以确保它是正确的。不幸的是，根据我们的经验，初学者似乎对测试有抵触情绪！为什么？我们认为有几个因素在起作用。第一个是有一个被广泛记录的问题，被称为*超级虫*，即人类在刚开始学习编程时，认为计算机可以理解代码的意图并相应地做出反应[1]。因为他们写了代码，代码对他们来说是有意义的，所以他们很难想象代码可能不起作用。第二个问题是在第一个问题的基础上加剧的：如果你认为你的代码是正确的，测试只能给你带来坏消息。如果你不测试，你就无法发现代码是否错误。这就像那句古老的谚语，把头埋在沙子里。
- en: Professional software engineers take a completely different approach than new
    programmers. They take testing extremely seriously because a mistake in the code
    can have significant consequences for their company. No one wants to be the person
    whose code causes the company to lose tons of revenue, lets hackers gain access
    to confidential user data, or has the self-driving car cause an accident. Given
    the cost of a mistake, it makes more sense to assume the code is wrong until proven
    otherwise. Only after testing it extensively should we trust that it’s working
    correctly. And, companies don’t just test the code once, they keep the tests in
    their system so every time someone changes code, tests are run not just on the
    changed code but also on any code that the changed code might affect (this is
    called regression testing).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师与新手程序员采取的方法完全不同。他们非常重视测试，因为代码中的错误可能会给他们的公司带来重大后果。没有人愿意成为导致公司损失大量收入、让黑客获取用户机密数据或导致自动驾驶汽车发生事故的代码编写者。考虑到错误的成本，假设代码是错误的直到证明其正确更有意义。只有经过广泛的测试后，我们才应该相信它正在正确运行。而且，公司不仅仅测试一次代码，他们还保留测试系统，以便每次有人更改代码时，不仅对更改的代码进行测试，而且对更改的代码可能影响的任何代码也进行测试（这被称为回归测试）。
- en: Companies take this so seriously that they often write their tests *before*
    writing their code in a process called test-driven development (TDD). This ensures
    everyone agrees on what the code should or shouldn’t do. We don’t think you (as
    readers) need to take this approach for the programs you’re writing with this
    book, but we mention it here to convey how crucial it is to test. Thinking about
    testing before writing code can help you understand what the code should do and
    that will help you write better prompts. In fact, you can include test cases directly
    in your prompts!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 公司对此非常重视，以至于他们经常在编写代码之前编写测试，这个过程被称为测试驱动开发（TDD）。这确保了每个人都同意代码应该或不应该做什么。我们认为你（作为读者）不需要采取这种方法来编写这本书中的程序，但我们在这里提到它，以传达测试的重要性。在编写代码之前考虑测试可以帮助你理解代码应该做什么，这将帮助你编写更好的提示。事实上，你可以在提示中直接包含测试案例！
- en: 'Finally, let’s remember what we know about Copilot: it makes mistakes. We shouldn’t
    assume anything about the correctness of any code given to us by Copilot. All
    this is to say that any code you’re given by Copilot should be tested before you
    trust it.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们记住关于Copilot我们所知道的事情：它会犯错误。我们不应该对我们从Copilot那里得到的任何代码的正确性做出任何假设。所有这些都意味着，在信任Copilot给出的任何代码之前，都应该对其进行测试。
- en: 6.2 Closed-box and open-box testing
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 封闭盒子和开箱测试
- en: There are two ways that software engineers commonly test their code. The first
    is called closed-box testing, and this approach assumes you know nothing about
    how the code works. As such, this kind of testing involves varying the inputs
    and observing the outputs. We often see closed-box testing applied to functions
    or entire programs. The advantage of closed-box testing is that you don’t need
    to look at the code to perform the tests and can therefore focus simply on the
    desired behavior.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师通常有两种测试代码的方法。第一种被称为封闭盒测试，这种方法假设你对代码的工作方式一无所知。因此，这种测试涉及改变输入并观察输出。我们经常看到封闭盒测试应用于函数或整个程序。封闭盒测试的优势在于，你不需要查看代码来执行测试，因此可以简单地专注于期望的行为。
- en: The second approach to testing is called open-box testing, and in this approach,
    we look at the code to see where the errors might occur. The advantage of open-box
    testing is that by looking at the particular structure of the code, we may see
    where the code is likely to fail and can design additional tests specific to that
    code. We’ll use both closed-box and open-box testing to come up with test cases
    that combine to strengthen our testing. A brief summary of closed-box and open-box
    testing appears in table 6.1\. In this section, let’s look at how we might test
    some functions using these approaches.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的第二种方法被称为开箱测试，在这种方法中，我们查看代码以确定错误可能发生的位置。开箱测试的优势在于，通过查看代码的特定结构，我们可能看到代码可能失败的地方，并可以针对该代码设计特定的额外测试。我们将使用封闭盒子和开箱子测试来制定测试案例，以增强我们的测试。封闭盒子和开箱子测试的简要概述见表6.1。在本节中，让我们看看我们可能如何使用这些方法来测试一些函数。
- en: Table 6.1 Brief overview of closed-box and open-box testing
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.1 封闭盒子和开箱测试简要概述
- en: '| Closed-box testing | Open-box testing |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 封闭盒测试 | 开箱测试 |'
- en: '| --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Requires understanding the function specification to test  | Requires both
    the function specification and the code that implements the function to test  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: 测试需要理解功能规范。测试需要同时理解功能规范和实现该功能的代码。
- en: '| Tests don’t require an understanding of what the code does.  | Tests should
    be tailored based on how the code was written.  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: 测试不需要理解代码的功能。测试应根据代码的编写方式定制。
- en: '| Testers need not have technical expertise about the code they’re testing.  |
    Testers need to be able to understand the code sufficiently well to determine
    which tests may be more important.  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: 测试人员不需要对所测试的代码有技术专长。测试人员需要足够理解代码，以确定哪些测试可能更重要。
- en: '| Tests the function by varying inputs and checking against expected results  |
    Can test the function in the same way as closed-box testing but can also have
    more granular tests within a function  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 通过改变输入并检查预期结果来测试函数 | 可以像封闭盒测试一样测试函数，但也可以在函数内部进行更细粒度的测试 |'
- en: 6.2.1 Closed-box testing
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 封闭盒测试
- en: Let’s imagine we’re trying to test a function that takes in a list of words
    (strings) and returns the longest word. To be more precise, the function signature
    would be
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们正在尝试测试一个函数，该函数接受一个单词（字符串）列表并返回最长的单词。为了更精确，函数签名将是
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The expected input is a list of words. The expected output is the word in that
    list with the most characters. In the event that multiple words are tied for the
    most characters, it should return the first word of that length.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输入是一个单词列表。预期输出是列表中最长的单词。如果多个单词字符数相同，则应返回该长度的第一个单词。
- en: Shorthand for expressing test cases
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试用例的缩写表示
- en: When writing tests for a function, the standard format is to write the function
    name and its input along with the desired outcome. For example, the call
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写函数测试时，标准格式是编写函数名及其输入以及期望的结果。例如，调用
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: means that if we call the function `longest_word` with the input list `['a',`
    `'bb',` `'ccc']`, then the value returned from the function should be `'ccc'`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着如果我们用输入列表`['a', 'bb', 'ccc']`调用函数`longest_word`，那么函数返回的值应该是`'ccc'`。
- en: 'There are two categories for which we typically think about writing test cases:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们通常考虑编写测试用例的两个类别：
- en: '*Common use cases—*These cases include some standard inputs you could imagine
    the function receiving and the corresponding result.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*常见用例—*这些情况包括一些标准输入，你可以想象函数会接收这些输入并得到相应的结果。'
- en: '***Edge cases—*These cases are uncommon but possible cases that might break
    the code. These are inputs that might test some of the rules for the function
    in more depth or contain unexpected inputs (e.g., a list with all empty strings).**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***边缘情况—*这些情况是不常见但可能破坏代码的情况。这些输入可能更深入地测试函数的一些规则或包含意外的输入（例如，所有字符串都为空的列表）。**'
- en: '**Looking back at our `longest_word` function signature in the previous example,
    let’s think about some test cases we might use to test it. Later in the chapter,
    we’ll see how to actually run these test cases to determine whether our code is
    working correctly. Let’s start with *common use cases*. We would likely want to
    include a test with just a few words where one word is longer than the others:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**回顾一下前一个例子中的`longest_word`函数签名，让我们考虑一些可能用来测试它的测试用例。在本章的后面部分，我们将看到如何实际运行这些测试用例以确定我们的代码是否正确工作。让我们从*常见用例*开始。我们可能希望包括一个只有几个单词的测试，其中一个单词比其他单词长：'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s another test with more words with the longest word appearing elsewhere
    in the list:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个包含更多单词的测试，其中最长的单词出现在列表的其他地方：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And last, let’s have a test with just one word:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们有一个只有一个单词的测试：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the program is working for these common uses, our next step would be to think
    about some *edge cases.* Let’s consider some edge cases.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序适用于这些常见用途，我们的下一步将是考虑一些*边缘情况*。让我们考虑一些边缘情况。
- en: 'Say we want to check whether the function conforms to our description by returning
    the first word when there are multiple words of the same length. This test may
    be considered a common case or an edge case, depending on whom you ask:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要检查函数是否按照我们的描述返回多个相同长度单词中的第一个单词。这个测试可能被认为是常见情况或边缘情况，这取决于你问的是谁：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What do we do if all the words in the list have no characters? A string with
    no characters is called an *empty string* and is written as just an empty pair
    of quotes. If all we have is a list of empty strings, then the longest word is
    just the empty string! So, a test with all empty strings should just give us back
    an empty string:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表中的所有单词都没有字符怎么办？没有字符的字符串被称为*空字符串*，写作只是一个空的引号对。如果我们只有一串空字符串，那么最长的单词就是空字符串！因此，使用所有空字符串的测试应该只返回一个空字符串：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The term *edge case* comes from the fact that errors often happen at the “edge”
    of execution, meaning either the first or last element. In many loops, mistakes
    can be made when the loop is starting (e.g., forgetting or mishandling the first
    element in the list) or at the end (e.g., forgetting the last element or going
    past the end of the list and trying to access an element that doesn’t exist).
    Especially when the code is likely to have loops processing many elements, you’ll
    want to watch the behavior at the start and end of the loop.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*边缘情况*来源于错误通常发生在执行的“边缘”，意味着第一个或最后一个元素。在许多循环中，错误可能发生在循环开始时（例如，忘记或错误处理列表中的第一个元素）或结束时（例如，忘记最后一个元素或超出列表的末尾并尝试访问一个不存在的元素）。特别是当代码可能需要处理许多元素的循环时，你将希望观察循环的开始和结束处的行为。
- en: Incorrect input testing
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不正确的输入测试
- en: Another category of tests will test the function on how it responds when given
    incorrect input. We won’t talk about this much in our book because we’re assuming
    you’re correctly calling your own functions, but in production code, this kind
    of testing can be common. A few examples of calling this function with incorrect
    inputs might be to give the function a nonexisting list by using the value `None`
    instead of an actual list (e.g., `longest_word(None)`), to give the function an
    empty list (e.g., `longest_word([])`), to give the function a list with integers
    as input (e.g., `longest_word` `([1,2])`), or to provide a list of strings but
    have the strings contain spaces or more than single words (e.g., `longest_word(['hi`
    `there',` `'` `my` `',` `'friend'])`). It’s hard to say what the function should
    do when given incorrect input, and programmers need to decide whether they care
    about this in larger code bases, but we’ll ignore this category of tests in this
    book because we’ll assume you’ll call your own functions in ways that the functions
    are designed to handle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类测试将测试函数在接收到不正确输入时的响应。在我们的书中我们不会过多地讨论这一点，因为我们假设你正在正确地调用自己的函数，但在实际代码中，这种测试可能是常见的。调用此函数的不正确输入的几个例子可能包括使用值`None`而不是实际的列表来给函数一个不存在的列表（例如，`longest_word(None)`），给函数一个空列表（例如，`longest_word([])`），给函数一个整数列表作为输入（例如，`longest_word([1,2])`），或者提供一个包含空格或超过单个单词的字符串列表（例如，`longest_word(['hi
    there', 'my', 'friend'])`）。很难说函数在接收到不正确输入时应该做什么，程序员需要决定他们是否关心在更大的代码库中这一点，但在这本书中我们将忽略这一类测试，因为我们假设你会以函数设计的方式来调用自己的函数。
- en: 6.2.2 How do we know which test cases to use?
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 我们如何知道要使用哪些测试用例？
- en: In chapter 3, we discussed that good testing involves capturing different categories
    of function calls. One way to find these categories is by using the types of parameters
    and varying their values.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们讨论了良好的测试涉及捕获不同类别的函数调用。找到这些类别的一种方法是通过使用参数类型并改变它们的值。
- en: For example, if the function takes a string or list as a parameter, it may make
    sense to test the case when that string or list is empty, has one element, and
    has multiple elements. If we’re trying to test multiple elements, we might use
    four elements, for example. It likely also wouldn’t make sense to test with five
    or six elements or more because if our code works with four elements, it’s unlikely
    that something could suddenly go wrong when we increase to five. Sometimes, some
    of these test cases may not make sense for a given function; for example, it wouldn’t
    make sense to ask for the longest word in a list that didn’t have any words in
    it, so we wouldn’t test the empty list for our `longest_word` function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果函数接受一个字符串或列表作为参数，那么测试该字符串或列表为空、有一个元素和有多个元素的情况是有意义的。如果我们试图测试多个元素，我们可能会使用四个元素，例如。使用五个或六个元素或更多进行测试可能也没有意义，因为如果我们的代码可以处理四个元素，那么当我们增加到五个时，突然出错的可能性不大。有时，某些测试用例可能对给定的函数没有意义；例如，在列表中没有单词的情况下要求最长的单词是没有意义的，因此我们不会为我们的`longest_word`函数测试空列表。
- en: As another example, if a function takes two numbers as parameters, it may make
    sense to test when one number is zero, both numbers are zero, one number is negative,
    both numbers are negative, and both numbers are positive.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，如果一个函数接受两个数字作为参数，那么测试一个数字为零、两个数字都为零、一个数字为负、两个数字都为负以及两个数字都为正的情况可能是有意义的。
- en: Another way to find categories is to think about the specific task of the function.
    For example, for our `longest_word` function, it’s supposed to be finding the
    longest word, so we should test that it’s actually doing that in a typical case.
    And, if multiple words are the longest, it’s supposed to return the first of those,
    so we should have a test case where the list has multiple words that are the longest.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种寻找类别的方法是思考函数的具体任务。例如，对于我们的`longest_word`函数，它的任务应该是找到最长的单词，因此我们应该测试它在典型情况下是否真的做到了这一点。而且，如果存在多个最长的单词，它应该返回这些单词中的第一个，因此我们应该有一个测试案例，其中列表包含多个最长的单词。
- en: Finding the categories to test is a mix of science and art. We’ve given you
    some rules of thumb here, but what counts as useful test cases often depends on
    the specific functionality being tested. As is so often the case, practicing your
    testing skill is the best way to improve your ability to write useful tests that
    ultimately help you make your code better.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找要测试的类别是一种科学与艺术的结合。我们在这里提供了一些经验法则，但什么是有用的测试案例往往取决于正在测试的具体功能。正如经常发生的那样，练习你的测试技能是提高你编写有用测试的能力的最佳方式，这些测试最终有助于你改进代码。
- en: 6.2.3 Open-box testing
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 开放盒测试
- en: The big difference between open-box testing and closed-box testing is that open-box
    testing examines the code to see if there are additional kinds of test cases to
    check. In theory, closed-box testing may be sufficient to fully test the function,
    but open-box testing tends to give you more ideas about where the code might be
    failing. Let’s say we asked for Copilot to write our `longest_word` function and
    got back the code shown in the following listing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 开放盒测试和封闭盒测试之间的主要区别在于，开放盒测试会检查代码以查看是否有额外的测试案例类型需要检查。理论上，封闭盒测试可能足以完全测试函数，但开放盒测试往往能给你更多关于代码可能失败的地方的思路。假设我们要求Copilot编写我们的`longest_word`函数，并得到了以下列表中所示的代码。
- en: Listing 6.1 Function to find the longest word (incorrect!)
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1：查找最长单词的函数（错误！）
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 >= is wrong. It should be >.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 `>=`是错误的。它应该是`>`。'
- en: 'For this example, we intentionally introduced an error in the code to help
    explain the role of open-box testing. Let’s say that when you were thinking through
    your test cases, you forgot to test what happens when there are two words in the
    list of `words` that both have the most characters. Well, reading through this
    code you might spot the following `if` statement:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们故意在代码中引入了一个错误，以帮助解释开放盒测试的作用。假设你在思考测试案例时，忘记测试当`words`列表中有两个单词都具有最多字符时会发生什么。通过阅读这段代码，你可能会注意到以下`if`语句：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When reading the `if` statement, you might notice that it’s going to update
    the longest word in the list of words when the length of the most recent element
    is greater than *or equal* to the longest word we’ve seen so far. This is a mistake;
    it should be `>`, not `>=`, but suppose you aren’t sure. This would motivate you
    to write a test case like the one we described previously that has multiple words,
    more than one of which is the longest:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读`if`语句时，你可能会注意到它将在最近一个元素的长度大于或等于我们迄今为止看到的最长单词时更新单词列表中的最长单词。这是一个错误；它应该是`>`，而不是`>=`，但假设你不确定。这会促使你编写一个像我们之前描述的那样具有多个单词的测试案例：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This test will fail with the code in listing 6.1 as it would return `'dog'`
    rather than the correct answer of `'cat'`. The test failing is valuable information
    that the code in listing 6.1 is incorrect.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试将因为列表6.1中的代码而失败，因为它会返回`'dog'`而不是正确的答案`'cat'`。测试失败是宝贵的情报，表明列表6.1中的代码是错误的。
- en: As we’ve said, open-box testing is useful because it leads to test cases that
    follow the structure of the code itself. For example, if our code is using a loop,
    we’ll find that loop when doing open-box testing. The loop in listing 6.1 is correct,
    but by seeing the loop in our code, we’ll be reminded to test the edge cases to
    make sure it’s properly handling the first element, the last element, and an empty
    list. In sum, knowing how the code is processing the input often offers insight
    into when the program might be misfunctioning.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，开箱测试是有用的，因为它会导致遵循代码自身结构的测试用例。例如，如果我们的代码使用了循环，我们将在进行开箱测试时找到那个循环。列表 6.1
    中的循环是正确的，但通过看到我们的代码中的循环，我们会提醒自己测试边界情况，以确保它正确地处理了第一个元素、最后一个元素以及空列表。总的来说，了解代码如何处理输入通常可以提供关于程序何时可能出现故障的见解。
- en: 6.3 How to test your code
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 如何测试你的代码
- en: There are a number of good ways to test your code that vary from quick tests
    you might perform just to check if your code is working for yourself to tests
    that are built into a company’s regression test suite. For production code, Python
    programmers typically use testing tools more powerful and full-featured than what
    we’re about to demonstrate in this chapter. The most common of those tools is
    pytest, which is a module that needs to be installed before it can be used. We
    feel that pytest is beyond what we need here to introduce the core ideas of testing.
    We’ll focus on more lightweight testing to help you gain confidence that the code
    from Copilot works properly. We can do that either by testing at the Python prompt
    or using a built-in Python module called doctest.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多好的方法可以测试你的代码，这些方法从你为了检查代码是否对你自己工作而进行的快速测试，到集成到公司回归测试套件中的测试。对于生产代码，Python
    程序员通常使用比我们在本章将要展示的更强大、功能更全面的测试工具。其中最常见的是 pytest，这是一个在使用之前需要安装的模块。我们认为 pytest 超出了我们在这里介绍测试核心思想的需要。我们将专注于更轻量级的测试，以帮助你确信
    Copilot 生成的代码能够正常工作。我们可以通过在 Python 提示符中进行测试或使用一个名为 doctest 的内置 Python 模块来实现这一点。
- en: 6.3.1 Testing using the Python prompt
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 使用 Python 提示符进行测试
- en: The first way to test is in the Python prompt through the interactive window
    like we have in the previous chapters. The advantage of this testing is that it
    can be quick to run, and you can easily add more tests as a result of output from
    the previous test. The tests we’ve run so far are examples of testing with the
    Python prompt. For example,
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的第一种方式是在 Python 提示符中通过交互式窗口进行，就像我们在前面的章节中所做的那样。这种测试的优势在于它可以快速运行，并且你可以根据前一次测试的输出轻松地添加更多测试。我们迄今为止运行的测试是使用
    Python 提示符进行测试的例子。例如，
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In running that test, if you expected the result to be `'cat'`, you’d be pleased
    to see that result. However, if the test shows that your code was wrong, you now
    have the opportunity to go back to fix it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行那个测试时，如果你期望结果是 `'cat'`，你会很高兴看到那个结果。然而，如果测试显示你的代码有误，你现在有机会回去修复它。
- en: After you fix the code, you’ll want to test the new code. Here is where you
    may go wrong with testing using the Python prompt alone. When you come back to
    test the code you just changed, you might be tempted to run *just* the test case
    that had failed previously. However, in fixing the code to correctly address the
    test case that had failed, you could have introduced an error that would cause
    the *previous* test cases that had already passed to now fail. What you really
    want then is a way to run not just your current test but all previous tests as
    well.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 修复代码后，你将想要测试新的代码。这就是你可能会在使用 Python 提示符进行测试时出错的地方。当你回来测试你刚刚更改的代码时，你可能会倾向于只运行之前失败的测试用例。然而，在修复代码以正确处理失败的测试用例时，你可能会引入一个错误，导致之前已经通过的测试用例现在失败。你真正想要的是一种方法，不仅可以运行当前的测试，还可以运行所有之前的测试。
- en: 6.3.2 Testing in your Python file (we won’t be doing it this way)
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 在你的 Python 文件中进行测试（我们不会这样做）
- en: It would be tempting to then put all your test cases in your Python program
    (outside a function, so in the equivalent of a main function) so they can all
    run. This solution addresses the problem with Python prompts that we just described,
    but it introduces a new problem. What happens when you want your Python program
    to perform the main task for which it was designed rather than just run tests?
    You could delete all the tests, but the point was running them again if so desired.
    You could comment them out so you can run them in the future, but that’s not a
    very clean solution either. What we want then is a way to run all our tests on
    our functions when we want to but still have the ability to run the program. The
    way to do this is using a module called doctest.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 很有可能会把所有的测试用例都放在你的Python程序中（在函数外部，相当于主函数中），这样它们都可以运行。这种解决方案解决了我们刚才描述的Python提示问题，但它引入了新的问题。当你想要你的Python程序执行它被设计的主要任务而不是仅仅运行测试时会发生什么？你可以删除所有测试，但这样做的目的是在需要时再次运行它们。你可以将它们注释掉，以便将来运行它们，但这也不是一个很干净的办法。我们想要的，然后，是在我们想要的时候运行我们函数的所有测试，但仍然能够运行程序。要做到这一点，可以使用一个名为doctest的模块。
- en: 6.3.3 doctest
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 doctest
- en: The doctest module is built in to Python. The great thing about using doctest
    is that we simply add our test cases to the docstring that describes the function.
    This beefed-up docstring serves a dual purpose. First, we can use doctest to run
    all those test cases whenever we’d like. Second, it can sometimes help Copilot
    generate better code in the first place or fix already-written code that isn’t
    quite working. Let’s write that `longest_word` function with all the test cases
    included and ready to be executed with doctest (see listing 6.2).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: doctest模块是Python内置的。使用doctest的好处在于，我们只需将测试用例添加到描述函数的文档字符串中。这个增强的文档字符串具有双重作用。首先，我们可以使用doctest在需要时运行所有这些测试用例。其次，它有时可以帮助Copilot在最初生成更好的代码，或者修复已经编写但不太正常工作的代码。让我们编写一个包含所有测试用例并准备好用doctest执行的`longest_word`函数（参见列表6.2）。
- en: Listing 6.2 Using doctest to test the `longest_word` function
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.2 使用doctest测试`longest_word`函数
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 Shows the test cases for doctest'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 显示doctest的测试用例'
- en: '#2 Shows the correct code for the function'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 显示函数的正确代码'
- en: '#3 Code (in main) that calls doctest to perform the test'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 调用doctest执行测试的代码（在main中）'
- en: In this code, we see the docstring with our test cases provided as the prompt
    to Copilot. Copilot generated the correct code to implement this function. We
    then manually wrote the last two lines of the code to perform the testing. When
    run, we get the output in the following listing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们看到文档字符串中提供了我们的测试用例作为Copilot的提示。Copilot生成了正确的代码来实现这个函数。然后我们手动编写了代码的最后两行来执行测试。运行后，我们得到以下列表中的输出。
- en: Listing 6.3 Doctest output from running our program in listing 6.2
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.3 列出6.2中程序运行时的doctest输出
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#1 First test in longest_word passed'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 `longest_word`函数的第一次测试通过'
- en: '#2 Second test in longest_word passed'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 `longest_word`函数的第二次测试通过'
- en: '#3 Third test in longest_word passed'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 `longest_word`函数的第三次测试通过'
- en: '#4 Fourth test in longest_word passed'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 `longest_word`函数的第四次测试通过'
- en: '#5 Fifth test in longest_word passed'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 `longest_word`函数的第五次测试通过'
- en: '#6 There are no tests in main (outside the function).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 主函数（函数外部）中没有测试。'
- en: '#7 longest_word passed all tests.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 `longest_word`通过了所有测试。'
- en: '#8 0 failed is what you hope to see.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 希望看到的是0个失败。'
- en: 'From this output, we can see that each test ran and each test passed. The reason
    these tests ran is because of the last two lines that we added in listing 6.2:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，我们可以看到每个测试都运行了，并且每个测试都通过了。这些测试之所以能运行，是因为我们在列表6.2中添加的最后两行：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the first line, we import the doctest module. That’s the module that helps
    us test our code by automatically running the test cases when we run our program.
    In the second line, we’re calling the `testmod` function from the doctest module.
    That function call tells doctest to perform all the tests; the argument `verbose=True`
    tells doctest to give us the outcome for all tests, whether they pass or not.
    If we switch to `verbose=False`, it will only give us output if test cases fail
    (`verbose=False` is actually the default, so you can just call the function with
    no arguments, and it will default to not providing output unless one or more tests
    fail). This can be a nice feature as we can keep the doctest running and only
    see the output when tests fail.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们导入了doctest模块。这个模块帮助我们通过在运行程序时自动执行测试用例来测试我们的代码。在第二行，我们调用doctest模块中的`testmod`函数。这个函数调用告诉doctest执行所有测试；参数`verbose=True`告诉doctest为我们提供所有测试的结果，无论它们是否通过。如果我们切换到`verbose=False`，它只有在测试用例失败时才会给出输出（`verbose=False`实际上是默认值，所以你可以不带参数调用函数，它将默认不提供输出，除非一个或多个测试失败）。这可以是一个很好的特性，因为我们可以在doctest运行时保持其运行，并且只有在测试失败时才看到输出。
- en: In this case, our code passed all the test cases. But let’s experience what
    happens when our code doesn’t pass.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的代码通过了所有测试用例。但让我们体验一下当我们的代码没有通过时会发生什么。
- en: If we find a word that’s the same length as our current longest word, we should
    ignore it because we always want to return the first longest word if there are
    multiple words tied for the longest. That’s why the correct thing to do is to
    use `>` in the `if` statement (finding a new longest word only if it’s truly longer
    than our current longest word) rather than `>=`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现一个单词的长度与当前最长的单词相同，我们应该忽略它，因为我们总是希望在有多个单词长度相同时返回第一个最长的单词。这就是为什么在`if`语句中使用`>`（只有当新找到的最长单词确实比当前最长的单词长时才寻找新的最长单词）而不是`>=`是正确做法的原因。
- en: We can break the code in listing 6.2 then by changing the `>` to `>=`, which
    will cause it to select the last word of the longest length rather than the first.
    Let’s change the following line from
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将列表6.2中的`>`改为`>=`来中断代码，这将导致它选择最长单词的最后一个单词而不是第一个。让我们将以下行更改为
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: to
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 更改为
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, the tests shouldn’t all pass. In addition, let’s change the last line to
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试不应该全部通过。此外，让我们将最后一行更改为
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By providing no arguments to the `testmod` function, `verbose` is now set to
    `False`. When we run the code, this is the output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不对`testmod`函数提供任何参数，`verbose`现在被设置为`False`。当我们运行代码时，这是输出：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Doctest conveniently tells us which test was run, what the expected output was,
    and what the function produced instead. This would catch the bug and allow us
    to go back to fix the error.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Doctest方便地告诉我们哪个测试被执行了，预期的输出是什么，以及函数实际产生了什么。这将捕获错误并允许我们返回去修复错误。
- en: Test cases aren’t automatically run by Copilot
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Copilot不会自动运行测试用例
- en: 'We commonly hear the following question: Why doesn’t Copilot directly incorporate
    the test cases when generating code? For example, if we add test cases, it would
    be nice if Copilot could try to generate functions and only provide us with the
    code that would pass those test cases. Unfortunately, there are some technical
    challenges in doing this, and as of the time of writing, this feature isn’t yet
    included. So, if you add test cases, it just improves the prompt to Copilot but
    doesn’t guarantee that the Copilot code suggestion passes those tests.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常听到以下问题：为什么Copilot在生成代码时不直接包含测试用例？例如，如果我们添加测试用例，如果Copilot能够尝试生成函数并且只提供通过那些测试用例的代码，那会很好。不幸的是，在这方面存在一些技术挑战，并且截至写作时，这个功能尚未包含。所以，如果你添加测试用例，它只是改善了Copilot的提示，但不能保证Copilot的代码建议通过那些测试。
- en: At this point, we’ve seen how to run our tests with both the Python prompt and
    doctest. Now that we know how to test our code, let’s think about how this modifies
    our code design cycle.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用Python提示符和doctest运行我们的测试。现在我们知道如何测试我们的代码了，让我们考虑一下这如何修改我们的代码设计周期。
- en: 6.4 Revisiting the cycle of designing functions with Copilot
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 重新审视使用Copilot设计函数的周期
- en: In chapter 3, we gave you an early version of how to design functions in figure
    3.3\. At that point, we didn’t know as much about examining our code (which we
    learned in chapters 4 and 5) or as much about how to test our code as we do now.
    As such, let’s create a new version of this cycle (figure 6.1) to reflect our
    new understanding.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们在图3.3中给出了如何设计函数的早期版本。在那个阶段，我们对检查我们的代码（我们在第4章和第5章中学习了）或如何测试我们的代码（我们现在知道的更多）了解得不多。因此，让我们创建这个周期的新的版本（图6.1），以反映我们新的理解。
- en: '![figure](../Images/6-1.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/6-1.png)'
- en: Figure 6.1 The function design cycle with Copilot, augmented to include more
    about testing
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1 使用Copilot的函数设计周期，增加了更多关于测试的内容
- en: 'The figure is a bit more complex than before, but if we examine it closely,
    we can see much of the original process is retained. The things that have been
    added or changed include the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图比之前复杂一些，但如果我们仔细观察，我们可以看到保留了大部分原始过程。增加或改变的内容包括以下：
- en: When we write the prompt, we may include doctests as part of that initial prompt
    to help Copilot in generating the code.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们编写提示时，我们可能将doctests作为初始提示的一部分来帮助Copilot生成代码。
- en: Having made our way through chapters 4 and 5, we’re in good shape to read the
    code to see whether it behaves properly, so we now have an additional step to
    address what happens when the initial code from Copilot looks wrong. If that occurs,
    we’ll use Ctrl-Enter to explore the Copilot suggestions to hopefully find a solution.
    If we can find such a solution, we’ll select it and move forward. If we can’t,
    we’ll need to revise our prompt to help Copilot generate improved suggestions.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经过第4章和第5章的学习，我们现在可以阅读代码来检查其行为是否正常，因此我们现在有一个额外的步骤来处理Copilot的初始代码看起来不正确的情况。如果发生这种情况，我们将使用Ctrl-Enter来探索Copilot的建议，希望能找到解决方案。如果我们能找到这样的解决方案，我们将选择它并继续前进。如果我们找不到，我们需要修改我们的提示来帮助Copilot生成改进的建议。
- en: After finding code that looks like it could be correct, we’ll run doctest to
    see whether the code passes the doctests we included in the prompt (if we didn’t
    include any, it will pass automatically). If doctest passes, then we can continue
    adding tests and checking them until we’re happy that the code is functioning
    properly. If doctest fails, we’ll need to figure out how to modify the prompt
    to address the failed tests. Once the prompt is modified, it will hopefully help
    Copilot generate new code that may be capable of passing the tests that we’ve
    provided.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在找到看起来可能正确的代码后，我们将运行doctest来查看代码是否通过了我们在提示中包含的doctests（如果没有包含任何，它将自动通过）。如果doctest通过，那么我们可以继续添加测试并检查它们，直到我们满意代码正常工作。如果doctest失败，我们需要找出如何修改提示来解决失败的测试。一旦修改了提示，它可能会帮助Copilot生成新的代码，可能能够通过我们提供的测试。
- en: With this new workflow, we’re in a much better position not only to determine
    whether our code is working properly but also to fix the code if it isn’t already
    working. In the next chapters, we’ll give ourselves even more tools to help when
    the code isn’t working properly, but for now, let’s put this all together by solving
    a new problem and testing the Copilot solutions using the workflow we described
    here.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新的工作流程，我们不仅能够确定我们的代码是否正常工作，而且在代码尚未正常工作时也能修复代码。在接下来的章节中，我们将提供更多的工具来帮助我们在代码不正常工作时进行操作，但到目前为止，让我们通过解决一个新的问题并使用这里描述的工作流程测试Copilot的解决方案来将这些内容综合起来。
- en: 6.5 Full testing example
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 完整测试示例
- en: Let’s try a problem that we might need to solve to help students decide where
    to sit in in-person classes. Although we’re talking about finding empty seats
    in a classroom, this problem is the same as trying to find the number of empty
    seats in a concert hall, theater, movie theater, or office layout.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个可能需要解决的问题，以帮助学生决定在面对面课程中坐在哪里。虽然我们谈论的是在教室中寻找空座位，但这个问题与尝试在音乐厅、剧院、电影院或办公室布局中找到空座位是相同的。
- en: Suppose we have the classroom layout as a two-dimensional list with rows of
    seats. Each seat either contains a space (`'` `'`) or a student (`'S'`) to represent
    an empty or occupied seat, respectively. We’re going to ask Copilot to create
    a function to determine which row we could add the most students to, and along
    the way, we’ll design the tests needed to check whether the code is working properly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个教室布局，它是一个二维列表，包含座位行。每个座位要么包含一个空格(`'` `'`)，要么包含一个学生(`'S'`)，分别表示空座位或占用座位。我们将要求Copilot创建一个函数来确定我们可以添加最多学生的行，在这个过程中，我们将设计检查代码是否正常工作的测试。
- en: 6.5.1 Finding the most students we can add to a row
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 寻找我们可以添加到一行中的最多学生数
- en: We want to figure out the largest number of new students we could add in a single
    row in the classroom. (Equivalently, we’re looking for the largest number of empty
    seats in any row.) For this, let’s start with a somewhat ambiguous prompt and
    see how well Copilot does.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想找出我们可以在教室的单行中添加的最大新学生数。（等价地，我们正在寻找任何一行中的最大空座位数。）为此，让我们从一个有些含糊的提示开始，看看Copilot的表现如何。
- en: Listing 6.4 Largest number of students we can add to a row
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.4我们可以添加到一行中的最大学生数
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '#1 This is a somewhat ambiguous part of the prompt.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这部分提示有些含糊不清。'
- en: 'For the sake of this example, our prompt wasn’t very good. “How many new students
    can sit in a row?” is a reasonable starting point to give to a human, but it’s
    not that specific, and it’s easy to imagine Copilot struggling to interpret what
    we mean. Copilot might get confused about whether we’re counting the number of
    students or the number of empty seats in a row, or it might return the total number
    of available seats in the classroom rather than in a row. It turns out that our
    prompt confused Copilot, and the code isn’t correct, but before we dive into the
    code, let’s think about what tests we should run. We’ve come up with the following
    set of test cases:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个例子，我们的提示不是很清楚。“一行中可以坐多少新学生？”对于一个人类来说是一个合理的起点，但它不是很具体，很容易想象Copilot在解释我们的意思时会感到困惑。Copilot可能会弄不清楚我们是计算每行的学生数还是空座位数，或者它可能会返回教室中可用的总座位数而不是一行的座位数。结果证明，我们的提示让Copilot感到困惑，代码并不正确，但在我们深入代码之前，让我们考虑我们应该运行哪些测试。我们已经想出了一套测试案例：
- en: A classroom with some number of consecutive empty seats and some number of nonconsecutive
    empty seats to make sure it isn’t just counting consecutive empty seats
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个教室中有一些连续的空座位和一些非连续的空座位，以确保它不仅仅是在计算连续的空座位数量
- en: A classroom with no empty seats to make sure it returns 0 in that case
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个没有空座位的教室，以确保在这种情况下返回0
- en: A classroom with a row full of empty seats to make sure all are counted, including
    the first and last seats (edge case)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个行满空座的教室，以确保所有座位都被计算在内，包括第一和最后一个座位（边缘情况）
- en: A classroom with multiple rows with the same number of empty seats to make sure
    it returns just one of those values (and not, perhaps, the sum of the number of
    empty seats across all of these rows)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有多行且每行空座位数相同的教室，以确保它只返回这些值中的一个（而不是，也许，所有这些行中空座位的总和）
- en: Let’s start by adding the first test case and adding the doctest code to run
    the test, as shown in the following listing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加第一个测试案例，并添加doctest代码来运行测试，如下所示。
- en: Listing 6.5 Largest number of students we can add to a row
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.5我们可以添加到一行中的最大学生数
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#1 Doctest for a common case. The \ is necessary in docstring test cases if
    you need to do a newline.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 常见情况的Doctest。在docstring测试案例中，如果需要换行，\是必要的。'
- en: 'When we run this code, we get this output (we cleaned up the formatting of
    the classroom list manually to help with the readability of the answer):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们得到以下输出（我们手动清理了教室列表的格式，以帮助提高答案的可读性）：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Although we’d prefer the code to work, we appreciate that the first test case
    found an error. The row with the most empty seats is the third row with four seats
    available. But the code from Copilot is incorrectly telling us the answer is six.
    That’s pretty odd. Even without reading the code, you might hypothesize that it’s
    counting either the number of seats per row or the maximum number of students
    seated per row. Our test case had a full row of students in the second row, so
    it’s hard to tell. What we can do is change the classroom to be
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们希望代码能正常工作，但我们欣赏第一个测试案例发现了错误。最多空座位的行是第三行，有四个座位可用。但Copilot的代码错误地告诉我们答案是六个。这很奇怪。即使不阅读代码，你也可能假设它是在计算每行的座位数或每行最多可坐的学生数。我们的测试案例中第二行有一排满的学生，所以很难判断。我们可以做的是将教室改为
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '#1 We removed the first student from the second row.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们从第二行移除了第一个学生。'
- en: So, the second row now has five students. When we run the code again, the test
    again fails with the code giving us an answer of five. It seems that the code
    isn’t just telling us the number of seats per row. It must be doing something
    related to where students are sitting. Our next step is to improve the prompt
    and determine whether we can get better code from Copilot, but for completeness,
    let’s first explain what the code was really doing in the following listing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在第二行有五个学生。当我们再次运行代码时，测试再次失败，代码给出的答案是五。看起来代码不仅仅是在告诉我们每行的座位数。它一定是在做与学生们坐的位置有关的事情。我们的下一步是改进提示，确定我们是否能从
    Copilot 那里得到更好的代码，但为了完整性，让我们首先在以下列表中解释代码实际上做了什么。
- en: Listing 6.6 Walkthrough of the incorrect code from Copilot
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.6 对 Copilot 错误代码的遍历
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 Starts with the max_students initialized to 0'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从 max_students 初始化为 0 开始'
- en: '#2 For each row in the classroom'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 对于教室中的每一行'
- en: '#3 Initializes the student counter to 0 for this row'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 为这一行初始化学生计数器为 0'
- en: '#4 For each seat in the row'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 对于行中的每个座位'
- en: '#5 If there is a student in the seat, increment the counter.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 如果座位上有学生，增加计数器。'
- en: '#6 If there is an empty seat, reset the counter.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 如果有空座位，重置计数器。'
- en: '#7 Checks to see if the student counter is bigger than seen before and, if
    so, makes that the new maximum seen before'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 检查学生计数器是否比之前看到的更大，如果是，则将其作为新的最大值'
- en: You can see from the code description what is happening per line, but at a high
    level, this code is counting the number of consecutive students in each row. It
    does this by initializing a counter to 0 for each row and then incrementing that
    counter as long as it keeps seeing a student in a seat. It also resets the counter
    as soon as it sees an empty seat. The `if` statement at the end of the inner loop
    is a pretty standard way of keeping track of the largest of something seen before,
    and in this case, it’s keeping track of the largest number of consecutive students
    seen. That’s not at all what we wanted, and our poor prompt is partially to blame.
    The key piece, though, is that our test lets us know the code is incorrect. (If
    you spotted the error yourself in reading the code, that’s great too!)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从代码描述中看到每行的操作，但从高层次来看，这段代码是在计算每行连续学生的数量。它是通过为每行初始化一个计数器为 0 来做到这一点的，只要它看到座位上有学生，就会增加这个计数器。一旦它看到空座位，它就会重置计数器。内循环末尾的
    `if` 语句是跟踪之前看到的东西的最大值的一种相当标准的方式，在这种情况下，它是在跟踪之前看到的连续学生数量的最大值。这根本不是我们想要的，我们糟糕的提示部分要为此负责。然而，关键的部分是，我们的测试让我们知道代码是错误的。（如果你在阅读代码时发现了错误，那也很好！）
- en: 6.5.2 Improving the prompt to find a better solution
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 改进提示以找到更好的解决方案
- en: Let’s rewrite the prompt, keep the test case, and see whether we can do better
    in the following listing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写提示，保留测试用例，看看我们是否能在以下列表中做得更好。
- en: Listing 6.7 Trying again to find the largest number of students
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.7 再次尝试找到最大的学生数
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 The improved prompt says we specifically want the maximum number of '' ''
    characters in any given row.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 改进的提示明确表示我们想要任何给定行中 '' '' 字符的最大数量。'
- en: '#2 count is a list function that returns the number of the argument in the
    list.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 count 是一个列表函数，它返回参数在列表中的数量。'
- en: '#3 Code to keep track of maximum seats'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 代码用于跟踪最大座位数'
- en: To get this solution, we had to look through the possible Copilot solutions
    using Ctrl-Enter. Some of the solutions now counted the consecutive occurrences
    of `'` `'`, whereas others, like the one in listing 6.7, passed the doctest. Oddly,
    the first time we tried the improved prompt, the suggested solution was correct.
    This is another reminder of why nondeterminism in the Copilot output makes testing
    so important.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到这个解决方案，我们必须使用 Ctrl-Enter 遍历可能的 Copilot 解决方案。其中一些解决方案现在计算了 `'` `'` 的连续出现次数，而其他一些，如列表
    6.7 中的，通过了 doctest。奇怪的是，我们第一次尝试改进提示时，建议的解决方案是正确的。这再次提醒我们为什么 Copilot 输出的非确定性使得测试如此重要。
- en: Let’s take a minute and look at what made this second prompt better than the
    first. Both prompts had
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟看看是什么让第二个提示比第一个提示更好。这两个提示都有
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The part of the prompt that led to us receiving the wrong answer was
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 导致我们得到错误答案的提示部分是
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The part of the prompt that yielded a correct answer was
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 得到正确答案的提示部分是
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can never really know why a large language model (LLM) like Copilot produces
    the answer it does, but let’s remember that it’s trained to just make predictions
    of next words based on the words it’s been given and words that were in its training
    data (i.e., lots of code in GitHub).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远无法真正了解像Copilot这样的大型语言模型（LLM）为什么会给出这样的答案，但让我们记住，它是被训练去仅根据它所接收到的单词以及训练数据中的单词（即GitHub上的大量代码）来预测下一个单词。
- en: The first prompt asks Copilot to make some inferences, some of which it does
    well, and some not so well. The prompt, in a sense, is asking Copilot to know
    what a row is in a list of lists. Thankfully, that’s really common in programming,
    so it had no problem there.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个提示要求Copilot进行一些推断，其中一些做得很好，而有些则不太理想。从某种意义上说，提示是在询问Copilot在列表的列表中知道什么是行。幸运的是，这在编程中非常常见，所以在这方面它没有问题。
- en: Then, the prompt asks Copilot to make the basic logical step of inferring that
    an empty seat is where a *new* student could sit. Here is where Copilot struggled.
    We suspect that because we’re asking about new students sitting in a row, it wasn’t
    able to make the jump to realize that “new” students would require figuring out
    how many students you can *add* or, in other words, how many empty seats there
    are. Instead, Copilot focused on the “students °.°.°. in a row” part of the prompt
    and started counting students in each row. It could have also used the function
    name (which, admittedly, could be better; i.e., `max_empty_seats_per_row`) to
    think it needs to count the maximum number of students. That’s not what we want,
    but we can understand how Copilot makes this mistake.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，提示要求Copilot进行基本的逻辑步骤，推断出一个空座位是新生可以坐的地方。这正是Copilot遇到困难的地方。我们怀疑，因为我们询问的是新生坐在一行，它无法跳跃到意识到“新生”需要计算出你可以添加多少学生，换句话说，有多少空座位。相反，Copilot专注于提示中的“学生在一行中”的部分，并开始计算每行的学生人数。它也可以使用函数名（诚然，可以更好；例如，`max_empty_seats_per_row`）来思考它需要计算最大学生数。这并不是我们想要的，但我们能理解Copilot为什么会犯这个错误。
- en: Now let’s talk about why, in response to our vague first prompt, Copilot decided
    to count *consecutive* students in a given row. Maybe counting consecutive students
    is a more common pattern in Copilot’s training data. Maybe it’s because “sit in
    a row” could be interpreted as “sit consecutively.” Or maybe it’s because when
    we were coding this example, we’d been working on another version of the problem
    that asked for consecutive empty seats, and Copilot remembered that conversation.
    We don’t know why Copilot gave us this answer, but we know that our prompt was
    too vague.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈为什么，针对我们模糊的第一个提示，Copilot决定计算给定行中的连续学生人数。也许在Copilot的训练数据中，连续学生人数是一个更常见的模式。也许是因为“坐在一行”可以被解释为“连续地坐”。或者也许是因为当我们编写这个示例时，我们一直在处理另一个要求连续空座位的版本的问题，Copilot记得那次对话。我们不知道为什么Copilot给出了这个答案，但我们知道我们的提示太模糊了。
- en: In contrast, our second prompt was more specific in a few ways. First, it clearly
    asks for the maximum. Second, it asks for the number of spaces, or empty seats,
    in a row. That takes away the need for Copilot to infer that an empty seat means
    a spot for a new student. We also used “total” and “given row” to try to get Copilot
    out of its current approach to counting consecutive values, but that didn’t quite
    do the trick. Consequently, we ended up having to sift through Copilot answers
    (using Ctrl-Enter) that were sometimes looking for consecutive empty seats and
    sometimes finding the count of empty seats.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们的第二个提示在几个方面更为具体。首先，它明确要求最大值。其次，它要求一行中的空位或空座位的数量。这消除了Copilot推断空座位意味着新生座位的需求。我们还使用了“总数”和“给定行”来试图让Copilot摆脱其当前连续值计数的方法，但这并没有完全奏效。因此，我们最终不得不筛选Copilot的答案（使用Ctrl-Enter），这些答案有时在寻找连续空座位，有时又找到了空座位的数量。
- en: 6.5.3 Testing the new solution
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.3 测试新解决方案
- en: 'Returning to our example, because the new code passes the current test, let’s
    give it more tests to ensure that it’s behaving correctly. In the next test, we’ll
    check that the code properly returns 0 when there are no empty seats in any rows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到我们的示例，因为新的代码通过了当前的测试，让我们给它更多的测试以确保它表现正确。在下一个测试中，我们将检查代码在没有任何行有空座位时是否正确返回0：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next test will ensure that the code properly counts all three empty seats
    in a single row (here, the second row) so there isn’t an edge case problem (e.g.,
    it fails to count the first or last element). Admittedly, looking at the code,
    we can see the `count` function is being used, and because that function is built
    in to Python, we should be fairly confident this test will pass. However, it’s
    still safer to test it to make sure:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试将确保代码正确地计算单行（这里指第二行）中的所有三个空座位，以避免出现边缘案例问题（例如，未能计算第一个或最后一个元素）。诚然，查看代码，我们可以看到正在使用`count`函数，并且因为这个函数是Python内置的，所以我们应该相当有信心这个测试会通过。然而，为了确保安全，测试它仍然是更安全的做法：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The last test checks to see that Copilot properly handles the case that two
    rows have the same number of empty seats:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的测试是为了检查Copilot是否正确处理了两行具有相同空座位的案例：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After adding these test cases, we again ran the full program, shown in the following
    listing, and all test cases passed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了这些测试案例之后，我们再次运行了完整的程序，如下所示列表，所有测试案例都通过了。
- en: Listing 6.8 Full code and doctests for largest number of students
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.8 最大学生数量的完整代码和doctests
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, we saw how to write a function to solve a problem from start
    to finish. Copilot gave us the wrong answer, partially because of a difficult-to-interpret
    prompt. We figured out that it gave us the wrong answer because the code failed
    on our first test. We then improved the prompt and used the code reading skills
    we learned in the previous two chapters to pick out a solution that looked correct
    for our needs. The new code passed our initial basic test, so we added more test
    cases to see whether the code worked in more situations. After seeing it pass
    those additional tests, we have more evidence that the code is correct. At this
    point, we’ve tested the common cases and edge cases, so we’re highly confident
    that our current code is correct. Regarding testing, this example showed us how
    tests can help us find mistakes *and* give us more confidence that the code will
    function properly.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到了如何从头到尾编写一个函数来解决一个问题。Copilot给出了错误的答案，部分原因是难以理解的提示。我们意识到它给出错误答案是因为代码在我们的第一次测试中失败了。然后我们改进了提示，并利用在前两章中学到的代码阅读技巧挑选出一个看起来符合我们需求的解决方案。新的代码通过了我们的初始基本测试，因此我们添加了更多的测试案例来查看代码是否在更多情况下都能工作。在看到它通过这些额外的测试后，我们有更多的证据表明代码是正确的。在这个时候，我们已经测试了常见的案例和边缘案例，所以我们非常自信我们的当前代码是正确的。关于测试，这个例子向我们展示了测试如何帮助我们找到错误，并且给我们更多的信心，相信代码将正常工作。
- en: '6.6 Another full testing example: Testing with files'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 另一个完整的测试示例：使用文件进行测试
- en: In most cases, you’ll be able to test your code by adding examples to the docstring
    like we did in the previous example. However, there are times when testing can
    be a bit more challenging. This is true when you need to test your code against
    some kind of external input. An example is when we need to test code that interacts
    with external websites, but this is more common in advanced code than the kind
    of code you’ll be creating within the scope of this book.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你将能够通过向文档字符串添加示例来测试你的代码，就像我们在前面的例子中所做的那样。然而，有时测试可能会更具挑战性。当你需要测试你的代码与某种外部输入进行交互时，这一点是正确的。一个例子是我们需要测试与外部网站交互的代码，但这在高级代码中比本书范围内你将创建的代码更常见。
- en: An example that *is* within the scope of this book is working with files. How
    do you write test cases when your input is a file? Python does support doing this
    in a way internal to the docstring here, but for continuity with what we’ve already
    done, we’re not going to do it that way. Instead, we’ll use external files to
    test our code. Let’s see how to do that by revising our NFL quarterback (QB) example
    from chapter 2.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本书范围内的一个例子是处理文件。当你的输入是一个文件时，你如何编写测试案例？Python支持在文档字符串内部以这种方式进行，但为了与我们已经完成的内容保持一致，我们不会那样做。相反，我们将使用外部文件来测试我们的代码。让我们通过修改第2章中的NFL四分卫（QB）示例来看看如何做到这一点。
- en: We could walk through an example with the entire file, but because our queries
    about quarterbacks were only for the first nine columns of the file, we’re going
    to strip off the remaining columns of the file to make things more readable. After
    stripping off the remaining columns, table 6.2 shows the first four rows of the
    file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以逐行通过一个示例，但由于我们对四分卫的查询仅针对文件的前九列，我们将去掉文件中剩余的列，以便使内容更易于阅读。在去掉剩余的列后，表6.2显示了文件的头四行。
- en: Table 6.2 The first four lines of an abridged version of the NFL dataset
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.2 NFL数据集缩略版的头四行
- en: '| game_id | player_id | position | player | team | pass_cmp | pass_att | pass_yds
    | pass_td |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| game_id | player_id | position | player | team | pass_cmp | pass_att | pass_yds
    | pass_td |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 18  | 30  | 203  |
    1  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 18  | 30  | 203  |
    1  |'
- en: '| 201909050chi  | JoneAa00  | RB  | Aaron Jones  | GNB  | 0  | 0  | 0  | 0  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 201909050chi  | JoneAa00  | RB  | Aaron Jones  | GNB  | 0  | 0  | 0  | 0  |'
- en: '| 201909050chi  | ValdMa00  | WR  | Marquez Valdes-Scantling  | GNB  | 0  |
    0  | 0  | 0  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 201909050chi  | ValdMa00  | WR  | Marquez Valdes-Scantling  | GNB  | 0  |
    0  | 0  | 0  |'
- en: We’ll assume that each row in the dataset has just these nine columns for the
    remainder of the example, but we hope it’s not a big stretch to imagine how to
    do this for the full dataset (you’d just need to add all the additional columns
    in each case).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例的剩余部分，我们将假设数据集的每一行只有这九个列，但我们希望想象如何处理整个数据集不会太困难（你只需在每个情况下添加所有额外的列即可）。
- en: 'Suppose we want to make a function that takes in the filename of the dataset
    and the name of a player as input and then outputs the total number of passing
    yards that player achieved in the dataset. We’ll assume that the user will be
    providing the data as formatted in the NFL offensive stats file in chapter 2 and
    in table 6.2\. Before we write the prompt or function, how should we test this?
    Well, we have some options:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个函数，该函数接受数据集的文件名和玩家名称作为输入，然后输出该玩家在数据集中取得的传球总码数。我们假设用户将提供的数据格式与第2章和表6.2中描述的NFL进攻统计数据文件格式相同。在我们编写提示或函数之前，我们应该如何测试这个？嗯，我们有一些选择：
- en: '*Find tests in the larger dataset—*A solution is to give the full dataset to
    the function and multiple player names as inputs. The challenge is figuring out
    whether we’re correct or not. We could open the file in software such as Google
    Sheets or Microsoft Excel and use spreadsheet features to figure out the answer
    for each player. For example, we could open the file as a sheet in Excel, sort
    by player, find a player, and use the sum function in Excel to add up all the
    passing yards for that player. This isn’t a bad solution at all, but it’s also
    a fair bit of work, and if you put enough time into finding the answer for testing,
    you might have already fulfilled your needs and no longer require the Python code!
    In other words, figuring out the answer for the test cases might just give you
    the answer you wanted in the first place, making the code less valuable. Another
    problem is in finding all the edge cases you might want to test: Will your dataset
    have all the edge cases you’d want to test to write a program that will work on
    other datasets later? Yet another drawback of this approach is determining what
    you do when the function is doing something considerably more complicated than
    just summing a value in a bunch of rows. There, figuring out the answers for some
    real test values might be a great deal of work.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在更大的数据集中查找测试用例—*一个解决方案是将完整的数据集和多个玩家名称作为输入传递给函数。挑战在于确定我们是否正确。我们可以使用像Google
    Sheets或Microsoft Excel这样的软件打开文件，并使用电子表格功能来确定每个玩家的答案。例如，我们可以将文件作为Excel中的一个工作表打开，按玩家排序，找到玩家，并使用Excel中的求和函数来计算该玩家的所有传球码数。这并不是一个坏解决方案，但它也需要相当多的工作，而且如果你花足够的时间来找到测试答案，你可能已经满足了你的需求，不再需要Python代码！换句话说，确定测试用例的答案可能只是给你最初想要的答案，使得代码的价值降低。另一个问题是寻找你可能想要测试的所有边缘情况：你的数据集是否包含你想要测试的所有边缘情况，以便编写可以在以后的数据集上运行的程序？这种方法的另一个缺点是确定当函数执行比在多行中求和值复杂得多的操作时你应该做什么。在那里，确定一些真实测试值的答案可能是一项大量工作。'
- en: '*Create artificial dataset(s) for testing—*Another solution is to create artificial
    datasets where you know the answer to a number of possible queries. Because the
    dataset is artificial, you can add edge cases to see how the code performs in
    those cases without having to find such rare examples in the real dataset. (Sometimes
    the real dataset won’t include those edge cases, but you still want to test them,
    so the code behaves properly if you get an updated or new dataset.)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建用于测试的人工数据集—*另一个解决方案是创建已知多个可能查询答案的人工数据集。因为数据集是人工的，你可以添加边缘情况来查看代码在这些情况下的表现，而无需在真实数据集中找到这样的罕见示例。（有时真实数据集可能不包括这些边缘情况，但你仍然想要测试它们，以便代码在获取更新或新数据集时表现正确。）'
- en: Given the advantages to creating test cases in an artificial dataset, we’re
    going to proceed with that approach here.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到在人工数据集中创建测试用例的优势，我们将继续采用这种方法。
- en: 6.6.1 What tests should we run?
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.1 我们应该运行哪些测试？
- en: 'Let’s think through the common cases and edge cases that we would want to test.
    For common cases, we’d want to have a few tests:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下我们想要测试的常见情况和边缘情况。对于常见情况，我们想要有一些测试：
- en: '*A player appears multiple times in different rows of the dataset (nonconsecutively),
    including the last row.* This test makes sure the code iterates over all the players
    before returning a result (i.e., doesn’t make the false assumption that the data
    is sorted by player name).'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*球员在数据集的不同行中多次出现（非连续的），包括最后一行。* 这个测试确保代码在返回结果之前遍历了所有球员（即不会错误地假设数据是按球员姓名排序的）。'
- en: '*A player appears in consecutive rows of the dataset.* This test makes sure
    there isn’t some kind of error where consecutive values are somehow skipped.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个球员在数据集中的连续行中出现。* 这个测试确保没有某种错误导致连续值被跳过。'
- en: '*A player appears just once in the dataset.* This test makes sure that the
    sum behaves properly even when it’s just summing one value.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个球员在数据集中只出现一次。* 这个测试确保即使只是累加一个值，求和操作也能正确执行。'
- en: '*A non-quarterback could appear in the dataset.* For this, we ensure the code
    is including all players, not just quarterbacks.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个非四分卫球员也可能出现在数据集中。* 为了这一点，我们确保代码包括所有球员，而不仅仅是四分卫。'
- en: '*A player has 0 total passing yards in a game.* This checks to make sure that
    the code behaves properly when players don’t have any passing yards. This is a
    common case to test because players can get hurt and miss a game due to the injury.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个球员在一场比赛中总传球码数为0。* 这检查确保当球员没有传球码数时，代码的行为是正确的。这是一个常见的测试案例，因为球员可能会受伤并因伤错过比赛。'
- en: 'For edge cases, we’d want to test a couple more things:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于边缘情况，我们还想测试一些其他的事情：
- en: '*The player isn’t in the dataset.* This is actually pretty interesting: What
    do we want the code to do in this case? A reasonable answer is to return that
    they passed for 0 yards. If we asked the dataset how many yards Lebron James (a
    basketball player, not a football player) passed for in the NFL from 2019 to 2022,
    0 is the right answer. However, this may not be the most elegant solution for
    production code. For example, if we ask for the passing yards for Aron Rodgers
    (misspelling Aaron Rodgers), we’d rather have the code tell us he’s not in the
    dataset than that he passed for 0 yards, which could really confuse us when he
    won the league MVP twice during this time frame. To signal that the name was missing,
    we might return a large negative value (e.g., –9999), or we might use something
    called exceptions, but they are beyond the scope of this book.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*球员不在数据集中。* 这实际上很有趣：在这种情况下，我们希望代码做什么？一个合理的回答是返回他们传球码数为0。如果我们询问数据集中2019年至2022年勒布朗·詹姆斯（篮球运动员，不是足球运动员）在NFL的传球码数，0是正确的答案。然而，这可能不是生产代码中最优雅的解决方案。例如，如果我们询问阿隆·罗杰斯（拼写错误为Aron
    Rodgers）的传球码数，我们更希望代码告诉我们他不在数据集中，而不是他传球了0码数，这可能会在他在这个时间段内两次获得联盟最有价值球员时真正让我们困惑。为了表示名称缺失，我们可能返回一个很大的负值（例如，-9999），或者我们可能使用称为异常的东西，但这些超出了本书的范围。'
- en: '*A player has a negative total number of yards across all games or a player
    has a single game with negative yards to ensure the code is properly handling
    negative values.* If you don’t follow American football, this can happen if a
    player catches a ball and is tackled behind the starting point (line of scrimmage).
    It’s unlikely a quarterback would have negative passing yards for an entire game,
    but it could happen if they throw one pass for a loss (negative yards) and get
    hurt at the same time, causing them to not play for the rest of the game.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个球员在所有比赛中总码数是负数，或者一个球员在单场比赛中码数是负数，以确保代码正确处理负值。* 如果你不懂美式足球，这种情况可能发生，如果球员接球后被对方球员在起点（进攻线）后方擒抱。四分卫在整个比赛中传球码数是负数的情况不太可能发生，但如果他们传球一次导致码数减少（负码数）并且同时受伤，导致他们无法参加剩余的比赛，这种情况是有可能发生的。'
- en: Now that we have an idea of what we want to test, let’s build an artificial
    file that captures these test cases. We could have split these tests across multiple
    files, which would be a reasonable choice to make as well, but an advantage of
    putting them all in one file is that we can keep all of our test cases together.
    Table 6.3 is what we built and saved as test_file.csv.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了想要测试的内容，让我们构建一个人工文件来捕捉这些测试用例。我们本可以将这些测试分散到多个文件中，这同样是一个合理的做法，但将它们全部放在一个文件中的优势在于我们可以将所有测试用例集中在一起。表6.3是我们构建并保存为test_file.csv的文件。
- en: Table 6.3 Our file to test the NFL passing yards function
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.3 我们用于测试NFL传球码数函数的文件
- en: '| game_id | player_id | position | player | team | pass_cmp | pass_att | pass_yds
    | pass_td |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| game_id | player_id | 位置 | 球员 | 球队 | 传球完成数 | 传球尝试数 | 传球码数 | 传球达阵数 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 20  | 30  | 200  |
    1  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 20  | 30  | 200  |
    1  |'
- en: '| 201909080crd  | JohnKe06  | RB  | Kerryon Johnson  | DET  | 1  | 1  | 5  |
    0  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 201909080crd  | JohnKe06  | RB  | Kerryon Johnson  | DET  | 1  | 1  | 5  |
    0  |'
- en: '| 201909080crd  | PortLe00  | QB  | Leo Porter  | UCSD  | 0  | 1  | 0  | 0  |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 201909080crd  | PortLe00  | QB  | Leo Porter  | UCSD  | 0  | 1  | 0  | 0  |'
- en: '| 201909080car  | GoffJa00  | QB  | Jared Goff  | LAR  | 20  | 25  | 200  |
    1  |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 201909080car  | GoffJa00  | QB  | Jared Goff  | LAR  | 20  | 25  | 200  |
    1  |'
- en: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 10  | 15  | 150  |
    1  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 10  | 15  | 150  |
    1  |'
- en: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 25  | 35  | 300  |
    1  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 25  | 35  | 300  |
    1  |'
- en: '| 201909080car  | GoffJa00  | QB  | Jared Goff  | LAR  | 1  | 1  | –10  | 0  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 201909080car  | GoffJa00  | QB  | Jared Goff  | LAR  | 1  | 1  | –10  | 0  |'
- en: '| 201909080crd  | ZingDa00  | QB  | Dan Zingaro  | UT  | 1  | 1  | –10  | 0  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 201909080crd  | ZingDa00  | QB  | Dan Zingaro  | UT  | 1  | 1  | –10  | 0  |'
- en: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 15  | 25  | 150  |
    0  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 15  | 25  | 150  |
    0  |'
- en: Notice that the data here is entirely artificial. (These aren’t the real statistics
    for any player, as you can tell by the fact that Dan and Leo are now magically
    NFL quarterbacks.) We did keep the names of some real players as well as real
    `game_id`s and `player_id`s from the original dataset. It’s generally a good idea
    to make your artificial data be as close to real data as possible so that the
    tests are genuine and more apt to be representative of what will happen with real
    data.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的数据完全是虚构的。（这些不是任何球员的真实统计数据，正如你可以从丹和利奥现在神奇地成为NFL四分卫这一事实中看出。）我们仍然保留了某些真实球员的名字以及原始数据集中的真实`game_id`和`player_id`。通常，使你的虚构数据尽可能接近真实数据是一个好主意，这样测试才是真实的，并且更有可能代表真实数据可能发生的情况。
- en: Let’s look at how we incorporated all the test cases in this test file (table
    6.3). Aaron Rodgers occurs multiple times in the file, both consecutively and
    nonconsecutively, and as the last entry. Jared Goff appears multiple times, and
    we gave him an artificial –10 yards in a game (as an elite NFL QB, I hope he’s
    okay with us giving him an artificially bad single game). We kept Kerryon Johnson
    as a running back (RB) from the real dataset and gave him 5 passing yards to make
    sure the solution doesn’t filter for only QBs. Kerryon Johnson also only has one
    entry in the data. We added Leo Porter to the dataset and gave him 0 passing yards
    (he’s pretty sure he’d do anything to not get tackled by an NFL player). We also
    added Dan Zingaro and gave him a completed pass, but for –10 yards, covering the
    case that a single player’s total is negative. Table 6.4 shows what it *should*
    return per player when we run the query for each player.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是如何将所有测试用例纳入这个测试文件（表6.3）的。Aaron Rodgers在文件中多次出现，既有连续的也有非连续的，并且作为最后一条记录。Jared
    Goff也多次出现，我们在一场比赛中给他虚构了-10码（作为一个精英NFL四分卫，我希望他能够接受我们给他虚构的糟糕单场比赛）。我们保留了从真实数据集中来的Kerryon
    Johnson作为跑卫（RB），并给他5码传球码数以确保解决方案不会仅过滤四分卫。Kerryon Johnson在数据中只有一条记录。我们还添加了Leo Porter到数据集中，并给他0码传球码数（他肯定愿意做任何事情来避免被NFL球员擒抱）。我们还添加了Dan
    Zingaro，并给他一个完成的传球，但传球码数为-10码，覆盖了单个球员总码数为负的情况。表6.4显示了当我们为每位球员运行查询时，每个球员应该返回的内容。
- en: Table 6.4 Passing yards per player in the test case
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.4 测试用例中每位球员的传球码数
- en: '| Player | Passing yards in the test case |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 球员 | 测试用例中的传球码数 |'
- en: '| --- | --- |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Aaron Rodgers  | 800  |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| Aaron Rodgers  | 800  |'
- en: '| Kerryon Johnson  | 5  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| Kerryon Johnson  | 5  |'
- en: '| Leo Porter  | 0  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| Leo Porter  | 0  |'
- en: '| Jared Goff  | 190  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| Jared Goff  | 190  |'
- en: '| Dan Zingaro  | –10  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| Dan Zingaro  | –10  |'
- en: 6.6.2 Creating the function
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.2 创建函数
- en: Let’s start with the function name and describe the problem in the docstring.
    This problem may be complicated enough that we’ll need to offer prompts within
    the function to help it know to open the file, process the data, and close the
    file, but let’s try to just describe the function first and see how Copilot does.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从函数名开始，并在文档字符串中描述问题。这个问题可能足够复杂，以至于我们需要在函数内提供提示来帮助它知道如何打开文件、处理数据和关闭文件，但让我们先尝试描述函数，看看Copilot的表现如何。
- en: Listing 6.9 Function to find total passing yards per player
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.9 查找每个球员总传球码数的函数
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '#1 We abbreviated the function name.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们缩短了函数名。'
- en: Before looking at the code produced, we want to point out that we didn’t include
    the test cases for this example because they likely wouldn’t help Copilot. We
    recommend having Copilot generate code prior to you adding test cases if your
    test cases will simply open and use artificial files. Each test case will just
    be a filename, a player, and the expected output. Copilot likely can’t read the
    file that corresponds to that filename and figure out that we’re summing the eighth
    column to get the desired result. This means that giving Copilot the test cases
    isn’t going to add to the quality of the prompt. In fact, the artificial nature
    of our data might even confuse it (e.g., in what scenario does a real NFL player
    have a negative total for passing yards?).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看生成的代码之前，我们想指出，我们没有包括这个示例的测试用例，因为它们可能不会对Copilot有所帮助。如果你的测试用例只是打开并使用人工文件，我们建议你在添加测试用例之前让Copilot生成代码。每个测试用例将只是一个文件名、一个球员和预期的输出。Copilot可能无法读取与该文件名对应的文件，并推断出我们正在对第八列求和以获得所需的结果。这意味着给Copilot测试用例并不会提高提示的质量。事实上，我们数据的人工性质甚至可能使其困惑（例如，在什么情况下一个真正的NFL球员会有负的传球码数总额？）。
- en: Now looking at the code that Copilot gave us, we can see that it’s quite reasonable
    and almost identical to the code we saw in chapter 2\. Given that it seems reasonable
    when we read it, let’s see how to test it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看Copilot给出的代码，我们可以看到它相当合理，几乎与我们第2章看到的代码相同。鉴于我们阅读它时看起来合理，让我们看看如何测试它。
- en: 6.6.3 Testing the function
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.3 测试函数
- en: To test the function, we’ll augment the docstring to include our test cases
    for the full piece of code, as shown in the following listing.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个函数，我们将扩展文档字符串以包含整个代码块的所有测试用例，如下所示。
- en: Listing 6.10 Testing the function to find player passing yards
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.10 测试查找球员传球码数的函数
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '#1 The additional test case for a player not in the dataset'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 为数据集中未出现的球员添加额外的测试用例'
- en: We ran this code, and all the test cases passed. (We know that all test cases
    passed because there was no output from doctest.) We now have additional evidence
    that the code is functioning properly!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行了这段代码，所有的测试用例都通过了。（我们知道所有测试用例都通过了，因为doctest没有输出。）我们现在有额外的证据表明代码正在正常工作！
- en: 6.6.4 Common challenges with doctest
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.4 doctest的常见挑战
- en: Let’s rewrite the previous prompt and add a really subtle error to the first
    test, as shown in the following listing.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写之前的提示，并在第一个测试中添加一个非常微妙的错误，如下所示。
- en: Listing 6.11 Mistake in doctest
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.11 doctest中的错误
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '#1 There is an extra space after the 800 that isn’t visible.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 在800后面有一个不可见的额外空格。'
- en: 'When we ran this code, we received this error:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们收到了以下错误：
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: On first glance, this seems really odd. The test case expects 800 and it got
    800, but it’s telling us it failed. Well, it turns out that we made a mistake
    in writing the test case and wrote “800 ” (with a space at the end) rather than
    “800”. This mistake causes Python to think the space is important and causes the
    test to fail. The bad news is that this is a really common problem working with
    doctest! We’ve made this mistake more often than we’d like to admit. The good
    news is it’s really easy to fix by just finding and deleting the space. If a test
    is failing but the output from doctest suggests that it should be passing, always
    check ends of lines for spaces or extra or missing spaces anywhere in your output
    compared to exactly what doctest is expecting.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎非常奇怪。测试用例期望得到800，但它告诉我们失败了。好吧，事实证明我们在编写测试用例时犯了一个错误，写了“800 ”（末尾有一个空格）而不是“800”。这个错误导致Python认为空格很重要，并导致测试失败。坏消息是，这真的是一个在使用doctest时非常常见的问题！我们犯了这个错误比我们愿意承认的要多。好消息是，通过仅仅找到并删除空格就可以很容易地修复它。如果一个测试失败了，但doctest的输出表明它应该通过，那么请检查行尾是否有空格或多余的空格，或者与doctest期望的输出相比，你的输出中是否有任何缺失的空格。
- en: Given that all our test cases passed, we can feel confident returning to the
    larger dataset and using the function we just created. The key thing from this
    example is that we can, and should, create artificial files to test functions
    that work with files. Again, testing is all about gaining confidence that the
    code is working properly, and you want to be sure you test any code you write
    or given to you by Copilot.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有测试用例都通过了，我们可以有信心回到更大的数据集并使用我们刚刚创建的函数。从这个例子中，关键的一点是我们可以，也应该创建人工文件来测试与文件一起工作的函数。再次强调，测试完全是关于获得代码正常工作的信心，你想要确保测试你编写的或由Copilot提供的任何代码。
- en: In this chapter as a whole, we learned about the importance of testing code,
    how to test code, and how to do it in two detailed examples. In our examples,
    we wrote and tested functions. But how do we decide which functions should be
    written to solve even larger problems? Well, we figure that out through a process
    known as problem decomposition that we’ll cover in detail in our next chapter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们整体学习了代码测试的重要性、如何测试代码，以及如何在两个详细示例中实施。在我们的示例中，我们编写并测试了函数。但我们是如何决定编写哪些函数来解决更大的问题的呢？嗯，我们通过一个称为问题分解的过程来解决这个问题，我们将在下一章中详细讨论。
- en: 6.7 Exercises
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 练习
- en: 'Given the following scenarios, identify whether closed-box testing or open-box
    testing would be more appropriate and explain why:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定以下场景，确定是封闭盒测试还是开放盒测试更合适，并解释原因：
- en: A tester is given a function specification and needs to ensure that the function
    behaves correctly without looking at the implementation.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试员被给出一个函数规范，需要确保该函数在没有查看实现的情况下表现正确。
- en: A tester needs to debug a function by writing tests that specifically target
    edge cases revealed by understanding the code implementation.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试员需要通过编写针对由理解代码实现揭示的边缘情况的测试来调试函数。
- en: 'Here is a function with some test cases. Identify which of the following test
    cases are common use cases and which are edge cases:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个带有一些测试用例的函数。确定以下哪些是常见用例，哪些是边缘情况：
- en: '[PRE35]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '3\. We’re building a program to analyze website traffic. Website traffic is
    represented as a list of dictionaries. Each dictionary has two keys: `"weekday"`
    (a string representing the day of the week) and `"visitors"` (an integer representing
    the number of visitors on that day). The same day of the week can appear in multiple
    dictionaries. Our goal is to find the day of the week with the highest number
    of visitors.'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 我们正在构建一个分析网站流量的程序。网站流量以字典列表的形式表示。每个字典有两个键：“weekday”（表示一周中某天的字符串）和“visitors”（表示该天访问者的整数）。同一周中的某天可以出现在多个字典中。我们的目标是找到访问者数量最多的一天。
- en: 'Here’s the initial prompt we gave to an AI code-generation tool:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在AI代码生成工具中给出的初始提示：
- en: 'def busiest_day(traffic_data): # traffic_data is a list of dictionaries. #
    Find the busiest day.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 'def busiest_day(traffic_data): # traffic_data是一个字典列表。# 找到最繁忙的一天。'
- en: The tool generated the following code, but it doesn’t seem quite right.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 工具生成了以下代码，但它似乎并不完全正确。
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Can you explain why and how you would improve the prompt to get the desired
    functionality?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你能解释为什么以及如何改进提示以获得所需的功能吗？
- en: '4\. Imagine you have a function (`find_highest_grossing_book(filename)`) that
    analyzes book sales data and returns information about the book with the highest
    total revenue. Sales data is stored in a CSV file where each line represents a
    sale. The columns in the CSV file are as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 假设你有一个函数（`find_highest_grossing_book(filename)`），该函数分析图书销售数据并返回关于总收入最高的图书的信息。销售数据存储在一个CSV文件中，其中每行代表一次销售。CSV文件中的列如下：
- en: '`title`—The title of the book sold (string)'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`title`—售出图书的标题（字符串）'
- en: '`author`—The author of the book (string)'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`author`—图书的作者（字符串）'
- en: '`price`—The price of the book (float)'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`price`—图书的价格（浮点数）'
- en: '`quantity`—The number of copies sold for that particular sale (integer)'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`quantity`—特定销售中售出的副本数量（整数）'
- en: Create a Python script containing the `find_highest_grossing_book` function
    (implementation not provided here). Include a docstring explaining the function’s
    purpose, and add test cases using the doctest module.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含`find_highest_grossing_book`函数（实现未在此提供）的Python脚本。包括一个文档字符串来解释函数的目的，并使用doctest模块添加测试用例。
- en: 5\. Review the provided test cases for the `is_palindrome` function. Identify
    which test cases are incorrect, and explain why. Provide the correct version of
    the test cases.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5. 审查提供的`is_palindrome`函数的测试用例。确定哪些测试用例是不正确的，并解释原因。提供正确的测试用例版本。
- en: '[PRE37]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 6\. Analyze the test coverage of the `find_max` function. Are there any scenarios
    not covered by the existing test cases? Suggest additional test cases if necessary.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6. 分析 `find_max` 函数的测试覆盖率。是否存在现有测试用例未覆盖的场景？如有必要，建议添加额外的测试用例。
- en: '[PRE38]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Testing is a critical skill when writing software using Copilot.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用 Copilot 编写软件时，测试是一项关键技能。
- en: Closed-box and open-box testing are different approaches to ensuring the code
    is correct. In closed-box testing, we come up with test cases based on what we
    know about the problem; in open-box testing, we additionally examine the code
    itself.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封闭盒测试和开放盒测试是确保代码正确性的不同方法。在封闭盒测试中，我们根据对问题的了解来制定测试用例；在开放盒测试中，我们还会检查代码本身。
- en: Doctest is a module that comes with Python that helps us test our code.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Doctest 是 Python 内置的一个模块，它帮助我们测试代码。
- en: To use doctest, we add test cases to the docstring description of a function.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用 doctest，我们需要将测试用例添加到函数的文档字符串描述中。
- en: Creating artificial files is an effective way to test code that uses files.**
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建人工文件是测试使用文件功能的代码的有效方法。**
