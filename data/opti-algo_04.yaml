- en: 4 Informed search algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 启发式搜索算法
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Defining informed search
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义启发式搜索
- en: Learning how to solve the minimum spanning tree problem
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何解决最小生成树问题
- en: Learning how to find the shortest path using informed search algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用启发式搜索算法找到最短路径
- en: Solving a real-world routing problem using these algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些算法解决实际世界的路由问题
- en: In the previous chapter, we covered blind search algorithms, which are algorithms
    in which no information about the search space is needed. In this chapter, we’ll
    look at how search can be further optimized if we utilize some information about
    the search space during the search.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了盲搜索算法，这些算法在搜索过程中不需要关于搜索空间的信息。在本章中，我们将探讨如果在搜索过程中利用一些关于搜索空间的信息，搜索可以进一步优化。
- en: As problems and search spaces become larger and more complex, the complexity
    of the algorithms themselves increases. I’ll start by introducing informed search
    algorithms, and then we’ll discuss minimum spanning tree algorithms and shortest
    path search algorithms. A routing problem will be presented as a real-life application
    to show how you can use these algorithms.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 随着问题和搜索空间变得更大、更复杂，算法本身的复杂性也会增加。我将首先介绍启发式搜索算法，然后我们将讨论最小生成树算法和最短路径搜索算法。将路由问题作为一个实际应用来展示如何使用这些算法。
- en: 4.1 Introducing informed search
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 介绍启发式搜索
- en: As we discussed in the previous chapter, *blind search algorithms* work with
    no information about the search space, other than the information needed to distinguish
    the goal state from the others. Like the colloquial expression, “I’ll know it
    when I see it,” blind search follows a set framework of rules (e.g., breadth-first,
    depth-first, or Dijkstra’s algorithm) to systematically navigate the search space.
    *Informed search algorithms* differ from blind search algorithms in the sense
    that the algorithm uses knowledge acquired during the search to guide the search
    itself. This knowledge can take the form of distance to target or incurred costs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章中讨论的，*盲搜索算法*在没有关于搜索空间信息的情况下工作，除了区分目标状态和其他状态所需的信息。就像俗语“当我看到它时，我就知道它”一样，盲搜索遵循一套规则框架（例如，广度优先、深度优先或Dijkstra算法）来系统地导航搜索空间。*启发式搜索算法*与盲搜索算法的不同之处在于，算法在搜索过程中使用在搜索过程中获得的知识来指导搜索本身。这种知识可以采取目标距离或产生成本的形式。
- en: For example, in the 8-puzzle problem, we might use the number of misplaced tiles
    as a heuristic to determine how far any given state is from the goal state. In
    this way, we can determine at any given iteration of the algorithm how well it
    is performing and modify the search method based on current conditions. The definition
    of “good performance” depends on the heuristic algorithm being used.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在8个拼图问题中，我们可能会使用错位拼图的数目作为启发式来确定任何给定状态与目标状态的距离。这样，我们可以在算法的任何给定迭代中确定其性能如何，并根据当前条件修改搜索方法。对“良好性能”的定义取决于所使用的启发式算法。
- en: Informed search algorithms can be broadly classified into those that solve for
    minimum spanning tree (MST) problems and those that compute the shortest path
    between two specific nodes or states, as outlined in figure 4.1.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 启发式搜索算法可以广泛分为解决最小生成树（MST）问题的算法和计算两个特定节点或状态之间最短路径的算法，如图4.1所示。
- en: '![](../Images/CH04_F01_Khamis.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F01_Khamis.png)'
- en: Figure 4.1 Examples of informed search algorithms. Each algorithm has multiple
    variants based on improvements, specific use cases, and specialized domains.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 启发式搜索算法的示例。每种算法都有基于改进、特定用例和特定领域的多个变体。
- en: 'Several algorithms have been proposed to solve MST problems:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 已提出几种算法来解决最小生成树（MST）问题：
- en: '*Borůvka’s algorithm* finds an MST in a graph for which all edge weights are
    distinct. It also finds a minimum spanning forest, in the case of a graph that
    is not connected. It starts with each node as its own tree, identifies the cheapest
    edge leaving each tree, and then merges the trees joined by these edges. No edge
    presorting is needed or maintained in a priority queue.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Borůvka算法*在所有边权重都不同的图中找到一个最小生成树。在图不连通的情况下，它还找到一个最小生成森林。它从每个节点作为其自己的树开始，识别离开每个树的最低成本边，然后通过这些边合并连接的树。不需要或维护优先队列中的边预排序。'
- en: '*Jarník-Prim’s algorithm* starts from the root vertex and finds the lowest-weight
    edge from an MST vertex to a non-MST vertex and adds it to MST at each step.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jarník-Prim算法*从根顶点开始，找到从MST顶点到非MST顶点的最低权重边，并在每一步将其添加到MST中。'
- en: '*Kruskal’s algorithm* sorts edges by increasing weight and starts from the
    least-weighted edge to form a small MST component and then grows them into one
    large MST. I will describe this algorithm in more detail in the next section.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*克鲁斯卡尔算法*按权重递增排序边，并从最轻的边开始形成一个小的MST组件，然后将其扩展成一个大的MST。我将在下一节更详细地描述这个算法。'
- en: 'Hill climbing (HC), beam search, the A* algorithm, and contraction hierarchies
    (CH) are examples of informed search algorithms that can be used to find the shortest
    path between two nodes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 爬山法（HC）、束搜索、A*算法和收缩分层（CH）是有信息搜索算法的例子，可以用来找到两个节点之间的最短路径：
- en: '*Hill climbing* is a local search algorithm that continuously moves in the
    direction of optimizing the objective function, increasing in the case of maximization
    problems, or decreasing in the case of minimization problems.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*爬山法* 是一种局部搜索算法，它持续地向优化目标函数的方向移动，在最大化问题中增加，在最小化问题中减少。'
- en: '*Beam search* explores a graph or tree by expanding the most promising node
    within a limited predefined set.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*束搜索* 通过在有限的预定义集合内扩展最有希望的节点来探索图或树。'
- en: '*The A* algorithm* combines both the cost accrued up to a node and heuristic
    information, such as the straight-line distance between this node and the destination
    node, to select new nodes for expansion.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*算法*结合了到达一个节点所累积的成本和启发式信息，例如该节点与目标节点之间的直线距离，以选择新的扩展节点。'
- en: '*Hierarchical approaches*, such as reach-based routing, highway hierarchies
    (HHs), highway-node routing (HNR), transit-node routing (TNR), and contraction
    hierarchy (CH), are hierarchical approaches that take into consideration node
    importance and try to prune the search space by admissible heuristics.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分层方法*，如基于可达性的路由、高速公路分层（HH）、高速公路节点路由（HNR）、交通节点路由（TNR）和收缩分层（CH），是考虑节点重要性的分层方法，试图通过可接受启发式方法剪枝搜索空间。'
- en: The next section introduces the concept of an MST and presents an algorithm
    that can generate an MST for any given graph.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分介绍了最小生成树（MST）的概念，并介绍了一种可以生成任何给定图的最小生成树的算法。
- en: 4.2 Minimum spanning tree algorithms
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 最小生成树算法
- en: Imagine that you are the infrastructure manager for a small, remote rural town.
    Unlike most towns, there isn’t really a main street or downtown area, so most
    points of interest are scattered. Additionally, budget cuts in previous years
    have left the roads either damaged or non-existent. The damaged roads are all
    buried under mud and are essentially impassable. You’ve been given a small budget
    to fix or build roads to improve the situation, but the money isn’t enough to
    repair all the existing roads or to build new ones. Figure 4.2 shows a map of
    the town, as well as the locations of the existing damaged roads.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是偏远农村小镇的基础设施经理。与大多数城镇不同，这里实际上没有主街道或市中心区域，所以大多数兴趣点都分散各处。此外，前几年的预算削减导致道路要么损坏，要么根本不存在。损坏的道路都被泥土掩埋，基本上无法通行。你被分配了一小笔预算来修复或建造道路以改善情况，但这笔钱不足以修复所有现有的道路或建造新的道路。图4.2显示了城镇的地图以及现有损坏道路的位置。
- en: '![](../Images/CH04_F02_Khamis.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2](../Images/CH04_F02_Khamis.png)'
- en: Figure 4.2 The muddy city problem. The roads in this town are badly damaged,
    but there isn’t enough money to repair them all.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 污染城市问题。这个城镇的道路严重损坏，但资金不足以修复所有道路。
- en: There are several ways to approach this problem, ranging from the not feasible
    (repair all the damaged roads and live with the consequences of a bankrupt town)
    to the overly conservative (only fix a few roads, or none at all, and ignore all
    the complaining townspeople). This problem is typically known as the muddy city
    problem, where various nodes in a graph must be connected while minimizing the
    edge weights. These weights can present the cost of fixing or paving the road,
    which may vary depending on the road’s condition, length, and topology.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法有很多，从不可行的（修复所有损坏的道路并忍受城镇破产的后果）到过于保守的（只修复几条道路，或者一条都不修，并忽略所有抱怨的市民）。这个问题通常被称为污染城市问题，其中图中的各种节点必须连接起来，同时最小化边的权重。这些权重可以表示修复或铺路的开销，这可能会根据道路的状况、长度和拓扑结构而变化。
- en: The mathematical way of solving the muddy city problem involves the idea of
    a minimum spanning tree (MST). A spanning tree, in general, is a cycle-free or
    loop-free subgraph of an undirected graph that connects all the vertices of the
    graph with the minimum number of edges. In figure 4.3, the left tree shows a graph
    *G* with nodes from A to F, while the middle and right trees show spanning trees
    of *G*. Notice that generic spanning trees do not require the edges to be weighted
    (i.e., to have a length, speed, time, or cost associated with them).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 解决泥泞城市问题的数学方法涉及到最小生成树（MST）的概念。一般来说，生成树是无向图的一个无环或无环子图，它用最少数量的边连接图的所有顶点。在图4.3中，左边的树显示了从A到F的节点组成的图*G*，而中间和右边的树显示了*G*的生成树。请注意，一般的生成树不需要边的权重（即，不需要与长度、速度、时间或成本相关联）。
- en: '![](../Images/CH04_F03_Khamis.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F03_Khamis.png)'
- en: Figure 4.3 Examples of spanning trees. The middle and right trees reach every
    node of graph *G* with no loops or cycles.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 生成树的示例。中间和右边的树没有回路或环，连接了图*G*的所有节点。
- en: An MST or minimum-weight spanning tree of an edge-weighted graph is a spanning
    tree whose weight (the sum of the weights of its edges) is no larger than the
    weight of any other spanning tree.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最小生成树（MST）或边权重图的最小权重生成树是一棵生成树，其权重（其边的权重之和）不大于任何其他生成树的权重。
- en: 'If *G*=(*V, E*) is a graph, then any subgraph of *G* is a spanning tree if
    both of the following conditions are met:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*G*=(*V, E*)是一个图，那么*G*的任何子图都是一棵生成树，如果满足以下两个条件：
- en: The subgraph contains all vertices *V* of *G*.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子图包含*G*的所有顶点*V*。
- en: The subgraph is connected with no circuits and no self-loops.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子图是连通的，没有回路和自环。
- en: For a given spanning tree *T* for a graph *G*, the weight *w* of the spanning
    tree is the sum of the weights of all the edges in *T*. If the weight of *T* is
    the lowest of the weights of all the possible spanning trees of *G*, then we can
    call this an MST.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个图*G*的给定生成树*T*，生成树*T*的权重*w*是*T*中所有边的权重之和。如果*T*的权重是所有可能的生成树权重中的最低值，那么我们可以称它为最小生成树。
- en: The previously described muddy city problem will be solved as an MST. Kruskal,
    Borůvka, Jarník-Prim, and Chazelle are all examples of algorithms that can be
    used to find an MST. Algorithm 4.1 shows the pseudocode for Kruskal’s algorithm.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的泥泞城市问题将被作为一个最小生成树（MST）来解决。Kruskal、Borůvka、Jarník-Prim和Chazelle都是可以用来找到最小生成树的算法示例。算法4.1展示了Kruskal算法的伪代码。
- en: Algorithm 4.1 Kruskal’s algorithm
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 算法4.1 Kruskal算法
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To better understand these steps, let’s apply Kruskal’s algorithm to solve the
    muddy city problem. Figure 4.4 shows the original graph. The numbers near the
    edges represent edge weights, and no edges have been added to the MST yet. The
    following steps will generate the MST by hand iteration.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些步骤，让我们应用Kruskal算法来解决泥泞城市问题。图4.4显示了原始图。边附近的数字代表边权重，还没有添加任何边到最小生成树中。以下步骤将通过手动迭代生成最小生成树。
- en: '![](../Images/CH04_F04_Khamis.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F04_Khamis.png)'
- en: Figure 4.4 Solving the muddy city problem using Kruskal’s algorithm—original
    graph
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 使用Kruskal算法解决泥泞城市问题——原始图
- en: 1\.  The shortest edge is E-H with a length of 1, so it is highlighted and added
    to the MST (figure 4.5).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  最短的边是E-H，长度为1，因此它被突出显示并添加到最小生成树中（图4.5）。
- en: '![](../Images/CH04_F05_Khamis.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F05_Khamis.png)'
- en: Figure 4.5 Solving the muddy city problem using Kruskal’s algorithm—step 1
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 使用Kruskal算法解决泥泞城市问题——第1步
- en: 2\.  B-C, C-G, G-F, and I-J are now the shortest edges with lengths of 2\. B-C
    is chosen arbitrarily and is highlighted, followed by C-G, G-F, and I-J, as they
    don’t form a cycle (figure 4.6).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  B-C、C-G、G-F和I-J现在是长度为2的最短边。B-C被任意选择并突出显示，然后是C-G、G-F和I-J，因为它们没有形成环（图4.6）。
- en: '![](../Images/CH04_F06_Khamis.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F06_Khamis.png)'
- en: Figure 4.6 Solving the muddy city problem using Kruskal’s algorithm—step 2
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 使用Kruskal算法解决泥泞城市问题——第2步
- en: 3\.  C-F, F-J, G-I, A-D, and D-E are now the shortest edges with lengths of
    3\. C-F cannot be chosen, as it forms a cycle. A-D is chosen arbitrarily and is
    highlighted, followed by D-E and G-I. F-J cannot be chosen, as it forms a cycle
    (figure 4.7).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  C-F、F-J、G-I、A-D和D-E现在是长度为3的最短边。C-F不能被选择，因为它形成了一个环。A-D被任意选择并突出显示，然后是D-E和G-I。F-J不能被选择，因为它形成了一个环（图4.7）。
- en: '![](../Images/CH04_F07_Khamis.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F07_Khamis.png)'
- en: Figure 4.7 Solving the muddy city problem using Kruskal’s algorithm—step 3
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 使用Kruskal算法解决泥泞城市问题——第3步
- en: 4\.  The next-shortest edges are A-E and G-H with lengths 4\. A-E cannot be
    chosen because it forms a cycle, so the process finishes with the edge G-H. The
    minimum spanning tree has been found (figure 4.8).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 下一个最短边是A-E和G-H，长度为4。由于A-E会形成一个环，所以不能选择它，因此过程以边G-H结束。最小生成树已经找到（图4.8）。
- en: '![](../Images/CH04_F08_Khamis.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8](../Images/CH04_F08_Khamis.png)'
- en: Figure 4.8 Solving the muddy city problem using Kruskal’s algorithm—step 4
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 使用Kruskal算法解决泥泞城市问题——步骤4
- en: Figure 4.9 shows the final solution with all nodes in the graph connected.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9显示了所有节点在图中都连接的最终解决方案。
- en: '![](../Images/CH04_F09_Khamis.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9](../Images/CH04_F09_Khamis.png)'
- en: Figure 4.9 Solving the muddy city problem using Kruskal’s algorithm. The algorithm
    adds edges to the final tree by ascending weight order, ignoring edges that will
    form a cycle.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 使用Kruskal算法解决泥泞城市问题。算法通过按升序权重顺序添加边到最终树中，忽略会形成环的边。
- en: This algorithm can be implemented easily in Python by using NetworkX’s `find_cycle()`
    and `is_connected()` methods, which determine if an edge is a viable candidate
    for the MST, as well as the overall algorithm’s termination condition, respectively.
    For the purposes of visual presentation, I’ve also used `spring_layout()` for
    the positions of the nodes and edges of the graph. The `spring_layout()` method
    uses a random number generator internally to generate these positions, and we
    can pass a seed (which allows a deterministic generation of so-called “pseudo-random”
    numbers) to guarantee a specific layout on each execution. Try modifying the seed
    parameter, and see what happens.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法可以通过使用NetworkX的`find_cycle()`和`is_connected()`方法轻松地在Python中实现，这些方法分别确定边是否是MST的可行候选，以及整体算法的终止条件。为了视觉展示，我还使用了`spring_layout()`来设置图的节点和边的位置。`spring_layout()`方法内部使用随机数生成器来生成这些位置，我们可以传递一个种子（允许生成所谓的“伪随机”数）来保证每次执行都得到特定的布局。尝试修改种子参数，看看会发生什么。
- en: Listing 4.1 Solving the muddy city problem using Kruskal’s algorithm
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 使用Kruskal算法解决泥泞城市问题
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Create an undirected graph and populate it with nodes and edges.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个无向图，并用节点和边填充它。
- en: ② Using a seed with the spring_layout method guarantees the same placement of
    nodes every time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用种子与spring_layout方法保证每次放置节点相同。
- en: ③ Sort edges by weight in ascending order.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 按照权重升序排序边。
- en: ④ find_cycle raises an error if no cycles exist in the graph. We can try/catch
    this error to determine if adding a new edge creates a cycle.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果图中不存在环，`find_cycle`会引发错误。我们可以尝试/捕获这个错误，以确定添加新边是否会形成一个环。
- en: ⑤ The set of edges in mst is a spanning tree if the graph formed by those edges
    is connected.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 如果由这些边形成的图是连通的，那么mst中的边集就是一个生成树。
- en: 'As a continuation of listing 4.1, the following code snippet is used to generate
    an MST using Kruskal and to visualize the MST:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 作为列表4.1的延续，以下代码片段用于生成使用Kruskal的最小生成树并可视化它：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Call Kruskal’s algorithm to generate the MST.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ① 调用Kruskal算法生成最小生成树。
- en: ② Draw the edges.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ② 绘制边。
- en: ③ Add the labels.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 添加标签。
- en: ④ Draw the MST.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 绘制最小生成树。
- en: As you can see in figure 4.10, our Python implementation of the muddy city problem
    produces the exact same results that we achieved using hand iteration. Node G,
    which is the town hall, becomes a sort of central hub for the town’s transportation
    infrastructure, and the total cost of road construction is minimized. It’s worth
    noting, however, that while MST minimizes the total cost of connecting all nodes,
    it doesn’t usually produce the most “convenient” solution. Should someone wish
    to travel from the place of worship to the hospital, for example, the shortest
    achievable distance would be 7 (passing through the police station), while our
    road network requires a total distance of 15.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图4.10中看到的，我们用Python实现的泥泞城市问题产生了与手动迭代相同的结果。节点G，即市政厅，成为城镇交通基础设施的一个中心枢纽，道路建设的总成本被最小化。然而，值得注意的是，尽管最小生成树（MST）最小化了连接所有节点的总成本，但它通常不会产生最“方便”的解决方案。例如，如果有人想从宗教场所前往医院，最短可达距离将是7（经过警察局），而我们的道路网络需要总距离为15。
- en: '![](../Images/CH04_F10_Khamis.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10](../Images/CH04_F10_Khamis.png)'
- en: Figure 4.10 The muddy city problem solved using Kruskal’s algorithm. The highlighted
    edges are part of the MST.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 使用Kruskal算法解决的泥泞城市问题。高亮显示的边是MST的一部分。
- en: Let’s apply this algorithm and this code to find the MST for all nodes in a
    search space surrounding the University of Toronto. Imagine that we have been
    tasked with installing new communications cables across the city, and we want
    to minimize the length of cable we use.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此算法和此代码应用于找到多伦多大学周围搜索空间内所有节点的 MST。想象一下，我们被分配在城市中安装新的通信电缆的任务，我们希望最小化使用的电缆长度。
- en: Listing 4.2 University of Toronto MST
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 多伦多大学 MST
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Use the drive network to only focus on drivable roads. This prevents the code
    from building an MST with a combination of roads and sidewalks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用驾驶网络仅关注可驾驶的道路。这可以防止代码使用道路和人行道组合构建 MST。
- en: ② Get an undirected copy of the graph, and sort the road network edges by edge
    length.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ② 获取无向图副本，并按边长对道路网络边进行排序。
- en: ③ Call the Kruskal algorithm from optalgotools, using a presorted list and specifying
    the graph type.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用预排序列表并指定图类型，从 optalgotools 调用 Kruskal 算法。
- en: ④ Visualize the MST by highlighting the included edges.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 通过突出显示包含的边来可视化最小生成树（MST）。
- en: Figure 4.11 shows the resulting MST generated by Kruskal’s algorithm. The road
    network graph in the figure may seem like one big connected component, but it
    isn’t. There are one-way streets that seem to connect adjacent nodes on the graph,
    but in reality, they are not connected (you can go from A to B but not the reverse).
    We overcome this by converting the directed graph into an undirected graph using
    the `to_undirected` function in NetworkX.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 显示了 Kruskal 算法生成的结果 MST。图中的道路网络图可能看起来像一个大连通分量，但实际上并非如此。图中似乎连接相邻节点的单行道实际上并没有连接（你可以从
    A 到 B，但不能反过来）。我们通过使用 NetworkX 中的 `to_undirected` 函数将有向图转换为无向图来克服这个问题。
- en: The version of Kruskal’s algorithm used in the listing is the same as was used
    for the muddy city problem. We’re importing it from optalgotools to reduce the
    amount of code needed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中使用的 Kruskal 算法版本与泥泞城市问题中使用的相同。我们将其从 optalgotools 导入以减少所需的代码量。
- en: '![](../Images/CH04_F11_Khamis.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F11_Khamis.png)'
- en: Figure 4.11 The MST generated by Kruskal’s algorithm. All the edges included
    in the MST are highlighted. There are no cycles in the MST, and the total weight
    of the tree is minimized.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 Kruskal 算法生成的 MST。所有包含在 MST 中的边都被突出显示。MST 中没有环，且树的总权重最小化。
- en: MSTs have a wide variety of applications in the real world, including network
    design, image segmentation, clustering, and facility location problems. MSTs are
    especially useful when dealing with problems concerning budgeting, such as planning
    networks, as they allow all nodes to be connected with a minimum total cost. As
    previously mentioned, informed search algorithms can be used to find MSTs as described
    in this section and with shortest path algorithms, which are discussed in the
    next section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: MST 在现实世界中有着广泛的应用，包括网络设计、图像分割、聚类和设施定位问题。当处理涉及预算的问题时，如规划网络，MST 特别有用，因为它们允许所有节点以最低的总成本连接。如前所述，信息搜索算法可以用来找到本节所述的
    MST，以及下一节讨论的最短路径算法。
- en: 4.3 Shortest path algorithms
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 最短路径算法
- en: Informed search algorithms can be used to find the shortest path between two
    nodes by using knowledge about the problem (domain-specific knowledge) to prune
    the search. This knowledge, in the form of a heuristic function, gives an estimate
    of the distance to the goal. Examples of informed search algorithms include hill
    climbing, beam search, best-first, A*, and contraction hierarchies. The following
    subsections discuss these algorithms in detail.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 信息搜索算法可以通过使用关于问题的知识（领域特定知识）来剪枝搜索，以找到两个节点之间的最短路径。这种知识以启发式函数的形式给出对目标距离的估计。信息搜索算法的例子包括岗位攀登、束搜索、最佳优先、A*
    和收缩层次。以下小节将详细讨论这些算法。
- en: 4.3.1 Hill climbing algorithm
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 岗位攀登算法
- en: Assume that you are trying to climb to the top of a mountain in a dense fog.
    There is only one path up and down the mountain, but you aren’t sure exactly where
    the peak is. Thus, you are only able to judge your progress by looking one step
    behind you and seeing if you’ve gone uphill or downhill since your last step.
    How can you know when you’ve reached the summit? A good guess would be when you’re
    no longer going uphill!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在试图在浓雾中攀登山顶。上山和下山的路径只有一条，但你不确定确切的山顶位置。因此，你只能通过查看你上一步之后的进展来判断你是否已经上山或下山。你如何知道你已经到达山顶？一个不错的猜测是当你不再上山时！
- en: Starting with a known (non-optimized) solution to a function or with an initial
    state, the hill climbing algorithm checks the neighbors of that solution and chooses
    the neighbor that is more optimized. This process is repeated until no better
    solution can be found, at which point the algorithm terminates.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个已知（非优化）的函数解或初始状态开始，岗位攀登算法检查该解决方案的邻居，并选择更优化的邻居。这个过程会重复进行，直到找不到更好的解决方案，此时算法终止。
- en: The hill climbing algorithm is a local greedy search algorithm that tries to
    improve the efficiency of depth-first by incorporating domain-specific knowledge
    or heuristic information, so it can be considered as an informed depth-first algorithm.
    The hill climbing algorithm’s pseudocode applied to graph search is shown in the
    algorithm 4.2 assuming minimization problem.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 岗位攀登算法是一种局部贪婪搜索算法，它试图通过结合领域特定知识或启发式信息来提高深度优先搜索的效率，因此它可以被认为是一种有信息的深度优先搜索算法。算法4.2中应用于图搜索的岗位攀登算法的伪代码假设为最小化问题。
- en: Algorithm 4.2 The hill climbing algorithm
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 算法4.2 岗位攀登算法
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The algorithm sorts the successors of a node (according to their heuristic values)
    before adding them to the list to be expanded. This algorithm demands very little
    in the way of memory and computational overhead, as it simply remembers the current
    successors as the current path it is working on. It’s a non-exhaustive technique;
    it does not examine the entire tree, so its performance will be reasonably fast.
    However, while this algorithm works relatively well with convex problems, functions
    with multiple local maxima will often result in an answer that is not the global
    maximum. It also performs poorly when there are plateaus (a local set of solutions
    that are all similarly optimized).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法在将节点后继者（根据它们的启发式值）添加到待扩展列表之前，对它们进行排序。这种算法在内存和计算开销方面要求非常低，因为它只是简单地记住当前的后继者作为当前正在工作的路径。它是一种非穷举技术；它不会检查整个树，因此其性能将相对较快。然而，尽管这种算法在凸问题上相对表现良好，但具有多个局部最大值的函数通常会得到一个不是全局最大值的答案。当存在高原（一组所有解决方案都同样优化的局部解决方案）时，它的表现也较差。
- en: As shown in figure 4.12, depending on the initial state, the hill climbing algorithm
    may get stuck in local optima. Once it reaches the top of a hill, the algorithm
    will stop, since any new successor will be down the hill. This is analogous to
    climbing the mountain in the fog, reaching a smaller peak, and thinking that you’ve
    reached the main summit.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如图4.12所示，根据初始状态，岗位攀登算法可能会陷入局部最优。一旦它达到山顶，算法将停止，因为任何新的后继者都会在山脚下。这类似于在雾中爬山，达到一个较小的顶峰，并认为你已经到达了主峰。
- en: '![](../Images/CH04_F12_Khamis.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F12_Khamis.png)'
- en: Figure 4.12 Depending on the initial state, the hill climbing algorithm may
    get stuck in local optima. Once it reaches a peak, the algorithm will stop, since
    any new successor will be down the hill.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 根据初始状态，岗位攀登算法可能会陷入局部最优。一旦它达到一个顶峰，算法将停止，因为任何新的后继者都会在山脚下。
- en: Simple hill climbing, steepest-ascent hill climbing, stochastic hill climbing,
    and random-restart hill climbing are all variants of the hill climbing algorithm,
    as shown in figure 4.13.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的岗位攀登、最陡上升岗位攀登、随机岗位攀登和随机重启岗位攀登都是岗位攀登算法的变体，如图4.13所示。
- en: '![](../Images/CH04_F13_Khamis.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F13_Khamis.png)'
- en: Figure 4.13 Variants of the hill climbing algorithm
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 岗位攀登算法的变体
- en: '*Simple hill climbing* examines the neighboring nodes one by one and selects
    the first neighboring node that optimizes the objective function as the next node
    to be explored. *Steepest-ascent or steepest-descent hill climbing* is a variation
    on the simple hill-climbing algorithm that first examines all the neighboring
    nodes of the current state and selects one neighbor node that is closest to the
    goal state. *Stochastic hill climbing* is a randomized version of a hill climbing
    algorithm that selects a neighboring node at random without examining all the
    neighboring nodes. This algorithm decides whether to move to that neighbor or
    to examine another based on the amount of improvement in that neighbor. Random-restart
    hill climbing or first-choice hill climbing follows a try-and-try strategy and
    iteratively searches the nodes and selects the best one at each step until the
    goal is found. If it gets stuck in a local maximum, it restarts the process from
    a new random initial state. Compared to the other hill climbing variants, this
    algorithm is better able to reach the destination if there are plateaus, local
    optima, and ridges.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单爬山法*逐个检查邻近节点，并选择第一个优化目标函数的邻近节点作为下一个要探索的节点。*最陡上升或最陡下降爬山法*是简单爬山算法的一种变体，它首先检查当前状态的所有邻近节点，并选择一个最接近目标状态的邻近节点。*随机爬山法*是爬山算法的一个随机版本，它随机选择一个邻近节点，而不检查所有邻近节点。此算法根据该邻近节点的改进量决定是否移动到该邻近节点或检查另一个节点。随机重启爬山法或首次选择爬山法遵循尝试策略，并迭代搜索节点，在每一步中选择最佳节点，直到找到目标。如果陷入局部最大值，它将从新的随机初始状态重新开始过程。与其他爬山变体相比，如果存在高原、局部最优和脊，此算法更有可能到达目的地。'
- en: Gradient descent algorithm
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度下降算法
- en: The *gradient descent algorithm* is widely used in machine learning to train
    models and make predictions. Gradient descent and hill climbing are two fundamentally
    different algorithms and cannot be confused with each other. Instead of climbing
    up a hill, gradient descent can be seen as hiking down to the bottom of a valley.
    Gradient descent is an iterative algorithm that looks at the slope of the local
    neighbors and moves in the direction with the steepest slope or the direction
    of negative gradient to optimize a continuous differentiable function. Alternatively,
    in the case of a maximization problem, *gradient ascent* moves in the direction
    with a positive gradient to optimize the objective function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*梯度下降算法*在机器学习中被广泛用于训练模型和进行预测。梯度下降和爬山算法是两种基本不同的算法，不能相互混淆。与爬山不同，梯度下降可以看作是向山谷底部徒步。梯度下降是一种迭代算法，它观察局部邻居的斜率，并朝着斜率最陡或负梯度方向移动以优化连续可微函数。在最大化问题的情形下，*梯度上升*则朝着正梯度方向移动以优化目标函数。'
- en: The gradient descent algorithm usually converges to a global minimum if the
    function is convex (i.e., if any local minimum is also a global minimum) and the
    learning rate is properly chosen. The hill climbing algorithm is a heuristic greedy
    algorithm that can easily get stuck in local optima. It is used mainly for discrete
    optimization problems, such as the traveling salesman, as it doesn’t require the
    objective function to be differentiable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数是凸函数（即，如果任何局部最小值也是全局最小值）并且学习率选择得当，梯度下降算法通常收敛到全局最小值。爬山算法是一种启发式贪婪算法，容易陷入局部最优。它主要用于离散优化问题，如旅行商问题，因为它不需要目标函数是可微的。
- en: Assume we have the simple graph shown in figure 4.14\. The source node is S
    and the destination node is G.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个如图4.14所示的简单图。源节点是S，目标节点是G。
- en: '![](../Images/CH04_F14_Khamis.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F14_Khamis.png)'
- en: Figure 4.14 An 8 points of interest (POIs) road network in the form of a graph
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 以图的形式表示的8个兴趣点（POIs）道路网络
- en: This graph can be converted into a tree by finding a spanning tree that includes
    all the vertices of the original graph and that is connected and acyclic, as shown
    in figure 4.15.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此图可以通过找到一个包含原始图所有顶点且连通且无环的生成树来转换为树，如图4.15所示。
- en: '![](../Images/CH04_F15_Khamis.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F15_Khamis.png)'
- en: Figure 4.15 An 8 points of interest (POIs) road network in the form of a tree
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 以树的形式表示的8个兴趣点（POIs）道路网络
- en: As you can see, there are multiple ways to go from S to G, each with different
    costs. Following the hill climbing algorithm, the shortest path between S and
    G will be S→A→C→E→G, as illustrated in figure 4.16.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，从 S 到 G 有多种路径，每种路径的成本不同。遵循爬山算法，S 和 G 之间的最短路径将是 S→A→C→E→G，如图 4.16 所示。
- en: '![](../Images/CH04_F16_Khamis.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F16_Khamis.png)'
- en: Figure 4.16 Shortest path between S and G using the hill climbing algorithm
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 使用爬山算法在 S 和 G 之间找到的最短路径
- en: Let’s now use the 8-puzzle problem to illustrate the hill climbing approach.
    Figure 4.17 shows how the hill climbing search progresses, using the number of
    misplaced tiles, excluding the blank tile, as heuristic information *h*(*n*).
    For example, in step 2, tiles 1, 4, 6, and 7 are wrongly placed, so *h* = 4\.
    In step 3, tiles 1, and 4 are misplaced, so *h* = 2.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 8 个拼图问题来说明爬山方法。图 4.17 展示了爬山搜索的进展，使用不包括空白瓷砖的错位瓷砖数量作为启发式信息 h(n)。例如，在第 2
    步中，瓷砖 1、4、6 和 7 放置错误，所以 h = 4。在第 3 步中，瓷砖 1 和 4 放置错误，所以 h = 2。
- en: '![](../Images/CH04_F17_Khamis.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F17_Khamis.png)'
- en: Figure 4.17 Using the hill climbing algorithm to solve the 8-puzzle problem.
    At each iteration, the algorithm explores neighboring states, looking for the
    minimum heuristic value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 使用爬山算法解决 8 个拼图问题。在每次迭代中，算法探索相邻状态，寻找最小启发式值。
- en: Listing 4.3 shows a simple implementation of hill climbing in Python. The code
    selects nodes to explore by minimizing the heuristic value of the next node. A
    more complex version, involving generating shortest paths, will be presented at
    the end of this chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 展示了 Python 中爬山算法的简单实现。代码通过最小化下一个节点的启发式值来选择探索的节点。更复杂的版本，涉及生成最短路径，将在本章末尾介绍。
- en: Listing 4.3 Solving the 8-puzzle problem using hill climbing
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 使用爬山法解决 8 个拼图问题
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① The neighbor nodes of the current state can be generated using expand().
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ① 可以使用 expand() 函数生成当前状态的邻居节点。
- en: ② The “closest” neighbor is the one with the lowest cost function (i.e., the
    fewest misplaced tiles).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ② “最近”的邻居是成本函数最低的（即错位瓷砖最少）。
- en: ③ Terminate the algorithm if the goal state has been reached.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果达到目标状态，则终止算法。
- en: ④ Calculate and return the number of misplaced tiles that are not in their goal
    positions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 计算并返回不在目标位置上的错位瓷砖数量。
- en: Note The State class and visualize function are defined in the complete listing,
    available in the book’s GitHub repo.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：State 类和 visualize 函数在完整的列表中定义，可在本书的 GitHub 仓库中找到。
- en: 'The following code snippet defines the initial and goal states of the puzzle
    and uses hill climbing to solve the puzzle:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段定义了拼图的初始状态和目标状态，并使用爬山法来解决拼图问题：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Check if there is even a solution.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ① 检查是否有解决方案。
- en: ② Solve the puzzle using hill climbing
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用爬山法解决拼图问题
- en: ③ Plot the search progress, and visualize the solution.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 绘制搜索进度，并可视化解决方案。
- en: The output is shown in figure 4.18.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示在图 4.18 中。
- en: '![](../Images/CH04_F18_Khamis.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F18_Khamis.png)'
- en: Figure 4.18 States of the hill climbing solution for the 8-puzzle problem. Each
    subsequent state is selected by minimizing its cost compared to its neighbors.
    As the 8-puzzle problem has not only a well-defined but also an achievable goal
    state, the algorithm’s termination condition (the goal being reached) coincides
    with the “peak” of the hill (which in this case is a valley, as it is a minimization
    problem).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 显示了 8 个拼图问题爬山解决方案的状态。每个后续状态都是通过将其成本与邻居相比最小化来选择的。由于 8 个拼图问题不仅有一个明确定义的目标状态，而且这个目标状态是可以实现的，算法的终止条件（达到目标）与“山峰”的“顶峰”相吻合（在这种情况下是一个山谷，因为它是一个最小化问题）。
- en: As the 8-puzzle problem uses a heuristic as a cost, it essentially becomes a
    minimization problem. This implementation differs from the standard hill climbing
    in that, as a solution can always be found, and the graph is fully connected (you
    can transition from any state to another state through some combination of tile
    movements), the algorithm is guaranteed to find the optimal solution eventually.
    More complex problems will often generate solutions that are near-optimal.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 8 个拼图问题使用启发式作为成本，它本质上变成了一个最小化问题。这种实现与标准爬山算法的不同之处在于，由于总可以找到解决方案，并且图是完全连接的（您可以通过一些瓷砖移动的组合从任何状态转换到另一个状态），算法最终保证找到最优解。更复杂的问题通常会生成接近最优的解决方案。
- en: 4.3.2 Beam search algorithm
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 光束搜索算法
- en: The *beam search algorithm* tries to minimize the memory requirements of the
    breadth-first algorithm, so it can be seen as an informed breadth-first algorithm.
    While hill climbing maintains a single best state throughout the run, beam search
    keeps *w* states in memory, where *w* is the beam width. At each iteration, it
    generates the neighbors for each of the states and puts them into a pool with
    the states from the original beam. It then selects the best *w* states from the
    pool at each level to become the new beam, and the rest of the states are discarded.
    This process then repeats. The algorithm expands only the first *w* promising
    nodes at each level.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 束搜索算法试图最小化广度优先算法的内存需求，因此它可以被视为一种启发式广度优先算法。在爬山法在整个运行过程中保持一个最佳状态的同时，束搜索在内存中保持*W*个状态，其中*W*是束宽度。在每次迭代中，它为每个状态生成邻居并将它们放入与原始束中的状态相同的池中。然后，它在每个级别上从池中选择最佳的*W*个状态成为新的束，其余状态被丢弃。这个过程然后重复。该算法在每个级别上仅扩展前*W*个有希望的节点。
- en: This is a non-exhaustive search, but it is also a hazardous process, because
    a goal state might be missed. As this is a local search algorithm, it is also
    susceptible to getting stuck at a local optima. A beam search with *w* equal to
    the number of nodes in each level is the same as a BFS. Because there is the risk
    that a state that could lead to the optimal solution might be discarded, beam
    searches are incomplete (they may not terminate with the solution).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非穷尽搜索，但也是一个危险的过程，因为可能会错过目标状态。由于这是一个局部搜索算法，它也容易陷入局部最优。当*w*等于每个级别的节点数时，束搜索与BFS相同。因为存在可能丢弃导致最优解的状态的风险，所以束搜索是不完整的（它们可能不会以解结束）。
- en: Algorithm 4.3 shows the pseudocode for the beam search algorithm applied to
    a graph search.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 算法4.3展示了将束搜索算法应用于图搜索的伪代码。
- en: Algorithm 4.3 The beam search algorithm
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 算法4.3 束搜索算法
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In section 2.3.1, you saw that BFS has an exponential complexity of *O*(*b^d*),
    where *b* represents the maximum branching factor for each node and *d* is the
    depth one must expand to reach the goal. In the case of beam search, we only explore
    *w* × *b* nodes at any depth, saving many unneeded nodes compared to BFS. However,
    finding the best states or routes requires sorting, which is time-consuming if
    *w* × *b* is a huge number. A beam threshold can be used to handle this problem,
    where the best node is selected based on the heuristic function *h*(*n*) within
    a certain threshold, and all the nodes outside this are pruned away.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.3.1节中，您看到BFS具有指数复杂度*O*(*b^d*)，其中*b*代表每个节点的最大分支因子，*d*是必须扩展以达到目标深度的深度。在束搜索的情况下，我们只在任何深度探索*w*×*b*个节点，与BFS相比，节省了许多不必要的节点。然而，找到最佳状态或路线需要排序，如果*w*×*b*是一个很大的数字，那么排序将是耗时的。可以使用束阈值来处理这个问题，其中根据启发式函数*h*(*n*)在某个阈值内选择最佳节点，并将所有超出此阈值的节点剪枝掉。
- en: Revisiting the simple routing problem with 8 points of interest (figure 4.14)
    and following the beam search algorithm with *w* = *2*, the shortest path between
    S and G will be S-A-C-E-G, as illustrated in figure 4.19.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视具有8个兴趣点的简单路由问题（图4.14）并遵循束搜索算法（*w* = *2*），S和G之间的最短路径将是S-A-C-E-G，如图4.19所示。
- en: '![](../Images/CH04_F19_Khamis.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F19_Khamis.png)'
- en: Figure 4.19 The shortest path between S and G using a beam search algorithm.
    With a beam width *w* = 2, two states are kept in the beam at each iteration.
    After generating the neighbors of each element in the beam, only the best *w*
    beams are kept.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 使用束搜索算法在S和G之间找到的最短路径。束宽度*w* = 2时，在每个迭代中保持束中的两个状态。在生成束中每个元素的邻居后，仅保留最佳的*w*束。
- en: The following listing shows a basic implementation of beam search used for a
    simple routing problem. See the full code in the GitHub repo to see how the graph
    is initialized, as well as how the visualization is generated (it is quite similar
    to that of listing 4.1).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了用于简单路由问题的基本束搜索实现。要查看如何初始化图以及如何生成可视化（它与列表4.1中的类似），请参阅GitHub仓库中的完整代码。
- en: Listing 4.4 Simple routing with beam search
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 使用束搜索的简单路由
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Create a directed graph.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ①创建一个有向图。
- en: ② Get the neighbors of the node using the origin class’s expand() method, passing
    any necessary arguments.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ②使用原始类的expand()方法获取节点的邻居，传递任何必要的参数。
- en: ③ Prune the pool down to only the best k paths, passing any necessary arguments
    to the cost function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ③将池修剪到仅包含最佳k路径，传递任何必要的参数到成本函数。
- en: ④ Child routes are generated for each route by adding one extra node to the
    route. For each of these new routes, they are rejected (already explored), added
    to the beam (and then to the pool), or accepted (because they reach the destination).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 为每条路径生成子路径，通过在路径中添加一个额外的节点来实现。对于这些新路径中的每一个，它们会被拒绝（已探索）、添加到束中（然后到池中）或接受（因为它们到达了目的地）。
- en: ⑤ None is returned if a path cannot be found.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 如果找不到路径，则不返回任何内容。
- en: 'This function can be called with the following example parameters:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以使用以下示例参数调用：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Visualizing the output of this algorithm produces the graph in figure 4.20,
    where the highlighted line represents the solution path from S to G.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化此算法的输出产生图 4.20，其中高亮线表示从 S 到 G 的解决方案路径。
- en: '![](../Images/CH04_F20_Khamis.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F20_Khamis.png)'
- en: Figure 4.20 Solution using a beam width of *w* = 2. The highlighted line represents
    the solution path.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 使用束宽 *w* = 2 的解决方案。高亮线表示解决方案路径。
- en: As you will see in a later section, when applying beam search to a real-life
    routing problem, generating the children in a beam search can become very complicated
    and time consuming.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如您将在后续章节中看到，当将束搜索应用于现实生活中的路由问题时，生成束搜索中的子节点可能会变得非常复杂和耗时。
- en: 4.3.3 A* search algorithm
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 A* 搜索算法
- en: The *A** (pronounced A-star) algorithm is an informed search algorithm widely
    used in pathfinding and graph traversal. This algorithm is a special case of the
    best-first algorithm. Best-first search is a kind of mixed depth- and breadth-first
    search that expands the most desirable unexpanded node based on either the cost
    to reach the node or an estimate or heuristic value of the cost to reach the goal
    from that node. The A* algorithm takes into account both the cost to reach the
    node and the estimated cost to reach the goal in order to find the optimal solution.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*A*（发音为 A-star）算法是一种在路径查找和图遍历中广泛使用的启发式搜索算法。该算法是最佳优先搜索算法的一个特例。最佳优先搜索是一种混合深度优先搜索和广度优先搜索的方法，它根据到达节点的成本或从该节点到达目标的估计或启发式成本值来扩展最期望的未扩展节点。A*
    算法考虑到达节点的成本和到达目标的估计成本，以找到最优解。'
- en: The pseudocode for A* is shown in algorithm 4.4.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: A* 算法的伪代码在算法 4.4 中展示。
- en: Algorithm 4.4 A* algorithm
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 算法 4.4 A* 算法
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A* search tries to reduce the total number of states explored by incorporating
    both the actual cost and a heuristic estimate of the cost to get to the goal from
    a given state. The driving force behind A* is the selection of a new vertex (or
    node) to explore based on the lowest value. The value of the evaluation function
    *f*(*n*) is computed using the following formula:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: A* 搜索试图通过结合实际成本和从给定状态到达目标的启发式成本估计来减少探索的总状态数。A* 的驱动力是基于最低值选择新的顶点（或节点）进行探索。评估函数
    *f*(*n*) 的值使用以下公式计算：
- en: '| *f*(*n*) = *g*(*n*) + *h*(*n*) | 4.1 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| *f*(*n*) = *g*(*n*) + *h*(*n*) | 4.1 |'
- en: In equation 4.1, *g*(*n*) is the actual cost of the partial path already traveled
    from the source node S to node *n*. The heuristic information *h*(*n*) can be
    the straight-line distance between node *n* and destination node G, or some other
    function. When *h*(*n*) = 0 for all nodes, A* will behave like a uniform-cost
    search (UCS), which was explained in section 3.4.2, so the node with the lowest
    cost will be expanded regardless of the estimated cost to reach the goal.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程 4.1 中，*g*(*n*) 是从源节点 S 到节点 *n* 已经走过的部分路径的实际成本。启发式信息 *h*(*n*) 可以是节点 *n* 和目标节点
    G 之间的直线距离，或者某个其他函数。当所有节点的 *h*(*n*) = 0 时，A* 将表现得像均匀成本搜索（UCS），这在第 3.4.2 节中已解释，因此，无论到达目标的估计成本如何，都会扩展成本最低的节点。
- en: 'In *weighted A**, a constant weight is added to the heuristic function as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *加权 A* 中，将一个常数权重添加到启发式函数中，如下所示：
- en: '| *f*(*n*) = *g*(*n*) + *w* × *h*(*n*) | 4.2 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| *f*(*n*) = *g*(*n*) + *w* × *h*(*n*) | 4.2 |'
- en: To increase the importance of *h*(*n*), *w* should be greater than 1\. A dynamic
    weight *w*(*n*) can be also used. The choice of the heuristic information is critical
    to the search results. The heuristic information *h*(*n*) is admissible if and
    only if *h*(*n*) is less than the actual cost to reach the goal state from *n*
    for every node *n* . This means that admissible heuristics never overestimate
    the cost to reach the goal and can lead to optimal solutions only when the heuristic
    function is close to the true remaining distance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加 *h*(*n*) 的重要性，*w* 应该大于 1。也可以使用动态权重 *w*(*n*)。启发式信息的选取对搜索结果至关重要。当且仅当启发式信息
    *h*(*n*) 小于从节点 *n* 到目标状态的实际成本时，启发式信息 *h*(*n*) 是可接受的。这意味着可接受启发式永远不会高估到达目标状态的成本，并且只有当启发式函数接近真实剩余距离时，才能导致最优解。
- en: The A* heuristic algorithm operates by choosing the next vertex for exploration
    in a *greedy* manner, prioritizing nodes based on the value of the heuristic function.
    As the sum of the distance to the origin and destination is minimized when *n*
    lies on a straight line from S to G, this heuristic prioritizes nodes that are
    closer to the straight-line distance from origin to destination.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: A* 启发式算法通过以 *贪婪* 的方式选择下一个要探索的顶点，根据启发函数的值优先考虑节点。由于当 *n* 位于从 S 到 G 的直线上时，到起点和终点的距离之和最小，这个启发式优先考虑那些更接近起点到终点直线距离的节点。
- en: To better understand the A* procedure, let’s consider the simple problem of
    finding the shortest path between a source node S and a goal node G in an 8 points
    of interest (POIs) road network. This is the same POI graph from figure 4.14 but
    with heuristic values added for each node. An example of heuristic information
    is the straight-line distance to the goal as shown above each vertex in figure
    4.21.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 A* 算法，让我们考虑这样一个简单问题：在一个 8 个兴趣点（POIs）路网中，寻找源节点 S 和目标节点 G 之间的最短路径。这是与图
    4.14 相同的 POI 图，但每个节点都添加了启发值。启发信息的例子是图 4.21 中每个顶点上方显示的到目标点的直线距离。
- en: '![](../Images/CH04_F21_Khamis.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F21_Khamis.png)'
- en: Figure 4.21 An 8 POIs road network in the form of a graph with heuristic information
    (straight-line distance to the goal) shown above each vertex
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 显示了一个具有启发信息（到目标点的直线距离）的 8 个 POIs 路网图，每个顶点上方都标明了这些信息
- en: Figure 4.22 shows the steps for using A* to find the shortest path from S to
    G.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22 展示了使用 A* 寻找从 S 到 G 的最短路径的步骤。
- en: '![](../Images/CH04_F22_Khamis.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F22_Khamis.png)'
- en: Figure 4.22 The A* steps to find the shortest path between the source node S
    and goal node G in an 8 POIs road network. The sum of the already incurred costs
    and the distance to the goal is used as the heuristic value to determine whether
    to expand a certain node.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22 显示了在 8 个 POIs 路网中，从源节点 S 到目标节点 G 的 A* 步骤寻找最短路径。使用已发生的成本总和以及到目标点的距离作为启发值，以确定是否展开某个节点。
- en: This algorithm may look complex since it seems to need to store incomplete paths
    and their lengths at various places. However, using a recursive best-first search
    implementation can solve this problem in an elegant way without the need for explicit
    path storing. The quality of the lower-bound goal distance from each node greatly
    influences the timing complexity of the algorithm. The closer the given lower
    bound is to the true distance, the shorter the execution time.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法可能看起来很复杂，因为它似乎需要在多个地方存储不完整的路径及其长度。然而，使用递归最佳优先搜索实现可以优雅地解决这个问题，而无需显式存储路径。从每个节点到下界目标距离的质量极大地影响了算法的时间复杂度。给定的下界越接近真实距离，执行时间就越短。
- en: We can apply the A* algorithm to the simple routing problem as follows (see
    the book’s GitHub repo for the full code, containing graph initialization and
    visualization).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 A* 算法应用于简单的路由问题，如下所示（有关完整代码，包括图初始化和可视化，请参阅本书的 GitHub 仓库）。
- en: Listing 4.5 Simple routing using A* search
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 使用 A* 搜索进行简单路由
- en: '[PRE11]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① Choose a node based on its heuristic value
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ① 根据启发值选择一个节点
- en: ② Expand the node’s children, adding them to the frontier or terminating if
    the destination is found.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ② 展开节点的子节点，将它们添加到前沿或如果找到目的地则终止。
- en: ③ Add the toOrigin value for each node on the fly
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在线为每个节点添加 toOrigin 值
- en: 'The implementation of A* in listing 4.5 doesn’t use a “real” A* heuristic algorithm
    for two reasons:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 中的 A* 实现没有使用“真正的”A* 启发式算法，原因如下：
- en: The straight line or haversine distance from any node to the destination cannot
    be readily determined, as we only have edge weights and no real spatial data (coordinates)
    to situate each node. To get around this, I created a function called `dummy_astar_heuristic`
    that returns static, arbitrarily generated distances for the purposes of this
    example.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们只有边权重而没有实际的空间数据（坐标）来确定每个节点，因此无法直接确定从任何节点到目的地的直线距离或 haversine 距离。为了解决这个问题，我创建了一个名为
    `dummy_astar_heuristic` 的函数，该函数为此示例返回静态、任意生成的距离。
- en: The distance from the origin to any node (straight line or otherwise) cannot
    be determined ahead of time for the same reasons as in the previous point. Thus,
    we use the traveled distance (i.e., the cost from the origin to the node as far
    as has been explored), and we update that value as the algorithm discovers new
    nodes. Later in this chapter, we will see how working with geographic data (such
    as road networks) allows us to capture this information beforehand.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于与前一点相同的原因，无法提前确定从起点到任何节点（直线或其他）的距离。因此，我们使用已行驶的距离（即从起点到已探索节点的成本），并在算法发现新节点时更新该值。在本章的后面部分，我们将看到如何处理地理数据（如道路网络）允许我们在事先捕获此信息。
- en: '`A_Star` can be called as follows, with some example parameters:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`A_Star` 可以如下调用，以下是一些示例参数：'
- en: '[PRE12]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This gives us the same result as with beam search and hill climbing: a path
    of S-A-C-E-G.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了与波束搜索和爬山搜索相同的结果：路径为 S-A-C-E-G。
- en: Haversine distance
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Haversine 距离
- en: 'The haversine formula is used to calculate the geographic distance between
    two points on earth, given their longitudes and latitudes, based on a mean spherical
    earth radius. This distance is also known as the great-circle distance and is
    calculated using the following formula:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Haversine 公式用于根据两点在地球上的经纬度以及平均球面地球半径来计算两点之间的地理距离。这个距离也被称为大圆距离，并使用以下公式计算：
- en: '*d* = *R* × *C* and *C* = 2 × atan2(√*a*, √(1-*a*))        **4.3**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*d* = *R* × *C* 和 *C* = 2 × atan2(√*a*, √(1-*a*))        **4.3**'
- en: In the preceding equation, *a* = sin²(∆*lat*/2) + cos(*lat1*) × cos(*lat2*)
    × sin²(∆*lon*/2), *R* is the earth radius (6,371 km or 3,691 miles), and *d* is
    the final distance between the two points. The following figure shows the haversine
    distance between Los Angeles, USA (34.0522° N, 118.2437° W) and Madrid, Spain
    (40.4168° N, 3.7038° W).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的公式中，*a* = sin²(∆*lat*/2) + cos(*lat1*) × cos(*lat2*) × sin²(∆*lon*/2)，*R*
    是地球半径（6,371 公里或 3,691 英里），*d* 是两点之间的最终距离。以下图显示了美国洛杉矶（34.0522° N, 118.2437° W）和西班牙马德里（40.4168°
    N, 3.7038° W）之间的 haversine 距离。
- en: '![](../Images/CH04_F22_UN01_Khamis.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F22_UN01_Khamis.png)'
- en: Haversine distance between Los Angeles and Madrid
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 洛杉矶和马德里之间的 Haversine 距离
- en: 'The following Python code can be used to calculate the haversine distance:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Python 代码可以用来计算 Haversine 距离：
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① Install the Haversine package, and import the haversine function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ① 安装 Haversine 包，并导入 haversine 函数。
- en: ② Set coordinates of two points in (latitude, longitude) format.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ② 以（纬度，经度）格式设置两个点的坐标。
- en: ③ Set coordinates of two points in (latitude, longitude) format.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 以（纬度，经度）格式设置两个点的坐标。
- en: ④ Calculate the distance in kilometers.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 计算千米距离。
- en: The implementation of the A* heuristic in optalgotools defaults to calculating
    distances as if the earth were flat. For local searches, this yields the best
    results. If the size of the search area is larger, it is better to calculate distance
    by passing `optalgotools.utilities.haversine_distance` into the `measuring_dist`
    parameter, which considers the curvature of the earth.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: optalgotools 中 A* 启发式实现的默认行为是计算距离，好像地球是平的一样。对于局部搜索，这会产生最佳结果。如果搜索区域的大小较大，最好通过将
    `optalgotools.utilities.haversine_distance` 传递到 `measuring_dist` 参数中来计算距离，该参数考虑了地球的曲率。
- en: 4.3.4 Hierarchical approaches
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.4 层次方法
- en: When facing routing problems at larger scales, such as those involving entire
    countries or graphs with millions of nodes, it is simply implausible to use basic
    approaches like Dijkstra's. In the previous chapter, you saw that bidirectional
    Dijkstra's gives a two times speedup compared to Dijkstra’s algorithm. However,
    much faster routing algorithms are needed for interactive applications like navigation
    apps. One way to achieve this is to precompute certain routes and cache them on
    servers so that response times to user queries are reasonable. Another method
    involves pruning the search space. Hierarchical search algorithms prune the search
    space by generating admissible heuristics that abstract the search space.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对更大规模的路线问题时，例如涉及整个国家或具有数百万个节点的图时，使用基本方法（如Dijkstra算法）是不可思议的。在上一章中，你看到双向Dijkstra算法比Dijkstra算法快两倍。然而，对于交互式应用（如导航应用）需要更快的路由算法。实现这一目标的一种方法是在服务器上预先计算某些路线并将它们缓存起来，以便对用户查询的响应时间合理。另一种方法涉及剪枝搜索空间。分层搜索算法通过生成可接受启发式算法来剪枝搜索空间，这些算法抽象了搜索空间。
- en: Note For more details about the general approaches of hierarchical methods,
    see Leighton, Wheeler, and Holte, “Faster optimal and suboptimal hierarchical
    search” [1].
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关分层方法的一般方法细节，请参阅Leighton、Wheeler和Holte的“更快的最优和次优分层搜索” [1]。
- en: Highway hierarchies involve the assignment of hierarchy “levels” to each road
    in a road network graph. This distinguishes the type of road segment (e.g., residential
    roads, national roads, highways). This is further supplemented by relevant data
    such as the maximum designated driving speed as well as the number of turns in
    the road. After the heuristics are generated for the graph, the data is passed
    through a modified search function (bidirectional Dijkstra's, A*, etc.) that considers
    the distance to the destination and the potential expansion node type. Highway
    hierarchy algorithms will generally consider highways as viable expansion nodes
    when they are further away from the target and will start to include national
    roads, and finally residential streets, as they near the destination. During the
    trip, less important roads merge with more important roads (e.g., residential
    roads merge with national roads, and national roads merge with highways). This
    allows us to avoid exploring millions of nodes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 高速公路分层涉及将“层级”分配给道路网络图中的每条道路。这区分了道路段类型（例如，住宅道路、国家道路、高速公路）。这还通过相关数据得到补充，例如最大指定驾驶速度以及道路中的转弯次数。在为图生成启发式算法之后，数据将通过一个修改后的搜索函数（双向Dijkstra算法、A*等）传递，该函数考虑目的地距离和潜在扩展节点类型。高速公路分层算法通常在距离目标更远时将高速公路视为可行的扩展节点，并将开始包括国家道路，最后是住宅街道，随着接近目的地。在旅行过程中，不太重要的道路会与更重要的道路合并（例如，住宅道路与国家道路合并，国家道路与高速公路合并）。这使我们能够避免探索数百万个节点。
- en: Take, for example, a long-distance driving trip from New York to Miami. In the
    beginning, you will need to navigate local roads toward a highway or interstate.
    In the middle section of the trip, you will drive exclusively on the interstate
    or highway. Nearing your destination, you will leave the interstate and once again
    take local roads. While this approach makes sense, there are some disadvantages.
    First, the algorithm overlooks what kind of roads humans prefer to drive on. While
    a highway might make sense for a given route, the user may prefer to take local
    roads (such as when driving to a friend’s house who lives nearby). Second, highway
    hierarchies do not consider factors such as traffic, which fluctuates often and
    adds significant cost to an “optimal” route. You can learn more about highway
    hierarchies in Sanders and Schultes’ article “Highway hierarchies hasten exact
    shortest path queries” [2].
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以从纽约到迈阿密的远程驾驶旅行为例。在旅行的开始阶段，你需要导航到高速公路或州际公路的当地道路。在旅行的中间部分，你将仅在州际公路或高速公路上驾驶。接近目的地时，你将离开州际公路，再次走上当地道路。虽然这种方法是有道理的，但也有一些缺点。首先，算法忽略了人类更喜欢驾驶的道路类型。虽然高速公路对于给定的路线可能是有意义的，但用户可能更喜欢走当地道路（例如，开车去住在附近的朋友的房子）。其次，高速公路分层没有考虑交通等因素，交通经常波动，给“最优”路线增加了显著的成本。你可以在Sanders和Schultes的文章“高速公路分层加速精确最短路径查询”
    [2]中了解更多关于高速公路分层的信息。
- en: The contraction hierarchies (CH) algorithm is another hierarchical approach.
    It is a speed-up technique that improves the performance of shortest-path computations
    by pruning the search space based on the concept of node contraction. For example,
    for an 80 mile single-source single-destination shortest path search query, the
    bidirectional Dijkstra's algorithm explores 220,000 nodes, unidirectional A* explores
    50,000 nodes, and bidirectional A* improves on those by exploring about 25,000
    nodes. Contraction hierarchies solve the same problem by exploring only about
    600 nodes. This makes CH much faster than Dijkstra's, bidirectional Dijkstra's,
    and A*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 收缩层次（CH）算法是另一种分层方法。它是一种加速技术，通过基于节点收缩的概念剪枝搜索空间来提高最短路径计算的性能。例如，对于一个80英里单源单目的最短路径搜索查询，双向Dijkstra算法探索了220,000个节点，单向A*探索了50,000个节点，双向A*通过探索大约25,000个节点来改进这些结果。收缩层次通过只探索大约600个节点来解决相同的问题。这使得CH比Dijkstra的、双向Dijkstra的以及A*都要快得多。
- en: 'Note Contraction hierarchies were introduced in Geisberger et al.’s 2008 “Contraction
    hierarchies: Faster and simpler hierarchical routing in road networks” article
    [3]. The 80 mile single-source single-destination shortest path search query is
    discussed on the *GraphHopper* blog ([http://mng.bz/n142](http://mng.bz/n142)).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：收缩层次在Geisberger等人2008年的“收缩层次：道路网络中更快、更简单的分层路由”文章[3]中被引入。80英里单源单目的最短路径搜索查询在*GraphHopper*博客上进行了讨论([http://mng.bz/n142](http://mng.bz/n142))。
- en: 'The CH algorithm encompasses two main phases:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: CH算法包含两个主要阶段：
- en: The *preprocessing phase* is where nodes and edges are categorized based on
    some notion of importance. Important nodes can be major cities, major intersections,
    bridges connecting the two sides of a city, or points of interest that shortest
    paths go through. Each node is contracted based on the level of importance from
    least important to most important. During the contraction process, a set of shortcut
    edges is added to the graph to preserve shortest paths.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*预处理阶段*是节点和边根据某些重要性概念进行分类的地方。重要的节点可以是主要城市、主要交叉口、连接城市两边的桥梁，或者最短路径经过的兴趣点。每个节点根据从最不重要到最重要的级别进行收缩。在收缩过程中，向图中添加了一组快捷边以保留最短路径。'
- en: The *query phase* is where a bidirectional Dijkstra's search (or any other search)
    is run on the preprocessed graph, considering only increasingly important edges.
    This results in selectively ignoring less important nodes, and overall improving
    querying speed.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*查询阶段*是在预处理图上运行双向Dijkstra搜索（或任何其他搜索）的地方，只考虑越来越重要的边。这导致有选择地忽略不那么重要的节点，从而整体提高查询速度。'
- en: It’s worth noting that the CH algorithm is mainly a preprocessing algorithm,
    which means that it is used before querying the shortest path. This preprocessing
    phase takes some time, but once it’s done, the query phase is very fast. The algorithm
    can handle large graphs and can be used for various types of graphs, not only
    road networks. Let’s dive into both phases in further detail.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，CH算法主要是一个预处理算法，这意味着它在查询最短路径之前使用。这个预处理阶段需要一些时间，但一旦完成，查询阶段就非常快。该算法可以处理大型图，并且可用于各种类型的图，而不仅仅是道路网络。让我们更详细地探讨这两个阶段。
- en: The CH preprocessing phase
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: CH预处理阶段
- en: The preprocessing phase takes as input the original graph, and it returns an
    augmented graph and node order to be used during the query phase.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理阶段以原始图作为输入，并返回用于查询阶段的增强图和节点顺序。
- en: 'Assume a weighted directed graph *G* = (*V*,*E*). The nodes of this graph are
    ordered based on node importance. In the case of road networks, node importance
    can be based on road type: residential roads, national roads, and motorways or
    highways. The basic intuition here is that closer to the source or target, we
    usually consider residential roads; far away from the source or target, national
    roads are considered; and even further away from the source or the target, it
    makes sense to consider highways. Some other heuristics that affect the node importance
    include the maximum speed, toll rates, the number of turns, etc.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个加权有向图 *G* = (*V*,*E*)。该图的节点根据节点重要性进行排序。在道路网络的情况下，节点重要性可以基于道路类型：住宅道路、国家道路、以及连接城市两边的桥梁或最短路径经过的兴趣点。基本直觉是，靠近源点或目标点时，我们通常考虑住宅道路；远离源点或目标点时，考虑国家道路；而更远离源点或目标点时，考虑高速公路是有意义的。影响节点重要性的其他启发式方法包括最大速度、通行费率、转弯次数等。
- en: 'Once the node order is determined, the vertex set or nodes are ordered by importance:
    *V* = {1,2,3…,*n*}. Nodes are contracted or removed in this order using the following
    procedure:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了节点顺序，顶点集或节点就按重要性排序：*V* = {1,2,3…,*n*}。使用以下程序按此顺序收缩或删除节点：
- en: '[PRE14]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As illustrated in figure 4.23, node *v* can be contracted from graph *G*. If
    necessary, a shortcut or edge with a cost of 5 should be added to ensure that
    the shortest distance between *u* and *w* is preserved or remains the same, even
    after *v* has been contracted. Contracting a node *v* means replacing the shortest
    paths going through *v* with shortcuts. The new graph is called an *overlay graph*
    or an *augmented graph* (i.e., a graph with an augmented set of edges). This graph
    contains the same set of vertices as the initial graph and all the edges, plus
    all the added edges (shortcuts) used to preserve shortest distances in the original
    graph.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 4.23 所示，节点 *v* 可以从图 *G* 中收缩。如果需要，应添加一个成本为 5 的捷径或边，以确保在收缩 *v* 后，*u* 和 *w*
    之间的最短距离保持不变或保持相同。收缩节点 *v* 意味着用捷径替换通过 *v* 的最短路径。新的图称为 *overlay graph* 或 *augmented
    graph*（即具有增强边的图）。此图包含与初始图相同的顶点集和所有边，以及用于在原始图中保留最短距离的所有添加的边（捷径）。
- en: '![](../Images/CH04_F23_Khamis.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F23_Khamis.png)'
- en: Figure 4.23 Node contraction operation—the number in brackets denotes the cost
    of the added shortcut.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.23 节点收缩操作—括号中的数字表示添加的捷径的成本。
- en: When contracting node *v*, no shortcut is needed if there is a path *P* between
    *u* and *w* with *w*(*P*) <= *w*(<*u*,*v*,*w*>). This path is called a *witness
    path*, as shown in figure 4.24.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当收缩节点 *v* 时，如果存在一条从 *u* 到 *w* 的路径 *P*，且 *w*(*P*) <= *w*(<*u*,*v*,*w*>)，则不需要任何捷径。这条路径被称为
    *witness path*，如图 4.24 所示。
- en: '![](../Images/CH04_F24_Khamis.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F24_Khamis.png)'
- en: Figure 4.24 Witness path—there is another path from *P* to *w* that is shorter,
    so no shortcut is needed when contracting *v*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.24 证人路径—从 *P* 到 *w* 存在另一条更短的路径，因此在收缩 *v* 时不需要捷径。
- en: During the CH preprocessing phase, since the nodes are ordered based on importance,
    a node can be iteratively contracted, and an additional shortcut arc can be added
    to preserve short distances and to form an augmented graph. We end up with a contraction
    hierarchy, with one overlay graph for each individual node. This preprocessing
    is done offline, and the augmented graph is used later during the query phase.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CH 预处理阶段，由于节点是根据重要性排序的，因此节点可以迭代收缩，并添加一个额外的捷径弧以保留短距离并形成增强图。我们最终得到一个收缩层次结构，每个节点都有一个覆盖图。这种预处理是在离线完成的，增强图在查询阶段稍后使用。
- en: 'Let’s consider a simple graph with four nodes. Figure 4.25 shows the steps
    of the contraction process. We will contract each node following the order of
    importance from the least to the most important node (i.e., following the importance
    or hierarchy level from 1 to *n*). This process will form shortcuts, which will
    allow us to search the graph much faster, as we can ignore nodes that have been
    pruned. The initial graph is shown in figure 4.25a:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个具有四个节点的简单图。图 4.25 显示了收缩过程的步骤。我们将按照从最不重要到最重要的节点的顺序（即从 1 到 *n* 的重要性或层次级别）收缩每个节点。这个过程将形成捷径，这将使我们能够更快地搜索图，因为我们能够忽略已经被剪枝的节点。初始图如图
    4.25a 所示：
- en: By contracting the least important node, node 1, nothing happens, as the shortest
    path between the neighboring nodes 2 and 4 does not pass by node 1 (figure 4.25b).
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过收缩最不重要的节点，节点 1，由于相邻节点 2 和 4 之间的最短路径不经过节点 1，因此没有任何变化（如图 4.25b 所示）。
- en: Moving forward and contracting the next most important node, node 2, we have
    now changed the shortest path for 1→3, 1→4, and 3→4\. We can encode these shortest
    paths by creating new edges (shortcuts). The numbers in brackets denote the costs
    of the added shortcuts (figure 4.25c).
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续前进并收缩下一个最重要的节点，节点 2，我们现在已经改变了 1→3、1→4 和 3→4 的最短路径。我们可以通过创建新的边（捷径）来编码这些最短路径。括号中的数字表示添加的捷径的成本（如图
    4.25c 所示）。
- en: Contracting node 3 does not cause any change, as there is a shorter path between
    nodes 2 and 4 that does not pass by node 3 (figure 4.25d).
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收缩节点 3 不会引起任何变化，因为节点 2 和 4 之间存在一条更短的路径，且不经过节点 3（如图 4.25d 所示）。
- en: We do not need to contract node 4, as it is the last node in the graph (figure
    4.25e).
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要收缩节点 4，因为它是图中的最后一个节点（如图 4.25e 所示）。
- en: The generated overlay graph after the contraction process is shown in figure
    4.25f. The nodes are ordered based on importance.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 收缩过程后的生成覆盖图如图 4.25f 所示。节点根据重要性排序。
- en: '![](../Images/CH04_F25_Khamis.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F25_Khamis.png)'
- en: Figure 4.25 An example of the CH preprocessing phase
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.25 CH预处理阶段的示例
- en: The order of contraction does not affect the success of CH, but it will affect
    the preprocessing and query time. Some contraction ordering systems minimize the
    number of shortcuts added in the augmented graph and thus the overall running
    time.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 合并的顺序不会影响CH的成功，但它将影响预处理和查询时间。一些合并排序系统最小化增强图中添加的快捷路径数，从而降低整体运行时间。
- en: To begin, we need to use some notion of importance and keep all the nodes in
    a priority queue by decreasing importance. Edge difference, lazy updates, the
    number of contracted neighbors, and shortcut cover (all explained shortly) are
    examples of importance criteria. The *importance* of each node in the graph is
    its *priority*. This metric guides the order in which nodes are contracted. This
    *priority* term is dynamic and is continuously updated as nodes are contracted.
    The typical importance criteria include
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用某种重要性概念，并按重要性递减的顺序将所有节点保持在优先队列中。边差、懒惰更新、合并邻居的数量和快捷覆盖（所有内容将简要解释）是重要性标准的一些例子。图中每个节点的
    *重要性* 是其 *优先级*。这个指标指导了节点合并的顺序。这个 *优先级* 是动态的，并且随着节点的合并而持续更新。典型的重要性标准包括
- en: '*Lazy updates*—The priority of the node on top of the priority queue (i.e.,
    the node with the smallest priority) is updated before it is removed. If this
    node is still on top after the update, it will be contracted. Otherwise, the new
    topmost node will be processed in the same way.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*懒惰更新*—在从优先队列中移除之前，更新优先队列顶部的节点（即具有最小优先级的节点）。如果更新后此节点仍然位于顶部，它将被合并。否则，新的最顶部节点将以相同的方式进行处理。'
- en: '*Edge difference* (ED)—The ED of a node is the number of edges that need to
    be added versus the number of edges to be removed. We want to minimize the number
    of edges added to the augmented graph. For a node *v* in a graph, assume that'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*边差*（ED）—一个节点的边差是需要添加的边数与需要移除的边数之差。我们希望最小化添加到增强图中的边数。对于一个图中的节点 *v*，假设'
- en: in(*v*) is the incoming degree (i.e., the number of edges coming into a node)
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: in(*v*) 是入度（即进入节点的边的数量）
- en: out(*v*) is the outgoing degree (i.e., the number of outgoing edges emanating
    from a node)
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: out(*v*) 是出度（即从节点发出的边的数量）
- en: deg(*v*) is the total degree of the node, which is the sum of its in and out
    degrees so deg(*v*) = in(*v*) + out(*v*)
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: deg(*v*) 是节点的总度数，它是其入度和出度的总和，因此 deg(*v*) = in(*v*) + out(*v*)
- en: add(*v*) is the number of added shortcuts
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: add(*v*) 是添加的快捷路径数
- en: ED(*v*) is the edge difference after contracting node *v*, and it’s given by
    ED(*v*) = add(*v*) – deg(*v*)
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ED(*v*) 是合并节点 *v* 后的边差，它由 ED(*v*) = add(*v*) – deg(*v*) 给出
- en: The next two figures show how the edge difference is calculated and used to
    choose between contracting an edge node like *A* (figure 4.26) and a hub node
    like *E* (figure 4.27)
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下两个图显示了边差是如何计算并用于在合并边节点如 *A*（图4.26）和中心节点如 *E*（图4.27）之间进行选择的。
- en: '![](../Images/CH04_F26_Khamis.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F26_Khamis.png)'
- en: Figure 4.26 Edge difference in the case of edge node *A*
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.26 边节点 *A* 情况下的边差
- en: '![](../Images/CH04_F27_Khamis.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F27_Khamis.png)'
- en: Figure 4.27 Edge difference in case of a hub node. The numbers in brackets denote
    the cost of the added shortcuts.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27 中心节点情况下的边差。括号中的数字表示添加的快捷路径的成本。
- en: '*Number of contracted neighbors*—This reflects how nodes are spread across
    the map. It is better to avoid contracting all nodes in a small region of the
    graph and to ensure uniformity during the contraction process. We first contract
    the node with the smallest number of contracted neighbors.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*合并邻居的数量*—这反映了节点在地图上的分布情况。最好避免在图的小区域内合并所有节点，并确保合并过程中的均匀性。我们首先合并合并邻居数量最少的节点。'
- en: '*Shortcut cover*—This method approximates how unavoidable the node is (e.g.,
    a bridge connecting two parts of a city across a river). It represents the number
    of neighbors of a node, and thus how many shortcuts we’ll need to create to or
    from them after contracting the node, because they’re unavoidable nodes. Nodes
    with a smaller number of shortcut covers are contracted first.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*快捷覆盖*—这种方法近似地表示节点不可避免的程度（例如，连接城市两部分的桥梁）。它代表节点的邻居数量，因此表示在合并节点后我们需要创建多少快捷路径到或从它们，因为它们是不可避免的节点。快捷覆盖数较少的节点将首先合并。'
- en: The priority of a node estimates the attractiveness of contracting the node
    and can be a weighted linear combination of the previously described importance
    criteria, such as edge difference, number of contracted neighbors, and shortcut
    cover. The least important node is extracted in each iteration. The contraction
    process may affect the importance of a node, so we need to recompute this node
    importance. The newly updated importance is then compared with the node on the
    top of the priority queue (with the lowest importance) to decide whether or not
    this node needs to be contracted. The node with the smallest updated importance
    is always contracted.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的优先级估计收缩节点的吸引力，可以是先前描述的重要性标准（如边差异、收缩邻居的数量和捷径覆盖）的加权线性组合。在每次迭代中提取最不重要的节点。收缩过程可能会影响节点的重要性，因此我们需要重新计算这个节点的重要性。然后，将新更新的重要性与优先队列顶部的节点（重要性最低）进行比较，以决定是否需要收缩这个节点。更新后重要性最小的节点总是被收缩。
- en: The CH query phase
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: CH查询阶段
- en: 'During the CH query phase, we apply bidirectional Dijkstra''s to find the shortest
    path between the source and the target, as follows (figure 4.28):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在CH查询阶段，我们应用双向Dijkstra算法以找到源节点和目标节点之间的最短路径，如下所示（图4.28）：
- en: Dijkstra’s algorithm from the source only considers edges *u*,*v* where level(*u*)
    > level(*v*), so you only want to relax nodes with a higher level than the node
    you have relaxed at that iteration. This is called the *upward graph*. In the
    context of Dijkstra’s algorithm, *relaxing* a node refers to the process of updating
    the estimated distance or cost to reach that node from a source node by considering
    shorter paths through neighboring nodes. This helps refine the estimate of the
    shortest path to the node from the source.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dijkstra算法从源节点出发仅考虑边 *u*,*v* 其中 level(*u*) > level(*v*)，因此你只想放松比你在该迭代中放松的节点级别高的节点。这被称为
    *向上图*。在Dijkstra算法的上下文中，*放松*一个节点是指通过考虑通过相邻节点更短的路径来更新从源节点到达该节点的估计距离或成本的过程。这有助于细化从源节点到节点的最短路径的估计。
- en: Dijkstra’s algorithm from the target only considers edges *u*,*v* where level(*u*)
    < level(*v*), so you only want to relax nodes with a lower level than the node
    you have relaxed at that iteration. This is called the *downward graph*.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dijkstra算法从目标节点出发仅考虑边 *u*,*v* 其中 level(*u*) < level(*v*)，因此你只想放松比你在该迭代中放松的节点级别低的节点。这被称为
    *向下图*。
- en: '![](../Images/CH04_F28_Khamis.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F28_Khamis.png)'
- en: Figure 4.28 CH query phase
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.28 CH查询阶段
- en: A CH example
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一个CH示例
- en: Consider the following network with an arbitrary node ordering (figure 4.29).
    The numbers in the circles are the order in which the nodes will be contracted.
    The numbers on the edges represent the costs.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下具有任意节点排序的网络（图4.29）。圆圈中的数字是节点将被收缩的顺序。边上的数字代表成本。
- en: '![](../Images/CH04_F29_Khamis.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F29_Khamis.png)'
- en: Figure 4.29 A CH example
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.29 一个CH示例
- en: 'Let’s run the CH algorithm on this graph to get the shortest path between two
    nodes in this road network. The following steps show how to apply the CH algorithm:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在该图上运行CH算法以获取该道路网络中两个节点之间的最短路径。以下步骤显示了如何应用CH算法：
- en: 1\.  *Contracting node 1*—There’s no need to add a shortcut, as we do not lose
    a shortest path (figure 4.30).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  *收缩节点1*—不需要添加捷径，因为我们没有丢失最短路径（图4.30）。
- en: '![](../Images/CH04_F30_Khamis.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F30_Khamis.png)'
- en: Figure 4.30 Graph contraction using an arbitrary node ranking—contracting node
    1
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.30 使用任意节点排名进行图收缩—收缩节点1
- en: 2\.  *Contracting node 2*—There’s no need to add a shortcut, as we do not lose
    a shortest path (figure 4.31).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  *收缩节点2*—不需要添加捷径，因为我们没有丢失最短路径（图4.31）。
- en: '![](../Images/CH04_F31_Khamis.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F31_Khamis.png)'
- en: Figure 4.31 Graph contraction using an arbitrary node ranking—contracting node
    2
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.31 使用任意节点排名进行图收缩—收缩节点2
- en: 3\.  *Contracting node 3*—A shortcut needs to be added to preserve the shortest
    path between 8 and 5, as there is no witness path. The cost of the added arc is
    7 (figure 4.32).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  *收缩节点3*—需要添加一个捷径以保持8和5之间的最短路径，因为没有见证路径。添加的弧的成本是7（图4.32）。
- en: '![](../Images/CH04_F32_Khamis.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F32_Khamis.png)'
- en: Figure 4.32 Graph contraction using an arbitrary node ranking—contracting node
    3
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.32 使用任意节点排名进行图收缩—收缩节点3
- en: 4\.  *Contracting node 4*—No shortcuts need to be added (figure 4.33).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  *收缩节点4*—不需要添加捷径（图4.33）。
- en: '![](../Images/CH04_F33_Khamis.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F33_Khamis.png)'
- en: Figure 4.33 Graph contraction using an arbitrary node ranking—contracting node
    4
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.33 使用任意节点排序进行图收缩——收缩节点4
- en: 5\.  *Contracting node 5*—No shortcuts need to be added (figure 4.34).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  *收缩节点5*——不需要添加任何捷径（图4.34）。
- en: '![](../Images/CH04_F34_Khamis.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F34_Khamis.png)'
- en: Figure 4.34 Graph contraction using an arbitrary node ranking—contracting node
    5
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.34 使用任意节点排序进行图收缩——收缩节点5
- en: 6\.  *Contracting node 6*—No shortcuts need to be added, as there is a witness
    path between 7 and 10, which is 7-11-12-10 (figure 4.35).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  *收缩节点6*——不需要添加任何捷径，因为7和10之间存在一个见证路径，即7-11-12-10（图4.35）。
- en: '![](../Images/CH04_F35_Khamis.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F35_Khamis.png)'
- en: Figure 4.35 Graph contraction using an arbitrary node ranking—contracting node
    6
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.35 使用任意节点排序进行图收缩——收缩节点6
- en: 7\.  *Contracting node 7*—No shortcuts need to be added (figure 4.36).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  *收缩节点7*——不需要添加任何捷径（图4.36）。
- en: '![](../Images/CH04_F36_Khamis.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F36_Khamis.png)'
- en: Figure 4.36 Graph contraction using an arbitrary node ranking—contracting node
    7
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.36 使用任意节点排序进行图收缩——收缩节点7
- en: 8\.  *Contracting node 8*—A shortcut needs to be added to preserve the shortest
    path between 9 and 12 (figure 4.37).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  *收缩节点8*——需要添加一个捷径以保持9和12之间的最短路径（图4.37）。
- en: '![](../Images/CH04_F37_Khamis.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F37_Khamis.png)'
- en: Figure 4.37 Graph contraction using an arbitrary node ranking—contracting node
    8
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.37 使用任意节点排序进行图收缩——收缩节点8
- en: 9\.  *Contracting node 9*—No shortcuts need to be added (figure 4.38).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  *收缩节点9*——不需要添加任何捷径（图4.38）。
- en: '![](../Images/CH04_F38_Khamis.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F38_Khamis.png)'
- en: Figure 4.38 Graph contraction using an arbitrary node ranking—contracting node
    9
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.38 使用任意节点排序进行图收缩——收缩节点9
- en: 10\.  *Contracting node 10*—No shortcuts need to be added (figure 4.39).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  *收缩节点10*——不需要添加任何捷径（图4.39）。
- en: '![](../Images/CH04_F39_Khamis.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F39_Khamis.png)'
- en: Figure 4.39 Graph contraction using an arbitrary node ranking—contracting node
    10
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.39 使用任意节点排序进行图收缩——收缩节点10
- en: 11\.  *Contracting node 11*—No shortcuts need to be added (figure 4.40).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 11.  *收缩节点11*——不需要添加任何捷径（图4.40）。
- en: '![](../Images/CH04_F40_Khamis.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F40_Khamis.png)'
- en: Figure 4.40 Graph contraction using an arbitrary node ranking—contracting node
    11
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.40 使用任意节点排序进行图收缩——收缩节点11
- en: 12\.  *Contracting node 12*—No shortcuts need to be added (figure 4.41).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 12.  *收缩节点12*——不需要添加任何捷径（图4.41）。
- en: '![](../Images/CH04_F41_Khamis.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F41_Khamis.png)'
- en: Figure 4.41 Graph contraction using an arbitrary node ranking—contracting node
    12
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.41 使用任意节点排序进行图收缩——收缩节点12
- en: The contracted graph can now be queried using a bidirectional Dijkstra's search.
    In the following figures, the numbers in brackets denote the cost of the added
    shortcut.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用双向Dijkstra搜索查询收缩后的图。在以下图中，括号中的数字表示添加的捷径的成本。
- en: The upward graph in figure 4.42 shows the forward Dijkstra's search from the
    source to the target. The solid lines represent the visited edges, and the bold
    solid lines represent the shortest path between the source node and the meeting
    node.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.42中的向上图显示了从源到目标的前向Dijkstra搜索。实线代表已访问的边，粗实线代表源节点和汇合节点之间的最短路径。
- en: '![](../Images/CH04_F42_Khamis.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F42_Khamis.png)'
- en: Figure 4.42 Solving a road network problem using the CH algorithm—upward graph
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.42 使用CH算法解决道路网络问题——向上图
- en: The downward graph in figure 4.43 shows the backward Dijkstra's search from
    the target to the source. The solid lines represent the visited edges, and the
    bold solid lines represent the shortest path between the target node and the meeting
    node.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.43中的向下图显示了从目标到源的反向Dijkstra搜索。实线代表已访问的边，粗实线代表目标节点和汇合节点之间的最短路径。
- en: '![](../Images/CH04_F43_Khamis.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F43_Khamis.png)'
- en: Figure 4.43 Solving a road network problem using the CH algorithm—downward graph
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.43 使用CH算法解决道路网络问题——向下图
- en: The minimum is at node 12 (4 + 8 = 12), so node 12 is the meeting point (figure
    4.44).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值在节点12（4 + 8 = 12），因此节点12是汇合点（图4.44）。
- en: '![](../Images/CH04_F44_Khamis.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F44_Khamis.png)'
- en: Figure 4.44 Solving a road network problem using the CH algorithm—meeting point
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.44 使用CH算法解决道路网络问题——汇合点
- en: The shortest path will be 1-10-12-8-5\. However, this path contains a shortcut
    (5-8). The actual arc (8-3-5) needs to be unpacked according to the shortcut pointer
    (node 3) stored during the contraction process. The actual shortest path is 1-10-12-8-3-4
    with a cost of 12 (figure 4.45).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最短路径将是1-10-12-8-5。然而，这条路径包含一个快捷（5-8）。实际弧（8-3-5）需要根据收缩过程中存储的快捷指针（节点3）进行解包。实际最短路径是1-10-12-8-3-4，成本为12（图4.45）。
- en: '![](../Images/CH04_F45_Khamis.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F45_Khamis.png)'
- en: Figure 4.45 Solving a road network problem using the CH algorithm—shortest path
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.45 使用CH算法解决道路网络问题——最短路径
- en: Listing 4.6 shows the implementation in Python. Note that the code for graph
    initialization has been omitted here, as it is similar to previous examples, but
    it can be viewed in the full listing in the book’s GitHub repo. Likewise, the
    code for graph visualization is also in the full listing.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6展示了Python中的实现。请注意，这里省略了图初始化的代码，因为它与之前的示例类似，但可以在书中GitHub仓库的完整列表中查看。同样，图可视化的代码也在完整列表中。
- en: Listing 4.6 Contraction hierarchy with predetermined node order
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6 预定节点顺序的收缩层次
- en: '[PRE15]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Copy the main graph so that the nodes are only removed from the copy, not
    the main graph.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ① 复制主图，以便节点只从副本中移除，而不是从主图中移除。
- en: ② Contract the node by removing it from the copied graph.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ② 通过从复制的图中移除节点来收缩节点。
- en: ③ Recalculate the shortest path matrix, now with the node contracted.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 重新计算最短路径矩阵，现在节点已被收缩。
- en: ④ Add a shortcut edge to replace the changed shortest path, and keep track of
    it so  we can uncontract it when querying later.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 添加一个快捷边来替换改变后的最短路径，并跟踪它，以便在以后查询时可以解包它。
- en: You will notice that the preceding code creates two shortcut edges for each
    contraction, one from *P* to *v*, and one in reverse from *v* to *u*. As we are
    using an undirected graph, this duplication has no effect, since the edge (*u,
    v*) is the same as the edge (*v, u*).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，前面的代码为每个收缩创建了两个快捷边，一个从 *P* 到 *v*，另一个从 *v* 到 *u* 的反向边。由于我们使用的是无向图，这种重复没有影响，因为边
    (*u, v*) 与边 (*v, u*) 相同。
- en: 'Querying the generated graph requires a simple modified bidirectional Dijkstra''s
    search, where neighbor nodes are disqualified for expansion if they are lower
    in the hierarchy than the current node. For the purposes of this book, we will
    use `networkx.algorithms.shortest_paths.weighted.bidirectional_dijkstra`, with
    a slight change (only nodes of higher hierarchy than the current node can be explored).
    As a continuation of listing 4.6, the following code snippet shows the querying
    process. The full code for the modified algorithm can be found in listing 4.6
    in the book’s GitHub repo:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 查询生成的图需要一个简单的修改后的双向Dijkstra搜索，其中如果邻居节点在层次结构中低于当前节点，则取消资格进行扩展。为了本书的目的，我们将使用`networkx.algorithms.shortest_paths.weighted.bidirectional_dijkstra`，略有变化（只有比当前节点层次结构高的节点可以被探索）。作为列表4.6的延续，以下代码片段显示了查询过程。修改算法的完整代码可以在书中GitHub仓库的列表4.6中找到：
- en: '[PRE16]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Run bidirectional Dijkstra's using NetworkX.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NetworkX运行双向Dijkstra算法。
- en: ② Unpack any edges that are marked as contracted, and generate the unpacked
    route.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ② 解包任何标记为收缩的边，并生成解包路线。
- en: The preceding code will generate an unpacked route that can be visualized as
    in figure 4.46.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将生成一个可以如图4.46可视化的解包路线。
- en: '![](../Images/CH04_F46_Khamis.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F46_Khamis.png)'
- en: Figure 4.46 The solution path after unpacking the contracted edges. The original
    route returned by bidirectional Dijkstra's passes through the contracted edge
    (8,5), which is then unpacked into (8,3) and (3,5).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.46 解包收缩边后的解决方案路径。双向Dijkstra算法返回的原始路线通过收缩边（8,5），然后解包为（8,3）和（3,5）。
- en: Contraction hierarchies expend a great deal of processing time on the preprocessing
    phase, but a correctly pruned graph (i.e., where the node contraction order is
    good) allows for much faster queries. While the small reduction in search space
    is negligible on a graph with 21 nodes, some graphs can be pruned up to 40%, resulting
    in significant cost and time savings when querying. In the example from listing
    4.6, the search from node 1 to node 5 explores 11 nodes, as compared to the original
    16 nodes in a normal bidirectional Dijkstra's. That’s almost a 33% reduction!
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 收缩层次在预处理阶段消耗了大量的处理时间，但一个正确剪枝的图（即节点收缩顺序良好）可以允许进行更快的查询。虽然在一个有21个节点的图上，搜索空间的微小减少是可以忽略的，但某些图可以被剪枝高达40%，在查询时可以节省显著的成本和时间。在4.6列表的例子中，从节点1到节点5的搜索探索了11个节点，而正常双向Dijkstra的原始节点是16个。这几乎减少了33%！
- en: 4.4 Applying informed search to a routing problem
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 将启发式搜索应用于路由问题
- en: Let’s look again at the University of Toronto routing problem introduced in
    section 3.5\. We need to find the shortest path from the King Edward VII Equestrian
    statue at Queen’s Park to the Bahen Centre for Information Technology. The search
    space is represented by a road network in which the intersections and points of
    interest (including the origin and destination) are nodes, and edges are used
    to represent road segments with weight (e.g., distance, travel time, fuel consumption,
    number of turns, etc.). Let’s look at how we can find the shortest path using
    the informed search algorithms discussed in this chapter.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看第3.5节中介绍的多伦多大学路由问题。我们需要找到从女王公园的国王爱德华七世骑马雕像到信息科技中心的最短路径。搜索空间由一个道路网络表示，其中交叉口和兴趣点（包括起点和终点）是节点，边用于表示带有权重（例如，距离、旅行时间、燃料消耗、转弯次数等）的道路段。让我们看看我们如何可以使用本章讨论的启发式搜索算法找到最短路径。
- en: 4.4.1 Hill climbing for routing
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 路由的爬山搜索
- en: Listing 4.7 uses two functions from `optalgotools.routing` that generate random
    and child routes. While the actual HC algorithm is deterministic, the randomized
    initial route means that different results can be achieved over different runs.
    To counter this, we’ll use a higher *n* value, which allows a broader diversity
    of children routes, so an optimal (or near optimal) solution will more likely
    be achieved.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7使用了来自`optalgotools.routing`的两个函数，这些函数生成随机和子路线。虽然实际的HC算法是确定的，但随机化的初始路线意味着在不同的运行中可以得到不同的结果。为了应对这种情况，我们将使用更高的*n*值，这允许更广泛的子路线多样性，因此更有可能得到最优（或近似最优）的解决方案。
- en: Listing 4.7 U of T routing using the hill climbing algorithm
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7 U of T路由使用爬山算法
- en: '[PRE17]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① Track time and costs for comparison.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ①跟踪时间和成本以进行比较。
- en: ② Generate an initial route randomly.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ②随机生成一个初始路线。
- en: ③ Get k neighbors (children).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ③获取k个邻居（子节点）。
- en: While the implementation in listing 4.7 is deterministic, the initial route
    is still randomized. That means it is possible to get different results across
    runs. Hill climbing will return some decent results, as there are few local optimal
    points in the route function. However, larger search spaces will naturally have
    more local maxima and plateaus, and the HC algorithm will get stuck quickly.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然列表4.7中的实现是确定的，但初始路线仍然是随机的。这意味着在不同的运行中可能会得到不同的结果。爬山搜索将返回一些相当不错的结果，因为路线函数中局部最优点的数量很少。然而，较大的搜索空间自然会有更多的局部最大值和平台，HC算法会很快陷入困境。
- en: Figure 4.47 shows a final solution of 806.892 m, which happens to be the same
    as the result generated by Dijkstra’s algorithm in chapter 3 (an optimal solution).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.47显示了一个最终解决方案为806.892米，这恰好与第3章中Dijkstra算法生成的结果相同（一个最优解）。
- en: '![](../Images/CH04_F47_Khamis.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F47_Khamis.png)'
- en: Figure 4.47 Shortest path solution generated using hill climbing. The solution
    shown here uses an *n* value of 100, which increases the total processing time
    but returns better and more consistent results.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.47 使用爬山算法生成的最短路径解决方案。这里显示的解决方案使用了一个* n *值为100，这增加了总处理时间，但返回了更好、更一致的结果。
- en: 4.4.2 Beam search for routing
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 路由的束搜索
- en: A beam search for routing will follow much the same format as the HC search,
    with the exception that a “beam” of solutions is kept for comparison at each iteration.
    The full code for listing 4.8, with the graph initialization and visualization,
    is in the book’s GitHub repo.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 路由的束搜索将与HC搜索具有类似的格式，但不同之处在于在每个迭代中都会保留一个用于比较的“束”解决方案。4.8列表的完整代码，包括图初始化和可视化，可以在本书的GitHub仓库中找到。
- en: Listing 4.8 U of T routing using the beam search algorithm
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8 使用光束搜索算法的U of T路由
- en: '[PRE18]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Generate child routes for each route in the beam.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为光束中的每条路线生成子路线。
- en: ② Initialize empty sets to keep track of visited nodes and path costs.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ② 初始化空集合以跟踪已访问节点和路径成本。
- en: ③ The seen routes must be converted to a tuple so they are hashable and can
    be stored in a set.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 已看到的路线必须转换为元组，以便它们是可哈希的，可以存储在集合中。
- en: ④ Keep the k best routes at each iteration until generating new beams no longer
    finds better solutions.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在生成新光束不再找到更好的解决方案之前，在每个迭代中保留k条最佳路线。
- en: ⑤ The final route is the best route in the last beam.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 最终路线是最后光束中的最佳路线。
- en: ⑥ Return the final route, its cost, processing time, and space required.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 返回最终路线、其成本、处理时间和所需空间。
- en: Beam searches for routing are particularly costly, as they require multiple
    child routes to be generated for each beam. Like HC, generating more children
    results in a broader penetration of the search space, and thus is more likely
    to return a solution that is closer to or reaches the optimal solution. Figure
    4.48 shows a final solution generated by beam search.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 光束搜索在路由中特别昂贵，因为它们需要为每个光束生成多个子路线。像HC一样，生成更多子路线会导致搜索空间的更广泛渗透，因此更有可能返回一个接近或达到最优解的解决方案。图4.48显示了由光束搜索生成的最终解决方案。
- en: '![](../Images/CH04_F48_Khamis.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F48_Khamis.png)'
- en: Figure 4.48 Shortest path using a beam search algorithm. This solution was generated
    using *k* = 10 and *n* = 20, which means that 20 routes were generated for each
    route in the beam, and the top 10 routes were kept for each new beam. Lower *k*
    and *n* values will improve processing time but reduce the likelihood of generating
    a near-optimal or optimal solution.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.48 使用光束搜索算法的最短路径。此解决方案使用*k* = 10和*n* = 20，这意味着为光束中的每条路线生成20条路线，并为每个新光束保留前10条路线。较低的*k*和*n*值将提高处理时间，但会降低生成接近最优或最优解决方案的可能性。
- en: 4.4.3 A* for routing
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 路由的A*
- en: The next listing shows how we can use A* search to find the shortest route between
    two points of interest.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了我们可以如何使用A*搜索找到两个感兴趣点之间的最短路线。
- en: Listing 4.9 U of T routing using A*
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9 使用A*的U of T路由
- en: '[PRE19]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① Set up King’s College Cir, Toronto, ON as a reference.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将多伦多国王学院环道设为参考。
- en: ② Create a graph.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个图。
- en: ③ Set up the King Edward VII equestrian statue as the origin.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将爱德华七世骑马雕像设为起点。
- en: ④ Set up the Bahen Centre for Information Technology at U of T as the destination.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将多伦多大学的信息技术中心设为目标。
- en: ⑤ Get the osmid of the nearest nodes to the points
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 获取最近节点的osmid。
- en: ⑥ Convert the source and destination nodes to Node.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 将源节点和目标节点转换为节点。
- en: ⑦ Find the shortest path using A*.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 使用A*找到最短路径。
- en: ⑧ Print the cost, processing time, space required, and explored nodes, and draw
    the final route.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 打印成本、处理时间、所需空间和已探索的节点，并绘制最终路线。
- en: The optimality of the A* search depends on the heuristic used. In this case,
    the solution returned is not optimal, but the incredibly high processing speed
    achieved is more important for most applications. Figure 4.49 shows a final solution
    generated by A* search.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: A*搜索的最优性取决于使用的启发式函数。在这种情况下，返回的解决方案不是最优的，但所达到的极高处理速度对于大多数应用来说更为重要。图4.49显示了由A*搜索生成的最终解决方案。
- en: '![](../Images/CH04_F49_Khamis.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F49_Khamis.png)'
- en: Figure 4.49 Shortest path using the A* algorithm. Better heuristic functions
    that closely approach the actual costs from any node to the goal will return better
    results.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.49 使用A*算法的最短路径。更接近实际成本的启发式函数将返回更好的结果。
- en: 4.4.4 Contraction hierarchies for routing
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.4 路由的收缩层次
- en: In order to run CH on the road network graph, we first need to rank the nodes
    by importance and then contract the graph. For this example, we are selecting
    edge difference (ED) as our measure of node importance.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在道路网络图中运行CH，我们首先需要按重要性对节点进行排序，然后对图进行收缩。对于这个例子，我们选择边差异（ED）作为节点重要性的度量。
- en: Listing 4.10 U of T routing using CH
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.10 使用CH的U of T路由
- en: '[PRE20]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① Some nodes are essentially dead ends, where they have no outbound edges. These
    nodes have an ED equal to their degree.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ① 一些节点实际上是死胡同，它们没有出边。这些节点的ED等于它们的度数。
- en: ② We can ignore two-way edges—an inbound edge and an outbound edge that originate
    and terminate at the same node.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们可以忽略双向边——一个起点和终点相同的节点的一个入边和一个出边。
- en: ③ The edge difference is the difference between edges that need to be added
    to the graph and the degree of the node.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 边的差异是需要添加到图中边的数量与节点的度数之间的差异。
- en: 'Contracting the graph is as simple as adding an edge for every shortest path
    that gets altered by the contraction. The full code for graph contraction can
    be found in the book’s GitHub repo. Contracted edges are marked with an attribute
    called *midpoint*, which stores the ID of the node that was contracted. Following
    a modified bidirectional Dijkstra''s similar to that used in listing 4.6, the
    final route can be easily unpacked using the following snippet of code:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 将图收缩的过程就像为每条被收缩操作改变的路径添加一条边一样简单。图收缩的完整代码可以在本书的GitHub仓库中找到。收缩的边用名为*midpoint*的属性标记，该属性存储了被收缩的节点的ID。遵循类似于列表4.6中使用的修改后的双向Dijkstra算法，可以使用以下代码片段轻松地解包最终路由：
- en: '[PRE21]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① For every midpoint unpacked, recursively unpack the resulting two edges, as
    some contracted edges may contain other contracted edges.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ① 对于每个解包的中点，递归地解包产生的两个边，因为一些收缩边可能包含其他收缩边。
- en: ② Unpack every node pair in the contracted route.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ② 解包收缩路由中的每个节点对。
- en: The GitHub repo also contains the full Python implementation of CH for routing.
    The route generated is identical to that shown by a normal bidirectional Dijkstra's
    algorithm (such as in chapter 3). If you will recall, running the normal bidirectional
    Dijkstra's in chapter 3 yielded a result where 282 nodes were explored during
    the search. For our CH result, only 164 nodes were explored, which means more
    than a 40% reduction of search space! Thus, while the optimality of the algorithm
    remains unchanged, contraction hierarchies allow for much bigger spaces to be
    searched in a reasonable amount of time.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub仓库还包含了CH路由的完整Python实现。生成的路由与正常双向Dijkstra算法（如第3章中所示）显示的路由相同。如果你还记得，在第3章中运行正常双向Dijkstra算法的结果是在搜索过程中探索了282个节点。对于我们的CH结果，只探索了164个节点，这意味着搜索空间减少了超过40%！因此，虽然算法的优化性保持不变，但收缩层次结构允许在合理的时间内搜索更大的空间。
- en: Table 4.1 compares the search algorithms discussed in this chapter when applied
    to the U of T routing problem. A similar table can be found in chapter 3 for blind
    search algorithms.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1比较了本章讨论的搜索算法在应用于U of T路由问题时的表现。第3章中也有一个类似的表格，用于盲搜索算法。
- en: Table 4.1 Comparing informed search algorithms in terms of time and space complexities,
    where *b* is the branching factor, *w* is the beam width, *d* is the shallowest
    graph depth, *E* is the number of edges, and *V* is the number of vertices
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1比较了基于时间和空间复杂度的信息搜索算法，其中*b*是分支因子，*w*是光束宽度，*d*是最浅的图深度，*E*是边的数量，*V*是顶点的数量
- en: '| Algorithm | Cost (meters) | Time (s) | Space (bytes) | Explored | Time complexity
    | Space complexity |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 算法 | 成本（米） | 时间（秒） | 空间（字节） | 探索 | 时间复杂度 | 空间复杂度 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| Hill climbing | 806.892 | 21.546 | 976 | 400 nodes | *O*(∞) | *O*(*b*) |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| 岩石上升法 | 806.892 | 21.546 | 976 | 400节点 | *O*(∞) | *O*(*b*) |'
- en: '| Beam search | 825.929 | 44.797 | 1,664 | 800 nodes | *O*(*wd*) | *O*(wb)
    |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| 光束搜索 | 825.929 | 44.797 | 1,664 | 800节点 | *O*(*wd*) | *O*(wb) |'
- en: '| A* search | 846.92 | 0.063 | 8,408 | 80 nodes | *O*(*b^d*) | *O*(*b^d*) |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| A*搜索 | 846.92 | 0.063 | 8,408 | 80节点 | *O*(*b^d*) | *O*(*b^d*) |'
- en: '| CH with bidirectional Dijkstra''s | 806.892 | 0.0469 | 72 | 164 nodes | *O*(*E*
    + *V*log*V*) | *O*(*b^d*/2) |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| 双向Dijkstra算法的CH | 806.892 | 0.0469 | 72 | 164节点 | *O*(*E* + *V*log*V*) |
    *O*(*b^d*/2) |'
- en: Note The time listed for CH with bidirectional Dijkstra's is only for querying.
    Remember that the preprocessing step is usually quite costly. In this case, contracting
    the road network of 404 nodes took around 24.03125 seconds.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：双向Dijkstra算法的CH所列出的时间仅用于查询。请记住，预处理步骤通常成本很高。在这种情况下，收缩404个节点的道路网络大约需要24.03125秒。
- en: While hill climbing and beam search produced respectable results, they were
    too costly in terms of time to be useful for larger graphs. A* gives the fastest
    results but a non-optimal heuristic function, and it required excessive space
    for the heuristic values, so it has its own disadvantages. CH with bidirectional
    Dijkstra's is the only algorithm in table 4.1 that guarantees optimality, but
    the costly preprocessing step may not be suitable for all applications.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然岩石上升法和光束搜索产生了可尊敬的结果，但它们在时间上的成本太高，对于更大的图来说没有用。A*给出了最快的搜索结果，但非最优的启发式函数，并且需要大量的空间来存储启发式值，因此它也有自己的缺点。双向Dijkstra算法的CH是表4.1中唯一保证最优性的算法，但昂贵的预处理步骤可能不适合所有应用。
- en: When comparing search algorithms, it is important to be aware of the constraints
    for any given problem and to select an algorithm based on those constraints. For
    example, certain implementations of hill climbing may result in rapid exit conditions.
    If the goal is to maximize the number of problems solved (and if local maxima
    are an acceptable result), HC algorithms result in quick solutions that have some
    degree of optimality. On the other hand, preprocessing-heavy algorithms like CH
    offer incredibly low space costs (even more so when implemented with a bidirectional
    search), as well as rapid searches for guaranteed optimal solutions (if using
    Dijkstra’s algorithm). For high-volume usage implementations where preprocessing
    is not a concern (e.g., Uber), contraction hierarchies are a viable choice. In
    fact, the osrm package used in this book is primarily based on an implementation
    of contraction hierarchies.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较搜索算法时，了解任何给定问题的约束条件非常重要，并基于这些约束条件选择算法。例如，某些爬山算法的实现可能导致快速退出条件。如果目标是最大化解决问题的数量（并且如果局部最大值是可以接受的结果），HC算法会导致快速解决方案，具有一定的最优性。另一方面，预处理密集型算法如CH提供了极低的存储成本（在双向搜索实现时更是如此），以及快速搜索保证最优解（如果使用Dijkstra算法）。对于预处理不是问题的使用量大的实现（例如，Uber），收缩层次结构是一个可行的选择。实际上，本书中使用的osrm包主要基于收缩层次结构的一个实现。
- en: Pandana, a Python library for network analysis, uses CH to calculate shortest
    paths and fast travel accessibility metrics. In Pandana, the backend code for
    CH is in C++ but can be accessed using Python. Pyrosm is another Python library
    for reading and parsing OpenStreetMap data. It is similar to OSMnx but faster,
    and it works with Pandana.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Pandana是一个用于网络分析的Python库，它使用CH来计算最短路径和快速旅行可达性指标。在Pandana中，CH的后端代码是用C++编写的，但可以使用Python访问。Pyrosm是另一个用于读取和解析OpenStreetMap数据的Python库。它与OSMnx类似，但更快，并且与Pandana兼容。
- en: The next listing is a snippet of code that calculates the shortest distances
    to an amenity of interest in a selected city using the CH algorithm implemented
    in Pandana. The complete code is available in the book’s GitHub repo.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表是一个代码片段，它使用Pandana中实现的CH算法计算选定城市中感兴趣设施的最短距离。完整的代码可在本书的GitHub仓库中找到。
- en: Listing 4.11 Using CH to calculate the shortest distances to amenities
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.11 使用CH计算到设施的最近距离
- en: '[PRE22]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① Get data for the city, region, or country of interest.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: ① 获取感兴趣的城市、地区或国家的数据。
- en: ② Get nodes and edges from the road network with a "driving" type.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从具有“驾驶”类型的道路网络中获取节点和边。
- en: ③ Get points of interest for a certain amenity in the city.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 获取城市中特定设施的感兴趣点。
- en: ④ Create a network graph.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建网络图。
- en: ⑤ Ensure all hospitals are represented as points.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 确保所有医院都表示为点。
- en: ⑥ Precompute distances up to 1,000 meters.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 预先计算1,000米内的距离。
- en: ⑦ Attach hospitals to the Pandana graph.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 将医院附加到Pandana图上。
- en: ⑧ For each node, find the distances to the five closest hospitals up to 1,000
    meters away.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 对于每个节点，找到距离1,000米内最近的五家医院。
- en: In this example, OpenStreetMap is used to get data on the city of Toronto, and
    a subset is created to contain data on the city’s hospitals. A Pandana object
    is then created, and the range queries are precomputed, given a horizon distance
    (e.g., 1,000 meters) to represent the reachable nodes within this distance. For
    each node in the network, we can find distances to the five closest hospitals
    up to 1,000 meters away using the fast CH algorithm implemented in Pandana.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用OpenStreetMap获取多伦多的数据，并创建一个子集以包含该城市医院的数据。然后创建一个Pandana对象，并预先计算范围查询，给定一个视距（例如，1,000米）来表示此距离内的可达节点。对于网络中的每个节点，我们可以使用Pandana中实现的快速CH算法找到距离1,000米内最近的五家医院。
- en: In the next part of the book, we’ll look at trajectory-based algorithms starting
    with the simulated annealing algorithm and then the tabu search algorithm. These
    algorithms improve local search and are less susceptible to getting stuck in local
    optima than the previously discussed greedy algorithms, which only accept improving
    moves.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一部分，我们将从模拟退火算法和禁忌搜索算法开始，探讨基于轨迹的算法。这些算法改进了局部搜索，并且比之前讨论的贪婪算法更不容易陷入局部最优，因为贪婪算法只接受改进的移动。
- en: Summary
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Informed search algorithms use domain-specific knowledge or heuristic information
    to streamline the search process while striving for optimal solutions or accepting
    near-optimal ones if necessary.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有信息搜索算法使用领域特定知识或启发式信息来简化搜索过程，同时力求找到最优解或在必要时接受近似最优解。
- en: Informed search algorithms can be used to solve minimum spanning tree (MST)
    problems and to find the shortest path between two nodes in a graph.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有信息搜索算法可用于解决最小生成树（MST）问题，以及在图中找到两个节点之间的最短路径。
- en: The Borůvka algorithm, Jarník-Prim algorithm, and Kruskal algorithm are informed
    search algorithms for solving MST problems. An MST is a tree that contains the
    least weight among all the other spanning trees of a connected weighted graph.
    Kruskal’s algorithm is a greedy algorithm that computes the MST for an undirected
    connected weighted graph by repeatedly adding the next shortest edge that doesn’t
    produce a cycle.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Borůvka算法、Jarník-Prim算法和Kruskal算法是解决最小生成树（MST）问题的启发式搜索算法。MST是包含所有其他连通加权图生成树中最小权重的树。Kruskal算法是一种贪婪算法，通过反复添加不会产生环的下一个最短边来计算无向连通加权图的最小生成树。
- en: Hill climbing (HC), beam search, best-first search, the A* algorithm, and contraction
    hierarchies (CH) are examples of informed search algorithms that can be used to
    find the shortest path between two nodes.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hill climbing（HC）、beam search、best-first search、A*算法和收缩层次（CH）是有信息搜索算法的例子，可用于在两个节点之间找到最短路径。
- en: The HC algorithm is a local greedy search algorithm that tries to improve on
    the efficiency of depth-first by incorporating domain-specific knowledge or heuristic
    information.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HC算法是一种局部贪婪搜索算法，它通过结合领域特定知识或启发式信息来提高深度优先搜索的效率。
- en: Beam search expands the most promising node within a limited predefined set
    defined by the beam width.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Beam search在由beam width定义的有限预定义集合内扩展最有希望的节点。
- en: Best-first search is a greedy algorithm that always expands the node that is
    closest to the goal node based on heuristic information only.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳优先搜索是一种贪婪算法，它仅基于启发式信息始终扩展离目标节点最近的节点。
- en: The A* algorithm is a special case of a best-first algorithm that incorporates
    both the actual cost and a heuristic estimate of the cost to get to the goal from
    a given state.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A*算法是结合了实际成本和从给定状态到达目标状态的启发式成本估计的最佳优先算法的特殊情况。
- en: CH is a speed-up technique for improving the performance of pathfinding. During
    the preprocessing phase, each node is contracted in order of importance (from
    least important to most important), and shortcuts are added to preserve the shortest
    paths. Then the bidirectional Dijkstra’s algorithm is applied to the resultant
    augmented graph to compute the shortest path between the source node and the target
    node.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CH是一种加速技术，用于提高路径查找的性能。在预处理阶段，每个节点按照重要性顺序（从最不重要到最重要）进行收缩，并添加捷径以保留最短路径。然后应用双向Dijkstra算法到结果增强图，以计算源节点和目标节点之间的最短路径。
