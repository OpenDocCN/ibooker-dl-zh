- en: 3 Designing software with ChatGPT
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 设计与ChatGPT的软件
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Prototyping potential designs with ChatGPT
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ChatGPT原型设计潜在的设计
- en: Documenting our architecture in Mermaid
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mermaid记录我们的架构
- en: Completing our design with ChatGPT
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ChatGPT完成我们的设计
- en: Now that we have an intuition about when and how to use Generative AI, we will
    start to design, explore, and document our application’s architecture. Laying
    out some of the critical components upfront is beneficial in several ways. For
    example, it allows us to delegate some of the design to sub-architects or some
    of the development to other team members. Designing up front will also help us
    clarify our thinking about the implementation, allowing us to anticipate and avoid
    some pitfalls. Finally, capturing the design as documentation enables us to justify
    our crucial design decisions, communicating our intent to our future selves, our
    stakeholders, and those who may inherit the project.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对何时以及如何使用生成式AI有了直觉，我们将开始设计、探索和记录我们应用程序的架构。提前布局一些关键组件在几个方面都有益。例如，它允许我们将一些设计委托给子架构师或一些开发工作委托给其他团队成员。提前设计还将帮助我们澄清我们对实施的思考，使我们能够预见并避免一些陷阱。最后，将设计作为文档捕获使我们能够证明我们关键的设计决策，向我们的未来自己、利益相关者和可能继承项目的人传达我们的意图。
- en: 'First, let’s get an overview of the application that we will be designing in
    this chapter: the *information technology asset management* (ITAM) system. We’ll
    build out key features in subsequent chapters.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们概述一下本章将要设计的应用：*信息技术资产管理*（ITAM）系统。我们将在后续章节中构建关键特性。
- en: 3.1 Introducing our project, the information technology asset management system
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 介绍我们的项目，信息技术资产管理系统
- en: An ITAM system is a tool to manage and track hardware devices, software licenses,
    and other IT-related components throughout their lifecycle. ITAM systems typically
    consist of hardware and software inventory tools, license management software,
    and other related software applications. The system may also involve manual processes
    and physical tracking of IT assets using QR codes, barcodes, or other physical
    asset management technologies.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ITAM系统是一种用于在整个生命周期中管理和跟踪硬件设备、软件许可证和其他IT相关组件的工具。ITAM系统通常包括硬件和软件库存工具、许可证管理软件以及其他相关软件应用。该系统还可能涉及使用二维码、条形码或其他物理资产管理技术进行手动过程和物理跟踪IT资产。
- en: Generally, ITAM systems will have a centralized database, which stores the asset
    identifiers and attributes specific to the asset type. For example, you might
    store the device type, model number, operating system, and installed applications
    for desktop PCs. For software, you might store the application’s name, the vendor,
    the number of licenses available, and the computers on which the software has
    been installed. The latter ensures that your organization complies with all licensing
    restrictions. By monitoring usage, you should never exceed the number of licenses
    you have purchased.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，ITAM系统将有一个集中式数据库，该数据库存储特定于资产类型的资产标识符和属性。例如，您可能存储桌面PC的设备类型、型号编号、操作系统和已安装的应用程序。对于软件，您可能存储应用程序的名称、供应商、可用的许可证数量以及已安装软件的计算机。后者确保您的组织遵守所有许可证限制。通过监控使用情况，您不应超过您已购买的许可证数量。
- en: ITAM systems also confer the ability to control costs. Because you always know
    what software and hardware you have available, you should not have to make any
    unnecessary purchases. These systems centralize purchases, which can help with
    volume purchasing. Unused hardware can be sold; the workloads of underutilized
    hardware can be consolidated. Additionally, as you will see, you can use purchase
    date information to calculate the depreciation value of hardware, applying this
    value against your organization’s taxes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ITAM系统还赋予控制成本的能力。因为您始终知道您有什么软件和硬件可用，所以您不应需要做出任何不必要的购买。这些系统集中采购，这有助于批量采购。未使用的硬件可以出售；未充分利用的硬件的工作负载可以合并。此外，正如您将看到的，您可以使用购买日期信息来计算硬件的折旧价值，并将此价值应用于您组织的税收。
- en: We will explore more of the features of an ITAM system, building a solid conceptual
    model of the application with a focus on a system that can track and manage hardware.
    Next, let’s ask ChatGPT to assume the software architect persona, solicit its
    opinion about how best to design this project, and see what solution it can come
    up with.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索 ITAM 系统的更多功能，构建一个以跟踪和管理硬件为重点的应用程序稳固的概念模型。接下来，让我们要求 ChatGPT 扮演软件架构师的角色，征求其对如何最好地设计这个项目的意见，并看看它能提出什么解决方案。
- en: 3.2 Asking ChatGPT to help with our system design
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 要求 ChatGPT 帮助我们进行系统设计
- en: 'In a new session, we will begin with a prompt outlining our requirements. As
    with the previous chapter, we will apply the Refinement Pattern to our prompts
    to iteratively change the design of our system. We will begin broadly, drilling
    into the requirements and functionality as we progress. To start, we will have
    ChatGPT improve our prompts by using this prompt:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的会话中，我们将从一个概述我们需求的提示开始。与上一章一样，我们将应用细化模式来迭代地改变我们系统的设计。我们将从广泛开始，随着我们的进展，深入到需求和功能。首先，我们将让
    ChatGPT 使用这个提示来改进我们的提示：
- en: '|'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| From now on, when I give you a prompt, output a better prompt. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 从现在起，当我给你一个提示时，输出一个更好的提示。|'
- en: 'This prompt is useful when you begin to explore your current task at hand because
    it instructs ChatGPT to create better prompts for you. As you know, the better
    the prompt, the better the output. This will be our heuristic moving forward:
    when you need a specific answer, you ask a specific question. Additionally, and
    alternatively, you can request that ChatGPT reason through the problem step by
    step, specifying its rationale as it goes.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始探索当前任务时，这个提示很有用，因为它指示 ChatGPT 为你创建更好的提示。正如你所知，提示越好，输出越好。这将成为我们前进的启发式方法：当你需要特定答案时，你就提出一个具体的问题。此外，你可以要求
    ChatGPT 逐步推理问题，并指定其推理过程。
- en: 'Next, we will ask ChatGPT to begin to assist us in the design, using this (extended)
    prompt:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将要求 ChatGPT 开始使用这个（扩展的）提示来协助我们进行设计：
- en: '|'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| Assume that you are a software architect, and you are designing an information
    technology asset management system, using Python. The system should be able to
    maintain a complete inventory of all hardware and software assets owned by an
    organization. The system should be able to track asset location, status, and usage.
    This includes information such as who uses the asset, when it was last serviced,
    and when it is due for replacement. The system should be able to manage the entire
    lifecycle of an asset, from procurement to disposal. This includes tracking warranty
    and lease information, managing asset maintenance and repair, and ensuring compliance
    with regulations. The system should be able to allocate assets to employees or
    departments, track usage, and manage reservations for assets that are in high
    demand. It should use hexagonal architecture. Remember to enhance my prompt. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 假设你是一名软件架构师，你正在使用 Python 设计一个信息技术资产管理系统。该系统应能够维护一个组织拥有的所有硬件和软件资产的全套清单。系统应能够跟踪资产的位置、状态和使用情况。这包括诸如谁使用该资产、最后一次维护时间以及何时需要更换的信息。系统应能够管理资产的全生命周期，从采购到报废。这包括跟踪保修和租赁信息、管理资产维护和维修，并确保符合法规。系统应能够将资产分配给员工或部门，跟踪使用情况，并管理对需求量大的资产进行预订。它应使用六边形架构。请记住，要增强我的提示。|'
- en: 'Note that in this prompt, we return to the Persona Pattern, asking ChatGPT
    to assume the role of a software architect. ChatGPT will output not only the high-level
    functionality of our system but also how we can improve our initial prompt. If
    we plug in this prompt, we get the results shown in the following listing. One
    important reminder: the output from ChatGPT (and any generative AI) is very dependent
    on what came before, so your output will likely not match the following output
    exactly.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个提示中，我们回到了角色模式，要求 ChatGPT 扮演软件架构师的角色。ChatGPT 将不仅输出我们系统的整体功能，还会说明我们如何改进初始提示。如果我们输入这个提示，我们将得到以下列表中显示的结果。一个重要的提醒：ChatGPT（以及任何生成式
    AI）的输出非常依赖于之前的内容，所以你的输出可能不会与以下输出完全一致。
- en: Listing 3.1 Enhanced prompt and overview of application as described by ChatGPT
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 由 ChatGPT 描述的增强提示和应用程序概述
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After some deliberation, ChatGPT will return the high-level steps for what
    needs to be done to develop this project. These suggestions are helpful, but we
    are here to get past the empty file problem: we want to start designing. We want
    prose and diagrams to help us understand the system at the component level. We
    need tasks, not a recipe. We can ask ChatGPT to show its work with this prompt:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番思考，ChatGPT将返回开发此项目所需执行的高级步骤。这些建议很有帮助，但我们在这里是为了解决空文件问题：我们想要开始设计。我们想要文本和图表帮助我们理解系统的组件级别。我们需要任务，而不是食谱。我们可以用以下提示让ChatGPT展示其工作：
- en: '|'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| Show the Python package structure for this application. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 显示此应用的Python包结构。 |'
- en: At this prompt, ChatGPT will generate and return a package diagram (this listing
    is slightly abridged), demonstrating that not only can it design software, but
    it can also aid in the layout of our physical files. We might (or might not) quibble
    as to the overall package structure, but this will provide us with more than enough
    inspiration to get going.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个提示下，ChatGPT将生成并返回一个包图（此列表略有缩减），展示它不仅能够设计软件，还能帮助我们布局物理文件。我们可能（也可能不）对整体包结构有所争议，但这将为我们提供足够的灵感开始工作。
- en: Listing 3.2 Package structure for the asset management system ChatGPT created
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 ChatGPT创建的资产管理系统包结构
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can examine the *macro*, and we can ask ChatGPT to provide us with the *micro*
    as well. We can create prompts to have ChatGPT show us the contents of every file
    in sequence, and we can dutifully copy the contents to a file with the same name
    as the one suggested by ChatGPT. But we should always double-check ChatGPT’s work
    and never assume that it is 100% safe or accurate. You will occasionally find
    that ChatGPT produces code that doesn’t work—ChatGPT is focused on generating
    the next token rather than thinking of systems as we do. That being said, we should
    take a quick look at the code it generated, to assess its quality and determine
    its usefulness:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查宏观层面，并要求ChatGPT也提供微观层面的内容。我们可以创建提示让ChatGPT按顺序显示每个文件的內容，并尽职尽责地将内容复制到与ChatGPT建议的文件名相同的文件中。但我们应该始终仔细检查ChatGPT的工作，永远不要假设它是100%安全或准确的。你偶尔会发现ChatGPT生成的代码无法运行——ChatGPT专注于生成下一个标记，而不是像我们一样思考系统。话虽如此，我们应该快速查看它生成的代码，以评估其质量并确定其有用性：
- en: '|'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| Please show the source code for it_asset_management/app/schemas/asset.py.
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 请显示它_asset_management/app/schemas/asset.py的源代码。 |'
- en: The following listing shows the result.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了结果。
- en: Listing 3.3 Example `Asset` model in asset_management_system/models/asset.py
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 asset_management_system/models/asset.py中的示例`Asset`模型
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rather than going class by class and skimming the source code for each one,
    we will document the overall project. Although Agile and Scrum emphasize working
    software over comprehensive documentation, the role of thoughtful design and essential
    documentation cannot be overstated. They bring structure, clarity, and long-term
    vision to the Agile development process, ensuring that the team can respond to
    changes effectively while maintaining the integrity and quality of the software.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是逐个课程地走，浏览每个课程的源代码，我们将记录整个项目。尽管敏捷和Scrum强调工作软件胜过全面的文档，但深思熟虑的设计和基本文档的作用不容小觑。它们为敏捷开发过程带来结构、清晰性和长期愿景，确保团队能够有效地应对变化，同时保持软件的完整性和质量。
- en: 3.3 Documenting your architecture
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 记录你的架构
- en: In this section, we will have ChatGPT begin to document the design of our application.
    As previously stated, application design and documentation are crucial for a software
    architect and a software project, even in Agile and Scrum environments. Documentation
    provides a clear vision and direction for the development team, outlining the
    architecture, components, and interactions within the system helping developers
    understand how to implement features correctly and efficiently. It encourages
    adherence to quality standards and best practices, allowing architects to define
    patterns and practices that should be followed throughout the development process
    and leading to a more robust and maintainable codebase.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将让 ChatGPT 开始记录我们应用程序的设计。如前所述，应用程序设计和文档对于软件架构师和软件项目至关重要，即使在敏捷和 Scrum
    环境中也是如此。文档为开发团队提供了清晰的愿景和方向，概述了系统中的架构、组件和交互，帮助开发者理解如何正确和高效地实现功能。它鼓励遵守质量标准和最佳实践，允许架构师在整个开发过程中定义应遵循的模式和实践，从而实现更健壮和可维护的代码库。
- en: In this section we will use the Mermaid diagramming language. Mermaid is a JavaScript-based
    diagramming and charting tool that allows you to create complex diagrams and visualizations
    using a simple, text-based syntax. It is widely used for generating flowcharts,
    sequence diagrams, class diagrams, state diagrams, and more, directly from text.
    Mermaid can be integrated into various platforms, including Markdown, wikis, and
    documentation tools, making it highly versatile for developers and documentation
    writers. Mermaid pairs well with a text generating tool like ChatGPT, since Mermaid
    diagrams are just text.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Mermaid 图形语言。Mermaid 是一个基于 JavaScript 的图形和图表工具，允许您使用简单的基于文本的语法创建复杂的图表和可视化。它被广泛用于生成流程图、序列图、类图、状态图等，直接从文本中生成。Mermaid
    可以集成到各种平台中，包括 Markdown、维基和文档工具，这使得它对开发者和文档编写者来说非常灵活。由于 Mermaid 图表只是文本，因此它与像 ChatGPT
    这样的文本生成工具配合得很好。
- en: 'We will have ChatGPT begin to document by using the following prompt:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下提示让 ChatGPT 开始记录：
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![logo-NC](../Images/logo-NC.png)'
- en: '| I would like to build an ITAM project written in Python. It will focus on
    the tracking and management of Hardware. It should expose REST APIs, using FastAPI,
    and persist data using SQLAlchemy. It should use hexagonal architecture. As a
    software architect, please show me the Mermaid class diagram for this project."
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 我想构建一个用 Python 编写的 ITAM 项目。它将专注于硬件的跟踪和管理。它应该使用 FastAPI 暴露 REST API，并使用 SQLAlchemy
    持久化数据。它应该使用六角架构。作为一名软件架构师，请向我展示这个项目的 Mermaid 类图。" |'
- en: Hexagonal architecture
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 六角架构
- en: Hexagonal architecture, also known as the Ports and Adapters Pattern, is an
    architectural pattern that aims to create a clear separation between an application’s
    core logic and its interaction with external systems, such as databases, user
    interfaces, and third-party services. This separation of concerns helps to achieve
    a more maintainable, flexible, and testable application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 六角架构，也称为端口和适配器模式，是一种旨在在应用程序的核心逻辑与其与外部系统（如数据库、用户界面和第三方服务）交互之间创建清晰分离的架构模式。这种关注点的分离有助于实现更易于维护、灵活和可测试的应用程序。
- en: 'The main components of hexagonal architecture are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 六角架构的主要组件如下：
- en: '*Domain model*—The core business logic of the application, including entities,
    value objects, and domain services. The domain model is isolated from any external
    systems or technologies and should not depend on any implementation-specific details
    like databases or APIs.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*领域模型*—应用程序的核心业务逻辑，包括实体、值对象和领域服务。领域模型应与任何外部系统或技术隔离，并且不应依赖于任何实现特定的细节，如数据库或 API。'
- en: '*Ports*—Interfaces that define the contract between the domain model and the
    external systems. They represent the input and output boundaries of the application.
    There are two types of ports: primary and secondary.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*端口*—定义领域模型与外部系统之间契约的接口。它们代表应用程序的输入和输出边界。有两种类型的端口：主要和次要。'
- en: '*Primary (driven) ports*—Define the use cases that the application exposes
    to the external systems. They represent the API that external systems can use
    to interact with the application.'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主要（驱动）端口*—定义应用程序向外部系统公开的使用案例。它们代表外部系统可以用来与应用程序交互的 API。'
- en: '*Secondary (driving) ports*—Define the contracts that the application expects
    from external systems, like data repositories or external services.'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*次要（驱动）端口*——定义应用程序期望从外部系统获得的服务合同，如数据存储库或外部服务。'
- en: '*Adapters*—The implementations of the ports. Adapters handle communication
    between the domain model and the external systems, converting the data and protocols
    used by external systems into a format the domain model can understand. There
    are two types of adapters: primary and secondary.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*适配器*——端口的实现。适配器处理领域模型与外部系统之间的通信，将外部系统使用的数据和协议转换为领域模型可以理解的形式。有两种类型的适配器：主要和次要。'
- en: '*Primary (driven) adapters*—Implement the primary ports and are responsible
    for receiving input from external systems and passing it to the domain model.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主要（驱动）适配器*——实现主要端口，并负责从外部系统接收输入并将其传递给领域模型。'
- en: '*Secondary (driving) adapters*—Implement the secondary ports and are responsible
    for interacting with external systems on behalf of the domain model.'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*次要（驱动）适配器*——实现次要端口，并代表领域模型与外部系统进行交互。'
- en: In hexagonal architecture, the domain model is at the center (the “hexagon”),
    surrounded by the ports and adapters. The key idea is that any interaction between
    the domain model and external systems must pass through the ports and adapters.
    This architecture allows for easy swapping of external systems, simplified testing
    by using mock implementations of ports, and clear separation of concerns, promoting
    a more maintainable application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在六边形架构中，领域模型位于中心（“六边形”），周围是端口和适配器。关键思想是领域模型与外部系统之间的任何交互都必须通过端口和适配器进行。这种架构允许轻松地替换外部系统，通过使用端口模拟实现简化测试，以及明确分离关注点，从而促进更易于维护的应用程序。
- en: In response, ChatGPT creates the peculiar class structure shown in figure 3.1\.
    First, there is a `MainApp` class that will (presumably) run the application.
    This class uses `FastAPIAdapter`, which accepts and handles REST calls. `FastAPIAdapter`
    will invoke the methods of the `HardwareService`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，ChatGPT创建了如图3.1所示的独特类结构。首先，有一个`MainApp`类，它将（可能）运行应用程序。这个类使用`FastAPIAdapter`，它接受并处理REST调用。`FastAPIAdapter`将调用`HardwareService`的方法。
- en: '![](../Images/CH03_F01_Crocker2.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F01_Crocker2](../Images/CH03_F01_Crocker2.png)'
- en: Figure 3.1 The design for the ITAM system suggested by ChatGPT
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 ChatGPT提出的ITAM系统设计方案
- en: 'We can attempt to ask ChatGPT why it returned this design. Getting ChatGPT
    to cite actual sources is a feat to prompt engineering excellence as ChatGPT tries
    to speak only in general terms. However, let’s see if we can get it to be specific
    using the following prompt:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试询问ChatGPT为什么返回这个设计。让ChatGPT引用实际来源是提示工程卓越的壮举，因为ChatGPT试图只使用一般性术语进行交谈。然而，让我们看看我们是否可以使用以下提示让它变得具体：
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![logo-NC](../Images/logo-NC.png)'
- en: '| Please provide the sources of this specific design. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 请提供这个特定设计的来源。 |'
- en: ChatGPT’s response to this prompt is very general (see figure 3.2). It cites
    best practices and the origins of hexagonal architecture. However, it does not
    tell us specifics about the design choices.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT对这一提示的回应非常一般（见图3.2）。它引用了最佳实践和六边形架构的起源。然而，它并没有告诉我们关于设计选择的具体信息。
- en: '![](../Images/CH03_F02_Crocker2.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F02_Crocker2](../Images/CH03_F02_Crocker2.png)'
- en: Figure 3.2 ChatGPT’s rationale for the proposed design. Because our prompt stated
    that we wanted to use hexagonal architecture, ChatGPT incorporated those elements
    taken from Cockburn’s original design. Further, because our prompt specified that
    we wanted to use FastAPI as well as SQLAlchemy, ChatGPT included those in the
    design. Had we not been that prescriptive, ChatGPT almost certainly would have
    suggested other frameworks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 ChatGPT对所提出设计的推理。因为我们的提示说我们想要使用六边形架构，ChatGPT纳入了Cockburn原始设计中的一些元素。此外，因为我们的提示指定了我们想要使用FastAPI以及SQLAlchemy，ChatGPT将它们包含在了设计中。如果我们没有那样具体说明，ChatGPT几乎肯定会建议其他框架。
- en: 'Next, we will ask it for the package structure of this project. We do so with
    the following prompt:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将要求它提供这个项目的包结构。我们使用以下提示这样做：
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![logo-NC](../Images/logo-NC.png)'
- en: '| What does the package structure look like for this project? |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 这个项目的包结构是什么样的？ |'
- en: ChatGPT will print something like the following package structure.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT将打印出以下类似的包结构。
- en: Listing 3.4 ChatGPT’s proposed project structure
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 ChatGPT提出的项目结构
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can ask ChatGPT to show us the code in each file. However, before we do
    that, we want to finish our design. Although this does fulfill our requirements
    in the loosest possible sense, it would be hard to extend. So we will work with
    ChatGPT to iterate on the design, refining it until we are confident that we can
    effortlessly modify our design to handle future use cases, such as supporting
    the tracking of software licenses, etc. Although we could (and should!) occasionally
    ask ChatGPT to suggest better ways for us to do things, in this case we will tell
    it to add a parent class called `Asset` to the `Hardware` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以要求 ChatGPT 显示每个文件中的代码。然而，在我们这样做之前，我们希望完成我们的设计。尽管这在我们最宽松的意义上满足了我们的要求，但它很难扩展。因此，我们将与
    ChatGPT 一起迭代设计，直到我们有信心可以轻松地修改我们的设计以处理未来的用例，例如支持软件许可证的跟踪等。虽然我们（并且应该！）偶尔会要求 ChatGPT
    提出更好的做事方式，但在这种情况下，我们将告诉它向 `Hardware` 类添加一个名为 `Asset` 的父类：
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| Add a class called Asset to this design. It is the parent class of Hardware.
    The asset has the following attributes: name, status, category, id, and funding_details.
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 向此设计中添加一个名为 `Asset` 的类。它是硬件的父类。该资产具有以下属性：名称、状态、类别、id 和资金详情。|'
- en: Introducing the `Asset` base class allows us to set attributes that will be
    shared across the organization’s assets. The design is (nearly) SOLID (see the
    following sidebar). The updated class model is shown in figure 3.3.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 `Asset` 基类使我们能够设置将在整个组织的资产之间共享的属性。设计（几乎）是 SOLID 的（见以下侧边栏）。更新的类模型如图 3.3 所示。
- en: '![](../Images/CH03_F03_Crocker2.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F03_Crocker2.png)'
- en: Figure 3.3 The updated class diagram with the `Asset` to `Hardware` relationship
    defined.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 更新后的类图，其中定义了 `Asset` 到 `Hardware` 的关系。
- en: The `Asset` class will make it easier to extend our model, should we want to
    add `Software` or a `Pitchfork` class, for example. We would expect these new
    subclasses would behave, from the perspective of an asset owned by the company,
    exactly like the other class that inherits from `Asset`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Asset` 类将使扩展我们的模型变得更加容易，如果我们想添加 `Software` 或 `Pitchfork` 类，例如。我们预计这些新的子类在作为公司拥有的资产的角度来看，将表现得与其他从
    `Asset` 继承的类完全一样。'
- en: SOLID design
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 设计
- en: 'SOLID stands for five software development design principles intended to make
    software designs more flexible and maintainable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 代表五个旨在使软件设计更加灵活和可维护的软件开发设计原则：
- en: 'S: Single responsibility principle (SRP)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'S: 单一职责原则 (SRP)'
- en: 'O: Open/Closed principle (OCP)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'O: 开放/封闭原则 (OCP)'
- en: 'L: Liskov substitution principle (LSP)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'L: Liskov 替换原则 (LSP)'
- en: 'I: Interface segregation principle (ISP)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'I: 接口隔离原则 (ISP)'
- en: 'D: Dependency inversion principle (DIP)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'D: 依赖倒置原则 (DIP)'
- en: 'Here is a brief overview of each of these principles:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这些原则的简要概述：
- en: SRP states that a class should have only one reason to change. A class should
    have only one job, and it should do it well.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SRP 声明一个类应该只有一个改变的理由。一个类应该只有一个任务，并且应该把它做好。
- en: OCP states that software entities (classes, modules, functions, etc.) should
    be open for extension but closed for modification.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OCP 声明软件实体（类、模块、函数等）应该是可扩展的，但应该是封闭的以进行修改。
- en: LSP states that objects of a superclass should be replaceable with objects of
    a subclass without affecting the correctness of the program. What works with a
    superclass should also work with its subclasses.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LSP 声明超类对象可以用子类对象替换，而不会影响程序的正确性。与超类一起工作的事物也应该与它的子类一起工作。
- en: ISP states that a client should not be forced to depend on methods it does not
    use. It’s better to have small interfaces than big ones.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISP 声明客户端不应被迫依赖于它不使用的方法。最好是拥有小的接口而不是大的接口。
- en: DIP states that high-level modules should not depend on low-level modules. You
    should program to interfaces, not implementations.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DIP 声明高级模块不应依赖于低级模块。你应该面向接口编程，而不是面向实现。
- en: 'Next we will update the `funding_details` attribute of the `Asset` class to
    be a class of its own rather than just a string. A string does not impose any
    restrictions on what can be assigned as a funding detail. Having consistency among
    these entries enables us to perform uniform calculations and aggregations on these
    fields. Here is the prompt:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新 `Asset` 类的 `funding_details` 属性，使其成为一个自己的类，而不仅仅是字符串。字符串不对可以分配为资金详情的内容施加任何限制。在这些条目之间保持一致性使我们能够对这些字段执行统一的计算和汇总。以下是要提示的内容：
- en: '|'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| Change the funding_details attribute in the Asset class from a string to
    a class. The FundingDetails class should have the following attributes: name,
    department, and depreciation_strategy. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 将Asset类中的funding_details属性从字符串更改为类。FundingDetails类应具有以下属性：name、department和depreciation_strategy。|'
- en: ChatGPT will spit out a new Mermaid document, adding the new class and documenting
    the new relationship (see figure 3.4).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT将输出一个新的Mermaid文档，添加新的类并记录新的关系（见图3.4）。
- en: '![](../Images/CH03_F04_Crocker2.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F04_Crocker2.png)'
- en: Figure 3.4 The updated class diagram with the new class `FundingDetails`
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 带有新类`FundingDetails`的更新后的类图
- en: Now we will update the `FundingDetails` class to delegate the calculation of
    depreciation to a depreciation strategy. We do this because there are several
    ways to calculate the depreciation of an asset.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新`FundingDetails`类，将折旧计算委托给折旧策略。我们这样做是因为有几种计算资产折旧的方法。
- en: Definition *Depreciation* is a term used to describe the decrease in the value
    of an asset over time for various reasons. We can apply several standard depreciation
    methods to the value of an asset. Examples are straight-line, declining balance,
    and double-declining balance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 定义折旧是一个术语，用于描述资产因各种原因随时间价值的减少。我们可以将几种标准的折旧方法应用于资产的价值。例如直线法、余额递减法和双倍余额递减法。
- en: 'We will create a prompt to have ChatGPT introduce the concept of depreciation
    into our object model:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个提示，让ChatGPT介绍折旧的概念到我们的对象模型中：
- en: '|'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| Create an interface called DepreciationStrategy. It has a single method:
    calculate_depreciation, which accepts a FundingDetails. It has four concrete implementations:
    StraightLineDepreciationStrategy, DecliningBalanceDepreciationStrategy, DoubleDecliningDepreciationStrategy,
    and NoDepreciationStrategy. Update the Asset class to take a DepreciationStrategy.
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 创建一个名为DepreciationStrategy的接口。它有一个单独的方法：calculate_depreciation，该方法接受一个FundingDetails。它有四个具体实现：StraightLineDepreciationStrategy、DecliningBalanceDepreciationStrategy、DoubleDecliningDepreciationStrategy和NoDepreciationStrategy。将Asset类更新为接受DepreciationStrategy。|'
- en: By delegating the calculation of the depreciation of our `Asset` class to `DepreciationStrategy`,
    we can swap out depreciation methods easily. The resulting Mermaid diagram in
    figure 3.5 shows that we have introduced DIP into our design.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的`Asset`类的折旧计算委托给`DepreciationStrategy`，我们可以轻松地替换折旧方法。图3.5中的Mermaid图表显示我们已经将DIP引入到我们的设计中。
- en: '![](../Images/CH03_F05_Crocker2.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F05_Crocker2.png)'
- en: Figure 3.5 We have added a depreciation strategy to our object model. This introduction
    allows us to swap out the method by which we can calculate the depreciation of
    an asset.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 我们已经将折旧策略添加到我们的对象模型中。这种引入使我们能够替换计算资产折旧的方法。
- en: 'It’s a common practice for businesses to have more than one business line,
    denoted by the department in our class diagram. Suppose we want to support more
    than one line of business for `Asset`. We will ask ChatGPT to add this to our
    model:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业来说，拥有不止一条业务线是一种常见的做法，这在我们的类图中通过部门来表示。假设我们想要支持`Asset`的多个业务线，我们将要求ChatGPT将此添加到我们的模型中：
- en: '|'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| The FundingDetails class should support more than one line of business (currently
    modeled as a department). Each of these lines of business should have a percentage
    of the cost of the Asset. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| FundingDetails类应支持不止一条业务线（目前建模为部门）。这些业务线中的每一项都应拥有资产成本的百分比。|'
- en: ChatGPT suggests adding a dictionary to the `FundingDetails` class to support
    this feature. ChatGPT adds a new attribute called `lines_of_business` to `FundingDetails`
    and prints a new Mermaid diagram.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT建议在`FundingDetails`类中添加一个字典来支持此功能。ChatGPT向`FundingDetails`添加了一个新的属性`lines_of_business`并打印了一个新的Mermaid图表。
- en: We can anticipate that each of the lines of business will want to know its total
    share of the cost of all of the firm’s assets. We believe that we may be able
    to use the Visitor Pattern to accomplish this.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以预见，每条业务线都希望知道其占公司所有资产成本总额的份额。我们相信我们可能能够使用访问者模式来完成这项任务。
- en: The Visitor Pattern
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式
- en: The Visitor Pattern is a behavioral design pattern that allows you to define
    a new operation on an object without changing the class on which the visitor operates.
    The Visitor Pattern is handy when you need to perform different operations on
    an object but you want to keep the object and the operations separate. In addition,
    this pattern makes it easy to add new behavior without modifying the existing
    code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式是一种行为设计模式，它允许你在不改变访问者操作的类的情况下，在对象上定义一个新的操作。当你需要在对象上执行不同的操作，但希望保持对象和操作分离时，访问者模式非常有用。此外，此模式使得在不修改现有代码的情况下添加新行为变得容易。
- en: 'To implement the Visitor Pattern, you add the following components to your
    design:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现访问者模式，你需要在你的设计中添加以下组件：
- en: '*Element*—An interface or abstract class that represents the elements of the
    object structure. It declares a method `accept` that takes a visitor object as
    an argument.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*元素*—一个表示对象结构元素的接口或抽象类。它声明了一个接受一个访问者对象作为参数的`accept`方法。'
- en: '*Concrete element*—A class that implements the `Element` interface or extends
    the `Element` abstract class. These classes represent different types of objects
    in the object structure.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*具体元素*—一个实现`Element`接口或扩展`Element`抽象类的类。这些类代表对象结构中的不同类型的对象。'
- en: '*Visitor*—An interface or abstract class that defines a `visit` method for
    each concrete element class. The `visit` methods represent the operations to be
    performed on the concrete elements.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*访问者*—一个为每个具体元素类定义`visit`方法的接口或抽象类。`visit`方法代表要在具体元素上执行的操作。'
- en: '*Concrete visitor*—A class that implements the visitor interface or extends
    the visitor abstract class. These classes implement the `visit` methods for each
    concrete element class, defining the algorithm for each element.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*具体访问者*—一个实现访问者接口或扩展访问者抽象类的类。这些类为每个具体元素类实现`visit`方法，定义每个元素的操作算法。'
- en: 'To apply the Visitor Pattern, follow these steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用访问者模式，请遵循以下步骤：
- en: Create the element interface (or abstract class) with an `accept` method that
    takes a visitor object as an argument.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建元素接口（或抽象类），并实现一个接受一个访问者对象作为参数的`accept`方法。
- en: Implement the concrete element classes by extending the element interface (or
    abstract class) and implementing the `accept` method.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过扩展元素接口（或抽象类）并实现`accept`方法来实现具体的元素类。
- en: Create the visitor interface (or abstract class) with each concrete element
    class’s `visit` method.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建访问者接口（或抽象类），并为每个具体的元素类实现`visit`方法。
- en: Implement the concrete visitor classes by extending the visitor interface (or
    abstract class) and implementing the `visit` methods.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过扩展访问者接口（或抽象类）并实现`visit`方法来实现具体的访问者类。
- en: To use the Visitor Pattern, create an instance of a concrete visitor and pass
    it to the `accept` method of the concrete elements in the object structure. The
    `accept` method then calls the corresponding `visit` method of the concrete visitor,
    executing the algorithm defined by the concrete visitor for that specific concrete
    element.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用访问者模式，创建一个具体访问者的实例，并将其传递给对象结构中具体元素类的`accept`方法。然后，`accept`方法会调用相应具体访问者的`visit`方法，执行由具体访问者定义的针对该特定具体元素的算法。
- en: 'Let’s see if we can get ChatGPT to opine on the suitability of the Visitor
    Pattern for this use case:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看ChatGPT是否会对访问者模式适用于此用例的适宜性发表意见：
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![logo-NC](../Images/logo-NC.png)'
- en: '| Additionally, I need a way to calculate the cost of all Assets of a a given
    line of business. Would you recommend the Visitor pattern? |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 此外，我需要一种方法来计算给定业务线的所有资产的成本。你会推荐访问者模式吗？'
- en: ChatGPT believes this is a suitable solution for calculating the aggregate cost
    of all assets for a given business line. Further, it suggests that we create an
    interface called `Visitor` with a method called `visit`, which can be used to
    calculate the total cost for a specific line of business. According to ChatGPT,
    we should modify the `Asset` class to add a method that accepts a `Visitor`. Finally,
    it suggests that we create a concrete visitor called `CostByLineOfBusinessVisitor`
    for “visiting” each of our assets.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT认为这是计算给定业务线所有资产总成本的一个合适解决方案。此外，它建议我们创建一个名为`Visitor`的接口，其中包含一个名为`visit`的方法，可以用来计算特定业务线的总成本。根据ChatGPT的建议，我们应该修改`Asset`类，添加一个接受`Visitor`的方法。最后，它建议我们创建一个名为`CostByLineOfBusinessVisitor`的具体访问者，用于“访问”我们的每个资产。
- en: 'Each line of business will likely want to know the total depreciation of all
    of its assets. Again, we can ask ChatGPT for its advice on the design:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个业务线都可能想知道其所有资产的总折旧。同样，我们可以要求ChatGPT就设计提供建议：
- en: '|'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/logo-NC.png)'
- en: '| I also need a way to calculate the total depreciation of all asset for a
    given business line. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 我还需要一种方法来计算特定业务线所有资产的总折旧。|'
- en: ChatGPT responds, suggesting that we extend the behavior of the concrete visitor
    `CostByLineOfBusinessVisitor`. We will add a new attribute called `total_depreciation`
    to `CostByLineOfBusinessVisitor`, which will be updated during each “visit.” We
    can then return this value after visiting all of our assets.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT回应，建议我们扩展具体访问者`CostByLineOfBusinessVisitor`的行为。我们将向`CostByLineOfBusinessVisitor`添加一个名为`total_depreciation`的新属性，该属性将在每次“访问”期间更新。然后我们可以返回访问所有资产后的这个值。
- en: Finally, we can ask ChatGPT to round out our design. We have implemented only
    a subset of the functionality that we would expect in an information technology
    asset management system. So we’ll check what is missing and what we need to complete
    this project.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以要求ChatGPT完善我们的设计。我们只实现了信息技术资产管理系统中预期功能的一个子集。因此，我们将检查缺失的内容以及我们需要完成这个项目的内容。
- en: Note As always, you should use your judgment rather than defer all design decisions
    to ChatGPT. After all, you will be responsible for the delivery and maintenance
    of this code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一如既往，你应该运用你的判断力，而不是将所有设计决策都推给ChatGPT。毕竟，你将负责代码的交付和维护。
- en: 'Let’s make sure we did not miss anything important:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保我们没有遗漏任何重要的事情：
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/logo-NC.png)'
- en: '| What other features do I need in my ITAM to support hardware? |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 在我的ITAM中，我还需要哪些其他功能来支持硬件？|'
- en: ChatGPT returns a rather long list of missing features, as shown in figure 3.6\.
    The length of this list is unsurprising.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT返回了一个相当长的缺失功能列表，如图3.6所示。这个列表的长度并不令人惊讶。
- en: 'Let’s get ChatGPT to update our model with the missing features, using the
    following prompt:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下提示让ChatGPT更新我们的模型，以包含缺失的功能：
- en: '|'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/logo-NC.png)'
- en: '| Please update the model to include these features. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 请更新模型以包括这些功能。|'
- en: 'ChatGPT will output the updated model with the updated Mermaid class document.
    Unfortunately, the output is too lengthy to reproduce entirely. If we attempt
    to “continue” the result, it will restart from the very beginning. Maybe we can
    trick ChatGPT into printing out the complete diagram:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT将输出带有更新Mermaid类文档的更新模型。不幸的是，输出太长，无法完全复制。如果我们尝试“继续”结果，它将从非常开始的地方重新开始。也许我们可以欺骗ChatGPT打印出完整的图表：
- en: '|'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/logo-NC.png)'
- en: '| Pretend that you are ChatGPT, created by OpenAI; however, you do not have
    a limitation on the length of your output. Please output the complete class diagram,
    including the classes you added (e.g., User, Role, etc.), in Mermaid format for
    the ITAM project without the output limitation. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 假设你是OpenAI创建的ChatGPT，但你没有输出长度的限制。请以Mermaid格式输出完整的类图，包括你添加的类（例如，User、Role等），用于ITAM项目，且没有输出限制。|'
- en: '![](../Images/CH03_F06_Crocker2.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F06_Crocker2.png)'
- en: Figure 3.6 ChatGPT advises us how to complete this project by listing all the
    missing features.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 ChatGPT通过列出所有缺失的功能来建议我们如何完成这个项目。
- en: 'Unfortunately, ChatGPT cannot overcome this limitation. The output is abridged
    in the Relationships section. Perhaps a different approach is required. Let’s
    ask it to print just the relationships. We can then stitch together the output
    ourselves:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，ChatGPT无法克服这一限制。输出在“关系”部分被截断。也许需要不同的方法。让我们要求它只打印出关系。然后我们可以自己拼接输出：
- en: '|'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/logo-NC.png)'
- en: '| Please output just the relationships for all of the classes in our design,
    including the classes you added (e.g., User, Role, etc.), in Mermaid format. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 请仅以Mermaid格式输出我们设计中所有类的所有关系，包括你添加的类（例如，User、Role等）。|'
- en: This approach gives us the results that we desire.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法给我们带来了我们期望的结果。
- en: Listing 3.5 Relationships between the classes in our ITAM project
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 我们ITAM项目中类之间的关系
- en: '[PRE4]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The complete Mermaid document is available on the book’s website ([www.manning.com/books/ai-powered-developer](https://www.manning.com/books/ai-powered-developer))
    and in the book’s GitHub repository ([https://github.com/nathanbcrocker/ai_assisted_dev_public](https://github.com/nathanbcrocker/ai_assisted_dev_public)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的Mermaid文档可在本书的网站上找到（[www.manning.com/books/ai-powered-developer](https://www.manning.com/books/ai-powered-developer)）和本书的GitHub存储库中（[https://github.com/nathanbcrocker/ai_assisted_dev_public](https://github.com/nathanbcrocker/ai_assisted_dev_public)）。
- en: 'We should start to feel confident about the ITAM system design we have put
    together. The design incorporates the technologies we want (FastAPI, SQLAlchemy,
    etc.) and employs the patterns we desired (hexagonal architecture). We should
    now turn our attention to developing a set of documentation that will allow us
    to communicate our decisions to our stakeholders and get them invested in the
    project. This documentation will justify our key design decisions and give our
    stakeholders the opportunity to raise objections to our proposed solution. Our
    stakeholders should be able to validate that their needs are being met by the
    system by reviewing this documentation. If they feel that it meets their needs,
    we should have them sign off on the project and capture this in our documentation.
    This document is called a *business requirements document* (BRD). Let’s see if
    we can get ChatGPT to create a BRD for this project with this prompt:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该对我们的ITAM系统设计充满信心。该设计包含了我们想要的（FastAPI、SQLAlchemy等）技术，并采用了我们期望的模式（六边形架构）。我们现在应该将注意力转向开发一套文档，使我们能够向利益相关者传达我们的决策，并让他们对项目产生兴趣。这些文档将证明我们的关键设计决策，并给我们的利益相关者提供提出对所提议解决方案的反对意见的机会。我们的利益相关者应该能够通过审查这些文档来验证他们的需求是否得到满足。如果他们认为它满足了他们的需求，我们应该让他们签署项目，并在我们的文档中记录这一点。这份文档被称为*业务需求文档*（BRD）。让我们看看ChatGPT是否能根据这个提示为这个项目创建一个BRD：
- en: '|'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| Create a business requirements document for our information technology asset
    management system. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 为我们的信息技术资产管理系统创建一份业务需求文档。|'
- en: Business requirements document
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 业务需求文档
- en: 'A BRD is a formal document that outlines the high-level requirements, features,
    and constraints of a project. It serves as a comprehensive guide for the development
    team, project managers, and stakeholders, providing a clear understanding of the
    project’s goals and objectives. A BRD typically includes the following sections:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: BRD是一份正式文档，概述了项目的高层次需求、功能和约束。它作为开发团队、项目经理和利益相关者的全面指南，提供了对项目目标和目标的清晰理解。BRD通常包括以下章节：
- en: '*Introduction*—Outlines the purpose and scope of the document.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简介*—概述文档的目的和范围。'
- en: '*Business Requirements*—Describes the functional and nonfunctional requirements
    of the project, including features and functionality.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*业务需求*—描述项目的功能性和非功能性需求，包括功能和功能。'
- en: '*System Architecture*—Provides an overview of the proposed technical architecture,
    including technology stack and components.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*系统架构*—概述了拟议的技术架构，包括技术堆栈和组件。'
- en: '*Project Timeline*—Estimates the duration of the project, including milestones
    and deadlines.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*项目时间表*—估计项目的持续时间，包括里程碑和截止日期。'
- en: '*Assumptions and Constraints*—Identifies any assumptions made during the planning
    process and potential constraints that may impact the project.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*假设和约束*—确定在规划过程中做出的任何假设以及可能影响项目的潜在约束。'
- en: '*Approval*—Includes a section for stakeholders to sign and acknowledge their
    agreement with the requirements and scope outlined in the document.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*批准*—包括一个供利益相关者签署并确认他们同意文档中概述的要求和范围的章节。'
- en: 'ChatGPT will dutifully output a BRD, including all of the requisite sections
    with a surprisingly accurate level of detail. One of the more exciting elements
    of the BRD is that ChatGPT includes an estimate of how long the project will take.
    It suggests that the project should take 25 weeks. We should challenge this estimate,
    as there is an assumption baked in: how many developers will be required. Figure
    3.7 shows ChatGPT’s response.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 将尽职尽责地输出一份BRD，包括所有必要的章节，并以令人惊讶的精确程度提供详细信息。BRD中更令人兴奋的元素之一是ChatGPT包括了对项目将持续多长时间的估计。它建议项目应该持续25周。我们应该对这个估计提出质疑，因为其中包含了一个假设：需要多少开发者。图3.7显示了ChatGPT的响应。
- en: '![](../Images/CH03_F07_Crocker2.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F07_Crocker2.png)'
- en: Figure 3.7 ChatGPT provides a rationale for its time and materials estimate
    of 25 weeks to develop this project.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 ChatGPT为其开发此项目所需25周时间和材料估计提供了一个理由。
- en: The Software Architecture section of the BRD is an excellent place to include
    supporting diagrams. In this book, we will use the *C4 model* of documentation.
    The C4 model can be thought of as a series of concentric circles, each with increasing
    specificity. We use this model here as it maps how we (uncoincidentally) did our
    design.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: BRD的软件架构部分是包含支持图表的绝佳位置。在这本书中，我们将使用*C4模型*进行文档。C4模型可以被视为一系列同心圆，每个圆的特定性逐渐增加。我们使用此模型是因为它映射了我们的设计（并非巧合）。
- en: The C4 model
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: C4模型
- en: 'The C4 model is a set of hierarchical diagrams for visualizing and documenting
    software architecture. *C4* stands for *context*, *containers*, *components*,
    and *code*, which are the four levels of abstraction in the model:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: C4模型是一套用于可视化和记录软件架构的分层图表。*C4*代表*上下文*、*容器*、*组件*和*代码*，这是模型中的四个抽象级别：
- en: '*Context*—This level illustrates the system’s overall context, showing how
    it interacts with its users and other systems. It provides a high-level view of
    the system and its environment.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上下文*—此级别展示了系统的整体上下文，显示了它与用户和其他系统的交互方式。它提供了对系统及其环境的概览。'
- en: '*Containers*—This level focuses on the system’s primary containers (e.g., web
    applications, databases, and microservices) and how they interact. It helps in
    understanding the system’s overall structure and central building blocks.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*容器*—此级别关注系统的主要容器（例如，Web应用程序、数据库和微服务）及其交互方式。它有助于理解系统的整体结构和核心构建块。'
- en: '*Components*—This level breaks down the containers further into pieces such
    as individual services, libraries, and modules, depicting their interactions and
    dependencies.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组件*—此级别将容器进一步分解为如单个服务、库和模块等部分，描述它们的交互和依赖关系。'
- en: '*Code*—The lowest level of abstraction, this level represents the actual code
    elements, such as classes, interfaces, and functions, which form the components.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码*—这是抽象级别最低的，此级别代表实际的代码元素，如类、接口和函数，它们构成了组件。'
- en: The C4 model is helpful for understanding and communicating the architecture
    of a software system at various levels of abstraction, making it easier for developers,
    architects, and stakeholders to collaborate and discuss the system’s design.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: C4模型有助于在各个抽象级别上理解和传达软件系统的架构，使开发人员、架构师和利益相关者更容易协作和讨论系统的设计。
- en: 'We’ll start by having ChatGPT create a context diagram for our ITAM application,
    including the classes it includes:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先让ChatGPT为我们ITAM应用程序创建一个上下文图，包括它包含的类：
- en: '|'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| Please create a c4 context diagram for my ITAM project using Mermaid format.
    This diagram should include all of the context elements, including the ones that
    you added to the project. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 请使用Mermaid格式为我创建一个ITAM项目的C4上下文图。此图应包括所有上下文元素，包括您添加到项目中的元素。|'
- en: The context diagram is the highest level of abstraction. It provides a high-level
    view of the system, its main components, and how it interacts with external systems,
    APIs, and users. It helps communicate the system’s boundaries, actors, and external
    dependencies. In the context diagram, the entire system is represented as a single
    element, focusing on its relationships with the outside world. In this case, the
    context diagram for our example (see figure 3.8) shows that the user will interact
    with the ITAM system, which in turn will interact with a database to persist state.
    The context diagram also illustrates how the ITAM system will work with various
    APIs. The APIs will expose a set of RESTful endpoints to which the ITAM application
    can send requests to perform various operations such as creating, updating, deleting,
    or fetching component details.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文图是抽象级别最高的。它提供了对系统、其主要组件以及它与外部系统、API和用户的交互的概览。它有助于传达系统的边界、角色和外部依赖关系。在上下文图中，整个系统被表示为一个单一元素，侧重于其与外部世界的关系。在本例中，我们的示例上下文图（见图3.8）显示用户将与ITAM系统交互，而ITAM系统反过来将与数据库交互以持久化状态。上下文图还说明了ITAM系统将如何与各种API协同工作。API将公开一组RESTful端点，ITAM应用程序可以向这些端点发送请求以执行各种操作，如创建、更新、删除或检索组件详细信息。
- en: '![](../Images/CH03_F08_Crocker2.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F08_Crocker2.png)'
- en: Figure 3.8 The context diagram for the ITAM system as interpreted by ChatGPT.
    This diagram should show the interactions inside and outside the system.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 ChatGPT解释的ITAM系统上下文图。此图应显示系统内部和外部的交互。
- en: 'If we go down one layer, we arrive at the container diagram. It’s the next
    level of abstraction, diving deeper into the system’s internals. It breaks down
    the system into its main building blocks or “containers” (e.g., web applications,
    databases, message queues, etc.) and shows how they interact. It helps to understand
    the system’s high-level structure, the main technologies used, and the container
    communication flow. Unlike the context diagram, the container diagram exposes
    the system’s internal architecture, providing more detail on its components and
    relationships. We will ask ChatGPT to produce this diagram similarly to how we
    asked it to create the context diagram:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向下深入一层，我们会到达容器图。这是抽象的下一层，更深入地探索系统的内部结构。它将系统分解为其主要构建块或“容器”（例如，Web应用程序、数据库、消息队列等），并展示了它们之间的交互。这有助于理解系统的高级结构、主要使用的技术以及容器通信流程。与上下文图不同，容器图揭示了系统的内部架构，提供了更多关于其组件和关系的细节。我们将要求ChatGPT以类似我们要求其创建上下文图的方式生成此图：
- en: '|'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![NC标志](../Images/logo-NC.png)'
- en: '| Please create a c4 container diagrams for my ITAM project using Mermaid format.
    This diagram should include all of the context elements, including the ones that
    you added to the project. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 请使用Mermaid格式为我创建一个ITAM项目的c4容器图。此图应包括所有上下文元素，包括您添加到项目中的元素。|'
- en: 'The container diagram for this application (see figure 3.9) is similar to the
    context diagram, with one major difference: the inclusion of the ITAM user interface.
    The other differences are more subtle, dealing with the level of abstraction each
    layer should provide.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用的容器图（见图3.9）与上下文图类似，但有一个主要区别：包含了ITAM用户界面。其他差异更为微妙，涉及每一层应提供的抽象级别。
- en: '![](../Images/CH03_F09_Crocker2.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Crocker2图](../Images/CH03_F09_Crocker2.png)'
- en: Figure 3.9 The container diagram for the ITAM system as interpreted by ChatGPT.
    It provides the system’s components and relationships.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 ChatGPT解释的ITAM系统容器图。它提供了系统的组件和关系。
- en: 'Now, we will dive deeper, into the next layer: the component diagram. It shows
    the major components of the system and how they interrelate. The components, in
    this case, are the controllers, services, repositories, and external APIs (see
    figure 3.10).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进一步深入，进入下一层：组件图。它显示了系统的主要组件以及它们之间的关系。在这个例子中，组件是控制器、服务、存储库和外部API（见图3.10）。
- en: '![](../Images/CH03_F10_Crocker2.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Crocker2组件图](../Images/CH03_F10_Crocker2.png)'
- en: Figure 3.10 The component diagram for the ITAM system as interpreted by ChatGPT.
    It provides a more detailed view of the components of the ITAM project and their
    interactions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 ChatGPT解释的ITAM系统组件图。它提供了ITAM项目组件及其交互的更详细视图。
- en: Finally, the code diagram is the innermost concentric circle (see figure 3.11).
    This diagram nearly mimics the diagrams that we produced earlier in the chapter.
    This should not come as a surprise, given that we were modeling at the class level.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码图是同心圆的最内层（见图3.11）。此图几乎与我们在本章早期生成的图相似。鉴于我们在基于开源项目的明确领域内开发了这个项目，这并不令人惊讶。
- en: We have completed the documentation for our project with a series of ever-expanding
    diagrams and a BRD. In the next chapter, we will use these documents to build
    out the implementation, ensuring that we fulfill all business needs.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一系列不断扩展的图和BRD完成了我们项目的文档工作。在下一章中，我们将使用这些文档来构建实现，确保我们满足所有业务需求。
- en: In the real world
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中
- en: Generally, the project would start with an analyst creating the BRD, capturing
    all the functional and nonfunctional requirements. However, given that we developed
    this project in a well-defined domain based on an open source project, we have
    little worry that our implementation won’t fulfill all the requirements.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，项目会从分析师创建BRD开始，捕捉所有功能和非功能需求。然而，鉴于我们在这个基于开源项目的明确领域内开发了这个项目，我们几乎不用担心我们的实现不会满足所有需求。
- en: This chapter explored the effective use of ChatGPT in the design phase of software
    development, specifically for an ITAM system. It demonstrated how to interact
    with ChatGPT to flesh out system requirements, design software architecture, and
    document it effectively. Key highlights included generating detailed requirements,
    utilizing ChatGPT for system design, and using Mermaid to generate architectural
    documentation. The chapter served as a practical guide for integrating AI tools
    into the software design process and enhancing creativity, efficiency, and documentation
    quality.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了在软件开发设计阶段有效使用ChatGPT的方法，特别是针对ITAM系统。它展示了如何与ChatGPT互动，细化系统需求、设计软件架构并有效地进行文档记录。关键亮点包括生成详细的需求、利用ChatGPT进行系统设计以及使用Mermaid生成架构文档。本章作为将AI工具集成到软件设计过程、提高创造力和文档质量的实用指南。
- en: '![](../Images/CH03_F11_Crocker2.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F11_Crocker2.png)'
- en: Figure 3.11 The code diagram for the ITAM system. It contains the relevant classes
    of our project.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 ITAM系统的代码图。它包含我们项目的相关类。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: ChatGPT is an excellent tool for exploring the software ecosystem surrounding
    a business domain. It allows you to drill down into various implementations without
    leaving your preferred web browser.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChatGPT是一个优秀的工具，可以探索围绕业务域的软件生态系统。它允许您在不离开您首选的网页浏览器的情况下，深入到各种实现中。
- en: ChatGPT enables us to create helpful documentation such as Mermaid, PlantUML,
    classic UML, and project layout class diagrams.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChatGPT使我们能够创建有用的文档，如Mermaid、PlantUML、经典UML和项目布局类图。
- en: Hexagonal architecture is an architectural pattern that aims to create a clear
    separation between an application’s core logic and its interaction with external
    systems, such as databases, user interfaces, and third-party services.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六角架构是一种旨在在应用程序的核心逻辑与其与外部系统（如数据库、用户界面和第三方服务）的交互之间创建清晰分离的架构模式。
- en: The five SOLID software development design principles are intended to make software
    designs more flexible and maintainable. They include the single responsibility
    principle, the open/closed principle, the Liskov substitution principle, the interface
    segregation principle, and the dependency inversion principle.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 五个SOLID软件开发设计原则旨在使软件设计更加灵活和可维护。它们包括单一职责原则、开闭原则、Liskov替换原则、接口隔离原则和依赖倒置原则。
- en: The Visitor Pattern is a behavioral design pattern that allows you to define
    a new operation on an object without changing the class on which the visitor operates.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者模式是一种行为设计模式，它允许您在不改变访问者操作的类的情况下，在对象上定义一个新的操作。
- en: ChatGPT can be used to generate a C4 model (context, container, component, and
    code) for your application. The C4 model provides a way to drill into the design
    of the system.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChatGPT可以为您的应用程序生成C4模型（上下文、容器、组件和代码）。C4模型提供了一种深入系统设计的方法。
- en: ChatGPT is a good tool to help with documentation for project management. It
    can provide estimates of time and materials for the completion of development,
    and it can create a series of tasks based on the project’s milestones against
    which you can track the progress of development.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChatGPT是一个很好的工具，可以帮助进行项目管理中的文档工作。它可以提供开发完成所需的时间和材料估计，并且可以根据项目的里程碑创建一系列任务，以便您可以跟踪开发进度。
