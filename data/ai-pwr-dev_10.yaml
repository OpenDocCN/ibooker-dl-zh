- en: 7 Coding infrastructure and managing deployments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 编码基础设施和管理部署
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating a Dockerfile with the assistance of Copilot
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Copilot 的帮助下创建 Dockerfile
- en: Drafting your infrastructure as code using large language models
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用大型语言模型起草基础设施代码
- en: Managing Docker images with a container registry
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器注册库管理 Docker 镜像
- en: Harnessing the power of Kubernetes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Kubernetes 的力量
- en: Releasing your code effortlessly using GitHub Actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 无缝发布您的代码
- en: There is nothing more demoralizing than having an application sit unused. For
    this reason, fast-tracking a well-tested application to production is the stated
    goal of every competent developer. Because we spent the last chapter testing our
    product, it is now ready for launch.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比一个应用程序闲置不用更令人沮丧的了。因此，快速将经过良好测试的应用程序推向生产是每个合格开发者的目标声明。因为我们已经在上一章测试了我们的产品，所以它现在可以准备发布了。
- en: This chapter will focus on that pivotal moment of transitioning from development
    to product launch. During this critical phase, understanding deployment strategies
    and best practices becomes essential to ensure a successful product launch.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点关注从开发到产品发布的那个关键时刻。在这个关键阶段，理解部署策略和最佳实践变得至关重要，以确保产品发布成功。
- en: With our application successfully secured and tested, it’s time to shift our
    attention toward launching the product. To this end, we will use the powerful
    capabilities of large language models (LLMs) to explore various deployment options
    tailored to cloud infrastructure.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序成功得到保护和测试后，是时候将我们的注意力转向产品的发布了。为此，我们将利用大型语言模型（LLMs）强大的功能来探索针对云基础设施的定制部署选项。
- en: By harnessing the power of LLMs and embracing their deployment options and methodologies,
    we can confidently navigate the complex landscape of launching our product, delivering
    a robust and scalable solution to our customers while using the benefits of cloud
    computing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用大型语言模型（LLMs）的力量并接受它们的部署选项和方法，我们可以自信地穿梭于启动产品的复杂领域，向客户交付一个强大且可扩展的解决方案，同时利用云计算的好处。
- en: First, we will develop deployment files for Docker. We will explore how to create
    Docker images and define deployment files. Additionally, we will discuss best
    practices for containerizing our application and achieving seamless deployment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将开发 Docker 的部署文件。我们将探讨如何创建 Docker 镜像并定义部署文件。此外，我们还将讨论容器化我们的应用程序和实现无缝部署的最佳实践。
- en: Next, we will use Terraform to define our infrastructure as code and automate
    the deployment of Elastic Compute Cloud (EC2) instances on Amazon Web Services
    (AWS). We will demonstrate how to write Terraform scripts to provision and deploy
    our application on EC2 instances, ensuring consistent and reproducible infrastructure
    setups.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 Terraform 来定义我们的基础设施代码，并自动化在亚马逊网络服务（AWS）上部署弹性计算云（EC2）实例。我们将演示如何编写
    Terraform 脚本来在 EC2 实例上配置和部署我们的应用程序，确保基础设施设置的一致性和可重复性。
- en: Then we will utilize LLMs to deploy our application onto Kubernetes (AWS Elastic
    Kubernetes Service [EKS]/Elastic Container Service [ECS]). We will have GitHub
    Copilot create the appropriate Kubernetes deployment files to streamline our deployment
    process and efficiently manage our application’s lifecycle. Given the relative
    simplicity of our application, we will not need a Kubernetes package manager like
    Helm. However, as the complexities and dependencies of services grow, you may
    want to explore it as one option. Fortunately, Copilot can write Helm charts for
    you as well!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将利用大型语言模型（LLMs）将我们的应用程序部署到 Kubernetes（AWS Elastic Kubernetes Service [EKS]/Elastic
    Container Service [ECS]）。我们将让 GitHub Copilot 创建适当的 Kubernetes 部署文件，以简化我们的部署流程并高效管理应用程序的生命周期。鉴于我们的应用程序相对简单，我们不需要像
    Helm 这样的 Kubernetes 包管理器。然而，随着服务和依赖的复杂性和增长，你可能希望将其作为选项之一进行探索。幸运的是，Copilot 还可以为你编写
    Helm 图表！
- en: Finally, we will briefly showcase migrating from local to automated deployments
    using GitHub actions. We can automate our build and deployment processes by integrating
    LLMs with this widespread continuous integration and deployment (CI/CD) tool,
    ensuring faster and more efficient deployments.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将简要展示如何使用 GitHub actions 从本地迁移到自动化部署。通过将 LLMs 与这个广泛使用的持续集成和持续部署（CI/CD）工具集成，我们可以自动化构建和部署流程，确保更快、更高效的部署。
- en: NOTE This chapter uses AWS as our cloud provider, but the principles and practices
    covered in the chapter can be adapted and applied to other cloud platforms and
    even on-premises infrastructure without virtualization (bare metal), allowing
    us to adapt and scale your product deployment strategy as your business needs
    evolve. You will find that by employing LLMs and using infrastructure as code,
    you can (partially) mitigate the vendor lock-in that is very common to cloud platforms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章使用 AWS 作为我们的云服务提供商，但本章中涵盖的原则和实践可以适应并应用于其他云平台，甚至在没有虚拟化（裸金属）的本地基础设施上，使我们能够根据业务需求的变化调整和扩展产品部署策略。你会发现，通过采用大型语言模型（LLMs）和使用基础设施即代码（infrastructure
    as code），你可以（部分地）减轻云平台非常常见的供应商锁定问题。
- en: Note that if you choose to deploy this (or any application) to AWS, there will
    be a cost associated with your activity. AWS and most cloud providers give you
    free trials to learn their platforms (Google Cloud Platform and Azure, for example),
    but once those credits have expired, you may get hit with a rather unexpectedly
    large bill. If you decide to follow along in this chapter, you need to set threshold
    alerts for an amount you can comfortably afford. Section 1.9 of Andreas Wittig
    and Michael Wittig’s *Amazon Web Services in Action, Third Edition* (Manning,
    2023; [www.manning.com/books/amazon-web-services-in-action-third-edition](https://www.manning.com/books/amazon-web-services-in-action-third-edition))
    is an excellent resource for setting up such a billing notification alert.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您选择将此（或任何应用程序）部署到AWS，您的活动将产生相关费用。AWS和大多数云服务提供商提供免费试用以学习他们的平台（例如Google Cloud
    Platform和Azure），但一旦这些信用额度到期，您可能会收到一个相当意外的账单。如果您决定跟随本章的内容，您需要设置一个您能舒适承担的阈值警报。Andreas
    Wittig和Michael Wittig的*Amazon Web Services in Action, Third Edition*（Manning，2023；[www.manning.com/books/amazon-web-services-in-action-third-edition](https://www.manning.com/books/amazon-web-services-in-action-third-edition)）的第1.9节是设置此类计费通知警报的极好资源。
- en: 7.1 Building a Docker image and “deploying” it locally
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 构建Docker镜像并在本地“部署”
- en: As you may remember from chapter 6, Docker is a containerization platform that
    allows you to run applications with little or no installation of an application
    (outside of Docker) in the traditional sense. Unlike a virtual machine, which
    simulates an entire operating system, a container shares the host system’s kernel
    (the core part of the operating system) and uses the host system’s operating system’s
    capabilities while isolating the application processes and file systems from the
    host. This lets you run multiple isolated applications on a single host system,
    each with its own environment and resource limits. Figure 7.1 gives you a sense
    of the relationship between the Docker runtime and the host.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从第6章可能记得的那样，Docker是一个容器化平台，允许您在传统意义上几乎不需要安装应用程序（除了Docker之外）的情况下运行应用程序。与模拟整个操作系统的虚拟机不同，容器共享宿主系统的内核（操作系统的核心部分）并使用宿主系统的操作系统功能，同时将应用程序进程和文件系统与宿主系统隔离。这使得您可以在单个宿主系统上运行多个隔离的应用程序，每个应用程序都有自己的环境和资源限制。图7.1展示了Docker运行时与宿主之间的关系。
- en: '![](../Images/CH07_F01_Crocker2.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 Docker容器与宿主系统关系图](../Images/CH07_F01_Crocker2.png)'
- en: Figure 7.1 Docker makes use of the host’s operating system while isolating each
    of the containers. This makes Docker containers lightweight compared to virtual
    machines, as they do not require a full OS to run.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 Docker利用宿主操作系统的功能，同时隔离每个容器。这使得与虚拟机相比，Docker容器更轻量，因为它们不需要完整的操作系统来运行。
- en: One of the more exciting features, from a production readiness perspective,
    is that Docker makes it easier to run applications that can self-heal in some
    sense. If they fail or fall over at runtime, you can configure them to restart
    without intervention. In this section, we will use Copilot to create the file
    (called a *Dockerfile*) from which we will build our *Docker image*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从生产准备的角度来看，其中一个更令人兴奋的功能是，Docker使得运行某些意义上可以自我修复的应用程序变得更加容易。如果它们在运行时失败或崩溃，您可以配置它们在无需干预的情况下重启。在本节中，我们将使用Copilot创建一个文件（称为*Dockerfile*），我们将从这个文件构建我们的*Docker镜像*。
- en: Definition *Docker images* are like blueprints for Docker containers. They are
    portable, including all the dependencies (libraries, environment variables, code,
    etc.) required for the application to run.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*Docker镜像*就像Docker容器的蓝图。它们是可移植的，包括应用程序运行所需的所有依赖项（库、环境变量、代码等）。
- en: Running Docker instances are called Docker *containers*. Given their lightweight
    nature, we can run multiple containers on a single host without a problem. We
    can do this because the containerization technology shares the OS kernel, operating
    in an isolated user space.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行的Docker实例被称为Docker *容器*。鉴于它们的轻量级特性，我们可以在单个主机上运行多个容器而不会出现问题。我们可以这样做，因为容器化技术共享OS内核，在隔离的用户空间中运行。
- en: NOTE Originally, I wanted to use AWS CodeWhisperer as the LLM for this chapter.
    It seemed logical, given the intended cloud platform. However, at the time of
    this writing, AWS CodeWhisperer only supports programming in a programming language.
    It does not have facilities for infrastructure as code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：最初，我想使用AWS CodeWhisperer作为本章的LLM。鉴于预期的云平台，这似乎是合理的。然而，在撰写本文时，AWS CodeWhisperer仅支持编程语言编程。它没有基础设施即代码的功能。
- en: 'We will begin with the following prompt to have Copilot draft the Dockerfile
    for us:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下提示来让Copilot为我们草拟Dockerfile：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You may be left with an empty file (other than this comment). Support for infrastructure
    as code is ever-evolving (not unlike the LLM ecosystem in general). According
    to Copilot Chat, GitHub Copilot is capable of creating a Dockerfile for you—but
    you have to goad it with the following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能只剩下一个空文件（除了这个注释）。基础设施即代码的支持是不断发展的（与一般的LLM生态系统类似）。根据Copilot Chat，GitHub Copilot能够为您创建Dockerfile——但是您必须通过以下步骤来激励它：
- en: In the Dockerfile, type `FROM python:` and wait for Copilot to suggest a version
    of Python to use. Select the version you want to use.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Dockerfile中输入`FROM python:`并等待Copilot建议要使用的Python版本。选择您想要使用的版本。
- en: Type `WORKDIR /app` to set the working directory for the container.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`WORKDIR /app`以设置容器的当前工作目录。
- en: Type `COPY . /app` to copy the contents of your project into the container.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`COPY . /app`以将项目内容复制到容器中。
- en: Type `RUN pip install --trusted-host pypi.python.org -r requirements.txt` to
    install the dependencies for your project.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`RUN pip install --trusted-host pypi.python.org -r requirements.txt`以安装项目的依赖项。
- en: Type `EXPOSE 8080` to expose port 8080 for the container.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`EXPOSE 8080`以暴露容器的8080端口。
- en: Type `CMD ["python", "main.py"]` to specify the command to run when the container
    starts.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`CMD ["python", "main.py"]`以指定容器启动时运行的命令。
- en: Alternatively, you may want to copy and paste the same prompt that you previously
    wrote into the Dockerfile into the Copilot Chat prompt window. Copilot Chat will
    give you the desired content for the Dockerfile.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可能希望将之前写入Dockerfile中的相同提示复制粘贴到Copilot Chat的提示窗口中。Copilot Chat将为您提供所需的Dockerfile内容。
- en: Listing 7.1 Dockerfile to build a Docker image
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1 构建Docker镜像的Dockerfile
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With a Dockerfile, we will build an image for deploying and running our application.
    We can enter the following command to build our application (run from the directory
    where the Dockerfile lives, and do not forget the trailing dot). You will need
    internet access to download the dependencies and create the image:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Dockerfile，我们将构建用于部署和运行我们应用程序的镜像。我们可以输入以下命令来构建我们的应用程序（从Dockerfile所在的目录运行，并且不要忘记最后的点）。您需要互联网访问来下载依赖项并创建镜像：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Building a Docker image can run for a few seconds to a few minutes, depending
    on which images and packages are installed on your system and your internet connection
    speed. Your patience will be rewarded, as you will shortly have an application
    you can install nearly anywhere from the lowliest commodity hardware to the most
    oversized hardware offered by your favorite cloud provider. Before running it
    anywhere, however, you need to try to get it running locally. If you’ve forgotten
    the command, Copilot Chat will happily and helpfully assist:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Docker镜像可能需要几秒钟到几分钟，具体取决于您的系统上安装了哪些镜像和包以及您的互联网连接速度。您的耐心将得到回报，因为您将很快拥有一个可以在几乎任何地方安装的应用程序，从最基础的商品硬件到您最喜欢的云提供商提供的最大型硬件。然而，在运行之前，您需要尝试在本地运行它。如果您忘记了命令，Copilot
    Chat将乐意并乐于提供帮助：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can confirm that your Docker container is running by issuing this command
    at the command line: `docker ps | grep itam`. You should see the running instance.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在命令行中输入以下命令来确认您的Docker容器正在运行：`docker ps | grep itam`。您应该能看到正在运行的实例。
- en: 7.2 Standing up infrastructure by copiloting Terraform
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 通过Copilot搭建基础设施
- en: Using a Docker image on your computer is useful when creating and testing an
    app. But when it comes time to launch your application, you need a machine with
    a little more heft than local computers. In this section, we’ll use GitHub Copilot
    to help us set up and control our AWS infrastructure by having Copilot write the
    requisite deployment descriptors for an infrastructure-as-code tool called Terraform.
    Terraform is made by HashiCorp and lets us write what we want our infrastructure
    to look like using a domain-specific language (DSL). This DSL saves us from having
    to understand all the complexities and intricacies that each cloud service provider
    uses to provision hardware. Additionally, it allows us to store and version our
    infrastructure using infrastructure as code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建和测试应用程序时，使用你电脑上的Docker镜像是有用的。但是，当到了启动你的应用程序的时候，你需要一台比本地电脑更强大的机器。在本节中，我们将使用GitHub
    Copilot帮助我们通过让Copilot编写基础设施代码工具Terraform所需的必要部署描述符来设置和控制我们的AWS基础设施。Terraform由HashiCorp制作，允许我们使用领域特定语言（DSL）来编写我们希望基础设施看起来像什么。这种DSL使我们免于理解每个云服务提供商用于配置硬件的所有复杂性和细微差别。此外，它还允许我们使用基础设施代码存储和版本化我们的基础设施。
- en: To start, we want to create a file called ec2.tf and add the prompt to inform
    Copilot that we intend this to be a Terraform file and how we want our infrastructure
    stood up. Notice that Copilot needs us to enter the first word of a given line
    before it can be cajoled to continue.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要创建一个名为ec2.tf的文件，并添加提示告知Copilot我们打算将其作为Terraform文件，以及我们希望如何搭建我们的基础设施。请注意，Copilot需要我们在输入给定行的第一个单词之前才能继续。
- en: Listing 7.2 Example Terraform file, including instance size
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 示例Terraform文件，包括实例大小
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You may find that Copilot skips over one small but crucial detail: it does
    not provide code for installing and provisioning Docker. Given that Docker is
    required for running our application, we need to correct this oversight. In fact,
    you may need to update the file manually to include the command to install Docker,
    like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现Copilot跳过了一个小但至关重要的细节：它没有提供安装和配置Docker的代码。鉴于Docker是运行我们的应用程序所必需的，我们需要纠正这个疏忽。实际上，你可能需要手动更新文件以包含安装Docker的命令，如下所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Copilot should produce a complete Terraform file that resembles the following
    listing. Your code probably does not exactly match the listing, but that’s fine
    as long as it contains the key features: the provider, the instance, the script
    to add the Docker daemon, the key pair, and the security group.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot应该生成一个完整的Terraform文件，类似于以下列表。你的代码可能并不完全匹配列表，但这没关系，只要它包含关键特性：提供者、实例、添加Docker守护进程的脚本、密钥对和安全组。
- en: Listing 7.3 Terraform file to create the smallest EC2 instance available
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3 创建最小EC2实例的Terraform文件
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you are using the default Virtual Private Cloud (VPC), the `vpc_id` entry
    is not strictly necessary. You will find that many of the default configurations
    and conventions chosen by the AWS team make sense; if you have stricter security
    requirements, or if you know everything about your infrastructure and assume nothing,
    you might consider setting up a new VPC from scratch using Terraform. You need
    to change the key pair entry on line 21 to be a key pair to which you have access.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是默认的虚拟专用云（VPC），则`vpc_id`条目不是严格必要的。你会发现AWS团队选择的许多默认配置和约定是有意义的；如果你有更严格的安全要求，或者如果你对你的基础设施了如指掌，并假设一切，你可能会考虑从头开始使用Terraform设置一个新的VPC。你需要将第21行的密钥对条目更改为你有访问权限的密钥对。
- en: Once you have completed this file satisfactorily, run the `terraform init` command.
    This command initializes a new or existing Terraform working directory. It downloads
    and installs the required provider plugins and modules specified in your configuration
    files and gets everything ready to go.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你满意地完成了这个文件，运行`terraform init`命令。这个命令初始化一个新的或现有的Terraform工作目录。它会下载并安装你在配置文件中指定的所需提供者插件和模块，并准备好一切以便开始。
- en: 'Next you will have Terraform explain the changes that it intends to make. You
    do this with the `terraform plan` command. This command creates an execution plan
    for your infrastructure changes: it shows you what changes Terraform will make
    to your infrastructure when you apply your configuration files. The plan will
    show you which resources will be created, modified, or destroyed and any other
    changes that will be made to your infrastructure.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Terraform将解释它打算做出的更改。你可以使用`terraform plan`命令来完成这个操作。这个命令为你的基础设施更改创建一个执行计划：它显示当你应用你的配置文件时，Terraform将如何更改你的基础设施。计划将显示哪些资源将被创建、修改或销毁，以及将对你的基础设施做出的任何其他更改。
- en: 'NOTE You may get an error when running `terraform plan` for the first time:
    “Error: configuring Terraform AWS Provider: no valid credential sources for Terraform
    AWS Provider found.” You get this error when Terraform attempts to connect to
    AWS but cannot supply AWS with proper credentials. To address this problem, you
    will need to create (or edit) the file called ~/.aws/credentials and add your
    ITAM AWS Access Key ID and AWS Secret Access Key credentials. You can find more
    details on how to accomplish this correctly in section 4.2.2, “Configuring the
    CLI,” of *Amazon Web Services in Action, Third Edition*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当你第一次运行`terraform plan`时可能会遇到错误：“错误：配置Terraform AWS Provider：未找到有效的Terraform
    AWS Provider凭证来源。”当你尝试连接到AWS但无法向AWS提供适当的凭证时，你会遇到这个错误。为了解决这个问题，你需要创建（或编辑）名为~/.aws/credentials的文件，并添加你的ITAM
    AWS访问密钥ID和AWS秘密访问密钥凭证。你可以在*Amazon Web Services in Action，第三版*的4.2.2节“配置CLI”中找到更多关于如何正确完成此操作的详细信息。
- en: Finally, to apply the Terraform changes, you use the `terraform apply` command.
    Terraform will then read the configuration files in the current directory and
    apply any changes to your infrastructure. If you have made any changes to your
    configuration files since the last time you ran `terraform apply`—for example,
    if you need to start up a new database instance or change the size of your EC2—Terraform
    will show you a preview of the changes that will be made and prompt you to confirm
    before applying the changes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了应用Terraform的更改，你将使用`terraform apply`命令。然后，Terraform将读取当前目录中的配置文件，并将任何更改应用到你的基础设施上。如果你在最后一次运行`terraform
    apply`之后对配置文件进行了任何更改——例如，如果你需要启动一个新的数据库实例或更改EC2的大小——Terraform将显示更改的预览，并提示你在应用更改之前进行确认。
- en: If you apply these changes, in a manner of minutes you will have a brand-new
    EC2 instance running in your VPC. However, this is only half of the equation.
    Having computing power at your fingertips is fantastic, but you need something
    to apply this power. In this case, we can use this EC2 instance to run our ISAM
    system. The following section briefly demonstrates transferring a locally built
    image to another machine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你应用这些更改，几分钟内你将有一个全新的EC2实例在你的VPC中运行。然而，这仅仅是方程的一半。拥有触手可及的计算能力是极好的，但你还需要一些东西来应用这种力量。在这种情况下，我们可以使用这个EC2实例来运行我们的ISAM系统。下一节简要演示了将本地构建的镜像传输到另一台机器的过程。
- en: 7.3 Moving a Docker image around (the hard way)
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 以困难的方式移动Docker镜像
- en: 'First we will export a Docker image from our local machines and load it onto
    a remote machine. We will use the commands `docker save` and `load` to accomplish
    this. You can use the `docker save` command on your local machine to save the
    image to a tar archive. The following command will save the image to a tar archive
    named <image-name>.tar:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从本地机器导出一个Docker镜像并将其加载到远程机器上。我们将使用`docker save`和`load`命令来完成这项任务。你可以在本地机器上使用`docker
    save`命令将镜像保存到一个tar归档文件中。以下命令将镜像保存到名为<image-name>.tar的tar归档文件中：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, transfer the tar archive to the remote machine using a file transfer
    protocol such as Secure Copy Protocol (SCP) or Secure File Transfer Protocol (SFTP).
    You can use the `docker load` command on the remote machine to load the image
    from the tar archive: `docker load -i <image-name>.tar.` This will load the image
    into the local Docker image cache on the remote machine. Once the image has been
    loaded, use the `docker run` command to start the image and run the Docker container,
    as you did after you built it. Then add this image to your Docker compose file,
    in which you have the Postgres database and Kafka instances.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用文件传输协议，如安全复制协议（SCP）或安全文件传输协议（SFTP），将tar存档传输到远程机器。你可以在远程机器上使用`docker load`命令从tar存档加载镜像：`docker
    load -i <image-name>.tar`。这将把镜像加载到远程机器上的本地Docker镜像缓存中。一旦镜像被加载，使用`docker run`命令启动镜像并运行Docker容器，就像你在构建它之后所做的那样。然后，将此镜像添加到你的Docker
    compose文件中，其中包含Postgres数据库和Kafka实例。
- en: NOTE This discussion of Terraform is heavily abridged. When you are ready to
    get serious with Terraform, your go-to resource should be Scott Winkler’s *Terraform
    in Action* (Manning, 2021; [www.manning.com/books/terraform-in-action](https://www.manning.com/books/terraform-in-action)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：关于Terraform的讨论被大大简化了。当你准备好认真使用Terraform时，你应该查阅Scott Winkler的《Terraform in
    Action》（Manning，2021年；[www.manning.com/books/terraform-in-action](https://www.manning.com/books/terraform-in-action)）。
- en: 'This section examined how to package up images and load them on remote hosts.
    This process is scriptable, but with the advent of container registries, it is
    now easier than ever to manage deployments without slinging them all around the
    internet. In the next section, we will explore one such tool: Amazon’s Elastic
    Container Registry (ECR).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了如何打包镜像并在远程主机上加载它们。这个过程是可脚本化的，但随着容器注册库的出现，现在管理部署比以往任何时候都更容易，无需将它们发送到整个互联网。在下一节中，我们将探讨这样一个工具：亚马逊的弹性容器注册库（ECR）。
- en: 7.4 Moving a Docker image around (the easy way)
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 以简单方式移动Docker镜像
- en: Docker images, the blueprints for our containers, are a fundamental building
    block of containerized applications. Managing them correctly ensures that we maintain
    clean, efficient, and organized development and deployment workflows. Amazon ECR
    serves as a fully managed Docker container registry that makes it easy for developers
    to store, manage, and deploy Docker container images.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像，我们容器的蓝图，是容器化应用的基本构建块。正确管理它们确保我们保持干净、高效和有序的开发和部署工作流程。Amazon ECR作为一个完全管理的Docker容器注册库，使得开发者能够轻松地存储、管理和部署Docker容器镜像。
- en: First, let’s dive into pushing Docker images to ECR. This process is vital to
    making your images accessible for use and deployment. We’ll walk through setting
    up your local environment, authenticating with ECR, and pushing your image. Before
    we can move an image to ECR, we must create a repository to house that image.
    This can be done from the AWS Management Console or, as we will do shortly, using
    the AWS command line interface (CLI). The command to create a new repository for
    an image is
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们深入了解如何将Docker镜像推送到ECR。这个过程对于使你的镜像可用于使用和部署至关重要。我们将逐步介绍设置你的本地环境、使用ECR进行认证以及推送你的镜像。在我们能够将镜像移动到ECR之前，我们必须创建一个用于存放该镜像的仓库。这可以通过AWS管理控制台完成，或者，就像我们很快要做的那样，使用AWS命令行界面（CLI）。创建用于镜像的新仓库的命令是
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next you need to tag your Docker image with the ECR repository URL and the
    image name. You may want to call it `latest` or use semantic versioning. Tagging
    will allow you to easily roll back or forward versions of your system. Tag your
    application image `latest` using the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要使用ECR仓库URL和镜像名称给你的Docker镜像打标签。你可能想称之为`latest`或使用语义版本控制。打标签将允许你轻松回滚或前进到系统版本。使用以下命令给你的应用程序镜像打上`latest`标签：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, authenticate Docker to the ECR registry using the `aws ecr get-login-password`
    command. This will generate a Docker `login` command that you can use to authenticate
    Docker to the registry. The command to log in is
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`aws ecr get-login-password`命令对Docker进行ECR注册库的认证。这将生成一个用于认证Docker到注册库的Docker
    `login`命令。登录命令如下
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, push the Docker image to the ECR registry using the `docker push`
    command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`docker push`命令将Docker镜像推送到ECR注册库：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once the image is in your registry, your deployment options have greatly increased.
    You could, for example, write a bash script that will log on to the EC2 instance
    and perform a `docker pull` to download and run the image on that EC2\. Alternatively,
    you may want to adopt a more bulletproof deployment pattern. In the next section,
    we’re going to walk through the process of setting up and launching our application
    on a powerful cloud service called Elastic Kubernetes Service (EKS). EKS is a
    managed Kubernetes service provided by AWS. Let’s dive in!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像存放在你的注册表中，你的部署选项大大增加。例如，你可以编写一个 bash 脚本，登录到 EC2 实例并执行 `docker pull` 来下载和在该
    EC2 上运行镜像。或者，你可能希望采用更可靠的部署模式。在下一节中，我们将介绍如何在名为 Elastic Kubernetes Service (EKS)
    的强大云服务上设置和启动我们的应用程序的过程。EKS 是 AWS 提供的托管 Kubernetes 服务。让我们深入探讨吧！
- en: 7.5 Deploying our application onto AWS Elastic Kubernetes Service
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 将我们的应用程序部署到 AWS Elastic Kubernetes Service
- en: Kubernetes confers many benefits over simply running Docker images on EC2 instances.
    For one, managing and scaling our application becomes considerably more straightforward
    with Kubernetes. Also, with Kubernetes, we do not have to spend a lot of additional
    time thinking about what our infrastructure should look like. Plus, thanks to
    its automatic management of the lifecycles of its images, known as *pods*, our
    application will essentially be self-healing. This means if something goes wrong,
    Kubernetes can automatically fix it, keeping our application running smoothly
    at all times.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 相比于在 EC2 实例上简单地运行 Docker 镜像提供了许多好处。首先，使用 Kubernetes 管理和扩展我们的应用程序变得更加简单。此外，使用
    Kubernetes，我们不需要花费很多额外的时间去思考我们的基础设施应该是什么样子。而且，多亏了其对名为 *pods* 的镜像生命周期的自动管理，我们的应用程序将基本上是自我修复的。这意味着如果出现问题，Kubernetes
    可以自动修复它，确保我们的应用程序始终运行顺畅。
- en: First we need a deployment descriptor written in YAML (Yet Another Markup Language
    or YAML Ain’t Markup Language, depending on who you ask), which will describe
    the state we want our ITAM system to be in at all times. This file (typically
    called deployment.yaml) will provide the template against which Kubernetes will
    compare the current running system, making corrections as needed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个用 YAML（Yet Another Markup Language 或 YAML Ain’t Markup Language，取决于你问谁）编写的部署描述符，这将描述我们希望
    ITAM 系统始终保持的状态。这个文件（通常称为 deployment.yaml）将提供 Kubernetes 将与之比较的当前运行系统的模板，并根据需要做出修正。
- en: Listing 7.4 Kubernetes deployment file for the ITAM system
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 ITAM 系统的 Kubernetes 部署文件
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will not work, however. Kubernetes will not be able to find the image that
    we reference in the deployment descriptor file. To correct this, we need to tell
    Kubernetes to use our newly minted ECR. Fortunately, this is not as challenging
    as it may sound. We just have to update the image entry in our file to point to
    the ECR image, as well as grant EKS permissions to access ECR (okay, maybe it
    is a little trickier, but it is manageable).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不会起作用。Kubernetes 将无法找到我们在部署描述文件中引用的镜像。为了纠正这个问题，我们需要告诉 Kubernetes 使用我们新创建的
    ECR。幸运的是，这并不像听起来那么具有挑战性。我们只需要更新文件中的镜像条目，使其指向 ECR 镜像，以及授予 EKS 访问 ECR 的权限（好吧，可能有点复杂，但它是可管理的）。
- en: 'First, update the deployment YAML to use the ECR image:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更新部署 YAML 以使用 ECR 镜像：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Then you would need to define a policy for EKS to use and apply the policy using
    either the AWS CLI or the Identity and Access Management (IAM) Management Console.
    Although applying the policy is (slightly) outside of the scope of this book,
    you can use Copilot to define it. The resulting policy will resemble the following
    listing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要为 EKS 定义一个策略，并使用 AWS CLI 或身份和访问管理（IAM）管理控制台应用该策略。尽管应用策略超出了本书的范围，但你可以使用
    Copilot 来定义它。生成的策略将类似于以下列表。
- en: Listing 7.5 IAM policy to allow EKS to pull images from ECR
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 允许 EKS 从 ECR 拉取镜像的 IAM 策略
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once the EKS can pull down the image from ECR, you will see a pod start to run.
    However, you have no way to access this pod externally. You need to create a service.
    In Kubernetes, a *service* is an abstraction that defines a logical set of pods
    (the smallest and simplest unit in the Kubernetes object model that you create
    or deploy) and a policy to access them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 EKS 能够从 ECR 拉取镜像，你将看到一个 pod 开始运行。然而，你无法外部访问这个 pod。你需要创建一个服务。在 Kubernetes
    中，*服务* 是一个抽象概念，它定义了一组逻辑上的 pod（你在 Kubernetes 对象模型中创建或部署的最小和最简单的单元）以及访问它们的策略。
- en: Services enable communication between different parts of an application and
    between different applications. They help distribute network traffic and load
    balance by exposing the pods to the network and other pods in Kubernetes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 服务使得应用程序的不同部分以及不同应用程序之间能够进行通信。它们通过将 Pod 暴露给网络和其他 Kubernetes 中的 Pod 来帮助分配网络流量和负载均衡。
- en: Listing 7.6 Kubernetes services file to enable external access for our application
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 Kubernetes 服务文件，以启用我们的应用程序的外部访问
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Kubernetes is responsible for routing all requests from this ingress through
    the service to the running pods, regardless of what host they are running on.
    This allows for seamless failover. Kubernetes expects things to fail. It banks
    on it. As a result, many of the best practices in distributed systems are baked
    into Kubernetes. Getting to Kube is a significant first step to having a reliable,
    highly available system. In the next section, we will examine how to ease the
    burden of getting our application onto Kubernetes repeatably and continuously.
    We will look at building out a small deployment pipeline using GitHub actions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 负责将所有请求从入口路由到服务，然后到正在运行的 Pod，无论它们运行在哪个主机上。这允许无缝故障转移。Kubernetes 预期事情会失败。它依赖于此。因此，许多分布式系统中的最佳实践都内置到了
    Kubernetes 中。到达 Kube 是构建一个可靠、高可用系统的重大第一步。在下一节中，我们将探讨如何重复和持续地减轻将我们的应用程序部署到 Kubernetes
    的负担。我们将查看如何使用 GitHub Actions 构建一个小型部署管道。
- en: 7.6 Setting up a continuous integration/continuous deployment pipeline in GitHub
    Actions
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 在GitHub Actions中设置持续集成/持续部署（CI/CD）管道
- en: If releasing is hard, it will not be done often. This limits our ability to
    add value to the application and thus to our stakeholders. However, automating
    the deployment process significantly reduces the time to release. This allows
    for more frequent releases, accelerating the pace of development and enabling
    faster delivery of features to users. Continuous integration/continuous deployment
    (CI/CD) pipelines limit the risk associated with deployment. By making smaller,
    more frequent updates, any problems that arise can be isolated and fixed quickly,
    minimizing the potential effect on the end users. These pipelines facilitate seamless
    integration of code changes and expedite deployment, simplifying the software
    release process.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发布很困难，那么它就不会经常进行。这限制了我们对应用程序增值的能力，从而也限制了我们对利益相关者的增值。然而，自动化部署过程显著减少了发布所需的时间。这使得更频繁的发布成为可能，加速了开发步伐，并能够更快地将功能交付给用户。持续集成/持续部署（CI/CD）管道限制了与部署相关的风险。通过进行更小、更频繁的更新，任何出现的问题都可以被隔离和快速修复，最小化对最终用户潜在的影响。这些管道促进了代码更改的无缝集成，并加速了部署，简化了软件发布过程。
- en: GitHub Actions allows us to construct customized CI/CD pipelines directly in
    our GitHub repositories. This makes the development workflow more efficient and
    enables the automation of various steps, freeing us to focus on coding rather
    than the logistics of integration and deployment.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 允许我们在 GitHub 仓库中直接构建定制的 CI/CD 管道。这使得开发工作流程更加高效，并能够自动化各种步骤，让我们能够专注于编码，而不是集成和部署的物流。
- en: This section provides a concise introduction to setting up a CI/CD pipeline
    using GitHub Actions and GitHub Copilot. Note that this will not be a comprehensive
    guide but rather a survey that introduces the potential benefits and general workflow.
    This should serve as a primer, giving you an insight into how these tools can
    be used to optimize your software development process.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要介绍了使用 GitHub Actions 和 GitHub Copilot 设置 CI/CD 管道。请注意，这不会是一个全面的指南，而是一个介绍潜在好处和一般工作流程的概述。这应该作为入门指南，让你了解这些工具如何被用来优化你的软件开发过程。
- en: 'First, create a file in your project in the path .github/workflows. Note the
    leading dot. You can call this file itam.yaml or whatever you desire. On the first
    line of this file, add the following prompt:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在你的项目中的路径 .github/workflows 下创建一个文件。注意前面的点。你可以把这个文件命名为 itam.yaml 或者你想要的任何名字。在这个文件的第一个行，添加以下提示：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: NOTE Like many of the infrastructure-related tasks that we have put to Copilot
    in this chapter, Copilot needs a lot of assistance in creating this file for us.
    We need to be aware of the structure of this file and how to begin every line.
    It makes sense in cases such as this one to ask ChatGPT or Copilot Chat to build
    the file for us.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：像本章中我们交给 Copilot 的许多与基础设施相关任务一样，Copilot 在创建此文件时需要我们提供大量帮助。我们需要了解这个文件的结构以及如何开始每一行。在这种情况下，向
    ChatGPT 或 Copilot Chat 请求为我们构建文件是有意义的。
- en: The first part of this file outlines when this action should take place. The
    on:push instruction denotes that when a git push occurs to the main branch, this
    action should be executed. There is a single job in this file, one with several
    steps. This job “build” uses an embedded function `login-ecr` to log into our
    ECR.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的这部分概述了此操作何时应该执行。on:push指令表示当向主分支进行git push时，此操作应该执行。此文件中只有一个作业，包含多个步骤。这个名为“build”的作业使用内嵌函数`login-ecr`登录到我们的ECR。
- en: Listing 7.7 Beginning of GitHub Actions file to build our application
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.7构建我们的应用程序的GitHub Actions文件的开始部分
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The build job will first check out the code from our GitHub repository. It uses
    the code written in the module `actions/checkout` version 2\. Similarly, it will
    next grab the EKS CLI and configure the credentials to connect to EKS. Note that
    the AWS access key and secret are values that are automatically passed into the
    application. GitHub Actions uses a built-in secret management system to store
    sensitive data such as API keys, passwords, and certificates. This system is integrated
    into the GitHub platform and allows you to add, remove, or update secrets (and
    other sensitive data) at both the repository and organization levels. Secrets
    are encrypted before they’re stored and are not shown in logs or available for
    download. They’re only exposed as environment variables to the GitHub Actions
    runner, making it a secure way to handle sensitive data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 构建作业首先会从我们的GitHub仓库检出代码。它使用模块`actions/checkout`版本2中编写的代码。同样，接下来它将获取EKS CLI并配置凭证以连接到EKS。请注意，AWS访问密钥和秘密是自动传递到应用程序中的值。GitHub
    Actions使用内置的秘密管理系统来存储敏感数据，如API密钥、密码和证书。该系统集成到GitHub平台中，允许你在仓库和组织级别添加、删除或更新秘密（以及其他敏感数据）。在存储之前，秘密会被加密，不会显示在日志中或可供下载。它们仅作为环境变量暴露给GitHub
    Actions运行器，这是一种处理敏感数据的安全方式。
- en: 'Likewise, you can create environmental parameters and use them in your actions.
    For example, look at the variable `ECR_REGISTRY`. This variable is created using
    the output from the `login-ecr` function. In this case, you still need to hardcode
    the ECR in your Actions file. However, you should do this because of consistency
    and the need to manage it in only one place in the file. Most of these steps should
    seem familiar, as we have used them throughout the chapter. That is the magic
    of automation: it does it for you.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以在操作中创建环境参数并使用它们。例如，看看变量`ECR_REGISTRY`。这个变量是使用`login-ecr`函数的输出创建的。在这种情况下，您仍然需要在您的Actions文件中硬编码ECR。然而，您应该这样做是为了保持一致性，并且需要在文件中仅在一个地方管理它。大多数这些步骤应该看起来很熟悉，因为我们已经在整个章节中使用了它们。这就是自动化的魔力：它为您完成这些工作。
- en: Listing 7.8 Build and deploy steps of our GitHub Actions file
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.8我们的GitHub Actions文件的构建和部署步骤
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The final part of the file logs in to AWS ECR. The steps in the Actions file
    invoke this action. On completion, it returns the output to the calling function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的最后部分登录到AWS ECR。Actions文件中的步骤调用此操作。完成后，它将输出返回到调用函数。
- en: Listing 7.9 A GitHub Actions file to build and deploy to EKS
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.9构建和部署到EKS的GitHub Actions文件
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Exploring code-as-infrastructure has enabled us to understand its vital role
    in any project and how it can be better managed through code. Tools like Terraform
    provide streamlined solutions for managing infrastructure, and GitHub’s code-centric
    features aid in maintaining the overall workflow.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 探索代码即基础设施使我们能够理解它在任何项目中的关键作用以及如何通过代码更好地管理。像Terraform这样的工具为管理基础设施提供了简化的解决方案，GitHub以代码为中心的功能有助于维护整体工作流程。
- en: Introducing CI/CD pipelines, primarily through platforms like GitHub Actions,
    highlights the importance of automating the software delivery process. Automating
    such processes increases the speed and reliability of the software development
    life cycle and minimizes the chances of human errors.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过GitHub Actions等平台引入CI/CD管道，突出了自动化软件交付过程的重要性。自动化此类过程可以提高软件开发生命周期的速度和可靠性，并最大限度地减少人为错误的可能性。
- en: The journey of managing infrastructure as code is ever-evolving, with new tools
    and practices emerging. It requires a constant learning and adaptation mindset.
    This chapter has given you a glimpse of the benefits and possibilities.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将基础设施作为代码管理的旅程是不断演变的，新的工具和实践不断涌现。这需要持续学习和适应的心态。本章为您展示了其优势和可能性。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned about the transition from application development to product launch,
    covering deployment strategies, best practices for cloud infrastructure, and the
    use of Docker and Terraform for managing and containerizing applications efficiently.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你了解了从应用开发到产品发布的转变，包括部署策略、云基础设施的最佳实践，以及使用Docker和Terraform高效管理和容器化应用的方法。
- en: The chapter explained how to manage application deployment via Kubernetes, including
    creating YAML deployment descriptors, forming services for network traffic distribution,
    and deploying on AWS’s Elastic Kubernetes Service (EKS).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章解释了如何通过Kubernetes管理应用部署，包括创建YAML部署描述符、形成用于网络流量分配的服务，以及在亚马逊的弹性Kubernetes服务（EKS）上部署。
- en: You discovered how to adapt deployment methods to different environments, whether
    on various cloud platforms or on premises, and how GitHub Copilot can assist in
    creating Dockerfiles and Terraform files accurately.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你发现了如何将部署方法适应不同的环境，无论是各种云平台还是本地环境，以及GitHub Copilot如何帮助准确创建Dockerfile和Terraform文件。
- en: Finally, we explored the process of exporting Docker images to remote machines,
    pushing them to Amazon’s Elastic Container Registry (ECR), and migrating to automated
    deployments using GitHub Actions.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们探讨了将Docker镜像导出到远程机器、推送到亚马逊的弹性容器注册库（ECR）以及使用GitHub Actions迁移到自动化部署的过程。
