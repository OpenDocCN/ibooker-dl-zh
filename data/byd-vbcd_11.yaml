- en: Chapter 8\. Security, Maintainability, and Reliability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章：安全、可维护性和可靠性
- en: This chapter confronts a critical aspect of vibe coding and AI-assisted engineering—ensuring
    that the code you produce with AI assistance is secure, reliable, and maintainable.
    Speed and productivity mean little if the resulting software is riddled with vulnerabilities
    or prone to crashing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章面对 vibe 编程和 AI 辅助工程的一个关键方面——确保使用 AI 辅助生成的代码是安全的、可靠的和可维护的。如果生成的软件漏洞百出或容易崩溃，那么速度和生产力就微不足道了。
- en: First, I’ll examine common security pitfalls that arise in AI-generated code,
    from injection vulnerabilities to secrets leakage. You’ll learn techniques for
    auditing and reviewing AI-written code for such issues, effectively acting as
    the security safety net for your AI pair programmer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将检查在 AI 生成的代码中出现的常见安全陷阱，从注入漏洞到机密泄露。你将学习审计和审查 AI 编写的代码以发现此类问题的技术，有效地作为你的
    AI 代码伙伴的安全保障。
- en: Next, I’ll discuss building effective testing and QA frameworks around AI-generated
    code to catch bugs and reliability issues early. Performance considerations will
    also be covered. AI might write correct code, but it’s not always the most efficient
    code, so I’ll outline how to identify and optimize performance bottlenecks. I’ll
    also explore strategies to ensure maintainability, such as enforcing consistent
    styles or refactoring AI code, since AI suggestions can sometimes be inconsistent
    or overly verbose.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将讨论围绕 AI 生成的代码构建有效的测试和 QA 框架，以早期捕捉到错误和可靠性问题。性能考虑也将被涵盖。AI 可能会编写正确的代码，但并不总是最有效的代码，因此我将概述如何识别和优化性能瓶颈。我还会探讨确保可维护性的策略，例如强制执行一致的样式或重构
    AI 代码，因为 AI 建议有时可能不一致或过于冗长。
- en: I’ll show you how to adapt your code-review practices to an AI-assisted workflow,
    highlighting what human reviewers should focus on when reviewing code that was
    partially or wholly machine-generated. Finally, I’ll round up best practices for
    deploying AI-assisted projects with confidence, from continuous integration pipelines
    to monitoring in production. By the end of this chapter, you’ll have a toolkit
    of approaches to keep your AI-accelerated development safe and robust.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向你展示如何调整你的代码审查实践以适应 AI 辅助工作流程，强调在审查部分或全部由机器生成的代码时，人类审查员应该关注什么。最后，我将总结部署 AI
    辅助项目的最佳实践，从持续集成管道到生产中的监控。到本章结束时，你将拥有一套方法，以确保你的 AI 加速开发既安全又稳健。
- en: Common Security Vulnerabilities in AI-Generated Code
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI 生成的代码中的常见安全漏洞
- en: AI coding assistants, while powerful, can inadvertently introduce security issues
    if not guided properly. They learn from lots of public code—which includes both
    good and bad practices—and may regurgitate insecure patterns if the prompt or
    context doesn’t steer them away. It’s vital for you to know these common pitfalls
    so you can spot and fix them. This can include using both manual and automated
    means to detect potential security issues (see [Figure 8-1](#ch08_figure_1_1752630044605613)).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 AI 编码助手功能强大，但如果使用不当，可能会无意中引入安全问题。它们从大量的公共代码中学习——包括好的和不好的实践——如果提示或上下文没有引导它们远离，它们可能会重复不安全的模式。了解这些常见陷阱对于你来说至关重要，这样你就可以发现并修复它们。这可能包括使用手动和自动手段来检测潜在的安全问题（参见[图
    8-1](#ch08_figure_1_1752630044605613)）。
- en: '![](assets/bevc_0801.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bevc_0801.png)'
- en: 'Figure 8-1\. AI-introduced security vulnerabilities: AI-generated code may
    contain subtle security flaws that require careful review and automated security
    scanning to identify and remediate.'
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. AI 引入的安全漏洞：AI 生成的代码可能包含微妙的漏洞，需要仔细审查和自动化的安全扫描来识别和修复。
- en: 'Some typical security issues observed in AI-generated code include:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AI 生成的代码中观察到的某些典型安全问题包括：
- en: Hard-coded secrets or credentials
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 固定编码的秘密或凭证
- en: Sometimes AI outputs API keys, passwords, or tokens in code, especially if similar
    examples were in its training data. For instance, if you ask it to integrate with
    AWS, it might put a dummy AWS secret key directly in the code. This is dangerous
    if left in—it could leak sensitive info if the code is shared. Always ensure that
    secrets are properly managed via environment variables or config files. If an
    AI suggests something like `api_key = "ABC123SECRET"`, treat it as a flag—real
    keys should not be in source code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有时AI会在代码中输出API密钥、密码或令牌，尤其是在其训练数据中有类似示例的情况下。例如，如果你要求它与AWS集成，它可能会直接在代码中放置一个虚拟的AWS密钥。如果留下它，这是危险的——如果代码被共享，可能会泄露敏感信息。始终确保通过环境变量或配置文件正确管理密钥。如果AI建议像`api_key
    = "ABC123SECRET"`这样的内容，将其视为一个警告——真正的密钥不应该出现在源代码中。
- en: SQL injection vulnerabilities
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入漏洞
- en: 'If you have your AI model generate SQL queries or ORM usage, check that it’s
    not constructing queries by concatenating user input directly. For example, an
    insecure pattern would be:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你让AI模型生成SQL查询或ORM使用，请检查它不是通过直接连接用户输入来构建查询的。例如，一个不安全的模式可能是：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is susceptible to injection attacks. An AI might produce this if you don’t
    specifically tell it to parameterize queries. Always use prepared statements or
    parameter binding. Many AI assistants will do so if they recall best practices
    (like using `?` or placeholders for user inputs in SQL), but it’s not guaranteed.
    It’s on you to verify and ask the AI to fix it if needed:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这容易受到注入攻击。如果你没有明确告诉它参数化查询，AI可能会生成这样的内容。始终使用预编译语句或参数绑定。许多AI助手会这样做，如果它们记得最佳实践（如使用`?`或占位符在SQL中为用户输入），但这并不保证。这取决于你验证并要求AI在需要时进行修复：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Cross-site scripting (XSS) in web apps
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用中的跨站脚本（XSS）
- en: 'When generating web code, AI tools don’t always automatically escape user input
    in outputs. For example, your AI might produce a templating snippet that directly
    inserts `{{comment.text}}` into HTML without escaping, which could allow a malicious
    script placed in a comment to run. If using frameworks, AIs often escape by default,
    but if they’re handling raw HTML construction, be careful. Implement output encoding
    or sanitization routines. You can prompt the AI:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成网络代码时，AI工具并不总是自动在输出中转义用户输入。例如，你的AI可能会生成一个模板片段，直接将`{{comment.text}}`插入HTML而不进行转义，这可能会允许恶意脚本在注释中运行。如果使用框架，AI通常默认转义，但如果它们处理原始HTML构建，请小心。实现输出编码或清理例程。你可以提示AI：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Many modern frameworks have built-in mechanisms, so ensure that the AI uses
    them, like `innerText` versus `innerHTML` in [Document Object Model (DOM) manipulation](https://oreil.ly/5o_2x).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代框架都有内置机制，因此请确保AI使用它们，例如在[文档对象模型 (DOM) 操作](https://oreil.ly/5o_2x)中使用`innerText`而不是`innerHTML`。
- en: Improper authentication and authorization
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不正确的身份验证和授权
- en: 'AIs can write authentication flows, but subtle mistakes might creep in: for
    instance, generating a [JSON Web Token (JWT)](https://oreil.ly/rf7JL) without
    a sufficiently strong secret or not checking a password hash correctly.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: AI可以编写身份验证流程，但细微的错误可能会悄悄出现：例如，在没有足够强大的密钥的情况下生成[JSON Web Token (JWT)](https://oreil.ly/rf7JL)或没有正确检查密码散列。
- en: 'The same is true for authorization: an AI might not automatically enforce that
    an action (like deleting a resource) is limited to the user who owns that resource.
    These logic issues are hard to catch automatically—they require thinking through
    the security model. When writing such code, specify clearly:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于授权来说，也是如此：AI可能不会自动强制执行操作（如删除资源）仅限于拥有该资源的用户。这些逻辑问题很难自动捕捉到——需要仔细思考安全模型。在编写此类代码时，请明确指定：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then test those conditions. It’s easy for an AI to omit a check because it doesn’t
    truly “understand” the context unless told.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后测试这些条件。AI很容易省略检查，因为它如果不被告知，并不真正“理解”上下文。
- en: Insecure defaults or configurations
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全默认或配置
- en: 'AI might choose convenience over security unless prompted to do otherwise.
    Examples include:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: AI可能会选择便利性而不是安全性，除非被提示做其他事情。例如：
- en: Using HTTP instead of HTTPS for API calls (if TLS is not specified)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP而不是HTTPS进行API调用（如果未指定TLS）
- en: Not validating SSL certificates (some code examples on the internet use `verify=false`
    in requests, which AI might copy)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不验证SSL证书（一些互联网上的代码示例在请求中使用`verify=false`，AI可能会复制）
- en: Widely enabling CORS for all origins and methods without restriction (potentially
    opening the app to any cross-origin requests)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无限制地启用对所有来源和方法的CORS（这可能会打开应用对任何跨源请求的访问）
- en: Choosing outdated cryptography (like MD5 or SHA1 for hashes, which are weak,
    instead of SHA-256/Bcrypt/Argon2 for passwords)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择过时的加密（如用于散列的MD5或SHA1，而不是用于密码的SHA-256/Bcrypt/Argon2）
- en: These issues are often subtle, which is one reason it’s good to audit your configuration
    files and initialization code. If the AI sets up something like `app.UseCors(allowAll)`
    or chooses an old cipher, you should spot that and correct it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题通常很微妙，这也是为什么审计您的配置文件和初始化代码是个好主意的原因之一。如果AI设置了类似`app.UseCors(allowAll)`或选择了旧加密算法，您应该注意到并纠正它。
- en: Error handling revealing sensitive info
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 揭露敏感信息的错误处理
- en: AI-generated error handling might print or return stack traces. For example,
    a Node.js API might catch an error and do `res.send(err.toString())`, which could
    leak internal details. Ensure that error messages to users are sanitized and logs
    are properly handled. Adjust as needed to avoid giving attackers clues like full
    error messages or file paths.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: AI生成的错误处理可能会打印或返回堆栈跟踪。例如，一个Node.js API可能会捕获错误并执行`res.send(err.toString())`，这可能会导致泄露内部细节。确保向用户传达的错误消息经过清理，并且日志得到适当处理。根据需要调整，以避免向攻击者提供如完整错误消息或文件路径之类的线索。
- en: Dependency management and updates
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项管理和更新
- en: 'If the AI adds dependencies (such as libraries) to your project, ensure that
    they’re up to date and from reputable sources. An AI might pick a library that
    was popular in its training data, but that is no longer maintained or has known
    vulnerabilities. For instance, if it suggests using an older version of a package,
    you should bump it to the latest stable. Running `npm audit` or equivalent after
    generation is wise too. Or ask the AI:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果AI向您的项目添加依赖项（如库），请确保它们是最新的且来自可信赖的来源。AI可能会选择在其训练数据中流行的库，但这些库可能不再维护或存在已知漏洞。例如，如果它建议使用较旧版本的包，您应该将其升级到最新稳定版。生成后运行`npm
    audit`或等效工具也是明智之举。或者询问AI：
- en: Is this library still maintained and secure?
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个库是否仍然得到维护且安全？
- en: It might not fully know, but it could tell you if there’s a known deprecation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能不完全清楚，但它可以告诉你是否存在已知的弃用。
- en: 'A 2023 large-scale analysis of GitHub Copilot in real-world projects revealed
    that as much as 25%–33% of generated code—depending on language—contained potential
    security weaknesses, including high-severity CWEs such as command injection, code
    injection, and [cross-site scripting](https://arxiv.org/abs/2310.02059). These
    findings underscore that Copilot reflects insecure patterns present in its training
    data, as opposed to intentionally producing flawed code. The consistent recommendation?
    Developers must stay alert: manually review AI-generated code, use security-aware
    tooling, and maintain strict code hygiene. Especially during “vibe coding,” the
    speed and scope of AI-generated content demand even more vigilance. More code
    in less time means more surface area to audit.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 2023年对GitHub Copilot在现实项目中的一次大规模分析揭示了，根据语言的不同，高达25%–33%的生成代码可能存在潜在的安全漏洞，包括命令注入、代码注入等严重程度高的CWEs（公共漏洞和暴露）。这些发现强调了Copilot反映了其训练数据中存在的安全模式，而不是有意生成有缺陷的代码。一致的推荐？开发者必须保持警惕：手动审查AI生成的代码，使用安全意识工具，并保持严格的代码卫生。特别是在“氛围编码”期间，AI生成内容的速度和范围需要更多的警惕。在更短的时间内编写更多代码意味着需要审计的表面区域更大。
- en: Let’s look at a short example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简短的例子。
- en: Improper Authentication and Authorization
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不恰当的认证和授权
- en: 'Imagine you ask an AI to create a login route in an Express app. It might produce
    something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下您要求AI在Express应用程序中创建一个登录路由。它可能会生成如下内容：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What are the issues here?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里存在哪些问题？
- en: It compares passwords directly, implying that the password is stored in plain
    text in the database—a big no-no.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它直接比较密码，这意味着密码以纯文本形式存储在数据库中——这是绝对不允许的。
- en: It sends very generic responses, which may be appropriate for security but could
    also inadvertently expose sensitive information.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它发送非常通用的响应，这可能对于安全性来说是合适的，但也可能无意中泄露敏感信息。
- en: Consider authentication  error messages as a critical example. A properly secure
    system should return a generic message like “Invalid credentials” when login fails,
    regardless of whether the username or password was incorrect. However, AI-generated
    code might produce more specific errors such as “Username not found” or “Incorrect
    password for this user.”
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑认证错误消息作为一个关键示例。一个安全得当的系统在登录失败时应该返回一个通用的消息，如“无效凭证”，无论用户名或密码是否错误。然而，AI生成的代码可能会产生更具体的错误，例如“用户名未找到”或“此用户的密码不正确。”
- en: These specific messages create a security vulnerability by confirming to potential
    attackers which piece of information they have correct. If an attacker receives
    “Incorrect password” as an error, they now know they have discovered a valid username
    in your system. This enables them to build a list of legitimate usernames through
    repeated attempts, then focus their efforts on cracking passwords for those confirmed
    accounts. This technique, known as *user enumeration*, transforms a guessing game
    into a more targeted attack. The AI’s tendency toward helpful, specific error
    messages inadvertently aids malicious actors unless you explicitly instruct it
    to maintain appropriately vague responses for security-sensitive operations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特定的消息通过确认潜在攻击者哪些信息是正确的，从而创建了一个安全漏洞。如果攻击者收到“密码错误”的错误信息，他们现在知道他们已经发现了系统中有效的用户名。这使得他们能够通过重复尝试构建一个合法用户名列表，然后集中精力破解这些已确认账户的密码。这种被称为*用户枚举*的技术，将猜测游戏转变为更具针对性的攻击。AI倾向于提供有帮助、具体的错误信息，除非你明确指示它为安全敏感操作保持适当模糊的响应，否则无意中帮助了恶意行为者。
- en: While it isn’t shown in the code, no rate limiting or other protections are
    included here.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码中没有显示，但这里没有包含速率限制或其他保护措施。
- en: 'A secure implementation would incorporate several critical safeguards:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个安全的实现将包含几个关键的安全措施：
- en: First and foremost, passwords should never be stored in plain text. Instead,
    the system should store cryptographically hashed passwords and use a secure comparison
    function to verify login attempts.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首要的是，密码绝不应该以明文形式存储。相反，系统应该存储经过加密散列的密码，并使用安全的比较函数来验证登录尝试。
- en: This comparison process must employ constant-time algorithms to prevent timing
    attacks, where attackers analyze response times to deduce information about password
    correctness. Many security-focused libraries provide these constant-time comparison
    functions specifically to address this vulnerability.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个比较过程必须使用恒定时间算法来防止时间攻击，攻击者通过分析响应时间来推断密码正确性的信息。许多以安全为重点的库提供这些恒定时间比较函数，专门用于解决这个漏洞。
- en: Additionally, the authentication system should implement rate limiting or throttling
    mechanisms to prevent brute-force attacks. Failed login attempts should be logged
    for security monitoring, allowing administrators to detect and respond to suspicious
    patterns. These measures work together to create a defense-in-depth approach that
    protects user credentials even if one security layer is compromised.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，认证系统应实施速率限制或节流机制，以防止暴力攻击。失败的登录尝试应记录在安全监控中，允许管理员检测并响应可疑模式。这些措施共同作用，创建了一种深度防御方法，即使在某个安全层被破坏的情况下也能保护用户凭据。
- en: 'You can ask AI to help fix this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以要求AI帮助修复这个问题：
- en: Improve the login route to use bcrypt to hash and compare passwords, and ensure
    the password in the database is hashed.
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 改善登录路由，使用bcrypt散列和比较密码，并确保数据库中的密码是散列的。
- en: 'It might then output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能输出：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is better: it uses `bcrypt` to compare against a hashed password (assuming
    the variable `user.passwordHash` stores that). When creating users, you’d also
    want to make sure to use `bcrypt.hash` to hash their passwords.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这更好：它使用`bcrypt`来比较散列密码（假设变量`user.passwordHash`存储了该密码）。在创建用户时，你还想确保使用`bcrypt.hash`来散列他们的密码。
- en: 'With a bit of guidance, the AI can do the right thing, but its initial naive
    output might well be insecure. This underscores the pattern: *review and refine*.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在一点指导之下，AI可以做到正确的事情，但它的初始天真输出可能并不安全。这强调了这样一个模式：*审查和改进*。
- en: Package Management Issues
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包管理问题
- en: Another common vulnerability category is package management. AI sometimes invents
    a library or misremembers a name, a problem known as *package hallucination*.
    Such a package might not exist, but an attacker could, theoretically, publish
    packages under commonly hallucinated names that contain malicious code. If you
    install such a package without confirming that it both exists and is the correct
    package, you could be introducing serious risk. If you’re not sure about a particular
    package, try a quick web search or check npm/PyPI directly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的漏洞类别是包管理。AI有时会发明一个库或忘记一个名称，这被称为*包幻觉*问题。这样的包可能不存在，但理论上，攻击者可以发布以常见幻觉名称为名的包含恶意代码的包。如果你在未确认该包存在且是正确包的情况下安装它，你可能会引入严重风险。如果你对某个特定包不确定，尝试快速网络搜索或直接检查npm/PyPI。
- en: Additionally, the AI might inadvertently produce code that is identical to a
    licensed snippet from training data. This is more an intellectual property concern
    than a security issue, but it warrants careful attention. GitHub Copilot, for
    instance, includes a duplicate detection feature that can flag when generated
    code closely matches public repositories, helping developers avoid potential licensing
    conflicts. Similar tools are emerging to address this specific challenge of AI-generated
    code provenance. [Chapter 9](ch09.html#ch09_the_ethical_implications_of_vibe_coding_1752630044848930)
    will delve into licensing and intellectual property considerations in more detail,
    providing comprehensive guidance on navigating these complex issues.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，AI 可能无意中生成与训练数据中授权片段相同的代码。这与其说是安全问题，不如说是知识产权问题，但它需要引起足够的重视。例如，GitHub Copilot
    包含一个重复检测功能，可以在生成的代码与公共存储库紧密匹配时发出警告，帮助开发者避免潜在的许可冲突。还有类似工具正在出现，以解决 AI 生成代码来源的特定挑战。[第
    9 章](ch09.html#ch09_the_ethical_implications_of_vibe_coding_1752630044848930)
    将更详细地探讨许可和知识产权问题，提供全面指导，帮助您应对这些复杂问题。
- en: 'In summary, the main message remains—and yes, I realize I’ve emphasized this
    point throughout the book to the point where you could probably recite it in your
    sleep—that *AI output requires the same careful review you would apply to a junior
    developer’s code*. The repetition is intentional, because this principle underpins
    virtually every aspect of safe and effective AI-assisted development. Whether
    you’re prototyping, building backends, or implementing security features, this
    mental model provides the right balance of trust and verification to make AI a
    powerful ally rather than a risky shortcut. It can write a lot of code fast, but
    you need to instill security best practices into it and double-check for vulnerabilities.
    Novelist Frank Herbert put it this way in an [often-quoted](https://oreil.ly/yr2B_)
    line from *God Emperor of Dune* (Putnam, 1981): “They increase the number of things
    we can do without thinking. Things we do without thinking—there’s the real danger.”'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，主要信息仍然如此——是的，我意识到我在整本书中都强调了这一点，以至于你可能几乎能在睡梦中背诵它——那就是 *AI 输出需要与审查初级开发人员代码相同的谨慎审查*。这种重复是有意的，因为这个原则几乎支撑着安全有效
    AI 辅助开发的各个方面。无论你是在进行原型设计、构建后端还是实现安全功能，这种思维模式提供了正确的信任和验证平衡，使 AI 成为一个强大的盟友而不是一个风险捷径。它可以快速编写大量代码，但你需要将其中的安全最佳实践内化，并双重检查漏洞。小说家弗兰克·赫伯特在《沙丘皇帝》（Putnam，1981年）中的一句经常被引用的话中这样说道：“它们增加了我们无需思考就能做的事情的数量。我们无需思考就能做的事情——这才是真正的危险。”
- en: Using AI can lull you into doing less thinking about routine code, and you should
    be consciously thinking about how to apply a security-review mindset. It’s crucial
    for catching those “things we can do without thinking.”
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AI 可能会让你在处理常规代码时减少思考，你应该有意识地思考如何应用安全审查的思维。捕捉那些“无需思考就能做的事情”至关重要。
- en: Security Audits
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全审计
- en: Given the types of vulnerabilities outlined, how can you effectively audit and
    secure our AI-generated code? This section looks at several techniques and tools
    you can employ.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 针对上述类型的漏洞，你如何有效地审计和确保我们生成的 AI 代码的安全性？本节探讨了你可以使用的几种技术和工具。
- en: Leverage Automated Security Scanners
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用自动化安全扫描器
- en: 'Static analysis tools (SASTs) can scan your code for known vulnerability patterns;
    for example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析工具（SASTs）可以扫描代码中的已知漏洞模式；例如：
- en: '[ESLint + security plug-ins](https://oreil.ly/55ppH) can detect insecure functions
    or unsanitized input in JavaScript and Node code.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ESLint + 安全插件](https://oreil.ly/55ppH) 可以检测 JavaScript 和 Node 代码中的不安全函数或未清理的输入。'
- en: '[Bandit](https://bandit.readthedocs.io) for Python can flag uses of assert
    in production, weak cryptography, hard-coded secrets, and more.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Bandit](https://bandit.readthedocs.io) 用于 Python，可以标记生产环境中 assert 的使用、弱加密、硬编码的秘密等。'
- en: '[GitHub CodeQL](https://github.com/github/codeql) lets you run queries across
    your codebase to find SQL injection, XSS, and other common patterns.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GitHub CodeQL](https://github.com/github/codeql) 允许你在代码库中运行查询，以查找 SQL 注入、XSS
    和其他常见模式。'
- en: '[Semgrep](https://semgrep.dev) has rules for many languages, including community-maintained
    ones for JavaScript, Python, Java, Go, and more, and can spot top issues out of
    the box.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Semgrep](https://semgrep.dev) 支持多种语言的规则，包括 JavaScript、Python、Java、Go 等社区维护的规则，并能直接识别出一些常见问题。'
- en: You can integrate these tools into your CI/CD or dev pipelines. Run them on
    your AI-generated code—it won’t catch everything, but it will probably flag the
    obvious mistakes (e.g., plain-text password checks, unsanitized SQL, insecure
    crypto). It’s a solid safety net.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些工具集成到你的CI/CD或开发管道中。在AI生成的代码上运行它们——它们不会捕捉到所有内容，但可能会标记出明显的错误（例如，明文密码检查、未清理的SQL、不安全的加密）。这是一个稳固的安全网。
- en: Use a Separate AI as a Reviewer
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用独立的AI作为审稿人
- en: 'Two distinct approaches can leverage AI for security review of generated code,
    each with unique advantages. The first involves using the same AI model that generated
    the code, asking it to switch perspectives and audit its own output. After generating
    code, you can prompt the model with something like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 两种不同的方法可以利用AI对生成的代码进行安全审查，每种方法都有其独特的优势。第一种方法涉及使用生成代码相同的AI模型，要求它转换视角并审计其输出。在生成代码后，你可以向模型提示如下内容：
- en: Review this code for security vulnerabilities and explain any issues you find.
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 审查此代码的安全漏洞，并解释你发现的问题。
- en: This approach often yields surprisingly effective results, as the model can
    identify common security problems such as plain-text password storage, missing
    input validation, or potential SQL injection vulnerabilities.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法往往会产生令人惊讶的有效结果，因为模型可以识别常见的安全问题，如明文密码存储、缺少输入验证或潜在的SQL注入漏洞。
- en: The second approach employs a different AI model as an independent reviewer.
    For instance, if you generated code using ChatGPT, you might paste that code into
    Claude or Gemini for security analysis. This cross-model review can surface different
    perspectives and catch issues the original model might have overlooked, much like
    how different security tools or human reviewers bring varying expertise and focus
    areas. Different models may have been trained with different emphases or datasets,
    potentially catching distinct categories of vulnerabilities.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法采用不同的AI模型作为独立的审稿人。例如，如果你使用ChatGPT生成了代码，你可以将那段代码粘贴到Claude或Gemini中进行安全分析。这种跨模型审查可以揭示不同的视角并捕捉到原始模型可能忽略的问题，就像不同的安全工具或人类审稿人带来不同的专业知识和关注领域一样。不同的模型可能被训练有不同的重点或数据集，可能捕捉到不同类别的漏洞。
- en: Both techniques serve as valuable additional layers of security review, complementing
    but never replacing proper security testing and human expertise. While AI reviewers
    may occasionally flag false positives or miss subtle vulnerabilities, they excel
    at catching common security antipatterns quickly. Think of this process as automated
    pair programming focused specifically on security considerations. The key lies
    in treating these AI-generated security reviews as another input to your security
    assessment process rather than as definitive security clearance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术都作为有价值的额外安全审查层，补充但不取代适当的安全测试和人类专业知识。虽然AI审稿人可能会偶尔标记出误报或错过细微的漏洞，但它们擅长快速捕捉常见的安全反模式。将这个过程视为专注于安全考虑的自动化结对编程。关键在于将这些AI生成的安全审查视为你安全评估过程中的另一个输入，而不是作为最终的安全许可。
- en: Perform a Human Code Review with a Security Checklist
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用安全清单进行人工代码审查
- en: 'If you’re in a team, have a checklist for reviewing code with an eye to security.
    AI often produces code that “works” for the expected case but isn’t hardened to
    deal with malicious cases. For AI-generated code, be sure to consider:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在团队中，应该有一个用于审查代码的安全清单。AI通常生成的代码在预期情况下“工作”，但并未针对恶意情况进行加固。对于AI生成的代码，务必考虑以下方面：
- en: 'Authentication flows: Are they solid?'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证流程：它们是否稳固？
- en: 'Any place data enters the system: Are we validating inputs?'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据进入系统的任何地方：我们是否验证了输入？
- en: 'Any place data leaves the system: Are we sanitizing outputs? Are we protecting
    sensitive data?'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据离开系统的任何地方：我们是否清理了输出？我们是否保护了敏感数据？
- en: 'Use of external APIs: Are we handling failures? Are we exposing keys?'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部API的使用：我们是否处理了失败？我们是否暴露了密钥？
- en: 'Database access: Are we using ORMs safely? Are we using parameterized queries?'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库访问：我们是否安全地使用ORM？我们是否使用参数化查询？
- en: 'Memory management in low-level code: If AI is writing C/C++ or Rust, are there
    overflows? Is there any misuse?'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低级代码中的内存管理：如果AI正在编写C/C++或Rust，是否存在溢出？是否存在任何滥用？
- en: Penetration Testing and Fuzzing
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渗透测试和模糊测试
- en: Use dynamic approaches. For fuzz testing, feed random or specially crafted inputs
    into your functions or endpoints to see if they break or do weird things. AI can
    help generate fuzz cases, or you can use [existing fuzz tools](https://oreil.ly/OoFzT),
    such as [OSS Fuzz by Google](https://oreil.ly/FvKSU).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态方法。对于模糊测试，将随机或特别定制的输入喂入你的函数或端点，以查看它们是否会崩溃或做奇怪的事情。AI可以帮助生成模糊案例，或者你可以使用[现有的模糊工具](https://oreil.ly/OoFzT)，例如[谷歌的OSS
    Fuzz](https://oreil.ly/FvKSU)。
- en: Running penetration-testing tools like OWASP’s ZAP against your AI-made web
    app can automate scanning for things like XSS and SQL injection vulnerabilities.
    For example, ZAP might attempt to inject a script and get it reflected, and detect
    that a certain input isn’t sanitized.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的AI制作的Web应用上运行像OWASP的ZAP这样的渗透测试工具，可以自动化扫描诸如XSS和SQL注入漏洞等问题。例如，ZAP可能会尝试注入一个脚本并使其反射，并检测到某些输入没有被清理。
- en: 'If you’re building an API, tools like Postman or custom scripts can try sending
    ill-formed data to see how the system behaves: does it throw a 500 error or handle
    errors gracefully?'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建一个API，可以使用Postman或自定义脚本等工具尝试发送格式不正确的数据，以查看系统如何响应：是否会抛出500错误或优雅地处理错误？
- en: Add Security-Focused Unit Tests
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加以安全为重点的单元测试
- en: For critical pieces of code, write tests that assert security properties. For
    instance, you might test that your login rate limiter triggers after X bad attempts,
    or that certain inputs (like `"<script>alert(1)</script>"`) come out escaped in
    the response. To test that unauthorized users cannot access a protected resource,
    simulate both authorized and unauthorized calls and ensure the app behaves correctly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关键代码片段，编写断言安全属性的测试。例如，你可能测试你的登录速率限制器在X次失败尝试后触发，或者某些输入（如`"<script>alert(1)</script>"`）在响应中输出时被转义。为了测试未经授权的用户无法访问受保护资源，模拟授权和未经授权的调用，并确保应用程序的行为正确。
- en: 'You can ask the AI to help generate these tests:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以要求AI帮助生成这些测试：
- en: Write tests to ensure an unauthorized user gets 403 on the /deleteUser endpoint.
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写测试以确保未经授权的用户在/deleteUser端点上收到403错误。
- en: And then run the tests.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行测试。
- en: Provide Updates to Compensate for Training Cutoffs
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供更新以补偿训练截止点
- en: 'AI models possess a fundamental limitation that directly impacts security:
    their knowledge freezes at a specific point in time. When a model completes training,
    it cannot learn about vulnerabilities discovered afterward, security patches released
    subsequently, or new best practices that emerge. This knowledge cutoff creates
    a critical gap between what the AI knows and current security standards.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: AI模型具有一个直接影响安全的根本性限制：它们的知识在某个时间点冻结。当模型完成训练后，它无法了解之后发现的漏洞、随后发布的安全补丁或出现的新最佳实践。这种知识截止点在AI所知和当前安全标准之间造成了关键差距。
- en: Consider a model trained in 2023 generating code in 2025\. During those intervening
    years, numerous security vulnerabilities have been discovered, patched, and documented.
    New attack vectors have emerged, frameworks have added security features, and
    best practices have evolved. The AI, however, remains unaware of these developments
    unless you explicitly provide updated information within your prompts.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在2023年训练的模型在2025年生成代码。在这段时间里，发现了许多安全漏洞，进行了修补和记录。新的攻击向量出现，框架增加了安全功能，最佳实践也发生了演变。然而，AI除非你明确在提示中提供更新信息，否则对这些发展一无所知。
- en: This limitation becomes particularly acute with rapidly evolving security standards
    and vulnerability databases. The [OWASP Top 10](https://oreil.ly/US-uh), for instance,
    undergoes periodic updates to reflect the changing threat landscape. If you prompt
    an AI to “write a secure file upload function,” it might implement reasonable
    protections based on its training data—perhaps including file type validation,
    size limits, and storage outside the web root. However, it could miss recently
    discovered attack vectors or fail to implement newly recommended mitigations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制在快速发展的安全标准和漏洞数据库中尤其明显。例如，[OWASP Top 10](https://oreil.ly/US-uh)会定期更新，以反映不断变化的威胁环境。如果你提示AI“编写一个安全的文件上传函数”，它可能会根据其训练数据实施合理的保护——可能包括文件类型验证、大小限制和存储在Web根目录之外。然而，它可能会错过最近发现的攻击向量或未能实施新推荐缓解措施。
- en: 'The solution involves actively supplementing the AI’s knowledge with current
    security information. When requesting security-sensitive code, include references
    to current best practices in your prompts. For example, rather than simply asking
    for secure code, you might prompt:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案涉及积极补充AI的知识，以当前的安全信息。在请求安全敏感的代码时，在您的提示中包含对当前最佳实践的引用。例如，您可能不会仅仅要求安全的代码，而是可能会提示：
- en: Write a file upload function that addresses the security concerns in the 2025
    OWASP Top 10, particularly focusing on injection attacks and server-side request
    forgery.
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个文件上传函数，解决2025年OWASP Top 10中的安全关注点，特别是关注注入攻击和服务器端请求伪造。
- en: This approach grounds the AI’s response in current security standards rather
    than potentially outdated training data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将AI的响应建立在当前的安全标准上，而不是可能过时的训练数据。
- en: Similarly, framework-specific security features often emerge after an AI’s training
    cutoff. Express.js applications, for instance, benefit significantly from the
    [Helmet middleware](https://oreil.ly/WSPar) for setting security headers. An AI
    trained before Helmet became standard practice might generate Express applications
    without this crucial security layer. By explicitly mentioning current security
    tools and practices in your prompts, you help the AI generate code that aligns
    with contemporary security standards rather than historical ones.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，框架特定的安全功能通常在AI的训练截止日期之后出现。例如，Express.js应用程序从[Helmet中间件](https://oreil.ly/WSPar)中受益匪浅，该中间件用于设置安全头。在Helmet成为标准实践之前训练的AI可能会生成没有这个关键安全层的Express应用程序。通过在提示中明确提及当前的安全工具和实践，您帮助AI生成与当代安全标准相符合的代码，而不是历史标准。
- en: Optimize Your Logging Practices
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化您的日志记录实践
- en: Ensure that the code (AI and human) has good logging, especially around critical
    operations or potential failure points. This helps in debugging issues in production.
    If an AI wrote a section with minimal logs, consider adding more. For example,
    if there’s an AI-generated catch block that just swallows an error, change it
    to log the error (and maybe some context) for visibility. Also, sanitize the logs
    so they contain no sensitive info.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 确保代码（AI和人类）有良好的日志记录，尤其是在关键操作或潜在的故障点周围。这有助于在生产中调试问题。如果AI编写了一个日志记录很少的部分，考虑添加更多。例如，如果有一个AI生成的捕获块只是吞咽错误，将其更改为记录错误（以及可能的一些上下文）以提高可见性。此外，清理日志，确保它们不包含任何敏感信息。
- en: Use Updated Models or Tools with a Security Focus
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用具有安全重点的更新模型或工具
- en: 'Some AI coding tools aim to blend code generation with built-in security scanning.
    Snyk is a prime example: it uses a [hybrid approach](https://oreil.ly/0ZGFv) combining
    LLM-generated suggestions with rule-based taint analysis. According to Snyk, when
    you request code (even from LLM libraries like OpenAI, Anthropic, or Hugging Face),
    Snyk Code tracks potentially unsafe data flows and flags untrusted inputs before
    they reach sensitive sinks. In practice, that means if an AI suggests a database
    query, Snyk ensures it’s parameterized, preventing SQL injection—even if you forget
    to do so yourself. This kind of tool is particularly useful because it works to
    avoid introducing insecure code through AI-generated suggestions.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些AI编码工具旨在将代码生成与内置的安全扫描相结合。Snyk是一个典型的例子：它采用[混合方法](https://oreil.ly/0ZGFv)，结合LLM生成的建议和基于规则的污点分析。根据Snyk的说法，当您请求代码（即使是来自OpenAI、Anthropic或Hugging
    Face等LLM库的代码）时，Snyk Code跟踪潜在的不安全数据流，并在它们到达敏感的汇点之前标记不受信任的输入。在实践中，这意味着如果AI建议一个数据库查询，Snyk确保它是参数化的，防止SQL注入——即使您自己忘记这样做。这类工具特别有用，因为它通过避免通过AI生成的建议引入不安全代码。
- en: Pay Attention to Warnings in Context
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注意上下文中的警告
- en: If you’re using an IDE, often you’ll see warnings or squiggly lines to highlight
    suspicious code. Modern IDEs with IntelliSense can sometimes catch, for instance,
    a string concatenation of SQL that looks suspicious. Don’t ignore those warnings
    and flags just because the AI writes them—address the issue. The AI doesn’t have
    the benefit of those real-time warnings when generating the code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是IDE，您通常会看到警告或波浪线来突出可疑代码。具有IntelliSense的现代IDE有时可以捕获，例如，看起来可疑的SQL字符串连接。不要因为AI编写了这些警告和标志就忽略它们——解决问题。AI在生成代码时没有这些实时警告的优势。
- en: Slow Down
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 放慢速度
- en: After using AI to generate a lot of code quickly, shift gears and *slow down*
    when it’s time for auditing. When you can produce features fast, it’s tempting
    to chase the next one, but schedule time for a thorough review. Think of it as
    “AI-accelerated development, human-accelerated security.” Snyk’s [best practices](https://oreil.ly/uUExW)
    recommend scanning AI code right in the IDE, and caution against letting AI’s
    speed outpace your security checks. In other words, integrate security scanning
    into your dev loop, so you can catch vulnerabilities as soon as the code is written.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用人工智能快速生成大量代码之后，当审计时间到来时，要放慢速度。当你能够快速生成功能时，追逐下一个功能是有诱惑力的，但请安排时间进行彻底的审查。将其视为“人工智能加速开发，人类加速安全”。Snyk的[最佳实践](https://oreil.ly/uUExW)建议在IDE中直接扫描人工智能代码，并警告不要让人工智能的速度超过你的安全检查。换句话说，将安全扫描集成到你的开发循环中，以便在代码编写后立即发现漏洞。
- en: In summary, when you audit AI-generated code, you’ll use many of the same tools
    you use in traditional development—static analysis, dynamic testing, code review—but
    you might apply them more frequently, because code is produced more quickly. *Treat
    every AI output as needing inspection*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当你审计人工智能生成的代码时，你会使用许多在传统开发中使用的相同工具——静态分析、动态测试、代码审查——但你可能需要更频繁地应用它们，因为代码生成速度更快。*将每个人工智能输出视为需要检查*。
- en: Building Effective Testing Frameworks for AI-Generated Systems
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为人工智能生成系统构建有效的测试框架
- en: While security forms one pillar of reliability, the broader concept encompasses
    the fundamental dependability of your software system. *Reliability*, in software
    architecture terms, addresses critical questions about system failure and its
    consequences. Does your system need to be fail-safe? Is it mission critical in
    ways that could affect human lives or safety? If the system fails, will it result
    in significant financial losses for your organization? These considerations determine
    the rigor required in your development and testing practices.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然安全性是可靠性的一个支柱，但更广泛的概念涵盖了你的软件系统的基本可靠性。*可靠性*在软件架构术语中，解决了关于系统故障及其后果的关键问题。你的系统是否需要是故障安全的？它是否在影响人类生活或安全的方式上是至关重要的？如果系统失败，是否会对你组织的财务造成重大损失？这些考虑决定了你在开发和测试实践中所需的严谨性。
- en: When you’re building with AI assistance, these reliability stakes remain unchanged.
    A banking application generated with AI assistance carries the same requirements
    for transaction accuracy and data integrity as one written entirely by humans.
    A healthcare system must meet identical standards for patient safety regardless
    of how its code originated. The AI’s involvement in code generation does not diminish
    these fundamental reliability requirements.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在人工智能辅助下进行构建时，这些可靠性风险仍然保持不变。使用人工智能辅助生成的银行应用程序与完全由人类编写的应用程序一样，对交易准确性和数据完整性有相同的要求。无论其代码的来源如何，医疗系统都必须满足相同的患者安全标准。人工智能在代码生成中的参与并不会降低这些基本可靠性要求。
- en: This reality underscores why comprehensive testing becomes even more critical
    in AI-assisted development. A strong testing framework ensures that your code
    performs its intended functions correctly and maintains that correctness as the
    project evolves. While testing AI-generated code follows the same fundamental
    principles as testing human-written code, certain nuances and opportunities emerge
    from the AI development process that warrant specific attention.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种现实强调了为什么在人工智能辅助开发中，全面的测试变得更加关键。强大的测试框架确保你的代码正确执行其预期功能，并在项目演变过程中保持这种正确性。虽然测试人工智能生成的代码遵循与测试人类编写的代码相同的根本原则，但人工智能开发过程中出现了一些细微差别和机会，值得特别注意。
- en: The following sections explore how to leverage AI not just in generating code
    but in creating robust test suites that validate reliability, maintain system
    stability, and provide confidence that your software will perform correctly when
    the stakes are highest.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分探讨了如何利用人工智能不仅生成代码，而且创建健壮的测试套件来验证可靠性、维护系统稳定性和提供信心，即当风险最高时，你的软件将正确执行。
- en: First, embrace automated testing early and often. It’s easy to skip writing
    tests when development is slow because you want to push features. Ironically,
    when development is *fast* (with AI), it’s *also* easy to skip tests, because
    new features keep coming at you. But when code is churned out rapidly, that’s
    precisely when you most need tests to catch regression or integration issues.
    So after implementing a feature with AI help, get into the habit of immediately
    writing tests for it (or even using AI to write those tests). This verifies the
    feature and also guards it as you change things later.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尽早并经常拥抱自动化测试。当开发进度缓慢时，你可能会跳过编写测试，因为你想要推动新功能的开发。讽刺的是，当开发速度加快（使用AI）时，跳过测试也变得容易，因为新功能不断涌现。但是，当代码快速生成时，这正是你最需要测试来捕捉回归或集成问题的时刻。因此，在使用AI帮助实现功能后，养成立即为其编写测试的习惯（甚至可以使用AI来编写这些测试）。这不仅可以验证功能，还可以在后续更改时保护它。
- en: A [2022 study](https://oreil.ly/Vc8Gd) found that developers who were using
    an AI assistant were *more confident* in the security of the code they wrote even
    when it was objectively less secure than code written by those without AI assistance.
    You need to counteract that overconfidence with actual tests.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一项[2022年的研究](https://oreil.ly/Vc8Gd)发现，使用AI助手的开发者对他们所编写的代码的安全性更有信心，即使从客观上讲，这些代码的安全性不如没有AI辅助的代码。你需要通过实际测试来对抗这种过度自信。
- en: 'As I noted in [Chapter 4](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362),
    you can use the AI not just to generate the code but also to produce a suite of
    tests. This way, AI helps double-check itself. It’s like having it do both the
    implementation and an initial pass at validation. For example, after writing a
    new module, you could ask:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第4章](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362)中提到的，你可以使用AI不仅来生成代码，还可以生成一系列测试。这样，AI可以帮助自我双重检查。这就像让它同时进行实现和初步验证。例如，在编写一个新的模块后，你可以这样问：
- en: Write unit tests for this module, covering edge cases.
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为此模块编写单元测试，覆盖边缘情况。
- en: If they pass, great. If they fail, either there’s a bug or the tests expected
    something else. Investigate and fix either code or test as appropriate.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们通过了，那很好。如果失败了，要么是有错误，要么是测试期望了其他内容。根据需要调查并修复代码或测试。
- en: Be cautious that the AI may assume some output or behavior incorrectly; treat
    its tests, like its code, as suggestions, not the ground truth. You might need
    to adjust the test’s expectations to match the intended behavior—but even that
    process is valuable, because it forces you to define the intended behavior clearly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎地对待AI可能错误地假设某些输出或行为；像对待其代码一样，将其测试视为建议，而不是事实。你可能需要调整测试的期望以匹配预期的行为——即使这个过程也是有价值的，因为它迫使你清楚地定义预期的行为。
- en: 'Incorporate your test suite into a CI pipeline that runs on every commit. This
    way, whenever AI-generated code is added or changed, all tests run automatically.
    If something breaks, you’ll catch it early. Sometimes AI might introduce subtle
    breaking changes (like changing a function signature or output format slightly),
    and a robust test suite will detect that. Include security scans in the CI too
    (like `npm audit` or static analysis) so that any new introduction of a risky
    pattern is flagged. Types of tests to try include:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的测试套件集成到每次提交时运行的CI管道中。这样，每当添加或更改AI生成的代码时，所有测试都会自动运行。如果出现问题，你将能够及早发现。有时AI可能会引入微妙的破坏性更改（如稍微改变函数签名或输出格式），一个健壮的测试套件将能够检测到这一点。在CI中还包括安全扫描（如`npm
    audit`或静态分析），以便任何引入的风险模式都会被标记出来。可以尝试的测试类型包括：
- en: Property-based testing and fuzzing
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试和模糊测试
- en: '*Property-based testing* (with tools like [Hypothesis for Python](https://oreil.ly/JcYBf)
    or [fast-check for JavaScript](https://fast-check.dev)) is another valuable technique.
    Instead of writing individual test cases with specific inputs and expected outputs,
    you define high-level properties that your code should always satisfy. The framework
    then generates a wide range of inputs to check whether those properties hold.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于属性的测试*（使用像[Python的Hypothesis](https://oreil.ly/JcYBf)或[JavaScript的fast-check](https://fast-check.dev)这样的工具）是另一种有价值的技巧。你不需要为特定的输入和预期输出编写单个测试用例，而是定义代码应该始终满足的高级别属性。然后，框架会生成广泛范围的输入来检查这些属性是否成立。'
- en: 'Take sorting as an example. Rather than asserting that `sort([3, 1, 2]) ===
    [1, 2, 3]`, you can define properties:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以排序为例。与其断言`sort([3, 1, 2]) === [1, 2, 3]`，你可以定义属性：
- en: The output should be in order
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出应该是有序的
- en: It should contain the same elements as the input
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该包含与输入相同的元素
- en: The tool then generates dozens or hundreds of input arrays to test those conditions—and
    finds edge cases you might not think of manually.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 工具随后会生成数十或数百个输入数组来测试这些条件——并发现您可能没有手动想到的边缘情况。
- en: This can be especially useful for AI-generated code. If your AI writes a function
    to normalize email addresses (such as by lowercasing the domain), a property test
    might check that the output is *idempotent*—meaning running the function twice
    gives the same result as running it once. If an edge case violates that invariant,
    the test framework will generate a counterexample to help you diagnose the bug.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于人工智能生成的代码尤其有用。如果您的AI编写了一个用于规范化电子邮件地址（例如，通过将域名转换为小写）的函数，属性测试可能会检查输出是否是*幂等的*——这意味着运行函数两次与运行一次得到相同的结果。如果边缘情况违反了这个不变性，测试框架将生成一个反例来帮助您诊断错误。
- en: Load and performance testing
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和性能测试
- en: AI might write code that’s not optimized. It’s a good idea to test your system
    under load. This is reliability in terms of performance. Use tools like JMeter,
    Locust, or k6 to simulate many requests or heavy data and see if the system holds
    up. If not, identify the bottlenecks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能可能编写未优化的代码。在负载下测试您的系统是个好主意。这在性能方面是可靠性的体现。使用JMeter、Locust或k6等工具模拟大量请求或大量数据，看看系统是否能够承受。如果不能，找出瓶颈。
- en: For instance, maybe the AI writes a naive `O(n^2)` algorithm that works fine
    on 100 items but will tank at 10,000\. Without performance tests, you might not
    notice that until it’s in production. So incorporate some performance scenarios,
    if applicable. Time some critical operations with increasing input sizes, or use
    profiling tools to see where CPU time or memory goes for heavy tasks.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，也许人工智能编写了一个在100个元素上运行良好的`O(n^2)`算法，但在10,000个元素上会崩溃。如果没有性能测试，您可能直到它投入生产时才注意到这一点。因此，如果适用，结合一些性能场景。随着输入大小的增加，对关键操作进行计时，或使用分析工具查看CPU时间或内存消耗在重任务中的位置。
- en: Error handling
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Intentionally cause errors to ensure the system responds gracefully, such as:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 故意引入错误以确保系统能够优雅地响应，例如：
- en: For an API, shut down the database and see if the API returns a friendly error
    or crashes. If it crashes, add code (or ask AI to add code) to handle DB connection
    errors.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于API，关闭数据库并查看API是否返回友好的错误或崩溃。如果它崩溃，添加代码（或要求人工智能添加代码）来处理数据库连接错误。
- en: For the frontend, simulate the backend returning 500 errors and ensure the UI
    shows an error message, not a blank page or infinite spinner.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于前端，模拟后端返回500错误，并确保UI显示错误消息，而不是空白页面或无限加载指示器。
- en: AI might not think of these failure modes on its own when writing code, so you
    have to test them and then refine. Testing these scenarios will improve reliability
    by prompting you to add proper fallback logic, retries, or user feedback.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能在编写代码时可能不会自己想到这些故障模式，因此您必须测试它们并加以改进。测试这些场景将通过提示您添加适当的回退逻辑、重试或用户反馈来提高可靠性。
- en: Monitoring and logging
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 监控和日志记录
- en: Incorporate logging and perhaps use the logs in tests for verification. For
    instance, if a certain action should trigger an audit log entry, test for that.
    AI can generate log lines; verify they print out as expected.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 结合日志记录，并在测试中可能使用日志进行验证。例如，如果某个操作应该触发审计日志条目，进行测试。人工智能可以生成日志行；验证它们是否按预期打印出来。
- en: Also, think about setting up monitoring (like an in-memory simulation of how
    your service will be monitored in production). For example, you might track if
    any uncaught exceptions are logged during test runs. If yes, treat it as a test
    failure; that means there’s some case not properly handled.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，考虑设置监控（例如，模拟在生产中如何监控您的服务）。例如，您可能需要跟踪测试运行期间是否记录了任何未捕获的异常。如果是，将其视为测试失败；这意味着某些情况没有得到妥善处理。
- en: Maintainability
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性
- en: Maintainability testing, like ensuring code style and standards, is important.
    Use linters and formatters to keep code consistent, since AI can produce slightly
    different styles from different prompts. A formatting tool like [Prettier](https://prettier.io)
    or [Black (for Python)](https://pypi.org/project/black) can unify style. For more
    logical consistency and to catch overly complex AI-generated code that might need
    refactoring, consider adding linting rules that enforce things like function complexity
    limits. (See [“Ensuring Maintainability in AI-Accelerated Codebases”](#ch08_ensuring_maintainability_in_ai_accelerated_codebas_1752630044622595)
    for more.)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 维护性测试，如确保代码风格和标准，非常重要。使用linters和formatters来保持代码一致性，因为AI可能会根据不同的提示产生略微不同的风格。一个格式化工具，如[Prettier](https://prettier.io)或[Black
    (for Python)](https://pypi.org/project/black)，可以统一风格。为了获得更多逻辑一致性，并捕捉可能需要重构的过于复杂的AI生成代码，考虑添加强制执行诸如函数复杂度限制之类的规则的linting规则。（更多信息请参阅[“确保AI加速代码库的可维护性”](#ch08_ensuring_maintainability_in_ai_accelerated_codebas_1752630044622595)）
- en: 'Once your tests are in place, you can refactor AI code more confidently. Perhaps
    the AI produces a working but clunky solution; you can improve it and rely on
    tests to ensure you haven’t broken its behavior. You might even ask AI to refactor
    its own code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的测试就绪，你就可以更有信心地重构AI代码。也许AI产生了一个工作但笨拙的解决方案；你可以改进它，并依靠测试来确保你没有破坏其行为。你甚至可以要求AI重构它自己的代码：
- en: Refactor this function for clarity while keeping it passing the current tests.
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重构这个函数以使其更清晰，同时确保它通过当前的测试。
- en: If your tests are good, you can check that the refactoring didn’t break anything.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的测试做得好，你可以检查重构是否破坏了任何东西。
- en: Understanding nondeterminism in AI systems requires distinguishing between two
    fundamentally different scenarios. When AI operates at runtime in production systems,
    such as a chatbot responding to customer queries or a recommendation engine personalizing
    content, the outputs can vary even with identical inputs. This variability stems
    from factors like model temperature settings, random seeds, or evolving model
    states. Testing such systems requires specialized approaches that account for
    acceptable variation ranges rather than expecting exact matches.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 理解AI系统中的非确定性需要区分两种根本不同的场景。当AI在生产系统中运行时，例如聊天机器人响应客户查询或推荐引擎个性化内容，即使输入相同，输出也可能不同。这种可变性源于模型温度设置、随机种子或演变的模型状态等因素。测试此类系统需要专门的方案，这些方案考虑了可接受的变异范围，而不是期望精确匹配。
- en: However, AI-assisted code generation presents a different paradigm entirely.
    Once an AI generates code and that code is committed to your repository, it becomes
    as deterministic as any human-written code. The function that calculates tax rates
    will produce the same output for the same input every time, regardless of whether
    a human or AI originally wrote it. This determinism is crucial for system reliability
    and makes traditional testing approaches entirely applicable to AI-generated code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，AI辅助的代码生成完全是一种不同的范式。一旦AI生成代码并将其提交到你的仓库，它就变得和任何人类编写的代码一样确定。计算税率的功能将每次对相同的输入产生相同的输出，无论最初是人为编写还是AI编写。这种确定性对于系统可靠性至关重要，使得传统的测试方法完全适用于AI生成的代码。
- en: The more subtle challenge emerges when integrating multiple AI-generated components,
    each potentially created in isolation with different implicit assumptions. Consider
    a concrete example from an ecommerce system. You might prompt an AI to generate
    an order processing module, instructing it to handle international orders. Separately,
    you ask the AI to create a shipping calculation service for the same system. The
    order processing module, following American conventions, formats dates as “12/25/2024”
    for December 25\. Meanwhile, the shipping service, perhaps influenced by European
    examples in its generation, expects dates formatted as “25/12/2024.” Both components
    function perfectly in isolation, passing their individual unit tests.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当集成多个AI生成的组件时，每个组件可能都是独立创建的，具有不同的隐含假设，这时会浮现出更微妙挑战。考虑一个来自电子商务系统的具体例子。你可能会提示AI生成一个订单处理模块，指示它处理国际订单。单独地，你要求AI为同一系统创建一个运输计算服务。订单处理模块遵循美国惯例，将日期格式化为“12/25/2024”表示12月25日。而运输服务，可能受到其生成过程中欧洲示例的影响，期望日期格式化为“25/12/2024”。这两个组件在独立运行时都表现完美，通过了各自的单元测试。
- en: The mismatch only surfaces during integration testing when the order processor
    passes a date to the shipping calculator. The shipping service interprets “12/01/2024”
    as January 12 rather than December 1, potentially calculating shipping times based
    on the wrong month entirely. This type of assumption mismatch is particularly
    common with AI-generated components because the AI might draw from different examples
    or conventions when generating each piece independently. Comprehensive integration
    testing that exercises the actual data flow between components becomes essential
    for catching these subtle incompatibilities before they cause production failures.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不匹配只有在集成测试期间才会显现出来，当订单处理程序将日期传递给运输计算器时。运输服务将“12/01/2024”解释为1月12日而不是12月1日，可能会基于错误的月份计算运输时间。这种假设不匹配在AI生成的组件中尤其常见，因为AI在独立生成每个部分时可能会从不同的示例或惯例中汲取灵感。进行全面的集成测试，以锻炼组件之间的实际数据流，对于在它们导致生产故障之前捕捉这些细微的不兼容性至关重要。
- en: The QA process for AI-assisted projects might require a bit more creativity,
    since AI can introduce unusual edge cases. For instance, an AI might output a
    feature you didn’t explicitly consider—if so, test that as well. If it added a
    hidden behavior, either remove it or properly test it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AI辅助项目的QA流程可能需要更多的创造性，因为AI可能会引入不寻常的边缘情况。例如，AI可能会输出你未明确考虑的功能——如果是这样，也要测试这一点。如果它添加了隐藏的行为，要么移除它，要么正确地测试它。
- en: Finally, if possible, test your application in an environment similar to production,
    with a realistic data load. Sometimes performance issues only appear with larger
    data volumes or higher concurrency. Use those test results to pinpoint inefficiencies.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果可能的话，在类似生产环境的环境中测试你的应用程序，使用真实的数据负载。有时只有在更大的数据量或更高的并发性下才会出现性能问题。使用这些测试结果来定位低效之处。
- en: Performance Optimization
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能优化
- en: While the AI often writes correct code, it may not always write *optimal* code.
    LLMs don’t inherently do performance analysis; they typically reproduce what is
    common in their training data. Therefore, be vigilant about potential performance
    issues, especially in critical paths or for large-scale use.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管AI经常编写正确的代码，但它并不总是编写**最优**的代码。大型语言模型（LLMs）本身并不进行性能分析；它们通常复制其在训练数据中常见的模式。因此，对潜在的性能问题保持警惕，尤其是在关键路径或大规模使用时。
- en: 'You can even chat with the AI for hints about performance optimization:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以与AI聊天，获取有关性能优化的提示：
- en: What is the complexity of this code? Can it be improved?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码的复杂度是多少？可以改进吗？
- en: This function is slow—any ideas on how to make it faster?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数运行得很慢——有没有什么办法让它更快？
- en: It might not always be right, but it can sometimes give useful suggestions or
    at least confirm your thinking.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能并不总是正确，但有时它可以提供有用的建议，或者至少确认你的思考。
- en: 'That said, don’t overoptimize, and don’t optimize prematurely or where it’s
    not needed. Sometimes the AI solution is perfectly fine, if the data sizes are
    small or the operation infrequent. Use your profiling data to focus on real bottlenecks
    and optimize the parts that really need it. The advantage of vibe coding is that
    you haven’t spent a ton of time handcrafting code from scratch, so you can afford
    to let some noncritical parts be simple and not superoptimized, as long as they
    don’t impact user experience or cost. This approach aligns with agile practices:
    make it work, then make it fast (if needed).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，不要过度优化，也不要过早或在不必要的地方进行优化。有时，如果数据量小或操作不频繁，AI解决方案可能完全没问题。使用你的分析数据来关注真正的瓶颈，并优化真正需要优化的部分。Vibe编码的优势在于你并没有花费大量时间从头开始手工编写代码，因此你可以允许一些非关键部分简单且不是超级优化，只要它们不影响用户体验或成本。这种方法与敏捷实践相一致：先让它工作，然后再让它变得更快（如果需要）。
- en: 'Here are some areas to cover as you ensure your AI-augmented project runs efficiently:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保你的AI增强项目高效运行时，以下是一些需要覆盖的区域：
- en: Complexity analysis
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性分析
- en: 'When the AI generates an algorithm, take a moment to consider its complexity.
    Sometimes it will use a brute-force solution where a more efficient algorithm
    exists. For example, it might double-sort a list because it didn’t recall a single-step
    method, resulting in O(n log n × 2) where O(n log n) could do (the capital *O*
    stands for memory usage). Or it might use nested loops that make an operation
    O(n²) when there’s a known O(n) approach. If you spot something like that, ask
    for improvements:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当AI生成算法时，花点时间考虑其复杂性。有时它可能会使用暴力解法，尽管存在更有效的算法。例如，它可能会对列表进行双重排序，因为它没有回忆起单步方法，导致O(n
    log n × 2)，而O(n log n)就可以做到（大写*O*代表内存使用）。或者它可能会使用嵌套循环，使得操作达到O(n²)，而存在已知的O(n)方法。如果你发现类似的情况，请要求改进：
- en: Can we optimize this to avoid nested loops? Perhaps use a set for lookups.
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们能否优化以避免嵌套循环？也许可以使用集合进行查找。
- en: The AI often will oblige and give a better solution if you hint at the approach.
    If not, you might have to implement that part manually.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你暗示了方法，AI通常会遵从并给出更好的解决方案。如果没有，你可能需要手动实现那部分。
- en: 'To identify slow functions, run a profiler or measure execution time of key
    code paths with representative or worst-case data. If something is too slow, you
    can attempt to optimize manually or with AI assistance:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别慢速函数，运行分析器或使用代表性或最坏情况数据测量关键代码路径的执行时间。如果某些操作太慢，你可以尝试手动或使用AI辅助进行优化：
- en: Optimize this function, which is currently a bottleneck; try to reduce its complexity.
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 优化这个当前作为瓶颈的功能；尽量减少其复杂性。
- en: The AI might restructure the code for performance. Use tests to make sure it
    still works.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: AI可能会为了性能重构代码。使用测试来确保它仍然可以工作。
- en: For critical algorithms, write a small benchmark harness. If AI gives you a
    piece of code to, say, compute something, test it against another approach, or
    at least measure how it scales with input size. You might decide to rewrite in
    a more efficient way if needed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关键算法，编写一个小型基准测试套件。如果AI给你一段代码，比如计算某个东西，测试它与其他方法，或者至少测量它随着输入大小的扩展情况。如果需要，你可能决定以更有效的方式重写。
- en: Memory usage, leaks, and retention
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 内存使用、泄漏和保留
- en: 'AI-generated solutions might use more memory than necessary: reading entire
    files into memory instead of streaming, for example, and thus holding large data
    structures. If your use case involves big data, check your system’s memory usage
    and optimize by streaming or chunking if needed. For instance, if you need to
    process millions of records, you’d want to refactor your AI-generated function
    `loadAllRecords()` to process them in batches or stream from the database.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: AI生成的解决方案可能比必要的使用更多内存：例如，将整个文件读入内存而不是流式传输，从而保留大量数据结构。如果你的用例涉及大数据，检查系统的内存使用情况，并在需要时通过流式传输或分块进行优化。例如，如果你需要处理数百万条记录，你希望重构AI生成的函数`loadAllRecords()`以批量处理它们或从数据库中流式传输。
- en: Also check that the AI-generated code is releasing resources. In languages like
    Java or C#, maybe it opens a file or DB connection and doesn’t close it. In a
    frontend single-page app, maybe event listeners aren’t removed, leading to leaks.
    Tools can help (like Chrome dev tools’ Memory Inspector for frontends or Valgrind
    for C++ leaks), but often just reading the code helps. Identify these and fix
    them. If you see an open file handle not closed, add a close in a `finally` block.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 还要检查AI生成的代码是否释放了资源。在像Java或C#这样的语言中，可能它打开了一个文件或数据库连接而没有关闭。在前端单页应用中，可能事件监听器没有被移除，导致泄漏。工具可以帮助（如前端Chrome开发者工具的内存检查器或C++的Valgrind泄漏检测），但通常只是阅读代码就能帮助。识别这些问题并修复它们。如果你看到一个未关闭的打开文件句柄，在`finally`块中添加一个关闭操作。
- en: Concurrency and parallelism
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 并发与并行
- en: If you’re using languages that support threads or async, look for places where
    the AI code might be single-threaded when it could be parallel. AI might not automatically
    use async/await where appropriate, and may not know to offload a heavy CPU task
    to a worker thread. Identify such opportunities. For example, for I/O-bound tasks
    in Node or Python, ensure asynchronous usage so that the system doesn’t block.
    For CPU-bound tasks, maybe the AI can’t help much in code, but you might decide
    to implement in a more performant language or offload to a background job.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用支持线程或异步的语言，寻找AI代码可能单线程的地方，而它本可以是并行的。AI可能不会在适当的地方自动使用async/await，并且可能不知道将重负载CPU任务卸载到工作线程。识别这样的机会。例如，对于Node或Python中的I/O密集型任务，确保异步使用，以便系统不会阻塞。对于CPU密集型任务，AI可能在代码上帮助不大，但你可能决定在更高效的语言中实现或将其卸载到后台任务。
- en: Caching
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存
- en: 'A common performance optimization that AI doesn’t always automatically add
    is to cache results of expensive operations. Look at your code: is it recalculating
    something repeatedly? If so, implement caching (either in-memory or using an external
    cache like Redis). You can prompt AI:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: AI不总是自动添加的一种常见性能优化是将昂贵操作的结果进行缓存。看看你的代码：是否反复计算某些内容？如果是这样，实现缓存（内存中的或使用外部缓存如Redis）。你可以提示AI：
- en: Add caching to this function to avoid redundant calculations.
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将缓存添加到这个函数中，以避免重复计算。
- en: It may implement a simple memorization or suggest using a caching library.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能实现简单的记忆功能或建议使用缓存库。
- en: Database query optimization
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库查询优化
- en: If your application uses a database, examine the queries the AI creates. Are
    they using indexes properly? Perhaps the AI wrote `SELECT *` where only a few
    columns are needed. Or it’s fetching extensive data to filter in code, creating
    performance bottlenecks like the N + 1 query problem. These inefficiencies require
    optimization by pushing more work to the database or leveraging proper indexing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序使用数据库，检查AI创建的查询。它们是否正确使用索引？也许AI写了`SELECT *`，但实际上只需要几个列。或者它正在检索大量数据以在代码中进行过滤，从而创建性能瓶颈，如N
    + 1查询问题。这些低效需要通过将更多工作推送到数据库或利用适当的索引进行优化。
- en: For instance, if the generated code calls `findOne` repeatedly within a loop,
    resulting in multiple database round trips, you can refactor this into a single
    batch query using `WHERE id IN (...)`. Similarly, if the AI omitted index creation
    in a migration for frequently queried fields, adding those indexes becomes essential
    for maintaining acceptable performance. The AI often generates functionally correct
    but suboptimal database interactions that require human expertise to identify
    and resolve.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果生成的代码在循环中反复调用`findOne`，导致多次数据库往返，你可以将其重构为使用`WHERE id IN (...)`的单个批量查询。同样，如果AI在迁移中省略了频繁查询字段的索引创建，添加这些索引对于保持可接受的性能变得至关重要。AI通常生成功能上正确但次优的数据库交互，需要人类专业知识来识别和解决。
- en: 'To illustrate, let’s take an example. Suppose AI writes you a function that
    merges two sorted arrays by simply concatenating and sorting the result: (O(n
    log n))—even though there’s a known linear algorithm it could be using to merge
    two sorted lists (like merge step or merge sort, O(n)). In code review, you realize
    this could be a bottleneck for large arrays, so you prompt AI to implement the
    linear merge:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，让我们举一个例子。假设AI为你编写了一个函数，该函数通过简单地将两个排序数组连接并排序来合并它们：（O(n log n)）——即使有一个已知的线性算法可以用来合并两个排序列表（如合并步骤或归并排序，O(n)）。在代码审查中，你意识到这可能是大型数组的瓶颈，因此你提示AI实现线性合并：
- en: Optimize the mergeSortedArrays function to perform the merge in linear time
    without using built-in sort.
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 优化mergeSortedArrays函数，以线性时间执行合并操作，而不使用内置排序。
- en: 'The AI recognizes this as the classic merge algorithm and writes it. The solution
    passes your tests, so congratulations: you gained performance without sacrificing
    correctness.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能将其识别为经典的合并算法并将其写入。解决方案通过了你的测试，所以恭喜：你在不牺牲正确性的情况下提高了性能。
- en: AI-assisted development doesn’t remove the need for performance tuning; it just
    shifts *when* you do that tuning. You’ll often get a correct solution first (which
    is extremely valuable), then turn your attention to measuring and optimizing targeted
    parts. When you do need to optimize something, the AI can help, as long as you
    guide it on what you need.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: AI辅助开发并不消除对性能调优的需求；它只是改变了你进行调优的时间。你通常会首先得到一个正确的解决方案（这非常有价值），然后转向关注测量和优化目标部分。当你需要优化某些内容时，AI可以帮助你，只要你引导它了解你需要什么。
- en: Ensuring Maintainability in AI-Accelerated Codebases
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保在AI加速的代码库中的可维护性
- en: A codebase’s *maintainability* describes how easy it is to modify, extend, and
    comprehend over time. Some worry that AI-generated code could be messy or inconsistent,
    especially if multiple suggestions have varying styles or patterns. This section
    covers several practices you can use to address these concerns and keep your vibe-coded
    project clean and maintainable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库的*可维护性*描述了随着时间的推移修改、扩展和理解的难易程度。有些人担心AI生成的代码可能杂乱无章或不一致，特别是如果多个建议有不同的风格或模式。本节涵盖了你可以使用的几个实践来处理这些担忧，并保持你的项目整洁且可维护。
- en: While Prompting
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在提示过程中
- en: 'As you prepare your prompts, a few things to keep in mind:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备你的提示时，以下是一些需要注意的事项：
- en: Use consistent coding standards
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一致的编码标准
- en: Use linters and formatters to enforce a consistent style. As mentioned, AI might
    sometimes use different naming conventions or formatting in different outputs.
    Running a formatter (like Prettier for JS, Black for Python, gofmt for Go, etc.)
    on all code after generation ensures it conforms to a unified style. This makes
    reading code much easier (no cognitive load switching styles). Additionally, define
    naming conventions for your project and stick to them. If the AI outputs `get_user_data`
    in one place and `fetchUserData` in another, decide which convention you prefer
    (`snake_case` versus `camelCase`, etc.) and refactor to one style.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用linters和formatters来强制执行一致的风格。如前所述，AI有时可能会在不同的输出中使用不同的命名约定或格式。在生成所有代码后运行格式化器（如JS的Prettier、Python的Black、Go的gofmt等）确保其符合统一风格。这使得阅读代码变得更加容易（无需在风格之间切换认知负荷）。此外，为你的项目定义命名约定并坚持使用。如果AI在一个地方输出`get_user_data`而在另一个地方输出`fetchUserData`，决定你更喜欢哪种约定（`snake_case`与`camelCase`等）并重构为一种风格。
- en: Use architectural patterns to encourage modularity and avoid sprawl
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用架构模式来鼓励模块化并避免蔓延。
- en: 'Encourage the AI to write modular code by prompting it to separate concerns.
    For example, instead of asking it to write one huge file implementing everything,
    break the work into tasks:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提示AI分离关注点来鼓励它编写模块化代码。例如，不要让它编写一个实现所有内容的巨大文件，而是将工作分解成任务：
- en: Create a UserService class for user logic.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户逻辑创建一个UserService类。
- en: Create a separate module for sending emails.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为发送电子邮件创建一个单独的模块。
- en: 'This leads to a codebase that’s logically divided. It’s easier to maintain
    when each module has a clear responsibility. You can guide the architecture:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致代码库在逻辑上被划分。当每个模块都有明确的职责时，它更容易维护。你可以引导架构：
- en: Put database access code in a separate file or class from the API routing code.
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将数据库访问代码放在与API路由代码分开的文件或类中。
- en: 'Because it’s so very easy to add features when using AI, it’s crucial to guard
    against feature creep and code sprawl. Without disciplined architectural thinking,
    you risk your codebase devolving into what software architects call a *big ball
    of mud*: an antipattern where code lacks clear structure or boundaries. This risk
    intensifies with AI assistance, as the friction traditionally associated with
    adding features disappears, potentially accelerating architectural decay.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用AI添加功能非常容易，因此防止功能蔓延和代码蔓延至关重要。如果没有纪律性的架构思维，你的代码库可能会演变成软件架构师所说的“大泥球”：一种代码缺乏清晰结构或边界的反模式。这种风险在AI辅助下加剧，因为添加功能时传统上所关联的摩擦消失了，可能会加速架构的退化。
- en: 'To combat this, ground your AI-assisted development in proven architectural
    patterns and principles. When instructing AI, explicitly reference the patterns
    your project follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这一问题，将你的AI辅助开发建立在经过验证的架构模式和原则之上。在指导AI时，明确指出你的项目遵循的模式：
- en: Add this new feature following the repository/service pattern used in the project.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照项目中使用的仓库/服务模式添加此新功能。
- en: Implement this using the hexagonal architecture established in our domain layer.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们在领域层建立的六边形架构来实现这一点。
- en: This specificity helps maintain consistency even as features accumulate rapidly.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种具体性有助于在功能快速积累的同时保持一致性。
- en: 'For developers seeking deeper architectural grounding, several foundational
    texts provide essential guidance:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于寻求更深入架构基础的开发者，几本基础文本提供了必要的指导：
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* (Addison-Wesley,
    1994) by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (the “Gang
    of Four”) remains the definitive catalog of reusable design solutions.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides（“四人帮”）所著的《*设计模式：可复用面向对象软件元素*》（Addison-Wesley，1994）仍然是可复用设计解决方案的权威目录。
- en: '[*Fundamentals of Software Architecture: An Engineering Approach*](https://learning.oreilly.com/library/view/fundamentals-of-software/9781098175504/)
    by Mark Richards and Neal Ford offers comprehensive coverage of architectural
    patterns and principles across technology stacks.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[《*软件架构基础：工程方法*》](https://learning.oreilly.com/library/view/fundamentals-of-software/9781098175504/)
    由Mark Richards和Neal Ford所著，全面涵盖了技术栈中的架构模式和原则。'
- en: '*Domain-Driven Design: Tackling Complexity in the Heart of Software* by Eric
    Evans (Addison-Wesley, 2003) provides crucial techniques for aligning software
    design with business domains—particularly valuable when AI generates code that
    must reflect complex business logic.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*领域驱动设计：软件核心的复杂性应对*》（Eric Evans 著，Addison-Wesley，2003年）提供了将软件设计与业务领域对齐的关键技术——尤其是当AI生成的代码必须反映复杂的业务逻辑时，这一点尤为宝贵。
- en: 'These resources equip you to guide AI tools effectively, ensuring generated
    code adheres to sound architectural principles rather than contributing to technical
    debt. Remember: AI excels at implementing patterns but cannot determine which
    patterns are appropriate for your specific context. That architectural judgment
    remains fundamentally human.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源使你能够有效地指导AI工具，确保生成的代码遵循良好的架构原则，而不是增加技术债务。记住：AI擅长实现模式，但不能确定哪些模式适合你的特定环境。那种架构判断本质上仍然是人类的。
- en: Working with Code Output
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与代码输出一起工作
- en: 'Once the AI responds with generated code, maintainability techniques to use
    include the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦AI响应并生成代码，以下是一些可用的维护技术：
- en: Refactor continuously
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 持续重构
- en: 'Don’t hesitate to refactor AI-generated code when needed. Sometimes the first
    pass is correct but not ideally structured: for example, the AI might write a
    very long function or duplicate its logic in two places. A common challenge is
    unintentionally duplicated code: the AI might not realize two functions do similar
    things and create both. If you notice similar blocks, refactor to one. Tools like
    code linters can detect duplicates (there are linters for too-similar code). Running
    those could highlight places to “DRY out” (don’t repeat yourself).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 需要时不要犹豫重构AI生成的代码。有时第一次尝试可能正确，但结构并不理想：例如，AI可能会编写一个非常长的函数或在两个地方重复其逻辑。一个常见的挑战是不经意间重复的代码：AI可能没有意识到两个函数做的是类似的事情，因此创建了两个。如果你注意到类似的代码块，就重构为一个。像代码检查器这样的工具可以检测重复（有针对过于相似代码的检查器）。运行这些工具可能会突出显示需要“DRY
    out”（不要重复自己）的地方。
- en: 'To ask the AI to help refactor, you could prompt:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要让AI帮助重构，你可以提示：
- en: Refactor this code to remove duplication and improve clarity.
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重构此代码以消除重复并提高清晰度。
- en: It might create helper functions or simplify some logic. Always test after refactoring.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会创建辅助函数或简化一些逻辑。重构后始终要测试。
- en: Test
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 测试
- en: This chapter has already covered testing, so I’ll just note that a good test
    suite makes maintenance easier. When you or others modify code in the future (possibly
    with AI again), your tests will catch if the changes break anything, so you can
    refactor or change implementations with peace of mind. Testing decouples “what
    it does” from “how it does it,” giving you flexibility to maintain or improve
    “how” without altering “what.”
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经涵盖了测试，所以这里只提一下，一个好的测试套件可以使维护更容易。当你或其他人将来修改代码（可能再次使用AI）时，你的测试将捕捉到是否有任何更改破坏了任何东西，这样你就可以安心地进行重构或更改实现。测试将“做什么”与“如何做”解耦，这让你在不改变“做什么”的情况下，有灵活性来维护或改进“如何”。
- en: Avoid excessive complexity or overrelying on AI-specific constructs
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 避免过度复杂或过度依赖AI特定的结构
- en: 'Sometimes the AI might use a clever trick or less common function that other
    developers might not know. While that’s not inherently bad, consider maintainability:
    if an average developer would scratch their head at the code, maybe simplify it.
    For instance, if AI uses a bit of regex magic or list comprehension that’s too
    terse, rewrite it in a more explicit loop for clarity (or at least comment it).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有时AI可能会使用一些巧妙的技巧或不太常见的函数，其他开发者可能不知道。虽然这本身并不坏，但考虑可维护性：如果一个普通开发者看到代码会挠头，也许可以简化它。例如，如果AI使用了一些正则表达式的魔法或过于简略的列表解析，为了清晰起见，可以将其重写为更明确的循环（或者至少注释它）。
- en: Similarly, an AI trying to be helpful might overengineer a solution, like adding
    layers that aren’t needed. For instance, maybe a direct approach was fine, but
    the AI introduced an abstraction that isn’t pulling its weight. Remove it to keep
    things straightforward. Simpler code is usually easier to maintain.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个试图提供帮助的AI可能会过度设计解决方案，比如添加不必要的层。例如，可能直接的方法就足够了，但AI引入了一个没有发挥作用的抽象。移除它以保持事情简单。通常，更简单的代码更容易维护。
- en: Build in resilience and fallbacks
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 增强代码的弹性和回退机制
- en: Think about fallback strategies in case of failures. For example, if an AI-coded
    component calls an external API and that API is down or returns unexpected data,
    do we have a fallback (like using cached data or a default response)? Implementing
    such resilience patterns (circuit breakers, retries with backoff, etc.) can make
    the system more robust. The AI likely won’t do this on its own unless asked. Ensure
    the system can handle partial failures gracefully. One microservice going down
    shouldn’t take the whole app down, if possible. Use timeouts and fallback logic.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在出现故障时采取后备策略。例如，如果一个AI编写的组件调用外部API，而这个API出现故障或返回意外数据，我们是否有后备方案（如使用缓存数据或默认响应）？实现这种弹性模式（断路器、带有退避的重试等）可以使系统更健壮。除非被要求，否则AI可能不会自己这样做。确保系统可以优雅地处理部分故障。如果可能的话，一个微服务崩溃不应该导致整个应用程序崩溃。使用超时和后备逻辑。
- en: Follow-Up
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后续
- en: 'Once you’re satisfied with the code, a few more practices help to keep it maintainable:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对代码感到满意，一些额外的做法可以帮助保持其可维护性：
- en: Provide thorough documentation and comments
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 提供详尽的文档和注释
- en: 'Make sure the code is properly documented. AI often writes minimal comments
    unless prompted. You can request docstrings or comments with prompts:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 确保代码得到适当的文档化。AI通常除非被提示，否则只会写最少的注释。你可以通过提示请求文档字符串或注释：
- en: Add comments to explain the purpose of each section in this code.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为这段代码的每个部分添加注释以解释其目的。
- en: Write a docstring for this function.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为这个函数编写文档字符串。
- en: These can save future readers time. The AI can usually generate fairly good
    explanations but sometimes misexplains subtle points, so review for accuracy.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以节省未来读者的时间。AI通常可以生成相当好的解释，但有时会误解细微之处，因此请进行审查以确保准确性。
- en: Also consider maintaining a high-level documentation (like a README or design
    doc) for the project, describing its architecture, main components, and so on.
    You can largely write this yourself, but AI can help by summarizing the codebase
    if needed.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 还应考虑为项目维护高级文档（如README或设计文档），描述其架构、主要组件等。你可以大部分自己编写，但如果需要，AI可以通过总结代码库来提供帮助。
- en: If you encounter some quirk like “The AI always names this parameter weirdly,”
    mention it in your dev notes for others. It’s part of the new collaborative environment.
    If it’s just you using the AI-generated code, a few quirks are fine—but if others
    join the project, they might wonder, “Why is this thing named like that?” Perhaps
    just standardize those names.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到一些怪癖，比如“AI总是以奇怪的方式命名这个参数”，请在你的开发笔记中提及它，以便其他人知道。这是新协作环境的一部分。如果你是唯一使用AI生成代码的人，一些怪癖是可以接受的——但如果其他人加入项目，他们可能会想知道，“为什么这个命名是这样的？”也许只是标准化那些名称。
- en: 'There’s also an aspect of maintainability in terms of knowing which pieces
    of code were AI-generated and which were human-written. It’s not strictly necessary
    to label, but some teams might comment, “Generated with the help of GPT-4 on 2025-05-01”
    for traceability. Ideally, flag anything you’re unsure about in your PR description:
    “Used ChatGPT to help with this function; it seems to work, but please check the
    error-handling logic carefully.”'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在维护性方面，了解哪些代码是AI生成的，哪些是人工编写的，也是一个方面。这并不是严格必要的，但一些团队可能会注释，“由GPT-4于2025-05-01生成”以供追溯。理想情况下，在PR描述中标记任何你不确定的事情：“使用ChatGPT帮助完成此功能；它似乎可以工作，但请仔细检查错误处理逻辑。”
- en: 'This isn’t a widespread practice. It can be helpful during code review, but
    you might not need it if a human has already reviewed the code and it’s now just
    code. If you do keep any transcripts or prompts, you could link them in comments
    for complicated code: “This algorithm derived via GPT-4, based on prompt X; see
    docs for derivation.” A reviewer doesn’t need to treat it differently in terms
    of scrutiny (you should scrutinize all code), but it can help to understand the
    context. For example, if code has a certain style mismatch or an odd idiom, knowing
    it came from AI might clue the reviewer in that this isn’t a deliberate authorial
    choice but an AI artifact.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个普遍的做法。在代码审查期间可能会有所帮助，但如果已经有人类审查过代码，现在只是代码的话，你可能不需要它。如果你保留任何转录或提示，你可以在复杂代码的注释中链接它们：“此算法通过GPT-4推导，基于提示X；请参阅文档以了解推导过程。”审查者不需要在审查时对待它有所不同（你应该审查所有代码），但它有助于理解上下文。例如，如果代码存在某种风格不匹配或奇特的习语，知道它来自AI可能会让审查者意识到这并不是作者故意的选择，而是AI的产物。
- en: Code reviews and team norms
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查和团队规范
- en: If you’re working in a team, have all team members review code—even if one person
    and AI cowrote it. They might spot awkward patterns or things that break team
    norms. Over time, you’ll develop a sense of how to prompt the AI to match your
    team’s style (maybe including specifics in system prompts or initial guidelines).
    If multiple developers use AI, make sure everyone knows the desired style patterns
    so they can prompt accordingly (like “Write this in functional style” or “Use
    async/await, not callbacks”). See the next section for some tips on code review
    with AI code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个团队中工作，让所有团队成员审查代码——即使是一个人和AI共同编写的。他们可能会发现尴尬的模式或违反团队规范的事情。随着时间的推移，你会发展出一种感觉，如何提示AI以匹配你团队的风格（可能包括在系统提示或初始指南中具体说明）。如果有多个开发者使用AI，确保每个人都了解期望的风格模式，以便他们可以相应地提示（例如，“用函数式风格编写这个”或“使用async/await，而不是回调”）。下一节将提供一些关于使用AI代码进行代码审查的技巧。
- en: Track technical debt
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪技术债务
- en: 'If, during development, you accept an AI solution that you know isn’t ideal,
    track it as technical debt in your comments or the project to-dos: “TODO: The
    solution works but is O(n²); if data grows, optimize this,” or “TODO: This uses
    a global variable for simplicity; refine this later.” The AI can even insert TODO
    comments itself if you ask:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在开发过程中，你接受了一个你知道并不理想的AI解决方案，请在你的注释或项目待办事项中将其跟踪为技术债务：“待办：这个解决方案工作正常，但效率是O(n²)；如果数据增长，优化这一点，”或者“待办：为了简单起见，这里使用了全局变量；稍后进行细化。”如果你要求，AI甚至可以自己插入待办注释：
- en: If there are any areas that need future improvement, add to-do comments.
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果有任何需要未来改进的区域，添加待办事项注释。
- en: Just address those to-dos eventually.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 只需最终解决这些待办事项。
- en: Learn from AI patterns
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从AI模式中学习
- en: If AI introduces a design pattern or library you’re not familiar with, take
    time to learn more about it rather than ignoring it. Understanding a particular
    caching approach or a library it uses will help you maintain or modify that part
    confidently in the future. If it’s too arcane, you might decide to remove it in
    favor of something you know—but sometimes AI can pleasantly surprise you with
    a useful library or pattern you didn’t know. If it’s a well-known solution that
    you and the team can learn, this can even improve maintainability.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果AI引入了一个你不太熟悉的设计模式或库，花时间了解更多关于它的信息，而不是忽略它。了解特定的缓存方法或它使用的库将有助于你在未来自信地维护或修改这部分内容。如果它过于晦涩，你可能会决定用你已知的东西替换它——但有时AI会以你不知道的有用库或模式让你感到惊喜。如果这是一个你和你团队都可以学习的知名解决方案，这甚至可以提高可维护性。
- en: In practice, maintainability comes down to applying the same good software-engineering
    principles as always—just applying them to code that was partially written by
    AI. Fortunately, because AI reduces the grunt work, you may have more time to
    focus on cleaning up the code and writing docs, which *improves* maintainability.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，可维护性归结为始终应用相同的良好软件工程原则——只是将这些原则应用到部分由AI编写的代码上。幸运的是，由于AI减少了繁琐的工作，你可能会有更多的时间来整理代码和编写文档，这*提高了*可维护性。
- en: Some companies [report](https://oreil.ly/2lrTW) that after an initial burst
    of generating code with AI, they invest time in a “hardening sprint” to refactor
    and document it all. Consider alternating between generation-heavy sprints and
    cleanup sprints as a potential strategy.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一些公司[报告](https://oreil.ly/2lrTW)，在用AI生成代码的初始爆发之后，他们会投入时间进行“加固冲刺”来重构和记录所有内容。考虑在生成密集型冲刺和清理冲刺之间交替，这可能是一种潜在策略。
- en: Code Review Strategies
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码审查策略
- en: As discussed in [Chapter 4](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362),
    code review is a critical process in traditional development and remains so in
    AI-assisted development. This section discusses some nuances to consider when
    a chunk of the code under review is machine-suggested. Because AI can produce
    code so quickly, it’s reasonable to worry that code review will become a bottleneck—but
    don’t let that worry hamper the review process. It’s crucial to allocate proper
    time for reviews. Don’t skimp on the assumption that “we wrote it fast, let’s
    merge fast.” If anything, commit smaller changes more frequently to make reviews
    easier (generally a good practice anyway). Frequent, smaller pull requests (PRs)
    are easier to review thoroughly than one giant PR. The AI can help break tasks
    into smaller PRs as well, if you plan accordingly.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第4章](ch04.html#ch04_beyond_the_70_maximizing_human_contribution_1752630043401362)所述，代码审查是传统开发中的关键过程，在AI辅助开发中也是如此。本节讨论了在审查的代码块由机器建议时需要考虑的一些细微差别。由于AI可以快速生成代码，因此有理由担心代码审查可能会成为瓶颈——但不要让这种担忧阻碍审查过程。为审查分配适当的时间至关重要。不要因为“我们写得快，就合并得快”的假设而节省时间。相反，更频繁地提交较小的更改，以便更容易进行审查（这通常也是一项良好的实践）。频繁的小型拉取请求（PR）比一个巨大的PR更容易彻底审查。如果计划得当，AI还可以帮助将任务分解成更小的PR。
- en: Don’t assume code is correct just because “the AI wrote it and the tests pass.”
    Think critically and try to reason through the logic. If possible, test it mentally
    or with additional cases outside the provided tests, because tests might not cover
    everything. You can also run the code and even experiment by running a snippet
    with a tricky input to see if it behaves.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 不要仅仅因为“AI编写了代码并且测试通过”就假设代码是正确的。要批判性地思考，并尝试通过逻辑推理。如果可能的话，通过心理测试或使用提供的测试之外的其他案例来测试它，因为测试可能无法涵盖所有内容。你还可以运行代码，甚至通过运行具有复杂输入的代码片段来实验，看看它是否表现正常。
- en: Code reviews can also be important learning moments. If the AI introduces a
    novel solution that is actually good, the reviewer might learn something new while
    verifying its correctness. Similarly, if the AI/human combination does something
    suboptimal, the reviewer can explain a better approach. Over time, this feedback
    loop can improve how the team uses AI (like helping everyone understand which
    things to avoid or ask differently). In a sense, code review helps to close the
    human learning loop, since the human author should learn and understand anything
    the AI wrote that is new to them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查也可以是重要的学习时刻。如果AI引入了一种实际上很好的新解决方案，审查者可以在验证其正确性的同时学到新东西。同样，如果AI/人类组合做出了次优决策，审查者可以解释一个更好的方法。随着时间的推移，这个反馈循环可以提高团队使用AI的方式（例如帮助每个人了解哪些事情要避免或以不同的方式询问）。从某种意义上说，代码审查有助于关闭人类学习循环，因为人类作者应该学习和理解AI为他们编写的新内容。
- en: 'When you review code, your first priority should be making sure it meets the
    requirements and intended design. Does this code do what the feature/bugfix is
    supposed to? Does it cover any edge cases mentioned in the specifications? If
    the prompt is off, AI might solve a slightly different problem: maybe it handles
    a case that wasn’t needed or misses a case. This is normal, but watch that the
    developer didn’t just accept AI output that only partially addresses the issue.
    For example, an AI might produce code to format a date but assume a certain time
    zone, which might or might not align with requirements.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当你审查代码时，你的首要任务应该是确保它符合要求和预期设计。这段代码是否完成了功能/错误修复应该完成的工作？它是否涵盖了规格说明中提到的任何边缘情况？如果提示不正确，AI可能会解决一个稍微不同的问题：它可能处理了不需要的情况，或者遗漏了某个情况。这是正常的，但要注意开发者是否只是接受了AI输出，该输出仅部分解决了问题。例如，AI可能会生成格式化日期的代码，但假设一个特定时区，这可能与要求一致或不一致。
- en: If something in the code isn’t obvious, ask the author to explain how it works
    or why it’s done that way. If they struggle to explain or reach for “the AI did
    it and I assume it’s right,” that’s a red flag. The team should understand everything
    in the codebase. Encourage the author to double-check with the AI or documentation
    and provide a proper explanation, possibly as a comment in code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码中的某些内容不明显，请要求作者解释它是如何工作的或为什么这样做。如果他们难以解释或寻求“AI做了，我假设它是正确的”，那么这是一个红旗。团队应该理解代码库中的所有内容。鼓励作者与AI或文档进行双重检查，并提供适当的解释，可能是在代码中的注释。
- en: Pay attention to the security and performance vulnerabilities discussed earlier
    in this chapter, too, and if any known best practice is violated, call it out—like
    if output isn’t escaped (in web dev) or if you find credentials in the code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意本章前面讨论过的安全和性能漏洞，如果违反了任何已知最佳实践，请指出——比如输出没有转义（在Web开发中）或你在代码中找到凭证。
- en: 'Request changes or refactoring if you see code that works but could be simpler
    or more in line with team style:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到代码虽然能工作，但可以更简单或更符合团队风格，请请求更改或重构：
- en: The AI created 3 separate functions for different user roles that mostly duplicate
    each other. Can we merge these into one function with a parameter for role?
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: AI为不同的用户角色创建了3个不同的函数，这些函数大部分是重复的。我们能将它们合并成一个带有角色参数的函数吗？
- en: 'The code’s author can then do so (maybe with AI’s help). If the AI suggestion
    didn’t use the team’s consistent style or standard libraries, mention that too:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的作者可以这样做（也许需要AI的帮助）。如果AI的建议没有使用团队的一致风格或标准库，也要指出这一点：
- en: We usually use the requests library for HTTP calls, but this code is using http.client.
    Let’s stick to requests for consistency.
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们通常使用requests库来进行HTTP调用，但这段代码使用了http.client。为了保持一致性，我们还是坚持使用requests库。
- en: The author can then prompt the AI to rewrite using the preferred library.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，作者可以提示AI使用首选库进行重写。
- en: If the AI has written something really complex, like a tricky algorithm, consider
    discussing it with another reviewer or the team for a deeper review.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果AI编写了一些非常复杂的代码，比如一个棘手的算法，考虑与另一位审查者或团队讨论，进行更深入的审查。
- en: You may want to try some of the emerging tools that use AI to assist in code
    review—like GitHub’s Copilot for Pull Requests, which can generate summaries and
    flag potential bugs and other issues. Such a tool might highlight something like
    “This code snippet is similar to one in module X with slight differences” (pointing
    out possible duplication). These hints can complement the human review but should
    not replace it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想尝试一些使用AI辅助代码审查的新兴工具——比如GitHub的Copilot用于Pull Requests，它可以生成摘要并标记潜在的bug和其他问题。这样的工具可能会突出显示“这个代码片段与模块X中的一个类似，但有细微差别”（指出可能的重复）。这些提示可以补充人工审查，但不应该取代它。
- en: 'Finally, be respectful and constructive in your reviewing, even when the code
    has flaws due to AI. Avoid blaming the developer for what could be an AI artifact:
    while they are still responsible for their code, recognize the context. AI is
    a tool, and both author and reviewer are working with it. The goal is to improve
    the code and share knowledge, not point fingers. For example: “This part seems
    to have a security issue⁠—likely an oversight from the AI suggestion; let’s fix
    it.”'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，即使代码由于AI而存在缺陷，也要在审查中保持尊重和建设性。避免责怪开发者可能是由AI产生的错误：虽然他们仍然对其代码负责，但也要认识到背景。AI是一个工具，作者和审查者都在使用它。目标是改进代码和分享知识，而不是指责。例如：“这部分似乎存在安全问题——可能是AI建议的疏忽；让我们修复它。”
- en: Ultimately, code review in vibe coding is how we fully exercise the *human intelligence*
    side of the human/AI partnership. It’s where oversight and expertise come in to
    catch what the AI might miss and to keep the quality bar high. It’s also a knowledge-sharing
    moment for the team, since discussing code in reviews spreads understanding of
    both the domain and how to best use AI.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，在vibe coding中，代码审查是我们完全发挥人/AI伙伴关系中的*人类智能*方面。这是监督和专业知识介入以捕捉AI可能遗漏的内容并保持质量标准高的地方。它也是团队的知识共享时刻，因为审查中的代码讨论可以加深对领域和如何最好地使用AI的理解。
- en: 'Code review also formalizes the concept of “developers as editors” [introduced
    by Grant Gross in *CIO*](https://oreil.ly/INPFV): the reviewer is an editor, making
    sure the code is polished and fit for production. This aligns perfectly with vibe
    coding as a concept, where the vibes (AI suggestions) are there but human judgment
    refines them.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查也正式化了“开发者作为编辑”的概念[由Grant Gross在*CIO*](https://oreil.ly/INPFV)提出：审查者是一个编辑，确保代码经过打磨且适合生产。这与作为概念的vibe
    coding完美契合，其中vibe（AI建议）存在，但人类的判断力对其进行了细化。
- en: Best Practices for Reliable Deployment
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠部署的最佳实践
- en: Once you know your code is secure, tested, and maintainable, you need to deploy
    it and keep it running reliably in production.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道你的代码是安全的、经过测试的且可维护的，你需要将其部署并确保在生产环境中可靠运行。
- en: While AI-assisted development doesn’t alter the core principles of software
    deployment, it does introduce considerations around deployment velocity and operational
    complexity. For those seeking comprehensive coverage of deployment fundamentals,
    *The DevOps Handbook* (IT Revolution Press, 2016), by Gene Kim, Jez Humble, Patrick
    Debois, John Willis, and Nicole Forsgren, provides the definitive guide, covering
    everything from continuous integration and deployment pipelines to monitoring,
    security, and organizational transformation. This foundational knowledge becomes
    even more critical when AI accelerates your ability to generate deployable code,
    as the principles ensure your deployment practices can scale with your increased
    development velocity.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管人工智能辅助开发并没有改变软件部署的核心原则，但它确实引入了关于部署速度和运营复杂性的考虑。对于那些寻求全面覆盖部署基础的人来说，Gene Kim、Jez
    Humble、Patrick Debois、John Willis 和 Nicole Forsgren 著的《DevOps 手册》（IT Revolution
    Press，2016年），提供了权威指南，涵盖了从持续集成和部署管道到监控、安全和组织转型的各个方面。当人工智能加速你生成可部署代码的能力时，这种基础性知识变得更加关键，因为这些原则确保你的部署实践可以随着你的开发速度的增加而扩展。
- en: Before and During Deployment
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在部署前和部署期间
- en: 'As you ramp up to deployment, consider the following best practices:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备部署时，考虑以下最佳实践：
- en: Automate your CI/CD pipeline
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化你的 CI/CD 管道
- en: Given the fast pace of AI development, a robust continuous integration/continuous
    deployment (CI/CD) pipeline is valuable. Every commit (with or without AI-generated
    code) should be built, tested, and potentially deployed through an automated pipeline.
    This reduces human error and confirms that all deployment steps (tests, lint,
    security scans) are consistently run. If AI code introduces something that breaks
    the build or fails the tests, the CI will catch it immediately. Also, an automated
    CI/CD pipeline allows for quick iteration, so you can patch any AI-introduced
    issues and deploy fixes rapidly.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于人工智能发展的快速步伐，一个健壮的持续集成/持续部署（CI/CD）管道非常有价值。每个提交（无论是否有人工智能生成的代码）都应该通过自动化管道进行构建、测试，并可能部署。这减少了人为错误，并确认所有部署步骤（测试、代码审查、安全扫描）都是一致运行的。如果人工智能代码引入了破坏构建或测试失败的内容，CI
    将立即捕捉到它。此外，自动化的 CI/CD 管道允许快速迭代，因此你可以快速修复人工智能引入的问题并部署修复程序。
- en: Infrastructure as code
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施即代码
- en: 'Use infrastructure as code (Terraform, CloudFormation, etc.) to define your
    deployment environment. While not directly related to AI coding, it’s part of
    reliable deployments. You could even use AI to help write Terraform scripts, but
    treat those with the same caution and testing as other AI code, including perhaps
    testing them in a sandbox before applying them to production. A valuable starting
    point is the book [*Terraform: Up & Running*](https://learning.oreilly.com/library/view/terraform-up-and/9781098116736/)
    (O’Reilly, 2022), by Yevgeniy Brikman, which provides a comprehensive introduction
    to the principles and practices of IaC with Terraform.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '使用基础设施即代码（Terraform、CloudFormation 等）来定义你的部署环境。虽然它与人工智能编码没有直接关系，但它构成了可靠的部署的一部分。你甚至可以使用人工智能来帮助编写
    Terraform 脚本，但要以与其他人工智能代码相同的谨慎和测试来对待它们，包括在应用到生产之前在沙盒中测试它们。一个有价值的起点是 Yevgeniy Brikman
    著的书籍 [*Terraform: Up & Running*](https://learning.oreilly.com/library/view/terraform-up-and/9781098116736/)（O’Reilly，2022年），它提供了对使用
    Terraform 的基础设施即代码原则和实践的全面介绍。'
- en: Use staged rollouts—and have a rollback plan
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分阶段推出，并制定回滚计划
- en: Use staged rollout strategies like deploying to a staging environment or a canary
    release before full production rollout. This way, you can catch anything you’ve
    overlooked before it affects all users. For example, you might deploy a new AI-coded
    feature to 5% of users and monitor (with metrics and logs) for any errors or performance
    issues. If all is good, roll it out to 100% of users.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分阶段推出策略，如在生产全面推出之前部署到测试环境或金丝雀发布。这样，你可以在它影响所有用户之前捕捉到你忽略的任何内容。例如，你可能会将新的 AI
    编码功能部署给 5% 的用户，并监控（使用指标和日志）任何错误或性能问题。如果一切顺利，将其推广到 100% 的用户。
- en: Always have a rollback plan. Despite all tests and reviews, sometimes things
    slip through. If a new release goes wrong, be ready to revert to the last stable
    version. If you’re using a containerization strategy like Kubernetes, maintain
    previous deployments for quick switchback. If it’s a serverless function, keep
    the previous version alive until you’re confident in the new one.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 总是制定回滚计划。尽管经过所有测试和审查，有时事情还是会出错。如果新版本出现问题，准备好回滚到最后一个稳定版本。如果你使用像 Kubernetes 这样的容器化策略，保持之前的部署以快速切换回。如果是一个无服务器函数，保持上一个版本运行，直到你对新版本有信心。
- en: Set up observability
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 设置可观察性
- en: 'Set up comprehensive monitoring in production, of both system metrics and application
    logs:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中设置全面的监控，包括系统指标和应用程序日志：
- en: Use tools like Sentry to track errors and capture exceptions. If the AI code
    throws an unexpected error in production (perhaps an edge case wasn’t covered),
    you’ll get an alert so you can fix it.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Sentry等工具跟踪错误并捕获异常。如果AI代码在生产中抛出意外的错误（可能是因为没有覆盖边缘情况），你会收到警报，以便你可以修复它。
- en: Use performance-monitoring tools like application performance monitoring (APM)
    to track response times, throughput, and memory usage. This will show you if any
    code in the new deployment has introduced a slowdown or memory leak.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用性能监控工具，如应用程序性能监控（APM），以跟踪响应时间、吞吐量和内存使用情况。这将显示新部署中是否有任何代码引入了减速或内存泄漏。
- en: 'Monitor availability: for instance, ping the service endpoints to confirm they’re
    up. If something crashes (maybe due to some untested scenario), an alert should
    fire, so you can react quickly.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控可用性：例如，ping服务端点以确认它们正在运行。如果发生崩溃（可能由于某些未测试的场景），应该触发警报，以便你可以快速反应。
- en: Stay vigilant about security
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 保持对安全的警惕
- en: Make sure that secrets like API keys are handled properly in deployment. For
    example, if your AI wrote code that expects a secret in an environment variable,
    set up that secret in the CI/CD or cloud config, so it’s not accidentally logged
    or exposed. Use secret management tools like [HashiCorp Vault](https://oreil.ly/NqQ-T)
    (HashiCorp Vault offers secrets management, key management, and more with many
    integrations) or [AWS Secrets Manager](https://oreil.ly/LlYX-) (AWS Secrets Manager
    allows you to securely store and rotate secrets like database credentials, API
    keys, and tokens, and can integrate with CI/CD tools like GitHub). Also, if you’re
    using container images, scan them for vulnerabilities.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在部署中妥善处理像API密钥这样的机密。例如，如果你的AI编写的代码期望在环境变量中有一个机密，请在CI/CD或云配置中设置该机密，这样就不会意外记录或暴露。使用像[HashiCorp
    Vault](https://oreil.ly/NqQ-T)（HashiCorp Vault提供机密管理、密钥管理以及许多集成）或[AWS Secrets
    Manager](https://oreil.ly/LlYX-)（AWS Secrets Manager允许你安全地存储和轮换机密，如数据库凭据、API密钥和令牌，并且可以与CI/CD工具如GitHub集成）这样的机密管理工具。此外，如果你使用容器镜像，扫描它们以查找漏洞。
- en: Test using techniques like blue-green deployments or shadow testing
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用蓝色-绿色部署或影子测试等技术进行测试
- en: 'For major changes, consider a blue-green deploy. This involves setting up two
    identical production environments: “blue” (the current live version) and “green”
    (the new version). Traffic is initially directed to the blue environment. Once
    the green environment is ready and tested, traffic is switched over to it. If
    any issues arise with the green environment, traffic can be quickly rerouted back
    to the blue environment, minimizing downtime and risk. This method tests the new
    version in a full production setting before making it the sole live version.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于重大变更，考虑使用蓝色-绿色部署。这涉及到设置两个完全相同的生产环境：“蓝色”（当前运行版本）和“绿色”（新版本）。初始流量被引导到蓝色环境。一旦绿色环境准备就绪并经过测试，流量就会切换到它。如果绿色环境中出现任何问题，流量可以迅速重新路由回蓝色环境，最小化停机时间和风险。这种方法在将其作为唯一运行版本之前，在完整的生产环境中测试新版本。
- en: Alternatively, if a specific AI-coded algorithm change is risky or you want
    to validate its behavior with real-world data without impacting users, you could
    shadow test it. This involves deploying the new version alongside the current
    live version. Real production inputs are fed to both versions in parallel. However,
    only the current version’s outputs are shown to users. The outputs from the new
    (shadow) version are collected and compared against the current version’s results
    to evaluate its performance, accuracy, and stability. If the shadow version’s
    results are satisfactory and performance is good, you can then confidently switch
    it to be the active version.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果特定的AI编码算法更改有风险或你希望在不对用户产生影响的情况下验证其实际数据的行为，你可以进行影子测试。这涉及到将新版本与当前运行版本一起部署。同时向两个版本提供真实的生产输入。然而，只向用户展示当前版本的输出。收集新（影子）版本的输出并与当前版本的输出进行比较，以评估其性能、准确性和稳定性。如果影子版本的输出令人满意且性能良好，然后你可以自信地将它切换为活动版本。
- en: Ongoing Best Practices
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续最佳实践
- en: 'After deployment, these strategies can help keep everything running reliably:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后，以下策略可以帮助确保一切可靠运行：
- en: Create operational runbooks
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 创建操作运行手册
- en: 'Provide runbooks for the ops team that describe any special aspects of the
    AI-generated parts of the code: “This service uses an AI model for X; if the model
    output seems erroneous, try restarting service or check the model’s version.”
    Or “Feature Y heavily uses caching to perform well; if performance issues arise,
    check the cache hit rate.” Essentially, document any operational considerations
    that might not be obvious. If AI has introduced a dependency (like using a temp
    file), note that, so ops will know to monitor disk space and the like.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为运维团队提供操作手册，描述代码中AI生成部分的任何特殊方面：“此服务使用AI模型进行X；如果模型输出看起来有误，尝试重启服务或检查模型的版本。”或者“功能Y大量使用缓存以实现良好的性能；如果出现性能问题，请检查缓存命中率。”基本上，记录任何可能不明显的工作考虑因素。如果AI引入了依赖（如使用临时文件），请注意这一点，以便运维人员知道要监控磁盘空间等。
- en: Test in production
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中进行测试
- en: In addition to testing during development and as part of the rollout, some companies
    do testing in production (TiP) in safe ways, like running continuous small experiments.
    For instance, you might use feature flags to turn on an AI-generated feature for
    a small subset of users and see if any error rates change. This overlaps with
    canary releases, but you can make it more granular using feature toggles.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 除了开发期间和作为部署的一部分进行测试之外，一些公司还会以安全的方式在生产中进行测试（TiP），例如运行连续的小实验。例如，你可能可以使用功能标志为一小部分用户打开AI生成的功能，并查看是否有任何错误率的变化。这与金丝雀发布重叠，但你可以使用功能开关使其更加细致。
- en: Audit regularly
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 定期审计
- en: 'Schedule periodic security and performance audits of the codebase, especially
    as more AI contributions accumulate. This is similar to managing tech debt: it
    helps you catch things that were fine at first but that could turn problematic
    as the scale or context changes. Watch for “drift,” too—if AI code is generating
    SQL queries, make sure that your migrations and code stay in sync and that the
    deployment runs migrations properly before new code takes traffic.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 定期对代码库进行安全和性能审计，特别是在更多AI贡献积累时。这与管理技术债务类似：它帮助你捕捉到最初可能没问题，但随着规模或环境的变化可能会变得有问题的事情。也要注意“漂移”——如果AI代码正在生成SQL查询，确保你的迁移和代码保持同步，并且在新的代码开始接收流量之前，部署正确运行迁移。
- en: Keep humans in the loop
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让人类参与其中
- en: The theme continues—humans should monitor the automations. AI might help you
    write code, but it won’t fix a production incident at 2 a.m. Have someone on call
    who understands the system. Over time, you might enlist AI for troubleshooting
    help like analyzing logs (a feature of some emerging tools), but at the end of
    the day, a human should make decisions about fixes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 主题继续——人类应该监控自动化。AI可以帮助你编写代码，但不会在凌晨2点修复生产事件。安排一个了解系统的值班人员。随着时间的推移，你可能会让AI帮助进行故障排除，例如分析日志（一些新兴工具的功能），但最终，人类应该对修复做出决定。
- en: Learn from failures
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 从失败中学习
- en: No process is 100% perfect. If an error gets through your defenses and causes
    an incident, do a postmortem. Identify if the problem was related to AI usage
    (like “We trusted the AI code here and it failed under scenario X”), and update
    your processes and tests to prevent that class of issue. Doing this kind of analysis
    every time continuously improves reliability.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 没有过程是100%完美的。如果错误通过了你的防御并导致了事件，进行事后分析。确定问题是否与AI使用相关（例如“我们信任这里的AI代码，但在场景X下失败了”），并更新你的流程和测试以防止这类问题。每次进行这种分析都会持续提高可靠性。
- en: Reliability isn’t just about code, of course; it also involves the infrastructure
    and operations *around* the code. AI helps mostly on the code side. Robust operational
    practices (which can be partially assisted by AI) keep the overall system reliable.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠性不仅仅是关于代码，当然；它还涉及代码周围的**基础设施和运维**。AI主要在代码方面提供帮助。稳健的运维实践（可以部分由AI辅助）可以保持整个系统的可靠性。
- en: 'In essence, treat an AI-heavy project the same as any high-quality software
    project when it comes to deployment: employ thorough testing, roll out gradually,
    monitor heavily, and make sure you can roll back quickly. Because AI can create
    changes faster, you may end up deploying more frequently (which is fine, if your
    CI/CD pipeline is good). [Frequent small deployments](https://oreil.ly/ATjYo)
    are actually [known to reduce risk](https://oreil.ly/Y5uDn) compared to infrequent
    big ones. The reason is that each individual change is smaller, making it easier
    to identify and fix any issues that arise. If a problem occurs, rolling back a
    small change is also simpler and faster. This approach contrasts with large, infrequent
    releases where numerous changes are bundled together, making it difficult to pinpoint
    the cause of any problems and increasing the potential impact of a failed deployment.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，在部署方面，将AI密集型项目视为任何高质量软件项目一样：进行彻底的测试，逐步推出，严格监控，并确保你可以快速回滚。因为AI可以更快地创建变化，你可能会更频繁地部署（如果您的CI/CD管道良好，这是可以的）。[频繁的小型部署](https://oreil.ly/ATjYo)实际上[已知可以降低风险](https://oreil.ly/Y5uDn)，与不频繁的大型部署相比。原因是每个单独的变化都更小，这使得识别和修复任何出现的问题更容易。如果出现问题，回滚一个小变化也更简单、更快。这种方法与大型、不频繁的发布形成对比，其中许多变化捆绑在一起，这使得确定任何问题的原因变得困难，并增加了失败部署的潜在影响。
- en: By following these best practices, you can be confident that even though a lot
    of its code was machine-generated, your system as a whole will behave reliably
    for users. The combination of automated testing, careful deployment, and monitoring
    closes the loop to catch anything that slipped through earlier stages. As a result,
    you can reap the speed and productivity benefits of AI development without sacrificing
    your ability to trust your software in production.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些最佳实践，你可以有信心，尽管其中很大一部分代码是机器生成的，但你的整个系统将可靠地为用户服务。自动化测试、谨慎的部署和监控的组合，可以关闭循环，捕捉到之前阶段遗漏的任何内容。因此，你可以在不牺牲在生产环境中信任你的软件能力的情况下，享受到AI开发的速度和生产力优势。
- en: Summary and Next Steps
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和下一步
- en: 'In summary, vibe coding does not remove the need for engineering rigor—it amplifies
    the productivity of the engineers who apply that rigor. Your mantra should be
    the old Russian proverb: Trust but verify. Trust the AI to handle the grunt work,
    but verify everything with your tools and expertise.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，vibe编码并没有消除对工程严谨性的需求——它放大了那些严谨工程师的生产力。你的座右铭应该是古老的俄罗斯谚语：信任但核实。信任AI处理繁琐的工作，但用你的工具和专业知识核实一切。
- en: Security and reliability are one dimension of responsible development; ethics
    is another. AI-assisted coding raises important questions about intellectual property,
    bias, the impact on developer jobs, and more. [Chapter 9](ch09.html#ch09_the_ethical_implications_of_vibe_coding_1752630044848930)
    will delve into those broader implications. How can you use AI coding tools responsibly
    and fairly? How do you deal with licensing of AI-generated code and ensure your
    models and prompts are used ethically?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性和可靠性是负责任开发的一个维度；伦理是另一个维度。AI辅助编码提出了关于知识产权、偏见、对开发者工作的影响等问题。[第9章](ch09.html#ch09_the_ethical_implications_of_vibe_coding_1752630044848930)将深入探讨这些更广泛的影响。你如何负责任和公平地使用AI编码工具？你如何处理AI生成代码的许可，并确保你的模型和提示被道德地使用？
