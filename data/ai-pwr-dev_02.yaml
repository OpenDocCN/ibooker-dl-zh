- en: 2 Getting started with large language models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 开始使用大型语言模型
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Engaging with ChatGPT
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与ChatGPT互动
- en: Learning the basics of using Copilot
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用Copilot的基础
- en: Learning the basics of using CodeWhisperer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用CodeWhisperer的基础
- en: Exploring prompt engineering patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索提示工程模式
- en: Contrasting the differences between these three Generative AI offerings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对比这三个生成式人工智能产品的差异
- en: 'In this chapter, we embark on a practical journey through the landscape of
    Generative AI, harnessing the power of three groundbreaking tools: ChatGPT, GitHub
    Copilot, and AWS CodeWhisperer. As we navigate the intricacies of these technologies,
    we’ll apply them to a series of challenging scenarios modeled after the rigorous
    interview questions posed by leading tech giants. Whether you’re a seasoned developer
    or a curious enthusiast, prepare to unlock innovative strategies that could give
    you the edge in your next technical interview. Get ready to transform abstract
    concepts into tangible solutions right at the forefront of AI’s evolving role
    in tech hiring.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将踏上探索生成式人工智能领域的实际之旅，利用三个开创性的工具的力量：ChatGPT、GitHub Copilot和AWS CodeWhisperer。随着我们深入这些技术的复杂性，我们将把它们应用于一系列以顶尖科技巨头提出的严格面试问题为模型的有挑战性的场景。无论你是经验丰富的开发者还是好奇的爱好者，都准备好解锁可能让你在下一场技术面试中占据优势的创新策略。准备好将抽象概念转化为AI在技术招聘中不断演变角色的前沿的实际解决方案。
- en: 'We will begin by using two currently available models for ChatGPT: GPT-4 and
    GPT-3.5\. The purpose is twofold: it will allow us to appreciate the engagement
    model of ChatGPT, and it will also let us establish a baseline against which we
    can compare and contrast the other two. Using two models will also allow us to
    appreciate the generational sea change between these model versions. Finally,
    throughout this chapter, we will use some common patterns in prompt engineering.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用目前可用的两个ChatGPT模型：GPT-4和GPT-3.5。目的是双重的：它将使我们能够欣赏ChatGPT的参与模式，并且它还将让我们建立一个基准，我们可以据此比较和对比其他两个模型。使用两个模型还将使我们能够欣赏这些模型版本之间的代际变革。最后，在本章中，我们将使用一些常见的提示工程模式。
- en: 2.1 A foray into ChatGPT
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 ChatGPT的初步探索
- en: Context is one of the most important aspects of working with ChatGPT. Your previous
    *prompts* can drastically change the results from your current prompt. In language
    models like ChatGPT, a prompt refers to the input provided to the model to generate
    a response. It can be a single sentence, a paragraph, or even a longer text. It
    serves as the instruction or query to the model, guiding its response. Given the
    quality of the prompt and the context in which the model responds, it is essential
    always to be aware of the prompts you have issued in the current session. Therefore,
    starting with a new session every time you begin a new project is advised. Appendix
    A will walk you through setting up an account, logging in to ChatGPT, and writing
    your first prompt.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文是与ChatGPT一起工作的最重要的方面之一。你之前的*提示*可以极大地改变你当前提示的结果。在ChatGPT这样的语言模型中，提示是指提供给模型以生成响应的输入。它可以是一个句子、一个段落，甚至更长的文本。它作为对模型的指令或查询，指导其响应。鉴于提示的质量和模型响应的上下文，始终意识到你当前会话中发出的提示至关重要。因此，每次开始一个新项目时都建议开始一个新的会话。附录A将指导你如何设置账户、登录ChatGPT以及编写你的第一个提示。
- en: 2.1.1 Navigating nuances with GPT-4
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 使用GPT-4导航细微差别
- en: 'In this section, we will work toward finding a solution to the following question:
    “How would you reserve a singly linked list in Python?”'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将努力寻找以下问题的解决方案：“你如何在Python中保留一个单链表？”
- en: What is a singly linked list?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是单链表？
- en: A *singly linked list* is a fundamental data structure in computer science that
    consists of a sequence of elements, each stored in a node. Generally, singly linked
    lists consist of nodes in which the data is stored and a reference to the next
    node in the linked list.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*单链表*是计算机科学中的一个基本数据结构，由一系列元素组成，每个元素存储在一个节点中。通常，单链表由存储数据的节点和指向链表中下一个节点的引用组成。'
- en: With a singly linked list, you can only travel in one direction. Common operations
    on a singly linked list include insertion (adding a new node), deletion (removing
    a node), searching (finding a node), and traversal (accessing each node sequentially).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单链表，你只能向一个方向移动。单链表上的常见操作包括插入（添加新节点）、删除（移除节点）、搜索（找到节点）和遍历（按顺序访问每个节点）。
- en: 'We will start with this simple prompt:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从以下简单的提示开始：
- en: '|'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/logo-NC.png)'
- en: '| Going forward, when I ask a question, try to formulate a better question.
    As an intern who studied computer science in college, how would you define a singly
    linked list in pseudocode? |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 在我提问时，尽量提出一个更好的问题。作为一名在大学学习计算机科学的实习生，你将如何用伪代码定义单链表？|'
- en: 'Okay, this may not be such a simple prompt. First, we have directed ChatGPT
    to enhance and reformulate our questions based on its training data so we will
    get better prompts. Better prompts make for better output. You may be asking,
    what makes for a better prompt? Great question! General prompts produce general
    results. Specific prompts produce specific results. As we engage with large language
    models (LLMs) generally and ChatGPT specifically, we will go from general to specific,
    refining the output as we go. This is known as the *Refinement Pattern in prompt
    engineering*: iteratively refining or improving the prompt to get more accurate,
    relevant, or sophisticated responses.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这可能不是一个简单的提示。首先，我们指导ChatGPT根据其训练数据增强和重构我们的问题，以便我们得到更好的提示。更好的提示会产生更好的输出。你可能想知道，什么才是更好的提示？这是一个好问题！一般性的提示会产生一般性的结果。具体的提示会产生具体的结果。当我们与大型语言模型（LLMs）以及ChatGPT进行交互时，我们将从一般性转向具体性，在过程中不断改进输出。这被称为提示工程中的**细化模式**：迭代地细化或改进提示，以获得更准确、相关或复杂的回应。
- en: 'The second part of the prompt introduces a prompting pattern we will see throughout
    this book: the *Persona Pattern*. In the context of prompt engineering, mainly
    related to AI and LLMs, the Persona Pattern refers to a strategy of designing
    prompts that establish a specific persona or role for the AI to assume. This approach
    guides the model’s responses consistently and contextually appropriately. One
    of the key benefits of using the Persona Pattern is maintaining consistency in
    responses. Adhering to a defined persona makes the AI’s replies more predictable
    and aligned with the user’s expectations. In this case, we have asked ChatGPT
    to assume the persona of an intern with a background in computer science. Why
    an intern? We want a persona who will do the work.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 提示的第二部分介绍了一种贯穿本书的提示模式：**角色模式**。在提示工程的大背景下，主要与AI和LLMs相关，角色模式指的是为AI设计提示，使其承担一个特定的角色或身份。这种方法可以引导模型以一致和上下文适当的方式回应。使用角色模式的一个关键好处是保持回应的一致性。遵循定义的角色可以使AI的回复更加可预测，并与用户的期望保持一致。在这种情况下，我们要求ChatGPT扮演一个具有计算机科学背景的实习生的角色。为什么是实习生？我们希望有一个会做工作的角色。
- en: It bears repeating that when working with LLMs, even when applying personas,
    the same input will not always produce the same output. For this reason, your
    output may not match the following exactly, but hopefully it is similar. (Note
    that these listings are pseudocode.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 需要重复强调的是，当与LLMs合作时，即使应用角色模式，相同的输入也不一定会产生相同的输出。因此，你的输出可能不会与以下内容完全一致，但希望它是相似的。（注意，这些列表是伪代码。）
- en: Listing 2.1 ChatGPT’s reformulation of our question about reversing a linked
    list
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 ChatGPT对我们关于反转链表问题的重构
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When asked the refined question, ChatGPT will provide the following code listing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当被问及细化的问题时，ChatGPT将提供以下代码列表。
- en: Listing 2.2 ChatGPT’s answer about how to reverse a linked list
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 ChatGPT关于如何反转链表的回答
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: One of the excellent quality-of-life-enhancing features of working with ChatGPT
    is that it will usually provide documentation about the code in question. Figure
    2.1 is a screenshot of the textual description provided by ChatGPT.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与ChatGPT合作的一个极好的提升生活质量的功能是，它通常会提供关于所讨论代码的文档。图2.1是ChatGPT提供的文本描述的截图。
- en: '![](../Images/CH02_F01_Crocker2.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F01_Crocker2](../Images/CH02_F01_Crocker2.png)'
- en: Figure 2.1 ChatGPT Model 4’s explanation of the pseudocode definition of a singly
    linked list
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 ChatGPT模型4对单链表伪代码定义的解释
- en: 'We will now have ChatGPT assume a new role—that of a computer science intern:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将让ChatGPT扮演一个新的角色——计算机科学实习生的角色：
- en: '|'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![logo-NC](../Images/logo-NC.png)'
- en: '| As an intern with a background in computer science, how would you define
    the structure and basic operations of a singly linked list using the programming
    language Python? This definition should include the essential components of the
    list, such as nodes and links, and outline fundamental operations like creating
    a node, adding a node to the list, and traversing the list. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 作为一名具有计算机科学背景的实习生，你将如何使用Python编程语言定义单链表的结构和基本操作？这个定义应包括列表的基本组件，如节点和链接，并概述基本操作，如创建节点、将节点添加到列表中以及遍历列表。|'
- en: Listing 2.3 ChatGPT’s implementation of a singly linked list in Python
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 ChatGPT 在 Python 中实现单链表
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ChatGPT will likely include a sample test harness to run this code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 可能会包含一个示例测试框架来运行此代码。
- en: Listing 2.4 Python-based method to implement and run the singly linked list
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 基于Python实现和运行单链表的方法
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Similarly, we can refine the persona to be an interviewee for an engineering
    job. The switch in personas will signal to the ChatGPT-3.5 model that it should
    explain the code as well as an approach to solving the problem:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以将角色细化为一个工程职位面试的应聘者。角色的转换将向 ChatGPT-3.5 模型发出信号，表明它应该解释代码以及解决问题的方法：
- en: '|'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/logo-NC.png)'
- en: '| You are a student with a background in computer science who is interviewing
    for an engineering job at a software company. You are asked the following question,
    based on the previous definition of a singly linked list (in Python), how would
    you write a method that would reverse the output of the traversal method. How
    would you implement such a method? |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 你是一名具有计算机科学背景的学生，正在一家软件公司面试工程职位。你被问到以下问题，基于之前定义的单链表（在 Python 中），你将如何编写一个方法来反转遍历方法的输出。你将如何实现这样的方法？
    |'
- en: Listing 2.5 ChatGPT’s explanation of how to reverse a singly linked list
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 ChatGPT 解释如何反转单链表
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ChatGPT will likely output text similar to what is shown in figure 2.2, explaining
    the method and the approach to solving the problem.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 可能会输出类似于图 2.2 所示的文本，解释方法和解决问题的方法。
- en: '![](../Images/CH02_F02_Crocker2.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F02_Crocker2.png)'
- en: Figure 2.2 ChatGPT Model 4’s explanation of the pseudocode definition of a reversing
    a linked list
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 ChatGPT 模型 4 对反转链表伪代码定义的解释
- en: This implementation effectively reverses the singly linked list in place, and
    the traversal method will output the elements in reverse order compared to their
    original insertion sequence.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现有效地在原地反转单链表，遍历方法将按与原始插入顺序相反的顺序输出元素。
- en: 2.1.2 Charting paths with GPT-3.5
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 使用 GPT-3.5 绘制路径
- en: In this section, we will explore how to harness the capabilities of ChatGPT-3.5
    to create a singly linked list in Python. ChatGPT-3.5 excels at generating human-like
    text based on the input it receives. This makes it a valuable tool for coding
    assistance, as it can provide step-by-step guidance, suggest improvements, and
    offer detailed explanations of complex programming concepts.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何利用 ChatGPT-3.5 的能力在 Python 中创建单链表。ChatGPT-3.5 在根据接收到的输入生成类似人类的文本方面表现出色。这使得它成为编码辅助的有价值工具，因为它可以提供逐步指导，提出改进建议，并详细解释复杂的编程概念。
- en: To create a singly linked list, we will use ChatGPT-3.5 to generate the necessary
    Python code. A singly linked list is a data structure consisting of nodes, where
    each node contains a value and a reference to the next node in the sequence. This
    structure is particularly useful for dynamic memory allocation and efficient insertions
    and deletions. Using ChatGPT-3.5, we can simplify the process of coding a singly
    linked list, ensuring that our implementation is both efficient and easy to understand.
    The following example demonstrates how to define the `Node` and `LinkedList` classes,
    initialize a list, and perform basic operations such as insertion and traversal.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建单链表，我们将使用 ChatGPT-3.5 生成必要的 Python 代码。单链表是一种由节点组成的数据结构，其中每个节点包含一个值和指向序列中下一个节点的引用。这种结构特别适用于动态内存分配和高效的插入和删除操作。使用
    ChatGPT-3.5，我们可以简化编写单链表代码的过程，确保我们的实现既高效又易于理解。以下示例演示了如何定义 `Node` 和 `LinkedList`
    类，初始化列表，并执行基本操作，如插入和遍历。
- en: Listing 2.6 Implementation of a singly linked list by ChatGPT-3.5
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 ChatGPT-3.5 实现单链表
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can apply the Persona Pattern in either direction: you can tell the LLM
    to respond as though it were someone or something within a given role, or you
    can ask the LLM to assume that you are a certain persona. This can be very useful
    when you need to explain some code in simplified terms or are attempting to understand
    complex or complicated topics. For example, we can ask ChatGPT to explain our
    code to us in a simplified manner with this prompt:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任一方向应用角色模式：您可以告诉大型语言模型（LLM）以某个角色中的人或事物的身份回应，或者您可以要求 LLM 假设您是某个角色。这在您需要用简化的术语解释一些代码或试图理解复杂或复杂主题时非常有用。例如，我们可以使用以下提示让
    ChatGPT 以简化的方式向我们解释我们的代码：
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![](../Images/logo-NC.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/logo-NC.png)'
- en: '| Assume that I am an adult who graduated from college with a degree in communications.
    I have no experience with computer science. How would you explain that method
    to me? |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 假设我是一个成年人，已经从大学毕业，获得了传播学学位。我没有计算机科学方面的经验。你会如何向我解释那个方法？ |'
- en: Let’s examine how ChatGPT would explain our method to someone without a computer
    science background.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看ChatGPT会如何向没有计算机科学背景的人解释我们的方法。
- en: Listing 2.7 ChatGPT explanation for someone who is not a computer scientist
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7：为非计算机科学家解释ChatGPT
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you use the Persona Pattern in reverse, it is commonly referred to as the
    *Audience Persona Pattern* in the context of prompt engineering. This refers to
    a predefined profile or representation of the intended audience for a particular
    application or use case. It helps in tailoring the responses generated by LLMs
    to better suit the needs and expectations of a specific group of users or individuals.
    Before we move on to GitHub CoPilot, let’s compare the output quality of each
    model.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用反向的Persona模式时，在提示工程的环境中通常被称为*受众Persona模式*。这指的是为特定应用或用例预定义的受众档案或表示。它有助于调整由大型语言模型（LLM）生成的响应，以更好地满足特定用户群体或个人的需求和期望。在我们继续讨论GitHub
    CoPilot之前，让我们比较每个模型的输出质量。
- en: '2.1.3 Navigating the AI seas: From the shores of GPT-3.5 to the horizons of
    GPT-4'
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 在AI海洋中导航：从GPT-3.5的岸边到GPT-4的地平线
- en: One of the significant differences between the output of these two models is
    in the sophistication and transparency of their outputs, particularly in how these
    models interact with and modify data structures. The difference between the approaches
    used by GPT-3.5 and GPT-4 underscores a broader shift toward greater clarity and
    predictability in AI-generated code. As AI models become more advanced, their
    output increasingly reflects the nuances of good programming practices, mirroring
    the evolution of human programmers’ skills and sensibilities. This evolution is
    crucial for AI to be a reliable partner in software development, where clarity
    and precision are not just ideals but necessities.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个模型输出之间的一个显著差异在于它们输出的复杂性和透明度，尤其是在这些模型如何与数据结构交互和修改方面。GPT-3.5和GPT-4所采用方法的差异凸显了人工智能生成代码向更高清晰度和可预测性转变的更广泛趋势。随着人工智能模型变得更加先进，它们的输出越来越多地反映了良好的编程实践细微差别，这与人类程序员技能和敏感性的演变相呼应。这种演变对于人工智能成为软件开发中可靠的合作伙伴至关重要，在软件开发中，清晰度和精确性不仅是理想，而且是必需的。
- en: With GPT-3.5, the approach taken in the `reverse_and_display` method was somewhat
    opaque in its execution. This version of the model altered the underlying data
    structure of the linked list, effectively reversing the nodes. However, it did
    so without explicitly signaling this change to the user. From a developer’s standpoint,
    this could lead to unexpected side effects. For instance, if we were to call `reverse_and_display`
    with the assumption of merely displaying the reversed list, we would find that
    the original list structure had been permanently altered. This lack of transparency
    in the operation could easily lead to confusion and bugs, especially in more complex
    applications where the integrity of the original data structure is crucial.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPT-3.5中，`reverse_and_display`方法在执行过程中有些不透明。这个模型版本改变了链表的基本数据结构，实际上反转了节点。然而，它并没有明确向用户发出这种变化的信号。从开发者的角度来看，这可能导致意外的副作用。例如，如果我们假设只是显示反转后的列表而调用`reverse_and_display`，我们会发现原始的列表结构已经被永久改变。这种操作的不透明性很容易导致混淆和错误，尤其是在原始数据结构完整性至关重要的更复杂应用中。
- en: 'In contrast, GPT-4 exhibits a more refined approach with its `reverse` method.
    This method explicitly reverses the linked list, and any seasoned programmer could
    infer from the name and structure of the method that it would modify the underlying
    data structure. GPT-4’s methodology aligns more closely with clear and maintainable
    code principles. It embodies the idea that each function or method should perform
    a well-defined task. The separation of concerns is evident here: the reversal
    of the list and its display are treated as distinct operations. This enhances
    code readability and reduces the likelihood of unintended side effects, as the
    developer is fully aware of the changes applied to the data structure.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，GPT-4 使用其 `reverse` 方法展示了更为精细的方法。这个方法明确地反转了链表，任何经验丰富的程序员都可以从方法的名字和结构中推断出它将修改底层的数据结构。GPT-4
    的方法更符合清晰和可维护的代码原则。它体现了每个函数或方法应该执行一个定义良好的任务的观念。关注点的分离在这里是明显的：列表的反转和显示被视为不同的操作。这增强了代码的可读性，并减少了意外副作用的可能性，因为开发者完全清楚对数据结构所做的更改。
- en: 2.2 Let Copilot take control
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 让 Copilot 掌控全局
- en: 'Now let’s use GitHub Copilot to tackle the same problem. Appendix B has instructions
    on creating an account and installing the plugin into your favorite integrated
    development environment (IDE; assuming your favorite IDE is either VS Code or
    PyCharm). Once you have completed the installation, you should create a new project
    in your IDE. First, create a new file named main.py. At the beginning of this
    file, enter the following comment/prompt:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 GitHub Copilot 来解决相同的问题。附录 B 中有创建账户和将插件安装到您喜欢的集成开发环境（IDE；假设您的 IDE 是
    VS Code 或 PyCharm）的说明。一旦您完成安装，您应该在您的 IDE 中创建一个新的项目。首先，创建一个名为 main.py 的新文件。在这个文件的开始处，输入以下注释/提示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note the hash character at the beginning; it denotes a Python comment. What
    is particularly interesting is that we used the same prompt in ChatGPT and GitHub
    Copilot.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意开头的哈希字符；它表示 Python 注释。特别有趣的是，我们在 ChatGPT 和 GitHub Copilot 中使用了相同的提示。
- en: Next, note that as you begin to type the definition of the `ListNode` class,
    Copilot will make code suggestions. This is the inline mode of engagement. Alternatively,
    you can activate the interactive model by pressing Ctrl-Enter and have Copilot
    generate up to 10 recommendations based on the current context.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意，当你开始输入 `ListNode` 类的定义时，Copilot 将提供代码建议。这是内联模式的互动。或者，你可以通过按 Ctrl-Enter
    激活交互式模型，让 Copilot 根据当前上下文生成最多 10 个建议。
- en: NOTE Throughout the book, we will mainly use inline mode, in which you use the
    Tab key to accept a given suggestion.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在整个书中，我们将主要使用内联模式，其中你使用 Tab 键接受给定的建议。
- en: 'You will likely get code resembling the source code created by ChatGPT. Let’s
    try a slightly different programming challenge rather than reprint the same code
    from the previous section. We will ask the following of Copilot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会得到类似于 ChatGPT 创建的源代码的代码。让我们尝试一个稍微不同的编程挑战，而不是重新打印上一节中的相同代码。我们将向 Copilot 提出以下要求：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After a few carriage returns, Copilot should add some comments that discuss
    this code’s time and space complexity and the problem in general. Fascinating!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 几次换行后，Copilot 应该添加一些注释来讨论这段代码的时间复杂度和空间复杂度以及一般问题。真令人着迷！
- en: Listing 2.8 ChatGPT calculating and reporting the complexity of this code
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.8 ChatGPT 计算并报告这段代码的复杂度
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Copilot’s suggestion is admirable and completely valid, but it would not likely
    be an acceptable answer during an interview. It feels like a cheat. We should
    expect that there would be a follow-up question about how to do this without sorting
    the entire list. Let’s refine the prompt to ensure that the list is not sorted
    before taking the *k*th element:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 的建议是值得称赞的，并且完全合理，但在面试中可能不太可能是一个可接受的答案。它感觉像是在作弊。我们应该期待会有一个后续问题，询问如何在不需要对整个列表进行排序的情况下完成这个任务。让我们完善提示，确保在取第
    *k* 个元素之前不排序列表：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code that Copilot provides looks very similar to a binary search, which
    is certainly an interesting choice.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 提供的代码看起来非常类似于二分查找，这当然是一个有趣的选择。
- en: Listing 2.9 Copilot’s approach to solving the *k*th element problem
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.9 Copilot 解决第 *k* 个元素问题的方法
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 2.3 Let CodeWhisperer speak loudly
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 让 CodeWhisperer 大声说话
- en: Before we begin using CodeWhisperer, we should disable Copilot. Click the Extensions
    tab, and search for Copilot. Once you have found it, click the Disable button.
    You will need to restart the application. When the application has restarted,
    you can begin to use CodeWhisperer. If you need assistance installing or configuring
    CodeWhisperer, refer to appendix C. Once the plugin is installed and you are logged
    in to your developer account, create a file called asset.py. Figure 2.3 shows
    how to locate and disable this plug-in.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 CodeWhisperer 之前，我们应该禁用 Copilot。点击扩展选项卡，搜索 Copilot。一旦找到它，点击禁用按钮。您需要重新启动应用程序。当应用程序重新启动后，您就可以开始使用
    CodeWhisperer。如果您需要安装或配置 CodeWhisperer 的帮助，请参阅附录 C。一旦插件安装完成，并且您已登录到您的开发者账户，创建一个名为
    asset.py 的文件。图 2.3 展示了如何定位和禁用此插件。
- en: '![](../Images/CH02_F03_Crocker2.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F03_Crocker2.png)'
- en: Figure 2.3 Before we can switch to CodeWhisperer, we must disable Copilot. We
    turn off the extension in the Extensions tab.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 在我们可以切换到 CodeWhisperer 之前，我们必须禁用 Copilot。我们在扩展选项卡中关闭了扩展。
- en: 'We will use the same prompt that we used for Copilot. It is reprinted here
    for convenience:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与 Copilot 相同的提示。这里重新打印出来以方便查阅：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code that CodeWhisperer provides implements the Quickselect algorithm, which
    is closely related to the QuickSort sorting algorithm. Quickselect is specifically
    designed to efficiently find the *k*th smallest element in an unsorted array.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: CodeWhisperer 提供的代码实现了快速选择算法，该算法与快速排序算法密切相关。快速选择算法专门设计用于高效地在一个未排序的数组中找到第 *k*
    个最小的元素。
- en: Listing 2.10 CodeWhisperer’s approach to solving the *k*th element problem
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10 CodeWhisperer 解决第 *k* 个元素问题的方法
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is a fascinating distinction between the code created by Copilot and that
    of CodeWhisperer. CodeWhisperer interprets `k` as the index of the element in
    the sorted array. Because array indices in most programming languages start at
    0, if `k` is 2, CodeWhisperer will find the third-smallest element (because indices
    0, 1, and 2 correspond to the first, second, and third smallest elements, respectively).
    On the other hand, Copilot assumes that `k` refers to the rank of the element,
    not the index. So, if `k` is 2, Copilot will return the second-smallest element
    in the array. This is akin to saying “second place” rather than “index 2.”
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 和 CodeWhisperer 生成的代码之间存在一个有趣的区别。CodeWhisperer 将 `k` 解释为排序数组中元素的索引。由于大多数编程语言中的数组索引从
    0 开始，如果 `k` 是 2，CodeWhisperer 将找到第三小的元素（因为索引 0、1 和 2 分别对应于第一个、第二个和第三个最小的元素）。另一方面，Copilot
    假设 `k` 指的是元素的排名，而不是索引。因此，如果 `k` 是 2，Copilot 将返回数组中的第二个最小的元素。这类似于说“第二名”而不是“索引 2”。
- en: In this section, we introduced AWS CodeWhisperer into the mix. Like its predecessors,
    CodeWhisperer capably generated code that solves the problem, reinforcing AI’s
    transformative potential in software development.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将 AWS CodeWhisperer 引入讨论。像其前辈一样，CodeWhisperer 能够生成解决该问题的代码，强化了 AI 在软件开发中的变革潜力。
- en: 'Given the striking similarity of the code produced by these tools, an intriguing
    question naturally arises: how do these products truly compare? Given each tool’s
    unique strengths and limitations, the answer is not as straightforward as you
    may think.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些工具生成的代码具有显著的相似性，一个有趣的问题自然产生：这些产品真正是如何比较的？考虑到每个工具的独特优势和局限性，答案可能不像您想象的那么简单。
- en: In the following section, we’ll delve into this question, comparing these three
    tools—ChatGPT, Copilot, and AWS CodeWhisperer—in a bid to understand their unique
    offerings, optimal use cases, and how they may reshape the future of software
    development. We aim to provide a comprehensive guide that can help software developers
    navigate this rapidly evolving landscape of AI-driven tools.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨这个问题，比较这三个工具——ChatGPT、Copilot 和 AWS CodeWhisperer——以了解它们的独特功能、最佳用例以及它们如何可能重塑软件开发的未来。我们的目标是提供一份全面的指南，帮助软件开发者在这个快速发展的
    AI 驱动工具领域中导航。
- en: 2.4 Comparing ChatGPT, Copilot, and CodeWhisperer
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 比较 ChatGPT、Copilot 和 CodeWhisperer
- en: 'The first dimension we will consider is the engagement model: how we engage
    with AI. In the case of ChatGPT, we log in to the chat website and enter prompts
    into a chat input box. Then we refine our requirements in subsequent prompts.
    The feedback loop takes the context from the previous prompts, applies it to the
    current prompt, and generates output to which the user reacts and refires. If
    we contrast this engagement model against that of Copilot and CodeWhisperer, we
    note that the latter two tools work within an IDE. We can’t use it outside our
    IDE, try as we may. The approach is not inherently inferior; it just differs.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑的第一个维度是参与模型：我们如何与AI互动。在ChatGPT的情况下，我们登录到聊天网站，并在聊天输入框中输入提示。然后我们在后续的提示中细化我们的要求。反馈循环从先前的提示中获取上下文，将其应用于当前提示，并生成用户反应和重新触发的输出。如果我们将这种参与模型与Copilot和CodeWhisperer的参与模型进行对比，我们会注意到后两种工具在IDE内部工作。我们无法在IDE之外使用它，尽管我们可能尝试过。这种方法本身并不低劣；它只是不同而已。
- en: 'The way that Copilot and CodeWhisperer keep you in your IDE can be seen as
    a benefit rather than a deficiency. In later chapters, we will get acquainted
    with Copilot Chat, the best of both worlds: ChatGPT and GPT-4, all in your IDE.
    These tools keep you in your code without distraction for longer. Working distraction-free
    is one of the keys to productivity. Copilot and CodeWhisperer excel at getting
    out of your way, keeping you from switching contexts, freeing you from distraction,
    and keeping you in the flow state longer. They do this well. You engage ChatGPT
    in a dialog; Copilot and CodeWhisperer advise you. The dialog takes longer; advice
    comes fast and free.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot和CodeWhisperer让你留在IDE中的方式可以被视为一种优势而不是缺陷。在后面的章节中，我们将熟悉Copilot Chat，这是两者的最佳结合：ChatGPT和GPT-4，全部都在你的IDE中。这些工具让你在代码中保持专注，不受干扰的时间更长。无干扰工作是提高生产力的关键之一。Copilot和CodeWhisperer擅长为你清除障碍，防止你切换上下文，让你摆脱干扰，并让你保持流畅状态的时间更长。他们做得很好。你与ChatGPT进行对话；Copilot和CodeWhisperer为你提供建议。对话可能需要更长的时间；建议来得快且免费。
- en: Next, we will examine how the code is presented and generated. ChatGPT can create
    the code as a block, method, class, or project. ChatGPT reveals projects deliberatively
    if asked. But it does create the project behind the scenes. ChatGPT, after all,
    likes to talk. With Copilot and CodeWhisperer, the code unfolds one method at
    a time, at least initially. As you use these tools more, you will notice that
    they can write more and more of the code for a given class. But unfortunately,
    they can’t write an entire project with a tiny prompt.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查代码是如何呈现和生成的。ChatGPT可以将代码作为一个块、方法、类或项目来创建。如果被要求，ChatGPT会故意揭示项目。但它在幕后确实创建了项目。毕竟，ChatGPT喜欢说话。与Copilot和CodeWhisperer一起，代码至少最初是一行一行地展开的。随着你更频繁地使用这些工具，你会注意到它们可以为给定的类编写越来越多的代码。但不幸的是，它们不能通过微小的提示来编写整个项目。
- en: One item that they all share is their ability to respond to prompts. With ChatGPT,
    prompts are the only way to engage with the tool. With Copilot and CodeWhisperer,
    responding to prompts is not strictly necessary, but coding such prompts will
    make the output correspond more closely to what you initially had in mind.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它们共同拥有的一个特点是它们对提示的反应能力。在ChatGPT中，提示是唯一与工具互动的方式。在Copilot和CodeWhisperer中，对提示的反应不是严格必要的，但编写这样的提示会使输出更接近你最初的想法。
- en: Combining these factors, you may conclude that ChatGPT is an excellent choice
    for exploration and prototyping. However, ChatGPT can introduce unnecessary distractions,
    partly because you have left your IDE and are now in a web browser with all of
    the accompanying temptations that come with it. ChatGPT itself is part of the
    inclusion of unnecessary distractions. You will eventually fall into the proverbial
    rabbit hole. The tool makes it too easy not to. Don’t let that scare you off.
    It is a beautiful resource.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这些因素，你可能会得出结论，ChatGPT是探索和原型设计的绝佳选择。然而，ChatGPT可能会引入不必要的干扰，部分原因是因为你已经离开了IDE，现在在一个带有所有伴随诱惑的网页浏览器中。ChatGPT本身也是引入不必要的干扰的一部分。你最终可能会陷入俗语中的兔子洞。这个工具让你太容易不做这件事了。不要让这吓到你。这是一个美丽的资源。
- en: Copilot and CodeWhisperer require that you have a desired outcome in mind. Therefore,
    these tools are perfect for when you want to go head down, coding with precise
    requirements and tight deadlines. Copilot and CodeWhisperer work best when you
    know the language and the framework. They can automate much of the drudgery, allowing
    you to focus on the business requirements, which add value and are likely why
    you are writing the software in the first place. Figure 2.4 briefly summarizes
    the benefits and limitations of all three generative AIs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot和CodeWhisperer要求你心中有一个期望的结果。因此，这些工具非常适合当你想要全力以赴，按照精确的要求和紧迫的截止日期进行编码时。当你了解语言和框架时，Copilot和CodeWhisperer的工作效果最佳。它们可以自动化许多繁琐的工作，让你能够专注于业务需求，这些需求增加了价值，也可能是你最初编写软件的原因。图2.4简要总结了所有三个生成式AI的优点和局限性。
- en: '![](../Images/CH02_F04_Crocker2.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F04_Crocker2.png)'
- en: Figure 2.4 A comparison of the positives and negatives of ChatGPT, Copilot,
    and CodeWhisperer
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 ChatGPT、Copilot和CodeWhisperer的优缺点比较
- en: In this chapter, we went through a lot, implementing basic data structures and
    solving some classic computer science problems. The work in this chapter is foundational,
    allowing us to better recognize when it makes sense to use ChatGPT as opposed
    to when to use the other IDE-focused tools such as Copilot and CodeWhisperer.
    In subsequent chapters, we will use this knowledge to choose the most suitable
    tool.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们经历了很多，实现了基本的数据结构，并解决了一些经典的计算机科学问题。本章的工作是基础性的，使我们能够更好地判断何时使用ChatGPT，而不是使用其他以IDE为中心的工具，如Copilot和CodeWhisperer。在随后的章节中，我们将利用这些知识来选择最合适的工具。
- en: 'One final note: these tools work best when they work together. ChatGPT is an
    excellent tool for example and structure. Copilot and CodeWhisperer allow you
    to extend and customize the code.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点：这些工具在协同工作时效果最佳。例如，ChatGPT是一个出色的工具，用于示例和结构。Copilot和CodeWhisperer允许你扩展和自定义代码。
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: ChatGPT is a prompt-based Generative AI that engages the user in a dialogue
    that helps them explore ideas to aid in the design and development of entire projects.
    In addition, ChatGPT artfully generates documentation for each method it writes.
    One of the reasons we began the chapter using it is that it helped define a template
    we used throughout the remainder of the chapter. It is a fascinating product,
    one that can lead to unnecessary albeit enjoyable distractions.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChatGPT是一种基于提示的生成式AI，通过与用户进行对话来帮助他们探索想法，以帮助设计和开发整个项目。此外，ChatGPT巧妙地为它所编写的每个方法生成文档。我们之所以在章节开始时使用它，其中一个原因就是它帮助我们定义了一个在章节剩余部分使用的模板。这是一个令人着迷的产品，它可能导致不必要的但令人愉快的分心。
- en: Copilot and CodeWhisperer are head-down tools that work best when you know what
    you want to do and need some advice about how best to get it done. You engage
    with these tools in a way that is remarkably similar, as are the results.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot和CodeWhisperer是专注型工具，当你知道你想做什么并需要关于如何最好地完成它的建议时，它们的效果最佳。你与这些工具的互动方式非常相似，结果也是如此。
- en: ChatGPT (as of this writing) does not support development within an IDE. However,
    unlike GitHub Copilot and AWS CodeWhisperer, it can produce entire projects and
    easily translate code from one programming language to another. Copilot and CodeWhisperer
    take hints from your comments to infer what code you want to write. With ChatGPT,
    you explicitly write prompts that ChatGPT uses to create the code.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChatGPT（截至本文写作时）不支持在IDE中进行开发。然而，与GitHub Copilot和AWS CodeWhisperer不同，它能够生成整个项目，并且能够轻松地将代码从一种编程语言翻译成另一种。Copilot和CodeWhisperer会从你的注释中获取提示，以推断你想要编写的代码。使用ChatGPT时，你需要明确写出ChatGPT用来创建代码的提示。
- en: The purpose of the Persona Pattern is to design prompts that establish a specific
    persona or role for the AI to assume, which guides the model’s responses in a
    consistent and contextually appropriate manner. By adhering to a defined persona,
    the AI’s replies become more predictable and aligned with the user’s expectations.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个性模式的目的是为AI设计提示，使AI承担一个特定的个性或角色，从而以一致和情境适当的方式引导模型的响应。通过遵循定义好的个性，AI的回复变得更加可预测，并与用户的期望保持一致。
- en: The intern persona is often characterized by eagerness to learn, a basic to
    intermediate level of knowledge in the field, and a willingness to take on various
    tasks for learning and experience. The intern may ask clarifying questions, seek
    guidance, and demonstrate a proactive approach to problem-solving. They are often
    resourceful but may lack the deep expertise of more experienced professionals
    in the field. This persona is useful in scenarios where the AI needs to simulate
    a learning and growth-oriented mindset.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实习生的角色通常被描述为渴望学习，对所在领域的知识具有基础到中级水平，并且愿意承担各种学习与经验积累的任务。实习生可能会提出澄清问题，寻求指导，并展现出积极主动的解决问题的态度。他们通常很机智，但可能缺乏该领域经验更丰富的专业人士的深厚专业知识。这种角色在AI需要模拟一个以学习和成长为导向的心态的场景中非常有用。
- en: The Refinement Pattern involves iteratively refining or improving the prompt
    to get more accurate, relevant, or sophisticated responses. It’s about going from
    general to specific, enhancing the output quality as the interaction progresses
    with large language models like ChatGPT.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精炼模式涉及迭代地精炼或改进提示，以获得更准确、相关或复杂的响应。这关乎从一般到具体，随着与像ChatGPT这样的大型语言模型的交互进展，不断提升输出质量。
- en: The Audience Persona Pattern is a variation of the Persona Pattern in prompt
    engineering. It involves defining a profile or representation of the intended
    audience for a particular application or use case, which helps tailor the responses
    generated by LLMs to better suit the needs and expectations of a specific group
    of users or individuals.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受众角色模式是提示工程中角色模式的一种变体。它涉及定义特定应用或用例的目标受众的档案或代表，这有助于调整由LLM（大型语言模型）生成的响应，以更好地满足特定用户群体或个人的需求和期望。
