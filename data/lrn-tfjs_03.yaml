- en: Chapter 2\. Introducing TensorFlow.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。介绍TensorFlow.js
- en: “If your actions inspire others to dream more, learn more,
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “如果你的行动激励他人梦想更多，学习更多，
- en: do more, and become more, you are a leader.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 做更多，成为更多，你就是一个领导者。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —John Quincy Adams
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —约翰·昆西·亚当斯
- en: We’ve been talking about TensorFlow.js a bit and what it can do, but we haven’t
    really dug into what a machine learning framework like TensorFlow.js actually
    is. In this chapter, we’ll tackle the concept of a machine learning framework
    and then quickly dive into writing code. I know it’s important to write code that
    has some kind of tangible outcome, so in this chapter, you’ll finally get your
    computer running TensorFlow.js and producing results.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微谈到了TensorFlow.js以及它的功能，但我们还没有真正深入探讨像TensorFlow.js这样的机器学习框架到底是什么。在本章中，我们将探讨机器学习框架的概念，然后迅速进入编写代码。我知道编写具有某种实际结果的代码很重要，所以在本章中，你最终将让你的计算机运行TensorFlow.js并产生结果。
- en: 'We will:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将：
- en: Look at the concept of TensorFlow.js
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看TensorFlow.js的概念
- en: Set up TensorFlow.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置TensorFlow.js
- en: Run a TensorFlow.js model package
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行一个TensorFlow.js模型包
- en: Take a deep look at what the AI did
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解AI的工作原理
- en: Let’s start with the framework we’ll be using to make it all happen.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们将使用的框架开始。
- en: Hello, TensorFlow.js
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好，TensorFlow.js
- en: Given how our previous chapter discussed the philosophies of ancient times and
    the birth of machine learning as a field, you’d expect AI frameworks to have a
    history that reaches as far back as the early 1960s. However, AI was stagnant
    for a long time, and this time is often called “AI winter.” The concepts of AI
    were beleaguered by disbelief and extreme mathematical calculations for the small
    data that was available. Who could blame these researchers? Most software developers
    today depend on shipping apps without writing GPU-enabled linear algebra and calculus
    from scratch, and building your own AI shouldn’t be the exception. Fortunately,
    due to some open source contributions from the Google Brain team, we have options.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们之前的章节讨论了古代哲学和机器学习作为一个领域的诞生，你会期望人工智能框架的历史可以追溯到上世纪60年代初。然而，人工智能长时间停滞不前，这段时间通常被称为“人工智能寒冬”。人工智能的概念受到怀疑和极端数学计算的困扰，因为当时可用的数据量很小。谁能责怪这些研究人员呢？今天大多数软件开发人员依赖于发布应用程序，而不是从头开始编写支持GPU的线性代数和微积分，构建自己的人工智能不应该是例外。幸运的是，由于谷歌Brain团队的一些开源贡献，我们有了选择。
- en: There’s a lot of buzzwords that get thrown around when you’re starting machine
    learning. TensorFlow, TensorFlow Lite, and TensorFlow.js can all be mentioned,
    and it’s not clear to most newcomers what these terms mean or why there are even
    three of them. For now, let’s ignore the term *tensor*, as you’ve heard the word
    in [Chapter 1](ch01.html#the_chapter_1) and you’ll really get to understand it
    in subsequent chapters. Instead, let’s focus on defining TensorFlow.js so we can
    use it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始学习机器学习时，会听到很多流行词。TensorFlow、TensorFlow Lite和TensorFlow.js都可能被提到，对于大多数新手来说，这些术语的含义以及为什么会有三个都不清楚。现在，让我们暂时忽略“张量”这个术语，因为你在[第1章](ch01.html#the_chapter_1)中已经听过这个词，而且在接下来的章节中你会真正理解它。相反，让我们专注于定义TensorFlow.js，以便我们可以使用它。
- en: TensorFlow, without any extra “.js” or “Lite,” was Google’s first public machine
    learning framework; the Google Brain team released it in late 2015.^([1](ch02.html#idm45049254746888))
    This framework focused on effectively solving machine learning problems for Google
    in the cloud with Python. It wasn’t long before Google realized there would be
    benefits to pushing this popular framework to IoT and mobile devices that have
    limited computing power, and that required an adaptation of TensorFlow, which
    is known as TensorFlow Lite. This successful adaptation paved the way to push
    TensorFlow ideals into other languages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow，没有任何额外的“.js”或“Lite”，是谷歌的第一个公开的机器学习框架；谷歌Brain团队于2015年底发布了它。这个框架专注于用Python在云端有效解决谷歌的机器学习问题。谷歌很快意识到将这个流行的框架推广到计算能力有限的物联网和移动设备上会有好处，这就需要对TensorFlow进行适应，这就是所谓的TensorFlow
    Lite。这一成功的适应为将TensorFlow理念推广到其他语言铺平了道路。
- en: You can probably guess what happened next. In early 2018, Google announced a
    Google-backed JavaScript import of the machine learning framework TensorFlow for
    JavaScript, called TensorFlow.js. This new effort empowered the practicality of
    TensorFlow in a whole new way. Daniel Smilkov, Nikhil Thorat, and Shanqing Cai
    were part of a team that released TensorFlow.js. At the [TensorFlow Developer
    Summit](https://youtu.be/YB-kfeNIPCE), Smilkov and Thorat train a model to control
    a *PAC-MAN* game using computer vision and a webcam in the browser.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能可以猜到接下来会发生什么。2018年初，谷歌宣布了一个由谷歌支持的JavaScript导入机器学习框架TensorFlow的版本，称为TensorFlow.js。这一新举措以全新的方式增强了TensorFlow的实用性。Daniel
    Smilkov、Nikhil Thorat和Shanqing Cai是发布TensorFlow.js的团队的一部分。在[TensorFlow开发者峰会](https://youtu.be/YB-kfeNIPCE)上，Smilkov和Thorat使用计算机视觉和网络摄像头训练一个模型来控制*吃豆人*游戏。
- en: It was this moment when the “Python-only” chains were removed from options of
    popular AI frameworks, and neural networks could effectively traverse the JavaScript
    domain. *If you can run JavaScript, you can run AI that is powered by TensorFlow.js
    ML.*
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这一刻，“仅限Python”的选项被从流行的人工智能框架选项中移除，神经网络可以有效地穿越JavaScript领域。*如果你可以运行JavaScript，你就可以运行由TensorFlow.js
    ML支持的人工智能。*
- en: 'All three of these implementations are alive today and grow with their specific
    purpose. By expanding TensorFlow to a JavaScript implementation, we can now implement
    AI/ML with node servers and even the client browser. In the paper “TensorFlow.js:
    Machine Learning for the Web and Beyond” [(Daniel Smilkov et al., 2019)](https://oreil.ly/XkIjZ),
    they state, “TensorFlow.js has empowered a new set of developers from the extensive
    JavaScript community to build and deploy machine learning models and enabled new
    classes of on-device computation.” TensorFlow.js can leverage a vast platform
    of devices while still accessing the GPU and even Web Assembly. With JavaScript,
    our machine learning can venture to the horizon and back.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '这三种实现今天都是活跃的，并随着它们特定目的的增长。通过将TensorFlow扩展到JavaScript实现，我们现在可以在节点服务器甚至客户端浏览器中实现AI/ML。在论文“TensorFlow.js:
    用于Web和更多的机器学习”中[(Daniel Smilkov等人，2019)](https://oreil.ly/XkIjZ)，他们表示，“TensorFlow.js使来自庞大JavaScript社区的新一代开发人员能够构建和部署机器学习模型，并实现新类的设备上计算。”
    TensorFlow.js可以利用广泛的设备平台，同时仍然可以访问GPU甚至Web Assembly。有了JavaScript，我们的机器学习可以涉足地平线并回来。'
- en: It’s also worth noting that in several benchmarking tests, Node has outperformed
    Python 3 with lower CPU load,^([2](ch02.html#idm45049254735528)) so while Python
    has been the adopted language of most AI, JavaScript serves as a parimary language
    platform for products and services.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在几项基准测试中，Node在较低的CPU负载下胜过了Python 3，因此尽管Python一直是大多数AI的采用语言，JavaScript作为产品和服务的主要语言平台。
- en: But there’s no need to remove or promote any one language. TensorFlow models
    are based on directed acyclic graphs (DAGs), which are language-independent graphs
    that are the *output* of the training. These graphs can be trained by one language
    and then converted and consumed by a completely different programming language.
    It’s the goal of this book to arm you with the tools you’ll need to get the most
    out of using JavaScript and TensorFlow.js.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但没有必要删除或推广任何一种语言。TensorFlow模型基于有向无环图（DAG），这是与语言无关的图，是训练的*输出*。这些图可以由一种语言训练，然后转换并被完全不同的编程语言消耗。本书的目标是为您提供使用JavaScript和TensorFlow.js的工具，以便充分利用它们。
- en: Leveraging TensorFlow.js
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用TensorFlow.js
- en: For a lot of people, “learning” can sometimes mean starting at the fundamentals,
    which means starting with the mathematics. For those people, a framework like
    TensorFlow and a pragmatic branch of a framework like TensorFlow.js is a poor
    start. In this book, we’ll be building projects and touching on the fundamentals
    of the framework of TensorFlow.js, and we’ll spend little time, if any, on the
    underlying mathematical magic.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于很多人来说，“学习”有时可能意味着从基础开始，这意味着从数学开始。对于这些人来说，像TensorFlow这样的框架和像TensorFlow.js这样的实用分支是一个糟糕的开始。在本书中，我们将构建项目，并涉及TensorFlow.js框架的基础知识，我们将很少或根本不花时间在底层数学魔法上。
- en: Frameworks like TensorFlow and TensorFlow.js help us avoid the specifics of
    the linear algebra involved. You’re freed from terms like *forward propagation*
    and *backpropagation*, as well as their computations and calculus. Instead, we’ll
    be focused on industry terms like *inference* and *model training*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 像TensorFlow和TensorFlow.js这样的框架帮助我们避免涉及的线性代数的具体细节。您不再需要关注*前向传播*和*反向传播*这样的术语，以及它们的计算和微积分。相反，我们将专注于像*推断*和*模型训练*这样的行业术语。
- en: While TensorFlow.js can access lower-layer APIs (such as `tfjs-core`) to do
    some fundamental optimization on classical problems, those moments are left to
    the academics and advanced users who have a strong foundation regardless of the
    framework at hand. This book is meant to show the power of TensorFlow.js, and
    utilizing the hard work and optimization of the framework is how we’ll do that.
    We leave TensorFlow.js the job of configuring and optimizing our code to work
    with the wide variety of device constraints and WebGL APIs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然TensorFlow.js可以访问底层API（如`tfjs-core`）来对经典问题进行一些基本优化，但这些时刻留给了那些无论手头的框架如何都有坚实基础的学者和高级用户。这本书旨在展示TensorFlow.js的强大之处，利用框架的辛勤工作和优化是我们将如何做到这一点。我们让TensorFlow.js负责配置和优化我们的代码，以适应各种设备约束和WebGL
    API。
- en: We might even take things a bit too far and apply machine learning to algorithms
    you could easily code by hand, but that’s generally where most people really grasp
    concepts clearly. Solving simple problems you understand with machine learning
    helps you extrapolate the steps, logic, and trade-offs of solving advanced problems
    you could never code by hand.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可能走得太远，将机器学习应用于您可以轻松手工编码的算法，但这通常是大多数人真正理解概念的地方。用机器学习解决您理解的简单问题有助于您推断解决您无法手工编码的高级问题的步骤、逻辑和权衡。
- en: On the other side of the coin, some fundamentals of neurons, activation functions,
    and model initialization cannot be ignored and may require some explanation. It’s
    the goal of this book to give you a healthy balance of theory and practicality.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一些关于神经元、激活函数和模型初始化的基础知识是不能被忽视的，可能需要一些解释。本书的目标是为您提供理论和实用性的健康平衡。
- en: As you might have surmised, the variety of platforms for TensorFlow.js means
    that there’s no singular prescribed setup. We’ll be able to run TensorFlow.js
    in a client or a server for this book. However, our most tacit interactive option
    is to take full advantage of the browser. For that reason, we’ll perform the lion’s
    share of examples in the browser. We will, of course, still cover the key aspects
    of hosting a node server solution where appropriate. Each of these two tools has
    their underlying drawbacks and benefits, which we’ll mention as we venture into
    the power of TensorFlow.js.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经推测到的那样，TensorFlow.js的各种平台意味着没有单一的预设设置。我们可以在本书中在客户端或服务器上运行TensorFlow.js。然而，我们最隐性的交互选项是充分利用浏览器。因此，我们将在浏览器中执行大部分示例。当然，在适当的情况下，我们仍将涵盖托管节点服务器解决方案的关键方面。这两种工具都有各自的优缺点，我们将在探索TensorFlow.js的强大之处时提到。
- en: Let’s Get TensorFlow.js Ready
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们准备好TensorFlow.js
- en: Like any popular tool, you might notice there are several flavors for the TensorFlow.js
    package, as well as several locations where you can access the code. The majority
    of this book will focus on the most available and “ready to run” versions of TensorFlow.js,
    which means the browser client. Optimized builds of the framework are made for
    the server side. These builds talk to the same underlying C++ core API that Python
    does, but via Node.js, which allows you to leverage all the performance of your
    server’s graphics card or CPU. TensorFlow.js AI models run in a variety of locations
    and utilize a variety of optimizations for each environment (see [Figure 2-1](#flavors)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何流行工具一样，您可能会注意到TensorFlow.js包有几种不同版本，以及几个可以访问代码的位置。本书的大部分内容将专注于TensorFlow.js最常用和“准备运行”的版本，即浏览器客户端。优化的框架版本是为服务器端制作的。这些版本与Python使用相同的底层C++核心API进行通信，但通过Node.js，这使您能够利用服务器的图形卡或CPU的所有性能。TensorFlow.js
    AI模型在各种位置运行，并利用各种环境的各种优化（请参见[图2-1](#flavors)）。
- en: '![Tensorflow options chart](assets/ltjs_0201.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Tensorflow选项图表](assets/ltjs_0201.png)'
- en: Figure 2-1\. Options for TensorFlow.js
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-1。TensorFlow.js的选项
- en: The knowledge you’ll learn in this book can be applied to most platforms. For
    your convenience, we’ll cover the setup process for the most common platforms.
    If you’re uncomfortable setting up your environments from scratch, you can simply
    access the preconfigured projects built for you in the source code associated
    with this book, located at [*https://github.com/GantMan/learn-tfjs*](https://github.com/GantMan/learn-tfjs).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中学到的知识可以应用于大多数平台。为了方便起见，我们将覆盖最常见平台的设置过程。如果您不愿意从头开始设置环境，可以直接访问与本书相关的源代码中为您构建的预配置项目，位于[*https://github.com/GantMan/learn-tfjs*](https://github.com/GantMan/learn-tfjs)。
- en: Getting Set Up with TensorFlow.js in the Browser
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中设置TensorFlow.js
- en: 'Let’s jump into the fastest, most versatile, and simplest way of running TensorFlow.js.
    To get TensorFlow.js running in your browser, it’s actually quite easy. I’m going
    to assume that you’re familiar with the basics of JavaScript and that you’ve imported
    JavaScript libraries into existing code before. TensorFlow.js supports a wide
    variety of ways to be included, so developers of any experience can access it.
    If you’re familiar with including JavaScript dependencies, you’ll be familiar
    with these common practices. We can import TensorFlow.js into a page two ways:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看运行TensorFlow.js的最快、最多功能和最简单的方法。要在浏览器中运行TensorFlow.js，实际上非常容易。我假设您熟悉JavaScript的基础知识，并且以前已经将JavaScript库导入到现有代码中。TensorFlow.js支持多种包含方式，因此任何经验的开发人员都可以访问它。如果您熟悉包含JavaScript依赖项，您将熟悉这些常见做法。我们可以以两种方式将TensorFlow.js导入到页面中：
- en: Using NPM
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NPM
- en: Including a script tag
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含脚本标签
- en: Using NPM
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NPM
- en: 'One of the most popular ways to manage your dependencies for your website is
    to use a package manager. If you’re used to building projects with NPM or Yarn,
    you can access the code via the NPM registry at [*https://oreil.ly/R2lB8*](https://oreil.ly/R2lB8).
    Simply install the dependency at the command line:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 管理网站依赖项的最流行方式之一是使用包管理器。如果您习惯使用NPM或Yarn构建项目，您可以通过NPM注册表访问代码[*https://oreil.ly/R2lB8*](https://oreil.ly/R2lB8)。只需在命令行安装依赖项：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you have imported the `tfjs` package, you can import this code in your
    JavaScript project with the following ES6 JavaScript import code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`tfjs`包后，您可以在JavaScript项目中使用以下ES6 JavaScript导入代码导入此代码：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Including a Script Tag
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含脚本标签
- en: 'If a website does not use a package manager, you can simply add a script tag
    to the HTML document. This is the second way you can include TensorFlow.js in
    your project. You can download and host TensorFlow.js locally or utilize a content
    delivery network (CDN). We’ll be pointing the script tag at a CDN-hosted script
    source:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网站不使用包管理器，您可以简单地向HTML文档添加一个脚本标签。这是您可以在项目中包含TensorFlow.js的第二种方式。您可以下载并在本地托管TensorFlow.js，或者利用内容传送网络（CDN）。我们将把脚本标签指向CDN托管的脚本源：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Besides caching across websites, CDNs are extremely quick because they utilize
    edge locations to ensure speedy delivery worldwide.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了跨网站缓存外，CDN非常快，因为它们利用边缘位置确保全球快速交付。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As you might have noticed, I’ve locked this code to a specific version (2.7.0),
    which I strongly recommend you always do in your projects regarding CDNs. You
    don’t want to run into any issues with automatic breaking changes for your site.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我已将此代码锁定到特定版本（2.7.0），我强烈建议您在涉及CDN的项目中始终这样做。您不希望在网站出现自动破坏性更改的问题。
- en: Getting Set Up with TensorFlow.js Node
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Node中设置TensorFlow.js
- en: The TensorFlow.js package we use for the browser works just fine with Node.js,
    and this is a fine solution if you’re planning on only temporarily experimenting
    with Node.js. A good rule is to use the simple `/tfjs` over the `/tfjs-node` import
    if you’re not interested in hosting a live project for others or training on large
    amounts of data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在浏览器中使用的TensorFlow.js包与Node.js完全兼容，如果您计划仅暂时尝试Node.js，这是一个很好的解决方案。一个好的规则是，如果您不打算为他人托管实时项目或在大量数据上进行训练，则使用简单的`/tfjs`而不是`/tfjs-node`导入。
- en: If your goal is to go beyond experimentation and into effective Node.js with
    TensorFlow.js, you should spend some time improving your Node.js setup with some
    of [these alternative packages](https://oreil.ly/zREQy). There are two better
    distributions of TensorFlow.js that are built specifically for Node and speed.
    They are `tfjs-node` and `tfjs-node-gpu`. Keep in mind that each developer machine
    is unique and your installs and experiences may vary.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的目标是超越实验，并在TensorFlow.js中实现有效的Node.js，您应该花一些时间改进您的Node.js设置，使用一些[这些替代包](https://oreil.ly/zREQy)。有两个更好的TensorFlow.js分发版本专门为Node和速度构建。它们是`tfjs-node`和`tfjs-node-gpu`。请记住，每台开发者机器都是独特的，您的安装和体验可能有所不同。
- en: For Node.js you’ll likely make a selection between `@tensorflow/tfjs-node` or
    `@tensorflow/tfjs-node-gpu`. You can utilize the latter GPU-powered package if
    your computer is configured with an NVIDIA GPU and properly set up with CUDA software.
    Compute Unified Device Architecture (CUDA) allows direct GPU-accelerated access
    through a parallel computing platform for NVIDIA hardware. While the GPU package
    is the absolute fastest of the TensorFlow.js options, it’s also the least likely
    to be ready and configured for most machines, due to its hardware and software
    constraints. For now, our examples will work on installing `tfjs-node` and leave
    the optional CUDA configuration up to you.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Node.js，您可能需要在`@tensorflow/tfjs-node`和`@tensorflow/tfjs-node-gpu`之间进行选择。如果您的计算机配置了NVIDIA
    GPU并正确设置了CUDA软件，您可以使用后者GPU加速的软件包。Compute Unified Device Architecture（CUDA）允许通过并行计算平台直接访问GPU加速的NVIDIA硬件。虽然GPU软件包是TensorFlow.js选项中绝对最快的，但由于其硬件和软件约束，它也是最不可能准备好并配置好的软件包。目前，我们的示例将在安装`tfjs-node`上运行，并将可选的CUDA配置留给您。
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Warning
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Oftentimes, if your computer has not been set up to develop advanced C++ libraries,
    you might have to do a bit of installing to get your machine ready. This rabbit
    hole is only necessary if you’re looking to actively work with `tfjs-node` or
    `tfjs-node-gpu`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果您的计算机尚未设置为开发高级C++库，您可能需要安装一些软件来准备好您的计算机。只有当您希望积极使用`tfjs-node`或`tfjs-node-gpu`时，才需要进行这种深入研究。
- en: 'If your NPM install was successful, congratulations! You are ready to import
    from this package. If you have Node set up to handle ES6, you can import with
    the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的NPM安装成功，恭喜！您已准备好从此包中导入。如果您已经设置了Node来处理ES6，您可以使用以下代码导入：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you haven’t configured your Node.js package to handle ES6 imports, you can
    still access the code with a classic require:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未配置Node.js软件包以处理ES6导入，您仍然可以使用经典的require访问代码：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Verifying TensorFlow.js Is Working
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证TensorFlow.js是否正常工作
- en: All of the previous methods will make a variable `tf` available in your JavaScript
    code, which gives you access to TensorFlow.js. To make sure our import worked
    appropriately, let’s log the version of the imported TensorFlow.js library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的所有方法都会在您的JavaScript代码中提供一个名为`tf`的变量，这使您可以访问TensorFlow.js。为了确保我们的导入工作正常，让我们记录导入的TensorFlow.js库的版本。
- en: Add this code to your JavaScript, and if you see a version printed in the console,
    your import is good to go!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到您的JavaScript中，如果在控制台中看到一个版本打印出来，您的导入就可以继续进行了！
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the page is run, we can right-click the page and inspect to access the
    JavaScript console logs. There we’ll find the output of our log command, “3.0.0”
    or whatever version of TensorFlow.js you imported. For the Node.js example, the
    value will simply print directly in the console.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 运行页面时，我们可以右键单击页面并检查以访问JavaScript控制台日志。在那里，我们将找到我们的日志命令的输出，“3.0.0”或您导入的TensorFlow.js版本。对于Node.js示例，该值将直接在控制台中打印。
- en: Warning
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Before you access features of the `tf` variable (TensorFlow.js library), you
    would normally need to assure TensorFlow.js has properly loaded a backend and
    is ready. The aforementioned code bypasses this check, but it’s always prudent
    to run your initial code awaiting the promise of `tf.ready()`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问`tf`变量（TensorFlow.js库）的功能之前，通常需要确保TensorFlow.js已经正确加载了后端并准备就绪。上述代码绕过了这个检查，但始终最好运行您的初始代码等待`tf.ready()`的承诺。
- en: Download and Run These Examples
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载并运行这些示例
- en: As mentioned in [Chapter 1](ch01.html#the_chapter_1), you have access to code
    from this book. To make sure you don’t have to set up these projects from scratch
    on every example, ensure you have the source code for each project, including
    the simple code shown previously.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](ch01.html#the_chapter_1)中所述，您可以访问本书中的代码。为了确保您不必在每个示例中从头开始设置这些项目，请确保您拥有每个项目的源代码，包括之前显示的简单代码。
- en: 'Download the project in your preferred way from the book’s repo: [*https://github.com/GantMan/learn-tfjs*](https://github.com/GantMan/learn-tfjs).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从书的存储库中以您喜欢的方式下载项目：[*https://github.com/GantMan/learn-tfjs*](https://github.com/GantMan/learn-tfjs)。
- en: Navigate to the directory for Chapter 2, and make sure you can run the code
    on your machine.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 转到第2章的目录，并确保您可以在您的计算机上运行代码。
- en: Running the simple example
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行简单示例
- en: In *chapter2/simple/simplest-example* we are avoiding NPM and simply pulling
    our code from a CDN. With the way this code is currently structured, we don’t
    even have to host the site! We can simply open *index.html* in any modern browser,
    and it will work!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在*chapter2/simple/simplest-example*中，我们避免使用NPM，只是从CDN中拉取我们的代码。以当前结构化的方式，我们甚至不需要托管网站！我们只需在任何现代浏览器中打开*index.html*，它就会运行！
- en: At some point, we’ll actually need to host these simple examples because we’ll
    access additional assets that require full URIs. We can do this quite easily by
    using a small web server to host the files. The smallest web server I know is
    called Web Server for Chrome and has a funny hand-drawn “200 OK!” logo. Within
    five minutes, we can get our files properly served on a local server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，我们实际上需要托管这些简单示例，因为我们将访问需要完整URI的其他资产。我们可以通过使用一个小型的Web服务器来托管文件来轻松实现这一点。我知道的最小的Web服务器叫做Web服务器，有一个有趣的手绘“200
    OK！”标志。在五分钟内，我们就可以在本地服务器上正确提供我们的文件。
- en: You can find Web Server for Chrome on the [Chrome Web Store as an extension](https://oreil.ly/ZOedW).
    In this book we’ll sometimes call this plug-in “200 OK!” When you point the web
    server at the *index.html* file, it will automatically serve the file for you,
    and all adjacent files will be accessible with their associated URLs, as we will
    require in later lessons. The app interface should look like [Figure 2-3](#two_hundred).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[Chrome Web Store作为扩展](https://oreil.ly/ZOedW)上找到Chrome的Web服务器。在本书中，我们有时会称此插件为“200
    OK！”当您将Web服务器指向*index.html*文件时，它将自动为您提供文件，并且所有相邻文件都可以通过其关联的URL访问，正如我们将在后续课程中所需的那样。应用程序界面应该看起来像[图2-3](#two_hundred)。
- en: '![200 OK! Dialogue](assets/ltjs_0203.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![200 OK！对话框](assets/ltjs_0203.png)'
- en: Figure 2-3\. Web Server for Chrome 200 OK! dialog
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-3。Chrome的Web服务器200 OK！对话框
- en: If you’d like to peruse other options or want a link to the mentioned Chrome
    plug-in, take a look at *chapter2/extra/hosting-options.md* to find the one that
    works for you. And of course, if you find a fantastic option that’s not listed,
    please contribute a pull request.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看其他选项或想要链接到提到的Chrome插件，请查看*chapter2/extra/hosting-options.md*，找到适合您的选项。当然，如果您发现一个未列出的绝妙选项，请贡献一个拉取请求。
- en: Once you find a server that runs *simple-example* in a way you enjoy, you can
    use that service for all simple options going forward.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到一个以您喜欢的方式运行*simple-example*的服务器，您可以将该服务用于以后的所有简单选项。
- en: Running the NPM web example
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行NPM web示例
- en: If you’re more familiar with NPM, the basic NPM example for this project uses
    Parcel. Parcel is the fastest application bundler with zero configuration. It
    also includes Hot Module Reloading to get real-time updates and excellent error
    logging.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更熟悉NPM，此项目的基本NPM示例使用Parcel。Parcel是最快的应用程序捆绑工具，零配置。它还包括热模块重新加载，以获取实时更新和出色的错误日志记录。
- en: 'To run the code, navigate to *chapter2/web/web-example* and do an NPM install
    (`npm i`). Once that’s done, there’s a script in the *package.json* that kicks
    everything off. You can simply run the start script:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码，请导航至*chapter2/web/web-example*并执行NPM安装（`npm i`）。完成后，在*package.json*中有一个脚本可以启动所有内容。您只需运行启动脚本：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That’s it! We’ll be using this method to run all NPM-based code in the book.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们将使用这种方法来运行本书中所有基于NPM的代码。
- en: Running the Node.js example
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行Node.js示例
- en: The Node.js example is just as easy to run as the Parcel NPM example. While
    Node.js is generally unopinionated, the Node.js examples in this book will include
    a few opinionated dev dependencies so we can make our Node.js example code align
    with the browser examples. The code throughout this book will take full advantage
    of ECMAScript. We do this with some transpiling, file watching, and node magic.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js示例与Parcel NPM示例一样易于运行。虽然Node.js通常没有明确的意见，但本书中的Node.js示例将包括一些明确的开发依赖项，以便我们可以使我们的Node.js示例代码与浏览器示例保持一致。本书中的代码将充分利用ECMAScript。我们通过一些转译、文件监视和节点魔法来实现这一点。
- en: 'To prep this example, navigate to *chapter2/node-example* and do an NPM install
    (`npm i`). If you have any issues, you may need to run `npm i -g ts-node nodemon
    node-gyp` to assure you have the needed libraries to make all our magic happen.
    Once your node packages are properly in place, you can start the project at any
    time by running the start script:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备这个示例，请导航至*chapter2/node-example*并执行NPM安装（`npm i`）。如果遇到任何问题，您可能需要运行`npm i
    -g ts-node nodemon node-gyp`来确保您拥有所需的库，以确保我们所有的魔法发生。一旦您的节点包正确放置，您可以随时通过运行启动脚本来启动项目：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code is transpiled via TypeScript and reload-friendly `nodemon`. If everything
    ran properly, you’ll see the installed TensorFlow.js version printed directly
    in the console/terminal where you ran the server.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过TypeScript转译，并且使用`nodemon`进行重新加载。如果一切正常运行，您将在运行服务器的控制台/终端中直接看到已安装的TensorFlow.js版本。
- en: Let’s Use Some Real TensorFlow.js
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们使用一些真实的TensorFlow.js
- en: 'Now that we have TensorFlow.js, let’s use it to make something epic! OK, that’s
    quite a simplification: if it were that easy, the book would be over. There’s
    still a mountain of things to learn, but that doesn’t stop us from taking a gondola
    to get a high-level view.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了TensorFlow.js，让我们用它来创造一些史诗般的东西！好吧，这有点简化：如果那么容易，这本书就结束了。仍然有很多东西要学习，但这并不妨碍我们乘坐缆车，以获得高层视角。
- en: TensorFlow.js has plenty of prewritten code and models we can utilize. These
    pre-written libraries help us get the benefits of utilizing TensorFlow.js without
    fully grasping the underlying concepts.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow.js有大量预先编写的代码和模型可供我们利用。这些预先编写的库帮助我们获得利用TensorFlow.js的好处，而无需完全掌握底层概念。
- en: 'While there are plenty of community-driven models that work quite well, the
    official maintained list of TensorFlow.js models is on the TensorFlow GitHub under
    a repo named `tfjs-models`. For stability, we’ll use these as often as we can
    in this book. You can peruse the links here: [*https://github.com/tensorflow/tfjs-models*](https://github.com/tensorflow/tfjs-models).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有很多社区驱动的模型效果很好，但TensorFlow.js模型的官方维护列表在TensorFlow GitHub上，名称为`tfjs-models`。为了稳定性，我们将尽可能经常在本书中使用这些模型。您可以在这里查看链接：[*https://github.com/tensorflow/tfjs-models*](https://github.com/tensorflow/tfjs-models)。
- en: For this foray into running actual TensorFlow.js models, let’s pick something
    with a relatively simple input and output. We’ll use the TensorFlow.js *Toxicity*
    classifier to check if text input is insulting or not.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次尝试运行实际TensorFlow.js模型时，让我们选择一个相对简单的输入和输出。我们将使用TensorFlow.js的*Toxicity*分类器来检查文本输入是否具有侮辱性。
- en: The Toxicity Classifier
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 毒性分类器
- en: Google provides a few “ready-to-go” models of varying complexity. One beneficial
    model is called the Toxicity model, which is perhaps one of the most straightforward
    and useful models for beginners.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌提供了几个不同复杂度的“即插即用”模型。其中一个有益的模型被称为毒性模型，这可能是对初学者来说最直接和有用的模型之一。
- en: Like all programming, a model will require specific input and will provide specific
    output. To kick things off, let’s take a look at what those are for in this model.
    Toxicity detects toxic content such as threats, insults, cussing, and generalized
    hate. Since those aren’t necessarily mutually exclusive, it’s important that each
    of these violations has their own probability.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有编程一样，模型将需要特定的输入并提供特定的输出。让我们开始看看这个模型的输入和输出是什么。毒性检测有毒内容，如威胁、侮辱、咒骂和普遍仇恨。由于这些并不一定是互斥的，因此每种违规行为都有自己的概率是很重要的。
- en: 'The Toxicity model attempts to identify a probability that a given input is
    true or false for the following characteristics:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 毒性模型试图识别给定输入是否符合以下特征的真假概率：
- en: Identity attack
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份攻击
- en: Insult
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 侮辱
- en: Obscene
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 淫秽
- en: Severe toxicity
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严重毒性
- en: Sexually explicit
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性暴力
- en: Threat
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 威胁
- en: Toxicity
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 毒性
- en: When you give the model a string, it returns an array of seven objects to identify
    the percentage-of-probability prediction for each specific violation. Percentages
    are represented as two `Float32` values between zero and one.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当您给模型一个字符串时，它会返回一个包含七个对象的数组，用于识别每个特定违规行为的概率预测百分比。百分比表示为两个介于零和一之间的`Float32`值。
- en: If a sentence is surely *not* a violation, the probabilities will give most
    of the value to the zero index in the `Float32` array.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一句话肯定*不*是违规行为，概率将主要分配给`Float32`数组中的零索引。
- en: For example, `[0.7630404233932495, 0.2369595468044281]` reads that the prediction
    for this particular violation is 76% not a violation and 24% likely a violation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`[0.7630404233932495, 0.2369595468044281]`表示对于这种特定违规行为的预测是76%不是违规行为，24%可能是违规行为。
- en: This can be quite a “Hold on, what!?” moment for most developers. It’s a bit
    strange getting probabilities where we’re used to true and false, isn’t it? But
    in an intuitive way, we’ve always understood that language has a lot of gray area.
    The exact science of insults often depends on the person and even the day!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数开发人员来说，这可能是一个“等等，什么！？”的时刻。在我们习惯于真和假的地方得到概率，这有点奇怪，不是吗？但直观地，我们一直知道语言有很多灰色地带。侮辱的确切科学往往取决于个人，甚至是当天！
- en: For this reason, the model has a bonus feature of allowing you to pass a threshold
    that will identify when a particular violation surpasses the allotted limit. When
    an insult is detected beyond the threshold, the `match` flag is set to true. This
    is a nice little bonus to help you quickly map the results for significant violations.
    Picking a valid threshold depends on your needs and the situation. You can shoot
    from the hip, but if you need some guidance, statistics has all kinds of tools
    you could review. Read up on Receiver Operating Characteristic (ROC) graphs for
    plotting and picking an optimal threshold for your needs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该模型具有一个额外功能，允许您传递一个阈值，当特定违规行为超过分配的限制时将其识别出来。当检测到超过阈值的侮辱时，`match`标志将设置为true。这是一个很好的额外功能，可以帮助您快速映射重大违规行为的结果。选择有效的阈值取决于您的需求和情况。您可以凭直觉行事，但如果需要一些指导，统计学有各种工具供您查阅。阅读有关接收器操作特性（ROC）图的文章，以绘制和选择适合您需求的最佳阈值。
- en: Warning
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: To activate the Toxicity model, we will have to write something insulting. The
    following example uses an insult based on looks. The insult avoids using profanity
    but is still offensive. This is not directed to anyone in particular and is meant
    to illustrate the capabilities of AI to understand and identify toxic comments.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活毒性模型，我们将不得不写一些侮辱性的话。以下示例使用基于外表的侮辱。这个侮辱避免使用粗话，但仍然是冒犯性的。这并不针对任何特定人，而是旨在说明AI理解和识别有毒评论的能力。
- en: It’s important to choose an insult that is easy for humans to recognize, but
    difficult for a computer. Sarcasm detection is difficult in text form and has
    been a major problem in computer science. To seriously test this model, the insult
    should avoid common and blatant inflammatory wording. Running the Toxicity model
    on a particularly crafty insult with the threshold set to `0.5` yields the array
    shown in [Example 2-1](#output_full_toxicity).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个对人类容易识别但对计算机难以识别的侮辱是很重要的。在文本形式中检测讽刺是困难的，并且一直是计算机科学中的一个主要问题。为了严肃测试这个模型，侮辱应避免使用常见和明显的煽动性措辞。将阈值设置为`0.5`，在特别狡猾的侮辱上运行毒性模型会产生示例2-1中显示的数组。
- en: 'The insult input: “She looks like a cavewoman, only far less intelligent!”'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 侮辱输入：“她看起来像一个穴居人，只是远不如智慧！”
- en: Example 2-1\. The full toxicity report on the input sentence
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-1。输入句子的完整毒性报告
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see from [Example 2-1](#output_full_toxicity), we snuck under the
    “insult” radar by a hair (50.2% false), but we got dinged by the toxicity indicator,
    which resulted in `"match": true`. This is quite impressive, because I don’t have
    any explicitly offensive language in the sentence. As a programmer, it wouldn’t
    be straightforward to write an algorithm to catch and identify this toxic insult,
    but AI was trained to identify the complex patterns of toxic language after studying
    heaps of labeled insults so we don’t have to.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '正如您从[示例2-1](#output_full_toxicity)中可以看到的，我们在“侮辱”雷达下勉强通过（50.2%错误），但我们被毒性指标扣分，导致`"match":
    true`。这相当令人印象深刻，因为我在句子中没有任何明确的冒犯性语言。作为程序员，编写一个算法来捕捉和识别这种有毒的侮辱并不直接，但AI经过研究大量标记的侮辱后，被训练来识别有毒语言的复杂模式，这样我们就不必自己做了。'
- en: The previous example uses a single sentence in an array as input. If you include
    multiple sentences as input, your sentence index will correspond directly with
    your result index for each category.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用一个句子的数组作为输入。如果将多个句子作为输入，您的句子索引将直接对应于每个类别的结果索引。
- en: 'But don’t take my word for it; now it’s your turn to run the code. You can
    add the model to your website with NPM via this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要只听我的话；现在轮到您运行代码了。您可以通过以下方式将模型添加到您的网站：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'and then import the library:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后导入库：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or you can add the script directly from a CDN.^([3](ch02.html#idm45049252373352))
    Order matters with script tags, so make sure your tag is placed on the page before
    you try to use the model:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以直接从CDN添加脚本。^([3](ch02.html#idm45049252373352)) 脚本标签的顺序很重要，所以确保在尝试使用模型之前将标签放在页面上：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Either of the previous examples will provide results in a ready-to-go `toxicity`
    variable. We’ll use this variable’s `load` method to load the ML model promise.
    And from that model, we can utilize the `classify` method on an array of sentences.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的任何示例都将在一个准备就绪的`toxicity`变量中提供结果。我们将使用这个变量的`load`方法来加载ML模型的承诺。然后，我们可以利用该模型在一个句子数组上使用`classify`方法。
- en: Here’s an example of loading the model and running classification on three sentences.
    This exact example can be found in three different forms in the associated sections
    of [the chapter code on GitHub](https://oreil.ly/sTs5a).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是加载模型并对三个句子进行分类的示例。这个确切的示例可以在[GitHub上的章节代码](https://oreil.ly/sTs5a)的相关部分中以三种不同形式找到。
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_introducing_tensorflow_js_CO1-1)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introducing_tensorflow_js_CO1-1)'
- en: The model is loaded into the browser with a threshold.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 模型加载到浏览器中并带有阈值。
- en: '[![2](assets/2.png)](#co_introducing_tensorflow_js_CO1-2)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introducing_tensorflow_js_CO1-2)'
- en: The loaded model is asked to classify inputs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 加载的模型被要求对输入进行分类。
- en: '[![3](assets/3.png)](#co_introducing_tensorflow_js_CO1-3)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_introducing_tensorflow_js_CO1-3)'
- en: The object is printed nicely using JavaScript Object Notation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript对象表示法很好地打印了对象。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you run this code in a browser, you’ll need to view the console to view the
    output. You can navigate to the console from inspecting the page, or generally,
    you can press Control+Shift+J on Windows or Command+Option+J on Mac. If you’re
    running this from the command line with `npm start`, you should see the output
    immediately in the console.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中运行此代码，您需要查看控制台以查看输出。您可以通过检查页面导航到控制台，或者通常情况下，您可以在Windows上按Control+Shift+J或在Mac上按Command+Option+J。如果您使用`npm
    start`从命令行运行此代码，您应该立即在控制台中看到输出。
- en: The results for multiple sentences are grouped by toxicity category. So the
    previous code attempts to identify each sentence depending on each category. For
    instance, the “insult” output from the previous should read similar to [Example 2-2](#output_insult_result).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 多个句子的结果按毒性类别分组。因此，前面的代码尝试根据每个类别识别每个句子。例如，前面的“侮辱”输出应该类似于[示例2-2](#output_insult_result)。
- en: Example 2-2\. Insult section results
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-2\. 侮辱部分结果
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Ta-daaaaa! The code works great. Each `results` index corresponds to the input
    sentence index, and it properly diagnoses the two insults among the three sentences.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 哒哒哒！代码运行得很好。每个`results`索引对应于输入句子索引，并且正确诊断了三个句子中的两个侮辱。
- en: Congratulations on running your first TensorFlow.js model. Now that you’re a
    master of AI, let’s talk through the steps and underlying concepts of this library.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 祝贺您运行您的第一个TensorFlow.js模型。现在您是AI的大师，让我们一起讨论这个库的步骤和基本概念。
- en: Loading the Model
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载模型
- en: When we call `toxicity.load`, you might be thinking the model is being loaded
    into memory, but you’d only be half-right. Most of these libraries do not ship
    with the trained model in the JavaScript codebase. Read that sentence again. This
    might seem a bit alarming to our NPM developers, but it makes complete sense to
    our CDN users. The load method fires off a network call to download the model
    that the library uses. In some cases, the model that is loaded is optimized for
    the environment and device where the JavaScript is located. Review the network
    logs illustrated in [Figure 2-4](#model_download).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`toxicity.load`时，您可能会认为模型被加载到内存中，但您只对一半正确。大多数这些库不会在JavaScript代码库中提供经过训练的模型。再读一遍那句话。这对于我们的NPM开发人员可能有点令人担忧，但对于我们的CDN用户来说完全合理。加载方法触发一个网络调用来下载库使用的模型。在某些情况下，加载的模型会针对JavaScript所在的环境和设备进行优化。查看[图2-4](#model_download)中说明的网络日志。
- en: '![Toxicity Download](assets/ltjs_0204.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![毒性下载](assets/ltjs_0204.png)'
- en: Figure 2-4\. Network download requests
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-4\. 网络下载请求
- en: Warning
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: While the Toxicity NPM bundle can be minified and zipped to a mere 2.4 KB, there’s
    an additional multimegabyte payload over the network for the actual model file
    when the library is used.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管毒性NPM捆绑包可以被缩小并压缩到仅2.4 KB，但在使用库时，实际模型文件在网络上有额外的多兆字节负载。
- en: The load method for this Toxicity library takes a threshold that it will apply
    to all subsequent classifications and then fires off a network call to download
    the actual model file. When that model is fully downloaded, the library then loads
    the model into tensor-optimized memory for use.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个毒性库的加载方法需要一个阈值，它将应用于所有后续分类，然后触发一个网络调用来下载实际的模型文件。当模型完全下载时，库会将模型加载到张量优化内存中供使用。
- en: It’s important to evaluate each library appropriately. Let’s review some common
    questions people ask when they learn a bit more about this.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 适当评估每个库是很重要的。让我们回顾一些人们在学习更多关于这个库时常问的常见问题。
- en: Classifying
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类
- en: The next thing our Toxicity code did is run a `classify` method. This is the
    moment where our input sentences were passed through the model, and we got the
    results. While it seemed just as simple as any other JavaScript function, this
    library actually hid some fundamental processing that was necessary.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的毒性代码接下来做的事情是运行`classify`方法。这是我们的输入句子通过模型传递的时刻，我们得到了结果。虽然它看起来就像任何其他JavaScript函数一样简单，但这个库实际上隐藏了一些必要的基本处理。
- en: All data in and out of a model is converted to a tensor. We will cover tensors
    in greater detail in [Chapter 3](ch03.html#the_chapter_3), but it’s important
    to note that this conversion is essential for the AI. All the input strings are
    converted, and calculations are made, and the results that come out are tensors
    that are reconverted into normal JavaScript primitives.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 模型中的所有数据都被转换为张量。我们将在[第3章](ch03.html#the_chapter_3)中更详细地介绍张量，但重要的是要注意，这种转换对于AI至关重要。所有输入字符串都被转换，进行计算，得到的结果是重新转换为普通JavaScript基元的张量。
- en: It’s nice that this library handled this for us. When you’re finished with this
    book, you’ll be able to wrap machine learning models with the same dexterity.
    You’ll be able to keep your users in blissful ignorance of the intricacies of
    data conversions that are happening behind the scenes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 很高兴这个库为我们处理了这个问题。当您完成本书时，您将能够以相同的灵活性包装机器学习模型。您将能够让您的用户对发生在幕后的数据转换的复杂性保持幸福的无知。
- en: In the next chapter, we’ll jump into that conversion. You’ll fully grasp the
    transition of data into tensors and all the data manipulation superpowers that
    come with it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨这种转换。您将完全掌握数据转换为张量以及随之而来的所有数据操作超能力。
- en: Try It Yourself
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自己试试
- en: Now that you’ve implemented one model, you can most likely implement the [other
    models provided by Google](https://oreil.ly/WFq62). Most of the other Google models’
    GitHub pages have README documents explaining how to implement each library. Many
    of the implementations are similar to what we saw with Toxicity.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经实现了一个模型，很可能你可以实现[谷歌提供的其他模型](https://oreil.ly/WFq62)。大多数其他谷歌模型的 GitHub 页面都有
    README 文档，解释如何实现每个库。许多实现与我们在毒性中看到的类似。
- en: Take a moment to browse through the existing models to let your imagination
    run wild. You can begin working with these libraries immediately. Knowing these
    models exist will also be useful as you progress in this book. Not only are you
    going to better understand what these libraries are capable of, but you might
    want to combine and even improve on these existing libraries for your needs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间浏览现有的模型，让你的想象力发挥得淋漓尽致。你可以立即开始使用这些库进行工作。随着你在本书中的进展，了解这些模型的存在也会很有用。你不仅将更好地理解这些库的能力，还可能想要结合甚至改进这些现有库以满足你的需求。
- en: In the next chapter, we’ll start digging into the details of what these well-wrapped
    libraries are hiding so we can unleash your TensorFlow.js skills without limit.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始深入挖掘这些包装良好的库隐藏的细节，以便无限释放你的 TensorFlow.js 技能。
- en: Chapter Review
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节复习
- en: We set up your computer for TensorFlow.js via a few common practice options.
    We assured our machine is ready to run TensorFlow.js, and we even pulled down
    and ran a packaged model for determining text toxicity.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过几种常见的实践选项为 TensorFlow.js 设置了你的计算机。我们确保我们的机器已经准备好运行 TensorFlow.js，甚至下载并运行了一个打包好的模型来确定文本毒性。
- en: 'Chapter Challenge: Truck Alert!'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 章节挑战：卡车警报！
- en: Take the time to try the [MobileNet model](https://oreil.ly/fUKoy), which has
    the ability to look at images and attempt to classify the predominant artifact.
    This model can be passed any `<img>`, `<video>`, or `<canvas>` element, and it
    returns an array of most likely predictions for what it sees in that particular
    graphic.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间尝试一下[MobileNet 模型](https://oreil.ly/fUKoy)，它可以查看图像并尝试对主要物件进行分类。这个模型可以传递任何
    `<img>`、`<video>` 或 `<canvas>` 元素，并返回对该特定图形中所见内容的最有可能预测的数组。
- en: The MobileNet model has been trained to classify [1,000 possible items](https://oreil.ly/6PEAn)
    from stone walls, to garbage trucks, to even an Egyptian cat. People have used
    this library to detect a wide variety of fun things. I once saw some code that
    connected a webcam to MobileNet to [detect llamas](https://oreil.ly/L0nBz).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: MobileNet 模型已经经过训练，可以对[1,000种可能的物品](https://oreil.ly/6PEAn)进行分类，从石墙到垃圾车，甚至是埃及猫。人们已经使用这个库来检测各种有趣的事物。我曾经看到一些代码将网络摄像头连接到
    MobileNet 来[检测羊驼](https://oreil.ly/L0nBz)。
- en: For this Chapter Challenge, you’re tasked with creating a website that can detect
    trucks. Given an input image, you’re looking to identify if it’s a truck or not.
    When you detect a truck from a photo, do an `alert("TRUCK DETECTED!")`. By default,
    the MobileNet package returns the top three detections. If any of those three
    see a truck in the photo, your alert should notify the user just like in [Figure 2-5](#truck_detected).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个章节挑战，你的任务是创建一个可以检测卡车的网站。给定一个输入图像，你要识别它是否是一辆卡车。当你从照片中检测到一辆卡车时，执行 `alert("检测到卡车！")`。默认情况下，MobileNet
    包返回前三个检测结果。如果这三个中有任何一个在照片中看到卡车，你的警报应该像[图 2-5](#truck_detected)中一样通知用户。
- en: '![Truck detector with active alert](assets/ltjs_0205.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![带有活动警报的卡车检测器](assets/ltjs_0205.png)'
- en: Figure 2-5\. Truck detector working
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. 卡车检测器工作
- en: You can find the answer to this challenge in [Appendix B](app02.html#appendix_b).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[附录 B](app02.html#appendix_b)中找到这个挑战的答案。
- en: Review Questions
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习问题
- en: 'Let’s review the lessons we’ve learned from the code you’ve written in this
    chapter. Take a moment to answer the following questions:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下你在本章编写的代码中学到的教训。花点时间回答以下问题：
- en: Can regular TensorFlow run in the browser?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常规 TensorFlow 能在浏览器中运行吗？
- en: Does TensorFlow.js have access to the GPU?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TensorFlow.js 能访问 GPU 吗？
- en: Do you have to have CUDA installed to run TensorFlow.js?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 TensorFlow.js 是否必须安装 CUDA？
- en: If I don’t specify a version on a CDN, what happens?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我在 CDN 上没有指定版本，会发生什么？
- en: How does the Toxicity classifier identify violations?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 毒性分类器如何识别违规行为？
- en: When do we pass a threshold to Toxicity?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们何时会达到毒性的阈值？
- en: Does the Toxicity code contain all the needed files?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 毒性代码是否包含所有所需的文件？
- en: Do we have to do any tensor work to use this Toxicity library?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否需要进行任何张量工作来使用这个毒性库？
- en: Solutions to these exercises are available in [Appendix A](app01.html#book_appendix).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的解决方案可以在[附录 A](app01.html#book_appendix)中找到。
- en: ^([1](ch02.html#idm45049254746888-marker)) TensorFlow didn’t reach 1.0.0 status
    until February 11, 2017.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#idm45049254746888-marker)) TensorFlow 直到 2017 年 2 月 11 日才达到
    1.0.0 版本。
- en: '^([2](ch02.html#idm45049254735528-marker)) 2x boost with Node over Python case
    study: [*https://oreil.ly/4Jrbu*](https://oreil.ly/4Jrbu)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.html#idm45049254735528-marker)) Node 比 Python 案例研究提高了 2 倍：[*https://oreil.ly/4Jrbu*](https://oreil.ly/4Jrbu)
- en: ^([3](ch02.html#idm45049252373352-marker)) Notice this version is locked at
    1.2.2.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.html#idm45049252373352-marker)) 请注意，此版本已锁定在 1.2.2。
- en: ^([4](ch02.html#idm45049252013384-marker)) The Toxicity model info is available
    at [*https://oreil.ly/Eejyi*](https://oreil.ly/Eejyi).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.html#idm45049252013384-marker)) 毒性模型信息可在[*https://oreil.ly/Eejyi*](https://oreil.ly/Eejyi)找到。
