- en: Chapter 10\. Extending Copilot’s Functionality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章：扩展 Copilot 的功能
- en: GitHub Copilot is an amazingly useful tool. It can be made even more useful
    by extending its capabilities through integration with other tools. This includes
    ones you can write. The mechanisms for doing this are called *extensions*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Copilot 是一个非常有用的工具。通过与其他工具的集成来扩展其功能，可以使它更加有用。这包括您可以编写的工具。执行此操作的机制被称为
    *扩展*。
- en: Copilot extensions enhance the functionality of GitHub Copilot by tailoring
    it to specific use cases or environments. For example, extensions can integrate
    custom or third-party applications with Copilot through the chat interface. As
    an example, you can install a [Copilot Docker extension](https://oreil.ly/QS54S)
    and then ask questions via chat like “@Docker, how do I containerize this project?”
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 扩展通过针对特定用例或环境定制，增强了 GitHub Copilot 的功能。例如，扩展可以通过聊天界面将自定义或第三方应用程序与 Copilot
    集成。例如，您可以安装一个 [Copilot Docker 扩展](https://oreil.ly/QS54S)，然后通过聊天提出问题，如“@Docker，我该如何容器化这个项目？”
- en: In this chapter, we’ll examine what extensions for GitHub Copilot are and how
    to find and work with public ones from the marketplace. Then we’ll progress to
    understanding details about the various types, how they work, and their advantages
    and disadvantages. And we’ll cover some details on simple, yet useful, implementation
    examples. But before we cover those topics, we need to clarify some possibly confusing
    terminology.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 GitHub Copilot 的扩展是什么，以及如何从市场找到并使用公共扩展。然后，我们将深入了解各种类型、它们的工作原理以及它们的优缺点。我们还将介绍一些简单但实用的实现示例。但在我们讨论这些主题之前，我们需要澄清一些可能令人困惑的术语。
- en: Copilot Extensions Versus VS Code Extensions for Copilot
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Copilot 扩展与 VS Code 的 Copilot 扩展对比
- en: Extensions for Copilot’s functionality can be implemented for one of two different
    targets. They can be engineered to work on any platform where Copilot Chat is
    supported (IDEs, GitHub.com, etc.), independent of the platform. Or they can be
    targeted for VS Code to leverage its underlying functions and only run on that
    platform (or on another IDE if ported).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 功能的扩展可以针对两种不同的目标实现。它们可以设计为在任何支持 Copilot Chat 的平台上工作（IDE、GitHub.com 等），独立于平台。或者，它们可以针对
    VS Code，利用其底层功能，仅在平台上运行（或如果移植到其他 IDE）。
- en: Throughout this chapter, we’ll use the terms *VS Code extensions for Copilot*
    or c*hat participants* when referring to the ones implemented via VS Code. For
    the *native* Copilot ones (implemented to be independent of the platform), we’ll
    use the shorter term *Copilot extensions*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，当我们提到通过 VS Code 实现的扩展时，我们将使用术语 *VS Code 的 Copilot 扩展* 或 *聊天参与者*。对于 *原生*
    的 Copilot 扩展（设计为独立于平台），我们将使用更简短的术语 *Copilot 扩展*。
- en: In both cases, the extension’s functionality is surfaced through Copilot’s chat
    interface. VS Code extensions for Copilot simply utilize its functionality for
    both hosting and execution. Copilot extensions require a separately configured
    and dedicated GitHub App to bridge between the chat interface and the backend
    code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，扩展的功能都是通过 Copilot 的聊天界面呈现的。VS Code 的 Copilot 扩展只是简单地利用其功能进行托管和执行。Copilot
    扩展需要配置一个单独的 GitHub App，以便在聊天界面和后端代码之间建立桥梁。
- en: We’ll be discussing the details of implementation and configuration for both
    types of extensions later in this chapter. That will include information on what
    GitHub Apps are and how they are used with Copilot extensions. But, first, let’s
    learn more about what Copilot extensions are in general.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论这两种类型扩展的实现和配置细节。这包括有关 GitHub Apps 是什么以及它们如何与 Copilot 扩展一起使用的相关信息。但首先，让我们更深入地了解
    Copilot 扩展是什么。
- en: Server-Based and Client-Based Extensions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于服务器和基于客户端的扩展
- en: It may be helpful to think of Copilot extensions as *server-based*, in the sense
    of needing to communicate back to the app running on the GitHub side to function
    (although that’s not an official description). Likewise, VS Code extensions for
    Copilot could be thought of as *client-based* since they function utilizing the
    APIs of the VS Code client where they are installed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于将 Copilot 扩展视为 *基于服务器* 的，因为它们需要与运行在 GitHub 端的应用程序通信才能工作（尽管这不是官方描述）。同样，VS
    Code 的 Copilot 扩展可以被视为 *基于客户端* 的，因为它们利用安装在其上的 VS Code 客户端的 API 来工作。
- en: What Are Copilot Extensions?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Copilot 扩展？
- en: Copilot has a framework of APIs and lower-level capabilities that underlie its
    user-facing functionality. That framework can be used by third parties and users
    to extend Copilot’s capabilities. This framework allows other applications to
    provide their services through Copilot Chat directly to the user. As the user,
    you get the benefit of being able to invoke and converse with the other tooling,
    similar to the way you interact with the Copilot AI out of the box.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot有一个API框架和底层能力，这些能力构成了其用户界面的功能。这个框架可以被第三方和用户用来扩展Copilot的功能。这个框架允许其他应用通过Copilot
    Chat直接向用户提供服务。作为用户，您能够调用并与其他工具进行对话，就像您与开箱即用的Copilot AI交互一样。
- en: 'Extensions have multiple use cases, as noted in Copilot’s [documentation](https://oreil.ly/B7yAU).
    They include the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展有多种用途，如Copilot的[文档](https://oreil.ly/B7yAU)中所述。它们包括以下内容：
- en: Querying documentation
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 查询文档
- en: Allowing Copilot Chat to query a third-party documentation service to find information
    about a specific topic.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 允许Copilot Chat查询第三方文档服务以查找有关特定主题的信息。
- en: AI-assisted coding
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: AI辅助编码
- en: Using a third-party AI model to provide code suggestions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第三方AI模型提供代码建议。
- en: Data retrieval
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据检索
- en: A Copilot extension can allow Copilot Chat to query a third-party data service
    to retrieve information about a specific topic.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Copilot扩展可以使Copilot Chat查询第三方数据服务以获取特定主题的信息。
- en: Action execution
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 执行操作
- en: Allowing Copilot Chat to execute a specific action, such as posting to a message
    board or updating a tracking item in an external system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 允许Copilot Chat执行特定操作，例如在论坛上发布或更新外部系统中的跟踪项。
- en: Think of using Copilot extensions as giving Copilot Chat additional knowledge
    of another application or set of data, and adding specialized skills that you
    can invoke to help when needed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用Copilot扩展视为给Copilot Chat增加对另一个应用或数据集的了解，并添加您可以在需要时调用的专业技能。
- en: Copilot extensions are built to provide cross-platform compatibility, app management,
    and support. They work anywhere that chat does. They can be private, public and
    shareable, and listed on GitHub Marketplace, if desired. In fact, the marketplace
    is a good place to start learning about extensions and the public ones available
    to use.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot扩展旨在提供跨平台兼容性、应用管理和支持。它们在聊天可以工作的任何地方工作。它们可以是私有的、公共的，并且可以共享，如果需要，可以在GitHub
    Marketplace上列出。实际上，市场是了解扩展和可用公共扩展的好地方。
- en: Getting Copilot Extensions from the Marketplace
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从市场获取Copilot扩展
- en: You can write your own extensions (as you’ll see later in this chapter), and
    organizations or companies can create *private* extensions. In addition, *public*
    extensions from third-party companies and organizations are already available.
    To see these, go to [GitHub Marketplace](https://github.com/marketplace) and select
    Copilot in the left column. [Figure 10-1](#copilot-extensions-on) shows the main
    screen for Copilot extensions in the marketplace.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以编写自己的扩展（您将在本章后面看到），组织或公司可以创建*私有*扩展。此外，第三方公司和组织提供的*公共*扩展也已可用。要查看这些扩展，请访问[GitHub
    Marketplace](https://github.com/marketplace)，并在左侧列中选择Copilot。[图10-1](#copilot-extensions-on)显示了市场中的Copilot扩展主屏幕。
- en: '![](assets/lghc_1001.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1001.png)'
- en: Figure 10-1\. Copilot extensions on the marketplace
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-1. 市场上的Copilot扩展
- en: From here, we’ll pick the PerplexityAI extension. This extension allows for
    gathering responses through real-time web searches. Clicking the link in the marketplace
    opens up the extension’s details page with information about what the extension
    is and what it can do ([Figure 10-2](#extension-main-page)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们将选择PerplexityAI扩展。这个扩展允许通过实时网络搜索收集响应。点击市场中的链接将打开扩展的详细信息页面，其中包含有关扩展是什么以及它能做什么的信息（[图10-2](#extension-main-page)）。
- en: '![](assets/lghc_1002.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1002.png)'
- en: Figure 10-2\. Extension main page
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-2. 扩展主页面
- en: Clicking the Add button (in the upper right) or scrolling to the bottom takes
    you to the section of the page where you can install the extension ([Figure 10-3](#extension-install-pag)).
    This one is free.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 点击右上角的“添加”按钮或滚动到页面底部，您将进入可以安装扩展的部分（[图10-3](#extension-install-pag)）。这个是免费的。
- en: '![](assets/lghc_1003.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1003.png)'
- en: Figure 10-3\. Extension installation page
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-3. 扩展安装页面
- en: Some extensions may require you to select the user or organization that will
    be authorized to use the extension. You can see an example of that if you choose
    to install the Docker extension ([Figure 10-4](#docker-extension-inst)). In the
    case of the PerplexityAI extension, its functionality is general search, so it
    is usable for all repos associated with the user who is installing it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一些扩展可能需要您选择将有权使用该扩展的用户或组织。如果您选择安装Docker扩展（[图10-4](#docker-extension-inst)），您可以看到一个示例。在PerplexityAI扩展的情况下，其功能是通用搜索，因此它可以用于安装它的用户关联的所有仓库。
- en: '![](assets/lghc_1004.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1004.png)'
- en: Figure 10-4\. Installing the Docker extension with the user or organization
    selected
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-4. 选择用户或组织安装Docker扩展
- en: Most Copilot extensions get access to repositories and your account through
    the use of a *GitHub App*. These are basically backend applications installed
    and authorized in your GitHub account to work with your repositories. For Copilot
    extensions that use an app, the app serves as the bridge between the chat interface
    and the code that implements the extension’s functionality. The app provides the
    access and control layer between Copilot and the extension’s operations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Copilot扩展通过使用**GitHub App**来获取对仓库和您的账户的访问权限。这些是在您的GitHub账户中安装和授权的后端应用程序，用于与您的仓库一起工作。对于使用应用程序的Copilot扩展，该应用程序充当聊天界面和实现扩展功能的代码之间的桥梁。应用程序在Copilot和扩展操作之间提供访问和控制层。
- en: You can see the app integration once you’ve done the initial install for the
    extension. You’ll be asked to authorize the associated GitHub App for the account
    by authenticating to GitHub. After authorizing, you’ll be taken to the configuration
    page for the installed app, as shown in [Figure 10-5](#perplexity-ais-githu1).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在为扩展完成初始安装后查看应用程序集成。您将被要求通过GitHub进行身份验证来授权相关的GitHub应用程序。授权后，您将被带到已安装应用程序的配置页面，如图10-5所示[PerplexityAI的GitHub
    App配置](#perplexity-ais-githu1)。
- en: '![](assets/lghc_1005.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1005.png)'
- en: Figure 10-5\. PerplexityAI’s GitHub App configuration
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-5. PerplexityAI的GitHub App配置
- en: On this page, you can select specific permissions for the app and/or specific
    repositories for the app to access. In the case of the app for the PerplexityAI
    extension, it simply applies to all repositories and does not have any specific
    permission requirements, so we are good to go. You can also suspend or uninstall
    the app from this page.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在此页面上，您可以选择应用程序的特定权限和/或应用程序可以访问的特定仓库。对于PerplexityAI扩展的应用程序，它仅适用于所有仓库，并且没有特定的权限要求，所以我们一切就绪。您也可以从该页面暂停或卸载应用程序。
- en: Changing App Configuration
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改应用程序配置
- en: If you later need to change the configuration settings for the app and are logged
    in, you can go to the [applications portion of your settings](https://oreil.ly/WOBZf)
    to modify an installed app’s configuration.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以后需要更改应用程序的配置设置并且已登录，您可以前往[设置中的应用程序部分](https://oreil.ly/WOBZf)来修改已安装应用程序的配置。
- en: After the install and authorization steps are complete, start or restart any
    instances of applications where GitHub Copilot is active. Then, type the **`@`**
    sign and the extension’s name in the chat interface to start using the newly installed
    extension, as shown in [Figure 10-6](#invoking-the-perplexi).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成安装和授权步骤后，启动或重启任何GitHub Copilot活跃的应用实例。然后，在聊天界面中输入**`@`**符号和扩展名来开始使用新安装的扩展，如图10-6所示[调用PerplexityAI](#invoking-the-perplexi)。
- en: '![](assets/lghc_1006.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1006.png)'
- en: Figure 10-6\. Invoking the PerplexityAI app in chat
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-6. 在聊天中调用PerplexityAI应用程序
- en: The first time you attempt to use the new extension via the app after restarting,
    you may get prompted to authorize it—either for the selected workspace or for
    all workspaces ([Figure 10-7](#authorization-for-wor)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次通过应用程序重启后尝试使用新扩展时，您可能需要授权它——无论是为所选工作区还是为所有工作区（[图10-7](#authorization-for-wor)）。
- en: '![](assets/lghc_1007.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1007.png)'
- en: Figure 10-7\. Authorization for workspace
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-7. 工作空间的授权
- en: This is done in a similar manner to the initial authorization. Once the authorization
    is completed, you can pose your prompt again, and you should be able to get a
    response ([Figure 10-8](#perplexityai-response)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以类似初始授权的方式进行。一旦授权完成，您可以再次提出提示，并且应该能够得到响应（[图10-8](#perplexityai-response)）。
- en: '![](assets/lghc_1008.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1008.png)'
- en: Figure 10-8\. PerplexityAI response after authorization
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-8. 授权后的PerplexityAI响应
- en: The number of public Copilot extensions is growing regularly. If they fit with
    an application or purpose you need, they can be a useful option. But if you need
    functionality that is not already available or need an integration more directly
    with your data or processes, you may want to consider developing and using your
    own Copilot extension. To understand more about that option, let’s first talk
    about the two *implementation* types of Copilot extensions that can exist.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 公共 Copilot 扩展的数量正在定期增长。如果它们符合您需要的应用程序或用途，它们可以是一个有用的选项。但如果您需要尚未提供的功能，或者需要与您的数据或流程更直接地集成，您可能需要考虑开发和使用自己的
    Copilot 扩展。为了了解这个选项，让我们首先谈谈 Copilot 扩展可能存在的两种 *实现* 类型。
- en: Understanding Copilot Extension Implementation Types
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Copilot 扩展实现类型
- en: 'Copilot extensions can be implemented as one of two types:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 扩展可以以两种类型之一实现：
- en: Agent
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代理
- en: An extension implemented as an agent serves as a full AI assistant. This means
    it can handle complex chat conversations, execute custom code, and return very
    tailored responses.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为代理实现的扩展充当一个完整的 AI 助手。这意味着它可以处理复杂的聊天对话，执行自定义代码，并返回非常定制的响应。
- en: Skillsets
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 技能集
- en: An extension implemented as a skillset can invoke one or more API endpoints
    behind the scenes to retrieve specific information or perform basic actions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为技能集实现的扩展可以在幕后调用一个或多个 API 端点以检索特定信息或执行基本操作。
- en: You’ll see examples of how to build each implementation type later in the chapter.
    But for now, let’s level-set on the general advantages and disadvantages of each.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本章后面看到如何构建每种实现类型的示例。但就目前而言，让我们先了解一下每种类型的优势和劣势。
- en: Agents are the original type of Copilot extension and can provide the most extensive
    functionality if you need complex or custom processing and integration. They provide
    full control but also can be complex to implement.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是 Copilot 扩展的原始类型，如果您需要复杂或定制的处理和集成，它可以提供最广泛的功能。它们提供了完全的控制，但实现起来可能比较复杂。
- en: Skillsets make it easy to call other APIs or perform basic operations. They
    are simpler to implement while being more limited in what they can do and how
    much control they provide.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 技能集使得调用其他 API 或执行基本操作变得容易。它们实现起来更简单，但在能做什么以及提供多少控制方面更为有限。
- en: '[Table 10-1](#comparison-of-copilot) compares the two implementation choices.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 10-1](#comparison-of-copilot) 比较了两种实现选择。'
- en: Table 10-1\. Comparison of Copilot extension types
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1\. Copilot 扩展类型的比较
- en: '| Attribute | Copilot agents | Copilot skillsets |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | Copilot 代理 | Copilot 技能集 |'
- en: '| --- | --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Complexity | Requires more development effort to manage the entire user interaction
    flow response and response generation | Designed for easy integration with minimal
    setup |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 复杂性 | 需要更多的开发工作来管理整个用户交互流程、响应生成和响应生成 | 设计用于易于集成，设置最少 |'
- en: '| Control | Provides full control over how requests are processed and responses
    are generated | Limited control over the user interaction, focus is on data retrieval
    and basic actions |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 控制 | 提供对请求处理和响应生成的完全控制 | 对用户交互的控制有限，重点在于数据检索和基本操作 |'
- en: '| Use cases | Suitable for complex scenarios where you need to implement custom
    logic, integrate with other AI models, and manage conversation context | Straightforward
    tasks like fetching data from an external API or performing simple operations,
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 用例 | 适用于需要实现自定义逻辑、与其他 AI 模型集成和管理对话上下文的复杂场景 | 用于从外部 API 获取数据或执行简单操作等直接任务 |'
- en: '| Interfaces available | All (GitHub, IDEs) | All (GitHub, IDEs) |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 可用接口 | 所有（GitHub，IDEs） | 所有（GitHub，IDEs） |'
- en: '| Support | GitHub | GitHub |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 支持 | GitHub | GitHub |'
- en: Now that you understand these types, we can look at implementation. The first
    step in that process is making sure you are clear on some of the building blocks
    when you are assembling a Copilot extension.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了这些类型，我们可以看看实现。这个过程的第一步是确保您在组装 Copilot 扩展时对一些构建块有清晰的认识。
- en: Assembling Building Blocks for Extensions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组装扩展的构建块
- en: '*Building blocks* are the components that need to be assembled to allow the
    extension to be accessed and function. At the core, these are the parts we need
    when working with a Copilot extension:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*构建块* 是需要组装的组件，以便扩展可以被访问和运行。在核心上，这些是我们与 Copilot 扩展一起工作时需要的部分：'
- en: A GitHub App with a specific endpoint that handles interactions between the
    extension and Copilot Chat.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有特定端点的 GitHub 应用，该端点处理扩展与 Copilot Chat 之间的交互。
- en: A server process capable of hosting the backend and making endpoints available.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够托管后端并使端点可用的服务器进程。
- en: A backend implementation that provides the functionality for the extension.
    This functionality can involve calls to the LLM along with integration with external
    tools, services, or APIs.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供扩展功能的后端实现。此功能可能涉及对 LLM 的调用以及与外部工具、服务或 API 的集成。
- en: '[Figure 10-9](#overview-building-blocks) shows an overview of the building
    blocks we’ll be using to construct extensions.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-9](#overview-building-blocks) 展示了我们构建扩展将使用的构建块概述。'
- en: '![](assets/lghc_1009.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1009.png)'
- en: Figure 10-9\. Overview of our building blocks
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-9\. 我们构建块概述
- en: While GitHub apps and endpoint servers are required for agent and skillset extensions,
    those constructs are not unique to extensions. Next up is some clarification on
    how these are used for enabling extensions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 GitHub 应用和端点服务器对于代理和技能集扩展是必需的，但这些结构并不局限于扩展。接下来，我们将进一步说明这些结构如何用于启用扩展。
- en: GitHub Apps
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub Apps
- en: 'A *GitHub App* is a tool that integrates with GitHub to extend GitHub’s functionality.
    It can do this in several ways:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*GitHub 应用* 是一个与 GitHub 集成的工具，可以扩展 GitHub 的功能。它可以以多种方式做到这一点：'
- en: Automating tasks
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化任务
- en: Integrating with APIs and webhooks
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 API 和 webhooks 集成
- en: Customizing the GitHub workflow
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 GitHub 工作流程
- en: Once created, installed, and registered, a GitHub App can act, independently
    of the user, as an authorized process to do the type of operations described in
    the preceding list. The steps involve registering the app (including any manual
    configuration, if needed), writing any needed code for the functionality, and
    then setting it up to run via a webhook, callback URL, etc. The App also serves
    as a gateway for getting authorization to access resources.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建、安装和注册，GitHub 应用可以独立于用户，作为授权进程执行前面列表中描述的操作类型。这些步骤包括注册应用程序（包括任何需要的手动配置），编写任何需要的功能代码，然后通过
    webhook、回调 URL 等设置其运行。应用程序还充当获取访问资源授权的网关。
- en: Callback URL
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调 URL
- en: In the context of GitHub Copilot extensions, a *callback URL *is a URL that
    your custom Copilot extension provides to GitHub. The URL serves as the destination
    where the system will redirect the user after successfully authenticating with
    your extension. It acts like a *return address* once the authorization is complete.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub Copilot 扩展的上下文中，*回调 URL* 是你的自定义 Copilot 扩展提供给 GitHub 的 URL。该 URL 作为系统在通过你的扩展成功认证后用户将被重定向的目的地。一旦授权完成，它就像一个
    *回信地址*。
- en: The app for the PerplexityAI extension discussed previously is a good example.
    After installing the extension, go to your GitHub profile, and, from the left
    menu, under Integrations, choose Applications. You’ll then see the installed app
    for that extension ([Figure 10-10](#perplexityai-app-inst)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 之前讨论的 PerplexityAI 扩展的应用程序是一个很好的例子。安装扩展后，转到你的 GitHub 个人资料，然后从左侧菜单中，在集成下选择应用程序。你将看到该扩展已安装的应用程序([图
    10-10](#perplexityai-app-inst))。
- en: '![](assets/lghc_1010.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1010.png)'
- en: Figure 10-10\. PerplexityAI app installed via extension
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-10\. 通过扩展安装的 PerplexityAI 应用
- en: Link to Install Applications
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装应用程序的链接
- en: If you are logged into GitHub, you can also access the list of installed applications
    via [the Installations page](https://oreil.ly/WOBZf).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已登录 GitHub，你还可以通过[安装页面](https://oreil.ly/WOBZf)访问已安装应用程序的列表。
- en: For existing GitHub extensions that are available publicly or in your organization
    or enterprise, the app is installed and configured automatically as part of the
    extension’s installation and authorization process. For extensions that you implement,
    you’ll need to create and configure a new app as a part of the overall process.
    We’ll cover the creation and configuration steps in more detail later in this
    chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于公开或在你组织或企业中可用的现有 GitHub 扩展，应用程序作为扩展安装和授权过程的一部分自动安装和配置。对于你实现的扩展，你需要创建和配置一个新的应用程序作为整体过程的一部分。我们将在本章后面更详细地介绍创建和配置步骤。
- en: 'Next, let’s talk about another important piece of how extensions work: the
    endpoint server.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈扩展工作方式的重要部分之一：端点服务器。
- en: Endpoint Server
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端点服务器
- en: In simplest terms, an agent or skillset Copilot extension can be viewed as an
    app that connects to an endpoint which handles interactions between the extension
    and Copilot Chat. The *endpoint* is the API for code that processes a chat input,
    does some processing, and then streams the output back to the chat. So, having
    the endpoint available is a key requirement for the flow.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，代理或技能集Copilot扩展可以被视为一个连接到端点的应用程序，该端点处理扩展与Copilot Chat之间的交互。*端点*是处理聊天输入的API，进行一些处理，然后将输出流回聊天。因此，端点的可用性是流程的关键要求。
- en: In the case of an extension that you install from the marketplace or an enterprise/organization
    site, the server will have already been set up and configured. If you are creating
    your own extension, you need to have it hosted on a publicly accessible server
    (e.g., via deploying on a cloud service or tunneling). For example, you can use
    a simple service such as [Cloudflare](https://oreil.ly/m1eVi) or [ngrok](https://ngrok.com)
    to expose a public URL for development and testing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您从市场或企业/组织站点安装的扩展，服务器已经设置并配置好了。如果您正在创建自己的扩展，您需要将其托管在公开可访问的服务器上（例如，通过在云服务上部署或隧道传输）。例如，您可以使用像[Cloudflare](https://oreil.ly/m1eVi)或[ngrok](https://ngrok.com)这样的简单服务来公开开发测试的URL。
- en: Both of those services require signing up and then logging in to utilize. Another
    option, if you are using VS Code or a GitHub Codespace for development and testing,
    is to expose the port and enable [port forwarding](https://oreil.ly/jgyG3). This
    method is free and suitable for use before converting to a formal location when
    the extension is made public. The key thing to remember if using this method is
    that the port’s visibility must be changed to `public` from the default `private`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种服务都需要注册并登录才能使用。如果您正在使用VS Code或GitHub Codespace进行开发和测试，另一个选项是公开端口并启用[端口转发](https://oreil.ly/jgyG3)。这种方法是免费的，并且适合在将扩展公开之前将其转换为正式位置时使用。如果使用这种方法，需要记住的关键事项是必须将端口的可见性从默认的`private`更改为`public`。
- en: While the app and endpoint provide a way to exchange information with the chat
    interface, the real work happens with the backend code that implements the endpoint.
    The rest of this chapter is devoted to looking at and understanding how to do
    these implementations, starting with creating an extension as an agent.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然应用程序和端点提供了一种与聊天界面交换信息的方式，但实际的工作是在实现端点的后端代码中完成的。本章的其余部分致力于查看和理解如何进行这些实现，从创建一个作为代理的扩展开始。
- en: Implementing an Extension as an Agent
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将扩展作为代理实现
- en: A Copilot Agent is a custom tool embedded in a Copilot extension. Agents augment
    the capabilities of Copilot by allowing you to build and integrate custom features
    into the Copilot Chat interface.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot代理是嵌入在Copilot扩展中的自定义工具。通过允许您将自定义功能构建并集成到Copilot Chat界面中，代理增强了Copilot的功能。
- en: Copilot Agent Mode
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Copilot代理模式
- en: In [Chapter 4](ch04.html#ch04), we discussed Copilot’s built-in *Agent mode*
    that allows it to autonomously create code and terminal commands repeatedly to
    achieve a goal. In this chapter, we’re talking about agents again, but as separate
    functions built for use by extensions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html#ch04)中，我们讨论了Copilot的内置*代理模式*，它允许它自主地创建代码和终端命令以实现目标。在本章中，我们再次讨论代理，但作为为扩展而构建的独立功能。
- en: An agent implementation is appropriate when you need more control over how a
    request is processed or how a response is generated during a chat interaction.
    Agents can implement custom logic, integrate with other LLMs and the Copilot API,
    help with the context for chat conversations, and manage the interaction. But
    they are also more complex to create and maintain.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要更多控制如何在聊天交互过程中处理请求或生成响应时，代理实现是合适的。代理可以实现自定义逻辑，与其他LLM和Copilot API集成，帮助提供聊天对话的上下文，并管理交互。但它们也更复杂，创建和维护起来也更困难。
- en: Performing a Basic Implementation
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行基本实现
- en: In this section, you’ll see how to implement a basic but useful agent-based
    extension named `@meta-files`. Given a programming language in the prompt, our
    extension will generate example *.gitignore* and *.gitattributes* files. Alternatively,
    if the user provides an open source license name as part of the prompt, the extension
    will generate an example of the open source license. If the license has a placeholder
    for the user’s name and the current year, the extension will attempt to fill those
    in. Finally, the extension will also provide some guidance on when that type of
    license is useful.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解如何实现一个基本但有用的基于代理的扩展 `@meta-files`。给定一个编程语言提示，我们的扩展将生成示例 *.gitignore*
    和 *.gitattributes* 文件。或者，如果用户在提示中提供了开源许可证名称，扩展将生成开源许可证的示例。如果许可证有用户姓名和当前年份的占位符，扩展将尝试填充这些信息。最后，扩展还将提供有关何时使用此类许可证的指导。
- en: 'Examples of using the extension are shown in Figures [10-11](#extension-generating)
    and [10-12](#extension-generating-license). The prompts used to invoke the extension
    are shown in the upper right: `@meta-files Python` for [Figure 10-11](#extension-generating)
    and `@meta-files MIT` for [Figure 10-12](#extension-generating-license). The code
    is based on examples in the [Copilot extensions](https://oreil.ly/pWQcX) and can
    be found in [the book’s GitHub repository](https://oreil.ly/93ZY_).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该扩展的示例显示在图 [10-11](#extension-generating) 和 [10-12](#extension-generating-license)
    中。用于调用扩展的提示显示在上右角：`@meta-files Python` 用于 [图 10-11](#extension-generating) 和 `@meta-files
    MIT` 用于 [图 10-12](#extension-generating-license)。代码基于 [Copilot 扩展](https://oreil.ly/pWQcX)
    中的示例，可以在 [本书的 GitHub 仓库](https://oreil.ly/93ZY_) 中找到。
- en: '![](assets/lghc_1011.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1011.png)'
- en: Figure 10-11\. Extension generating meta files for Python
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-11\. 为 Python 生成元文件的扩展
- en: '![](assets/lghc_1012.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1012.png)'
- en: Figure 10-12\. Extension generating license information
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-12\. 为扩展生成许可证信息
- en: '[Figure 10-13](#agent-extension-overview) shows at a high level how an agent
    extension works. I’ll have more to say about the individual pieces in the following
    sections.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-13](#agent-extension-overview) 从高层次展示了代理扩展的工作方式。在接下来的部分，我会详细介绍各个部分。'
- en: '![](assets/lghc_1013.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1013.png)'
- en: Figure 10-13\. Agent extension overview
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-13\. 代理扩展概述
- en: For the sake of brevity, we won’t dive into all the code here. We’ll just hit
    some key points. This example is written in JavaScript, but your extension can
    be written in nearly any modern language.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们不会在这里深入所有代码。我们只关注一些关键点。这个示例是用 JavaScript 编写的，但你的扩展可以用几乎任何现代语言编写。
- en: 'This simple example focuses on only two standard JavaScript files: [*package.json*](https://oreil.ly/vowZU)
    and [*index.js*](https://oreil.ly/k16Kn). Let’s take a look at the *package.json*
    contents first. The contents are shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例只关注两个标准的 JavaScript 文件：[*package.json*](https://oreil.ly/vowZU) 和 [*index.js*](https://oreil.ly/k16Kn)。让我们首先看看
    *package.json* 的内容。内容如下：
- en: '[PRE0]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The structure of this is standard boilerplate for this type of file. We could
    have multiple other fields, but we’re keeping the example simple. The only pieces
    that warrant additional explanation are the dependencies.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构的文件是这种类型的标准样板。我们可以有多个其他字段，但我们保持示例简单。唯一需要额外解释的部分是依赖项。
- en: '[Express](https://expressjs.com) is a simple, backend web application framework.
    It’s designed to make it easy to build web apps and APIs with Node.js. When we
    create our agent extension, we are essentially creating a web app with an endpoint
    that is surfaced via the GitHub App.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[Express](https://expressjs.com) 是一个简单的前端 Web 应用程序框架。它旨在通过 Node.js 使构建 Web
    应用程序和 API 变得容易。当我们创建代理扩展时，我们实际上是在创建一个通过 GitHub App 提供端点的 Web 应用程序。'
- en: The other dependency we’re using, [Octokit](https://github.com/octokit), is
    a set of libraries provided by GitHub to let code interact with its REST and GraphQL
    APIs. It facilitates programmatically automating tasks and managing repositories
    and allows you to manipulate GitHub resources like pull requests and issues in
    code. We use it here to help get and work with a token for the user’s information.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的另一个依赖项是 [Octokit](https://github.com/octokit)，它是由 GitHub 提供的一组库，允许代码与其
    REST 和 GraphQL API 交互。它简化了任务自动化和仓库管理，并允许你在代码中操作 GitHub 资源，如拉取请求和问题。我们在这里使用它来帮助获取和操作用户信息的令牌。
- en: The file with our main logic is *index.js*. You can look at the [file in GitHub](https://oreil.ly/GJW8z)
    if you want to see the entire code. The logic at the top of the file does the
    necessary imports, starts an Express app, posts a welcome message, and then goes
    into the main processing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 包含主要逻辑的文件是 *index.js*。如果你想查看整个代码，可以查看 [GitHub 中的文件](https://oreil.ly/GJW8z)。文件顶部的逻辑执行必要的导入，启动一个
    Express 应用程序，发布一条欢迎消息，然后进入主要处理。
- en: 'The main processing uses Octokit to get a token, then moves into a standard
    cycle:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 主要处理使用 Octokit 获取令牌，然后进入一个标准周期：
- en: Getting the payload coming to us from the chat interface (via the GitHub App)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从聊天界面（通过 GitHub App）获取发送给我们的有效载荷
- en: Augmenting the prompt to tell the AI what we’re looking for
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强提示词以告诉 AI 我们在寻找什么
- en: Sending the prompt off to the underlying LLM to get a response from the AI
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将提示发送到底层的 LLM 以获取 AI 的响应
- en: Passing the response to the chat interface
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将响应传递到聊天界面
- en: 'The mechanics are fairly straightforward. The real magic happens where we augment
    the prompt to tell the AI what we’re looking for. Here’s the code for that part:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 机制相当简单。真正的魔法发生在我们增强提示词以告诉 AI 我们在寻找什么的地方。以下是这部分代码：
- en: '[PRE1]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are adding content to the prompt we received from the chat to tell the LLM
    what we want it to look for and how to respond. This is the key to making an agent
    extension work—providing a detailed prompt to the LLM to tell it what we want
    it to pay attention to and the kind of output we require. Think of it as similar
    to interacting directly with a model like ChatGPT. The more details we can provide
    in our prompt conversation, the better response we can expect from the AI. The
    logic we use in our agent code to get the desired outcome really comes down to
    crafting a good prompt.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在从聊天界面收到的提示词中添加内容，以告诉 LLM 我们想要它查找什么以及如何响应。这是使代理扩展工作的重要关键——向 LLM 提供详细的提示词，告诉它我们想要它注意什么以及我们需要的输出类型。把它想象成直接与
    ChatGPT 这样的模型交互。我们能在提示词对话中提供越多的细节，我们就能从 AI 那里得到越好的响应。我们用于在代理代码中获得预期结果的逻辑实际上归结于构建一个良好的提示词。
- en: Crafting a Good Prompt
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个良好的提示词
- en: Any number of resources are available with guidance on crafting a good prompt.
    Ultimately, the best prompt is the one that works as you intend in terms of parsing
    out the right information and returning a meaningful response.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多资源可以指导你如何构建一个良好的提示词。最终，最好的提示词是那个能够按照你的意图解析出正确信息并返回有意义的响应的提示词。
- en: One simple approach to this is trying out and then refining your prompt through
    the Copilot Chat interface (or an AI model) directly first. Once you have found
    a prompt that works, you can add it into your extension’s code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的简单方法是通过 Copilot Chat 接口（或 AI 模型）直接尝试和改进你的提示词。一旦你找到一个有效的提示词，你就可以将其添加到你的扩展代码中。
- en: With this basic setup, we have the core code we need for our extension. The
    necessary code for running this extension was created in a *nonproduction* environment.
    Taking this to production would require more implementation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个基本设置，我们有了扩展所需的核心代码。运行此扩展所需的所有代码都是在非生产环境中创建的。将其推向生产将需要更多的实现。
- en: To help simplify the larger implementation for production, GitHub has made an
    SDK available that implements some of the core functionality needed for production
    extensions. At the time of this writing, the SDK is only an alpha release and
    only suitable for extensions implemented as agents. You can learn more about it
    in the sidebar.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助简化生产中的更大实现，GitHub 提供了一个 SDK，该 SDK 实现了生产扩展所需的一些核心功能。在撰写本文时，该 SDK 仅是 alpha
    版本，并且仅适用于作为代理实现的扩展。你可以在侧边栏中了解更多信息。
- en: We need a server and an app to complete the implementation. Let’s look at how
    those can be set up.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个服务器和一个应用程序来完成实现。让我们看看这些是如何设置的。
- en: Configuring a GitHub App for a Copilot Agent Extension
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Copilot 代理扩展配置 GitHub App
- en: In this example, we’re leveraging a GitHub Codespace to provide the runtime
    environment and server for the endpoint. Using a codespace is not something you
    would do in production use, but it simplifies the process quite a bit for our
    basic demo and testing scenarios. You could also use a service like ngrok if you
    preferred.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们利用 GitHub Codespace 来提供端点的运行环境和服务器。在生产环境中，你不会使用 codespace，但它极大地简化了我们的基本演示和测试场景。如果你更喜欢，你也可以使用
    ngrok 这样的服务。
- en: 'The steps for creating a codespace from a GitHub repository are outlined [in
    the documentation](https://oreil.ly/DCh4K). Once the codespace is started, you
    just need two commands to get the server going:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub仓库创建codespace的步骤在[文档](https://oreil.ly/DCh4K)中有概述。一旦codespace启动，您只需要两个命令就可以启动服务器：
- en: '[PRE2]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Node App and npm
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node应用和npm
- en: The code here is a [node app](https://nodejs.org/en/about), and [npm](https://npmjs.com)
    is a node tool used to run it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的代码是一个[node应用](https://nodejs.org/en/about)，而[npm](https://npmjs.com)是用于运行它的node工具。
- en: At this point, you’ll have a server running from the codespace on port 3000\.
    You need to take two steps prior to configuring a GitHub App for the extension.
    First, you need to make the port serving the endpoint *public* instead of *private*.
    To do that, switch to the Ports tab in the codespace, right-click the port in
    the list, and change its Port Visibility setting to Public, as shown in [Figure 10-14](#changing-port-to-publ).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您将在端口3000上从codespace运行一个服务器。在为扩展配置GitHub应用之前，您需要采取两个步骤。首先，您需要将端点服务的端口设置为*公开*而不是*私有*。为此，切换到codespace中的端口选项卡，在列表中右键单击端口，并将其端口可见性设置更改为公共，如图[图10-14](#changing-port-to-publ)所示。
- en: '![](assets/lghc_1014.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1014.png)'
- en: Figure 10-14\. Changing the port to public
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-14. 将端口改为公开
- en: Then copy the server address from the same location ([Figure 10-15](#copying-the-port-addr)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从同一位置复制服务器地址([图10-15](#copying-the-port-addr))。
- en: '![](assets/lghc_1015.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1015.png)'
- en: Figure 10-15\. Copying the port address
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-15. 复制端口号
- en: Behind the Scenes
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背后情况
- en: If you want to understand more about how the codespace is configured and how
    the server is started, the port selected, etc., take a look at the files [*.devcontainer/devcontainer.json*](https://oreil.ly/E9daL)
    and [*.vscode/launch.json*](https://oreil.ly/HTlM8) in the GitHub repository.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于codespace的配置和服务器启动方式，选择的端口等信息，请查看GitHub仓库中的文件[*.devcontainer/devcontainer.json*](https://oreil.ly/E9daL)和[*.vscode/launch.json*](https://oreil.ly/HTlM8)。
- en: With the code implemented for the extension agent and the server running, we’re
    now ready to complete the implementation of the extension itself by creating and
    configuring a corresponding GitHub App.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了扩展代理的代码并启动服务器后，我们现在可以通过创建和配置相应的GitHub应用来完成扩展本身的实现。
- en: For Development and Test Purposes Only
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅限开发和测试使用
- en: In our examples in this chapter, we are creating code, setting up simple servers,
    and implementing user-specific agents for demo purposes. To convert these examples
    to production-ready instances, you would need to add functionality for security,
    hosting, and more.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，我们创建代码、设置简单服务器和实现用于演示的用户特定代理。要将这些示例转换为生产就绪实例，您需要添加安全、托管等功能。
- en: To set up the app, log into GitHub with the same ID as the the one used to run
    the codespace. Then go to your developer settings and create a new app. The shortcut
    link for this is [*https://github.com/settings/apps/new*](https://github.com/settings/apps/new).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置应用，请使用与运行codespace相同的ID登录GitHub。然后转到您的开发者设置并创建一个新的应用。此快捷链接为[*https://github.com/settings/apps/new*](https://github.com/settings/apps/new)。
- en: Next, fill in the required fields. The App Name should be a unique name. This
    is the name that you will use in the Copilot Chat interface to invoke your extension.
    For example, if you choose *my-app* for the name, you would use `@my-app` in the
    chat interface to invoke your extension.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，填写所需的字段。应用名称应该是唯一的名称。这是您将在Copilot Chat界面中用来调用您的扩展的名称。例如，如果您选择*my-app*作为名称，您将在聊天界面中使用`@my-app`来调用您的扩展。
- en: For the Homepage URL field, you can provide a URL that goes to a web page about
    your app/extension if you have a page. If not, you can just put in the link to
    the GitHub repository for your extension or even just [*https://github.com*](https://github.com).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主页URL字段，如果您有一个关于您的应用/扩展的网页，您可以提供一个指向该网页的URL。如果没有，您可以直接输入您的扩展GitHub仓库的链接，甚至只需[*https://github.com*](https://github.com)。
- en: The Callback URL field is where you place the public URL address from the port
    you set as public in the codespace. This must be in place in order for your extension
    to send and receive responses for its code. You should also add `/callback` at
    the end of the URL.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 回调URL字段是您放置在codespace中设置为公开的端口号的公开URL地址的地方。为了使您的扩展能够发送和接收其代码的响应，这一点必须到位。您还应在URL末尾添加`/callback`。
- en: For the examples we’re using here, we can disable any other selected options
    on this page, such as *Webhooks*. Next is the app’s visibility setting. You can
    make it accessible only to you for development and testing purposes. Later, you
    can enable public access when you’re ready to share. [Figure 10-16](#initial-agent-extensi)
    shows an example page with completed fields.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在这里使用的示例，我们可以禁用此页面上选定的任何其他选项，例如 *Webhooks*。接下来是应用程序的可见性设置。你可以使其仅对开发测试目的可访问。稍后，当你准备好分享时，你可以启用公共访问。[图
    10-16](#initial-agent-extensi) 展示了一个带有完成字段的示例页面。
- en: When you have completed this screen, you can click Create GitHub App to complete
    the registration.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成此屏幕后，你可以点击创建 GitHub 应用程序以完成注册。
- en: '![](assets/lghc_1016.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1016.png)'
- en: Figure 10-16\. Initial agent extension configuration
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-16\. 初始代理扩展配置
- en: At this point, you’ll need to generate a private key in order to install your
    app and sign access tokens. GitHub will provide you with a link to generate and
    download the key ([Figure 10-17](#generate-a-private-ke)). The key will then be
    automatically added to your app’s configuration.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你需要生成一个私钥，以便安装你的应用程序并签署访问令牌。GitHub 将提供链接以生成和下载密钥（[图 10-17](#generate-a-private-ke)）。然后该密钥将自动添加到你的应用程序配置中。
- en: '![](assets/lghc_1017.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1017.png)'
- en: Figure 10-17\. Generating a private key to install the app
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-17\. 生成私钥以安装应用程序
- en: Once you’ve created the app on the General page, you need to do a bit more configuration
    by using the selections on the left. On the Permissions & Events page, the only
    option you must set for dev/test purposes is in the Account Permissions section.
    Give Copilot Chat read-only permissions ([Figure 10-18](#adding-permissions-fo)).
    Then save those changes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在“常规”页面创建了应用程序，你需要通过左侧的选择进行一些额外的配置。在“权限和事件”页面，你必须为开发/测试目的在“账户权限”部分设置一个选项。给
    Copilot Chat 读取权限（[图 10-18](#adding-permissions-fo)）。然后保存这些更改。
- en: '![](assets/lghc_1018.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1018.png)'
- en: Figure 10-18\. Adding permissions for Copilot Chat
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-18\. 为 Copilot Chat 添加权限
- en: On the Copilot-specific settings page, change the app type from Disabled to
    Agent (since we’re implementing our extension as an agent). Then, in the URL section,
    paste the public URL from your codespace.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Copilot 特定设置页面，将应用程序类型从禁用更改为代理（因为我们正在将我们的扩展作为代理实现）。然后，在 URL 部分，粘贴你的 codespace
    的公共 URL。
- en: Lastly on this page, add content in the “Inference description” field. This
    information is used to provide a brief description of your agent to help users
    understand the purpose of the extension. The contents are displayed to users when
    they hover over the extension’s slug in the chat area. After completing this,
    you can save your changes. [Figure 10-19](#copilot-settings-for) shows the completed
    page.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后在此页面上，在“推理描述”字段中添加内容。这些信息用于向用户提供有关代理的简要描述，以帮助用户了解扩展的目的。当用户在聊天区域的扩展 slug 上悬停时，会显示这些内容。完成此操作后，你可以保存你的更改。[图
    10-19](#copilot-settings-for) 展示了完成的页面。
- en: '![](assets/lghc_1019.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1019.png)'
- en: Figure 10-19\. Copilot settings for the app
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-19\. 应用程序的 Copilot 设置
- en: These are all the required fields you need to set up for the app to work with
    your agent. An Optional Features page only allows you to opt out of token expiration,
    and an Advanced page handles Danger Zone types of options for transferring ownership
    of the app, deleting the app, or making it public.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你需要设置的所有字段，以便应用程序与你的代理一起工作。可选功能页面仅允许你选择退出令牌过期，而高级页面处理有关转让应用程序所有权、删除应用程序或使其公开的“危险区域”类型选项。
- en: After completing the preceding steps, you can install the app in your personal
    or organizational account for testing. To do this, click the Install App page
    and follow the instructions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 完成前面的步骤后，你可以在个人或组织账户中安装应用程序进行测试。为此，请点击“安装应用程序”页面并按照说明操作。
- en: The first time you attempt to use the extension, you’ll need to authorize access
    for it to continue ([Figure 10-20](#connecting-the-app-on)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试使用扩展时，你需要授权访问以便继续使用（[图 10-20](#connecting-the-app-on)）。
- en: '![](assets/lghc_1020.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1020.png)'
- en: Figure 10-20\. Connecting the app on the first use
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-20\. 首次使用时连接应用程序
- en: After clicking the Connect button, you’ll need to authorize the app to access
    the relevant resources ([Figure 10-21](#authorizing-app)).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 点击连接按钮后，你需要授权应用程序访问相关资源（[图 10-21](#authorizing-app)）。
- en: '![](assets/lghc_1021.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1021.png)'
- en: Figure 10-21\. Authorizing the app
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-21\. 授权应用程序
- en: Once the app is authorized, you’re ready to use the extension as shown earlier.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用被授权，你就可以像之前展示的那样使用扩展。
- en: Another way to create an extension is to utilize the *skillsets* pattern. This
    implementation choice works well for allowing Copilot to get real-time targeted
    information or do simple API processing easily. But while it can be a simpler
    coding implementation, it does require a more complex app configuration. We’ll
    explore extensions implemented via skillsets in the next section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 创建扩展的另一种方法是利用*技能集*模式。这种实现选择非常适合让Copilot轻松获取实时目标信息或执行简单的API处理。虽然它可能是一个更简单的编码实现，但它确实需要更复杂的应用程序配置。我们将在下一节中探讨通过技能集实现的扩展。
- en: Implementing an Extension via Skillsets
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过技能集实现扩展
- en: While agents provide a powerful and flexible architecture for implementing Copilot
    extensions, they can be overkill. If all you need to do in response to a chat
    prompt is invoke a specific tool or call an API, you can implement your extension
    by using skillsets instead.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代理为实施Copilot扩展提供了一个强大且灵活的架构，但可能有些过度。如果你在响应聊天提示时只需要调用特定工具或调用API，你可以通过使用技能集来实现你的扩展。
- en: A single *skill* in Copilot is a tool that the model calls to do a specific
    task in response to a prompt—for example, calling an external API. A collection
    of up to five skills is called a *skillset*. These skillsets allow for integration
    of external services or custom API endpoints into the Copilot workflow, without
    the complexity of agents.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot中的单个*技能*是模型在响应提示时调用来执行特定任务的工具——例如，调用外部API。最多五个技能的集合称为*技能集*。这些技能集允许将外部服务或自定义API端点集成到Copilot工作流程中，而不需要代理的复杂性。
- en: Skillsets are more lightweight and simpler than agents. They are a better architecture
    choice when you need to do simple, specific tasks without a lot of setup. They
    can automatically handle tasks like routing, prompt crafting, function evaluation,
    and response generation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 技能集比代理更轻量级、更简单。当你需要执行简单的、特定的任务且不需要大量设置时，它们是一个更好的架构选择。它们可以自动处理诸如路由、提示制作、函数评估和响应生成等任务。
- en: '[Figure 10-22](#overview-skillset-extension) shows at a high level how a skillset
    extension works. I’ll have more to say about the individual pieces in the following
    sections.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-22](#overview-skillset-extension)从高层次展示了技能集扩展的工作方式。在接下来的章节中，我将更多地讨论各个部分。'
- en: '![](assets/lghc_1022.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_1022.png)'
- en: Figure 10-22\. Overview of a skillset extension
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-22\. 技能集扩展概述
- en: Performing a Basic Implementation
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行基本实现
- en: 'As an example for the book, I’ve created a simple Copilot extension, implemented
    with skillsets, that allows you to do three basic operations for Go releases:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本书的示例，我创建了一个简单的Copilot扩展，使用技能集实现，允许你为Go版本执行三个基本操作：
- en: Find out the latest release of Go
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找Go的最新版本
- en: Find out the currently supported releases of Go
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找当前支持的Go版本
- en: Determine whether a given release of Go is supported or when it reached its
    end of life (EOL)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定给定的Go版本是否受支持或它何时达到其生命周期的结束（EOL）
- en: The code for this example lives in [book’s GitHub repository](https://oreil.ly/n13JY).
    To show an example of implementing an extension in a different language, the code
    for the `gover-ext` extension is written in Go. It is modeled after the Copilot
    [skillset extension example](https://oreil.ly/WWZxW).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码位于[书籍的GitHub仓库](https://oreil.ly/n13JY)。为了展示在不同语言中实现扩展的示例，`gover-ext`扩展的代码是用Go编写的。它是基于Copilot
    [技能集扩展示例](https://oreil.ly/WWZxW)构建的。
- en: 'A [*main.go file*](https://oreil.ly/8dk9j) *registers* handler functions for
    specific URL patterns related to each of the capabilities of the extension. The
    core logic is shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[*main.go文件*](https://oreil.ly/8dk9j) *注册*与扩展每个功能相关的特定URL模式的处理器函数。核心逻辑如下所示：
- en: '[PRE3]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For each of the handlers, we implement a separate function that invokes an API,
    checks for errors, and returns the desired results. For example, in the handler
    for getting the latest version—[LatestVersionGo](https://oreil.ly/TxXMz)—the key
    parts of the code are implemented as follows.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个处理器，我们实现了一个单独的函数，该函数调用API，检查错误，并返回所需的结果。例如，在获取最新版本的处理器——[LatestVersionGo](https://oreil.ly/TxXMz)——中，代码的关键部分实现如下。
- en: 'First, we implement a structure to hold the version and make a call to the
    Go site’s API to get the latest version:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实现一个结构来保存版本，并调用Go网站API以获取最新版本：
- en: '[PRE4]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After doing some error checking to make sure the call was successful, we buffer
    the response and then parse it to get the latest version and write that back to
    the stream:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行一些错误检查以确保调用成功之后，我们将响应缓冲并解析它以获取最新版本，然后将该版本写回流中：
- en: '[PRE5]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The handler for the supported versions query uses a similar approach. There’s
    a structure to hold the data and a call to a different API to get the raw information:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 支持版本查询的处理程序使用类似的方法。有一个结构来存储数据，并调用不同的API来获取原始信息：
- en: '[PRE6]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then after some error checking to make sure the call was successful, and buffering
    the response, the results are parsed and converted into a single string that is
    written back to the stream:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在一些错误检查以确保调用成功之后，并缓冲响应，结果被解析并转换成一个字符串，然后写回流中：
- en: '[PRE7]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The flow for the other function to determine whether a version is supported
    or has reached EOL is similar.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 确定版本是否受支持或已达到EOL的其它函数流程与此类似。
- en: Since the coding is pretty basic and makes no mention of the AI or inferences,
    you may be wondering how the prompts in Copilot Chat ultimately end up invoking
    the respective handlers. The secret is in the GitHub App configuration when you
    are creating an extension that uses skillsets.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编码相当基础，没有提及AI或推理，你可能想知道Copilot Chat中的提示是如何最终调用相应的处理程序的。秘密在于当你创建使用技能集的扩展时GitHub应用的配置。
- en: Configuring a GitHub App for a Copilot Extension Using Skillsets
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用技能集配置GitHub应用以用于Copilot扩展
- en: Like extensions that are implemented as agents, extensions implemented as skillsets
    need a GitHub App to act as a bridge between Copilot’s chat interface and the
    underlying extension implementation. Much of the setup is similar to that done
    for agents, but we’ll cover some significant differences here. (For any other
    details on app setup and configuration, you can refer back to [“Configuring a
    GitHub App for a Copilot Agent Extension”](#configuring-github-app).)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于作为代理实现的扩展，作为技能集实现的扩展需要GitHub应用作为Copilot聊天界面和底层扩展实现之间的桥梁。大部分的设置与为代理所做的设置类似，但在这里我们将介绍一些显著的不同之处。（对于应用设置和配置的任何其他细节，你可以参考[“为Copilot代理扩展配置GitHub应用”](#configuring-github-app)。）
- en: The first difference is that, on the General page, you do not have to put in
    an extension-specific Callback URL. You will need a callback URL for authentication,
    but it can be a simple URL like [*https://github.com*](https://github.com).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个区别是，在“通用”页面，你不需要输入特定扩展的回调URL。你将需要一个用于身份验证的回调URL，但它可以是一个简单的URL，例如[*https://github.com*](https://github.com)。
- en: The other changes for configuring the app, and the most significant ones, are
    done on the Copilot page. On this page, you need to set the App Type field to
    Skillset. Doing this will then bring up a section called Skill definitions ([Figure 10-23](#copilot-page-for-skil)).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 配置应用的其它更改，其中最重要的更改是在“Copilot”页面进行的。在这个页面上，你需要将“应用类型”字段设置为“Skillset”。这样做将会弹出一个名为“技能定义”的部分（[图10-23](#copilot-page-for-skil)）。
- en: '![](assets/lghc_1023.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1023.png)'
- en: Figure 10-23\. The Copilot page for setting up the skillset app
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-23. 设置技能集应用的Copilot页面
- en: The “Skill definitions” section is where the mapping happens from the prompt
    in chat to the handlers in the code. For each skill that we are handling in our
    code, we need to go through the process of adding a new skill. We’ll look at one
    as an example. The others follow the same pattern.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: “技能定义”部分是聊天提示与代码中的处理程序之间的映射发生的地方。对于我们在代码中处理的每个技能，我们需要通过添加新技能的过程。我们将以一个为例进行查看。其它技能遵循相同的模式。
- en: When you click the “Add new skill” button, you get a dialog with various fields
    to fill in, including Name, Inference description, URL, and Parameters ([Figure 10-24](#new-skill-definition)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击“添加新技能”按钮时，你会得到一个对话框，其中包含各种需要填写的字段，包括名称、推理描述、URL和参数（[图10-24](#new-skill-definition)）。
- en: '![](assets/lghc_1024.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/lghc_1024.png)'
- en: Figure 10-24\. New skill definition screen for the app
  id: totrans-218
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-24. 应用新技能定义屏幕
- en: In the Name field, we put the name of the skill to be used by the model, and
    that is shown to the user when it is invoked.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在“名称”字段中，我们放入模型将使用的技能名称，当它被调用时，这个名称会显示给用户。
- en: In the “Inference description” field, we are explaining to the model *what/when/how*
    this skill should be invoked. This description should be meaningful enough that
    the model can understand what is intended.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在“推理描述”字段中，我们向模型解释*何时/如何/为什么*应该调用这个技能。这个描述应该足够有意义，以便模型能够理解意图。
- en: Think of this as the direct prompt that you might supply to the model if you
    wanted it to execute this skill. While we are using a simple prompt here, depending
    on what your skill does and how complex it is, you may want to define additional
    details. Examples could include expected inputs and outputs, especially if other
    skillsets are very similar. [Figure 10-25](#skill-definition-in-a) shows an example
    definition including the inference description matching one of the skills we are
    using.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将其视为如果您想让模型执行此技能，您可能提供给模型的直接提示。虽然我们在这里使用了一个简单的提示，但根据您的技能做什么以及它的复杂程度，您可能需要定义额外的细节。示例可能包括预期的输入和输出，特别是如果其他技能集非常相似的话。[图
    10-25](#skill-definition-in-a) 展示了一个包括与我们所使用的技能匹配的推理描述的示例定义。
- en: '![](assets/lghc_1025.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_1025.png)'
- en: Figure 10-25\. Skill definition in the app
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-25\. 应用程序中的技能定义
- en: Based on the prompt in the chat and how well the model can match it up with
    the Inference description, the process will invoke the endpoint specified in the
    URL field. This field is where you put the endpoint server address with the path
    specified in the extension code. In this case, since our extension code is looking
    for `latest-version-go` to know to invoke the handler for getting the latest Go
    version, we can put the API endpoint in this field with `latest-version-go` at
    the end.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 根据聊天中的提示以及模型如何与推理描述相匹配，该过程将调用 URL 字段中指定的端点。该字段是您放置端点服务器地址并指定扩展代码中路径的地方。在这种情况下，由于我们的扩展代码正在寻找
    `latest-version-go` 以知道调用获取最新 Go 版本的处理器，我们可以在该字段中放置 API 端点，并在末尾添加 `latest-version-go`。
- en: 'In production, we would have a designated public URL that this would be directed
    to. But if we’re using ngrok, a codespace, or something similar to serve this,
    we would put the public URL being served from those applications with *latest-version-go*
    appended. For an [ngrok](https://ngrok.com) instance, the entire URL would look
    something like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，我们将有一个指定的公共 URL，该 URL 将被引导到这里。但如果我们使用 ngrok、codespace 或类似的服务，我们将放置从这些应用程序提供的公共
    URL，并在末尾附加 *latest-version-go*。对于 [ngrok](https://ngrok.com) 实例，整个 URL 可能看起来像这样：
- en: '[PRE8]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Localhost URL and ngrok
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地主机 URL 和 ngrok
- en: '*ngrok* lets you create secure tunnels from a public internet endpoint to a
    locally running service on your machine. This cross-platform tool lets you easily
    expose local web servers to the internet for testing and sharing without having
    to set up complex networking configurations.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*ngrok* 允许您从公共互联网端点到您机器上本地运行的服务创建安全隧道。这个跨平台工具让您可以轻松地将本地 Web 服务器暴露给互联网进行测试和共享，而无需设置复杂的网络配置。'
- en: While you would typically start ngrok serving on localhost:8080, you cannot
    use localhost in the skill configuration because it is not publicly reachable.
    Instead, you’ll need to grab the actual public URL that ngrok is forwarding to
    localhost:8080.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您通常会从 localhost:8080 启动 ngrok 服务，但在技能配置中不能使用 localhost，因为它不是公开可达的。相反，您需要获取
    ngrok 实际转发到 localhost:8080 的实际公共 URL。
- en: 'If we were using a codespace, the URL might look like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是 codespace，URL 可能看起来像这样：
- en: '[PRE9]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The Parameters section is for defining the parameters of the skill in JSON.
    Since each of our skillsets keys off the prompt string, we can simply use the
    following in this field:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 参数部分用于在 JSON 中定义技能的参数。由于我们每个技能集都是基于提示字符串来触发的，因此我们可以在该字段中简单地使用以下内容：
- en: '[PRE10]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we have the implementation completed and the app set up and configured,
    we can run the app in the same way as we did for the agent one. [Figure 10-26](#running-the-go-versio)
    shows an example of trying out the various skills from the extension. Notice the
    specific prompts that are being used: “@go-versions supported versions” and “@go-versions
    1.21” (as shown on the right).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了实现并设置了应用程序并进行了配置，我们就可以以与代理相同的方式运行应用程序。[图 10-26](#running-the-go-versio)
    展示了尝试扩展中各种技能的示例。注意正在使用的特定提示：“@go-versions supported versions” 和 “@go-versions
    1.21”（如右图所示）。
- en: '![](assets/lghc_1026.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_1026.png)'
- en: Figure 10-26\. Running the `go-versions` extension
  id: totrans-236
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-26\. 运行 `go-versions` 扩展
- en: Extensions implemented as agents and skillsets provide maximum flexibility with
    their ability to be run in any of the integrated chat interfaces (GitHub, IDEs).
    Now that we’ve covered those, it’s time to look at the other alternative for adding
    capabilities into the IDE mentioned at the start of the chapter—VS Code extensions
    for Copilot.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 作为代理和技能集实现的扩展提供了最大的灵活性，它们可以在任何集成的聊天界面（GitHub、IDEs）中运行。现在我们已经涵盖了这些，是时候看看本章开头提到的将功能添加到
    IDE 的其他替代方案——Copilot 的 VS Code 扩展了。
- en: Creating VS Code Extensions for Copilot
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建VS Code扩展用于Copilot
- en: Like Copilot extensions, VS Code extensions for Copilot provide additional capabilities
    for the user through Copilot Chat. Unlike Copilot extensions, VS Code extensions
    are implemented using the VS Code platform and APIs. Because of that implementation
    approach, the VS Code extensions have access to broad and deep VS Code functionality
    and can have tight integration. And they don’t require a separate GitHub App to
    use. The disadvantage is that you can’t use them in other non-IDE clients (like
    a chat interface in GitHub). [Table 10-2](#comparison2-of-copilot) shows an updated
    version of our earlier comparison table with an added column for VS Code extensions
    for Copilot.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与Copilot扩展一样，VS Code扩展通过Copilot Chat为用户提供额外的功能。与Copilot扩展不同，VS Code扩展是使用VS Code平台和API实现的。由于这种实现方法，VS
    Code扩展可以访问广泛的VS Code功能，并且可以紧密集成。而且它们不需要单独的GitHub App即可使用。缺点是它们不能在其他非IDE客户端（如GitHub中的聊天界面）中使用。[表10-2](#comparison2-of-copilot)显示了之前比较表的更新版本，增加了一个用于VS
    Code扩展的Copilot的列。
- en: Table 10-2\. Comparison of Copilot extension types
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-2. Copilot扩展类型的比较
- en: '| Attribute | Copilot agents | Copilot skillsets | VS Code extensions for Copilot
    |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | Copilot代理 | Copilot技能集 | VS Code的Copilot扩展 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Complexity | Requires more development effort to manage the entire user interaction
    flow response and response generation | Designed for easy integration with minimal
    setup | Can be complex or simple, depending on VS Code APIs used |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 复杂性 | 需要更多的开发工作来管理整个用户交互流程的响应和响应生成 | 设计用于易于集成，设置最少 | 可以是复杂或简单，具体取决于使用的VS
    Code API |'
- en: '| Control | Provides full control over how requests are processed and how responses
    are generated | Limited control over the user interaction, focus is on data retrieval
    and basic actions | Most control as written for VS Code only |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 控制 | 提供对请求处理方式和响应生成的完全控制 | 对用户交互的控制有限，重点在于数据检索和基本操作 | 对于VS Code来说，控制力最强 |'
- en: '| Use cases | Suitable for complex scenarios where you need to implement custom
    logic, integrate with other AI models, and manage conversation context | Straightforward
    tasks like fetching data from an external API or performing simple operations
    | Tasks for working with code in the IDE and, optionally, providing additional
    commands for the participant |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 用例 | 适用于需要实现自定义逻辑、与其他AI模型集成和管理对话上下文的复杂场景 | 简单任务，如从外部API获取数据或执行简单操作 | 用于在IDE中处理代码的任务，以及可选地为参与者提供额外的命令
    |'
- en: '| Interfaces available | All (GitHub, IDEs) | All (GitHub, IDEs) | Limited
    to VS Code to get full advantage of all VS Code APIs |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 可用的接口 | 所有（GitHub，IDEs） | 所有（GitHub，IDEs） | 仅限于VS Code以充分利用所有VS Code API
    |'
- en: '| Support | GitHub | GitHub | VS Code Team   |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 支持 | GitHub | GitHub | VS Code团队 |'
- en: Ultimately, what the user sees when we add a VS Code extension for Copilot is
    a new chat participant.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，当我们为Copilot添加VS Code扩展时，用户看到的是一个新的聊天参与者。
- en: A *chat participant* is a domain expert that can answer questions about a specific
    topic, or perform specific tasks, when you are working with Copilot Chat in an
    IDE. We’ve discussed these before in the context of participants that come built-in
    with Copilot (see [Chapter 3](ch03.html#ch03)). For example, the built-in `@workspace`
    participant can respond relative to your entire VS Code workspace. To do this,
    it uses integrated tools such as semantic search and code indexes. Other examples
    we’ve discussed include `@termi⁠nal` and `@vscode`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用IDE中的Copilot Chat工作时，*聊天参与者*是一个特定领域的专家，可以回答关于特定主题的问题，或执行特定任务。我们之前已经讨论过这些内容，是在Copilot内置的参与者上下文中（参见[第3章](ch03.html#ch03)）。例如，内置的`@workspace`参与者可以相对于你的整个VS
    Code工作区进行响应。为此，它使用集成工具，如语义搜索和代码索引。我们之前讨论的其他例子包括`@termi⁠nal`和`@vscode`。
- en: 'Chat participants are invoked using the same `@identifier` syntax as for other
    extensions. Once a participant is invoked and passed a prompt, the code for the
    participant can use one of several approaches to handle the prompt. These include
    the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的 `@identifier` 语法调用聊天参与者，这与其他扩展的语法相同。一旦参与者被调用并传递了一个提示，参与者的代码可以使用几种方法来处理这个提示。这些方法包括以下几种：
- en: Calling an AI model to interpret and respond
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个AI模型来解释并响应
- en: Forwarding the request to a backend service
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求转发到后端服务
- en: Using built-in logic and/or APIs to do the processing
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置逻辑和/或API进行处理
- en: Because of the underlying tight integration with VS Code, chat participants
    can return responses that include interactive elements like buttons, file trees,
    or progress updates. The chat participants can also provide follow-up suggestions
    and their own slash commands (as in previous examples, such as `/explain` and
    `/fix`) that are related to the participant’s domain.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与 VS Code 的底层紧密集成，聊天参与者可以返回包含交互元素（如按钮、文件树或进度更新）的响应。聊天参与者还可以提供与参与者领域相关的后续建议和自己的斜杠命令（如先前的示例中的
    `/explain` 和 `/fix`）。
- en: In short, VS Code extensions for Copilot can provide rich *client-side* experiences.
    These extensions have access to the VS Code client context and interfaces on the
    frontend, while utilizing the power of Copilot on the backend.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，VS Code 的 Copilot 扩展可以提供丰富的 *客户端* 体验。这些扩展可以访问 VS Code 的客户端上下文和前端接口，同时利用后端
    Copilot 的功能。
- en: Chat Participants in Other IDEs
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他 IDE 中的聊天参与者
- en: While we are focusing on VS Code in this chapter, chat participants are available
    in other IDEs as well. Likewise, depending on the capabilities of the underlying
    IDE platform, VS Code extensions for Copilot could be ported to other IDEs where
    Copilot also runs.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们本章专注于 VS Code，但聊天参与者也适用于其他 IDE。同样，根据底层 IDE 平台的功能，Copilot 的 VS Code 扩展也可以移植到
    Copilot 也运行的其他 IDE 中。
- en: The implementation example we’ll use for this extension is an *API finder*.
    This extension, when installed in VS Code, allows the user to search for APIs
    that perform a certain function and stream back information in the chat interface
    on the APIs and how to use them.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个扩展使用的一个实现示例是 *API 查找器*。当这个扩展安装到 VS Code 中时，它允许用户搜索执行特定功能的 API，并在聊天界面上流回关于这些
    API 及其使用方法的详细信息。
- en: '[Figure 10-27](#overview-vscode-extension) shows at a high level how a VS Code
    extension for Copilot works. I’ll have more to say about the individual pieces
    in the following sections.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-27](#overview-vscode-extension) 从高层次展示了 Copilot 的 VS Code 扩展是如何工作的。我将在接下来的部分中详细介绍各个部分。'
- en: '![](assets/lghc_1027.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_1027.png)'
- en: Figure 10-27\. Overview of a VS Code extension
  id: totrans-261
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-27\. VS Code 扩展概述
- en: '[Figure 10-28](#using-the-apifinder-c) shows an example of using the extension’s
    user-facing functionality to find suitable APIs.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-28](#using-the-apifinder-c) 展示了使用扩展的用户界面功能来查找合适的 API 的示例。'
- en: '![](assets/lghc_1028.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_1028.png)'
- en: Figure 10-28\. Using the API Finder chat participant to find weather APIs
  id: totrans-264
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-28\. 使用 API 查找器聊天参与者查找天气 API
- en: This extension also has an additional command built-in that can be invoked as
    `/⁠exam⁠ples`. [Figure 10-29](#using-the-command-fro) shows an example usage of
    the command.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展还内置了一个额外的命令，可以调用为 `/⁠exam⁠ples`。[图 10-29](#using-the-command-fro) 展示了该命令的一个示例用法。
- en: '![](assets/lghc_1029.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lghc_1029.png)'
- en: Figure 10-29\. Using the command from our chat participant
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-29\. 使用聊天参与者中的命令
- en: The code for the extension is located in [the book’s GitHub repository](https://oreil.ly/RUAtr).
    This one is implemented in TypeScript, with the main logic in the file [*src/extension.ts*](https://oreil.ly/VSPMM).
    This is based on the [example](https://oreil.ly/uRBxt) in the VS Code extension
    examples in GitHub.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的代码位于 [本书的 GitHub 仓库](https://oreil.ly/RUAtr) 中。这个扩展是用 TypeScript 实现的，主要逻辑在文件
    [*src/extension.ts*](https://oreil.ly/VSPMM) 中。这是基于 GitHub 中 VS Code 扩展示例中的 [示例](https://oreil.ly/uRBxt)。
- en: 'The code starts off by importing dependencies from VS Code’s libraries. Then
    it defines the prompt to send to the model for the base functionality and the
    one to send for the code font command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先从 VS Code 的库中导入依赖项。然后它定义了用于基本功能的模型发送提示和用于代码字体命令的提示：
- en: '[PRE11]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that we are being explicit about how we want the LLM to process our query
    by supplying detailed prompts to use.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过提供详细的提示来明确我们希望 LLM 如何处理我们的查询。
- en: Specifying the Language for /examples
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 /examples 指定语言
- en: In the previous example shown in [Figure 10-29](#using-the-command-fro), we
    specified the language `Go` as a second argument on the prompt to `@apifinder
    /⁠examples`. However, our prompt does not explicitly reference the programming
    language. This is a benefit of using the AI to handle the request. It infers additional
    context and meaning that we don’t have to explicitly call out.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 10-29](#using-the-command-fro) 中展示的先前示例中，我们在 `@apifinder /⁠examples` 的提示中将
    `Go` 语言指定为第二个参数。然而，我们的提示并没有明确引用编程语言。这是使用 AI 处理请求的好处。它推断出额外的上下文和意义，我们不必明确指出。
- en: 'Code at the bottom of the file instantiates the chat handler and adds an icon
    to it for use in chat:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 文件底部的代码实例化了聊天处理程序，并为其添加了一个用于聊天的图标：
- en: '[PRE12]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The main processing function selects the prompt (based on whether we want the
    core functionality or are using the `examples` command). It then combines the
    prompt and any previous messages, sends that to the model, and streams the response:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 主要处理函数选择提示（基于我们是否想要核心功能或正在使用 `examples` 命令）。然后它将提示和任何之前的消息结合起来，将其发送到模型，并流式传输响应：
- en: '[PRE13]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Testing this extension is as simple as opening the folder in VS Code, installing
    the dependencies with `npm install`, compiling the code via `npm run compile`,
    and then running the extension in a new VS Code instance.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这个扩展就像在 VS Code 中打开文件夹，使用 `npm install` 安装依赖项，通过 `npm run compile` 编译代码，然后在新的
    VS Code 实例中运行扩展一样简单。
- en: Running a Participant with the Debugger
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调试器运行参与者
- en: Probably the simplest way to test your participant code is to load it into a
    VS Code instance, run the `npm` commands, and then use the Start Debugging option
    from the Run menu to spin up a new instance of VS Code. The new debug instance
    will have the participant installed and active, so you can use it in that instance’s
    chat interface. Instructions can be found in the repository’s [README file](https://oreil.ly/QXsC_).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的参与者代码可能最简单的方法是将它加载到 VS Code 实例中，运行 `npm` 命令，然后从运行菜单中选择“开始调试”选项来启动一个新的 VS
    Code 实例。新的调试实例将安装并激活参与者，因此你可以在该实例的聊天界面中使用它。说明可以在存储库的 [README 文件](https://oreil.ly/QXsC_)
    中找到。
- en: As with the other types of extensions, you would want to make additional changes
    before rolling this out to production, such as ensuring that authentication works
    as needed. The [VS Code documentation](https://oreil.ly/UH18y) describes implementation
    in much more detail. You can also find information on publishing your finished
    extension to the [VS Code Marketplace](https://oreil.ly/HGZkA).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型的扩展一样，在将其推出到生产之前，你可能想要进行一些额外的更改，例如确保身份验证按需工作。[VS Code 文档](https://oreil.ly/UH18y)
    详细描述了实现方法。你还可以在 [VS Code 市场place](https://oreil.ly/HGZkA) 上找到有关发布你的完成扩展的信息。
- en: Conclusion
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: GitHub Copilot extensions and VS Code extensions for Copilot provide a way to
    augment the built-in capabilities of GitHub Copilot. These extensions are accessed
    via the Copilot Chat interface and the `@` prefix.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Copilot 扩展和 VS Code 的 Copilot 扩展提供了一种增强 GitHub Copilot 内置功能的方法。这些扩展通过
    Copilot 聊天界面和 `@` 前缀访问。
- en: The backend code for Copilot extensions can be architected in one of two ways.
    Agents are the most flexible option but also the most complex in general to implement.
    Extensions that use the skillsets architecture call one or more skills on the
    backend to get additional information. A skill can be as simple as an API call.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 扩展的后端代码可以以两种方式之一进行架构。代理是最灵活的选项，但通常也是实现起来最复杂的。使用技能集架构的扩展在后台调用一个或多个技能以获取更多信息。一个技能可能只是一个
    API 调用。
- en: VS Code extensions for Copilot are architected on top of VS Code’s platform.
    They have full access to the underlying VS Code APIs and rely on VS Code to function.
    From a user-facing perspective, they provide VS Code chat participants, similar
    to the built-in ones like `@workspace` and `@terminal`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 的 Copilot 扩展是在 VS Code 的平台上构建的。它们可以完全访问底层的 VS Code API，并且依赖于 VS Code
    来运行。从用户界面的角度来看，它们提供了类似于内置的 `@workspace` 和 `@terminal` 的 VS Code 聊天参与者。
- en: The backend code for extensions can be implemented in several languages, including
    JavaScript, TypeScript, and Go. For extensions using the agent approach and JavaScript,
    GitHub has provided an early version of an SDK that can be used to simplify coding
    and help fill in production needs like authentication.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的后端代码可以用多种语言实现，包括 JavaScript、TypeScript 和 Go。对于使用代理方法的扩展和 JavaScript，GitHub
    提供了一个早期版本的 SDK，可用于简化编码并帮助满足生产需求，如身份验证。
- en: Copilot extensions (implemented as either agents or skillsets) require a GitHub
    App to bridge the connection between the Copilot chat interface and the backend
    code. While both use GitHub Apps, the configuration for each is different. Agents
    rely on a single callback URL defined in the app. Apps for skillsets require additional
    inference details in their configuration so that the AI can map the prompt to
    the correct skill API endpoint.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 扩展（作为代理或技能集实现）需要一个 GitHub App 来在 Copilot 聊天界面和后端代码之间建立连接。虽然两者都使用 GitHub
    Apps，但每个的配置都不同。代理依赖于在应用中定义的单个回调 URL。技能集的应用需要在其配置中提供额外的推理细节，以便 AI 能够将提示映射到正确的技能
    API 端点。
- en: Since Copilot extensions utilize a GitHub App, they can run in any Copilot chat
    interface, including in an IDE or on GitHub. In contrast, since VS Code extensions
    for Copilot rely on VS Code APIs and functions, they can only be used in that
    environment.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Copilot 扩展利用 GitHub App，它们可以在任何 Copilot 聊天界面中运行，包括在 IDE 或 GitHub 上。相比之下，由于
    Copilot 的 VS Code 扩展依赖于 VS Code API 和功能，它们只能在那个环境中使用。
