- en: Chapter 12\. Deployment of AI Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章\. 人工智能服务的部署
- en: In this final chapter, it is time to complete your GenAI solution by deploying
    it. You’re going to learn several deployment strategies and, as part of deployment,
    containerize your services with Docker following its best practices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，是时候通过部署来完善你的通用人工智能解决方案了。你将学习几种部署策略，作为部署的一部分，你将使用Docker的最佳实践将你的服务容器化。
- en: Deployment Options
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署选项
- en: 'You now have a working GenAI service that you want to make accessible to your
    users. What are your deployment options? There are a few common deployment strategies
    you can adapt to make your apps accessible to users:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有一个可以供用户使用的通用人工智能服务。你的部署选项有哪些？你可以采用几种常见的部署策略来使你的应用程序对用户可用：
- en: Virtual machines (VMs)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机（VM）
- en: Serverless functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器函数
- en: Managed application platforms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理应用程序平台
- en: Containerization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化
- en: Let’s explore each in more detail.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨每个选项。
- en: Deploying to Virtual Machines
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署到虚拟机
- en: If you plan to use your own on-premises servers or prefer to deploy your services
    on the same hardware hosting your other applications for high isolation and security,
    you can deploy your GenAI service to a VM.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划使用自己的本地服务器或更倾向于在承载其他应用程序的相同硬件上部署你的服务以实现高隔离和安全，你可以将你的通用人工智能服务部署到虚拟机上。
- en: A VM is a software emulation of a physical computer running an operating system
    (OS) and applications. It’s no different from a physical computer like a laptop,
    smartphone, or server.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机是运行操作系统和应用程序的物理计算机的软件模拟。它与笔记本电脑、智能手机或服务器等物理计算机没有区别。
- en: The VM’s *host* system provides resources such as CPU, memory, and storage,
    while a software layer called the *hypervisor* manages the VM and allocates resources
    from the host to the VM. The resources that the hypervisor allocates to the VM
    is the *virtual hardware* that its OS and applications run on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机的**宿主**系统提供资源，例如CPU、内存和存储，而一个名为**虚拟机管理程序**的软件层则管理虚拟机并从宿主系统分配资源给虚拟机。虚拟机管理程序分配给虚拟机的资源是其在上运行的**虚拟硬件**。
- en: The VM could run directly on host’s hardware (bare metal) or on a conventional
    operating system (i.e., be hosted). As a result, the OS installed within the VM
    is then referred to as the *guest OS*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机可以直接在宿主硬件（裸机）上运行，或者在一个传统的操作系统（即，托管）上运行。因此，安装在虚拟机内的操作系统被称为**客户操作系统**。
- en: '[Figure 12-1](#deployment_vm_architecture) shows the virtualization technology
    system architecture.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-1](#deployment_vm_architecture)展示了虚拟化技术系统架构。'
- en: '![bgai 1201](assets/bgai_1201.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 1201](assets/bgai_1201.png)'
- en: Figure 12-1\. Virtualization system architecture
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-1\. 虚拟化系统架构
- en: Cloud providers or your own data center can consist of several physical servers,
    each hosting multiple VMs with their own guest OS and hosted applications. For
    cost-effective resource sharing, these VMs may share the same mounted physical
    storage drive even though they’re contained within fully isolated environments,
    as you can see in [Figure 12-2](#deployment_vm_data_center).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商或你自己的数据中心可以由多个物理服务器组成，每个服务器托管多个虚拟机，每个虚拟机都有自己的客户操作系统和托管应用程序。为了实现成本效益的资源共享，尽管这些虚拟机在完全隔离的环境中运行，但它们可能共享相同的挂载物理存储驱动器，如图[图12-2](#deployment_vm_data_center)所示。
- en: '![bgai 1202](assets/bgai_1202.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 1202](assets/bgai_1202.png)'
- en: Figure 12-2\. Hosted VMs in a data center
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-2\. 数据中心中的托管虚拟机
- en: The benefit of using a VM is that you have direct access to the guest OS, virtual
    hardware resources, and GPU drivers. If there are any issues with deployment,
    you can connect to the VM via the *Secure Shell Transfer* (SHH) protocol to inspect
    application logs, set up application environment, and debug production issues.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟机的优点是你可以直接访问客户操作系统、虚拟硬件资源和GPU驱动程序。如果部署过程中有任何问题，你可以通过**安全外壳传输**（SSH）协议连接到虚拟机，检查应用程序日志、设置应用程序环境以及调试生产问题。
- en: Deploying your services to VMs will be as straightforward as cloning your code
    repository to the VM and then installing the required dependencies, packages,
    and drivers to successfully start up your application. However, the recommended
    way to do this is to use a containerization platform such as Docker running on
    the VM to enable continuous deployments and other benefits. You should also ensure
    you size your VM resources appropriately so that your services aren’t starved
    for CPU/GPU cores, memory, or disk storage.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的服务部署到虚拟机将像将你的代码仓库克隆到虚拟机中，然后安装所需的依赖项、软件包和驱动程序以成功启动你的应用程序一样简单。然而，推荐的做方法是使用在虚拟机上运行的容器化平台，如Docker，以实现持续部署和其他好处。你还应该确保适当地调整虚拟机资源的大小，以确保你的服务不会因为CPU/GPU核心、内存或磁盘存储而资源不足。
- en: With on-premises VMs, you can save on-cloud hosting or server rental costs and
    can fully secure your application environments to a handful of users, isolated
    from the public internet. These benefits are also achievable with cloud VMs but
    require additional networking and resource configuration to set up. In addition,
    you can have access to GPU hardware and configure drivers for your application
    requirements.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地虚拟机，你可以节省云托管或服务器租赁成本，并且可以完全保护你的应用环境，使其对少数用户安全，并从公共互联网中隔离。这些好处也可以通过云虚拟机实现，但需要额外的网络和资源配置来设置。此外，你可以访问GPU硬件，并为你的应用需求配置驱动程序。
- en: Bear in mind that using the VM deployment pattern may not be easily scalable
    and requires significant effort to maintain. Additionally, VM servers normally
    run 24/7 incurring constant running costs, unless you automate their startup and
    shutdown based on your needs. You’ll be responsible for applying security patches,
    OS updates, and package upgrades alongside any networking configurations. With
    direct access to hardware resources, you’ll also have more decisions to make that
    can slow you down, leading to decision fatigue.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用虚拟机部署模式可能不太容易扩展，并且需要大量的维护工作。此外，虚拟机服务器通常全天候运行，产生持续的运行成本，除非你根据需要自动化它们的启动和关闭。你将负责应用安全补丁、操作系统更新和软件包升级，以及任何网络配置。由于直接访问硬件资源，你将需要做出更多决策，这可能会减慢你的速度，导致决策疲劳。
- en: My advice is to deploy to a VM if you don’t plan to scale your services anytime
    soon or need to maintain low server costs and a secure isolated application environment
    for a handful of users. In addition, make sure you’ve planned sufficient time
    for deployment, networking, and configuration of your VMs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是，如果你不久内不打算扩展你的服务，或者需要为少数用户维护低服务器成本和安全的隔离应用环境，那么请部署到虚拟机（VM）。此外，确保你已经为部署、网络和虚拟机的配置预留了足够的时间。
- en: Deploying to Serverless Functions
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署到无服务器函数
- en: Aside from VMs, you can also deploy your services on cloud functions that cloud
    providers supply as *serverless* systems. In serverless computing, your code is
    executed in response to events such as database changes, updates to blobs in a
    storage, HTTP requests, or messages added to a queue. This means you pay only
    for the requests or compute resources your services use, rather than for an entire
    server as with a continuously running VM.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了虚拟机之外，你还可以将你的服务部署到云提供商提供的作为*无服务器*系统的云函数上。在无服务器计算中，你的代码会在响应事件时执行，例如数据库更改、存储中blob的更新、HTTP请求或队列中添加的消息。这意味着你只需为你的服务使用的请求或计算资源付费，而不是像持续运行的虚拟机那样为整个服务器付费。
- en: 'Serverless deployments are often useful when:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下情况发生时，无服务器部署通常很有用：
- en: You want to have event-driven systems instead of a running VM, which might be
    on 24/7
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望拥有事件驱动的系统，而不是24/7运行的虚拟机
- en: You want to deploy your API services using a serverless architecture that’s
    highly cost-efficient
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望使用高度成本效益的无服务器架构来部署你的API服务
- en: Your services are to perform batch processing jobs
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的服务需要执行批量处理作业
- en: You need workflow automation
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要工作流程自动化
- en: The term *serverless* doesn’t mean that cloud functions don’t require hardware
    resources to execute but rather that the management of these resources is handled
    by the cloud provider. This allows you to focus on writing application code without
    worrying about server and OS-level details.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*无服务器*并不意味着云函数不需要硬件资源来执行，而是意味着这些资源的管理由云提供商处理。这允许你专注于编写应用程序代码，而无需担心服务器和操作系统级别的细节。
- en: Cloud providers instantiate compute resources to meet the demand of their customers.
    Often, there is a surge in demand, requiring them to create additional resources
    in advance to handle the demand spike. However, once the demand drops, excess
    unallocated compute resources remain that must be either shut down or shared among
    other customers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商实例化计算资源以满足其客户的需求。通常，需求会激增，需要他们提前创建额外的资源来处理需求峰值。然而，一旦需求下降，多余的未分配计算资源仍然存在，必须关闭或与其他客户共享。
- en: Removing and creating resources is an intensive compute operation to perform.
    At scale, these operations carry significant costs for cloud providers. Therefore,
    cloud providers prefer to keep these resources running as much as possible and
    distribute them among existing customers to maximize billing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 移除和创建资源是一项密集的计算操作。在规模上，这些操作对云服务提供商来说成本很高。因此，云服务提供商更喜欢尽可能多地保持这些资源运行，并将它们分配给现有客户以最大化计费。
- en: To encourage customers to use these excess compute, they’ve built cloud function
    services that you can leverage to run your backend services on excess (i.e., serverless)
    compute. Luckily, there are packages such as Magnum that allow you to package
    FastAPI services on AWS cloud functions. You will soon see that FastAPI services
    can also be deployed as Azure cloud functions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了鼓励客户使用这些多余的计算资源，他们构建了云函数服务，您可以利用这些服务在多余的（即无服务器）计算上运行您的后端服务。幸运的是，有像Magnum这样的包允许您将FastAPI服务打包到AWS云函数上。您很快就会看到FastAPI服务也可以作为Azure云函数部署。
- en: What you need to bear in mind is that these functions are allocated only a small
    amount of resources and have a short timeout. However, you can request longer
    timeouts and compute resources to be allocated, but it may take longer to receive
    these allocations, leading to higher latencies for your users.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要记住的是，这些函数仅分配了少量资源，并且有较短的超时时间。然而，您可以请求更长的超时时间和分配更多的计算资源，但这可能需要更长的时间才能收到这些分配，从而导致用户的高延迟。
- en: Warning
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If your business logic consumes a lot of resources or requires longer than a
    handful of minutes to execute, cloud functions may not be a suitable deployment
    option for you.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的业务逻辑消耗大量资源或需要超过几分钟的时间来执行，云函数可能不是您合适的部署选项。
- en: However, you can split your FastAPI services across multiple functions, with
    each function handling a single exposed endpoint. This way, you can deploy parts
    of your service as cloud functions, reducing the portion of the FastAPI service
    that needs to be deployed using other methods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以将FastAPI服务拆分到多个函数中，每个函数处理一个公开端点。这样，您可以将服务的一部分作为云函数部署，减少需要使用其他方法部署的FastAPI服务的部分。
- en: The main advantage of using serverless functions for deploying your services
    is their scalability. You can scale your applications as needed and pay only a
    fraction of the cost compared to reserving dedicated VM resources. Cloud providers
    typically charge based on the number of function executions and runtime, often
    with generous monthly quotas. This means that if your functions run quickly and
    you have a moderate number of concurrent users, you might be able to host all
    your services for free.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无服务器函数部署您的服务的主要优势是其可伸缩性。您可以根据需要扩展应用程序，并且只需支付与预留专用虚拟机资源相比的一小部分费用。云服务提供商通常根据函数执行次数和运行时收费，通常有慷慨的月度配额。这意味着如果您的函数运行得快，并且您有适度的并发用户数量，您可能能够免费托管所有服务。
- en: Furthermore, cloud providers also supply function runtimes that you can install
    locally for local testing and development so that you can significantly shorten
    development iterations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，云服务提供商还提供可以在本地安装以进行本地测试和开发的函数运行时，这样您可以显著缩短开发迭代周期。
- en: Each cloud provider has their own approach to deploying serverless functions.
    Often, you require an entry script such as *main.py* that can import dependencies
    from other modules as needed. Alongside the entry point script, you’ll need to
    upload a function host JSON configuration file alongside *requirements.txt* for
    required dependencies to be installed on deployment on a Python runtime.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个云服务提供商都有自己部署无服务器函数的方法。通常，您需要一个入口脚本，如*main.py*，它可以按需从其他模块导入依赖项。除了入口点脚本外，您还需要上传一个函数宿主JSON配置文件，以及*requirements.txt*文件，以便在部署到Python运行时安装所需的依赖项。
- en: You can then deploy functions by uploading all the required files as a zipped
    directory or using CI/CD pipelines that authenticate with the provider and execute
    the deployment commands within your cloud project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过上传所有必需文件作为压缩目录或使用与提供者进行身份验证的 CI/CD 管道来部署函数，这些管道在云项目中执行部署命令。
- en: 'As an example, let’s try to deploy a bare-bones FastAPI app that returns LLM
    responses. The structure of the project will be as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们尝试部署一个返回 LLM 响应的裸骨 FastAPI 应用程序。项目的结构将如下所示：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can then package a FastAPI app as an [Azure serverless function](https://oreil.ly/ZaOuF)
    by following the upcoming code examples.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以按照即将提供的代码示例将 FastAPI 应用打包为 [Azure 无服务器函数](https://oreil.ly/ZaOuF)。
- en: 'You will need to install the `azure-functions` package to run Azure’s serverless
    function runtime for local development and testing:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装 `azure-functions` 包来运行 Azure 的无服务器函数运行时进行本地开发和测试：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, create *host.json* by following [Example 12-1](#deployment_function_azure_host).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照[示例 12-1](#deployment_function_azure_host)的说明创建 *host.json*。
- en: Example 12-1\. Azure Functions host configurations (host.json)
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-1\. Azure Functions 主机配置（host.json）
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Afterward, implement your GenAI service with the FastAPI service as usual by
    following [Example 12-2](#deployment_function_azure_app).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，按照[示例 12-2](#deployment_function_azure_app)的说明，像往常一样使用 FastAPI 服务实现你的 GenAI
    服务。
- en: Example 12-2\. Simple FastAPI application serving LLM responses
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-2\. 简单的 FastAPI 应用程序，提供 LLM 响应
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, wrap your FastAPI `app` within `func.AsgiFunctionApp` for the Azure
    serverless function runtime to hook into it, as shown in [Example 12-3](#deployment_function_azure_function).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将你的 FastAPI `app` 包裹在 `func.AsgiFunctionApp` 中，以便 Azure 无服务器函数运行时可以连接到它，如[示例
    12-3](#deployment_function_azure_function)所示。
- en: Example 12-3\. Deploying a FastAPI service with Azure Functions
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-3\. 使用 Azure Functions 部署 FastAPI 服务
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can then start the function app by running the `func start` command, which
    should be available as a CLI command once you install the `azure-functions` package:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过运行 `func start` 命令来启动函数应用，该命令在安装了 `azure-functions` 包后应作为 CLI 命令可用：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can then try URLs corresponding to the handlers in the app by sending HTTP
    requests to both simple and the parameterized paths:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过向简单路径和参数化路径发送 HTTP 请求来尝试与应用程序中的处理程序对应的 URL：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once ready, you can then deploy your FastAPI wrapped serverless function to
    the Azure cloud and then run the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备就绪，你可以将包装好的 FastAPI 无服务器函数部署到 Azure 云，然后运行以下命令：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `publish` command will then publish the project files from the project directory
    to `<FunctionAppName>` as a ZIP deployment package.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish` 命令将随后将项目目录中的项目文件发布到 `<FunctionAppName>`，作为 ZIP 部署包。'
- en: 'After deployment, you can then test different paths on the deployed URL:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后，你可以测试部署 URL 上的不同路径：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Warning
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Your chosen cloud provider may not support serving a FastAPI server within its
    function runtime. If that’s the case, you may want to seek alternative deployment
    options. Otherwise, you’ll need to migrate the logic of your endpoints to the
    supported web framework of the function runtime and create separate functions
    for each endpoint.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的云提供商可能不支持在其函数运行时内提供 FastAPI 服务器。如果是这种情况，你可能需要寻找替代的部署选项。否则，你需要将端点的逻辑迁移到函数运行时支持的
    Web 框架，并为每个端点创建单独的函数。
- en: As you see, deploying your FastAPI service as cloud functions is straightforward
    and allows you to delegate the management and scaling of your services to cloud
    providers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，将你的 FastAPI 服务作为云函数部署非常简单，这允许你将服务的管理和扩展委托给云提供商。
- en: Bear in mind that if you decide to serve a GenAI model in your service, cloud
    functions wouldn’t be suitable deployment targets due to their short timeout periods
    (10 minutes). Instead, you’d want to use a model provider API in your services
    so that you have reliable and scalable access to the model without being constrained
    by execution time limits.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你决定在你的服务中提供 GenAI 模型，由于它们的超时时间短（10 分钟），云函数不适合作为部署目标。相反，你希望在服务中使用模型提供者
    API，以便你有可靠且可扩展的模型访问，而不受执行时间限制的约束。
- en: Deploying to Managed App Platforms
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署到托管应用平台
- en: In addition to cloud functions or VMs, you can upload your codebase as ZIP files
    to app platforms managed by cloud providers. Managed app platforms let you delegate
    several tasks related to maintenance and management of your services to the cloud
    provider. In exchange, you pay only for the compute resources managed by the cloud
    provider that serve your application. The cloud provider systems allocate and
    optimize resources based on your application’s needs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了云函数或虚拟机之外，您还可以将代码库作为 ZIP 文件上传到云提供商管理的应用平台。托管应用平台允许您将与服务维护和管理相关的多项任务委托给云提供商。作为交换，您只需为云提供商管理的、为您的应用程序提供服务的计算资源付费。云提供商系统根据您的应用程序需求分配和优化资源。
- en: Examples of such services include Azure App Services, AWS Elastic Beanstalk,
    Google App Engine, or Digital Ocean app platform.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种服务的例子包括 Azure App Services、AWS Elastic Beanstalk、Google App Engine 或 Digital
    Ocean 应用平台。
- en: Third-party platforms such as Heroku, Hugging Face Spaces, railway.app, render.com,
    or fly.io also exist for deploying your services directly from code in repositories,
    which abstract away certain decisions from you so that you can deploy faster and
    easier. Under the hood, third-party managed app platforms may be using the infrastructure
    of main cloud providers like Azure, Google, or AWS.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在第三方平台，如 Heroku、Hugging Face Spaces、railway.app、render.com 或 fly.io，可以直接从代码库中部署您的服务，这些平台从您那里抽象出某些决策，以便您能够更快、更轻松地部署。在底层，第三方托管应用平台可能会使用
    Azure、Google 或 AWS 等主要云提供商的基础设施。
- en: The main benefit of deploying to managed app platforms is the ease and speed
    of deployment, networking, scaling, and maintaining your services. Such platforms
    provide you with tools you need to secure, monitor, scale, and manage your services
    without having to worry about the underlying resource allocations, security, or
    software updates. They can let you configure load balancers, SSL certificates,
    domain mappings, monitoring, and staging environments so that you can focus more
    on application development than deployment workload of the project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务部署到托管应用平台的主要好处是部署、网络、扩展和维护服务的简便性和速度。这些平台为您提供所需的工具，以便在不担心底层资源分配、安全或软件更新的情况下，安全、监控、扩展和管理您的服务。它们可以让您配置负载均衡器、SSL
    证书、域名映射、监控和预发布环境，这样您就可以更多地关注应用程序开发而不是项目的部署工作量。
- en: Because these platforms follow the platform-as-a-service (PaaS) payment model,
    you’ll be billed a higher rate compared to relying on your own infrastructure
    or using lower-level resources such as bare-bone VMs or serverless compute options.
    Alternative services may use the infrastructure-as-a-service (IaaS) payment model
    that often is more cost-effective.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些平台遵循平台即服务（PaaS）的计费模式，您将比依赖自己的基础设施或使用底层资源（如裸机虚拟机或无服务器计算选项）支付更高的费用。替代服务可能使用基础设施即服务（IaaS）的计费模式，通常更具成本效益。
- en: Personally, I find managed app platforms a convenient way to deploy my applications
    without much hassle. If I’m working on a prototype and need to get my services
    available to users as fast as possible, managed app platforms is my first go-to
    option. Although, bear in mind that if you need access to GPU hardware for running
    inference services, you’ll have to rely on dedicated VMs, on-premises servers,
    or specialized AI platform services to serve your models. The app platforms can
    only provide CPU, memory, and disk storage for serving backend services or frontend
    applications.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我发现托管应用平台是一种方便的方式，可以轻松部署我的应用程序而无需太多麻烦。如果我在制作原型并且需要尽可能快地将我的服务提供给用户，托管应用平台是我的首选选项。尽管如此，请记住，如果您需要访问
    GPU 硬件来运行推理服务，您将不得不依赖专用虚拟机、本地服务器或专门的 AI 平台服务来托管您的模型。应用平台只能提供 CPU、内存和磁盘存储来托管后端服务或前端应用程序。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: A handful of managed cloud provider AI platforms include Azure Machine Learning
    Studio or Azure AI, Google Cloud Vertex AI Platform, AWS Bedrock and SageMaker,
    or IBM Watson Studio.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一些托管云提供商的 AI 平台包括 Azure Machine Learning Studio 或 Azure AI、Google Cloud Vertex
    AI 平台、AWS Bedrock 和 SageMaker 或 IBM Watson Studio。
- en: There are also third-party platforms for hosting your models including Hugging
    Face Inference Endpoints, Weights & Biases Platform, or Replicate.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三方平台可以托管您的模型，包括 Hugging Face Inference Endpoints、Weights & Biases 平台或 Replicate。
- en: Deploying from code repositories will often require you to add certain configuration
    files to the root of your project depending on which app platform you will be
    deploying to. The process also depends on whether the app platform supports the
    application runtime, libraries, and framework versions you’re using, so a successful
    deployment isn’t always guaranteed. It’s also often challenging to migrate to
    supported runtimes or versions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码仓库进行部署通常需要您根据您将要部署到的应用程序平台，在项目的根目录中添加某些配置文件。此过程还取决于应用程序平台是否支持您使用的应用程序运行时、库和框架版本，因此成功的部署并不总是有保证。迁移到支持的运行时或版本通常也具有挑战性。
- en: Due to these unforeseen issues, many engineers are switching to containerization
    technologies such as Docker or Podman to package up and deploy their services.
    These containerized applications can then be deployed directly to any app platform
    supporting containers with guarantees that the application will run no matter
    what the underlying resources, runtime, or dependency versions are.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些不可预见的问题，许多工程师正在转向容器化技术，如Docker或Podman，以打包和部署他们的服务。这些容器化应用程序可以直接部署到支持容器的任何应用程序平台，并保证无论底层资源、运行时或依赖项版本如何，应用程序都将运行。
- en: Deploying services with containers is now one of the most reliable strategies
    for shipping your applications to production for users to access.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器部署服务现在是将您的应用程序部署到生产环境以供用户访问的最可靠策略之一。
- en: Deploying with Containers
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用容器进行部署
- en: A *container* is a loosely isolated environment designed for building and running
    applications. Containers can run your services quickly and reliably in any computing
    environment by packaging your code with all the required dependencies.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*容器*是一个松散隔离的环境，用于构建和运行应用程序。容器可以通过将您的代码及其所有必需的依赖项打包，在任意计算环境中快速且可靠地运行您的服务。'
- en: Under the hood, containers rely on an OS-virtualization method that enables
    them to run on physical hardware, in the cloud, on VMs, or across multiple operating
    systems.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，容器依赖于一种操作系统虚拟化方法，使它们能够在物理硬件、云中、虚拟机上或跨多个操作系统上运行。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Similar to managed app platforms and serverless functions, you can configure
    containers to automatically restart and self-heal, if your application exits for
    any reason.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与托管应用程序平台和无服务器函数类似，您可以配置容器在应用程序由于任何原因退出时自动重启和自我修复。
- en: Unlike VMs whose underlying technologies rely on virtualization, containers
    rely on containerization.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与依赖于虚拟化的底层技术的虚拟机不同，容器依赖于容器化。
- en: Containerization packages applications and their dependencies into lightweight,
    isolated units that share the host OS kernel. On the other hand, virtualization
    enables running multiple operating systems on a single physical machine using
    hypervisors. Therefore, unlike virtual machines, containers don’t virtualize hardware
    resources. Instead, they run on top of a container runtime platform that abstracts
    the resources, making them lightweight (i.e., as low as a few megabytes to store)
    and faster than VMs since they don’t require a separate OS per container.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化将应用程序及其依赖项打包成轻量级、隔离的单位，这些单位共享宿主操作系统的内核。另一方面，虚拟化通过使用虚拟机管理程序在单个物理机上运行多个操作系统。因此，与虚拟机不同，容器不虚拟化硬件资源。相反，它们在容器运行时平台之上运行，该平台抽象化了资源，使它们轻量级（即，存储量低至几兆字节）并且比虚拟机更快，因为它们不需要每个容器都运行一个单独的操作系统。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In essence, virtualization is about abstracting hardware resources on the host
    machine while containerization is about abstracting the operating system kernel
    and running all application components inside an isolated unit called a *container*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，虚拟化是关于在宿主机器上抽象硬件资源，而容器化是关于抽象操作系统内核，并在称为*容器*的隔离单元中运行所有应用程序组件。
- en: '[Figure 12-3](#deployment_container_architecture) compares the virtualization
    and containerization system architectures.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-3](#deployment_container_architecture)比较了虚拟化和容器化系统架构。'
- en: '![bgai 1203](assets/bgai_1203.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 1203](assets/bgai_1203.png)'
- en: Figure 12-3\. Comparison of containerization and virtualization system architectures
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-3\. 容器化和虚拟化系统架构的比较
- en: The main benefit from using containers is their *portability*, *boot-up speed*,
    *compactness*, and *reliability* across various computing environments, as they
    don’t require a guest OS and a hypervisor software layer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器的最大好处是它们的*便携性*、*启动速度*、*紧凑性*和*可靠性*，在各种计算环境中，因为它们不需要客户操作系统和虚拟机管理程序软件层。
- en: This makes them perfect for deploying your services with minimal resources,
    deployment effort and overheads. They boot up faster than a VM, and scaling them
    is also more straightforward. You can add more containers to *horizontally scale*
    your services.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这使它们非常适合以最少的资源、部署努力和开销来部署你的服务。它们的启动速度比虚拟机快，扩展它们也更加直接。你可以添加更多容器来 *水平扩展* 你的服务。
- en: To help with containerizing your applications, you can rely on platforms such
    as Docker that have been battle-tested across the MLOps and DevOps communities.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助容器化你的应用程序，你可以依赖像 Docker 这样的平台，这些平台已经在 MLOps 和 DevOps 社区中得到实战检验。
- en: Containerization with Docker
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 容器化
- en: Docker is a containerization platform used to build, ship, and run containers.
    At the time of writing, Docker has around [22% market share](https://oreil.ly/A5x63)
    in the virtualization platforms market with more than 9 million developers and
    [11 billion monthly image downloads](https://oreil.ly/8-wx4), making it the most
    popular containerization platform. Many server environments and cloud providers
    support Docker within many variants of Linux and Windows server.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一个用于构建、运输和运行容器的容器化平台。在撰写本文时，Docker 在虚拟化平台市场占有大约 [22% 的市场份额](https://oreil.ly/A5x63)，拥有超过
    900 万开发者，以及 [11 亿次每月镜像下载](https://oreil.ly/8-wx4)，使其成为最受欢迎的容器化平台。许多服务器环境和云服务提供商在多种
    Linux 和 Windows 服务器变体中支持 Docker。
- en: Chances are if you need to deploy your GenAI services, the easiest and most
    straightforward option will be to use Docker to containerize your application.
    However, to get comfortable with Docker, you need to understand its architecture
    and the underlying subsystems such as storage and networking.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要部署你的 GenAI 服务，最简单、最直接的选择可能是使用 Docker 来容器化你的应用程序。然而，为了熟悉 Docker，你需要了解其架构以及底层子系统，如存储和网络。
- en: Docker Architecture
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 架构
- en: 'The Docker system is composed of an engine, a client, and a server:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 系统由一个引擎、一个客户端和一个服务器组成：
- en: Docker engine
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 引擎
- en: The engine consists of several components including a client and a server running
    on the same host OS.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎由几个组件组成，包括在同一主机操作系统上运行的客户端和服务器。
- en: Docker client
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 客户端
- en: Docker comes with both a *CLI tool* named `docker` and a graphical user interface
    (GUI) application called *Docker Desktop*. Using the client-server implementation,
    the Docker client can communicate with the local or a remote server instance using
    a REST API to manage containers by running commands such as running, stopping,
    and terminating containers. You can also use the client to pull images from an
    image registry.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 既有名为 `docker` 的 *命令行工具*，也有名为 *Docker Desktop* 的图形用户界面（GUI）应用程序。使用客户端-服务器实现，Docker
    客户端可以通过 REST API 与本地或远程服务器实例通信，通过运行命令（如运行、停止和终止容器）来管理容器。你还可以使用客户端从镜像库中拉取镜像。
- en: Docker server
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 服务器
- en: The server is a *daemon* named `dockerd`. The Docker daemon responds to the
    client HTTP requests via the REST API and can interact with other daemons. It’s
    also responsible for tracking the lifecycle of containers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器是一个名为 `dockerd` 的 *守护进程*。Docker 守护进程通过 REST API 对客户端 HTTP 请求做出响应，并且可以与其他守护进程交互。它还负责跟踪容器的生命周期。
- en: The Docker platform also allows you to create and configure objects such as
    *networks*, *storage volumes*, *plug-ins*, and service objects to support your
    deployments.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 平台还允许你创建和配置如 *网络*、*存储卷*、*插件* 和服务对象等对象，以支持你的部署。
- en: Most important, to containerize your applications with Docker, you’ll need to
    build Docker images.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，为了使用 Docker 容器化你的应用程序，你需要构建 Docker 镜像。
- en: A *Docker image* is a portable package containing software and acts as a recipe
    for creating and running your application containers. In essence, a container
    is an in-memory instance of an image.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *Docker 镜像* 是一个包含软件的可移植包，它充当创建和运行你的应用程序容器的配方。本质上，容器是镜像的内存实例。
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: A container image is *immutable*, so once you’ve built one, you can’t change
    it. You can only add to an image and not subtract. You’ll have to re-create a
    new one if you want to apply changes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像是 *不可变的*，所以一旦你构建了一个，你就不能更改它。你只能向镜像中添加内容，而不能从中移除。如果你想应用更改，你必须重新创建一个新的镜像。
- en: Docker images are the first step toward containerizing your services as you’ll
    learn in the next section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像是你将在下一节中学习的将你的服务容器化的第一步。
- en: Building Docker Images
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: Let’s imagine you have a small GenAI service using FastAPI, as shown in [Example 12-4](#docker_app),
    that you want to containerize.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你有一个使用 FastAPI 的小型 GenAI 服务，如 [示例 12-4](#docker_app) 所示，你想要将其容器化。
- en: Example 12-4\. A simple GenAI FastAPI service
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-4\. 一个简单的 GenAI FastAPI 服务
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_deployment_of_ai_services_CO1-1)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_deployment_of_ai_services_CO1-1]'
- en: Assume that the `generate_text` function is calling a model provider API or
    an external model server.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `generate_text` 函数正在调用模型提供者 API 或外部模型服务器。
- en: 'To build this application into a container image, you’ll need to write instructions
    in a text file called a *Dockerfile*. Inside this Dockerfile, you can specify
    the following components:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此应用程序构建到容器镜像中，您需要在名为 *Dockerfile* 的文本文件中编写指令。在此 Dockerfile 中，您可以指定以下组件：
- en: The *base* image to create a new image from, supplying the OS and environment
    upon which additional application layers are built
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新镜像的基础镜像，提供操作系统和环境，在此之上构建额外的应用程序层
- en: Commands to update the guest OS and install additional software
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新客户操作系统和安装额外软件的命令
- en: Build artifacts to include such as your application code
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要包含的构建工件，例如您的应用程序代码
- en: Services to expose like storage and networking configuration
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要公开的服务，如存储和网络配置
- en: The command to run when the container starts
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器启动时运行的命令
- en: '[Example 12-5](#containers_dockerfile) illustrates how to build an application
    image in a Dockerfile.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-5](#containers_dockerfile) 展示了如何在 Dockerfile 中构建应用程序镜像。'
- en: Example 12-5\. Dockerfile to containerize a FastAPI application
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-5\. 将 FastAPI 应用程序容器化的 Dockerfile
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_deployment_of_ai_services_CO2-1)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_deployment_of_ai_services_CO2-1]'
- en: Use the official Python 3.12 slim image as the `base` image.^([1](ch12.html#id1291))
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用官方 Python 3.12 slim 镜像作为 `base` 镜像.^([1](ch12.html#id1291))
- en: '[![2](assets/2.png)](#co_deployment_of_ai_services_CO2-2)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_deployment_of_ai_services_CO2-2]'
- en: Set the working directory inside the container to `/code`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将容器内部的当前工作目录设置为 `/code`。
- en: '[![3](assets/3.png)](#co_deployment_of_ai_services_CO2-3)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_deployment_of_ai_services_CO2-3]'
- en: Copy the `requirements.txt` file from the host to the current directory in the
    container.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `requirements.txt` 文件从主机复制到容器当前目录。
- en: '[![4](assets/4.png)](#co_deployment_of_ai_services_CO2-4)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_deployment_of_ai_services_CO2-4]'
- en: Install the Python dependencies listed in `requirements.txt` without using the
    cache.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用缓存安装 `requirements.txt` 中列出的 Python 依赖项。
- en: '[![5](assets/5.png)](#co_deployment_of_ai_services_CO2-5)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)[#co_deployment_of_ai_services_CO2-5]'
- en: Copy all files from the host’s current directory to the current directory in
    the container.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将主机当前目录下的所有文件复制到容器当前目录。
- en: '[![6](assets/6.png)](#co_deployment_of_ai_services_CO2-6)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png)[#co_deployment_of_ai_services_CO2-6]'
- en: Inform Docker daemon that the application inside the container is listening
    on `8000` at runtime. The `EXPOSE` command doesn’t automatically map or allow
    access on ports.^([2](ch12.html#id1292))
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通知 Docker 守护进程容器中的应用程序在运行时监听 `8000`。`EXPOSE` 命令不会自动映射或允许端口访问.^([2](ch12.html#id1292))
- en: '[![7](assets/7.png)](#co_deployment_of_ai_services_CO2-7)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![7](assets/7.png)[#co_deployment_of_ai_services_CO2-7]'
- en: Run the `uvicorn` server with the application module and host/port configuration,
    when container is launched.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器启动时，使用应用程序模块和主机/端口配置运行 `uvicorn` 服务器。
- en: We won’t be covering the full [Dockerfile specification](https://oreil.ly/8fJ6l)
    in this chapter. However, notice how each command changes the image structure
    that enables you to run your full GenAI services within a container.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中不会涵盖完整的 [Dockerfile 规范](https://oreil.ly/8fJ6l)。然而，请注意每个命令如何改变镜像结构，这使您能够在容器内运行完整的
    GenAI 服务。
- en: 'You can use the `docker build` command to build the image in [Example 12-5](#containers_dockerfile):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `docker build` 命令在 [示例 12-5](#containers_dockerfile) 中构建镜像：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice the steps listed in the output. When each step executes, a new layer
    gets added to the image you’re building.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出中列出的步骤。当每个步骤执行时，都会在您构建的镜像中添加一个新的层。
- en: Once you have a container image, you can then use container registries to store,
    share, and download images.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了容器镜像，您就可以使用容器注册库来存储、共享和下载镜像。
- en: Container Registries
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器注册库
- en: To store and distribute images in a version-controlled environment, you can
    use *container registries*, which include both the public or private flavors.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要在版本控制环境中存储和分发镜像，您可以使用 *容器注册库*，包括公共或私有版本。
- en: '*Docker Hub* is a managed software-as-a-service (SaaS) container registry for
    storing and distributing images you create.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*Docker Hub* 是一个托管软件即服务 (SaaS) 容器注册库，用于存储和分发您创建的镜像。'
- en: Docker Hub is public by default. However, you can also use self-hosted or cloud
    provider private registries such as Azure Container Registry (ACR), AWS Elastic
    Container Registry (ECR), or Google Cloud Artifact Registry.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub默认是公开的。但是，您还可以使用自托管或云提供商的私有注册表，例如Azure容器注册表（ACR）、AWS弹性容器注册表（ECR）或Google
    Cloud Artifact Registry。
- en: You can view the full Docker platform system architecture in [Figure 12-4](#docker_architecture).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[图12-4](#docker_architecture)中查看完整的Docker平台系统架构。
- en: '![bgai 1204](assets/bgai_1204.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 1204](assets/bgai_1204.png)'
- en: Figure 12-4\. Docker platform system architecture
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-4\. Docker平台系统架构
- en: As you can see in [Figure 12-4](#docker_architecture), the Docker daemon manages
    containers and images. It creates containers from images and communicates with
    the Docker client, handling commands to build and run images. The Docker daemon
    can also pull images from or push them to a registry (e.g., Docker Hub) that contains
    images like Ubuntu, Redis, or PostgreSQL.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图12-4](#docker_architecture)所示，Docker守护进程管理容器和镜像。它从镜像创建容器并与Docker客户端通信，处理构建和运行镜像的命令。Docker守护进程还可以从包含像Ubuntu、Redis或PostgreSQL这样的镜像的注册表（例如，Docker
    Hub）中拉取或推送镜像。
- en: Using the Docker Hub registry, you can access other contributed images alongside
    distributing and version controlling your own. Registries like Docker Hub play
    a crucial role in scaling your services as container orchestration platforms like
    Kubernetes need access to registries to pull and run multiple container instances
    from images.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Hub注册表，您可以在分发和版本控制自己的镜像的同时访问其他贡献的镜像。像Kubernetes这样的容器编排平台需要访问注册表以从镜像中拉取和运行多个容器实例，因此Docker
    Hub等注册表在扩展您的服务中起着至关重要的作用。
- en: 'You can pull public images from Docker Hub using the `docker pull` command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker pull`命令从Docker Hub拉取公共镜像：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you push and pull images, you’ll need to specify a *tag* using the `<name>:<tag>`
    syntax. If you don’t provide a tag, Docker engine will use the `latest` tag by
    default.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当您推送和拉取镜像时，您需要使用`<name>:<tag>`语法指定一个*标签*。如果您不提供标签，Docker引擎将默认使用`latest`标签。
- en: 'Aside from pulling, you can also store your own images in container registries.
    First, you need to build and tag your image with both a version label and the
    image repository URL:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拉取之外，您还可以将您自己的镜像存储在容器注册表中。首先，您需要构建并标记您的镜像，包括版本标签和镜像仓库URL：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once your image is built and tagged, you can then push it to the Docker Hub
    container registry using the `docker push` command. You may need to log in first
    to authenticate with the hub:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的镜像构建并标记，您就可以使用`docker push`命令将其推送到Docker Hub容器注册表。您可能需要先登录以验证与注册表的连接：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Warning
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Be careful that during a push, you don’t overwrite the tag for an image in many
    repositories. For instance, an image built and tagged `genai:latest` in a repository
    can be overwritten by another image tagged `genai:latest`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在推送过程中，请注意不要覆盖多个仓库中镜像的标签。例如，在一个仓库中构建并标记为`genai:latest`的镜像可以被标记为`genai:latest`的另一个镜像覆盖。
- en: Now that your image is stored in the registry, you can pull it down on another
    machine^([3](ch12.html#id1297)) or at a later time to run the image without the
    need to rebuild it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的镜像已存储在注册表中，您可以在另一台机器上拉取它^([3](ch12.html#id1297))或在稍后时间运行镜像，而无需重新构建它。
- en: Container Filesystem and Docker Layers
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器文件系统和Docker层
- en: When building the image, Docker uses a special filesystem called the `Unionfs`
    (stackable unification filesystem) to merge the contents of several directories
    (i.e., *branches* or in Docker terminology *layers*), while keeping their physical
    content separate.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建镜像时，Docker使用一种特殊的文件系统，称为`Unionfs`（可堆叠统一文件系统），以合并几个目录的内容（即*分支*或Docker术语中的*层*），同时保持它们物理内容的分离。
- en: Using `Unionfs`, directories of distinct filesystems can be combined and overlaid
    to form a single coherent virtual filesystem, as shown in [Figure 12-5](#docker_unionfs).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Unionfs`，可以将不同文件系统的目录组合并叠加，形成一个单一的虚拟文件系统，如图[图12-5](#docker_unionfs)所示。
- en: '![bgai 1205](assets/bgai_1205.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 1205](assets/bgai_1205.png)'
- en: Figure 12-5\. Unified virtual filesystem from multiple filesystems
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-5\. 来自多个文件系统的统一虚拟文件系统
- en: Using the `Unionfs`, Docker can add or remove branches as you build out your
    container filesystem from an image.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Unionfs`，Docker可以在您从镜像构建容器文件系统时添加或删除分支。
- en: To illustrate the mechanism of layered architecture in containers, let’s review
    the image from [Example 12-5](#containers_dockerfile).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明容器分层架构的机制，让我们回顾[示例12-5](#containers_dockerfile)中的镜像。
- en: When building the image using [Example 12-5](#containers_dockerfile), you’re
    layering a Python 3.12 base image running on a Linux distribution on top of a
    root filesystem. Next, you’re adding *requirements.txt* on top of the Python base
    image and then installing dependencies on top of *requirements.txt* layer. You
    then add a new layer by coping the content of your project directory into the
    container, layering it on top of everything else. Finally, when you start the
    container with the `uvicorn` command, you add a final writable layer as part of
    the container filesystem. As a result, the ordering of layers becomes important
    when building Docker images.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [示例 12-5](#containers_dockerfile) 构建镜像时，您是在 Linux 发行版上运行的 Python 3.12 基础镜像之上叠加根文件系统。接下来，您在
    Python 基础镜像之上添加 *requirements.txt*，然后在该层上安装依赖项。然后，您通过将项目目录的内容复制到容器中，创建一个新的层，并将其叠加到其他所有内容之上。最后，当您使用
    `uvicorn` 命令启动容器时，您将一个可写层作为容器文件系统的一部分添加。因此，在构建 Docker 镜像时，层的顺序变得很重要。
- en: '[Figure 12-6](#docker_branches) shows the layered filesystem architecture.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-6](#docker_branches) 展示了分层文件系统架构。'
- en: '![bgai 1206](assets/bgai_1206.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 1206](assets/bgai_1206.png)'
- en: Figure 12-6\. Layered Unionfs filesystem architecture
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-6\. 分层 Unionfs 文件系统架构
- en: In [Example 12-5](#containers_dockerfile), each of the command steps is creating
    a cached image as the build process finalizes the container image. To run commands,
    intermediate containers are created and then automatically deleted after. The
    underlying cached image is kept on the build host and isn’t removed. These temporary
    images are layered over the previous image and combined into a single image once
    all steps are completed. This optimization allows future builds to reuse these
    images to speed up build times.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 12-5](#containers_dockerfile) 中，每个命令步骤都在构建过程中创建一个缓存镜像，以最终确定容器镜像。为了运行命令，会创建中间容器，并在之后自动删除。这些临时镜像在完成所有步骤后，会叠加到之前的镜像上，并合并成一个单独的镜像。这种优化允许未来的构建重用这些镜像以加快构建时间。
- en: At the end, the container will comprise one or more image layers and a final
    ephemeral container layer (i.e., that won’t be persisted) when the container is
    destroyed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当容器被销毁时，容器将包含一个或多个镜像层和一个最终的临时容器层（即不会持久化）。
- en: Docker Storage
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 存储空间
- en: In this section, you will learn about various Docker storage mechanisms. During
    the development of your services as containers, you can use these tools to manage
    data persistence, sharing data between containers and maintaining state between
    container restarts.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解各种 Docker 存储机制。在您以容器形式开发服务时，您可以使用这些工具来管理数据持久化、在容器之间共享数据以及维护容器重启之间的状态。
- en: When working with containers, your application may need to write data to the
    disk, which will persist in an *ephemeral* storage. Ephemeral storage is a short-lived,
    temporary storage deleted once the container is stopped, restarted, or removed.
    If you restart your container, you’ll notice that previously persisted data is
    no longer available. Under the hood, Docker writes the runtime data to an ephemeral
    writable container layer in the container’s virtual filesystem.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当与容器一起工作时，您的应用程序可能需要将数据写入磁盘，这些数据将保存在 *临时* 存储中。临时存储是一种短暂、临时的存储，一旦容器停止、重启或删除，就会被删除。如果您重启容器，您会注意到之前持久化的数据不再可用。在底层，Docker
    将运行时数据写入容器虚拟文件系统中的一个临时可写容器层。
- en: Warning
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: You’ll lose all your application generated data and log files you’ve written
    to disk during a container’s runtime if you rely on the container’s default storage
    configuration.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您依赖于容器的默认存储配置，您将丢失在容器运行时写入磁盘的所有应用程序生成数据和日志文件。
- en: To avoid loss of application runtime data and logs, you have several storage
    options available that enable you to persist data during a container’s lifetime.
    During development, you can use *volumes* or *bind mounts* to persist data to
    the host OS filesystem or rely on local databases for persisting data.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免应用运行时数据和日志的丢失，您有多种存储选项可供选择，这些选项允许您在容器生命周期内持久化数据。在开发过程中，您可以使用 *卷* 或 *绑定挂载*
    将数据持久化到主机操作系统文件系统，或者依赖本地数据库来持久化数据。
- en: '[Table 12-1](#docker_storage_options) shows the Docker storage mount options.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-1](#docker_storage_options) 展示了 Docker 存储挂载选项。'
- en: Table 12-1\. Docker storage mounts
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-1\. Docker 存储挂载
- en: '| Storage | Description | Use cases |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 存储 | 描述 | 用例 |'
- en: '| --- | --- | --- |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Volumes | I/O optimized and preferred storage solution. Managed by Docker
    and stored in a specific location on the host but decoupled from the host filesystem
    structure. | If you need to store and share data across multiple containers.If
    you don’t need to modify files or directories from the host. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 卷 | I/O优化且首选的存储解决方案。由Docker管理，存储在宿主机的特定位置，但与宿主文件系统结构解耦。 | 如果您需要在多个容器之间存储和共享数据。如果您不需要从宿主修改文件或目录。|'
- en: '| Bind mounts | Mount files or directories on host into the container but have
    limited functionality compared to volumes. | If you want both containers and host
    processes to access and modify host’s files and directories. For instance, during
    local development and testing. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 绑定挂载 | 将宿主上的文件或目录挂载到容器中，但与卷相比功能有限。 | 如果您希望容器和宿主进程都能访问和修改宿主的文件和目录。例如，在本地开发和测试期间。|'
- en: '| Temporary (tmpfs) mounts | Stores data in the host’s memory (RAM) and never
    written to the container or host’s filesystem. | If you need high-performance
    temporary storage for sensitive or nonstateful data that won’t persist after the
    container stops. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 临时（tmpfs）挂载 | 将数据存储在宿主的内存（RAM）中，并且永远不会写入容器或宿主文件系统。 | 如果您需要高性能的临时存储，用于敏感或无状态数据，这些数据在容器停止后不会持久化。|'
- en: '[Figure 12-7](#docker_storage_mounts) shows the different types of mounts.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-7](#docker_storage_mounts)显示了不同类型的挂载。'
- en: '![bgai 1207](assets/bgai_1207.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 1207](assets/bgai_1207.png)'
- en: Figure 12-7\. Docker storage mounts
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-7\. Docker存储挂载
- en: We’ll now study each storage option in detail so you can simulate your production
    environment locally with Docker containers using the appropriate storage. When
    deploying containers to production within a cloud environment, you can use a database
    or cloud storage offering for persisting data instead of Docker volumes or bind
    mounts to centralize storage across multiple containers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将详细研究每个存储选项，以便您可以使用Docker容器在本地模拟您的生产环境，使用适当的存储。当在云环境中将容器部署到生产环境中时，您可以使用数据库或云存储服务来持久化数据，而不是使用Docker卷或绑定挂载来跨多个容器集中存储。
- en: Docker volumes
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker卷
- en: 'Docker allows you to create isolated *volumes* for persisting application data
    between container runtimes. To create a volume, you can run the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Docker允许您创建用于在容器运行之间持久化应用程序数据的隔离**卷**。要创建卷，您可以运行以下命令：
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once created, you can use volumes to persist data between container runs. Volumes
    also allow you to persist data when you use database and memory store containers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，您可以使用卷在容器运行之间持久化数据。卷还允许您在使用数据库和内存存储容器时持久化数据。
- en: Warning
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Restarting a database container with new environment variables may not be enough
    to reset them with new settings.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新环境变量重新启动数据库容器可能不足以通过新设置重置它们。
- en: Some database systems may require you to re-create the container volume if you
    need to update settings like administrator user credentials.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库系统可能要求您在需要更新设置，如管理员用户凭证时，重新创建容器卷。
- en: By default, any volumes you create will be stored on the host machine filesystem
    until you explicitly remove them via the `docker volume remove` command.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，您创建的任何卷都将存储在宿主机器文件系统上，直到您通过`docker volume remove`命令显式删除它们。
- en: Bind mounts
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定挂载
- en: In addition to volumes, you can also use filesystem mappings via volume *bind
    mounts* that map directories residing on the host filesystem to the container
    filesystem, as shown in [Figure 12-8](#docker_bind_mounts).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 除了卷之外，您还可以通过卷**绑定挂载**使用文件系统映射，将宿主文件系统上的目录映射到容器文件系统，如图[图12-8](#docker_bind_mounts)所示。
- en: '![bgai 1208](assets/bgai_1208.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 1208](assets/bgai_1208.png)'
- en: Figure 12-8\. Bind mounts between host filesystem and a container
  id: totrans-210
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-8\. 宿主文件系统和容器之间的绑定挂载
- en: The mounts happen as you start your container. With the mounted directories,
    you can then directly access them from within the container. You can read and
    persist data to the mounted directories as you run and stop your containers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载发生在您启动容器时。有了挂载的目录，您就可以直接从容器内部访问它们。您可以在运行和停止容器时读取和将数据持久化到挂载的目录。
- en: 'To run a container with a volume bind mount, you can use the following command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用卷绑定挂载运行容器，您可以使用以下命令：
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the `-v` flag allows you to map the host directory to a container directory
    using the `<host_dir>:<container_dir>` syntax.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`-v`标志允许您使用`<host_dir>:<container_dir>`语法将宿主目录映射到容器目录。
- en: Warning
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The functionality of the `COPY` command you use in a Dockerfile is different
    from directory mounting.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您在Dockerfile中使用的`COPY`命令的功能与目录挂载不同。
- en: The former makes a separate copy of a host directory into the container during
    the image build process while the latter allows you to access and update the mapped
    host directory from within the container.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 前者会在镜像构建过程中将主机目录的单独副本放入容器中，而后者允许你在容器内访问和更新映射的主机目录。
- en: This means that if you’re not careful, you can unintentionally modify or delete
    all your original files on the host machine permanently, from within the container.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你不小心，你可能会在容器内无意中永久修改或删除主机机器上的所有原始文件。
- en: Bind mount volumes can still be useful in a local development environment. As
    you change the source code of your services, you’ll be able to observe the real-time
    impact of modifications on the running application containers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地开发环境中，绑定挂载卷仍然很有用。当你更改服务的源代码时，你将能够观察到修改对运行中的应用容器实时影响。
- en: Temporary mounts (tmpfs)
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 临时挂载（tmpfs）
- en: If you have some nonpersistent data such as model caches or sensitive files
    that you don’t need to store permanently, you should consider using temporary
    *tmpfs mounts*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些非持久数据，例如模型缓存或敏感文件，你不需要永久存储，你应该考虑使用临时的 *tmpfs 挂载*。
- en: This temporary mount will only persist the data to the host memory (RAM) during
    the container’s runtime and increases the container’s performance by avoiding
    writes into the container’s writeable layer.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个临时挂载将在容器运行时仅将数据持久化到主机内存（RAM）中，并通过避免写入容器的可写层来提高容器的性能。
- en: When containerizing GenAI applications, you can use temporary mounts to store
    cached results, intermediate model computations, temporary files, and session-specific
    logs that you won’t need once the container stops.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器化 GenAI 应用程序时，你可以使用临时挂载来存储缓存结果、中间模型计算、临时文件和容器停止后不再需要的特定会话日志。
- en: Tip
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: The container’s writeable layer is tightly coupled with the host machine through
    a storage driver to implement the union filesystem. Therefore, writing to the
    container’s writable layer reduces performance due to this additional layer of
    abstraction.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的可写层通过存储驱动程序与主机机器紧密耦合，以实现联合文件系统。因此，向容器的可写层写入会由于额外的抽象层而降低性能。
- en: Instead, you can use data volumes for persistent storage that writes directly
    to the host filesystem or tmpfs mounts for temporary in-memory storage.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以使用数据卷进行持久存储，它直接写入主机文件系统，或者使用 tmpfs 挂载进行临时内存存储。
- en: Unlike bind mounts and volumes, you can’t share the tmpfs mount between containers,
    and the functionality is available only on Linux systems. In addition, if you
    adjust directory permissions on tmpfs mounts, they can reset when the container
    restarts.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 与绑定挂载和卷不同，你不能在容器之间共享 tmpfs 挂载，并且该功能仅在 Linux 系统上可用。此外，如果你调整 tmpfs 挂载的目录权限，它们在容器重启时可能会重置。
- en: 'Here are a few other use cases of tmpfs mounts:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 tmpfs 挂载的一些其他用例：
- en: Temporarily storing data caches, API responses, logs, test data, configuration
    files, and AI model artifacts in-memory
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存中临时存储数据缓存、API 响应、日志、测试数据、配置文件和 AI 模型工件
- en: Avoiding I/O writes to disks while working with library APIs that require file-like
    objects
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在处理需要文件样对象库 API 的工作时进行 I/O 写入。
- en: Simulating high-speed I/O with rapid file access and writes
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过快速文件访问和写入模拟高速 I/O
- en: Preventing excessive or unnecessary disk writes if you need temporary directories
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要临时目录，可以防止过多的或不必要的磁盘写入
- en: 'To set a tmpfs mount, you can use the following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 tmpfs 挂载，你可以使用以下命令：
- en: '[PRE17]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, you are setting a tmpfs mount on the `/cache` directory for model caches,
    which will cease to exist once the container stops.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在为模型缓存设置 `/cache` 目录的 tmpfs 挂载，一旦容器停止，该挂载将不再存在。
- en: Handling filesystem permissions
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理文件系统权限
- en: A big source of frustration and a security consideration for many developers
    new to Docker is managing directory permissions when using filesystem bind mounts
    between the host OS and the container.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多刚开始使用 Docker 的开发者来说，管理目录权限是使用主机操作系统和容器之间的文件系统绑定挂载时的一个巨大的挫折和考虑因素。
- en: By default, Docker runs containers as the `root` user leading to containers
    having full read/write access to mounted directories on the host OS. If the `root`
    user inside the container creates directories or files, they will be owned by
    `root` on the host as well. You can then face permission issues if you have a
    nonroot user account on the host when you try to access or modify these directories
    or files.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker以`root`用户身份运行容器，导致容器对宿主操作系统上挂载的目录具有完全的读写访问权限。如果容器内的`root`用户创建目录或文件，它们在宿主机上也将由`root`用户拥有。当你尝试访问或修改这些目录或文件时，如果你在宿主机上有一个非root用户账户，可能会遇到权限问题。
- en: Warning
  id: totrans-239
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Running containers as the default `root` user is also a great security risk
    if a malicious actor gets access to the container since they’ll have access to
    the host system as `root`. Additionally, if you run a compromised image, you might
    risk executing malicious code on your host system with `root` privileges.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以默认的`root`用户身份运行容器也是一大安全风险，如果恶意行为者获得对容器的访问权限，因为他们将以`root`身份访问宿主系统。此外，如果你运行了一个受损害的图像，你可能会以`root`权限在宿主系统上执行恶意代码。
- en: 'To mitigate permission issues when running containers with bind mounts, you
    can use the `--user` flag to run the container as a nonroot user:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻在运行具有绑定挂载的容器时遇到的权限问题，你可以使用`--user`标志以非root用户身份运行容器：
- en: '[PRE18]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Alternatively, you can create and switch to a nonroot user within the final
    layers of the image build inside the Dockerfile, as shown in [Example 12-6](#docker_permissions).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在Dockerfile中图像构建的最终层内创建并切换到一个非root用户，如图例12-6所示。
- en: Example 12-6\. Creating and switching to nonroot user when building container
    images (Ubuntu/Debian containers only)
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例12-6。在构建容器图像时创建和切换到非root用户（仅限Ubuntu/Debian容器）
- en: '[PRE19]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_deployment_of_ai_services_CO3-1)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_deployment_of_ai_services_CO3-1]'
- en: Use build arguments to specify variables during the image build.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构建参数在图像构建期间指定变量。
- en: '[![2](assets/2.png)](#co_deployment_of_ai_services_CO3-2)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_deployment_of_ai_services_CO3-2]'
- en: Create a user group with the given `USER_GID`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定的`USER_GID`创建一个用户组。
- en: '[![3](assets/3.png)](#co_deployment_of_ai_services_CO3-3)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)[#co_deployment_of_ai_services_CO3-3]'
- en: Disable user login completely including password-based login.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 完全禁用用户登录，包括基于密码的登录。
- en: '[![4](assets/4.png)](#co_deployment_of_ai_services_CO3-4)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)[#co_deployment_of_ai_services_CO3-4]'
- en: Avoid creating a home directory for the user.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 避免为用户创建家目录。
- en: '[![5](assets/5.png)](#co_deployment_of_ai_services_CO3-5)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)[#co_deployment_of_ai_services_CO3-5]'
- en: Create a nonroot user account with the given `$USER_UID` and assign it to the
    newly created `USER_GID` group. Set the name of the user account to `fastapi`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定的`$USER_UID`创建一个非root用户账户，并将其分配给新创建的`USER_GID`组。将用户账户的名称设置为`fastapi`。
- en: '[![6](assets/6.png)](#co_deployment_of_ai_services_CO3-6)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png)[#co_deployment_of_ai_services_CO3-6]'
- en: Switch to the nonroot `fastapi` user.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到非root的`fastapi`用户。
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Often, you’ll need to install packages or add configurations that require privileged
    disk access or permissions. You should only switch to a nonroot user at the end
    of an image build once you’ve completed such installations and configurations.
    Avoid switching back and forth between root and nonroot users to prevent any unnecessary
    complexity and excess image layers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要安装包或添加需要特权磁盘访问或权限的配置。一旦完成此类安装和配置，你应该只在图像构建的末尾切换到非root用户。避免在root和非root用户之间来回切换，以防止不必要的复杂性和过多的图像层。
- en: If you hit issues with creating new groups or users in [Example 12-6](#docker_permissions),
    try changing the `USER_UID` and `USER_GID` as those IDs may already be in use
    by another nonroot user in the image.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到在图例12-6中创建新组或用户的问题，尝试更改`USER_UID`和`USER_GID`，因为这些ID可能已经被图像中的另一个非root用户使用。
- en: 'Let’s assume that during the image creation, the `root` user in the container
    has created the `myscripts` folder. You can inspect filesystem permissions using
    the `ls -l` command, which returns the following output:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在图像创建过程中，容器内的`root`用户创建了`myscripts`文件夹。你可以使用`ls -l`命令检查文件系统权限，该命令返回以下输出：
- en: '[PRE20]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can read permissions `drwxr-xr-x` for the `myscripts` directory using the
    following breakdown:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下分解读取`myscripts`目录的权限`drwxr-xr-x`：
- en: '`d`: Specifies that `myscripts` is a directory; otherwise would show a `-`.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：指定`myscripts`是一个目录；否则将显示为`-`。'
- en: '`rwx`: Owner `root` user can (r)read, (w)rite, and e(x)ecute files in this
    directory.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rwx`：所有者`root`用户可以（r）读取、（w）写入和（e）执行此目录中的文件。'
- en: '`r--`: Group `root` members can perform (r)ead-only operations but can’t write
    or execute any files.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r--`: 组 `root` 成员可以执行（r）只读操作，但不能写入或执行任何文件。'
- en: '`r--`: Everyone else can read the file but cannot write to or execute it.^([4](ch12.html#id1317))'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r--`: 任何其他人都可以读取文件，但不能写入或执行它.^([4](ch12.html#id1317))'
- en: If you want to set ownership or permissions on the `myscripts` directory, you
    can use the `chmod` or `chown` commands in Linux systems.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 `myscripts` 目录上设置所有权或权限，您可以在 Linux 系统中使用 `chmod` 或 `chown` 命令。
- en: 'Use the `chown` command to change the directory owner on host so that you can
    edit the files in your code editor:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `chown` 命令更改主机上的目录所有者，以便您可以在代码编辑器中编辑文件：
- en: '[PRE21]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Alternatively, if you only need to execute the scripts in the `myscripts` directory,
    use the `chmod` command to change the file or directory permissions:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您只需要执行 `myscripts` 目录中的脚本，可以使用 `chmod` 命令更改文件或目录权限：
- en: '[PRE22]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-273
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `-R` flag will recursively set the ownership or permissions on a nested
    directory.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`-R` 标志将递归地设置嵌套目录的所有权或权限。'
- en: This command will allow `root` group members and other users to execute files
    in the `myscripts` directory. Others can execute the files only if they use the
    `bash` command. However, only the owner can modify them.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将允许 `root` 组成员和其他用户执行 `myscripts` 目录中的文件。其他人只能通过使用 `bash` 命令来执行文件。然而，只有所有者才能修改它们。
- en: 'If you inspect the filesystem permissions again using `ls -l`, you’ll see the
    following output:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次使用 `ls -l` 检查文件系统权限，您将看到以下输出：
- en: '[PRE23]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`rwx`: Owner `root` user can still (r)read, (w)rite, and e(x)ecute files in
    this directory.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rwx`: 所有者 `root` 用户仍然可以在这个目录中（r）读取、（w）写入和（e）执行文件。'
- en: '`r-x`: Group `root` members can perform (r)ead and e(x)ecute operations but
    can’t modify any files.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r-x`: 组 `root` 成员可以执行（r）读取和（e）执行操作，但不能修改任何文件。'
- en: '`r-x`: Anyone else can’t modify files in `myscripts` directory but can read
    and execute them.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r-x`: 任何其他人不能修改 `myscripts` 目录中的文件，但可以读取和执行它们。'
- en: You can use [Example 12-7](#docker_permissions_execute) to set permissions when
    creating directories inside an image.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用[示例 12-7](#docker_permissions_execute)在镜像内部创建目录时设置权限。
- en: Example 12-7\. Creating scripts folder and allowing files to be executed (Ubuntu/Debian
    containers only)
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-7\. 创建脚本文件夹并允许执行文件（仅适用于 Ubuntu/Debian 容器）
- en: '[PRE24]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The instructions in [Example 12-7](#docker_permissions_execute) will allow you
    to configure permissions to execute files in the `scripts` directory from within
    the container.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-7](#docker_permissions_execute) 中的说明将允许您配置权限，以便在容器内部执行 `scripts` 目录中的文件。'
- en: Warning
  id: totrans-285
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: When using container volumes, be careful with mount bindings as they replace
    the permissions inside the container with those from the host filesystem.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用容器卷时，请注意挂载绑定，因为它们会替换容器内的权限为主机文件系统的权限。
- en: The most frustrating issues when working with containers will be related to
    filesystem permissions. Therefore, knowing how to set and correct file permissions
    will save you hours of development when working with containers that produce or
    modify artifacts on the host machine.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与容器一起工作时最令人沮丧的问题将与文件系统权限相关。因此，了解如何设置和纠正文件权限将节省您在处理在主机机器上生成或修改工件时的工作时间。
- en: Docker Networking
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 网络配置
- en: Docker networking is one of the hardest concepts to grasp in multicontainer
    projects. This section covers how Docker networking works and how to set up local
    containers to communicate, simulating production environments during development.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 网络是多容器项目中最难掌握的概念之一。本节将介绍 Docker 网络的工作原理以及如何设置本地容器以进行通信，在开发过程中模拟生产环境。
- en: Often, when you’re deploying to production environments in the cloud, you configure
    networking using the cloud provider’s solutions. However, if you need to connect
    containers in a development environment for local testing or deploying on on-premises
    resources, then you’ll benefit from understanding how Docker networking works.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当您将应用程序部署到云中的生产环境时，您会使用云提供商的解决方案配置网络。然而，如果您需要将容器连接到开发环境进行本地测试或部署到本地资源，那么了解
    Docker 网络的工作原理将使您受益。
- en: If you’re developing GenAI services that interact with external systems like
    databases, chances are you’ll be using multiple containers; one for your application
    and one for running each of your databases or external systems.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在开发与外部系统（如数据库）交互的 GenAI 服务，那么您可能会使用多个容器；一个用于您的应用程序，另一个用于运行您的每个数据库或外部系统。
- en: Docker ships with a networking subsystem that allows containers to connect with
    each other on the same or different hosts. You can even connect containers via
    internet-facing hosts.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Docker附带了一个网络子系统，允许容器在相同或不同的主机上相互连接。您甚至可以通过面向互联网的主机连接容器。
- en: When you create containers using the `docker run` command, they’ll have networking
    enabled by default on a *bridge network* so that they can make outgoing connections.
    However, they won’t expose or publish their ports to the outside world.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`docker run`命令创建容器时，它们将默认在*桥接网络*上启用网络，以便它们可以建立出站连接。然而，它们不会将端口暴露或发布到外部世界。
- en: Warning
  id: totrans-294
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: With the default settings, Docker interacts with the OS kernels to configure
    *firewall rules* (e.g., `iptables` and `ip6tables` rules on Linux) to implement
    network isolation, port publishing, and filtering.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 默认设置下，Docker与操作系统内核交互以配置*防火墙规则*（例如，Linux上的`iptables`和`ip6tables`规则）以实现网络隔离、端口发布和过滤。
- en: Since Docker can override these firewall rules, if you have a port on host like
    `8000` closed, Docker can force it open and expose it outside the host machine
    when you run a container with the `-p 8000:8000` flag. To prevent such an exposure,
    a solution is to run containers using `-p 127.0.0.1:8000:8000`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker可以覆盖这些防火墙规则，如果您的主机上有像`8000`这样的端口关闭，当您使用带有`-p 8000:8000`标志运行容器时，Docker可以强制将其打开并暴露在主机机器之外。为了防止这种暴露，一种解决方案是使用`-p
    127.0.0.1:8000:8000`标志运行容器。
- en: For the networking subsystem to function, Docker uses *networking drivers*,
    as shown in [Table 12-3](#docker_networking_drivers).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使网络子系统正常工作，Docker使用*网络驱动程序*，如[表12-3](#docker_networking_drivers)所示。
- en: Table 12-3\. Docker networking drivers
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 表12-3\. Docker网络驱动程序
- en: '| Driver | Description | Use case |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 驱动 | 描述 | 用例 |'
- en: '| --- | --- | --- |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Bridge (default) | Connects containers running on the same Docker daemon
    host. User-defined networks can leverage an embedded DNS server. | Control container
    communication in isolated Docker networks with a simple setup. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 桥接（默认） | 连接在同一Docker守护进程主机上运行的容器。用户定义的网络可以利用内嵌的DNS服务器。 | 通过简单的设置控制隔离Docker网络中的容器通信。
    |'
- en: '| Host | Removes the isolation layer between containers and the host system,
    so any TCP/UDP connections are accessible directly via host network such as the
    localhost without the need to publish ports. | Simplify access to container from
    the host network (e.g., localhost) or when a container needs to handle a large
    range of ports. |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 主机 | 移除容器和主机系统之间的隔离层，因此任何TCP/UDP连接都可以直接通过主机网络（如localhost）访问，无需发布端口。 | 简化从主机网络（例如localhost）访问容器或当容器需要处理大量端口时的访问。
    |'
- en: '| None | Disables all networking services and isolates running containers within
    the Docker environment. | Isolate containers from any Docker and non-Docker process
    for security reasons. Network debugging or simulating outages. Resource isolation
    and transient containers for short-lived processes. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| None | 禁用所有网络服务并将运行中的容器隔离在Docker环境中。 | 由于安全原因，隔离容器以防止任何Docker和非Docker进程。网络调试或模拟故障。为短期进程提供资源隔离和短暂容器。
    |'
- en: '| Overlay | Connects containers across multiple hosts/engines or in a *Docker
    Swarm* cluster.**Note:** Docker engine has *swarm* mode that enables container
    orchestration via *clusters* of Docker daemons/engines. | Remove the need for
    OS-level routing when connecting containers across Docker hosts. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| Overlay | 连接多个主机/引擎或Docker Swarm集群中的容器。**注意：**Docker引擎具有*swarm*模式，该模式通过Docker守护进程/引擎的*集群*启用容器编排。
    | 在连接Docker主机之间的容器时，无需在操作系统级别进行路由。 |'
- en: '| Macvlan | Assigns mac addresses to containers as if they’re physical devices.Misconfiguration
    may lead to unintentional degradation of your network due to IP address exhaustion,
    leading to VLAN spread (large number of mac addresses) or promiscuous mode (overlapping
    addresses). | Used in legacy systems or applications that monitor network traffic
    that expect to be directly connected to a physical network. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| Macvlan | 将mac地址分配给容器，就像它们是物理设备一样。配置错误可能导致由于IP地址耗尽而意外降低网络性能，导致VLAN扩散（大量mac地址）或混杂模式（地址重叠）。
    | 用于旧系统或应用程序，这些系统或应用程序监控网络流量并期望直接连接到物理网络。 |'
- en: '| IPVlan | Gives you total control over container IPv4 and IPv6 addressing,
    providing easy access to external services with no need for port mappings. | Advanced
    networking setup that bypasses the traditional Linux bridge for isolation, enhanced
    performance and simplified networking topology. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| IPVlan | 提供对容器IPv4和IPv6地址的完全控制，无需端口映射即可轻松访问外部服务。 | 一种绕过传统Linux网桥进行隔离的高级网络设置，提高了性能并简化了网络拓扑。
    |'
- en: To ensure your containers can communicate together, you may need to specify
    networking settings and drivers. You can select a networking driver that matches
    your use case based on [Table 12-3](#docker_networking_drivers).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您的容器能够相互通信，您可能需要指定网络设置和驱动程序。您可以根据[表12-3](#docker_networking_drivers)选择与您的用例相匹配的网络驱动程序。
- en: Note
  id: totrans-308
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some of these drivers may not be available depending on the platform/host OS
    you’re running Docker on (Windows, Linux, or macOS host).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这些驱动程序中的一些可能取决于您在哪个平台上运行Docker（Windows、Linux或macOS主机）而不可用。
- en: The most commonly used network drivers are bridge, host, and none. You likely
    won’t need to use other drivers (e.g., overlay, Macvlan, IPVlan) unless you need
    more advanced networking configurations.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的网络驱动程序是网桥、主机和无。除非您需要更高级的网络配置，否则您可能不需要使用其他驱动程序（例如overlay、Macvlan、IPVlan）。
- en: '[Figure 12-9](#docker_networking_drivers_viz) visualizes the functionality
    of the bridge, host, none, overlay, Macvlan, and IPVlan drivers.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-9](#docker_networking_drivers_viz)展示了网桥、主机、无、overlay、Macvlan和IPVlan驱动程序的功能。'
- en: '![bgai 1209](assets/bgai_1209.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 1209](assets/bgai_1209.png)'
- en: Figure 12-9\. Docker networking drivers
  id: totrans-313
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-9\. Docker网络驱动程序
- en: Let’s explore these networking drivers in more detail.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨这些网络驱动程序。
- en: Bridge network driver
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网桥网络驱动程序
- en: The bridge network driver connects containers by creating a default bridge network
    `docker0` and associating containers with it and the host’s main network interface,
    unless otherwise specified. This will allow your containers to access the host
    network (and the internet) plus allow you to access the containers.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 网桥网络驱动程序通过创建默认网桥网络`docker0`并将容器与它和主机的主要网络接口关联起来来连接容器（除非有其他指定）。这将允许您的容器访问主机网络（以及互联网），并允许您访问容器。
- en: 'You can view the networks using the `docker network ls` command:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker network ls`命令查看网络：
- en: '[PRE25]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The *network bridge* in Docker is a link layer software device running within
    the host machine’s kernel, allowing linked containers to communicate while isolating
    non-connected containers. The bridge driver automatically installs rules in the
    host machine so that containers on different bridge networks can’t communicate
    directly.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Docker中的*网络网桥*是在主机机器的内核中运行的链路层软件设备，允许连接的容器进行通信，同时隔离未连接的容器。网桥驱动程序会自动在主机机器中安装规则，使得不同网桥网络上的容器不能直接通信。
- en: Tip
  id: totrans-320
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Bridge networks only apply to containers running on the same Docker engine/daemon
    host. To connect containers running on other daemon hosts, you can manage routing
    at the host OS layer or use an *overlay* driver.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 网桥网络仅适用于在同一Docker引擎/守护程序主机上运行的容器。要连接在其他守护程序主机上运行的容器，您可以在主机操作系统层管理路由或使用*overlay*驱动程序。
- en: In addition to default bridge networks, you can create your own custom networks,
    which can provide superior isolation and packet routing experience.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认的网桥网络外，您还可以创建自己的自定义网络，这些网络可以提供更高级的隔离和数据包路由体验。
- en: Configure user-defined bridge networks
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置用户定义的网桥网络
- en: If you need more advanced or isolated networking environments for your containers,
    you can create a separate user-defined network.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要为容器提供更高级或隔离的网络环境，您可以创建一个单独的用户定义网络。
- en: User-defined networks are superior to the default bridge networks as they provide
    better isolation. In addition, containers can resolve each other by name or alias
    on user-defined bridge networks unlike the default network where they can only
    communicate via IP addresses.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的网络优于默认的网桥网络，因为它们提供了更好的隔离。此外，在用户定义的网桥网络上，容器可以通过名称或别名相互解析，而在默认网络中，它们只能通过IP地址进行通信。
- en: Warning
  id: totrans-326
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If you run containers without specifying `--network`, they’ll be attached to
    the default bridge network. This can be a security issue as unrelated services
    are then able to communicate and access each other.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有指定`--network`选项运行容器，它们将被连接到默认的网桥网络。这可能会成为一个安全问题，因为此时无关的服务能够相互通信和访问。
- en: 'To create a network, you can use the `docker network create` command, which
    will use `--driver bridge` flag by default:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建网络，您可以使用 `docker network create` 命令，它默认使用 `--driver bridge` 标志：
- en: '[PRE26]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-330
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When you create user-defined networks, Docker uses the host OS tools to manage
    the underlying network infrastructure, such as adding or removing bridge devices
    and configuring `iptables` rules on Linux.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建用户定义的网络时，Docker 使用主机操作系统工具来管理底层网络基础设施，例如添加或删除桥接设备，以及在 Linux 上配置 `iptables`
    规则。
- en: 'Once the network is created, you can list the networks using the `docker network
    ls` command:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 网络创建后，您可以使用 `docker network ls` 命令列出网络：
- en: '[PRE27]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The network topology will now look like [Figure 12-10](#docker_networking_isolated).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 网络拓扑现在将看起来像 [图 12-10](#docker_networking_isolated)。
- en: '![bgai 1210](assets/bgai_1210.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 1210](assets/bgai_1210.png)'
- en: Figure 12-10\. Isolated bridge networks
  id: totrans-336
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-10\. 隔离的桥接网络
- en: 'When you run containers, you can now attach them to the created network using
    the `--network genai-net` flag:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行容器时，您现在可以使用 `--network genai-net` 标志将它们附加到创建的网络：
- en: '[PRE28]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Warning
  id: totrans-339
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: On Linux, there is a limit of 1,000 containers that can connect to a single
    bridge network due to the Linux kernel restrictions. Linking more containers to
    a single bridge network can make it unstable and break inter-container communication.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，由于 Linux 内核的限制，单个桥接网络可以连接的容器数量限制为 1,000 个。将更多容器链接到单个桥接网络可能会使其不稳定并破坏容器间的通信。
- en: Both your containers can now access each other on your better isolated `genai-net`
    user-defined network with automatic *DNS resolution* between containers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您的两个容器现在可以在您更好的隔离 `genai-net` 用户定义网络上相互访问，容器之间有自动的 *DNS 解析*。
- en: Embedded DNS
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌入式 DNS
- en: Docker leverages an embedded DNS server with user-defined networks, as shown
    in [Figure 12-11](#docker_networking_bridge_dns), to map internal IP addresses
    so that containers can reach one by name.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 利用嵌入的 DNS 服务器与用户定义的网络，如图 12-11 所示，来映射内部 IP 地址，以便容器可以通过名称相互访问。
- en: '![bgai 1211](assets/bgai_1211.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![bgai 1211](assets/bgai_1211.png)'
- en: Figure 12-11\. Embedded DNS
  id: totrans-345
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-11\. 嵌入式 DNS
- en: For instance, if you name your application container as `genai-service` and
    your database container as `db`, then your `genai-service` container can communicate
    with the database by calling the `db` hostname.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您将应用程序容器命名为 `genai-service`，将数据库容器命名为 `db`，那么您的 `genai-service` 容器可以通过调用
    `db` 主机名与数据库进行通信。
- en: Warning
  id: totrans-347
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: You can’t access the `db` container from outside of the Docker bridge network
    by its name, as the embedded DNS server is not visible to the host machine.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法通过名称从 Docker 网络桥接之外访问 `db` 容器，因为嵌入的 DNS 服务器对主机机器不可见。
- en: Instead, you can expose a container port `5432` and access the `db` container
    using host’s network (e.g., via `localhost:5432`).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以通过暴露容器端口 `5432` 并使用主机网络（例如，通过 `localhost:5432`）来访问 `db` 容器。
- en: Let’s discuss how you can publish container ports to the outside environment
    such as the host machine next.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们讨论如何将容器端口发布到外部环境，例如主机机器。
- en: Publishing ports
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发布端口
- en: When you run containers in a network, they automatically expose ports to each
    other.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在网络上运行容器时，它们会自动向彼此暴露端口。
- en: 'If you need to access containers from the host machine or non-Docker processes
    on different networks, you’ll need to expose the container ports by publishing
    them using the `--publish` or `-p` flag:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要从主机机器或不同网络上的非 Docker 进程访问容器，您需要通过使用 `--publish` 或 `-p` 标志发布容器端口来暴露它们：
- en: '[PRE29]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This command allows you to create a container with exposed port `8000` mapped
    to `8000` port on the host machine (e.g., localhost) using the `<host_port>:​<con⁠tainer_port>`
    syntax.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令允许您创建一个容器，其中暴露的端口 `8000` 映射到主机机器上的 `8000` 端口（例如，localhost），使用 `<host_port>:<container_port>`
    语法。
- en: When you don’t specify a container port, Docker will publish and map port `80`
    by default.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当您未指定容器端口时，Docker 默认会发布并映射端口 `80`。
- en: Warning
  id: totrans-357
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Always double-check ports you want to expose and avoid publishing container
    ports that are already in use on your host machine. Otherwise, there’ll be *port
    conflicts* leading to requests being routed to conflicting services, which will
    also be time-consuming to troubleshoot.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 总是仔细检查您想要暴露的端口，并避免发布已在主机机器上使用的容器端口。否则，将会有 *端口冲突*，导致请求被路由到冲突的服务，这也会导致调试变得耗时。
- en: If using bridge networks and port mappings are causing you a lot of trouble,
    you can also use the *host* networking driver for connecting your containers,
    albeit without the same isolation and security benefits of bridge networks.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用网桥网络和端口映射给您带来很多麻烦，您也可以使用 *主机* 网络驱动来连接您的容器，尽管没有网桥网络相同的隔离和安全优势。
- en: Host network driver
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主机网络驱动
- en: A *host* network driver is useful for cases where you want to improve performance,
    when you want to avoid the container port mapping, or when one of your containers
    needs to handle a large number of ports.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '*主机* 网络驱动在以下情况下很有用：您想提高性能，当您想避免容器端口映射，或者当您的某个容器需要处理大量端口时。'
- en: 'Running a container with the host driver is as simple as using the `--net=host`
    flag with the `docker run` command:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主机驱动运行容器与使用 `docker run` 命令中的 `--net=host` 标志一样简单：
- en: '[PRE30]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In host networking, containers share the host machine’s network namespace, meaning
    that containers won’t be isolated from the Docker host. Therefore, containers
    won’t be allocated their own IP address.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机网络中，容器共享主机机的网络命名空间，这意味着容器不会与 Docker 主机隔离。因此，容器不会分配自己的 IP 地址。
- en: Warning
  id: totrans-365
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As soon as you enable the host network driver, previously published ports will
    be discarded, as containers won’t have their own IP address.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您启用主机网络驱动，之前发布的端口将被丢弃，因为容器不会有自己的 IP 地址。
- en: The host network driver is more performant because it doesn’t need a *network
    address translation* (NAT) for mapping IP addresses from one namespace (containers)
    to another (host machine) and avoids creating a *user-land proxy* (i.e., port
    forwarding) for each port. However, host networking is only supported with Linux—and
    not Windows—containers. In addition, containers won’t have access to the network
    interfaces of the host so can’t bind to host’s IP addresses, leading to added
    complexity in the network configuration you need.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 主机网络驱动性能更优，因为它不需要进行 *网络地址转换* (NAT) 来映射一个命名空间（容器）到另一个（主机机）的 IP 地址，并且避免了为每个端口创建
    *用户空间代理*（即端口转发）。然而，主机网络仅支持 Linux 容器——不支持 Windows 容器。此外，容器无法访问主机的网络接口，因此无法绑定到主机的
    IP 地址，这导致网络配置需要额外的复杂性。
- en: None network driver
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: None 网络驱动
- en: 'If you want to completely isolate the networking stack of a container, you
    can use the `--network none` flag when starting the container. Within the container,
    only the loopback device is created, a virtual network interface that the container
    uses to communicate with itself. You can specify the none network driver using
    the following command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想完全隔离容器的网络堆栈，您可以在启动容器时使用 `--network none` 标志。在容器内部，仅创建 loopback 设备，这是一个容器用来与自身通信的虚拟网络接口。您可以使用以下命令指定
    none 网络驱动：
- en: '[PRE31]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'These are a few cases where isolating containers are useful:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些隔离容器有用的场景：
- en: Applications handling highly sensitive data or running critical processes
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理高度敏感数据或运行关键进程的应用程序
- en: Where there’s a higher risk of network-based attacks or malware
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络攻击或恶意软件风险较高的环境中
- en: Performing network debugging and simulating network outages by eliminating external
    interference
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过消除外部干扰进行网络调试和模拟网络故障
- en: Running stand-alone containers without external dependencies can run independently
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行无外部依赖的独立容器
- en: Operating transient containers for short-lived processes to minimize network
    exposure
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行短暂容器以处理短期进程，以最小化网络暴露
- en: Generally, use the none network driver if you need to isolate containers from
    any Docker and non-Docker processes for security reasons.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果您需要出于安全原因将容器与任何 Docker 和非 Docker 进程隔离，请使用 none 网络驱动。
- en: Enabling GPU Driver
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用 GPU 驱动
- en: If you have an NVIDIA graphics card with the CUDA toolkit and necessary drivers
    installed, then you can use the `--gpus=all` flag to enable GPU support for your
    containers in Docker.^([5](ch12.html#id1336))
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您安装了 CUDA 工具包和必要的驱动程序的 NVIDIA 图形卡，则可以使用 `--gpus=all` 标志来启用 Docker 中容器的 GPU
    支持.^([5](ch12.html#id1336))
- en: 'To test that your system has the necessary drivers and supports GPU in Docker,
    run the following command to benchmark your GPU:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试您的系统是否具有必要的驱动程序并支持 Docker 中的 GPU，请运行以下命令以基准测试您的 GPU：
- en: '[PRE32]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-382
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also use the NVIDIA system management interface `nvidia-smi` tool to
    help manage and monitor NVIDIA GPU devices.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 NVIDIA 系统管理接口 `nvidia-smi` 工具来帮助管理和监控 NVIDIA GPU 设备。
- en: Deep learning frameworks such as `tensorflow` or `pytorch` can automatically
    detect and use the GPU device when running your applications in a GPU-enabled
    container. This includes Hugging Face libraries such as `transformers` that lets
    you self-host language models.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习框架如`tensorflow`或`pytorch`可以在GPU启用容器中运行您的应用程序时自动检测并使用GPU设备。这包括Hugging Face库如`transformers`，它允许您自托管语言模型。
- en: 'If using the `transformers` package, make sure to also install the `accelerate`
    library:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`transformers`包，请确保还安装了`accelerate`库：
- en: '[PRE33]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can now move the model to GPU before it’s loaded in CPU by using `device_map='cuda'`,
    as shown in [Example 12-8](#docker_gpu).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过使用`device_map='cuda'`将模型移动到GPU，在将其加载到CPU之前，如[示例12-8](#docker_gpu)所示。
- en: Example 12-8\. Transferring Hugging Face models to the GPU
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例12-8\. 将Hugging Face模型传输到GPU
- en: '[PRE34]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You should be able to run the predictions on the GPU by passing the `--gpus=all`
    flag to `docker run`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够通过向`docker run`传递`--gpus=all`标志来在GPU上运行预测。
- en: Docker Compose
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Compose
- en: In multicontainer environments, you can use the *Docker Compose* tool for defining
    and running application containers for a streamlined development and deployment
    experience.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在多容器环境中，您可以使用*Docker Compose*工具来定义和运行应用程序容器，以获得流畅的开发和部署体验。
- en: Using Docker Compose can help you simplify managing several containers, networks,
    volumes, variables, and secrets with a single *YAML configuration file*. This
    simplifies the complex task of orchestrating and coordinating various containers,
    making it easier to manage and replicate your services across different application
    environments using environment variables. You can also share the YAML file with
    others so that they can replicate your container environment. Additionally, it
    caches configurations to prevent re-creating containers when you restart services.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Compose可以帮助您通过单个*YAML配置文件*简化管理多个容器、网络、卷、变量和秘密。这简化了协调和协调各种容器的复杂任务，使得使用环境变量跨不同的应用程序环境管理和复制您的服务变得更加容易。您还可以与他人共享YAML文件，以便他们可以复制您的容器环境。此外，它缓存配置以防止在重启服务时重新创建容器。
- en: '[Example 12-9](#docker_compose) shows an example YAML configuration file.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例12-9](#docker_compose)展示了示例YAML配置文件。'
- en: Example 12-9\. Docker Compose YAML configuration file
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例12-9\. Docker Compose YAML配置文件
- en: '[PRE35]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[![1](assets/1.png)](#co_deployment_of_ai_services_CO4-1)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_deployment_of_ai_services_CO4-1)'
- en: Create the containers alongside the associated volumes, networks, and secrets.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 创建与相关卷、网络和秘密一起的容器。
- en: '[![2](assets/2.png)](#co_deployment_of_ai_services_CO4-2)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_deployment_of_ai_services_CO4-2)'
- en: Use the Dockerfile located at the same directory as the Compose file to build
    the `server` image.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与Compose文件相同的目录中的Dockerfile来构建`server`镜像。
- en: '[![3](assets/3.png)](#co_deployment_of_ai_services_CO4-3)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_deployment_of_ai_services_CO4-3)'
- en: Use Docker secrets to mask sensitive data like API keys within the container
    shell environment.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker secrets在容器shell环境中隐藏敏感数据，如API密钥。
- en: '[![4](assets/4.png)](#co_deployment_of_ai_services_CO4-4)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_deployment_of_ai_services_CO4-4)'
- en: Create a bridge `genai-net` network and attach both `server` and `db` containers
    to it.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`genai-net`的桥接网络，并将`server`和`db`容器附加到它。
- en: Tip
  id: totrans-405
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you have Docker objects like volumes and networks that you’re managing yourself,
    you can tag them with `external: true` in the compose file so that Docker Compose
    doesn’t manage them.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您正在自行管理Docker对象，如卷和网络，您可以在compose文件中将它们标记为`external: true`，这样Docker Compose就不会管理它们。'
- en: 'Once you have a `compose.yaml` file, you can then use simple compose commands
    to manage your containers:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了`compose.yaml`文件，您就可以使用简单的compose命令来管理您的容器：
- en: '[PRE36]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can use these commands to start/stop/restart services and view their logs
    or container statuses. Additionally, you can edit the Compose file shown in [Example 12-9](#docker_compose)
    to use `watch` so that your services are automatically updated as you edit and
    save your code.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些命令来启动/停止/重启服务，查看它们的日志或容器状态。此外，您还可以编辑[示例12-9](#docker_compose)中显示的Compose文件，使用`watch`以便在您编辑和保存代码时自动更新您的服务。
- en: '[Example 12-10](#docker_compose_watch) shows how to use the `watch` instruction
    on a given directory.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例12-10](#docker_compose_watch)展示了如何在指定目录上使用`watch`指令。'
- en: Example 12-10\. Enabling Docker Compose `watch` on a given directory
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例12-10\. 在指定目录上启用Docker Compose `watch`
- en: '[PRE37]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Whenever a file changes in the `./src` folder on your host machine, Compose
    will sync its content to `/code` and update the running application (server service)
    without restarting them.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在主机机器上的 `./src` 文件夹中的文件发生变化时，Compose 将将其内容同步到 `/code` 并更新正在运行的应用程序（服务器服务），而无需重新启动它们。
- en: 'You can then run the `watch` process using `docker compose watch`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 `docker compose watch` 运行 `watch` 进程：
- en: '[PRE38]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Docker Compose `watch` allows for greater granularity than is practical with
    bind mounts, as shown in [Example 12-9](#docker_compose). For instance, it lets
    you ignore specific files or entire directories within the watched tree to avoid
    I/O performance issues.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 的 `watch` 功能比使用绑定挂载更具有粒度，如[示例 12-9](#docker_compose) 所示。例如，它允许你忽略监视树中的特定文件或整个目录，以避免
    I/O 性能问题。
- en: Besides using Docker Compose `watch`, you can merge and override multiple Compose
    files to create a composite configuration tailored for specific build environments.
    Typically, the `compose.yml` file contains the base configurations, which can
    be overridden by an optional `compose.override.yml` file. For instance, as shown
    in [Example 12-11](#compose_override), you can inject local environment settings,
    mount local volumes, and create new a database service.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 Docker Compose 的 `watch` 功能外，你还可以合并和覆盖多个 Compose 文件，以创建针对特定构建环境的复合配置。通常，`compose.yml`
    文件包含基本配置，可以被可选的 `compose.override.yml` 文件覆盖。例如，如[示例 12-11](#compose_override)
    所示，你可以注入本地环境设置，挂载本地卷，并创建新的数据库服务。
- en: Example 12-11\. Merging and overriding Compose files for environment-specific
    build configurations
  id: totrans-418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-11\. 为特定构建配置合并和覆盖 Compose 文件
- en: '[PRE39]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[![1](assets/1.png)](#co_deployment_of_ai_services_CO5-1)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_deployment_of_ai_services_CO5-1]'
- en: The base Compose file contains instructions for running the production version
    of the application.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 基础 Compose 文件包含运行应用程序生产版本的说明。
- en: '[![2](assets/2.png)](#co_deployment_of_ai_services_CO5-2)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)[#co_deployment_of_ai_services_CO5-2]'
- en: Override base instructions by replacing the container start command, inject
    local variables, and add volume and networking configurations with a local database
    service.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 通过替换容器启动命令、注入本地变量以及添加本地数据库服务的卷和网络配置来覆盖基本说明。
- en: 'To use these files, run the following command:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些文件，请运行以下命令：
- en: '[PRE40]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Docker Compose will automatically merge configurations from both Compose files,
    applying the environment-specific settings from the override Compose file.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 将自动合并两个 Compose 文件中的配置，应用覆盖 Compose 文件中的环境特定设置。
- en: Enabling GPU Access in Docker Compose
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Docker Compose 中启用 GPU 访问
- en: To access GPU devices with services managed by Docker Compose, you’ll need to
    add the instructions to the composed file (see [Example 12-12](#DockerComposeapp)).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Docker Compose 管理的服务访问 GPU 设备，你需要将说明添加到组合文件中（参见[示例 12-12](#DockerComposeapp)）。
- en: Example 12-12\. Adding GPU configurations to the Docker Compose app service
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-12\. 将 GPU 配置添加到 Docker Compose 应用程序服务
- en: '[PRE41]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[![1](assets/1.png)](#co_deployment_of_ai_services_CO6-1)'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)[#co_deployment_of_ai_services_CO6-1]'
- en: Limit the number of GPU devices accessible by the app service.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 限制应用程序服务可访问的 GPU 设备数量。
- en: These instructions will give you more granular control over how your services
    should use your GPU resources.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这些说明将为你提供更细粒度的控制，以确定你的服务应该如何使用你的 GPU 资源。
- en: Optimizing Docker Images
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化 Docker 镜像
- en: If your Docker images grow in size, they’ll also be slower to run, build, and
    test in production. You’ll also be spending a lot of development time iterating
    over the development of the image.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Docker 镜像增大，它们在运行、构建和测试生产环境时也会变慢。你还将花费大量开发时间迭代图像的开发。
- en: In that case, it’s important to understand image optimization strategies, including
    how to use Docker’s layering mechanism to keep images lightweight and efficient
    to run, in particular with GenAI workloads.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，了解图像优化策略很重要，包括如何使用 Docker 的分层机制来保持图像轻量级且运行效率高，尤其是在 GenAI 工作负载中。
- en: 'These are a few ways to reduce image size and speed up the build process:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是减少图像大小并加快构建过程的一些方法：
- en: Using minimal base images
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最小基础镜像
- en: Avoiding GPU inference runtimes
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用 GPU 推理运行时
- en: Externalizing application data
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部化应用程序数据
- en: Layering ordering and caching
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层顺序和缓存
- en: Using multi-stage builds
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多阶段构建
- en: Implementing these optimizations as shown in [Table 12-4](#build_optimization_impact)
    may reduce typical image sizes from several gigabytes to less than 1 GB. Similarly,
    build times can reduce from several minutes on average to less than a minute.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 实施如图12-4所示的优化可能将典型镜像的大小从几个GB减少到不到1GB。同样，构建时间可以从平均几分钟减少到不到一分钟。
- en: Table 12-4\. Impact of build optimization on a typical image^([a](ch12.html#id1343))
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 表12-4\. 构建优化对典型镜像的影响^([a](ch12.html#id1343))
- en: '| Optimization step | Build time (seconds) | Image size (GB) |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| 优化步骤 | 构建时间（秒） | 镜像大小（GB） |'
- en: '| --- | --- | --- |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Initial | 352.9 | 1.42 |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| 初始 | 352.9 | 1.42 |'
- en: '| Using minimal base images | 38.5 | 1.38 |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| 使用最小基础镜像 | 38.5 | 1.38 |'
- en: '| Use caching | 24.4 | 1.38 |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| 使用缓存 | 24.4 | 1.38 |'
- en: '| Layer ordering | 17.9 | 1.38 |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| 层次排序 | 17.9 | 1.38 |'
- en: '| Multi-stage builds | 10.3 | 0.034 (34 MB) |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| 多阶段构建 | 10.3 | 0.034（34 MB）|'
- en: '| ^([a](ch12.html#id1343-marker)) Source: [warpbuild.com](https://www.warpbuild.com)
    |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch12.html#id1343-marker)) 来源：[warpbuild.com](https://www.warpbuild.com)
    |'
- en: Let’s review each in more detail with code examples for clarity.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码示例来更详细地回顾每个步骤，以增加清晰度。
- en: Use minimal base image
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用最小基础镜像
- en: Base images allow you to start from a preconfigured image so you don’t have
    to install everything from scratch, including the Python interpreter. However,
    some base images available on the Docker Hub may not be suitable for production
    deployments. Instead, you’ll want to select the right base image with a minimal
    OS footprint to work from for faster builds and smaller image sizes, possibly
    with pre-installed Python dependencies and support for installing its various
    packages.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 基础镜像允许您从一个预配置的镜像开始，这样您就不需要从头开始安装所有内容，包括Python解释器。然而，Docker Hub上的一些基础镜像可能不适合生产部署。相反，您将想要选择具有最小OS占用空间的基础镜像，以便进行更快的构建和更小的镜像大小，可能包括预安装的Python依赖项以及支持安装其各种包。
- en: Alpine base images use a lightweight Alpine Linux distribution designed to be
    small and secure, containing only the *base minimum* essential tools to run your
    application, but this won’t support installing many Python packages. On the other
    hand, slim base images may use other Linux distributions like Debian or CentOS,
    containing the *necessary* essential tools for running applications that make
    them larger than Alpine base images.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine基础镜像使用轻量级的Alpine Linux发行版，旨在小巧和安全，仅包含运行您的应用程序所需的*基本最小*工具，但这不支持安装许多Python包。另一方面，slim基础镜像可能使用其他Linux发行版，如Debian或CentOS，包含运行应用程序所需的*必要*基本工具，这使得它们比Alpine基础镜像更大。
- en: Tip
  id: totrans-457
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use slim base images if you care about build time and Alpine base images if
    you care about image size.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您关心构建时间，请使用slim基础镜像；如果您关心镜像大小，请使用Alpine基础镜像。
- en: 'You can use the `slim` base images such as `python:3.12-slim` or even Alpine
    base images like `python:3.12-alpine` that can be as small as 71.4 MB. A bare-bones
    Alpine image can even go down to 12.1 MB. The following command shows a list of
    base images pulled from the Docker repository:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`slim`基础镜像，如`python:3.12-slim`，甚至更小的Alpine基础镜像，如`python:3.12-alpine`，其大小可小至71.4MB。一个裸机Alpine镜像甚至可以降至12.1MB。以下命令显示了从Docker仓库拉取的基础镜像列表：
- en: '[PRE42]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Tip
  id: totrans-461
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Standard-sized images typically contain a full Linux distribution like Ubuntu
    or Debian containing a variety of pre-installed packages and dependencies, making
    them suitable for local development but perhaps not production environments.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 标准大小的镜像通常包含完整的Linux发行版，如Ubuntu或Debian，包含各种预安装的包和依赖项，这使得它们适合本地开发，但可能不适合生产环境。
- en: Avoid GPU inference runtimes
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免GPU推理运行时
- en: In AI workloads where you’re serving ML/GenAI models, you may need to install
    deep learning frameworks, dependencies, and GPU libraries that can suddenly explode
    the footprint of your images. For instance, to make inferences on a GPU using
    the `transformers` library, you’ll need to install 3 GB of NVIDIA packages for
    GPU inference, 1.6 GB for the `torch` to perform the inference.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在您服务于机器学习/通用人工智能模型的AI工作负载中，您可能需要安装深度学习框架、依赖项和GPU库，这可能会突然扩大您镜像的占用空间。例如，为了使用`transformers`库在GPU上进行推理，您需要安装3GB的NVIDIA推理包，以及1.6GB的`torch`进行推理。
- en: Unfortunately, you can’t reduce the image size if you need to use a GPU to perform
    an inference. However, if you can avoid GPU inference and just rely on CPUs, you
    may be able to reduce the image size by up to 10 times using the Open Neural Network
    Exchange (ONNX) runtime with model quantization.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果您需要使用 GPU 进行推理，则无法减小镜像大小。但是，如果您可以避免 GPU 推理并仅依赖 CPU，则可能通过使用具有模型量化的 Open
    Neural Network Exchange (ONNX) 运行时将镜像大小减少多达 10 倍。
- en: As discussed in [Chapter 10](ch10.html#ch10), you can use the INT8 quantization
    with an ONNX model to benefit from model compression without much loss in output
    quality.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第 10 章](ch10.html#ch10)中所述，您可以使用 ONNX 模型进行 INT8 量化，以在不损失太多输出质量的情况下从模型压缩中受益。
- en: 'To switch from the GPU inference runtime to the ONNX runtime for Hugging Face
    transformer models, you can use the `transformers[onnx]` package:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 GPU 推理运行时切换到 Hugging Face transformer 模型的 ONNX 运行时，您可以使用 `transformers[onnx]`
    包：
- en: '[PRE43]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can then export any Hugging Face transformer model checkpoint with default
    configurations to the ONNX format with `transformers.onnx`:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用 `transformers.onnx` 将任何 Hugging Face transformer 模型检查点以默认配置导出到 ONNX
    格式：
- en: '[PRE44]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This command exports the `distilbert/distilbert-base-uncased` model checkpoint
    as an ONNX graph stored in `onnx/model.onnx`, which can be run with any Hugging
    Face model accelerator that supports the ONNX standard, as shown in [Example 12-13](#docker_onnx).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将 `distilbert/distilbert-base-uncased` 模型检查点导出为存储在 `onnx/model.onnx` 中的 ONNX
    图，可以使用支持 ONNX 标准的任何 Hugging Face 模型加速器运行，如[示例 12-13](#docker_onnx)所示。
- en: Example 12-13\. Model inference using the ONNX runtime with quantization
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-13\. 使用量化进行 ONNX 运行时的模型推理
- en: '[PRE45]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![1](assets/1.png)](#co_deployment_of_ai_services_CO7-1)'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_deployment_of_ai_services_CO7-1)'
- en: ONNX runtime expects `numpy` arrays as input.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: ONNX 运行时期望输入 `numpy` 数组。
- en: Using a technique such as shown in [Example 12-13](#docker_onnx), you can downsize
    from image sizes between 5 and 10 GB to around 0.5 GB, which is a massive footprint
    reduction, significantly more cost-effective and scalable.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如[示例 12-13](#docker_onnx)中所示的技术，您可以将图像大小从 5 到 10 GB 缩小到大约 0.5 GB，这实现了巨大的足迹减少，显著提高了成本效益和可扩展性。
- en: Externalize application data
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部化应用程序数据
- en: A core contributor to image size is copying models and application data into
    the image during build time. This approach increases both the build time and image
    size.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 图像大小的一个核心贡献者是，在构建时将模型和应用程序数据复制到镜像中。这种方法增加了构建时间和镜像大小。
- en: A better approach is to use volumes during local development and external storage
    solutions for downloading and loading models at application startup in production.
    In Kubernetes container orchestration environments, you can also use persistent
    volumes for model storage.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是，在本地开发期间使用卷，在生产环境中启动应用程序时使用外部存储解决方案下载和加载模型。在 Kubernetes 容器编排环境中，您还可以使用持久卷来存储模型。
- en: Tip
  id: totrans-480
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: If your application container takes a long time to download data and model artifacts
    from an external source, your health checks may fail, and the hosting platform
    can kill your containers prematurely. In such cases, configure health check probes
    to wait longer or as a last resort, bake the model into the image.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序容器从外部源下载数据和时间较长的模型工件，则健康检查可能会失败，托管平台可能会提前终止您的容器。在这种情况下，配置健康检查探测器以等待更长的时间，或者作为最后的手段，将模型烘焙到镜像中。
- en: Layer ordering and caching
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 层次和缓存
- en: Docker uses a layered filesystem to create layers in an image for each instruction
    in the Dockerfile. These layers are like a stack, with each layer adding more
    content on top of the previous layers. Whenever a layer changes, that layer (and
    further layers) will need to be rebuilt for those changes to appear in the image
    (i.e., build cache must be invalidated).
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 使用分层文件系统在 Dockerfile 的每个指令中为每个镜像创建层。这些层就像一个堆栈，每个层在上一层的顶部添加更多内容。每当层发生变化时，该层（以及后续层）都需要重建，以便这些更改在镜像中显示出来（即，必须使构建缓存无效）。
- en: A layer (i.e., a filesystem snapshot) is created if the instruction is writing
    or deleting files into the container’s union filesystem.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指令是向容器联合文件系统写入或删除文件，则会创建一个层（即文件系统快照）。
- en: Tip
  id: totrans-485
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Dockerfile instructions that modify the filesystem like `ENV`, `COPY`, `ADD`,
    and `RUN` will contribute new layers to the build process, effectively increasing
    the image size. On the other hand, instructions such as `WORKDIR`, `ENTRYPOINT`,
    `LABEL`, and `CMD` that only update the image metadata don’t create any layers
    and any build cache.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 修改文件系统的Dockerfile指令，如`ENV`、`COPY`、`ADD`和`RUN`，将为构建过程贡献新的层，从而有效增加镜像大小。另一方面，仅更新镜像元数据的指令，如`WORKDIR`、`ENTRYPOINT`、`LABEL`和`CMD`，不会创建任何层，也不会创建任何构建缓存。
- en: After creation, each layer is then cached for reusability across image rebuilds
    if the instruction and files it depends on haven’t changed since the last build.
    Therefore, ideally, you want to write a Dockerfile that allows you to stop, destroy,
    rebuild, and replace containers with minimal setup and configuration.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，每个层都会缓存起来，以便在镜像重建过程中重用，前提是自上次构建以来指令及其依赖的文件没有发生变化。因此，理想情况下，您希望编写一个Dockerfile，允许您停止、销毁、重建和替换容器，同时设置和配置最小化。
- en: There are a few techniques you can use to minimize and optimize these layers
    as much as possible.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用一些技术尽可能最小化和优化这些层。
- en: Layer ordering to avoid frequent cache invalidation
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 避免频繁缓存失效的层排序
- en: Since changes to the earlier layers can invalidate the build cache leading to
    repeating steps, you should order your Dockerfile from the most stable (e.g.,
    installations) to the most frequently changing or volatile (e.g., application
    code, configuration files).
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 由于早期层的更改可能导致构建缓存失效并导致重复步骤，因此您应该从最稳定的（例如，安装）到最频繁更改或易变的（例如，应用程序代码、配置文件）对Dockerfile进行排序。
- en: Following this ordering, place the most stable yet expensive instructions (e.g.,
    model downloads or heavy dependency installations) at the start of the Dockerfile,
    and volatile, fast operations (e.g., copying application code) at the bottom.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 按照此顺序，将最稳定但昂贵的指令（例如，模型下载或重型依赖安装）放在Dockerfile的开头，将易变、快速的操作（例如，复制应用程序代码）放在底部。
- en: 'Imagine your Dockerfile file looks like this:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下您的Dockerfile文件看起来像这样：
- en: '[PRE46]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here you’re creating a layer by copying your working directory containing the
    application code into the image before downloading and installing dependencies.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您通过在下载和安装依赖项之前将包含应用程序代码的工作目录复制到镜像中来创建一个层。
- en: If any one of source files changes, Docker builder will invalidate the cache
    causing the dependency installation to be repeated, which is expensive and can
    take several minutes to complete, if not cached by `pip`.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何源文件发生变化，Docker构建者将使缓存失效，导致依赖安装重复，这既昂贵又可能需要几分钟才能完成，除非通过`pip`缓存。
- en: 'To avoid repeating expensive steps, you can logically order your Dockerfile
    instructions to optimize the layer caching by reordering instructions like these:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复昂贵的步骤，您可以逻辑地排序您的Dockerfile指令，通过重新排序这些指令来优化层缓存：
- en: '[PRE47]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now any changes to the source files won’t affect the long dependency installation
    step, drastically speeding up the build process.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何对源文件的更改都不会影响漫长的依赖安装步骤，从而大大加快构建过程。
- en: Minimize layers
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最小化层
- en: To keep image sizes small, you’ll want to minimize image layers as much as possible.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持镜像大小小，您需要尽可能最小化镜像层。
- en: 'A simple technique to achieve this is to combine multiple `RUN` instructions
    into one. For instance, instead of writing multiple `RUN apt-get` installations,
    you can combine them into a single `RUN` command with `&&`:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的简单方法是将多个`RUN`指令合并为一个。例如，您不必编写多个`RUN apt-get`安装指令，而是可以将它们合并为一个带有`&&`的单个`RUN`命令：
- en: '[PRE48]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will avoid adding unnecessary layers and prevents caching issues with `apt-get
    update` using the *cache busting* technique.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这将避免添加不必要的层，并使用*缓存破坏*技术防止`apt-get update`出现缓存问题。
- en: Since the builder may potentially skip updating the package index, causing installations
    to fail or use outdated packages, using the `&&` ensures that the latest packages
    are installed if the package index is updated.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构建者可能跳过更新包索引，导致安装失败或使用过时的包，使用`&&`确保如果包索引已更新，则安装最新包。
- en: Tip
  id: totrans-505
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also use the `--no-cache` flag when using `docker build` to avoid cache
    hits and ensure fresh downloads of base images and dependencies on every build.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`docker build`时，您也可以使用`--no-cache`标志来避免缓存命中并确保每次构建都下载和依赖最新镜像。
- en: Keep build context small
  id: totrans-507
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 保持构建上下文小
- en: The *build context* is the set of files and directories that’ll be sent to the
    builder to carry out the Dockerfile instruction. A smaller build context reduces
    the amount of data sent to the builder and lowers the chance of cache invalidation,
    resulting in faster builds.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '*构建上下文*是发送给构建器以执行Dockerfile指令的一组文件和目录。较小的构建上下文可以减少发送给构建器的数据量，降低缓存失效的可能性，从而加快构建速度。'
- en: When you use the `COPY . .` command in a Dockerfile to copy your working directory
    into an image, you may also add tool caches, development dependencies, virtual
    environments, and unused files into the build context. Not only the image size
    will be increased, but also the Docker builder will cache these unnecessary files.
    Any changes to these files will then invalidate the build, restarting the whole
    build process.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Dockerfile中使用`COPY . .`命令将工作目录复制到镜像中时，你也可以将工具缓存、开发依赖、虚拟环境和未使用的文件添加到构建上下文中。这不仅会增加镜像的大小，而且Docker构建器还会缓存这些不必要的文件。对这些文件的任何更改都将使构建失效，并重新启动整个构建过程。
- en: 'To prevent the unnecessary cache invalidation, you can add a *.dockerignore*
    file next to your Dockerfile, listing all files and directories that your services
    won’t need in production. As an example, here are items you can include in a *.dockerignore*
    file:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止不必要的缓存失效，你可以在Dockerfile旁边添加一个*.dockerignore*文件，列出你的服务在生产中不需要的所有文件和目录。例如，以下是可以包含在*.dockerignore*文件中的项目：
- en: '[PRE49]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Docker builder will then ignore these files even when you run the `COPY` command
    across your entire working directory.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在整个工作目录中运行`COPY`命令，Docker构建器也会忽略这些文件。
- en: Use cache and bind mounts
  id: totrans-513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用缓存和绑定挂载
- en: You can use *bind mounts* to avoid adding unnecessary layers to the image and
    *cache mounts* to speed up subsequent builds.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*绑定挂载*来避免向镜像添加不必要的层，并使用*缓存挂载*来加快后续构建。
- en: Bind mounts temporarily include files in the build context for a single `RUN`
    instruction and won’t persist as image layers after. Cache mounts specify a persistent
    cache location that you can read and write data to across multiple builds.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定挂载临时将文件包含在构建上下文中，用于单个`RUN`指令，并在之后不会作为镜像层持久化。缓存挂载指定一个持久的缓存位置，你可以在多个构建之间读取和写入数据。
- en: 'Here is an example where you can download a pretrained model from Hugging Face
    into a mounted cache to optimize layer caching:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，你可以从Hugging Face下载预训练模型到挂载的缓存中，以优化层缓存：
- en: '[PRE50]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This `RUN` instruction creates a cache of the downloaded pretrained model at
    `/root/.cache/huggingface`, which can be shared across multiple builds. This helps
    avoid redundant downloads and optimizes the build process by reusing cached layers.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`RUN`指令在`/root/.cache/huggingface`创建了一个下载的预训练模型的缓存，这可以在多个构建之间共享。这有助于避免重复下载，并通过重用缓存层优化构建过程。
- en: You can also use the `--no-cache-dir` flag when using the `pip` package manager
    to avoid caching altogether for minimizing image size. However, you’ll have a
    significantly slower build process as follow-on builds will need to redownload
    each time.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`pip`包管理器中使用`--no-cache-dir`标志来避免完全缓存，以最小化镜像大小。然而，构建过程将显著变慢，因为后续构建每次都需要重新下载。
- en: Use external cache
  id: totrans-520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用外部缓存
- en: If you’re building and deploying containers using a CI/CD pipeline, you can
    benefit from an external cache hosted on a remote location. An external cache
    can drastically speed up the build process in CI/CD pipelines where builders are
    often ephemeral and build minutes are precious.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用CI/CD管道构建和部署容器，你可以从远程位置托管的外部缓存中受益。外部缓存可以显著加快CI/CD管道中的构建过程，在这些管道中，构建器通常是短暂的，构建时间非常宝贵。
- en: 'To use an external cache, you can specify the `--cache-to` and `--cache-from`
    options with the `docker buildx build` command:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用外部缓存，你可以使用`docker buildx build`命令指定`--cache-to`和`--cache-from`选项：
- en: '[PRE51]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Besides layer ordering and cache optimization, you can use multi-stage builds
    to significantly shrink your image sizes.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 除了层排序和缓存优化之外，你还可以使用多阶段构建来显著减小镜像大小。
- en: Multi-stage builds
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多阶段构建
- en: Using *multi-stage builds*, you can reduce the size of your final image by splitting
    out the Dockerfile instructions into distinct stages. Common stages can be reused
    to include shared components and serve as a starting point for further stages.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*多阶段构建*，你可以通过将Dockerfile指令拆分为不同的阶段来减小最终镜像的大小。常见的阶段可以被重用来包含共享组件，并作为后续阶段的起点。
- en: You can also selectively copy artifacts from one stage to another, leaving behind
    everything you don’t want in the final image. This ensures that only the required
    outputs are included in the final image from previous stages, avoiding any non-essential
    artifacts. Furthermore, you can also execute multiple build stages in parallel
    to speed up the build process of your images.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以选择性地从某个阶段复制工件到另一个阶段，保留您不希望在最终镜像中保留的所有内容。这确保了只有之前阶段所需的输出包含在最终镜像中，避免了任何非必要的工件。此外，您还可以并行执行多个构建阶段以加快镜像构建过程。
- en: A common multi-stage build pattern is when you need a testing/development image
    and a slimmer production one with both starting from a shared first stage image.
    The development or testing image can include additional layers of tooling (i.e.,
    compilers, build systems, and debugging tools) to support the required workflows.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要一个用于测试/开发的镜像和一个从共享的第一阶段镜像开始的更精简的生产镜像时，常见的多阶段构建模式。开发或测试镜像可以包含额外的工具层（例如，编译器、构建系统和调试工具），以支持所需的流程。
- en: Imagine you need to serve a bert transformer model from Hugging Face in a FastAPI
    service. You can write your Dockerfile instructions to use three distinct sequential
    stages.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要在 FastAPI 服务中提供来自 Hugging Face 的 bert transformer 模型。您可以编写 Dockerfile 指令以使用三个不同的顺序阶段。
- en: 'The first stage downloads the transformer model into `/root/.cache/huggingface`
    and creates a Python virtual environment at `/opt/venv`:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个阶段将转换器模型下载到 `/root/.cache/huggingface`，并在 `/opt/venv` 创建一个 Python 虚拟环境：
- en: '[PRE52]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The second stage then copies the model artifacts and virtual Python environment
    `/opt/ven` from the `base` stage before copying source files over and creating
    a production version of the FastAPI service:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 然后第二个阶段会从`base`阶段复制模型工件和虚拟 Python 环境 `/opt/ven`，然后再复制源文件并创建 FastAPI 服务的生产版本：
- en: '[PRE53]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The last stage copies the production stage virtual Python environment with
    installed packages and adds several development tools on top. It then starts the
    server with hot reload functionality:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个阶段复制了带有已安装包的生产阶段虚拟 Python 环境，并在其上添加了几个开发工具。然后它启动服务器，具有热重载功能：
- en: '[PRE54]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Using a single Dockerfile, we were able to create three distinct stages and
    use them as we see fit via the `--target development` command when needed.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个 Dockerfile，我们能够创建三个不同的阶段，并在需要时通过`--target development`命令按需使用它们。
- en: docker init
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker init
- en: You now have an in-depth understanding of the containerization process with
    the Docker platform and the relevant best practices.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在对使用 Docker 平台的容器化过程以及相关最佳实践有了深入的了解。
- en: 'If you ever need to add Docker to an existing project, you can use the `docker
    init` command, which will guide you through a wizard to create all the necessary
    Docker deployment files in your current working directory:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要将 Docker 添加到现有项目中，可以使用`docker init`命令，该命令将引导您通过向导在当前工作目录中创建所有必要的 Docker
    部署文件：
- en: '[PRE55]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This will provide a great starting point that you can work from to include additional
    configuration steps, dependencies, or services as required.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供一个很好的起点，您可以从中添加额外的配置步骤、依赖项或服务。
- en: Tip
  id: totrans-542
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: I recommend using `docker init` when starting out as every generated file will
    adhere to best practices including leveraging `dockerignore`, optimizing image
    layers, using bind and cache mounts for package installation, and switching to
    nonroot users.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在入门时使用`docker init`，因为每个生成的文件都将遵循最佳实践，包括利用`dockerignore`、优化镜像层、使用绑定和缓存挂载进行包安装，以及切换到非root用户。
- en: Once you have an optimized image and a set of working containers, you can choose
    any cloud provider or self-hosting solution for pushing images to registries and
    deploying your new GenAI services.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有一个优化的镜像和一组工作容器，您可以选择任何云提供商或自托管解决方案来推送镜像到注册表并部署您的新 GenAI 服务。
- en: Summary
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed various strategies for deploying your GenAI services—for
    instance, on virtual machines, as cloud functions, with managed app service platforms,
    or via containers. As part of this, I covered how virtualization differs from
    containerization and why you may want to deploy your services as containers.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了部署您的 GenAI 服务的各种策略——例如，在虚拟机上、作为云函数、使用托管应用服务平台或通过容器。作为其中的一部分，我介绍了虚拟化与容器化的区别以及为什么您可能希望将服务作为容器部署。
- en: Next, you learned about the Docker containerization platform and how you can
    use it to build self-contained images of your applications that can run as containers.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您学习了Docker容器化平台以及如何使用它来构建应用程序的自包含镜像，这些镜像可以作为容器运行。
- en: We covered the Docker storage and networking mechanisms that allow you to persist
    data using the union filesystem in containers and how to connect containers with
    different networking drivers.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了Docker存储和网络机制，这些机制允许您使用联合文件系统在容器中持久化数据，以及如何连接具有不同网络驱动的容器。
- en: Finally, you were introduced to various optimization techniques for reducing
    the build time and size of your images to deploy your GenAI services as efficiently
    as possible.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您了解了各种优化技术，以减少构建时间和大小，以便尽可能高效地部署您的GenAI服务。
- en: With services containerized, you can push them to container registries to share,
    distribute, and run them on any cloud or hosting environment of your choice.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务容器化后，您可以将其推送到容器注册库以共享、分发，并在您选择的任何云或托管环境中运行。
- en: ^([1](ch12.html#id1291-marker)) Slim base Python images balance the size and
    compatibility of the Linux distribution with a wider range of Python packages
    out of the box compared to Alpine base Python images that minimize size but require
    extra configurations.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch12.html#id1291-marker)) 与最小化大小的Alpine基础Python镜像相比，精简的基础Python镜像在出厂时提供了更广泛的Python包，同时平衡了Linux发行版的尺寸和兼容性。
- en: ^([2](ch12.html#id1292-marker)) You can use the `-p` or `--publish` flag when
    running the container to map and enable container access via a port.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch12.html#id1292-marker)) 在运行容器时，您可以使用`-p`或`--publish`标志来映射并启用通过端口访问容器的功能。
- en: ^([3](ch12.html#id1297-marker)) Images built on one machine can only run on
    other machines with the same processor architecture.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch12.html#id1297-marker)) 在一台机器上构建的镜像只能在具有相同处理器架构的其他机器上运行。
- en: ^([4](ch12.html#id1317-marker)) You can still run executable files with the
    `r` permission alone by using the `bash script.sh` command instead of `./script.sh`.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch12.html#id1317-marker)) 您可以通过使用`bash script.sh`命令而不是`./script.sh`，仅使用`r`权限来运行可执行文件。
- en: ^([5](ch12.html#id1336-marker)) Refer to the NVIDIA documentation on how to
    install the latest CUDA toolkit and graphics drivers for your system.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch12.html#id1336-marker)) 请参考NVIDIA文档了解如何为您的系统安装最新的CUDA工具包和图形驱动程序。
