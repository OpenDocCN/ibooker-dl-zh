- en: Appendix A. Autodiff
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. 自动微分
- en: This appendix explains how PyTorch’s automatic differentiation (autodiff) feature
    works, and how it compares to other solutions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录解释了 PyTorch 的自动微分（autodiff）功能是如何工作的，以及它与其他解决方案的比较。
- en: Suppose you define a function *f*(*x*, *y*) = *x*²*y* + *y* + 2, and you need
    its partial derivatives ∂*f*/∂*x* and ∂*f*/∂*y*, typically to perform gradient
    descent (or some other optimization algorithm). Your main options are manual differentiation,
    finite difference approximation, forward-mode autodiff, and reverse-mode autodiff.
    PyTorch implements reverse-mode autodiff, but to fully understand it, it’s useful
    to look at the other options first. So let’s go through each of them, starting
    with manual differentiation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你定义了一个函数 *f*(*x*, *y*) = *x*²*y* + *y* + 2，你需要它的偏导数 ∂*f*/∂*x* 和 ∂*f*/∂*y*，通常用于执行梯度下降（或某些其他优化算法）。你的主要选项是手动微分、有限差分近似、前向模式自动微分和反向模式自动微分。PyTorch
    实现了反向模式自动微分，但要完全理解它，先看看其他选项是有用的。所以，让我们逐一来看每个选项，从手动微分开始。
- en: Manual Differentiation
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动微分
- en: 'The first approach to compute derivatives is to pick up a pencil and a piece
    of paper and use your calculus knowledge to derive the appropriate equation. For
    the function *f*(*x*, *y*) just defined, it is not too hard; you just need to
    use five rules:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 计算导数的第一个方法是拿起一支铅笔和一张纸，并使用你的微积分知识来推导适当的方程。对于刚刚定义的函数 *f*(*x*, *y*)，这并不太难；你只需要使用五条规则：
- en: The derivative of a constant is 0.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常数的导数是 0。
- en: The derivative of *λx* is *λ* (where *λ* is a constant).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*λx* 的导数是 *λ*（其中 *λ* 是一个常数）。'
- en: The derivative of *x*^λ is *λx*^(*λ*) ^– ¹, so the derivative of *x*² is 2*x*.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x*^λ 的导数是 *λx*^(*λ*) ^– ¹，所以 *x*² 的导数是 2*x*。'
- en: The derivative of a sum of functions is the sum of these functions’ derivatives.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和的导数是这些函数导数的和。
- en: The derivative of *λ* times a function is *λ* times its derivative.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数乘以 *λ* 的导数是 *λ* 乘以其导数。
- en: From these rules, you can derive [Equation A-1](#partial_derivatives_equations).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些规则中，你可以推导出[方程 A-1](#partial_derivatives_equations)。
- en: Equation A-1\. Partial derivatives of *f*(*x*, *y*)
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程 A-1\. 函数 *f*(*x*, *y*) 的偏导数
- en: <mtable displaystyle="true"><mtr><mtd columnalign="right"><mstyle scriptlevel="0"
    displaystyle="true"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow> <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac></mstyle></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mi>y</mi><mo>)</mo></mrow> <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac></mstyle>
    <mo>+</mo> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mi>y</mi></mrow>
    <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac></mstyle> <mo>+</mo> <mstyle scriptlevel="0"
    displaystyle="true"><mfrac><mrow><mi>∂</mi><mn>2</mn></mrow> <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac></mstyle>
    <mo>=</mo> <mi>y</mi> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>)</mo></mrow> <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac></mstyle>
    <mo>+</mo> <mn>0</mn> <mo>+</mo> <mn>0</mn> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mi>y</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>y</mi></mrow></mfrac></mstyle></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mi>y</mi><mo>)</mo></mrow> <mrow><mi>∂</mi><mi>y</mi></mrow></mfrac></mstyle>
    <mo>+</mo> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mi>y</mi></mrow>
    <mrow><mi>∂</mi><mi>y</mi></mrow></mfrac></mstyle> <mo>+</mo> <mstyle scriptlevel="0"
    displaystyle="true"><mfrac><mrow><mi>∂</mi><mn>2</mn></mrow> <mrow><mi>∂</mi><mi>y</mi></mrow></mfrac></mstyle>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn> <mo>+</mo>
    <mn>0</mn> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></mtd></mtr></mtable>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <mtable displaystyle="true"><mtr><mtd columnalign="right"><mstyle scriptlevel="0"
    displaystyle="true"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow> <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac></mstyle></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mi>y</mi><mo>)</mo></mrow> <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac></mstyle>
    <mo>+</mo> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mi>y</mi></mrow>
    <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac></mstyle> <mo>+</mo> <mstyle scriptlevel="0"
    displaystyle="true"><mfrac><mrow><mi>∂</mi><mn>2</mn></mrow> <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac></mstyle>
    <mo>=</mo> <mi>y</mi> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>)</mo></mrow> <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac></mstyle>
    <mo>+</mo> <mn>0</mn> <mo>+</mo> <mn>0</mn> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mi>y</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>y</mi></mrow></mfrac></mstyle></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mi>y</mi><mo>)</mo></mrow> <mrow><mi>∂</mi><mi>y</mi></mrow></mfrac></mstyle>
    <mo>+</mo> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>∂</mi><mi>y</mi></mrow>
    <mrow><mi>∂</mi><mi>y</mi></mrow></mfrac></mstyle> <mo>+</mo> <mstyle scriptlevel="0"
    displaystyle="true"><mfrac><mrow><mi>∂</mi><mn>2</mn></mrow> <mrow><mi>∂</mi><mi>y</mi></mrow></mfrac></mstyle>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn> <mo>+</mo>
    <mn>0</mn> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></mtd></mtr></mtable>
- en: This approach can become very tedious for more complex functions, and you run
    the risk of making mistakes. Fortunately, there are other options. Let’s look
    at finite difference approximation now.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于更复杂的函数来说可能会变得非常繁琐，而且你可能会犯错误。幸运的是，还有其他选择。现在让我们看看有限差分近似。
- en: Finite Difference Approximation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有限差分近似
- en: Recall that the derivative *h*′(*x*[0]) of a function *h*(*x*) at a point *x*[0]
    is the slope of the function at that point. More precisely, the derivative is
    defined as the limit of the slope of a straight line going through this point
    *x*[0] and another point *x* on the function, as *x* gets infinitely close to
    *x*[0] (see [Equation A-2](#derivative_definition)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，函数 *h*(*x*) 在点 *x*[0] 的导数 *h*′(*x*[0]) 是该点处函数的斜率。更精确地说，导数定义为通过该点 *x*[0]
    和函数上的另一个点 *x* 的直线的斜率的极限，当 *x* 无限接近 *x*[0] 时（见[方程 A-2](#derivative_definition)）。
- en: Equation A-2\. Definition of the derivative of a function *h*(*x*) at point
    *x*[0]
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程 A-2\. 函数 *h*(*x*) 在点 *x*[0] 的导数定义
- en: <mrow><msup><mi>h</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>0</mn></msub>
    <mo>)</mo></mrow></mrow> <mrow><mo>=</mo> <munder><mo movablelimits="true" form="prefix">lim</mo>
    <mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>→</mo><msub><mi>x</mi>
    <mn>0</mn></msub></mrow></mstyle></munder> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>h</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>-</mo><mi>h</mi><mrow><mo>(</mo><msub><mi>x</mi>
    <mn>0</mn></msub> <mo>)</mo></mrow></mrow> <mrow><mi>x</mi><mo>-</mo><msub><mi>x</mi>
    <mn>0</mn></msub></mrow></mfrac></mstyle></mrow> <mrow><mo>=</mo> <munder><mo
    movablelimits="true" form="prefix">lim</mo> <mstyle scriptlevel="0" displaystyle="false"><mrow><mi>ε</mi><mo>→</mo><mn>0</mn></mrow></mstyle></munder>
    <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>h</mi><mrow><mo>(</mo><msub><mi>x</mi>
    <mn>0</mn></msub> <mo>+</mo><mi>ε</mi><mo>)</mo></mrow><mo>-</mo><mi>h</mi><mrow><mo>(</mo><msub><mi>x</mi>
    <mn>0</mn></msub> <mo>)</mo></mrow></mrow> <mi>ε</mi></mfrac></mstyle></mrow>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <mrow><msup><mi>h</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>0</mn></msub>
    <mo>)</mo></mrow></mrow> <mrow><mo>=</mo> <munder><mo movablelimits="true" form="prefix">lim</mo>
    <mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>→</mo><msub><mi>x</mi>
    <mn>0</mn></msub></mrow></mstyle></munder> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>h</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>-</mo><mi>h</mi><mrow><mo>(</mo><msub><mi>x</mi>
    <mn>0</mn></msub> <mo>)</mo></mrow></mrow> <mrow><mi>x</mi><mo>-</mo><msub><mi>x</mi>
    <mn>0</mn></msub></mrow></mfrac></mstyle></mrow> <mrow><mo>=</mo> <munder><mo
    movablelimits="true" form="prefix">lim</mo> <mstyle scriptlevel="0" displaystyle="false"><mrow><mi>ε</mi><mo>→</mo><mn>0</mn></mrow></mstyle></munder>
    <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>h</mi><mrow><mo>(</mo><msub><mi>x</mi>
    <mn>0</mn></msub> <mo>+</mo><mi>ε</mi><mo>)</mo></mrow><mo>-</mo><mi>h</mi><mrow><mo>(</mo><msub><mi>x</mi>
    <mn>0</mn></msub> <mo>)</mo></mrow></mrow> <mi>ε</mi></mfrac></mstyle></mrow>
- en: 'So if we wanted to calculate the partial derivative of *f*(*x*, *y*) with regard
    to *x* at *x* = 3 and *y* = 4, we could compute *f*(3 + *ε*, 4) – *f*(3, 4) and
    divide the result by *ε*, using a very small value for *ε*. This type of numerical
    approximation of the derivative is called a *finite difference approximation*,
    and this specific equation is called *Newton’s difference quotient*. That’s exactly
    what the following code does:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想计算函数*f*(*x*, *y*)关于*x*在*x* = 3和*y* = 4处的偏导数，我们可以计算*f*(3 + *ε*, 4) –
    *f*(3, 4)，并将结果除以*ε*，使用一个非常小的*ε*值。这种导数的数值近似称为*有限差分近似*，而这个特定的方程被称为*牛顿差商*。这正是以下代码所做的事情：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Unfortunately, the result is imprecise (and it gets worse for more complicated
    functions). The correct results are respectively 24 and 10, but instead we get:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，结果不够精确（对于更复杂的函数来说情况会更糟）。正确的结果分别是24和10，但我们得到的是：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]  [PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]  [PRE3]'
