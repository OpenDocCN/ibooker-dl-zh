- en: Chapter 3\. The Build and Pre-Deployment Testing Steps of Continuous Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章\. 持续集成的构建和预部署测试步骤
- en: Simply put, our modern software delivery practices provide a structure to help
    us plan, write, build, test, and deploy software. In [Chapter 2](ch02.html#chapter_2_source_control_management_1749354010078326),
    we looked at how SCM systems help track and manage changes as we write code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们现代的软件交付实践提供了一种结构，帮助我们规划、编写、构建、测试和部署软件。在[第2章](ch02.html#chapter_2_source_control_management_1749354010078326)中，我们探讨了SCM系统如何帮助我们跟踪和管理代码编写过程中的变更。
- en: In this chapter, we turn our attention to continuous integration. [Figure 3-1](#chapter_3_figure_1_1749354010256769)
    shows a CI/CD pipeline that we’ll look at shortly and return to in Chapters [4](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896)
    and [8](ch08.html#chapter_8_feature_management_and_experimentation_1749354011197288).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注持续集成。![图3-1](#chapter_3_figure_1_1749354010256769)展示了我们将很快查看并将在第[4](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896)章和第[8](ch08.html#chapter_8_feature_management_and_experimentation_1749354011197288)章中再次讨论的CI/CD管道。
- en: '![](assets/ansd_0301.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![ansd_0301.png](assets/ansd_0301.png)'
- en: Figure 3-1\. A CI/CD pipeline
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1\. CI/CD管道
- en: We’ll explore the continuous integration pipeline with emphasis on build processes
    and pre-deployment testing (static scans, unit tests, and integration tests).
    We’ll demonstrate how an AI-native approach can accelerate CI through GenAI, agentic
    AI, and open standards such as MCP implementations. These technologies enable
    automated processes, predictive optimization, standardized context management,
    and intelligent testing strategies throughout the build, cache, and testing phases.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索持续集成管道，重点关注构建过程和预部署测试（静态扫描、单元测试和集成测试）。我们将展示如何通过通用人工智能（GenAI）、代理人工智能（agentic
    AI）和开放标准，如MCP实现，来加速CI。这些技术使自动化流程、预测优化、标准化上下文管理和智能测试策略在构建、缓存和测试阶段成为可能。
- en: In addition to the key continuous integration steps, we’ll review continuous
    integration tools and discuss factors to consider when selecting one. You will
    come away with an understanding of how to improve efficiency, quality, and security
    in your build pipeline.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关键持续集成步骤之外，我们还将回顾持续集成工具，并讨论在选择时需要考虑的因素。你将了解如何提高构建管道的效率、质量和安全性。
- en: A Short History of Building and Testing Software
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件构建和测试的简史
- en: This is a familiar story. In 1947, while working on the Harvard Mark II computer,
    a team of engineers discovered a moth trapped in a relay, causing the machine
    to malfunction. They removed the moth and taped it into their logbook with the
    note “First actual case of bug being found,” thus solidifying the association
    of “bug” with software errors. Finding the bug in the machine accurately characterizes
    testing in the early days of software development. Developers would write code
    independently and integrate it. Testing was typically done manually and ad hoc.
    Teams focused on finding the bugs, ridding machines of “the moths” when errors
    were discovered. Bugs were typically found in production, resulting in delays
    and unreliable software.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个熟悉的故事。1947年，在哈佛马克II计算机上工作时，一组工程师发现一只蛾被困在继电器中，导致机器出现故障。他们移除了蛾，并将其贴在日志簿上，注明“首次发现实际虫子案例”，从而巩固了“虫子”与软件错误的联系。在软件开发初期发现机器中的虫子准确地描述了测试。开发者会独立编写代码并集成它们。测试通常是手动和临时的。团队专注于寻找虫子，当发现错误时，从机器中清除“蛾子”。虫子通常在生产中发现，导致延误和不稳定的软件。
- en: As software development evolved, testing became more formalized and rigorous,
    with a focus on trying to “break” the software to uncover defects. Formal testing
    methodologies and standards began to emerge, such as the IEEE 829 Standard for
    Software and System Test Documentation (1983).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件开发的发展，测试变得更加规范和严格，重点是尝试“破坏”软件以发现缺陷。正式的测试方法和标准开始出现，例如1983年的IEEE 829软件和系统测试文档标准。
- en: Structured Software Development and Waterfall Methodologies
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化软件开发和瀑布方法
- en: Waterfall methodologies introduced a structured approach to software development,
    where testing became a distinct phase. Acceptance criteria, defined during requirements
    gathering, outlined the conditions the software must meet. Test cases were then
    developed and executed at the end of development to validate these criteria. Defects
    were documented and resolved until the software met all requirements. This formal
    approach, however, often resulted in a considerable delay between coding and testing,
    making early issue detection and resolution challenging and eventually resulting
    in a slower time-to-market for new products and features.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 瀑布式方法引入了一种结构化的软件开发方法，其中测试成为了一个独立的阶段。在需求收集期间定义的验收标准，概述了软件必须满足的条件。然后在开发结束时开发并执行测试用例来验证这些标准。缺陷被记录并解决，直到软件满足所有要求。然而，这种方法通常会在编码和测试之间产生相当大的延迟，使得早期问题检测和解决变得困难，并最终导致新产品和功能的上市时间变慢。
- en: Agile and Test-Driven Development
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敏捷和测试驱动开发
- en: In [Chapter 1](ch01.html#chapter_1_the_road_to_ai_native_devops_1749354009875299),
    we discussed the emergence of Agile methodologies in software development, motivated
    by the inefficiencies and limitations of the waterfall development. Agile methodologies’
    more flexible and responsive development model emphasized frequent feedback and
    iterative development, necessitating new testing approaches that could keep pace
    with the rapid development cycles. This led to new testing approaches.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.html#chapter_1_the_road_to_ai_native_devops_1749354009875299)中，我们讨论了敏捷方法在软件开发中的出现，这是由于瀑布式开发的低效和局限性所驱动的。敏捷方法更灵活、响应更快的开发模型强调了频繁的反馈和迭代开发，这需要新的测试方法来跟上快速的开发周期。这导致了新的测试方法的出现。
- en: Extreme Programming (XP), developed by Kent Beck, Ward Cunningham, and Ron Jeffries,
    was a specific Agile methodology defined by a set of best practices. One fundamental
    XP practice is test-driven development (TDD). In TDD, you write tests before writing
    the associated code. Beck’s influential book *Extreme Programming Explained*(Addison-Wesley),
    first published in 1999, popularized TDD to a wide audience, and early tools like
    JUnit (for Java) and NUnit (for .NET) provided developers with frameworks to easily
    write these types of tests before writing corresponding code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 极限编程（XP）是由Kent Beck、Ward Cunningham和Ron Jeffries开发的，是一种由一系列最佳实践定义的特定敏捷方法。极限编程的一个基本实践是测试驱动开发（TDD）。在TDD中，你先编写测试然后用代码实现它们。Beck有影响力的书籍《极限编程解释》（Addison-Wesley），首次出版于1999年，将TDD推广给了更广泛的受众，而早期的工具如JUnit（用于Java）和NUnit（用于.NET）为开发者提供了框架，使他们能够轻松地在编写相应代码之前编写这些类型的测试。
- en: 'Writing tests before code encourages developers to think deeply about desired
    code behavior, leading to better design and fewer defects. While this concept
    existed previously, TDD’s specific approach of writing failing tests first and
    then coding to pass them aligned well with Agile’s focus on short cycles and frequent
    delivery of working software. This practice redefined the notion of completeness:
    *A feature isn’t done when the code is working, but when the automated tests are
    complete and passing.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码之前编写测试鼓励开发者深入思考期望的代码行为，从而带来更好的设计和更少的缺陷。虽然这个概念之前就存在，但测试驱动开发（TDD）的具体方法——先编写失败的测试然后用代码通过它们——与敏捷对短期周期和频繁交付工作软件的重视非常吻合。这种实践重新定义了完整性的概念：*一个特性不是在代码工作时就完成了，而是在自动测试完成并通过时才算完成*。
- en: The automated tests created during TDD provide a safety net, allowing developers
    to refactor code with confidence, knowing that any regressions will be quickly
    caught by the tests. This enables faster iteration and more frequent releases,
    which in turn allows for quicker feedback from customers and stakeholders. The
    tests themselves also serve as a form of documentation, clearly articulating the
    expected behavior of the system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD期间创建的自动测试提供了一个安全网，让开发者可以自信地重构代码，因为他们知道任何回归都会被测试迅速捕捉。这使迭代更快，发布更频繁，从而允许从客户和利益相关者那里更快地获得反馈。测试本身也充当了一种文档形式，清楚地阐述了系统的预期行为。
- en: Enter Continuous Integration
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成登场
- en: As we introduced in [Chapter 1](ch01.html#chapter_1_the_road_to_ai_native_devops_1749354009875299),
    CI is the practice of automating the integration of code changes from multiple
    contributors into a shared repository, frequently triggering automated builds
    and tests to ensure the software remains in a working state. This complemented
    TDD.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](ch01.html#chapter_1_the_road_to_ai_native_devops_1749354009875299)中介绍的，CI是将多个贡献者的代码变更自动集成到共享存储库的实践，频繁触发自动构建和测试以确保软件保持工作状态。这补充了TDD。
- en: The [roots of CI](https://oreil.ly/neqmf) trace back to the 1990s. Grady Booch
    first coined the term “continuous integration” in 1991, but it was Kent Beck and
    Ron Jeffries who truly put it into practice while collaborating on a project in
    1997\. Their goal was to address the “integration hell” that arose from infrequent
    code merges, where conflicts and errors would pile up and become increasingly
    difficult to resolve.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[CI的根源](https://oreil.ly/neqmf)可以追溯到20世纪90年代。格雷迪·博奇（Grady Booch）于1991年首次提出了“持续集成”这个术语，但真正将其付诸实践的是肯特·贝克（Kent
    Beck）和罗恩·杰弗里斯（Ron Jeffries），他们在1997年合作进行一个项目时做到了这一点。他们的目标是解决由不频繁的代码合并引起的“集成地狱”，在那里冲突和错误会累积并变得越来越难以解决。'
- en: Early CI systems were often custom-built and tailored to specific projects.
    One notable example was CruiseControl, created in 2001 by ThoughtWorks. It was
    one of the first open source CI servers, allowing teams to automate the building
    and testing of software with every code commit. However, it lacked a user-friendly
    interface and flexible job scheduling, leading to the development of Hudson in
    2005 by Kohsuke Kawaguchi. Hudson quickly gained popularity due to its ease of
    use and powerful features.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的CI系统通常是定制构建并针对特定项目定制的。一个值得注意的例子是ThoughtWorks于2001年创建的CruiseControl。它是第一个开源CI服务器之一，允许团队在每次代码提交时自动构建和测试软件。然而，它缺乏用户友好的界面和灵活的作业调度，这导致了2005年由川口浩（Kohsuke
    Kawaguchi）开发的Hudson。Hudson因其易用性和强大的功能而迅速获得了人气。
- en: In 2011, a dispute with Oracle led to [Hudson being forked into Jenkins](https://oreil.ly/MF9WD),
    which has since become one of the most widely used tools for not only continuous
    integration, but also continuous delivery and deployment. The popularity of Jenkins
    can be attributed to its flexibility, extensibility, and vast plug-in ecosystem,
    allowing it to integrate with various tools and adapt to different workflows.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年，与Oracle的争议导致了[Hudson被分叉成Jenkins](https://oreil.ly/MF9WD)，这已经成为持续集成、持续交付和部署中最广泛使用的工具之一。Jenkins的流行可以归因于其灵活性、可扩展性和庞大的插件生态系统，使其能够与各种工具集成并适应不同的工作流程。
- en: Continuous Integration Today
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当前的持续集成
- en: 'Continuous integration has evolved into a foundational practice in modern software
    development, and CI/CD systems are the backbone of any delivery pipeline. Through
    the continuous integration of code changes, teams have come to depend on the following
    advantages:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成已成为现代软件开发的基础实践，CI/CD系统是任何交付管道的支柱。通过持续集成代码变更，团队已经依赖于以下优势：
- en: Reduced integration problems
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 减少集成问题
- en: CI eliminates the dreaded “integration hell” by ensuring developers merge their
    code changes frequently, minimizing conflicts and making them easier to resolve.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: CI通过确保开发者频繁合并他们的代码变更，最小化冲突并使它们更容易解决，消除了可怕的“集成地狱”。
- en: Faster feedback
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更快的反馈
- en: CI’s automated build and test processes provide developers with rapid feedback
    on their code changes, allowing them to catch and fix errors quickly, thus maintaining
    a stable and deployable codebase.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CI的自动构建和测试过程为开发者提供了对其代码变更的快速反馈，使他们能够快速捕捉和修复错误，从而保持一个稳定且可部署的代码库。
- en: Increased efficiency and reliability
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 提高效率和可靠性
- en: By automating the build and testing process, CI eliminates manual errors and
    inconsistencies, leading to more reliable and predictable builds.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自动化构建和测试过程，CI消除了手动错误和不一致性，从而导致了更可靠和可预测的构建。
- en: Improved transparency
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 提高透明度
- en: CI dashboards and notifications provide real-time visibility into the build
    and test status, allowing everyone on the team to track progress, identify potential
    issues, and collaborate more effectively.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: CI仪表板和通知提供了对构建和测试状态的实时可见性，使团队中的每个人都能跟踪进度、识别潜在问题，并更有效地协作。
- en: Accelerated releases
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 加速发布
- en: By streamlining and automating the build, test, and integration processes, CI
    enables faster and more frequent releases, allowing businesses to respond more
    rapidly to customer feedback and market changes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简化并自动化构建、测试和集成流程，持续集成（CI）使得更快、更频繁的发布成为可能，使企业能够更快地响应客户反馈和市场变化。
- en: In [“Continuous Integration in the CI/CD Pipeline”](#chapter_3_continuous_integration_in_the_ci_cd_pipeline_1749354010266620),
    we’ll look at the function of CI in the delivery pipeline and explore the landscape
    of CI tools.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“CI/CD流水线中的持续集成”](#chapter_3_continuous_integration_in_the_ci_cd_pipeline_1749354010266620)中，我们将探讨CI在交付流水线中的作用，并探索CI工具的格局。
- en: Continuous Integration in the CI/CD Pipeline
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD流水线中的持续集成
- en: In [Chapter 2](ch02.html#chapter_2_source_control_management_1749354010078326),
    we introduced a CI/CD pipeline, focusing on the relationship between the code
    repository and code integration. Let’s return to this pipeline and focus on the
    continuous integration, that is, the build step and the steps to execute pre-deployment
    test types, including static analysis, unit tests, and integration tests.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html#chapter_2_source_control_management_1749354010078326)中，我们介绍了CI/CD流水线，重点关注代码仓库与代码集成之间的关系。让我们回到这个流水线，并专注于持续集成，即构建步骤和执行预部署测试类型的步骤，包括静态分析、单元测试和集成测试。
- en: The pipeline in [Figure 3-2](#chapter_3_figure_2_1749354010256797) shows a typical
    CI process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-2中的流水线显示了典型的CI过程。
- en: '![](assets/ansd_0302.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/ansd_0302.png)'
- en: Figure 3-2\. CI pipeline triggered by opening a Git PR
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-2. 由Git PR触发的CI流水线
- en: 'This example is triggered when a developer opens a pull request. The goal of
    this pipeline is to validate the changes proposed in the PR *before the changes
    are merged into the main branch.* Let’s go through the steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例在开发者打开拉取请求时触发。此流水线的目标是验证PR中提出的更改，在更改合并到主分支之前。让我们看一下步骤：
- en: 1\. Code trigger
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 代码触发
- en: A developer or an AI agent opens a pull request on the hosted repository (e.g.,
    GitHub, GitLab, Bitbucket), which triggers the pipeline.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者或AI代理在托管仓库（例如，GitHub、GitLab、Bitbucket）上打开拉取请求，这会触发流水线。
- en: 2\. Checkout
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 检出
- en: The pipeline checks out the source code from the branch specified in the PR.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线从PR中指定的分支检出源代码。
- en: 3\. Build
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 构建
- en: The code is compiled (if necessary) and built into an executable or deployable
    artifact.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码（如果需要）被编译并构建成一个可执行或可部署的工件。
- en: 4\. Static analysis
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 静态分析
- en: Tools like linters and code analyzers scan the code for style violations, potential
    bugs, and security issues.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于linters和代码分析器这样的工具会扫描代码以查找样式违规、潜在错误和安全问题。
- en: 5\. Unit tests
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 单元测试
- en: Automated tests that verify the functionality of individual code units are executed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 执行自动测试以验证单个代码单元的功能。
- en: 6\. Integration tests
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 集成测试
- en: Relatively fast tests may be run to verify the interaction between different
    components of the code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可以运行相对较快的测试以验证代码不同组件之间的交互。
- en: 7\. Feedback
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 反馈
- en: The pipeline provides feedback to the developer about the PR’s status (success/failure)
    and any issues found. This feedback is displayed directly in the PR on the hosted
    repository.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线向开发者提供有关PR状态（成功/失败）和任何发现的问题的反馈。此反馈直接显示在托管仓库上的PR中。
- en: 'This pipeline detects and notifies developers of any issues within their code.
    The build step determines whether the code changes have broken the build. The
    test steps answer the following questions: Does this code do what is intended?
    Does this code include security vulnerabilities, unsafe operations, potential
    bugs, bad practices, deprecated features, or even inconsistent formatting?'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此流水线检测并通知开发者代码中存在的任何问题。构建步骤确定代码更改是否破坏了构建。测试步骤回答以下问题：此代码是否按预期工作？此代码是否包含安全漏洞、不安全操作、潜在错误、不良实践、已弃用功能，甚至不一致的格式？
- en: The code pipeline provides developers with near-real-time feedback by detecting
    issues and running fast tests when pull requests are opened or updated. It answers
    critical questions about the code’s functionality, security, and quality. Developers
    can then quickly address problems, refine the PR, or confidently merge it when
    all checks pass, accelerating development and ensuring a robust codebase.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码流水线通过在打开或更新拉取请求时检测问题并运行快速测试，为开发者提供近乎实时的反馈。它回答关于代码功能、安全和质量的关键问题。然后，开发者可以快速解决问题、完善PR，或者在所有检查通过时自信地合并它，从而加速开发并确保代码库的健壮性。
- en: (In [Chapter 4](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896),
    we’ll explore a complementary CI pipeline triggered when a PR is merged. This
    pipeline deploys new code to test environments and executes longer-running test
    suites.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: （在第4章[Chapter 4](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896)中，我们将探讨当PR合并时触发的辅助CI管道。此管道将新代码部署到测试环境并执行长时间运行的测试套件。）
- en: Note that while our sample pipeline uses a code change trigger, CI/CD systems
    typically offer other trigger options, like scheduled and manual triggers, for
    more flexibility.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然我们的示例管道使用代码更改触发器，但CI/CD系统通常提供其他触发选项，如计划触发和手动触发，以提供更多灵活性。
- en: The Essential Build Step
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重要的构建步骤
- en: The build step involves packaging code into a deployable artifact. Examples
    of deployable artifacts include container images (used to deploy in Kubernetes/serverless
    environments), language-specific packages (such as JAR, npm, NuGet, etc.), and
    mobile application packages (such as APK or IPA), among others. For example, code
    written in a compiled language, like C++, is first compiled and then linked to
    create machine code. Interpreted languages often require a build step to package
    code into an intermediate format, such as a Java Archive (JAR) file, for compilation
    at runtime. Other interpreted languages, including JavaScript, can be transpiled
    or minified to optimize for execution.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 构建步骤涉及将代码打包成可部署的工件。可部署的工件示例包括容器镜像（用于在Kubernetes/serverless环境中部署）、特定语言的包（如JAR、npm、NuGet等）和移动应用包（如APK或IPA）等。例如，用编译语言编写的代码，如C++，首先编译然后链接以创建机器代码。解释型语言通常需要一个构建步骤来将代码打包成中间格式，如Java归档（JAR）文件，以便在运行时编译。其他解释型语言，包括JavaScript，可以通过转译或压缩来优化执行。
- en: Depending on the type of code, this step or series of steps relies on build
    automation tools, task runners, or build scripts.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据代码类型，此步骤或一系列步骤依赖于构建自动化工具、任务运行器或构建脚本。
- en: 'Build automation tools orchestrate the entire build process. Popular examples
    of automation tools include the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自动化工具协调整个构建过程。以下是一些流行的自动化工具示例：
- en: Make and CMake
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Make和CMake
- en: Make is one of the oldest and most fundamental build tools. It uses a Makefile
    to define dependencies between files and the commands needed to build them. CMake
    is a newer cross-platform build system generator that can generate Makefiles,
    Visual Studio projects, and other build scripts. It’s widely used for C and C++
    projects.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Make是最古老和最基础的构建工具之一。它使用Makefile来定义文件之间的依赖关系和构建它们所需的命令。CMake是一个较新的跨平台构建系统生成器，可以生成Makefile、Visual
    Studio项目和其他构建脚本。它被广泛用于C和C++项目。
- en: Ant
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Ant
- en: An early Java-based build tool that uses XML to describe the build process.
    It’s known for its flexibility and cross-platform compatibility.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 早期基于Java的构建工具，使用XML来描述构建过程。它以其灵活性和跨平台兼容性而闻名。
- en: Maven
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Maven
- en: Another popular Java build tool that goes beyond just compilation. It manages
    dependencies, builds, tests, and packages projects.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种流行的Java构建工具，它不仅限于编译。它管理依赖项、构建、测试和打包项目。
- en: Gradle
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle
- en: A newer build tool that combines the best of Ant and Maven. It uses a Groovy-based
    DSL to define builds and offers a more flexible and concise syntax.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一种较新的构建工具，它结合了Ant和Maven的优点。它使用基于Groovy的DSL来定义构建，并提供更灵活和简洁的语法。
- en: Bazel
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Bazel
- en: Developed by Google, Bazel is a powerful build system designed for large-scale
    projects. It’s known for its speed, scalability, and support for multiple languages.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由Google开发，Bazel是一个为大型项目设计的强大构建系统。它以其速度、可扩展性和对多种语言的支持而闻名。
- en: MSBuild
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: MSBuild
- en: A build automation platform commonly used with .NET frameworks and languages
    like C#, Visual Basic .NET, and F#.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常用的构建自动化平台，通常与.NET框架和C#、Visual Basic .NET、F#等语言一起使用。
- en: Cargo
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo
- en: Cargo is a package manager for the Rust programming language, used to build,
    compile, and manage Rust projects.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo是Rust编程语言的包管理器，用于构建、编译和管理Rust项目。
- en: 'Task runners automate repetitive tasks in the development workflow, such as
    minification, concatenation, and transpilation. Widely used task runners for JavaScript
    include the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 任务运行器自动化开发工作流程中的重复性任务，如压缩、连接和转译。以下是一些广泛使用的JavaScript任务运行器：
- en: npm scripts
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: npm脚本
- en: Part of the Node Package Manager (npm), npm scripts are simple scripts defined
    in the *package.json* file that can automate common tasks like starting a development
    server, running tests, and building for production.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Node包管理器（npm）的一部分，npm脚本是在*package.json*文件中定义的简单脚本，可以自动化常见任务，如启动开发服务器、运行测试和构建生产版本。
- en: Gulp
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp
- en: A streaming build system that uses JavaScript code to define tasks. It’s known
    for its speed and efficiency in processing files.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript代码定义任务的流式构建系统。它以其处理文件的快速和高效而闻名。
- en: Grunt
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt
- en: Another task runner for JavaScript projects, Grunt uses configuration files
    to define tasks. It’s known for its vast ecosystem of plug-ins.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个JavaScript项目的任务运行器，Grunt使用配置文件来定义任务。它以其庞大的插件生态系统而闻名。
- en: Webpack
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack
- en: A module bundler primarily used for JavaScript applications. It can bundle JavaScript,
    CSS, and other assets into optimized files for production.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 主要用于JavaScript应用程序的模块打包器。它可以将JavaScript、CSS和其他资源打包成用于生产的优化文件。
- en: Rollup
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Rollup
- en: Another module bundler that’s known for its focus on generating smaller and
    more efficient bundles than Webpack.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个以生成比Webpack更小、更高效的包而闻名的模块打包器。
- en: Lastly, build scripts are custom scripts (often written in Bash, Python, or
    other scripting languages) that define the specific steps and commands needed
    to build a project. These can be used in conjunction with build automation tools
    or task runners.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，构建脚本通常是自定义脚本（通常用Bash、Python或其他脚本语言编写），用于定义构建项目所需的特定步骤和命令。这些可以与构建自动化工具或任务运行器一起使用。
- en: Prioritizing Quality and Security with Static Analysis
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过静态分析优先考虑质量和安全性
- en: 'Immediately after we build our code, we run static analysis tools, which may
    include a linter. Linters are a specific type of static analysis tool used to
    check coding style (ensuring, for example, consistent formatting and naming patterns);
    for interpreted languages like JavaScript, linters check for typos, missing semicolons,
    or incorrect language usage. These tools examine source code without executing
    it, similar to proofreading a document before publishing it. They help identify
    potential issues early in the development process. Static code analysis encompasses
    a range of techniques to evaluate code for:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建代码后立即运行静态分析工具，这些工具可能包括代码检查器。代码检查器是一种特定的静态分析工具，用于检查编码风格（例如，确保一致的格式化和命名模式）；对于JavaScript这样的解释型语言，代码检查器检查拼写错误、缺少分号或语言使用不当。这些工具在执行代码之前检查源代码，类似于在发布文档之前校对文档。它们有助于在开发早期阶段识别潜在问题。静态代码分析包括一系列技术，用于评估代码：
- en: Potential bugs
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在的bug
- en: Identifies common programming errors, like null pointer dereferences, resource
    leaks, or logic flaws
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 识别常见的编程错误，如空指针解引用、资源泄露或逻辑错误
- en: Security vulnerabilities
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 安全漏洞
- en: Detects insecure coding practices that could lead to SQL injections, cross-site
    scripting (XSS), or other exploits
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 检测可能导致SQL注入、跨站脚本（XSS）或其他利用的不安全编码实践
- en: Code smells
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代码异味
- en: Flags maintainability issues, like duplicate code, excessive complexity, or
    unused variables, suggesting areas for refactoring
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 标记可维护性问题，如重复代码、过度复杂或未使用变量，建议重构区域
- en: Adherence to standards
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 遵守标准
- en: Enforces coding guidelines and, sometimes, best practices specific to a language
    or project, ensuring consistency and readability
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 强制执行特定的编码指南和最佳实践，有时是针对特定语言或项目的，确保一致性和可读性
- en: By integrating these static analysis tools into the early stages of the development
    process, we not only ensure code quality but also implement a best practice referred
    to as shift-left security. Shift-left securityrefers to the strategy of implementing
    security practices in the earliest stages of development. We’ll dig into shift-left
    security and also explore how AI can help remediate security issues quickly in
    [Chapter 5](ch05.html#chapter_5_securing_applications_and_the_software_supply_chai_1749354010735711).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些静态分析工具集成到开发早期阶段，我们不仅确保代码质量，还实施了一种称为左移安全性的最佳实践。左移安全性指的是在开发最早阶段实施安全实践的战略。我们将在第5章（[Chapter 5](ch05.html#chapter_5_securing_applications_and_the_software_supply_chai_1749354010735711)）中深入了解左移安全性，并探讨AI如何帮助快速修复安全问题。
- en: 'Automated Testing: Test Early, Test Often'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化测试：尽早测试，经常测试
- en: 'Automated testing is fundamental to the CI/CD pipeline. After our example pipeline
    runs static analysis checks, it executes unit and integration tests against new
    code. Let’s look at these test types:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试是CI/CD管道的基本组成部分。在我们的示例管道运行静态分析检查后，它将针对新代码执行单元和集成测试。让我们看看这些测试类型：
- en: Unit tests
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试
- en: These tests validate the smallest isolated pieces of code (units), such as functions
    or methods, to verify that they behave as expected in isolation. Imagine a simple
    weather application that fetches weather data from an external API, processes
    it, and displays it to the user. Unit tests might test functions that process
    raw weather data, validating that they correctly convert the data into the desired
    formats. The tests validate the conversion logic alone.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试验证了最小的隔离代码片段（单元），例如函数或方法，以验证它们在隔离状态下是否按预期行为。想象一个简单的天气应用程序，它从外部API获取天气数据，处理它，并将其显示给用户。单元测试可能会测试处理原始天气数据的函数，验证它们是否正确地将数据转换为所需的格式。这些测试仅验证转换逻辑。
- en: Integration tests
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试
- en: These tests focus on verifying the interactions between software modules, ensuring
    proper communication and data exchange. Integration tests are relatively fast,
    often conducted after unit testing, and, like unit tests, help identify issues
    early. An integration test for the same weather app might focus on how the data
    fetching and processing modules interact. These tests could verify that the app
    correctly retrieves and handles weather data from the API, including error scenarios,
    using partial mocking to simulate real-world API responses. Unlike unit tests,
    which isolate components, integration tests assess how multiple components work
    together. Integration tests that are used early in the pipeline, such as in our
    example pipeline, should avoid slow operations such as accessing a database, file
    system, or other external systems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试专注于验证软件模块之间的交互，确保适当的通信和数据交换。集成测试相对较快，通常在单元测试之后进行，并且，像单元测试一样，有助于早期发现问题。对于同一个天气应用，集成测试可能关注数据获取和处理模块之间的交互。这些测试可以验证应用是否正确地从API检索和处理天气数据，包括错误场景，使用部分模拟来模拟真实的API响应。与单元测试不同，单元测试是隔离组件的，而集成测试评估多个组件如何协同工作。在管道早期使用的集成测试，例如在我们的示例管道中，应避免像访问数据库、文件系统或其他外部系统这样的慢操作。
- en: 'Unit and integration test frameworks are numerous and vary by language, for
    example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 单元和集成测试框架众多，且因语言而异，例如：
- en: Java
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Java
- en: JUnit 5 and TestNG are frameworks for unit testing. Mockito and Spring are used
    for Java integration testing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5和TestNG是单元测试的框架。Mockito和Spring用于Java的集成测试。
- en: JavaScript
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: Jest and Mocha for JavaScript are widely used for unit testing. Jest also supports
    integration testing.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Jest和Mocha用于JavaScript的单元测试，Jest也支持集成测试。
- en: Python
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: pyTest and pyUnit (UnitTest) are options for both unit and integration testing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: pyTest和pyUnit（UnitTest）是单元和集成测试的选项。
- en: .NET
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: .NET
- en: NUnit and xUnit for .NET are options for unit testing, whereas Moq and NSubstitute
    are commonly used for integration testing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: NUnit和xUnit用于.NET的单元测试，而Moq和NSubstitute通常用于集成测试。
- en: Ruby
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby
- en: RSpec supports both unit and integration testing for Ruby.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: RSpec支持Ruby的单元和集成测试。
- en: Mobile (iOS/Android)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 移动（iOS/Android）
- en: XCTest for iOS and Espresso for Android are standard bearers for mobile unit
    and integration testing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: XCTest用于iOS和Espresso用于Android是移动单元和集成测试的标准标杆。
- en: Unit and integration tests act as a first line of defense, alerting developers
    to potential bugs or regressions in their code. These quick, automated checks
    are just the beginning of our testing strategy. In [Chapter 4](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896),
    we’ll look at a subsequent pipeline that is triggered when the PR is closed and
    merged.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 单元和集成测试作为第一道防线，提醒开发者他们的代码中可能存在的潜在错误或回归。这些快速、自动化的检查只是我们测试策略的开始。在[第4章](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896)中，我们将探讨当PR关闭并合并时触发的后续管道。
- en: Thoroughly testing each unit of code, including all possible scenarios, results
    in a large but crucial suite of tests—even for seemingly simple code. However,
    since unit tests are isolated and don’t rely on external resources, they execute
    rapidly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 详尽地测试每一行代码，包括所有可能的场景，结果是一个庞大但至关重要的测试套件——即使是看似简单的代码。然而，由于单元测试是隔离的，并且不依赖于外部资源，它们执行得很快。
- en: Our pipeline prioritizes these speedy unit tests as the foundation, followed
    by integration tests that verify how different components work together, and finally,
    a smaller number of comprehensive end-to-end tests that simulate real-world usage.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的管道优先考虑这些快速的单元测试作为基础，然后是验证不同组件如何协同工作的集成测试，最后是数量较少的综合端到端测试，这些测试模拟真实世界的使用。
- en: In [“The Test Pyramid”](#chapter_3_the_test_pyramid_1749354010266825), we’ll
    look at the Test Pyramid framework, which illustrates how to balance different
    test types for optimal software quality.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“测试金字塔”](#chapter_3_the_test_pyramid_1749354010266825)中，我们将探讨测试金字塔框架，它说明了如何平衡不同测试类型以实现最佳软件质量。
- en: The Test Pyramid
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: The Test Pyramidprovides a model for structuring our tests strategically, prioritizing
    different types based on their scope and speed. While the Test Pyramid is sometimes
    depicted with specific test types at each layer, we prefer to conceptualize layers
    that encompass broad classes of tests, as shown in [Figure 3-3](#chapter_3_figure_3_1749354010256819).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔提供了一个战略性地构建测试的模型，根据测试的范畴和速度优先考虑不同类型。虽然测试金字塔有时会以每层特定的测试类型来表示，但我们更倾向于将包含广泛测试类别的层概念化，如图3-3[图](#chapter_3_figure_3_1749354010256819)所示。
- en: '![](assets/ansd_0303.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/ansd_0303.png)'
- en: Figure 3-3\. Large sets of fast tests make up the base of the Test Pyramid;
    smaller sets of slower tests form the higher layers
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-3. 大量快速测试构成了测试金字塔的基础；较小且较慢的测试集形成了金字塔的较高层
- en: At the base of our pyramid are pre-deployment tests, which include types like
    unit tests, integration tests, and static scans. These tests are small and execute
    quickly. Integration testing can refer to a range of test strategies. Integration
    tests that don’t interact with external systems like databases and network services
    are fast and are included at this level. The wide pyramid base reflects that the
    suite of these types of tests should be large and, ideally, cover the complete
    codebase. Tests should be designed to provide fast feedback to the developer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们金字塔的基础是预部署测试，包括单元测试、集成测试和静态扫描等类型。这些测试都是小型的，执行速度快。集成测试可以指代一系列测试策略。不与外部系统（如数据库和网络服务）交互的集成测试速度快，并包含在这一层级。金字塔宽阔的底部反映了这些测试类型套件应该很大，理想情况下覆盖整个代码库。测试应该设计成能够为开发者提供快速反馈。
- en: Moving up the pyramid, we depict the middle layer as including any type of tests
    that we execute against deployed code in a pre-production, test environment.Generally,
    these tests are typically slower than the ones mentioned above but provide valuable
    insights into how the system functions as a whole.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 随着金字塔的上升，我们将中间层描述为包括任何针对预生产测试环境中的已部署代码执行的测试类型。通常，这些测试比上面提到的测试慢，但提供了关于系统整体功能的宝贵见解。
- en: At the peak of the pyramid, we find manual tests.These are slow and labor-intensive
    and occur after the code has been vetted by layers of automated testing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔的顶端，我们发现手动测试。这些测试缓慢且劳动密集，发生在代码经过自动化测试层审核之后。
- en: Embracing the pyramid approach allows teams to balance speed, cost, and effectiveness
    in their testing efforts. By focusing on a solid foundation of small and fast
    tests and supplementing them with strategic testing against deployed code, we
    can achieve comprehensive test coverage while minimizing the time and resources
    required.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 采用金字塔方法可以使团队在测试工作中平衡速度、成本和有效性。通过专注于小型且快速的测试基础，并辅以对已部署代码的战略性测试，我们可以在最小化所需时间和资源的同时，实现全面的测试覆盖。
- en: A robust testing strategy is key to a streamlined pipeline, accelerating the
    delivery of high-quality releases. In [“Continuous Integration Tools”](#chapter_3_continuous_integration_tools_1749354010266880)
    we’ll consider how the CI tool choice can prioritize that factor.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的测试策略是简化流程、加速高质量发布的关键。在[“持续集成工具”](#chapter_3_continuous_integration_tools_1749354010266880)中，我们将探讨CI工具选择如何优先考虑这一因素。
- en: Continuous Integration Tools
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成工具
- en: Effective CI processes are essential for modern development teams. In this section,
    we’ll look at legacy CI tools and the features that characterize modern tools.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的CI流程对于现代开发团队至关重要。在本节中，我们将探讨传统CI工具和现代工具的特征性功能。
- en: A major national retailer—a client of ours—anticipating a surge in digital demand
    found itself at a crossroads. Its legacy CI/CD tools, including Jenkins, were
    fragmented across client web, mobile, and backend service teams, causing long
    build times that cost the company a staggering $500,000 annually in idle developer
    time. These tools not only stifled innovation but also posed significant security
    risks, further exacerbated by the $800,000 spent yearly on maintenance and custom
    scripts. This substantial investment diverted resources away from enhancing the
    customer experience. Faced with mounting challenges and escalating costs, the
    retailer sought a unified CI/CD platform to streamline operations, accelerate
    innovation, and fortify security.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一家主要的国家零售商——我们的客户——预计数字需求将激增，发现自己处于十字路口。其传统的 CI/CD 工具，包括 Jenkins，在客户端的网页、移动和后端服务团队中是分散的，导致构建时间过长，每年为公司浪费了高达
    50 万美元的开发者闲置时间。这些工具不仅抑制了创新，还带来了重大的安全风险，而每年 80 万美元的维护和定制脚本费用进一步加剧了这一风险。这笔巨额投资将资源从提升客户体验中转移开来。面对日益严峻的挑战和不断上升的成本，零售商寻求一个统一的
    CI/CD 平台，以简化操作、加速创新并加强安全性。
- en: The company’s compounding challenges shed light on the inherent limitations
    of Jenkins, especially as organizations scale and digital demands intensify. Let’s
    look at some of those limitations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 公司所面临的复合挑战揭示了 Jenkins 内在局限性的本质，尤其是在组织规模扩大和数字需求加剧的情况下。让我们来看看其中的一些局限性。
- en: Jenkins Considered
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑 Jenkins
- en: Jenkins deserves credit for bringing continuous integration into the mainstream.
    An open source automation server, Jenkins leverages a vast ecosystem of plug-ins
    that extend its functionality and features and give users the ability to customize
    their pipelines endlessly. The Jenkins plug-in marketplace is a central repository
    where users can find and install thousands of these community-developed plug-ins.
    The Jenkins community is large and its documentation is extensive. It is an adaptable
    solution for diverse development environments.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 应该得到认可，因为它将持续集成引入了主流。作为一个开源自动化服务器，Jenkins 利用庞大的插件生态系统来扩展其功能和特性，并使用户能够无限定制他们的管道。Jenkins
    插件市场是一个中央仓库，用户可以在这里找到并安装数千个这些社区开发的插件。Jenkins 社区规模庞大，其文档内容广泛。它是一个适应性强、适用于各种开发环境的解决方案。
- en: While Jenkins remains valuable for legacy systems due to its specialized plug-ins
    (e.g., mainframes), modern CI pipelines demand more. Today’s development environments
    require CI tools that deliver speed, security, collaborative workflows, and native
    integration with cloud technologies across multiple providers, Kubernetes orchestration,
    and containerized applications. The following sections explore specific challenges
    that make Jenkins less suitable for these modern requirements.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Jenkins 由于其专业的插件（例如，大型机）对遗留系统仍然有价值，但现代 CI 管道需要更多。今天的开发环境需要能够提供速度、安全性、协作工作流程以及与多个提供商的云技术、Kubernetes
    调度和容器化应用程序的本地集成的 CI 工具。以下部分将探讨一些使 Jenkins 对于这些现代需求不太适合的具体挑战。
- en: Plug-in complexity
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插件复杂性
- en: The flexibility and extensive plug-in ecosystem of Jenkins often leads to a
    complex and fragmented architecture, hindering maintainability and increasing
    developer toil. The reliance on Groovy scripts for pipeline customization can
    make troubleshooting and updates cumbersome, especially as the number of pipelines
    and their complexity grows.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 的灵活性和广泛的插件生态系统往往会导致复杂且分散的架构，阻碍了可维护性并增加了开发者的工作量。对 Groovy 脚本进行管道定制的依赖性可能会使故障排除和更新变得繁琐，尤其是在管道数量和复杂性增加的情况下。
- en: In addition, modern CI/CD solutions often embrace the “pipeline-as-code” paradigm,
    using declarative languages like YAML to define pipelines. This approach is generally
    considered more straightforward and maintainable than the scripting-heavy approach
    of Jenkins. YAML-based pipelines are generally more human-readable and easier
    to maintain (there might be exceptions) than Groovy scripts, which can become
    complex and harder to debug as pipelines grow in size and complexity. Defining
    pipelines as code allows them to be stored in VCSs alongside the application code.
    This ensures that pipeline changes are tracked, reviewed, and auditable, enabling
    better collaboration among team members. Thus, the pipeline-as-code approach allows
    for better version control, collaboration, and easier troubleshooting.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现代的CI/CD解决方案通常采用“代码化流水线”范式，使用如YAML这样的声明性语言来定义流水线。这种方法通常被认为比Jenkins脚本密集型方法更直接、更易于维护。基于YAML的流水线通常比Groovy脚本更易于阅读和维护（可能有例外），因为随着流水线规模和复杂性的增加，Groovy脚本可能会变得复杂且难以调试。将流水线定义为代码允许它们与应用程序代码一起存储在版本控制系统中。这确保了流水线更改可被跟踪、审查和审计，从而在团队成员之间实现更好的协作。因此，代码化流水线方法允许更好的版本控制、协作和更易于故障排除。
- en: Lastly, the need to manage a multitude of plug-ins, each with its own configuration,
    introduces maintenance overhead. Team members find themselves spending valuable
    time on mundane tasks like resolving plug-in conflicts, updating dependencies,
    and deciphering cryptic error messages. This detracts from the focus on innovation
    and core development, slowing down innovation and delivering features.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，管理大量具有各自配置的插件，引入了维护开销。团队成员发现自己花费宝贵的时间在解决插件冲突、更新依赖项和解读晦涩的错误信息等日常任务上。这分散了对创新和核心开发的关注，减缓了创新并影响了功能的交付。
- en: Scalability challenges
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可扩展性挑战
- en: The architecture of Jenkins, primarily designed for single-server setups, often
    struggles to scale efficiently as the number of jobs, pipelines, and users increases.
    This can lead to performance bottlenecks, slower build times, and overall system
    instability. While Jenkins offers distributed builds and clustering options, setting
    up and maintaining these solutions can be complex and resource-intensive, requiring
    specialized expertise and significant overhead. As a result, [scaling Jenkins
    horizontally](https://oreil.ly/6qFLO) to meet the demands of large organizations
    or high-throughput CI/CD workflows often becomes a major challenge.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins的架构主要是为单服务器设置设计的，当作业、流水线和用户数量增加时，往往难以高效扩展。这可能导致性能瓶颈、较慢的构建时间和整体系统不稳定。虽然Jenkins提供了分布式构建和集群选项，但设置和维护这些解决方案可能很复杂且资源密集，需要专业知识和大量开销。因此，为了满足大型组织或高吞吐量CI/CD工作流程的需求，[水平扩展Jenkins](https://oreil.ly/6qFLO)通常成为一个主要挑战。
- en: Security concerns
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全问题
- en: While Jenkins plug-ins provide extensibility, they also introduce potential
    vulnerabilities. Each plug-in, with its own codebase and dependencies, expands
    the attack surface of a Jenkins instance. Monitoring these plug-ins for vulnerabilities
    and ensuring timely updates becomes ongoing overhead for administrators. Furthermore,
    configuring Jenkins security, including user permissions, access controls, and
    network configurations, can be intricate. Misconfigurations can expose the system
    to unauthorized access or malicious activities. The dynamic nature of the plug-in
    ecosystem and the potential for misconfigurations mean you must be vigilant in
    monitoring risks and proactive in mitigating risks within your Jenkins environment.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Jenkins插件提供了可扩展性，但它们也引入了潜在的安全漏洞。每个插件，都有其自己的代码库和依赖项，扩大了Jenkins实例的攻击面。监控这些插件以发现漏洞并确保及时更新成为管理员持续的工作负担。此外，配置Jenkins安全，包括用户权限、访问控制和网络配置，可能非常复杂。配置错误可能会使系统面临未经授权的访问或恶意活动。插件生态系统的动态性和配置错误的可能性意味着您必须对Jenkins环境中的风险保持警惕，并主动减轻风险。
- en: Resource usage and efficiency concerns
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源使用和效率问题
- en: Jenkins’s resource consumption can be a significant drawback, especially as
    the number of jobs and plug-ins increases. The Java-based architecture (JVM’s
    runtime requirements, garbage collection behavior, and framework abstractions)
    often leads to high memory usage, and managing numerous concurrent builds can
    put a strain on CPU and disk resources. This can result in slower build times,
    increased infrastructure costs, and potential performance issues. In larger environments,
    scaling Jenkins horizontally can become complex and resource-intensive, requiring
    additional hardware and careful configuration.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 的资源消耗可能是一个重大的缺点，特别是随着作业和插件的增加。基于 Java 的架构（JVM 的运行时要求、垃圾回收行为和框架抽象）通常会导致高内存使用，管理大量并发构建可能会对
    CPU 和磁盘资源造成压力。这可能导致构建时间变慢、基础设施成本增加以及潜在的性能问题。在更大的环境中，水平扩展 Jenkins 可能变得复杂且资源密集，需要额外的硬件和仔细的配置。
- en: 'In addition, building Docker images in CI pipelines can quickly become resource-intensive
    and expensive, particularly when dealing with large codebases or frequent commits
    that trigger numerous parallel builds. Each image requires computational resources,
    storage space, and network bandwidth—costs that multiply across environments and
    branches. Similarly, while comprehensive observability provides valuable system
    insights, implementing excessive logging can create its own problems: storage
    costs surge, signal-to-noise ratios decrease, and processing overhead increases.
    Finding the right balance between comprehensive coverage and resource efficiency
    remains a critical challenge.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 CI 流程中构建 Docker 镜像可能会迅速变得资源密集和昂贵，尤其是在处理大型代码库或频繁提交触发大量并行构建的情况下。每个镜像都需要计算资源、存储空间和网络带宽——这些成本在环境和分支之间成倍增加。同样，虽然全面的可观察性提供了有价值的系统洞察，但过度实施日志记录可能会产生其自身的问题：存储成本激增，信噪比降低，处理开销增加。在全面覆盖和资源效率之间找到正确的平衡仍然是一个关键挑战。
- en: Beyond Jenkins
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越 Jenkins
- en: 'Due to the limitations of Jenkins, companies like our national retailer often
    outgrow it and seek modern, fully managed solutions that offer:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Jenkins 的局限性，像我们这样的国家零售商通常会超出其能力范围，并寻求现代、全面管理的解决方案，这些解决方案提供：
- en: Built-in, fully supported building blocks
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 内置、全面支持的构建块
- en: Modern CI/CD tools offer extensive libraries of built-in, fully supported building
    blocks that streamline pipeline setup. This eliminates reliance on community-maintained
    plug-ins, ensuring reliability and stability. However, recognizing the need for
    customization, most solutions still support extensibility through custom plug-ins.
    This empowers teams to automate unique workflows and tailor the CI/CD environment
    to their specific needs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现代CI/CD工具提供了丰富的内置、全面支持的构建块库，这些构建块简化了流程设置。这消除了对社区维护的插件的依赖，确保了可靠性和稳定性。然而，认识到定制化的需求，大多数解决方案仍然支持通过自定义插件进行扩展。这赋予了团队自动化独特工作流程并定制
    CI/CD 环境以满足其特定需求的能力。
- en: Pipelines define declaratively
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性定义流程
- en: Modern CI/CD tools streamline pipeline definition using declarative code like
    YAML, making them more accessible and easier to maintain than the Groovy scripts
    for Jenkins. This accelerates setup and minimizes errors associated with manual
    scripting.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 CI/CD 工具使用如 YAML 这样的声明性代码简化了流程定义，这使得它们比 Jenkins 的 Groovy 脚本更易于访问和维护。这加快了设置速度，并最小化了与手动脚本相关的错误。
- en: Native support for containerization and orchestration
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对容器化和编排的原生支持
- en: Jenkins predates the widespread adoption of Docker and Kubernetes, and while
    Jenkins pipelines can use plug-ins to work with and orchestrate containers, the
    lack of native support often results in cumbersome configurations. Newer tools,
    in contrast, seamlessly incorporate containerization and orchestration features,
    simplifying the deployment and management of applications in containerized environments.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 诞生于 Docker 和 Kubernetes 的广泛应用之前，虽然 Jenkins 流程可以使用插件来处理和编排容器，但缺乏原生支持通常会导致配置繁琐。相比之下，新工具无缝地结合了容器化和编排功能，简化了在容器化环境中的应用部署和管理。
- en: 'In the next sections, we’ll look at additional modern features that tools newer
    than Jenkins offer. Before we turn our attention to these features, let’s consider
    a fundamental question when considering CI/CD tools: whether to host and manage
    tools yourself or select a fully managed solution. The decision will impact everything
    from development velocity and cost-effectiveness to maintenance requirements.
    Given the importance of mobile, it’s essential to select a CI/CD setup that handles
    the complexities of building and deploying mobile applications and we’ll look
    at the factors specific to mobile app development to consider.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨比 Jenkins 更新的工具提供的其他现代功能。在我们转向这些功能之前，让我们考虑在考虑 CI/CD 工具时一个基本问题：是自己托管和管理工具，还是选择完全托管的解决方案。这个决定将影响从开发速度和成本效益到维护要求的一切。鉴于移动设备的重要性，选择一个能够处理构建和部署移动应用程序复杂性的
    CI/CD 设置至关重要，我们将探讨特定于移动应用程序开发的考虑因素。
- en: Hosting options
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 托管选项
- en: 'Organizations have three primary build infrastructure choices for their CI/CD
    systems: self-hosted on-premises, self-hosted cloud, and vendor-hosted (cloud).
    Each option presents unique benefits and drawbacks that should be carefully considered:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 组织在为其 CI/CD 系统选择基础设施时，有三个主要选项：自托管本地、自托管云和供应商托管（云）。每个选项都提供了独特的优势和劣势，这些都应该仔细考虑：
- en: Self-hosted, on-prem solutions
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 自托管、本地解决方案
- en: Self-hosting a CI/CD system on-premises gives you complete control and ownership
    over its infrastructure and data. This approach allows for maximum customization,
    enabling tailoring to specific security protocols and organizational needs. Additionally,
    some organizations may prefer the one-time payment model associated with on-prem
    solutions. However, this approach comes with several drawbacks. It necessitates
    substantial up-front investment in hardware and software, as well as time and
    effort to maintain and update. The demand for ongoing maintenance and potential
    scalability challenges can strain resources, particularly for smaller organizations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地自托管 CI/CD 系统提供了对其基础设施和数据的完全控制和所有权。这种方法允许最大程度的定制，能够根据特定的安全协议和组织需求进行定制。此外，一些组织可能更喜欢与本地解决方案相关的单次付款模式。然而，这种方法有几个缺点。它需要大量前期投资于硬件和软件，以及维护和更新的时间和精力。持续维护的需求和潜在的扩展挑战可能会对资源造成压力，尤其是对小型组织而言。
- en: Self-hosted, cloud solutions
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 自托管、云解决方案
- en: The self-managed, cloud-hosted model strikes a balance between control and scalability.
    Organizations maintain control over their CI/CD software while leveraging the
    cloud’s flexibility and scalability. This approach reduces the need for physical
    hardware and simplifies scaling compared to on-prem solutions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 自管理的云托管模型在控制性和可扩展性之间取得了平衡。组织对其 CI/CD 软件保持控制权，同时利用云的灵活性和可扩展性。这种方法减少了物理硬件的需求，与本地解决方案相比，简化了扩展。
- en: 'Cloud-hosted applications run within virtualized environments called hypervisors,
    and when considering cloud hosting, the type of hypervisor you select will impact
    simplicity and performance. The two types of hypervisors to understand are:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 云托管的应用程序在称为虚拟机的虚拟环境中运行，在考虑云托管时，您选择的虚拟机类型将影响简单性和性能。需要了解的两种虚拟机类型是：
- en: Type 1 bare-metal hypervisor
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 1 硬件裸机虚拟机
- en: These run directly on the hardware, offering superior performance and isolation
    but requiring dedicated hardware.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些直接在硬件上运行，提供卓越的性能和隔离性，但需要专用硬件。
- en: Type 2, embedded hypervisors
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 2，嵌入式虚拟机
- en: These run on top of an operating system, providing easier setup and flexibility
    but potentially with lower performance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在操作系统之上运行，提供更简单的设置和灵活性，但可能性能较低。
- en: Bare metal might be better for demanding, high-security setups, while embedded
    could be suitable for less intensive needs and budget constraints.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件裸机可能更适合要求高、安全性高的设置，而嵌入式可能适合需求较低和预算有限的情况。
- en: Any cloud-hosted toolset will require ongoing maintenance and updates, and your
    organization will remain responsible for managing the cloud infrastructure. This
    can lead to challenges similar to those of on-prem solutions, albeit with potentially
    reduced up-front costs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 任何云托管的工具集都将需要持续维护和更新，并且您的组织将负责管理云基础设施。这可能导致与本地解决方案类似的问题，尽管可能降低了前期成本。
- en: Fully managed, vendor-hosted solutions
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 完全托管、供应商托管解决方案
- en: Vendor-hosted CI/CD solutions offer a fully managed service where the vendor
    handles infrastructure, maintenance, and updates. Your organization focuses on
    development rather than infrastructure management. These solutions are highly
    scalable, easy to use, and often follow a pay-as-you-go model, making them cost-effective.
    However, they may offer less customization than self-hosted options and potentially
    limit your organization’s ability to tailor the system to your specific needs.
    Additionally, concerns about data security and potential vendor lock-in can arise
    with this approach.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商托管的 CI/CD 解决方案提供完全管理服务，其中供应商负责基础设施、维护和更新。您的组织专注于开发而不是基础设施管理。这些解决方案具有高度的可扩展性、易于使用，并且通常遵循按使用付费的模式，使其具有成本效益。然而，它们可能提供的定制化程度不如自托管选项，并可能限制您组织根据特定需求定制系统的能力。此外，使用这种方法可能会出现关于数据安全和潜在供应商锁定的问题。
- en: Mobile app development–specific challenges
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动应用程序开发特定挑战
- en: 'Having a robust and efficient CI/CD solution is crucial to keep pace with the
    fast release cycles and high-quality apps that mobile users expect. Developing
    for mobile brings unique challenges: your processes and your CI/CD tools must
    be able to manage device fragmentation and frequent mobile OS updates.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个强大且高效的 CI/CD 解决方案对于跟上快速发布周期和移动用户期望的高质量应用程序至关重要。为移动设备开发带来了独特的挑战：您的过程和 CI/CD
    工具必须能够管理设备碎片化和频繁的移动操作系统更新。
- en: When choosing between self-hosted and fully managed CI/CD solutions, consider
    that self-hosted solutions, while offering control and customization, can lead
    to challenges like physical hardware constraints. In addition, your team will
    be responsible for constant maintenance and updates to build environments. These
    complexities can lead to unexpected costs. The frequent release cycles of tools
    like Xcode for iOS development necessitate regular hardware updates, which can
    be a significant time and resource drain for any team.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择自托管和完全管理 CI/CD 解决方案之间时，请考虑自托管解决方案虽然提供控制和定制，但可能导致物理硬件限制等挑战。此外，您的团队将负责构建环境的持续维护和更新。这些复杂性可能导致意外的成本。iOS
    开发工具如 Xcode 的频繁发布周期需要定期硬件更新，这可能对任何团队都是一个重大的时间和资源消耗。
- en: Fully managed CI/CD solutions, on the other hand, alleviate these pain points
    by providing automatic updates to build environments and predictable costs. This
    allows your team to focus on building features and improving their apps rather
    than managing infrastructure. Moreover, fully managed CI/CD solutions specifically
    optimized for mobile development offer mobile-specific integrations and features
    that streamline the development process. Many of these platforms fully manage
    challenges of mobile development, such as device fragmentation and OS updates,
    for you.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 完全管理的 CI/CD 解决方案，另一方面，通过提供构建环境的自动更新和可预测的成本来缓解这些痛点。这使得您的团队能够专注于构建功能和改进他们的应用程序，而不是管理基础设施。此外，专门针对移动开发进行优化的完全管理
    CI/CD 解决方案提供特定的移动集成和功能，从而简化了开发过程。许多这些平台完全管理移动开发的挑战，例如设备碎片化和操作系统更新。
- en: Modern Features to Accelerate Software Builds
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代功能以加速软件构建
- en: 'Returning to our retailer: it researched newer options and decided to move
    on from Jenkins and the set of plug-ins and tools pieced together to work with
    it. The company selected a unified platform that simplified its toolset while
    providing the scalability and cost savings that it required. It was able to consolidate
    CI/CD processes for services, client web, and mobile teams onto this single platform.
    The new platform eliminated the need for extensive scripting, saving developers
    time and enabling them to focus on innovation. It also leveraged AI/ML for testing,
    resulting in further cost savings and much faster builds. Furthermore, a unified
    platform improved security by supporting security testing early in the pipeline,
    enabling faster detection and remediation of vulnerabilities. The efficiency,
    security, and reliability of the new platform enabled the retailer to easily handle
    its digital growth.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的零售商：它研究了新的选项，并决定从 Jenkins 以及与之一起工作的插件和工具组合中退出。公司选择了一个统一的平台，简化了其工具集，同时提供了所需的可扩展性和成本节约。它能够将服务、客户端网页和移动团队的
    CI/CD 流程整合到这个单一平台上。新的平台消除了大量脚本的需求，节省了开发者的时间，并使他们能够专注于创新。它还利用 AI/ML 进行测试，从而进一步节约成本并加快构建速度。此外，统一的平台通过在管道早期支持安全测试来提高安全性，从而加快了漏洞的检测和修复。新平台的高效性、安全性和可靠性使零售商能够轻松应对其数字增长。
- en: In the next sections, we will look at features in modern systems that enable
    faster, cost-effective, and secure pipelines.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨现代系统中使管道更快、更经济高效且更安全的特性。
- en: Accelerate builds with caching
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用缓存加速构建
- en: Modern build environments are ephemeral, enhancing agility by providing isolated,
    cost-effective, and scalable setups that accelerate development cycles while maintaining
    consistency across stages of the CI/CD pipeline. However, ephemeral environments
    require setting up the entire build process from scratch each time, including
    downloading dependencies, compiling code, and generating artifacts. This is time-consuming.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现代构建环境是短暂的，通过提供隔离的、成本效益高且可扩展的设置来增强敏捷性，这些设置可以加速开发周期，同时在CI/CD管道的各个阶段保持一致性。然而，短暂的构建环境需要每次从头开始设置整个构建过程，包括下载依赖项、编译代码和生成工件。这非常耗时。
- en: Caching is a technique used in CI/CD to store and reuse build artifacts, dependencies,
    Docker layers, and intermediate results. This significantly reduces build times
    by avoiding redundant operations and focusing on building only what has changed,
    which not only speeds up development cycles but also conserves computational resources
    and energy. Modern CI/CD systems intelligently manage this caching process, optimizing
    builds without manual intervention. Caching can be done at different stages—caching
    software dependencies, caching Docker layers, and caching build outputs from tools
    like Bazel, Gradle, and Maven.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是CI/CD中用于存储和重用构建工件、依赖项、Docker层和中间结果的技巧。通过避免冗余操作并专注于仅构建已更改的内容，这显著减少了构建时间，不仅加快了开发周期，还节省了计算资源和能源。现代CI/CD系统智能地管理此缓存过程，无需人工干预即可优化构建。缓存可以在不同的阶段进行——缓存软件依赖项、缓存Docker层以及缓存Bazel、Gradle和Maven等工具的构建输出。
- en: Streamline building, caching, and testing with AI
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用AI简化构建、缓存和测试
- en: An AI-native CI solution will seamlessly integrate GenAI, agentic AI, and MCP
    to enhance building the software, caching required components, and testing each
    build. Let’s look at these enhancements in more detail.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个AI原生CI解决方案将无缝集成GenAI、代理AI和MCP，以增强构建软件、缓存所需组件和测试每个构建。让我们更详细地看看这些增强功能。
- en: Build phase enhancements
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建阶段增强
- en: GenAI can automate boilerplate code creation for repetitive tasks (e.g., Dockerfile
    templates, CI configuration files), reducing manual effort. It can also analyze
    historical build data to predict dependency conflicts and suggest optimal versions,
    minimizing build failures. Another interesting use case for GenAI is generating
    optimized CI pipeline YAML configurations based on project structure, reducing
    trial-and-error setups.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: GenAI可以自动化重复性任务的样板代码创建（例如，Dockerfile模板、CI配置文件），从而减少人工工作量。它还可以分析历史构建数据以预测依赖项冲突并建议最佳版本，从而最小化构建失败。GenAI的另一个有趣用例是根据项目结构生成优化的CI管道YAML配置，从而减少试错设置。
- en: Agentic AI can detect build failures (e.g., missing dependencies), and can then
    automatically retry with corrected configurations and log root causes. It can
    also dynamically scale build resources (e.g., cloud instances) based on workload
    demands, balancing speed and cost, and can dynamically split monolithic builds
    into parallelizable tasks, reducing execution time.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 代理AI可以检测构建失败（例如，缺少依赖项），然后可以自动使用修正的配置重新尝试，并记录根本原因。它还可以根据工作负载需求动态扩展构建资源（例如，云实例），平衡速度和成本，并且可以动态地将单体构建拆分为可并行化的任务，从而减少执行时间。
- en: MCP can standardize environment variables, build flags, and toolchain versions
    across distributed teams, ensuring consistency and sharing prebuilt artifacts,
    such as compiled libraries, between related projects via MCP’s centralized cache,
    avoiding redundant builds.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: MCP可以在分布式团队之间标准化环境变量、构建标志和工具链版本，确保一致性，并通过MCP的集中式缓存共享预构建工件，如编译库，从而避免冗余构建。
- en: Cache phase enhancements
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存阶段增强
- en: GenAI can be used to make the caching techniques more intelligent. It can predict
    which dependencies (e.g., *node_modules*, *.m2* artifacts) will be needed based
    on code changes, precaching them before builds start. ML models can be used to
    identify stale caches by analyzing code diff patterns, ensuring only relevant
    artifacts are retained. Agentic AI can flag and purge poisoned caches (e.g., corrupted
    artifacts) in real time, preventing failed builds.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 生成式人工智能（GenAI）可以用来使缓存技术更加智能。它可以根据代码更改预测需要哪些依赖项（例如，*node_modules*、*.m2*工件），并在构建开始前预先缓存它们。机器学习模型可以通过分析代码差异模式来识别过时的缓存，确保只保留相关的工件。代理式人工智能可以实时标记并清除受污染的缓存（例如，损坏的工件），防止构建失败。
- en: Using MCP in scalable infrastructure has many advantages, including enabling
    secure, low-latency cache sharing across CI pipelines via standardized APIs, and
    reducing redundant data transfers by caching intermediate build outputs (e.g.,
    Docker layers) between CI runs. MCP can enable secure cache sharing between parallel
    CI jobs through standardized APIs, eliminating redundant builds in monorepo architectures.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在可扩展的基础设施中使用MCP（多容器平台）有许多优势，包括通过标准化API实现跨CI管道的安全、低延迟缓存共享，以及通过在CI运行之间缓存中间构建输出（例如，Docker层）来减少冗余数据传输。MCP可以通过标准化API在并行CI作业之间启用安全的缓存共享，消除单仓库架构中的冗余构建。
- en: Test phase enhancements
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试阶段增强
- en: Consider a scenario where a developer modifies a single line of code in a seldom-used
    component within a large application. We have high code coverage with our large
    and robust set of unit tests; these are the foundation of our test strategy, the
    base of our Test Pyramid. Yet, when little code has changed, executing the entire
    test suite results in lengthy, resource-intensive, and very inefficient test cycles.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个场景：一个开发者在一个大型应用程序中修改了一个很少使用的组件中的一行代码。我们拥有大量且健壮的单元测试，代码覆盖率很高；这些是测试策略的基础，也是测试金字塔的基石。然而，当代码变化很小的时候，执行整个测试套件会导致漫长的、资源密集型且非常低效的测试周期。
- en: Modern tools can mitigate these issues with AI tooling that intelligently selects
    and executes only the tests directly relevant to the modified code. This approach
    significantly reduces the time and resources required for testing, leading to
    faster feedback loops and more efficient development processes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现代工具可以通过使用人工智能工具来缓解这些问题，这些工具可以智能地选择和执行仅与修改的代码直接相关的测试。这种方法显著减少了测试所需的时间和资源，从而加快了反馈循环并提高了开发过程的效率。
- en: '[Harness Test Intelligence (TI)](https://oreil.ly/_-jPi) is an example of this
    approach. Let’s look at how TI works under the hood. Three components work together
    to enable Harness TI:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[利用测试智能（TI）](https://oreil.ly/_-jPi)是这种方法的例子。让我们看看TI在底层是如何工作的。三个组件协同工作以启用Harness
    TI：'
- en: TI service
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: TI服务
- en: This service uses AI and understands your repository, Git commits, and unit
    tests and uses this data to dynamically build a graph that maps the relationships
    between code methods and their corresponding unit tests. This graph is continuously
    updated to reflect changes in the codebase.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务使用人工智能并理解您的仓库、Git提交和单元测试，并使用这些数据动态构建一个图，映射代码方法和它们对应的单元测试之间的关系。此图会持续更新以反映代码库中的变化。
- en: A test runner agent
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行代理
- en: This component communicates with the service and executes tests.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件与服务通信并执行测试。
- en: A test step
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 测试步骤
- en: This is the step you add to your CI pipeline to integrate TI into your workflow.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您添加到持续集成（CI）管道中的步骤，以将测试智能（TI）集成到工作流程中。
- en: The TI workflow begins when a developer initiates a pull request and triggers
    the pipeline. The TI service analyzes the code changes and compares them to its
    graph to identify the tests that need to be executed. It considers not only the
    code modifications but also any changes or additions to the tests themselves.
    This ensures that all relevant aspects of the codebase are thoroughly tested while
    avoiding redundant test runs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 测试智能（TI）工作流程从开发者发起拉取请求并触发管道开始。TI服务分析代码更改并将其与自己的图进行比较，以确定需要执行的测试。它不仅考虑代码修改，还包括对测试本身进行的任何更改或添加。这确保了代码库的所有相关方面都得到了彻底的测试，同时避免了冗余的测试运行。
- en: Thus, by focusing on the impacted tests, intelligent testing approaches can
    significantly reduce the testing time, especially in large projects with extensive
    test suites. This translates to faster builds and faster feedback for developers,
    allowing them to identify and address issues more quickly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过关注受影响的测试，智能测试方法可以显著减少测试时间，尤其是在具有广泛测试套件的大型项目中。这转化为更快的构建和更快的开发者反馈，使他们能够更快地识别和解决问题。
- en: AI-powered build and test insights
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AI驱动的构建和测试洞察
- en: Modern CI/CD tools also leverage GenAI to automate tedious tasks and provide
    insights when things go wrong. For example, a tool can autogenerate your pipelines,
    analyze code for potential issues, and troubleshoot build and deployment failures
    in real time. If a CI build fails, GenAI can analyze log files, pinpoint the error,
    and even suggest potential fixes. This saves your time, reduces downtime, and
    accelerates the software delivery process.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现代CI/CD工具还利用GenAI自动化繁琐的任务，并在出现问题时提供洞察。例如，一个工具可以自动生成您的管道，分析代码以查找潜在问题，并在实时中解决构建和部署失败。如果CI构建失败，GenAI可以分析日志文件，定位错误，甚至提出可能的修复方案。这节省了您的时间，减少了停机时间，并加速了软件交付过程。
- en: Agentic AI can also be used to come up with recommendations to optimize existing
    pipelines based on your organization’s golden standards. This feature would be
    extremely valuable since organizations, more often than not, optimize their current
    pipelines rather than create new pipelines.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 代理AI还可以用于根据您组织的黄金标准提出优化现有管道的建议。这个功能将非常有价值，因为组织往往更倾向于优化现有管道而不是创建新管道。
- en: Another excellent use case for GenAI is writing intent-based tests. Testing,
    especially UI testing, can be extremely manual and flaky if the UI changes. By
    using GenAI, developers and QA engineers can simply state the intent of a test
    and let GenAI figure out the steps. We will discuss intent-based testing in detail
    in [Chapter 4](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: GenAI的另一个优秀用例是编写基于意图的测试。测试，尤其是UI测试，如果UI发生变化，可能会非常手动且不可靠。通过使用GenAI，开发人员和QA工程师可以简单地陈述测试的意图，让GenAI找出步骤。我们将在[第4章](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896)中详细讨论基于意图的测试。
- en: Finally, AI can also be used to generate data for tests ethically and responsibly.
    Some examples include ensuring compliance with GDPR and other regulations when
    using production data for model training, maintaining data privacy and security
    throughout the data generation process, and using proper algorithms to generate
    synthetic data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，AI还可以用于以道德和负责任的方式生成测试数据。一些例子包括在使用生产数据训练模型时确保符合GDPR和其他法规，在整个数据生成过程中维护数据隐私和安全，以及使用适当的算法生成合成数据。
- en: Unify CI/CD metrics with enterprise observability
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将CI/CD指标与企业可观察性统一
- en: A modern CI/CD solution should be a team player, working with the other key
    platforms in your corporate ecosystem, particularly the observability platform
    that your organization relies on to understand system behavior, identify performance
    bottlenecks, and proactively detect and resolve issues before they impact users
    or business operations. Observability platforms include Elastic with Logstash
    and Kibana, a popular open source platform, and Datadog and Splunk, well-known
    commercial options.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现代CI/CD解决方案应该是一个团队玩家，与您企业生态系统中其他关键平台协同工作，尤其是您组织依赖的用于理解系统行为、识别性能瓶颈、并在影响用户或业务运营之前主动检测和解决问题的可观察性平台。可观察性平台包括Elastic与Logstash和Kibana，一个流行的开源平台，以及Datadog和Splunk，知名的商业选项。
- en: Modern continuous integration tools provide telemetry data to these platforms
    by implementing OpenTelemetry, an open source framework. This brings in CI/CD
    metrics to enable observability and dashboards that can help you understand what’s
    happening and improve build performance and reliability.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现代持续集成工具通过实现开源框架OpenTelemetry向这些平台提供遥测数据。这引入了CI/CD指标，以实现可观察性和仪表板，这些仪表板可以帮助您了解正在发生的事情，并提高构建性能和可靠性。
- en: Modern CI/CD support for monorepos
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对monorepos的现代CI/CD支持
- en: Versioning and dependency management become very challenging when managing complex
    codebases across several repositories. Monorepos are single repositories that
    contain all the code for a project or organization, providing a centralized approach
    to managing complex codebases. A single repository simplifies dependency management
    by keeping a single copy of any shared library or component, and simplifies code
    sharing and reuse across different projects. While monorepos increase the risk
    of merge conflicts and require careful design to avoid tightly coupled code, many
    large companies have successfully adopted them for massive codebases, demonstrating
    that an effectively managed monorepo can provide a very scalable approach.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当在多个仓库中管理复杂的代码库时，版本控制和依赖管理变得极具挑战性。Monorepos 是包含一个项目或组织所有代码的单个仓库，提供了一种集中式管理复杂代码库的方法。单个仓库通过保留任何共享库或组件的单个副本来简化依赖管理，并简化了不同项目之间的代码共享和复用。虽然
    monorepos 增加了合并冲突的风险，并需要谨慎设计以避免代码紧密耦合，但许多大型公司已成功采用它们来管理庞大的代码库，证明了有效管理的 monorepo
    可以提供非常可扩展的方法。
- en: When adopting a monorepo strategy, it’s important to understand the unique requirements
    that monorepos make of code repositories and CI tools. With potentially hundreds
    of developers contributing to a large monorepo, managing changes and pull requests
    efficiently becomes critical. Teams must be able to define appropriate access
    by subdirectories, in part to ensure that only relevant reviewers are notified
    for each change. Repositories should support subdirectory-specific ownership.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在采用 monorepo 策略时，了解 monorepos 对代码仓库和 CI 工具的独特要求非常重要。在可能数百名开发者向大型 monorepo 贡献时，高效管理变更和拉取请求变得至关重要。团队必须能够定义适当的子目录访问权限，部分是为了确保每个变更只通知相关的审阅者。仓库应支持特定子目录的所有权。
- en: Monorepos require CI systems that enable selective building and testing of changed
    components and that support advanced dependency management, caching, and parallel
    execution. Tools like Harness CI support these needs through features like path-based
    triggers, which run pipelines only when specific directories in the repository
    change (e.g., triggering service A’s pipeline for changes to *serviceA/*), and
    sparse checkout, which clones a subdirectory instead of the entire repository.
    This optimizes resource usage and speeds up feedback loops while maintaining dependency
    integrity.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Monorepos 需要能够选择性地构建和测试已更改组件的 CI 系统，并支持高级依赖管理、缓存和并行执行。像 Harness CI 这样的工具通过诸如基于路径的触发器等特性来支持这些需求，这些触发器仅在仓库中的特定目录更改时运行管道（例如，触发服务
    A 的管道以更改 *serviceA/*），以及稀疏检出，它克隆子目录而不是整个仓库。这优化了资源使用并加快了反馈循环，同时保持依赖完整性。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'CI has become an indispensable practice, reducing integration issues, providing
    faster feedback, and improving overall efficiency. In this chapter, we looked
    at modern, fully managed CI/CD tool features, contrasting the trade-offs with
    the costs and challenges of self-hosting. We looked at the importance of prioritizing
    faster, smaller unit tests for quick feedback, followed by slower test types for
    comprehensive coverage. The continuous integration pipeline we looked at exemplified
    this practice: in the context of opening a PR, we build, complete static scans,
    and then run quick tests to ensure our code does what it should and doesn’t introduce
    regressions. We also explored various ways in which an AI-native CI tool could
    use GenAI, agentic AI, and MCP to enhance the build, cache, and test phases of
    CI.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: CI 已成为不可或缺的实践，减少了集成问题，提供了更快的反馈，并提高了整体效率。在本章中，我们探讨了现代、完全管理的 CI/CD 工具的功能，对比了自托管的开销和挑战。我们探讨了优先考虑更快、更小的单元测试以获得快速反馈的重要性，然后是更慢的测试类型以实现全面覆盖。我们探讨的持续集成管道体现了这一实践：在打开
    PR 的上下文中，我们构建、完成静态扫描，然后运行快速测试以确保我们的代码按预期工作且不会引入回归。我们还探讨了 AI 原生 CI 工具如何利用 GenAI、代理
    AI 和 MCP 来增强 CI 的构建、缓存和测试阶段。
- en: In [Chapter 4](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896),
    we’ll continue with CI/CD and focus on deploying to test environments and executing
    the slower tests that evaluate the system’s performance, resiliency, and end-to-end
    behavior.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 4 章](ch04.html#chapter_4_deploying_to_test_environments_1749354010445896)中，我们将继续探讨
    CI/CD，重点关注部署到测试环境和执行评估系统性能、弹性和端到端行为的较慢测试。
