# 第一章：通往 AI 原生 DevOps 之路

大多数软件开发团队都能讲述关于部署失败的战争故事。这些故事让我们走上了现代化交付实践的道路。

这里有一个例子：经过几周或几个月的功能工作、广泛的重构以及漫长的测试和稳定阶段后，一个团队准备进行部署。开发者、运维团队成员、一群管理者，也许还有几位高管聚集在一个“作战室”中。到目前为止，开发和运维之间几乎没有协作。然而，现在这两个团队作为一个单一团队一起工作。他们开始逐项检查一个长长的清单或操作手册中的手动步骤。

然而，即使是最详尽的清单也无法保证部署无问题。鉴于发布中的变更数量，部署可能很复杂且风险很高。正如我们将在以下章节中看到的，依赖关系管理具有挑战性，“依赖地狱”可能非常真实。因此，团队可能会发现生产环境中缺少一个关键依赖项。团队可能会发现安装了不兼容的库版本，或者关键设置配置错误，或者迁移步骤失败或被遗忘，或者更改导致对合作伙伴服务的请求失败。

任何数量的失误都可能导致原本复杂的部署偏离轨道。紧张局势会升级，紧急应对措施随之而来，时间也会无限延长。团队希望能在部署窗口内完成部署以及随后的任何手动烟雾测试。如果部署失败且无法修复，团队希望回滚到上一个版本不会导致意外的困难，从而延长停机时间和复杂性。当部署最终完成时，疲惫的团队会撤退。通常，团队在流量恢复的“关键护理期”内会被期望保持警惕。之后可能会有一段为期几天或几周的稳定期，在此期间，开发团队可能会暂停所有功能工作，专注于热修复或补丁。

正如这个故事所展示的，重负荷、高风险的部署对开发和运维团队来说都是一种消耗。这些大规模生产部署，以及随后的稳定工作周期，使团队无法继续构建增加商业价值的功能。

相比之下，现代软件交付简化并加速了从开发者的电脑到最终用户整个过程。部署频繁，戏剧性低，风险低，且高度自动化。但我们正进入一个新时代——一个超越自动化的时代。下一个前沿是 AI 原生软件交付。

AI 原生交付将 AI 融入软件交付生命周期的每一层，使智能代理能够做出决策、优化工作流程并在实时中进行调整。这些代理——从代码和 DevOps 到安全和测试——能够自主协作，执行合规性，自我修复基础设施，并使用强化学习持续优化软件交付管道。这一转变标志着从被动管理到主动管理的转变，从孤立的工具到统一生态系统的转变，以及从静态自动化到动态自主性的转变。

随着 AI 生成代码、编排管道和减少人工劳动，开发速度加快。系统变得更加健壮和安全，AI 可以预先识别问题并自主解决。同时，通过智能优化，云成本降低，协作通过 AI 驱动的代理以机器速度处理跨团队协调和决策而扩展。

在本章中，我们将描述过去 25 年软件交付的演变过程。我们将定义 DevOps，并描述 DevOps 实践如何使现代软件交付成为可能。我们将探讨当前 DevOps 状态所面临的众多挑战。最后，本章将概述现代软件交付、DevOps 实践和 AI 原生方法如何演变以应对这些挑战。

# 开发 + 运维 = DevOps

“DevOps”一词通常归功于帕特里克·德博伊斯（Patrick Debois），他在 2009 年将“开发”和“运维”这两个词结合起来，为一场旨在探索打破开发团队和运维团队之间传统壁垒、以更快地交付软件的会议命名。两个主要因素造成了这些壁垒：

沟通和协作不佳

开发人员通常专注于编写代码和功能，然后将成品“扔”过一道象征性的墙给运维团队。运维团队随后承担了部署、维护和在生产环境中调试代码的责任。

冲突的优先级

开发团队优先考虑快速开发和快速发布新功能，而运维团队则专注于系统稳定性、安全性和防止停机。尽管这些团队有不同的优先级，但它们本质上相互关联和相互依赖。无论你的代码或基础设施多么令人印象深刻，除非它被部署并在生产中运行以服务于你的业务目标，否则它就没有真正的价值。

这种目标不匹配，有时被称为“核心慢性冲突”，当出现问题时可能会导致摩擦和指责。

作为回应，DevOps 原则鼓励在每个阶段进行沟通。它们鼓励在开发早期就涉及运维，并在代码部署后继续与开发人员保持持续的合作伙伴关系，以支持代码。

# DevOps 简史

软件团队日益复杂，新的软件方法和新的工具有助于为 DevOps 铺平道路。在本节中，我们将探讨这些因素。

## 2000 年代的敏捷

在 2000 年代初，组织对如何使软件交付更高效的新想法表现出极大的兴趣和接受度。基于精益制造思想的“敏捷”方法论变得流行。这些方法论反对强调前期广泛规划和严格线性序列的“瀑布”软件交付模式。相反，敏捷提倡短的开发周期和频繁的发布，这些发布对变化高度敏感。许多并行努力正式化了新的敏捷实践。1995 年的一篇论文正式化了 Scrum 实践。Kent Beck 在他的 1999 年著作《极限编程揭秘》（Addison-Wesley）中描述了一套敏捷软件开发实践。2001 年，Beck 和其他有影响力的敏捷过程倡导者在敏捷宣言中谈到了类似的主题，该宣言提倡适应性和响应性，而不是对计划的僵化遵循。1 DevOps 从宣言的第一原则“我们最高的优先级是通过尽早和持续交付有价值的软件来满足客户”借用了“持续交付”这个名字。

Jeffrey Fredrick 观察到，Ken Schwaber 的 Scrum 书籍从 2001 年到 2007 年的发展历程可以作为敏捷日益成熟和组织影响力的一个晴雨表。在这段时间里，Scrum 因其清晰的架构、规定性的角色和跨团队的适应性而迅速成为主导的敏捷实践。2001 年，《Scrum 敏捷软件开发》（Pearson）向刚开始探索敏捷方法的开发者和小型团队介绍了这个框架。到 2004 年，《Scrum 敏捷项目管理》（Addison-Wesley）解决了实际实施挑战，标志着在更广泛的 IT 领域内日益增长的采用。到 2007 年，《企业 Scrum》（Microsoft Press）承认了将敏捷实践扩展到整个组织而不是单个团队的需求日益增长。这些书籍反映了——并帮助塑造了敏捷从边缘思想到企业必要性的转变之旅。

## 持续集成与持续交付

在接下来的十年里，技术组织越来越多地受到敏捷思维的影响。一个结果是采用了持续集成和持续交付（CI/CD）的实践。

“敏捷软件开发宣言”催生了持续集成的实践，这使得敏捷开发的一个关键原则——频繁交付可工作的软件成为可能。开发者将他们的代码更改合并到一个共享的仓库中。通过持续集成，每次合并都会触发一个自动的构建和测试过程。这个自动化的系统可以快速捕捉错误和冲突，使得团队能够在开发周期的早期阶段修复这些问题。持续集成鼓励更小、更频繁的更新，从而实现更快的交付、减少集成问题，并使代码库更加健康。

持续交付是持续集成的自然延伸。CD 自动化了将经过集成构建和测试的代码准备发布到生产环境的流程。这包括打包、配置和将软件部署到预发布区域等步骤。CD 使团队能够快速、可靠地推送新功能、错误修复和更新，确保可部署的软件始终可用。

在每个开发周期结束时交付一个“可能发布的产品”是另一个关键的敏捷实践。可能发布的意思是可靠、经过测试、打包的软件，可以部署到生产环境中。（在实践中，许多采用 CD 的组织只进行内部交付，并且继续不经常部署到生产环境。持续交付并不等同于持续部署。）

## 早期 DevOps 的里程碑

与敏捷方法倾向于关注软件交付生命周期的规划和执行部分不同，早期的 DevOps 专注于交付和运营。在 DevOps 出现后的几年里，这一运动获得了显著的动力。一个关键里程碑发生在 2009 年，首届 DevOpsDays 会议举行。这次活动汇集了专业人士，分享他们在 DevOps 实践方面的经验和见解。

另一个重要的发展是 2010 年 Gene Kim、Kevin Behr 和 George Spafford 合著的《凤凰项目》（IT 革命出版社）一书的出版。这部叙事作品描绘了一个虚构的 IT 组织面临的挑战，以及采用 DevOps 原则和实践如何导致其性能的戏剧性转变。它以与技术和非技术受众产生共鸣的方式为 DevOps 辩护。第二年，另一部有影响力的出版物《DevOps 手册》由 Gene Kim、Jez Humble、Patrick Debois 和 John Willis 合著发布。这本实用指南通过提供一个全面的框架来实施 DevOps，帮助许多组织开始他们的 DevOps 之旅。

2013 年，Kim 和 Humble 撰写的 Puppet Labs（现称 Puppet）的“DevOps 状态”报告引起了人们的关注。该报告不仅关注技术指标，还强调了 DevOps 采用的业务效益，证明了实施该方法的组织能够比同行快 30 倍地发布代码，失败率降低 50%。这直接将 DevOps 实践与领导者关心的业务成果联系起来。Nicole Forsgren、Jez Humble 和 Gene Kim 合著的《加速：精益软件和 DevOps 的科学》（IT 革命）一书更详细地探讨了这一主题。

2013 年，平台即服务（PaaS）和 Docker 的引入标志着另一个关键时刻，因为这些技术简化了应用程序的部署和管理，使得 DevOps 实践能够在更大规模上成为可能。在此之前，管理和应用基础设施的复杂性使得 DevOps 的广泛应用变得具有挑战性。2014 年 AWS Lambda 的推出进一步改变了这一格局，通过开创性的大规模事件驱动函数执行，允许开发者专注于编写代码，无需担心底层基础设施。同时，Kubernetes 也在 2014 年推出，为大规模编排容器化应用程序提供了一个强大的框架，确保部署可靠、高效且可扩展。

到了十年后半期，机器学习（ML）技术开始渗透到 DevOps 工具链中，尤其是在应用性能监控（APM）和测试领域。测试工具将使用 ML 来优化测试执行并检测用户界面的变化。同时，像 Datadog 和 New Relic 这样的 APM 工具很早就将自己定位为“AI Ops”，因为它们使用 ML 来识别问题信号。到 2018 年，[Harness 将 ML 应用于持续交付](https://oreil.ly/4BH7E)，以检测问题信号，使系统能够识别部署导致的问题并触发必要的回滚。这些技术共同为现代 DevOps 奠定了基础，提供了管理复杂软件系统所需的有效工具和框架，为 AI 原生 DevOps 铺平了道路。

## DevOps 1.0

DevOps 已经从一种松散的、小众的概念发展成为一个我们称之为“DevOps 1.0”的成熟思想体系。其属性包括：

文化转型

认识到文化转变的重要性，以使软件开发和运维团队能够保持一致

自动化实践

实施持续集成和持续交付等实践以简化软件交付

自动化工具

利用特定工具自动化软件交付管道的各个阶段，包括代码提交、测试、部署、配置和生产监控

DevOps 1.0 实践的早期采用者立即获得了成功。在 2010 年代初，许多工程团队每季度发布一次软件，花费数周时间进行手动测试、协调和生产部署。这些发布流程缓慢、易出错，需要加班安排以降低风险。随着组织开始接受早期的 DevOps 原则——将开发和运维团队更紧密地结合起来，并自动化交付管道的关键部分——他们实现了更快的发布周期、更高的可靠性和减少的手动工作量。对于许多人来说，这种转变使得从每季度发布转变为每两周甚至每周发布成为可能，为更迭式开发和更快的价值实现奠定了基础。

### DevOps 1.0 的挑战

DevOps 1.0 提供了有价值的概念、实践和工具。然而，由于以下原因，公司今天在完全实现 DevOps 的好处方面面临着新的挑战：

+   引入复杂性并要求 DevOps 适应的软件趋势

+   对于许多组织来说，功能不足或过于复杂的 DevOps 1.0 工具集

以下部分将探讨这些挑战的细节。

#### 采用云原生和微服务架构

新的架构模式涉及数十个离散的微服务部署到单个容器中。DevOps 1.0 管道没有准备好应对这些新架构的要求。

在过去十年中，微服务和云原生架构已成为现代软件开发的事实标准，这是由对软件系统更大可扩展性、灵活性和敏捷性的需求驱动的。这些架构为 DevOps 团队引入了新的重大要求。采用微服务导致部署的服务激增，每个服务都有自己的依赖项和配置。编排部署并维护这些分布式服务的一致性变得越来越具有挑战性。

容器（云原生系统的关键特性）和无服务器架构的使用需要新的部署和管理策略，并增加了另一层复杂性。DevOps 团队现在必须处理数十个甚至数百个短暂的容器或无服务器函数的部署，需要强大的编排工具、构建和管理容器生命周期的自动化流程，以及对这些新兴技术的深入理解。自动化容器的整个生命周期——从构建镜像，到将它们推送到注册表，到以最小停机时间推出更新——对于高效的容器管理至关重要。

#### 开源软件的兴起

开源软件（OSS）已成为现代软件开发的一个普遍组成部分。虽然 OSS 提供了众多好处，但它为 DevOps 团队引入了新的挑战。管理依赖项、确保与不同版本的兼容性，以及在多个 OSS 组件之间维护安全补丁可能是一项艰巨的任务。此外，团队必须仔细审查代码，并确保其符合他们组织的网络安全和合规标准。

#### 数字体验的重要性以及企业消费化

在这个数字颠覆的时代，马克·安德森关于“软件正在吞噬世界”的预言证明越来越准确。公司提供的数字体验正成为客户的主要接触点，塑造了他们对品牌的体验。此外，企业技术的消费者化意味着员工期望获得与针对客户的应用程序相同的无缝体验和持续更新。这些期望迫使 DevOps 团队提供更频繁的发布，保持高可用性，并启用实验以推动快速创新。

### 超出 DevOps 1.0 工具集

自 2009 年首届 DevOpsDays 以来，我们对工具的需求已经发生了变化。交付节奏加快，而监管负担增加。以工件注册为例：最初引入作为本地缓存以加快构建，现在对于在多种语言中确保软件供应链安全至关重要。为了简化部署，我们进行了容器化，我们的构建时间变得更长，使得我们的持续集成构建不再是连续的。我们从一组配置管理工具转向了更新的、云本地的声明式工具。但我们仍然需要测试、安全和治理这些基础设施变更。同时，新的工具不断出现——每个都承诺改进，但也需要与其他所有东西连接起来。对于许多团队来说，当前的堆栈正在崩溃。

管道很快变得非常复杂。组织平均管理 10 个或更多不同的工具来部署软件。例如，用于部署 Rails、Sidekiq 和 NodeJS 应用的自动化管道可能包括以下工具：

+   GitHub actions 用于运行 CI

+   用于对 Sidekiq、Rails 和 Puma 进行仪表化并将应用程序指标推送到 Prometheus 的库

+   Docker 镜像构建和 Kubernetes

+   Artifactory 用于存储镜像和 Helm 图表

+   ArgoCD 用于 Kubernetes 上的 GitOps 部署

+   Helm 用于管理部署和升级

+   Terraform 用于管理亚马逊网络服务 (AWS) 基础设施、角色、权限等

+   New Relic 用于异常捕获和监控

+   Kube-state-metrics 用于收集容器指标

+   Prometheus 用于存储指标

+   Grafana 用于使 Prometheus 指标可消费

对于资源有限的团队来说，整合和管理这个工具集可能是一个相当大的挑战。让我们看看 DIY 方法的一些挑战。

#### 广泛使用的开源工具通常不是最优的

DIY 方法实现的 DevOps 通常会导致效率较低的管道。一些开源工具缺乏可以减少开发者工作量和缩短生产时间的功能。例如，在 Jenkins 中维护正常运行时间和扩展需要大量资源。长的测试时间可能导致构建缓慢。最后，重用管道的模式是复制/粘贴，导致“管道蔓延”，这可能难以维护且成本高昂。Chapter 3 将更详细地讨论这些问题。

#### DIY 管道导致重复和浪费的努力

通常，团队必须实施管道来整合工具和系统。这会导致大量重复造轮子。例如，Jenkins 和 ArgoCD 是常用的 CI/CD 工具。这些工具提供了自动化软件开发和部署过程的强大功能，但它们要求团队从头开始构建诸如基于角色的访问控制（RBAC）、审计日志和通知等基本结构。实施和维护这些结构是本可以用于向客户交付价值的努力。

#### 自动化通常不完整，需要手动步骤

使用自动化脚本来完成大部分部署，但需要手动配置环境变量时，如果团队成员没有遵循相同的流程，可能会导致部署不一致。不完整的自动化可能导致监控和反馈循环出现空白，因为手动步骤可能不会触发自动警报或指标收集。手动步骤引入了人为错误的风险，这可能导致停机或安全漏洞。因此，DevOps 中的不完整自动化可能导致效率低下、错误和可扩展性问题。

#### 治理是事后之想

没有事先的治理，团队可能会忽略合规性要求（例如，满足通用数据保护条例[GDPR]标准），导致在问题被发现后进行昂贵的返工或罚款。如果安全措施应用不一致或作为事后考虑，应用程序将容易受到攻击。没有明确的治理政策，资源如云服务或基础设施可能会过度配置或利用率不足，导致浪费成本（我们将在第九章中讨论这个话题。Chapter 9）。没有监督，团队可能会使用不同的工具、流程和标准，导致集成挑战和效率低下。

## DevOps 2.0

DevOps 1.0 已显著加速了许多公司的软件交付过程。然而，其复杂性、留下的差距以及所需的投资为改进留下了空间。这就是我们所说的 DevOps 2.0——一个以更简单的开发者体验、端到端自动化以及易于管理所有移动部件的视角定义的愿景，并且具有增强整个管道的 AI 能力。这一演变将重点从工具和流程转移到服务的人和结果上。

DevOps 2.0 流程和工具通过强大的新功能提升了开发者体验。开发者可以在几分钟内通过自动化设置开发和交付工具链来启动新的项目和服务。开箱即用的集成使团队能够轻松启动并连接存储库、敏捷项目和管道。为了进一步简化流程，模板封装了组织的最佳实践，确保一致性，并在创建新服务时消除工作管理开销。团队专注于构建他们的应用程序，而不是繁琐的基础设施设置。AI 代理执行越来越复杂的 DevOps 任务，例如自动诊断和解决基础设施和管道问题，优化资源分配，并根据观察到的性能模式提出架构改进建议。

DevOps 2.0 工具通过一个更加统一、紧密集成的工具集，简化了 DevOps 1.0 解决方案的复杂性。必要的构造（如 RBAC、审计日志）已集成。内置了对各种部署策略和实验方法的支撑，使得团队能够实现频繁的发布和快速的迭代。新工具能够扩展以支持跨多个环境的大规模部署，包括本地、云和混合配置。DevOps 2.0 工具将提供安全的管道和政策执行，以最小化开源采用和 AI 编写代码固有的风险。

最后，AI 正在融入 DevOps 2.0 工具和流程的整个软件交付管道中。新兴的协议，如代理控制协议（ACP）、模型上下文协议（MCP）和代理间协议，正在帮助实现 AI 模型与更广泛的工具、系统和数据生态系统的无缝交互。这些协议定义了 AI 代理与工具交互、安全访问数据和在限制范围内执行任务的标准化方式——从而实现更动态和自主的工作流程。

在现代 DevOps 环境中，这些协议充当 AI 能力和运营基础设施之间的桥梁，使 AI 能够做到不仅仅是观察和建议；它们赋予它采取有意义行动的能力，同时保持可审计和合规。随着 DevOps 2.0 拥抱越来越智能的自动化，这些协议为安全、可扩展和有效的 AI 驱动型操作提供了基础，这些操作将加速开发者工作流程。想象一下能够生成代码、注释、测试和基础设施脚本的工具，或者使用自然语言搜索提取相关的代码片段。此外，机器学习通过仅执行相关的测试来加速测试周期。

利用人工智能，这些工具在入职期间提供个性化指导，检测漏洞并提供修复建议或启动修复，甚至帮助编写和理解政策。通过分析可观察性遥测来识别何时需要回滚，从而提高了部署的可靠性。AI 通过分析功能实验来理解变化的影响。这种贯穿整个软件开发生命周期（SDLC）的 AI 驱动型转型正在提高生产力、改善质量、降低风险，并增强整体开发者体验。

随着开发者能够使用 AI 编码助手越来越快地编码，企业快速且安全地将更改部署到生产中并了解这些更改是否有益的能力将成为创新的限制因素。要做好这一点，需要既做好 DevOps 的基本工作，又在每个交付阶段注入前沿的 AI。

# 摘要

现代软件交付强调快速发布、无缝体验和持续创新，推动了转型传统 DevOps 实践的需求。虽然 DevOps 1.0 通过 CI/CD 和初步的跨团队合作奠定了基础，但其依赖于由不同解决方案构建的复杂工具链，这造成了障碍。这些挑战源于应用程序日益增长的架构复杂性（微服务、容器）、开源组件的激增以及管理日益多样化的工具集的需求。DevOps 2.0 旨在通过简化开发者体验、提供更多集成和智能的工具集，并在整个管道中自然地注入 AI 来解决这些问题。这一演变承诺将带来更高的效率、增强的质量，并专注于交付价值而不是仅仅管理工具。

此外，AI 原生软件交付用自主代理（例如，代码、DevOps、安全）取代了静态自动化，以实现自我优化的系统和积极主动、统一的生态系统。它加速了开发速度，提高了可靠性，确保了合规性，降低了成本，并通过自主代码生成、上下文管道创建、预测性故障解决和实时决策，促进了可扩展的协作。虽然这是变革性的，但组织必须解决 AI 管理、数据隐私和技能差距，以充分利用其优势。

在第 2、3 和 4 章节中，我们将介绍 DevOps 自动化的核心内容。这包括有效的版本控制中的源代码管理、使用持续集成进行构建和测试以提高开发效率，以及使用持续交付系统内部部署以实现无缝的软件发布。我们将探讨 DevOps 1.0 的方法以及 DevOps 2.0 提供的机遇。

^(1) Kent Beck 等人，《敏捷软件开发宣言》（[“Manifesto for Agile Software Development”](https://agilemanifesto.org)，2001，敏捷联盟）。检索日期：2010 年 6 月 14 日。
