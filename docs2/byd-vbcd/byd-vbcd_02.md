# 第一章. 简介：什么是氛围编码？

AI 正在重塑我们构建软件的方式，引入了从自由式提示到结构化辅助的各种新的编程范式。想象一下，通过简单地*描述*你希望软件执行的操作——几乎就像与队友交谈一样——而 AI 将这些想法转化为代码。这就是*氛围编码*的精髓，这是一种以提示为先、探索性的方法，你用自然语言描述你想要的内容，让大型语言模型（LLM）填补空白。这个术语最近由 AI 先驱安德烈·卡帕西（[Andrej Karpathy](https://oreil.ly/Ot6CR)）提出，用以描述这种新的编程方式，其中开发者“完全屈服于 AI 辅助的节奏”。

在这本书中，我将更深入地探讨氛围编码对专业开发者意味着什么，以及它与我所称的*AI 辅助工程*——一种更正式的增强编码过程——如何比较和补充。我将探讨在这个以 AI 为先的时期，开发者角色是如何演变的，哪些工具和工作流程可以最大化你的效率，以及如何应对在代码库中让 AI 自由发挥的独特挑战。我还会探讨氛围编码的优势、劣势，以及如何平衡 AI 生成的速度与人类监督的智慧。到那时，你应该对如何在你的编码实践中利用“氛围”——负责任且有效地——成为不仅速度更快，而且在 AI 时代更具创造力和影响力的软件产品工程师有一个清晰的了解。

在本章中，我们探讨开发者角色如何从为机器编写详细指令转变为通过表达意图与 AI 协作（参见图 1-1）。我们将了解这种编程中的“氛围转变”为何如此重要，它在高层次上是如何运作的，以及它带来了哪些机遇和挑战。

![图片](img/bevc_0101.png)

###### 图 1-1. 使用意图进行编程的概念性插图。开发者提供高级规范（“意图”），AI 将其转换为代码。这突出了从逐行编写代码到在高级别引导代码生成的转变。

# AI 编码光谱：从氛围编码到 AI 辅助工程

在过去的一年里，我观察到开发者——尤其是中级和高级 Web 开发者——在他们的工作流程中拥抱 AI 的方式出现了有趣的分化。一端是氛围编码。另一端是我将称之为*AI 辅助工程*的方法：一种将 AI 编织到软件开发每个阶段（从设计到测试）的纪律性方法，在明确的约束下进行。这两种方法都利用了强大的 AI，但它们的目标、受众和期望有显著差异。在这本书中，我将探讨这两种极端，以及它们对现代 Web 开发的意义。

## 氛围编码方法：通过对话进行编码

在振动编码中，你利用强大的 LLM（大型语言模型）作为编码伙伴，让他们处理代码生成的繁重工作，这样你就可以专注于更高层次的目标。正如[Business Insider 的一篇总结](https://oreil.ly/nvcFW)所说，振动编码“意味着使用 AI 工具...在编码中进行繁重工作，以快速构建软件。”正如 NVIDIA 的首席执行官黄仁勋所说，得益于 AI，“最新的热门编程语言”是英语，而不是 Java 或 Python。你不需要手动输入每个函数和错误修复，而是用自然语言与 AI 互动——勾勒出功能，审查建议，并根据 AI 的输出进行迭代。

这种方法代表了从传统编程到 AI 辅助开发的重大转变。传统的编码需要仔细规划、语法精确性，以及通常痛苦的调试。振动编码颠覆了这一模式：“这实际上并不是编码——我只是看到东西，说出东西，运行东西，复制粘贴东西，大部分都奏效，”Karpathy 对 Business Insider 开玩笑说，突出了 AI 如何将高级指令转化为几乎无需手动努力的工作代码。

开发者从为计算机编写详细指令转变为在 AI 的帮助下*编排结果*。例如，[Karpathy 描述](https://oreil.ly/Ki6iJ)通过不断接受 AI 的建议来构建一个网络应用程序：“我总是‘接受全部’，不再阅读差异了。……当我收到错误信息时，我只是复制粘贴它们。……有时 LLM 无法修复一个错误，所以我只是绕过去或者要求随机更改直到它消失。”代码“增长”超出了他通常自己编写的代码，但项目通过迭代提示和修复迅速完成。本质上，振动编码将编码视为与你的 AI 搭档程序员进行交互式对话，而不是作为独自通过语法和堆栈跟踪的苦行。

几个趋势汇聚在一起，使得振动编码成为可能。首先，现代 AI 编码助手（如 OpenAI 的 Codex、ChatGPT、Anthropic 的 Claude 等）在生成和纠正代码方面变得令人惊讶地出色。在同样的帖子中，Karpathy 指出这是“因为 LLM...变得太好了”——它们吞噬了大量的 GitHub 代码，并能针对许多任务产生合理的解决方案。

其次，新的开发者工具已经出现，可以将这些模型无缝集成到编码工作流程中（稍后将有更多关于这些工具的介绍）。最后，开发者社区的心态正在演变，开始信任 AI 在更大和更大的工作部分上的辅助。这不再仅仅是增强版的自动完成；它是将整个函数或文件交给 AI。从实际的角度来看，振动编码常常感觉像是拥有无限供应的渴望的初级开发者来实施你要求的一切——除了它们以云计算的速度工作。

vibe 编码最令人瞩目的承诺之一是提高生产力。早期采用者报告称，他们能够以前十到一百倍的速度创建软件功能或原型。例如，[Codeium Windsurf 工程师 John Hoestje 沉思](https://oreil.ly/_nfZn)，“为什么只做一个 10 倍工程师，而不做一个 100 倍工程师呢？”这表明，有了正确的 AI 驱动的 IDE，非凡的生产力是触手可及的。像 Windsurf 这样的 AI 增强 IDE，“可以显著加快开发时间，让你实现 100 倍的生产力。”虽然 100 倍可能是一个极端的场景，但即使是更保守的研究也发现了巨大的收益。

开发者可以在几秒钟内生成样板代码，在眨眼间修复错误，甚至让 AI 编写测试或文档，将原本需要几天的工作流程压缩到仅仅几小时。不再受打字速度或记忆力的限制，一个配备 AI 的单个开发者通常可以在周末内原型化一个全栈应用——这在过去可能需要一个小团队几周时间才能完成。这不仅仅是炒作；正如我在 2025 年 1 月为*实用工程师*写的[博客文章](https://oreil.ly/khEfs)中提到的，调查显示，*75%的开发者*已经将某种形式的 AI 集成到他们的工作流程中，许多公司报告开发速度提高了两位数或三位数的百分比。简而言之，AI 配对程序员正在将传说中的“10 倍工程师”现象转变为一个真实且可触及的 100 倍工程师现象。

要理解这是多么革命性的，可以考虑一个具体的例子。一个开发者想要构建一个简单的网页应用，用于统计播客脚本中的单词数并估算阅读时间。他们不是从头开始，而是打开一个 AI 驱动的编码环境，并*告诉*AI 他们的想法。几分钟内，AI 就产生了一个可工作的原型。然后开发者说，“让统计计数器的颜色鲜艳，并添加 PDF 导出功能”，AI 就相应地更新了代码。结果是，一个功能性的工具，只需一键部署——所有这些都在 10 分钟内完成。这个现实世界的场景([由使用 Replit 的 AI 的创作者报道](https://oreil.ly/guqFZ))展示了如何通过高级请求驱动实现极快、迭代的开发。同样，非工程师也在加入：同一篇文章描述了一位没有编码背景的下岗营销人员，他使用 AI 编码助手构建了 100 个简单的网页工具，这些工具共同登上了 Product Hunt 的榜首。当创建软件的门槛降低到如此低的水平时，我们不仅提高了经验丰富的开发者的生产力——我们从根本上扩大了谁可以开发软件的范围。

然而，vibe coding 存在严重的警告。因为你将如此多的任务委托给了 AI，你可能会得到一些“工作”的代码，但在快乐路径下隐藏了满地的地雷或糟糕的设计决策。没有稳固的计划或限制，LLM 可能会生成缺乏适当错误处理、安全检查或可扩展性的解决方案。事实上，AI 生成的代码有时可能建立在沙滩上：它看起来很坚固，但隐藏的问题只有在实际条件下才会暴露出来。我见过一些案例，开发者通过 vibe coding 在创纪录的时间内完成了一个完整的功能，但后来发现代码效率低下且难以维护。这种“纸牌屋”式的代码在压力下可能会崩溃。

例如，想象一下要求一个 AI“快速制作一个用户登录系统”。AI 可能会迅速生成一个工作的认证流程，但可能使用了简化的加密方法或已知的易受攻击的库。如果你在未进行深入检查的情况下部署它，你是在盲目地相信一切都很安全。经验丰富的工程师知道这是有风险的：在生产环境中运行的代码必须被理解和信任。正如[一位专家](https://oreil.ly/ppXCf)所说：“通过 vibe coding 直接进入生产代码库显然是危险的。我们作为软件工程师所做的许多工作都涉及现有系统的演变，其中底层代码的质量和可理解性至关重要。”vibe coding 在极端情况下可能会绕过这些质量关卡。

另一个挑战是，vibe coding 往往低估了前期规划的重要性。传统的软件工程重视清晰的设计和通过数据模型进行约束性思考，选择合适的模式，并至少编写出最小规格说明。vibe coding 则相反：它从*无框架*开始，直接通过提示进入实现。这可能导致开发过程变得混乱。你可能会通过提示进入一个死角——比如说 AI 选择了一个你未打算使用的状态管理方法或库，现在你必须要么引导它回到正轨，要么忍受它。没有初始蓝图，最终的架构可能杂乱无章。这对于快速的概念验证来说是可行的，但在一个需要一致性的大型代码库中却是个麻烦。

Vibe coding 本身并不是“坏”的。事实上，它的出现是编程民主化进程的一部分。它降低了创建软件的门槛，就像早期的低代码平台或脚本语言所做的那样。一个有明确想法的动机非工程师可能仅通过 vibe coding 就能构建一个简单的应用程序。对于经验丰富的开发者来说，vibe coding 可以是一个强大的头脑风暴工具——它就像伪代码，但具有立即可运行的成果。关键是认识到它的局限性。没有纪律的速度可能导致软件脆弱，因此 vibe coding 需要一个警觉的人类参与其中。我经常提醒开发者（包括我自己），“vibe coding 不是低质量工作的借口。”它应该是解决方案的*开始*，而不是结束。

## 人工智能辅助工程方法：与人工智能伙伴一起构建结构

在我们的光谱的另一端是*人工智能辅助工程*——一种更结构化、更有条理的软件构建方式，其中人工智能作为每个步骤的副驾驶。在这里，开发者仍然牢牢掌握方向盘。人工智能辅助工程包括在传统的软件开发生命周期（SDLC）中使用人工智能，例如人工智能驱动的自动完成、聊天、代码迁移、错误检测、测试生成以及细粒度（功能、模块、组件）和完整代码生成（见图 1-2）。

![图片](img/bevc_0102.png)

###### 图 1-2\. 首先计划的人工智能辅助工程工作流程：开发者创建规范，向人工智能系统提供有针对性的提示，审查生成的代码片段，并将批准的解决方案集成到他们的项目中。

你从一份计划开始（即使它很轻量级），概述你需要构建的内容，并在一开始就定义约束和验收标准。然后，你以有针对性的方式整合人工智能工具来加速或增强该计划的某些部分。与“提示优先”的编码风格相比，我们可能会称之为“计划优先”的开发，并辅以人工智能支持。这可能是像迷你产品需求文档（一个特性的简短 PRD）那样正式，或者只是一个任务清单。关键的区别在于，在让人工智能放手之前，你将工作建立在*明确的意图和约束*的基础上。

考虑一个被分配创建新交互式仪表板组件的 React 开发者。在人工智能辅助工程方法中，他们可能首先写下组件的职责和 API：

> 仪表板组件显示分析卡片列表，支持按日期范围过滤，并具有刷新和导出按钮。它应从我们的 API（带有适当的错误处理）获取数据，并且必须遵循我们的设计系统进行样式设计。

这个大纲本质上是一个规范。开发者甚至可能快速绘制一个数据模型或识别现有的实用函数以供重用。然后，他们才引入人工智能：例如，使用具有生成组件骨架功能的人工智能 IDE 或编码助手，基于该描述。人工智能可能会提供一个 React 组件的起始实现，其中包含数据获取占位符和模拟的事件处理程序。由于开发者提供了明确的指导，人工智能的输出更有可能与项目的需求一致（例如使用正确的设计系统类或调用正确的 API 端点）。代码不是惊喜；它是良好请求的结果。

AI 辅助工程不仅仅局限于生成单个组件的代码。它以一种受控的方式渗透整个开发周期。对于常规编码任务，GitHub Copilot 这样的 AI 自动补全工具可以在你键入时建议接下来的几行，当你实现已知模式时节省按键。例如，当你编写单元测试时，你的 AI 助手可能会根据函数名自动建议断言。说到测试，一旦功能到位，你可以使用 AI 生成测试用例——将组件的规格或代码输入提示以获取应检查的边缘情况的建议。目的是**增强**工程师的工作，而不是取代它。你仍然在思考逻辑并验证正确性；AI 只是卸载了一些繁琐的工作。

当涉及到代码迁移或重构时，AI 可以是一个救星。想象一下，你需要将基于类的 React 组件转换为具有钩子的现代函数组件。而不是手动完成所有工作，你可以要求 AI 助手转换代码或至少概述步骤。有了对旧模式和新型模式的良好理解，LLM 可以生成重构代码的草案，然后你对其进行审查和润色。这种结构化的 AI 使用方法逐个解决定义明确的任务（如“将此代码从 Redux 迁移到 React Context API”），而不是给 AI 一个开放式的“构建任何东西”的命令。

AI 辅助工程最戏剧性的形式可能是使用 AI 从详细规格中生成完整的迷你应用程序或功能。现在有几款工具允许你输入应用程序的描述，类似于迷你 PRD，然后得到一个可工作的代码库或原型。例如，开发者可以提供以下规格：

> 一个具有 React 前端和 Node.js 后端、支持用户身份验证和实时更新的待办事项应用程序

AI 工具将构建项目框架，创建关键组件，并设置数据库模式。

这不是魔法；这只是勤奋的工程师在开始一个新项目时可能采取的加速版本（设置目录、选择库、编写样板代码）。重要的是，AI 的创造力是**受限于规格中给出的约束**。结果是符合你提供要求的最低可行产品（MVP）。经验丰富的开发者，如果正确处理这个输出，不会假设它在一开始就适合生产。相反，他们会将其视为初稿。他们会运行应用程序，编写或重新生成测试以验证每个功能，检查代码中的任何不一致或不安全的配置，并在需要时进行改进。简而言之，他们会应用他们所有的常规工程严谨性——只是通过 AI 从蓝图生成大量代码的能力而加速。

人工智能辅助工程的目标与 vibe coding 的目标不同。这里的目的是不仅快速获得*可工作*的代码，而且更有效地获得*高质量*的代码。这是关于提高生产力同时保持（甚至提高）结果的可信度。实践人工智能辅助工程的团队可能会说：“我们希望以两倍的速度交付这个功能，但对我们标准零妥协。”

这种方法的受众通常是那些已经建立了流程（代码审查、测试、部署管道）的专业开发者和团队，他们不愿意放弃这些流程。这些是中级到高级工程师，他们将人工智能视为工具箱中的一种强大新工具，而不是工具箱的替代品。他们可能已经看到了当你走捷径时会发生什么，因此他们重视保持软件可维护性的实践。（相比之下，vibe coding 的受众包括独自开发演示的独立开发者、有一定编码知识的以产品为导向的人，甚至相对较新的程序员，他们利用人工智能来弥补他们专业知识中的不足。）

在人工智能辅助工程中，人们的期望是保持人类对决策的控制，而人工智能提供建议或加速器。代码质量、性能和安全仍然至关重要，因此每个由人工智能生成的作品都应接受与初级开发者编写的作品相同的审查。将人工智能视为你的实习生，而不是你的替代者。你可能将任务委托给它，但必须审查其工作。就像你永远不会在没有代码审查的情况下部署由人类实习生编写的代码一样，你不应该在没有理解的情况下部署由人工智能编写的代码。这种心态将工程学科置于首位。

## 不同的思维方式，不同的期望

Vibe coding 和人工智能辅助工程是两种不同的思维方式。Vibe coding 是自上而下和探索性的：你从一个广泛的想法开始，通过与人工智能的交互来让实现出现。这有点像即兴爵士乐——结构最少，有大量的创意即兴空间，你在演奏的过程中发现歌曲的形状。人工智能辅助工程是系统性和迭代的：更像是古典作曲，你从一个主题或动机（你的需求）开始，并系统地发展它，也许在乐谱的范围内进行一些即兴创作（人工智能的建议）。两者都可以产生“音乐”，但过程和结果类型将不同。

对于一个中级或高级的 Web 开发者来说，你对每种方法的期望至关重要。如果你在“氛围式编码”，你期望会有惊喜。人工智能可能会提出你不会自己写的方案——也许它使用了你不太熟悉的库或编程习惯。吸引力的一部分在于从这些惊喜中学习，或者快速克服你发现乏味的事情。但你也需要预料到会有一些小插曲。热衷于氛围式编码的人应该带着清醒的头脑进入，知道他们将负责那个棘手的最后阶段。魔法是真实的，但并非万能。

如果你正在实践人工智能辅助的工程，你对长期项目的期望会更加谨慎，并且可以说是更加现实的。你期望人工智能能为你节省时间，也许能启发一两个解决方案，但不是完成整个工作。实际上，一个优秀的人工智能辅助工程师可能会在更大的框架内使用“氛围式提示”的“微剂量”。例如，在实现一个明确指定的模块时，他们可能会暂时切换到“氛围模式”，询问：“嘿，AI，生成一个快速的工具函数来格式化这些日期，”然后立即切换回工程师模式，整合并检查该函数。这种心态是，人工智能是一个在你的指导下工作的合作伙伴。你分配给它擅长完成的任务（如模板代码、重复性代码、粗略实现），而其余的你自己处理（关键逻辑、集成、最终审查）。

这里的期望包括提高生产力、减少机械错误（例如，人工智能不太可能拼错变量名），以及可能更广泛的解决方案搜索空间（人工智能可能会提出你未曾考虑过的算法）。但你也期望在验证上投入时间。调试人工智能辅助的代码仍然是调试：你需要运行测试，并在需要时在调试器中逐步执行代码。区别在于，你可能会发现自己正在调试人工智能为你编写的代码，这是一种新的体验，需要一定的学习曲线。第五章将详细讨论这一体验。

这两种方法的目标突出了它们之间的一个基本区别：氛围式编码优化的是短期内的“速度”，而人工智能辅助的工程优化的是“持续的速度和可靠性”。一个氛围式编码者可能会说：“我需要今晚让这个应用运行起来，看看这个想法是否可行。”而一个人工智能辅助的工程师会说：“我需要快速构建这个功能，但它应该足够健壮，能在我们的代码库中存活多年。”前者如果代码基本能运行就满意了；而后者关心的是代码是否足够干净，以便其他人可以在此基础上构建。

这些差异自然地吸引了不同的受众。经验较少的开发者或那些非工程学科的人可能会倾向于氛围编码，因为它降低了入门门槛并提供了即时满足感。我遇到过一些产品经理和设计师通过氛围提示尝试编码，几乎将 AI 当作一个超级强大的 Stack Overflow，它为他们提供了完整的解决方案。另一方面，经验丰富的开发者和工程团队往往更喜欢 AI 辅助工程。他们之前曾因脆弱的代码而吃过亏，因此他们从“让我们正确地做这件事，即使我们使用新工具来加快速度”的角度出发。他们前期投入了更多努力（编写那个迷你 PRD，设置项目结构），以换取长期回报。

## 在光谱上找到你的位置

很容易问：哪种方法更好？事实是，氛围编码和 AI 辅助工程并不是相互排斥的类别：它们代表了光谱的两端，现实世界的流程通常融合了两者的一些元素。开发者可能开始一个项目时用一阵氛围编码来构建一些新颖的东西，然后切换到工程模式来巩固它。或者，他们可能通常遵循 AI 辅助的学科，但偶尔——对于一个小型的单次脚本或一次性原型——可能会说：“你知道什么，我就这样氛围编码看看我能得到什么。”关键是理解权衡并使用适合特定情境的正确方法。

将氛围编码视为一种高速的探索性车辆：它能够迅速带你离开常规路线，非常适合发现。AI 辅助工程则更像是在轨道上的可靠火车：你必须先铺设轨道（规划），但这是一种更安全的赌注，更有可能在不脱轨的情况下到达一个明确的目的地。中级和高级开发者应该能够驾驶这两种车辆，但他们将根据手头的任务来选择。如果目标是快速创新或构思（比如在黑客马拉松或验证一个想法的可行性时），氛围编码提供了动力。但请记住，如果你打算重用那段代码，一定要确保代码整洁。如果目标是在一个专业环境中构建一个可维护的产品功能，那么倾向于 AI 辅助工程可以确保你不会在代码库中留下一个没有人真正理解的黑盒代码块。

我观察到的一个有趣的现象是，随着开发者对 AI 工具的实践经验增加，他们的使用往往自然地从氛围端转向工程端。最初，AI 从单个提示中生成整个代码块的新奇性非常吸引人——谁不想尝试“谈话”一个应用出来呢？

但蜜月期过后，现实主义开始发挥作用。开发者开始看到人工智能的亮点和不足之处。他们学会了将问题分解成小块，并分批提供给人工智能，而不是一次性要求整个解决方案。实际上，他们从“提示艺术家”转变为成为人工智能“乐团指挥”——仍然利用人工智能的创造力，但用熟练的手法引导，并遵循清晰的乐谱。在我的实践中，我变得更加谨慎地使用提示，经常编写小块的伪代码或注释，并要求人工智能完成它们，而不是仅仅提出开放式问题。这样，我得到了类似 vibe 的流畅性，但又在可控的结构中。

值得注意的是，工具也在不断发展，以支持整个谱系。一方面，我们有基于聊天的界面和专门为 vibe 编码设计的自然语言编码环境，你可能甚至直到请求时才看到代码。另一方面，IDE 正在添加人工智能功能，这些功能无缝地融入传统编码：例如，建议改进的人工智能代码检查器，解释代码的文档生成器，以及可以自动创建拉取请求并建议审查更改的版本控制机器人。这些工具通过适应常规的开发工作流程（编辑、审查、测试等）来鼓励工程思维，同时仍然利用人工智能。

随着最佳实践的浮现，vibe 编码和人工智能辅助工程之间的区别甚至可能随着时间的推移而变得模糊。我们可能会发现，今天感觉像“vibing”的东西将获得更多的约束，而感觉像“结构化工程”的东西将变得更加灵活。事实上，我会争辩说，理想未来的目标是我们能够轻松地在这一谱系中上下移动：当我们想要探索创造性解决方案时，与人工智能一起探索，但在需要将软件固化并发布时，始终用坚实的工程实践来控制一切。

这种方法谱系代表了我们在今天如何与人工智能工具合作的重要演变。然而，即使我们改进了与人工智能协作的技术——无论是通过快速 vibe 编码还是结构化工程工作流程——一种更根本的变革正在形成。编程本身的本质正在改变。我们正在从开发者必须将他们的想法转化为明确指令的传统范式，转向一个未来，我们可以直接表达我们的意图，让人工智能处理代码的翻译。

这种转变挑战了我们关于成为程序员意味着什么的最基本的假设。几代人以来，我们的价值与我们的能力紧密相连，即像机器一样思考——将问题分解成离散的逻辑步骤，让计算机执行。但当机器能够理解我们*想要*什么，而不仅仅是他们被告知做什么时，会发生什么呢？这就是*意图编程*出现的地方，它不仅仅代表了一种新的工具或技术，而是一种对开发者角色的根本性重新构想。

# 超越代码行数：意图编程

几十年来，编程意味着编写指令：一行又一行的代码告诉计算机*如何*做某事。每个函数、循环和条件都必须由人类精心制作。意图编程翻转了这个剧本。开发者不再关注低级实现，而是关注结果或目标：你希望程序完成什么。你以高级方式（通常是用自然语言）表达这种意图，然后 AI 系统找出满足它的代码。

这样想吧：传统的编码就像给某人提供一步一步的指示，而基于意图的编码就像告诉他们你的目的地，然后让他们找出最佳路线。通过关注*什么*而不是*如何*，开发者可以在更高的抽象级别上工作。这种方法并不完全新颖——像可视化编程、低代码平台和代码生成器这样的工具长期以来都承诺提高抽象级别。但今天的 AI 进步终于使以普通语言描述复杂行为并得到实际代码成为可能。

## 提示词的兴起：从指令到描述

这种转变的核心是谦逊的提示词。*提示词*是你提供给 AI 编码系统的输入或问题。本质上，它是对你希望程序做什么的描述，而不是如何做的指令。这可能会感觉与编写代码非常不同。例如，你可能会提示而不是编写一个解析文件的循环：

> 读取这个 CSV 文件并提取所有 18 岁以上的用户的电子邮件地址。

AI 将尝试生成完成该描述的代码。

为什么现在会发生这种情况？LLMs 在理解和生成文本方面的快速进步，包括编程语言，已经是一个转折点。这些 AI 模型在大量代码和自然语言文本上进行了训练。它们可以解释看起来像软件行为描述的提示，并将其翻译成实现该行为的实际代码。换句话说，它们已经学会了人类描述任务的模式以及这些任务如何转化为代码。

这种基于提示的开发兴起意味着，作为开发者，你越来越多地用自然语言或伪代码来描述功能和逻辑，并让 AI 处理编写语法正确的代码的繁重工作。提示成为你新的思维单元。它是对意图的简洁表达。我们已从告诉电脑“先做 X，然后做 Y，接着做 Z”转变为说“我需要完成 X、Y 和 Z”，并相信 AI 会填补空白。

重要的是要注意，编写一个好的提示本身也是一种技能（我们将在第三章中深入探讨）。模糊的提示可能导致错误的或不高效的代码，就像模糊的需求可能会让人类程序员感到困惑一样。你能在提示中更好地表达你的意图，AI 的输出就会更好地满足你的需求。这就是为什么许多人称提示编写为新的编程素养。

## 它是如何工作的：迭代周期和 AI 在代码生成中的作用

那么，AI 是如何从你的自由描述到实际、可运行的代码的呢？魔法在于 LLM（大型语言模型）解释上下文和生成文本的能力。“大”在“大型语言模型”中指的是它拥有的参数数量（内部配置），通常是数十亿或更多，这使得它能够捕捉自然语言和编程语言的复杂性。这些模型已经在公共代码存储库、论坛、文档和问答网站上进行了训练，学习编程语言的语法以及代码如何用于解决问题的语义。当你与 AI 编码器互动时，你正在利用这种广泛的学习知识。让我们用简单的话来分解它：

理解提示

当你提供一个提示（例如，“生成一个检查数字是否为素数的函数”）时，AI 模型会分析该提示的文本。来自谷歌、OpenAI 和 Anthropic 的现代模型已经在无数的语言和代码示例上进行了训练，因此它们使用统计模式来推断你提出的问题。本质上，AI 试图*预测*提示最可能的代码完成，使其有意义。

利用上下文

这些 AI 系统通常还会考虑单行提示之外的其他上下文。例如，如果你在与 AI 助手一起工作的 IDE 中工作，模型可能还会考虑当前文件内容、你的编码风格、注释，甚至相关文件。所有这些上下文都有助于 AI 生成适合你项目的代码。这类似于人类开发者阅读周围的代码和文档来了解下一步该做什么。

生成代码

一旦模型理解了（或至少对您的意图做出了最佳猜测），它就会开始生成代码。在底层，它一次生成一个标记（标记是单词或代码符号的一部分）使用在训练期间学到的概率。模型并不以传统意义上的“思考”来“思考”；它没有编译器或运行时检查代码。它只是非常擅长以高概率继续文本，因为它之前已经看到了很多示例。如果提示和上下文清晰，它产生的代码可以非常准确，甚至可以遵循其在训练数据中看到的最佳实践。

在人工监督下进行验证

重要的是，AI 不会自行运行并部署您的应用程序。您仍然处于循环中。您审查生成的代码，测试它，并可以接受或修改它。在许多情况下，如果被要求，AI 也可能提供代码的解释，帮助您理解结果。AI 的角色就像一个为您起草代码的助手——但您，作为开发者，仍然是确保代码正确并符合项目需求的决策者。

真正令人印象深刻的是，这个过程在几秒钟或更短的时间内完成。高级概述是，您的描述（提示）进入预测引擎（LLM），产生可能的代码作为输出。虽然模型的内部工作涉及复杂的数学和神经网络层，但在用户层面，它几乎感觉就像与一个能够立即回忆起如何实现几乎所有事情的专家合作。

关于 vibe coding（基于意图的编程）的一个关键理解是，它是在人类和 AI 之间的一种迭代、协作过程。您不仅仅写一个完美的提示，然后坐下来让 AI 完美地编写整个程序。在实践中，您参与来回交流，一个反馈循环，逐渐将一个模糊的想法转化为精炼的代码。

典型周期可能看起来是这样的：

第 1 步：您描述您想要的内容

这是您的初始提示或请求。例如：

> 生成一个函数，根据本金、利率和期限计算月度贷款还款额。

第 2 步：AI 提供初始解决方案

AI 为该功能生成代码，包括贷款支付的参数和公式。甚至可能包含解释公式的注释。

第 3 步：您审查和测试

您查看代码。它有道理吗？它能处理边缘情况吗？您进行快速测试：如果利率为 0 呢？它表现正确吗？您注意到它可能无法很好地处理这种情况。

第 4 步：您细化您的请求或代码

如果代码不完美（而且通常第一次尝试就不会完美），请对其进行细化。也许您再次提示 AI（“修改函数以优雅地处理 0%利率”），或者自己编辑代码并告诉 AI，“解释这部分”，如果有什么不清楚的地方。这种指导有助于纠正任何误解。

第 5 步：AI 细化解决方案

人工智能接收你的反馈或新的提示，并调整代码。现在函数检查零兴趣并适当地处理它。

第 6 步：根据需要重复

你继续这个循环，直到满意为止。也许接下来你会要求人工智能也为这个函数生成单元测试，以确保它正确工作。它做到了，然后你运行它们以验证一切正常。

这种合作类似于一种双人编程场景，其中一方是人类，另一方是人工智能助手。人类设定方向并了解高级需求，而人工智能提供建议、编写模板代码并加快繁琐部分的工作。单独使用任何一方对于复杂任务都是无效的：人工智能依赖人类的方向和验证，而人类将一些工作委托给人工智能以加快速度。

关键的是，迭代不仅仅是修复错误；它还涉及解决方案的演变。你可能从一个非常粗略的提示开始，然后随着你看到人工智能产生的结果，逐步细化你的意图。

这鼓励了一种实验心态。如果第一次尝试不正确，你并没有浪费太多时间——只需细化提示或调整代码再试一次。在传统的编码中，编写一个模块然后丢弃可能会令人沮丧，但有了人工智能生成的代码，错误开始的成本很低，鼓励探索不同的方法。

# 生产力、可访问性和编程性质的转变

为什么有意图的编程如此重要？这种转变有几个深远的影响：

提高开发者生产力

最直接的好处可能是速度。当人工智能处理常规工作时，开发者可以更快地完成任务。可能需要手动编写数小时才能完成的常规代码（如设置数据库模型、API 端点或数据清洗脚本）通常可以在几分钟内生成。早期对人工智能编码助手的研究证实了这一点：使用 GitHub Copilot 等工具的开发者已经显示出完成任务速度显著提高（[一项研究](https://oreil.ly/4Ksmy)发现，在有 Copilot 辅助的情况下，某个特定任务的时间减少了 55%）。当你将这些收益乘以整个项目时，它预示着一个未来，其中软件开发周期将大大缩短，团队可以更快地迭代。

让开发者“保持流畅”

除了原始速度之外，还有心理上的好处。编写模板代码或查找语法可能会打断程序员的流畅性和思维流程。有了人工智能处理许多这些中断，开发者可以专注于他们正在解决的问题。[许多用户报告](https://oreil.ly/inQHR)说，有了人工智能的帮助，他们感到不那么受繁琐任务的困扰，可以专注于编码的创造性和设计方面。换句话说，它可以通过卸载无聊的部分来使编码更加愉快，这反过来可以提高工作的质量（快乐的程序员往往能写出更好的代码）。

降低入门门槛

传统的编程需要学习代码的严谨语法以及各种库和框架的怪癖。在基于意图的编程中，一些负担转移到了 AI 身上。新手可能记不住打开文件的确切语法或绘图函数的参数，但如果他们能描述他们想要的内容，AI 就能填补这些细节。这并不意味着任何人都可以在没有知识的情况下编写复杂的系统（你仍然需要理解程序应该做什么），但这确实意味着产生有用结果的时间缩短了。可以想象，领域专家（如生物学家或经济学家）可以通过描述他们的需求来编写他们领域的原型，即使他们不是专业的开发者。从这个意义上说，编程对那些有想法和意图但没有深厚编码技能的人变得更加容易接近。

开发者角色和技能的改变

随着人工智能在代码生成方面的应用越来越广泛，人类开发者的角色也在不断演变。像架构设计、问题分解和验证这样的技能变得更加重要。你可能会发现自己花更多的时间在决定**要构建什么**以及审查**代码为什么能工作（或不能工作**）上，而不是在编写语法。"知道如何编码"的本质可能转向"知道如何让 AI 进行编码"。这可能会使软件开发的一些方面实现民主化，同时也会提升专业人士操作的水平。我们可能会看到围绕如何有效地引导 AI（我将在第三章中介绍这一主题，并在整本书中回顾）的新最佳实践。

生产力与创造力

有趣的是，随着 AI 处理越来越多的常规编码，人类开发者可以专注于更高层次的创造性任务，如改进用户体验、头脑风暴新功能或解决 AI 可能无法独立解决的棘手算法问题。在这个理想场景中，AI 提高了重复性 80%的编码生产力，释放了你的脑力，用于创新性的 20%。这是我们在分配精力方面的转变。

然而，并非一切尽善尽美。这种新的开发方式也带来了挑战：

信任与正确性

你能信任 AI 编写的代码吗？如果你没有看到每一行，可能会出现错误被忽视的风险。开发者需要彻底测试和审查 AI 生成的代码。确保输出正确、安全、高效的责任在于人类。盲目信任 AI 输出是有风险的，我们将在后面讨论。

失去一些低级技能

如果你依赖 AI 进行常规编码，你是否会逐渐失去从头编写代码或调试深层问题的能力？这是一个类似于过度依赖计算器削弱算术技能的担忧。开发者需要有意识地平衡便利性与保持对基础知识的牢固理解。

职业景观的变化

随着有意图的编程变得普遍，行业可能会重视不同的技能。对于仅仅擅长生成样板逻辑的人来说，需求可能会减少，而对于能够设计系统、集成组件和验证正确性的人来说，需求可能会增加。软件工作的性质可能会发生变化，人工智能将处理更多实现工作，而人类则专注于设计和监督。

此外，“感觉编码”中最关键的因素之一是上下文窗口大小。Gemini 提供了所有人工智能模型中最长的上下文窗口，这在处理大型项目时可能具有颠覆性的影响。一些模型现在支持超过一百万个标记的上下文窗口，这使得它们能够保持对整个应用程序的意识。开发者可以将整个代码库输入人工智能以获得全面的理解。

我们将在本章末尾更深入地探讨这些权衡。但首先，让我们熟悉一下使这种新的编码方式成为可能的新兴工具。

# 工具的概览：新兴生态系统

感觉编码可能是一种哲学，但它是由新一代人工智能工具所实现的。想要拥抱这种工作流程的资深开发者需要熟悉一些关键平台和模型，这些平台和模型使得人工智能辅助编码变得有效。

本节是对感觉编码者工具箱中基本工具的快速浏览。这些工具包括拥有日益增长的 AI 功能和扩展的 Visual Studio Code (VSCode)，下一代人工智能集成 IDE 如 Cursor 和 Windsurf，以及 Claude（其各种版本）和 ChatGPT。本节不涵盖背景编码代理，但我将在第十章（ch10.html#ch10_autonomous_background_coding_agents_1752630045087844）中详细讨论它们。

在阅读本节时，不必担心记住特定的工具名称或功能；这个领域正在快速发展。目标是了解可用的解决方案类型。

## VSCode + Copilot：微软的集成人工智能开发平台

[VSCode](https://code.visualstudio.com) 通过与 GitHub Copilot 的深度集成，已经从世界上最受欢迎的代码编辑器转变为一个综合的人工智能辅助开发平台。这种演变代表了微软将人工智能能力保持在熟悉的环境中的愿景，这个环境是数百万开发者每天都在使用的。

GitHub Copilot 是一个集成到 VSCode 中的人工智能编码助手。它根据自然语言提示和现有代码上下文提供代码建议、解释和自动实现。这种集成与众不同的地方在于其无缝性——Copilot 不仅仅是一个附加组件，它感觉像是编辑器本身的自然扩展。

VSCode 的 AI 能力核心集中在三种主要的交互模式。首先，是*内联代码自动补全*，Copilot 在你键入时提供内联代码建议，从单行补全到整个函数实现。随着你编写代码，会出现带有建议的幽灵文本，你可以使用 Tab 键接受建议，或者逐字部分接受建议。

其次，是可访问的*聊天界面*，通过侧边栏面板进入，你可以就你的代码进行对话，提问，或请求特定的实现。第三，也许是最强大的，是*代理模式*，它通过工具调用访问 Visual Studio 内部不断增长的功能集。当给定一个目标时，它会逐步选择并执行正确的工具。这种代理模式可以分析你的代码库，在多个文件中提出编辑建议，运行终端命令，响应构建错误，并在循环中自我纠正，直到任务完成。

使 VSCode 的 Copilot 实现特别吸引人的是它对模型上下文协议（MCP）的支持。MCP 为 AI 模型提供了一种标准化的方式来发现和交互外部工具、应用程序和数据源。这意味着 VSCode 中的 Copilot 可以连接到数据库，调用 API，访问文档，并集成到你的整个开发生态系统中。例如，启用 GitHub MCP 服务器后，你可以要求 Copilot“为每个我们讨论的 bug 创建一个 issue”，它将直接与 GitHub 的 API 交互以创建这些 issue。通过 MCP 的可扩展性，Copilot 从代码生成器转变为一个全面的发展助手，它不仅理解你的代码，还理解你的整个工作流程。

要在专业开发中有效地利用 VSCode 与 Copilot，首先根据任务复杂度探索不同的交互模式。对于简单的代码补全和重构，依赖于内联建议和出现在错误附近的闪烁图标——点击它以获取 AI 驱动的修复。

对于更复杂的任务，通过打开聊天面板并从下拉菜单中选择“代理”来切换到代理模式。代理模式针对在项目中的多个文件上进行自主编辑进行了优化。它特别适用于需要不仅代码编辑，还需要调用工具和终端命令的复杂任务。VSCode 熟悉的界面与 Copilot 不断发展的 AI 能力的结合，为希望在不离开既定开发环境的情况下获得企业级 AI 辅助的团队提供了一个有吸引力的选择。

## VSCode + Cline：开源自主编码代理

在探索专为 AI 设计的 IDE 之前，值得考察 [Cline](https://cline.bot)（以前称为 Claude Dev）如何将 VSCode 转变为强大的 AI 辅助开发环境。Cline 代表了一种与微软的 Copilot 不同的哲学。它不是作为一个紧密集成的助手，而是一个可以承担从开始到结束的复杂、多步骤开发任务的自主编码代理。这个开源扩展为 VSCode 带来了通常在专有 AI 编辑器中找不到的功能，同时保持了 VSCode 用户期望的灵活性和可扩展性。

Cline 的独特之处在于其对软件开发真正代理式的方法。当您给 Cline 一个高级请求，例如“创建一个具有身份验证功能的用户管理 REST API”，它不仅仅生成样板代码。相反，它会分析您的项目结构，跨多个文件规划实现，创建适当的文件夹层次结构，安装必要的依赖项，甚至可以运行测试以验证实现。在整个过程中，Cline 通过显示每个计划的操作——文件创建、修改和终端命令——并给您机会批准或修改每个步骤来保持透明度。这种 *人工在环* 设计在自动化和控制之间提供了完美的平衡，允许开发者利用 AI 的能力，同时保持对其代码库的监督。

Cline 的技术能力远不止代码生成。它可以利用 *浏览器自动化* 来研究 API 文档，通过分析多个文件中的错误跟踪来调试复杂问题，甚至可以通过其 MCP 支持与外部服务进行交互。对于调试，您可以粘贴错误消息，Cline 将遍历您的代码库以确定根本原因，提出修复方案，实施修复，并添加适当的错误处理以防止类似问题。其 MCP 集成意味着 Cline 可以连接到您的数据库以理解架构，在生成查询之前，访问您的项目管理工具以使实现与需求保持一致，或与任何其他 MCP 兼容的服务进行交互。这种可扩展性将 Cline 从代码生成器转变为全面的发展伙伴，它了解您的整个技术生态系统。

对于团队来说，Cline 提供了几个令人信服的优势。作为开源软件，团队可以检查其代码，贡献改进，或根据定制需求进行分支——这对于具有特定安全或合规性要求的组织至关重要。它支持多个 AI 提供商，包括 Anthropic 的 Claude、OpenAI 的模型、Google 的 Gemini，甚至可以通过 Ollama 使用本地模型，这为团队提供了根据性能、成本或数据驻留要求进行模型选择的灵活性。

要有效地使用 Cline，请创建包含项目上下文和约束条件的详细提示，利用其分析您整个代码库的能力在做出更改之前，并利用其迭代开发功能。Cline 实现一个功能后，您可以立即测试它，并在相同的对话上下文中请求改进。将 VSCode 的成熟生态系统与 Cline 的自主能力相结合，为团队提供了一条强大、灵活且成本效益高的 AI 辅助开发路径，而无需放弃他们现有的工具和工作流程。

## Cursor：AI 驱动的代码编辑器

感觉编码运动的旗舰工具之一是 Cursor，这是一个增强型 IDE，它迅速在寻求更流畅编码体验的开发者中获得了人气。Cursor 实质上是一个以 AI 为首的代码编辑器（实际上是 VSCode 的分支），它将最先进的代码生成和理解直接构建到您的开发环境中。

它的标语是“AI 代码编辑器”，它旨在让您使用简单的语言指令编写和修改代码。例如，您可以突出显示一个函数并要求 Cursor“优化此函数”或“在此处添加错误处理”，它将立即建议代码更改。Cursor 的 AI 能够识别项目——它索引您的代码库并理解您文件的上下文，因此可以提出更相关的建议（远超简单的自动完成）。Cursor IDE 将 LLM 功能集成到其核心界面中。它是了解您代码库的 ChatGPT。

在底层，Cursor 利用先进的语言模型（根据您的设置，通常是 Anthropic 的 Claude 或 OpenAI 的模型）来驱动其功能。它有一个聊天侧边栏，您可以在其中就您的代码进行对话，甚至还有一个用于多步代码生成的“作曲家”模式。安德烈·卡帕西本人就曾使用 Cursor 的“作曲家”模式，配合名为“Sonnet”的模型进行他的[vibe-coding 实验](https://oreil.ly/aFqAO)。这种设置使他能够真正地“说话”（通过“SuperWhisper”的语音到文本功能）并与编辑器交流，代码随即出现，然后他会接受或改进。

Cursor 不仅能够生成代码，还可以根据指令*编辑现有代码*。例如，您可以要求：

> 能否使在传输监听器中切换证书更容易？

Cursor 会理解您正在引用您的代码，并会在相关文件中提出直接编辑建议或从相关文件中读取，例如规范 Markdown 文件（见图 1-3）。在免费版本中，它通常会提供差异比较供您批准；在专业版本中，它可以将更改自动应用到您的开发环境中。

![图片](img/bevc_0103.png)

###### 图 1-3\. Cursor 的界面展示了将 AI 集成到 IDE 中的新一代。通过索引您的项目并对提示进行迭代，Cursor 等工具能够“让您的编辑器持续运行，去拿咖啡，回来时发现功能已经完全可用”，从而带来指数级的生产力提升。

要在专业工作流程中有效地使用 Cursor，你应该系统地利用其功能。首先，在 Cursor 中打开一个聊天窗口，描述你想要的功能或修复。例如：添加一个带有电子邮件和密码的用户登录表单，包括验证和错误信息。Cursor 将以草稿状态生成所需的代码（创建新文件或修改现有文件）。你可以审查这些更改（显示差异或预览），然后点击“应用”将它们合并到你的代码库中。许多开发者遵循这个循环：提示 → 审查 → 接受。如果建议不完美，你可以细化你的提示（例如，“使用 Tailwind CSS 来设置表单样式”）或者直接要求 Cursor 修复你发现的问题（“现在，处理电子邮件已注册的情况”）。本质上，你与你的代码进行对话，直到它看起来很好。

Cursor 在理解错误和日志方面也表现出色。如果你运行代码并得到跟踪回溯或错误消息，你可以将其粘贴到 Cursor 聊天中，通常 AI 会分析它并提出修复建议。这使调试成为一个[协作体验](https://oreil.ly/aFqAO)：而不是你手动搜索 Google 或 Stack Overflow，Cursor 的 AI 通常可以定位问题，甚至编写补丁。但话说回来，验证修复是明智的，因为 AI 可能不会在第一次尝试时就完全正确。

另一个专业技巧：使用 Cursor 的多文件处理能力。你可以选择一组文件（或者在提示中告知项目上下文），这样它在生成代码时会考虑你的整个代码库。例如：在后端添加一个新的 API 端点以支持登录表单，并将其连接到我们刚刚创建的前端表单。Cursor 将回忆起它刚刚编写的代码，并帮助构建相应的后端逻辑。与早期仅按文件工作的编码助手相比，这种项目级上下文是一个变革性的变化。

总结来说，Cursor 就像在你的 IDE 中拥有一个全天候的 AI 配对程序员。它是直观的（你可以用普通语言与之聊天），并且可以直接更新你的代码。你越练习分解任务并用清晰的指令提示 Cursor，你就能在短时间内完成更多的事情。它特别适合迭代开发：你构建一小部分，运行并查看输出，然后立即要求 Cursor 调整或扩展代码，并重复。

## 风帆冲浪：一个具有完整代码库索引的 AI 驱动 IDE

在 vibe-coding 工具箱中冉冉升起的新星是 Windsurf，这是一个 AI 驱动的开发环境，将代码理解提升到了新的水平。Windsurf 是由[Codeium 背后的团队](https://windsurf.com)开发的，它通过索引你的整个代码库并使用检索技术在工作时将相关部分输送到 AI 模型来区分自己。从实际的角度来看，这意味着 Windsurf 在处理大型项目时非常出色，其中问题的答案可能分布在许多文件中。它的核心使用一种称为*检索增强生成*（RAG）的技术，这是一种更高级的说法，即它会查找与你的提示相关的代码部分，并将这些上下文提供给 AI，以便其建议与你的现有代码保持一致。

这对开发者来说意味着什么？假设你是一个新加入的大型代码库的开发者，需要添加一个功能。使用 Windsurf，你可以用自然语言提问：

> 在代码库中用户认证逻辑是在哪里处理的？

它会搜索索引并指向正确的文件或甚至函数。然后，你可能会打开一个聊天（Windsurf 称之为“Cascade”视图，通过 Cmd+L 触发）并说：

> 在登录流程中添加基于电话的双因素认证。

由于 Windsurf 有你的认证逻辑上下文，它可以生成跨越多个文件（数据库、API、前端）的更改来实现这一点，做出与你的系统结构一致的有信息量的选择。

Windsurf 的写模式可以大胆地为你应用更改：它会自动创建新文件或编辑现有文件，而不是仅仅在侧边栏中建议差异。这可以节省大量时间：你不需要从建议中复制粘贴，而是看到你的项目在原地演变。Windsurf 本质上试图在你有信心时代表你采取行动，表现得像一个在代码库中实现功能的自主初级开发者。（Cursor 的哲学稍微保守一些，会要求确认，尽管其 Pro 版本也有“自动应用”功能。）

为了有效地利用 Windsurf，了解其优势很有帮助：

代码库问答

你可以用纯英文查询你的代码库，几乎就像是你项目的定制版 Stack Overflow。这对于大型遗留项目来说非常棒，因为找到某个定义可能需要几个小时。Windsurf 会通过从索引的代码中提取信息，在几秒钟内给出答案。

全局上下文建议

由于它将相关文件输入到模型中，Windsurf 可以很好地处理像“重构支付模块以使用我们编写的新的日志工具”这样的任务，因为它了解支付模块和日志工具。

操作模式

Windsurf 有多个模式（自动完成、聊天、命令和 Cascade，如前所述）。Cascade 就像是一个超级聊天，它可以考虑更广泛的环境。在聊天中的写模式实际上会执行更改。作为工程师的你，可以决定给它多少自主权。

对于团队来说，Windsurf 可以像 Cursor 一样集成到日常开发中。在选择它们之间时，一些开发者更喜欢 Windsurf 的速度和大胆（指出它生成和应用更改感觉更快），以及由于其索引而能够处理非常大的项目。另一方面，Cursor 的界面可能对 VSCode 用户来说更熟悉。这并不一定是一个非此即彼的选择——一些工程师两者都备有，或者团队可能会标准化使用其中一个。

总结来说，如果你想要一个在编写代码前真正“阅读文档/代码”的 AI 编码助手，Windsurf 是一个出色的工具。因为它可以查找信息，所以它最小化了产生幻觉功能或误命名的变量的可能性。为了充分利用它，提供清晰的指令，并在写模式下让它处理大型任务，但也请随意以更受控的方式使用它进行细微调整。始终审查它所做的更改（它会向您展示），特别是对于关键代码。Windsurf 很聪明，但并非完美无缺。明智地使用它，就像一个了解您整个项目的超智能 IDE，可以在其中实现想法，从而大大提高您的效率。

# 人工智能模型：代码生成的领域

人工智能编码领域发生了巨大变化，现在有多个强大的模型正在争夺开发者的关注，包括 Claude、Gemini 和 OpenAI 家族的模型。曾经可能由一个模型主导，但今天的生态系统提供了丰富的选择，每个选项都有独特的优势，使它们适合不同的编码场景。

## 理解模型类别

当前的编码模型通常根据其方法和优势分为几个类别：

速度优化

这些模型优先考虑快速响应，是实时代码完成和快速迭代的理想选择。它们通常在复杂任务上略微降低准确性，以换取更低的延迟。

深度推理

这些模型需要更多时间来“思考”问题，但在复杂调试、架构决策和多步骤问题解决方面表现出色。具有高级推理能力的模型可以逐步分解复杂错误。

多模态巨头

一些模型不仅可以处理代码和文本，还可以处理图像、图表，甚至视频内容。这使得它们在理解视觉文档或与 UI/UX 元素一起工作时特别有价值。

开源替代方案

DeepSeek 通过提供与闭源模型相当水平的 AI 能力，而不需要支付或注册，脱颖而出，尽管它可能缺少一些功能，如图像生成或网络浏览能力。

## 选择适合您任务的正确模型

与其寻求一个单一的“最佳”模型，成功的开发者现在会将模型与特定任务相匹配：

+   对于快速原型设计和通用编码，针对速度和广泛语言支持进行优化的模型效果良好。

+   对于复杂的调试和系统设计，能够有系统地追踪逻辑的深度推理模型是一个不错的选择。

+   对于处理大型代码库，选择具有广泛上下文窗口的模型，这些模型可以保持项目全局意识。

+   对于预算有限的团队，开源模型提供了无订阅成本的优秀价值。

许多工具现在支持多个 AI 模型，包括 OpenAI、Claude 和 Gemini 变体，以及专有模型，允许开发者根据任务切换它们。

## 任何模型的实用技巧

无论你选择哪个 AI 模型，某些实践始终能提高结果。首先，提供丰富的上下文。不要只是要求“一个支付处理函数”。相反，分享你的数据模型、现有的代码模式、错误处理方法以及任何具体要求。你提供的上下文越多，输出与你的代码库的匹配度就越好。

大多数现代编码模型在审查自己的输出方面表现出色。在收到生成的代码后，请模型检查潜在的问题，提出改进建议或解释其推理。这种自我批评通常能捕捉到细微的缺陷或提出优化建议。

利用模型维持对话上下文的能力。从一个基本的实现开始，然后通过后续请求逐步改进它。这种迭代方法通常比试图一次性指定所有内容能产生更好的结果。

每个模型在处理问题的方式上都有细微的差别。有些在解释上更加冗长，而有些则更加简洁。有些默认使用较新的语法，而有些则比较保守。了解这些倾向有助于你制作出更好的提示。

# 主要模型

人工智能编码领域每月都在演变，新的模型定期挑战既定的领导者。竞争已经变得如此激烈，以至于开发者能够从前所未有的选择和能力提升中受益。最重要的是不是选择“完美”的模型，而是理解如何利用任何可用工具的优势。

许多开发团队现在采用投资组合方法——利用快速模型处理常规任务，强大模型处理复杂挑战，以及针对特定领域（如数据库优化或前端开发）的专业模型。一些 IDE 甚至允许在任务进行中无缝切换模型。

成功来自于理解这些选项并战略性地应用它们以加速你的开发工作流程。

## Google Gemini：多模态编码的强大力量

[Google 的 Gemini](https://gemini.google.com)系列通过其本地的多模态能力，代表了人工智能辅助开发的根本转变。与主要在文本和代码上训练的模型不同，Gemini 从头开始设计，以无缝地理解和处理文本、代码、图像、视频和其他数据格式。这使得它在现代开发工作流程中特别强大，其中视觉上下文与文本信息一样重要。

Gemini 的多模态特性在 Web 开发场景中尤其有价值。开发者可以共享设计草图的屏幕截图，Gemini 可以生成像素级匹配视觉风格的实现。它擅长理解图表、图表和 UI 元素，在将视觉设计转换为功能性代码时是一个理想的合作伙伴。这种能力不仅限于简单的图像识别：Gemini 可以推理视觉元素，理解设计模式，并在整个项目中保持美学一致性。

Gemini 通过流行的编辑器（如 VSCode、Cursor、Windsurf）和插件（如 Cline 和 Code Assist）与开发工作流程的集成，为开发者提供了从个人偏好到团队标准的强大定制选项。开发者可以为重复性任务创建自定义命令，为每次代码生成建立规则，并在大型代码库中保持一致的编码模式。慷慨的免费层使其对学生、爱好者和初创企业可访问，而企业功能支持复杂的组织需求。

在编码领域中，双子座（Gemini）之所以与众不同，在于它能够在保持实际速度的同时深入思考问题。该模型可以在快速响应简单任务和进行复杂挑战的深入推理之间切换，根据手头的问题调整其方法。这种灵活性，结合其视觉理解能力，使其在需要前后端逻辑和美学同等重要的全栈开发中特别有效。

## Claude：推理大师

[Anthropic Claude 的编码辅助方法](https://anthropic.com/claude)侧重于透明度和深入的推理能力。Claude 家族，特别是 Sonnet 模型，已经证明在需要仔细分析和逐步解决问题的复杂软件工程任务中特别有能力。Claude 与众不同的地方在于它能够展示其思考过程，允许开发者跟随其推理，并在实施解决方案之前验证其逻辑。

“工件”功能代表了开发者与 AI 编码助手交互方式的范式转变。而不是仅仅在聊天界面中提供代码，Claude 创建了一个专用的代码工作区，其中代码可以实时查看、编辑和预览。这种交互式环境对于前端开发、数据可视化和任何需要即时视觉反馈以加速开发过程的情况特别强大。开发者可以在同一对话中迭代设计、测试功能并完善实现。

Claude 在现实世界的软件工程基准测试中表现出色，在诸如错误修复、功能实现和代码重构等任务中，始终位于顶级模型之列。它的优势不仅在于生成代码，还在于理解软件项目的更广泛背景。Claude 可以分析现有的代码库，识别模式和反模式，提出架构改进，并保持与既定编码风格的一致性。这使得它在绿地项目和遗留系统维护中都非常有价值。

模型的记忆和上下文管理方法使其能够在长时间的编码会话中建立理解。当处理大型项目时，Claude 可以提取并保留有关代码库结构、设计决策和特定项目模式的要点信息。这种累积的知识使它能够随着开发进程的推进提供越来越相关和上下文化的建议，使其更像是一个随着时间的推移逐渐熟悉项目的团队成员，而不是一个无状态的助手。

## ChatGPT：多才多艺的编码伴侣

[ChatGPT](https://oreil.ly/hZdNC) 已成为 AI 编码助手的瑞士军刀，其价值不在于专门的功能，而在于其非凡的通用性和广泛的知识库。它在开发者工具箱中的位置独一无二。虽然其他模型可能直接集成到 IDE 中或提供专门的编码环境，但 ChatGPT 作为一个始终可用的编程顾问，开发者会在整个工作日中将其保持在浏览器中打开。

ChatGPT 的对话界面使其在探索性问题解决和学习方面特别有效。开发者经常用它进行橡皮鸭调试，将问题代码粘贴进来，并通过自然对话思考问题。其广泛的训练使其能够识别几乎所有常用编程语言、框架和工具中的模式。无论是调试正则表达式、理解晦涩的错误消息，还是探索不熟悉的库文档，ChatGPT 都能提供基于其全面知识库的相关见解。

ChatGPT 的优势在于其能够弥合人类意图与代码实现之间的差距。它在双向翻译方面表现出色——将自然语言描述转换为工作代码，并以简单的英语解释复杂代码。这使得它在文档编写、代码审查和团队内部知识转移中非常有价值。开发者可以将不熟悉的代码粘贴进来，并收到对其功能性的清晰解释，或者描述所需的行为，并收到适用于多种编程范式的适当实现。

模型的灵活性不仅限于传统的编程语言，还包括配置文件、脚本、数据格式和特定领域的语言。虽然专门的编码工具在其专注的领域内表现出色，但 ChatGPT 在整个软件开发任务范围内提供了宝贵的帮助。这种广度使其在处理不同技术之间的边界问题或遇到跨越多个领域的问题时特别有用。它能够在扩展对话中保持上下文的能力，使开发者能够迭代地探索复杂问题，通过协作对话完善解决方案。

# 为您的需求选择合适的模型

这些强大的 AI 编码助手的出现代表了软件开发实践的根本转变。成功的开发者不会将它们视为相互竞争的选项，而是认识到每个模型系列为开发过程的各个方面带来了独特的优势。Google 的 Gemini 在视觉上下文和多模态理解至关重要的情况下表现出色，尤其是在 UI/UX 开发和处理设计规范时。Anthropic 的 Claude 在需要深入推理、复杂重构和透明问题解决方法的场景中闪耀。OpenAI 的模型系列提供了无与伦比的灵活性和广泛的知识，使其成为学习、调试和跨领域挑战的理想选择。

许多开发团队现在采用组合方法，在同一个项目中利用不同的模型来完成不同的任务。一个典型的流程可能包括使用 Gemini 将设计原型转换为初始实现，Claude 进行复杂的架构决策和代码审查，以及 ChatGPT 进行一般问题解决和文档编写。这种多模型方法通过将每个工具的优势与特定的开发挑战相匹配，最大化了生产力。

随着这些模型不断进化，有效 AI 辅助开发的关键不在于选择一个单一的“最佳”选项，而在于理解如何协调多个 AI 助手来加速并增强软件开发生命周期的各个方面。

这个生态系统尚年轻且快速变化。每几个月就会涌现新的参与者和新能力。关键要点是，您不必从头开始构建自己的 AI 来利用有目的的编程——有很多工具将这种力量带到您的指尖。在这本书的整个过程中，我将讨论各种平台以及它们如何融入 vibe 编码的工作流程。

# Vibe 编码的益处和局限：一种细微的观点

认识到 AI 辅助开发真正发光发热的场景——以及它可能仍然表现不佳的地方，这一点很重要。让我们探讨一些理想的使用案例，其中 vibe 编码表现出色，以及今天的人工智能仍然挣扎或需要大量人工干预的情况。

## Vibe 编码的理想用例

正如某些架构适合某些问题一样，Vibe 编码在软件开发领域也有其“甜蜜点”。

### 从零到一的产品开发

Vibe 编码是启动全新项目的一个变革者。术语*从零到一*（由彼得·蒂尔普及）指的是从头开始创造新事物。借助 AI，你可以以闪电般的速度从一张白纸到功能原型。需要建立一个以前从未存在过的 Web 应用？你可以在一次狂热的提示会话中生成前端、后端、数据库模式甚至部署脚本的样板代码。这对于初创公司或黑客马拉松项目来说非常完美，这些项目的目标是快速验证一个想法。你不必花费数周时间设置项目的“脚手架”（所有重复的设置代码），AI 可以在几分钟内完成这些工作。

许多开发者都分享了他们如何借助 AI 配对程序员在周末构建了一个最小可行产品（MVP）的经历——这可能是他们独自工作一个月才能完成的事情。通过快速将想法转化为可工作的产品，你可以更早地开始与用户或利益相关者进行测试。AI 在处理通用任务方面非常出色（如设置路由、基本 UI 组件、标准 CRUD 操作），这让你可以专注于产品的创新方面。

然而，一旦你的 MVP 获得关注并转向生产，你的方法必须转变。这就是 AI 辅助工程变得至关重要的地方。虽然 Vibe 编码帮助你快速探索和验证，但扩展现在需要更谨慎的实践。你需要对快速生成的代码进行重构，添加适当的错误处理，增加全面的测试覆盖，并建立清晰的架构边界。从原型到产品的转变标志着从 Vibe 编码的探索自由到工程结构化纪律的自然演变。聪明的团队认识到这个转折点，并相应地调整他们的 AI 使用——在保持速度的同时引入可持续增长所需的护栏。

### 功能原型和 CRUD 应用

许多软件工程，尤其是在商业应用程序中，涉及围绕数据的 CRUD（创建、读取、更新、删除）功能。这是 AI 特别擅长的工作，因为它已经看到了无数示例。如果您需要向系统中添加一个新“库存”模块，带有 CRUD 屏幕和 API，动态编码将处理得非常好。它可以生成数据库迁移、ORM 模型、API 端点和带有验证的 UI 表单——基本上是全栈——因为这些模式在其训练数据中非常常见，所以几乎不会出错。即使您的应用程序有自定义规则，您也可以在提示中指定这些规则，并获得一个不错的初步结果。结果是，过去需要一周时间完成的枯燥的连接任务现在只需要一个下午的提示和测试。对于内部工具或管理面板（本质上是大型的 CRUD 应用程序），鉴于它们通常既简单又耗时，您几乎可以完全依赖 AI 来生成它们。

当这些 CRUD 操作涉及复杂业务逻辑、数据验证规则或与现有系统集成时，工程方法变得至关重要。虽然动态编码可以快速生成基本结构，但 AI 辅助工程确保您的库存模块正确处理边缘情况，如并发更新、维护引用完整性，并遵循您组织建立的模式。例如，您可能使用动态编码生成初始 CRUD 脚手架，然后切换到工程模式以实现特定领域的规则，如库存阈值警报、多仓库分配逻辑或与现有认证和授权系统的集成。关键是识别何时从快速生成过渡到精心细化。

### 粘合代码和集成

需要集成两个服务或 API 吗？这通常涉及阅读文档和编写代码，将数据从一种格式转换为另一种格式。AI 模型通常是在 API 文档和代码示例上训练的，这意味着它们可以加速集成工作。让 ChatGPT 展示如何从语言 B 调用服务 A 的 API——很可能它会生成带有正确端点和可能甚至有认证示例的示例代码。当 AI 能够建议样板代码和边缘情况处理时，结合多个系统（如将支付网关与您的订单系统连接或连接第三方分析 SDK）变得更容易。它在这些标准集成模式上表现出色。

### 现代框架利用

AI 编码助手已经有效地阅读了所有流行框架的说明书：React、Angular、Django、Rails、Node/Express、Flutter——你说的都对。这意味着如果你使用的是知名框架，AI 可以为这些框架生成惯用的代码。例如，它可以生成带有钩子和状态管理的新的 React 组件，或者带有适当的 admin 类和序列化器的新的 Django 模型。好处是，你不必记住每一个小细节——AI 填补了这些空白。**氛围编码**在处理现代 Web 开发任务时表现尤为出色，比如生成带有正确类的 HTML/JSX 或连接控制器端点，因为这些任务 AI 模型已经反复见过。这就像总有一个框架专家在你身边，在你决定功能应该做什么的具体细节时，帮你编写样板代码。

### 重复代码生成

有时候你需要创建大量的相似代码（比如在某个模式中为每种类型创建许多类似的端点或类）。对于人类来说，这可能既繁琐又容易出错。另一方面，AI 喜欢重复的结构——一旦你向它展示一两个示例，它就可以持续地生成剩余的部分。这种批量代码生成可以节省大量时间。例如，如果你正在为 50 种记录类型编写数据模型类，你可以提示一个示例，并要求 AI 根据该模式生成所有 50 种类型的类。它很可能会完美无缺且在几秒钟内完成。结果是：你避免了整整一天的单调编码。

### 当 AI 辅助工程应优先考虑时

虽然**氛围编码**在某些场景中表现出色，但在其他情况下，AI 辅助工程变得不可或缺。理解这些情况有助于开发者从一开始就选择正确的方法，避免昂贵的重写或技术债务。复杂的算法实现需要工程方法。当你构建复杂的数据结构、实现性能关键型算法或解决新颖的计算问题时，你需要对实现的每个方面都进行精确控制。

在这里，AI 充当一个知识渊博的助手而不是代码生成器。你可以要求它解释算法方法或审查你的实现以检查正确性，但你保持对架构和优化决策的直接控制。AI 帮助你思考问题而不是全面解决问题。

对于关键任务系统，从一开始就需要严格的工程方法。金融交易、医疗保健应用、安全基础设施和其他高风险领域无法承担**氛围编码**的探索性质。在这些环境中，每一行代码都需要仔细考虑、全面测试，并且通常需要符合监管要求。AI 通过建议最佳实践、识别潜在漏洞并帮助确保符合标准来提供协助，但开发者对实现保持紧密控制。

这些系统中的失败成本远超过快速生成的任何速度优势。遗留系统集成提出了独特的挑战，其中工程学科至关重要。当与几十年前的代码库、专有协议或技术债务庞大的系统一起工作时，感觉编码的模式匹配往往失败。这些场景需要深入理解现有约束，仔细规划集成点，以及有系统的重构。人工智能可以通过解释遗留代码模式或提出现代化策略来帮助，但实际实施需要只有结构化工程才能提供的精确度。

性能优化是另一个领域，在这里工程学胜过感觉。虽然人工智能可以快速生成功能性代码，但它很少为性能关键路径产生最优解。像内存管理、缓存优化、并行处理和延迟降低这样的任务需要深入理解硬件、操作系统和算法复杂性。在这里，人工智能作为研究助理最为出色，帮助你探索优化技术或基准测试不同的方法，而你则做出关于实施的明智决策。

在这些场景中，人工智能的模式识别和速度与任务完美匹配。本质上，感觉编码在编程的熟路领域（如 CRUD 或典型的 Web 应用结构）以及从快速试错中受益的任务（原型、新想法）中蓬勃发展。这就像有一个阅读过每个 GitHub 仓库的初级开发者，可以立即回忆起通常是如何做的，并为你编写以供审查。这对于快速推进事物来说非常强大。

### 认识到转换点

现代人工智能增强开发的技艺不在于选择一种方法而放弃另一种，而在于认识到*何时在它们之间进行转换*。成功的开发者对这些转折点有着直觉。开始一个新功能？从感觉编码开始，快速探索可能性。注意到代码变得复杂或触及关键系统？切换到工程模式。为客户演示构建原型？感觉编码能让你快速到达那里。将原型转换为生产系统？是时候采取工程纪律了。

这种流动性——在快速探索和精心构建之间无缝切换的能力——区分了真正有效的 AI 增强开发者。他们明白，感觉编码和人工智能辅助工程是他们工具箱中的互补工具，各自适合开发生命周期的不同阶段。目标不是选择一方，而是战略性地利用两种方法，在整个软件开发过程中最大化速度和质量。

## AI 仍面临的挑战

尽管当前的 AI 编码工具非常令人印象深刻，但它们并不是魔法。有一些问题类别对于 AI 来说仍然难以可靠地处理，通常需要人类的洞察力或传统的编码技术。了解这些限制有助于设定正确的期望，并让你知道何时依赖 AI，何时重新掌握控制权。

限制包括以下内容：

深度复杂的系统

如果你处理的是非常复杂或 AI 可能未见过的创新问题，它可能会遇到困难。例如，从研究论文中编写全新的算法，或者做一些像编写编译器或高度并发系统的事情——这些涉及复杂的逻辑，需要真正的理解和经常性的创新飞跃。AI 可以尝试，但可能会在细节上出现错误。

在这些复杂的领域，AI 倾向于生成大致正确但并非完全正确的代码，这可能导致很多来回。正如第三章和第四章将要讨论的，正确性的最后 30%左右对于 AI 来说非常难以确定。这与我所说的*70%问题*有关——AI 可以快速带你走大部分路，但最后的部分很困难。经验丰富的开发者可能会使用 AI 生成这类复杂任务的框架或辅助函数，但核心逻辑则由自己完成。

低级优化和系统编程

当前的 AI 模型主要是基于高级语言和抽象进行训练的。如果你需要进行低级位操作，为特定的微控制器编写高度优化的 C 代码，或者生成矢量化 SIMD 指令，AI 可能不可靠。它可能会生成看似合理的代码，但在硬件层面上并不真正优化，甚至可能不正确。

类似地，对于像内存管理或实时约束这样的东西，AI 并没有真正的概念（它不会在脑海中模拟 CPU 缓存）。因此，对于性能关键代码，你可能需要彻底测试 AI 的建议，或者手动编写这些部分。尽管如此，AI 仍然可以通过提供起始模板或解释汇编来提供帮助，但在这些情况下你不能盲目地信任它。

独特或利基框架

如果你使用的是 AI 训练期间不存在的非常新或晦涩的框架，它将不会了解它。在这种情况下，AI 可能会尝试泛化，或者生成看起来似乎符合要求的代码，但实际上调用不存在的函数（幻觉）或使用 API 的过时版本。例如，如果上个月推出了一个新的 Web 框架版本，并带来了破坏性的变化，AI 将不会了解这些变化。它可能会给你提供旧版本的代码。在这些情况下，你必须求助于文档，也许甚至可以通过在你的提示中提供文档中的上下文来帮助训练 AI（基本上是在飞行中教学）。

创意 UI/UX 设计

如果你要求人工智能设计一个完全新颖的用户界面或体验，它在这方面并不擅长进行创造性飞跃。它可以生成已知模式的 UI 代码（如标准表单或仪表板），但如果你想要一个没有明确先例的创新 UI，人工智能可能不会给你带来有启发性的东西。它可能只是将熟悉的部分拼接在一起。人类设计师和前端开发者仍然非常需要来构想新的用户体验。在编码术语中，人工智能可以快速让你拥有一个标准外观的界面，但为了那种特殊的定制感觉，你需要引导它或手动调整。

解释意图和需求

有时当需求是隐含的或矛盾的时，人工智能会感到困难。它对你明确告诉它的目标之外没有真正的理解。如果需求是模糊的（“让它更高效”——这究竟意味着什么？），人工智能可能会错误地猜测你关心的事情（例如，内存与速度）。人类在阐明意图方面更擅长，尤其是在非技术利益相关者中。人工智能也可能误解指令，特别是如果它不了解特定领域的上下文（如商业规则）。它可能产生一个逻辑上正确的解决方案，但实际上并没有解决真正的问题，因为细微差别在翻译中丢失了。

一个结合这些情况的良好示例场景：想象一下在 Rust（系统级，性能关键）中开发一个新的 3D 图形引擎（复杂系统）。你有一些独特的渲染算法（独特的问题）。人工智能可能有助于编写一些样板代码，但你主要会依赖人类的独创性来完成核心部分。人工智能可能会帮助你设置窗口和基本的渲染循环（常见任务），但对于定制部分，你会继续使用传统的谨慎编码，并可能从人工智能那里获得一些伪代码形式的算法帮助。如果你要求它用汇编语言优化一个热点循环，你必须验证每条指令。

人工智能也缺乏真正的解决问题的洞察力。最终，它只是模式匹配。所以如果你的问题需要一种 *aha!* 的洞察力，人工智能可能只是四处乱撞，展示出看似代码但实际上无法解决问题的东西。这就是人类退后一步，抽象思考或借鉴实际经验可以拯救局面的地方。一旦你有了洞察力，你就可以利用人工智能快速实现它。

了解这些优势和劣势确保你会在正确的情况下部署 vibe-coding 技巧。为了最大化成功，利用人工智能擅长的地方（已知模式），并将你的创造力应用于应用程序的独特部分。准备好在人工智能已知会挣扎的领域进行干预。例如，仔细审查它编写的任何安全敏感的代码，因为它可能遗漏了一些边缘情况。

利用 AI 来补充人类的优势：让它处理广度（大量代码、样板），而你则处理深度（复杂逻辑、架构）。在它擅长的领域使用它作为助推器，并且不要害怕在那些更艰难的道路上接管方向盘。这发挥了双方的优势，并产生最佳结果。知道何时使用 AI 以及何时依赖人类技能，将使你在这个新时代成为一个高效的开发者。

每一项新技术都伴随着其优势和局限性。随着我们拥抱 AI 辅助开发带来的生产力和创造力提升，了解其局限性和权衡因素至关重要。主要好处包括：

更快的开发周期

项目可以从概念快速过渡到原型，再到成品。AI 可以瞬间生成脚手架代码（例如为新项目设置样板），这样你就有更多时间专注于应用程序的独特部分。

增强原型设计和实验

由于尝试某件事的成本较低（只需向 AI 描述你想要的内容并快速获得草稿），开发者可能会感到更自由地进行实验。你可以通过以不同的方式提示 AI 来原型化解决问题的多种方法，然后选择最好的一个。这种迭代式构思可以导致更具创造性的解决方案。

知识触手可及

大型语言模型（LLMs）是在庞大的编程知识库上训练的。它通常“知道”一些不为人知的 API 或错误信息解决方案。在实践中，它可以提出你未曾想到的解决方案或想法，使你成为一个更有效的解决问题者。

一致性和标准化

在团队环境中，AI 助手可以通过以一致的风格生成代码来帮助执行编码标准和最佳实践。如果配置了项目的风格指南，它可以确保每个人的代码都遵循类似的模式。即使没有明确的训练，AI 模型通常也会产生符合习惯用法的代码（因为它们从数百万个示例中学习）。这可以减少代码审查的努力，因为其功能可能看起来很熟悉，并且默认遵循常见约定。

需要考虑的一些限制和权衡因素包括：

可变输出质量

这些模型并非完美无缺。它们可能生成看起来正确但实际上存在细微错误或不效率的代码。它们可能会选择过时的方法，因为它们的训练数据包含大量旧代码。作为开发者，你必须保持警惕。正如你不会在没有理解的情况下从互联网上复制粘贴代码一样，你不应该无思考地接受 AI 生成的代码。本书第二部分将讨论验证和彻底测试 AI 生成代码的技术。

提示中的歧义会导致代码中的歧义

如果你的提示不够具体，AI 必须猜测你的意图——它可能会猜错。例如，如果你告诉它“对一组名字进行排序”，它可能会默认按字母顺序排序，但也许你指的是其他排序方式（比如按名字长度排序）。除非你澄清，否则 AI 不会知道区别。这就是为什么提示的具体性（第二章的主题）至关重要——你将学会预测需要明确说明哪些细节。

过度依赖和技能退化

如果新开发者总是依赖 AI 来编写他们的代码，他们是否会发展出对算法和调试的同样深入理解？存在技能退化的风险，这类似于过度依赖 GPS 导航可能会削弱你自己的方向感。为了减轻这种风险，重要的是将 AI 作为学习工具使用（注意它提供的代码并询问原因），有时在没有它的帮助下进行编码练习，以确保你保留基本技能。

隐私和安全问题

使用基于云的 AI 编码工具通常意味着将你的代码（可能是专有或敏感的）发送到第三方服务进行分析。公司需要考虑这一点。许多工具通过允许本地模型或提供不存储代码的保证来解决这个问题，但这仍然是一个需要考虑的因素。此外，存在 AI 无意中生成与训练数据中某些内容非常相似的代码的风险，这些内容可能处于开源许可之下（如 GPL）。虽然这种情况不太可能发生（并且有措施防止直接输出），但它突出了在集成之前审查和理解 AI 生成内容的需求。第八章深入探讨了安全和可靠性问题。

AI 输出中的偏见

AI 模型可以反映出其训练数据中存在的偏见。在编码环境中，这可能是从偏好某些变量名到使用假设特定用户属性的示例，程度不同。例如，它可能对每个示例变量使用`foo/bar`（因为许多示例都是这样），或者它可能对用户地区有所假设。与其他 AI 应用相比，在代码生成中这通常不是一个大问题，但了解这种可能性是值得的。更微妙的是，AI 可能倾向于它看到更频繁的解决方案，即使这些解决方案可能不是你案例中最好的。 第九章讨论了偏见和其他伦理考量。

人类因素和信任

并非所有开发者一开始都适应这种工作风格。编码有其特定的乐趣和艺术性，有些人可能会觉得这种乐趣因为 AI 的介入而减少了。也可能存在最初的信任缺失——“它真的这样做对了吗？”——这只有良好的实践和时间才能克服。采用 AI 的团队应该允许一段时间的调整，并鼓励分享经验和技巧。随着时间的推移，就像任何工具一样，大多数人会发现一个平衡点，在那里 AI 的贡献受到重视，而人类的专长则集中在人类最擅长的事情上。

# 摘要和下一步

趋向于有意图的编程的感觉转变为软件开发提供了巨大的潜力，使其更快、更易于访问，并在许多方面更加有趣。但实现这一潜力意味着理解新的动态：如何有效地与 AI 沟通，如何验证其输出，以及如何负责任地将它整合到你的开发过程中。

我的观点，是通过使用这些工具并观察许多项目形成的，那就是 AI 的最佳用途在于将创造性的“感觉”与坚实的工程卫生相结合。鼓励 AI 提供的狂野想法和快速草稿——这些是我们可利用的新超级力量。但要用软件开发几十年来积累的智慧来引导它们：规划、测试和了解你所构建的内容的重要性。

当我们达到这种平衡时，我们就能得到两者的最佳结合。我们得到的是构建更快、可能更具想象力的软件，同时也是我们信任、维护和有信心增长的软件。最终，这就是我们在 AI 时代提升我们技艺的方式：不是通过选择感觉胜过工程，或者相反，而是通过掌握两者之间的整个光谱。

接下来，第二章探讨了制作提示和与 AI 协作的艺术。带着本章的基础概念，你准备好探索这个新编程时代的实际应用。这将为后续章节中的实际示例和更深入的提示技术奠定基础。
