# 12 未来方向

### 本章涵盖

+   使用提示模式编写和解释代码

+   生成式 AI 工具的当前局限性和未来方向

在这一章的最后，我们希望让你一窥人们目前正在使用生成式 AI 工具（如 GitHub Copilot 和 ChatGPT）的创造性方式。例如，可以使得 Copilot Chat 向你提问，而不是反过来。还可以让 Copilot 扮演不同的角色，以更好地帮助你完成当前的编程任务。我们将简要介绍，目前还不清楚这将成为多少标准做法，但我们想借此机会展示这些新工具的创造力。我们还将讨论一些生成式 AI 工具的当前局限性（你已经在本书中看到了一些！），并分享我们对未来可能性的看法。

## 12.1 提示模式

在整本书中，我们阐述了为什么直接在 Python 中编程与使用 Copilot 编程相比有着非常不同的体验。我们关注的焦点不是编写代码，而是编写提示并与生成的代码交互，以确定其是否正确，并在需要时进行修复。但伴随着这些差异，没有 Copilot 的编码与有 Copilot 的编码之间也存在令人惊讶的相似之处。

当程序员编写代码时，他们不会每次编写新程序时都从头开始。研究人员和程序员已经创建了设计**模式**的目录，即组织程序以使其更容易编写、调试和扩展的通用方法。最著名的此类目录是一本名为《设计模式：可重用面向对象软件元素》的书[1]，也被称为“四人帮”书，因为它是由四位作者共同撰写的。它需要熟悉面向对象编程，而我们在这本书中没有教授，所以我们不建议你马上拿起那本书。只需知道，成千上万的程序员已经通过使用这本书中的模式节省了数千小时，而没有重新发明轮子。

以设计模式的一个例子来说明，假设你正在编写一个电脑游戏，其中人类玩家与电脑对战。你希望实现几个不同难度（例如，初学者、中级、高级和专家）的 AI 对手，为人类提供不同技能水平的对手。每个 AI 对手都将有自己的代码来决定其行为。使用`if`条件确定 AI 对手应该做什么是可能的：

```py
if ai_opponent == 'beginner':
    # make decision consistent with beginner AI opponent
elif ai_opponent == 'intermediate':
    # make decision consistent with intermediate AI opponent
…
```

但那样做的缺点是组织上的。我们会把所有 AI 代码放在同一个地方。我们从这本书中学到的知识告诉我们，像那样的大型函数不容易设计和测试。

组织这类程序的干净方式是使用一种称为*策略模式*的模式。我们不会在这里详细介绍该模式，但重要的是，人们已经为他人使用记录了这种模式[1]。模式文档会告诉你其意图（目的）、我们为什么要使用它的动机、实现它所需的代码结构以及示例代码。

研究人员开始整理可用于 GitHub Copilot 和 ChatGPT 等生成 AI 工具的模式。它们被称为*提示模式*，类似于设计模式，它们告诉你如何构建一个提示以实现一个期望的目标。每个这些模式的文档与设计模式的文档类似，但与示例代码不同，我们得到的是我们可以使用的示例提示。

在这本书中，我们大部分时间都在关注两种类型的 AI 响应：生成代码（通过在 VS Code 中按 Tab 键）和解释代码（通过使用 Copilot Chat）。新兴的提示模式可以帮助生成 AI 工具超越这些，帮助处理其他与代码相关的任务。

为了让你了解提示模式的前沿状态，我们将在这里采样几个。对于更多，我们鼓励你查看我们使用的提示模式目录[2]。但请注意：我们正在引用一篇学术论文，而不是入门指南，因为我们目前不知道有任何入门指南（这还是新事物）。

##### Copilot Chat 可能不会参与这些提示模式

在撰写本文时，Copilot Chat 拒绝参与一些已记录的提示模式，声称它们与编程辅助无关。虽然其中一些可能不太具体地与编程相关，但它们都是为了帮助程序员设计的。与 ChatGPT 不同，Copilot 被设计成始终试图专注于编程主题。如果你决定进一步探索各种模式，你可能希望在无法与 Copilot 有效互动时使用 ChatGPT。

### 12.1.1 交互模式反转

到目前为止，我们一直是请求代码和提问的人，而 Copilot 一直是回答的人。但我们可以反转脚本，让 Copilot 提问，我们回答。这被称为*交互模式反转*。

此模式的目的是在我们不知道 AI 需要什么信息来完成任务时，帮助我们与之互动。动机是，AI 可能知道如何更快地通过询问我们达到其目标，而不是如果我们提供不完整或不帮助的信息。我们的提示结构将看起来像这样：

我希望你问我问题以达到 X。你应该继续提问，直到我们达到这个目标，其中 X 是我们想要达到的目标。

这种结构并不是为了精确地规定我们应该使用的提示。相反，它提示我们需要在提示中传达的关键思想。例如，这里的关键思想是我们希望 Copilot 提问，并且我们希望它在我们达到目标之前不要停止。

在第三章中，我们编写了一个函数，不断询问用户输入密码，直到他们输入了一个强大的密码。假设我们不确定如何设计这个函数。我们可以通过提供代码提示让 Copilot 为我们设计它，但这样它可能会做出我们不认同的决定。相反，我们可以让 Copilot 提问。让我们使用 Copilot Chat 来做这件事。

LPHuman 我想要一个 Python 函数，它会不断询问用户输入密码，直到他们提供了一个强大的密码。在你能写出那个 Python 函数之前，一次问我一个问题。

![chatGpt](img/chatGpt.png)GitHub Copilot 当然，我很乐意帮助你编写一个不断询问用户输入强大密码的 Python 函数！以下是一些开始的问题：

1.  你认为什么是一把强大的密码？

1.  函数应该有任何输入参数吗？

1.  函数应该返回什么？

1.  函数应该有任何副作用，比如打印消息到控制台吗？

1.  函数应该有任何错误处理，比如处理用户无效的输入吗？

Copilot 未能遵循我们“一次问一个问题”的指示。让我们提醒它。

LPHuman 一次问我一个问题。

![chatGpt](img/chatGpt.png)GitHub Copilot 当然，让我们从第一个问题开始：

1.  你认为什么是一把强大的密码？

现在，我们可以开始回答这些问题。Copilot 将使用这些答案为我们编写代码。

LPHuman 密码必须至少包含一个大小写字母，至少一个数字和一个标点符号。

![chatGpt](img/chatGpt.png)GitHub Copilot 很好，感谢你告诉我！接下来是下一个问题：

1.  2. 函数应该有任何输入参数吗？

LPHuman 我不知道。它们会被用来做什么？

![chatGpt](img/chatGpt.png)GitHub Copilot 输入参数用于将数据传递给函数，以便函数可以对数据进行某些操作。例如，如果我们想编写一个将两个数字相加的函数，我们需要将这两个数字作为输入参数传递给函数。

在我们的密码函数的情况下，我们可能想要传递一些参数来定义强大密码的要求。例如，我们可能想要传递密码的最小长度、所需的大小写字母数量、所需的数字数量和所需的标点符号数量。

或者，我们可以将这些要求硬编码到函数本身中，但使用输入参数会使函数更加灵活和可重用。

LPHuman 请将它们硬编码。

![chatGpt](img/chatGpt.png)GitHub Copilot 当然，我们可以将密码要求硬编码到函数本身中。这是下一个问题：

1.  3. 函数应该返回什么？

LPHuman 该函数应返回用户的强密码。

![chatGpt](img/chatGpt.png)GitHub Copilot 很好，感谢你告诉我！这是下一个问题：

1.  4. 函数是否应该有任何副作用，例如向控制台打印消息？

我们在这里停止，因为我们认为阅读完整的交互并不有趣。我们继续与 Copilot 交谈并回答了问题 4 和 5，Copilot 拥有了编写我们想要的代码所需的信息。在回答了所有五个问题后，我们最终收到的代码如下所示。

##### 列表 12.1 通过翻转交互模式设计的函数

```py
import string

def get_strong_password():
    '''
    Keep asking the user to enter a password until they provide 
    a strong password.
    A strong password has at least one uppercase character, one 
    number, and one punctuation character.
    '''
    # Print the password requirements
    print("Your password must contain at least:")
    print("- One uppercase letter")
    print("- One number")
    print("- One punctuation character")

    # Keep asking for a password until a strong one is provided
    while True:                                          #1
        password = input("Enter a password: ")

        # Check if the password meets the requirements
        if not any(c.isupper() for c in password):        #2
            print("Password does not contain an uppercase letter.")
        elif not any(c.isdigit() for c in password):        #3
            print("Password does not contain a number.")
        elif not any(c in string.punctuation      #4
                     for c in password):          #4
            print("Password does not contain a punctuation character.") #4
        else: #4
            print("Password is strong!") #4
            return password                     #5
```

#1 没有办法使这个 True 条件变为 False！

#2 如果密码中没有大写字母

#3 如果密码中没有数字字符

#4 如果密码中没有标点符号

#5 这就是我们退出“while True”循环的方法。

到目前为止，在我们的 `while` 循环中，我们始终使用一个我们希望最终变为 `False` 的循环条件（否则，我们会遇到无限循环）。例如，我们可以想象有一个循环，实际上说的是，“当密码无效时继续循环。”但在这里，代码使用的是 `while True`，而 `True` 是一个永远不会变为 `False` 的条件。必须有一种其他方式退出循环——确实有！当密码有效时，我们通过 `return` 语句退出循环。也就是说，这里的逻辑是“永远循环；如果密码有效，停止循环。”`while True` 形式的 `while` 循环是本书中看到的一种常见替代结构。

这段代码很好地实现了我们的任务。它开始时通过一些 `print` 调用来告诉用户强密码的规则。如果用户的密码实际上不强，它还会告诉用户密码有什么问题。它持续循环，直到用户输入一个强密码。当我们最终从用户那里得到一个强密码时，我们返回它。

现在，我们已经知道了如何编写这个函数，因为我们已经在第三章的工作中做到了这一点。而且，到这一点，你的 Python 知识已经足够强大，你可以直接跳到编写函数签名，让 Copilot 编写代码，就像我们在整本书中做的那样。但对于你不太熟悉且可能不知道从何开始的任务，这种翻转交互模式可能会有所帮助。

### 12.1.2 个性模式

这种模式的目的是让 AI 扮演一个特定的角色或观点。我们为什么会想要这样做呢？好吧，这里有一个例子：假设你是一名入门级 Python 编程课程的学生。你的讲师正在课程中使用 Copilot，但他们禁止了一些他们认为会妨碍入门级 Python 学习的 Python 特性。你可以要求 Copilot 扮演那个讲师的角色，然后帮助你检查代码，以找到并（如果需要）移除任何不允许的 Python 特性。我们的提示结构将如下所示：

从现在起，扮演角色 X。提供角色 X 会创建的输出。

我们将用特定的角色来填充 X。让我们尝试使用我们的入门级编程讲师角色。我们将要求 Copilot 扮演这个角色，禁止一系列更高级的 Python 概念。（如果你从未听说过这些，请不要担心！）

LPHuman 从现在起，扮演一个入门级 Python 编程讲师的角色。在你教授的课程中，以下 Python 特性是不允许的：列表推导式、生成器、“lambda”以及“any”函数。我会提供代码，你需要检查代码中是否有不允许的 Python 特性，并提出如何重写代码以避免使用这些特性。

![chatGpt](img/chatGpt.png)GitHub Copilot 当然，我可以做到！请提供你希望我审查的代码。

让我们给它提供上一节中的 `get_strong_password` 函数。它使用了 `any` 函数，根据我们的角色规则，这个函数是不允许的。以下是我们的原始代码以及 Copilot 的响应。

**LPHuman**

```py
*`*def get_strong_password():*`*
 *`*'''*`*
 *`*Keep asking the user to enter a password until they provide*`* 
 *`*a strong password.*`*
 *`*A strong password has at least one uppercase character, one*`* 
 *`*number, and one punctuation character.*`*
 *`*'''*`*
 *`*# Print the password requirements*`*
 *`*print("Your password must contain at least:")*`*
 *`*print("- One uppercase letter")*`*
 *`*print("- One number")*`*
 *`*print("- One punctuation character")*`*

 *`*# Keep asking for a password until a strong one is provided*`*
 *`*while True:*`*
 *`*password = input("Enter a password: ")*`*

 *`*# Check if the password meets the requirements*`*
 *`*if not any(c.isupper() for c in password):*`*
 *`*print("Password does not contain an uppercase letter.")*`*
 *`*elif not any(c.isdigit() for c in password):*`*
 *`*print("Password does not contain a number.")*`*
 *`*elif not any(c in string.punctuation for c in password):*`*
 *`*print("Password does not contain a punctuation character.")*`*
 *`*else:*`*
 *`*print("Password is strong!")*`*
 *`*return password*`*
```

![chatGpt](img/chatGpt.png)GitHub Copilot `get_strong_password` 函数使用了 `any` 函数，这在你的课程中是不允许的。下面是修改后的函数版本，它没有使用 `any` 函数：

```py
*`*import string*`*

*`*def get_strong_password():*`*
 *`*'''*`*
 *`*Keep asking the user to enter a password until they provide*`*
 *`*a strong password.*`*
 *`*A strong password has at least one uppercase character, one*`* 
 *`*number, and one punctuation character.*`*
 *`*'''*`*
 *`*# Print the password requirements*`*
 *`*print("Your password must contain at least:")*`*
 *`*print("- One uppercase letter")*`*
 *`*print("- One number")*`*
 *`*print("- One punctuation character")*`*

 *`*# Keep asking for a password until a strong one is provided*`*
 *`*while True:*`*
 *`*password = input("Enter a password: ")*`*

 *`*# Check if the password meets the requirements*`*
 *`*has_uppercase = False*`*
 *`*has_number = False*`*
 *`*has_punctuation = False*`*
 *for c in password:* #1
 *`*if c.isupper():*`*
 *`*has_uppercase = True*`*
 *`*elif c.isdigit():*`*
 *`*has_number = True*`*
 *`*elif c in string.punctuation:*`*
 *`*has_punctuation = True*`*
 *`*if not has_uppercase:*`*
 *`*print("Password does not contain an uppercase letter.")*`*
 *`*elif not has_number:*`*
 *`*print("Password does not contain a number.")*`*
 *`*elif not has_punctuation:*`*
 *`*print("Password does not contain a punctuation character.")*`*
 *`*else:*`*
 *`*print("Password is strong!")*`*
 *`*return password*`*
```

#1 替换“any”的循环

这个版本的函数使用 `for` 循环遍历密码中的每个字符并检查它是否符合要求。这种方法比使用 `any` 函数更冗长，但它没有使用不允许的 Python 特性。

如 Copilot Chat 所示，这个程序没有使用 `any` 函数。Copilot 已经重写了程序以避免使用该函数，从而遵循了我们 Python 编程角色的规则。

`any` 函数在其参数中有一个或多个值为真时返回 `True`，如果所有值都为假，则返回 `False`。在幕后，`any` 必须查看每个值以检查它是否为真或假。听起来像是一个循环，对吧？确实，Copilot 就是用一个循环来替换这里的 `any` 函数调用的。

## 12.2 局限性和未来方向

在我们与 Copilot（以及学生）合作并阅读我们撰写本书期间发表的研究文献的过程中，我们观察到了一些生成式 AI 模型的局限性和未来可能性，我们希望与大家分享。

### 12.2.1 Copilot（目前）的挑战

我们发现 Copilot 在三种不同类型的场景中存在挑战：虚构问题、不明确问题和大型任务。

#### 虚构问题

在 ChatGPT 和 GitHub Copilot 风靡全球之后不久，编程教师们急忙寻找这些工具无法很好地完成的任务类型。一个早期的建议是使用虚构任务：通过使任务变得晦涩和复杂来试图误导像 Copilot 这样的工具生成错误的代码。对我们来说，这类任务似乎完全无趣，而且对学生来说也不公平，它们的用途似乎是一种最后的努力，试图在不承认 Copilot 等工具造成的破坏的情况下保留之前的编程课程风格。我们的感觉是，随着模型的持续改进，这些虚构任务最终会被 Copilot 解决，但即使它们没有被解决，这类问题通常也不是必须解决的。

#### 不明确的问题

一个不明确的问题是指那些没有精确指定的问题，这意味着我们并不确切知道或在所有情况下都没有决定我们应该做什么。例如，向 Copilot 请求一个函数来决定密码是否强大，直到我们定义了“强密码”的含义，这个问题才是不明确的。你可能会想，Copilot 不可能在这些类型的问题上变得更好。毕竟，如果我们难以精确指定我们想要的行为，我们如何将所需的行为传达给 Copilot 呢？不明确的问题对 Copilot 来说确实具有挑战性，但它们并不是不可能解决的。记得我们在本章前面讨论过的翻转交互提示模式吗？也许，不久的将来，Copilot 会自动切换到那种模式，当你没有足够精确的信息来解决问题时。

#### 大型任务

我们在整本书中花了大量时间教你如何设计小型函数，以及如何使用自顶向下的设计来组织这些函数以解决大型问题。我们这样做是因为当给 Copilot 一个单一的任务来解决时，Copilot 会感到困难。这是像 Copilot 这样的工具的固有局限性，还是 AI 可以克服它？我们不知道。目前，Copilot 在问题分解方面存在困难，即使它能够正确地做到这一点，概率也不利于它。具体来说，它编写代码越多，出错的可能性就越高。例如，如果它需要编写 20 个函数来解决一个任务，每个函数平均有 10 行代码，它几乎肯定会在某个地方犯错误。但反对这些系统也是不明智的。随着 Copilot 学习方式的进步，也许这一切并没有想象中那么遥远。

### 12.2.2 Copilot 是一种新的编程语言吗？

当我们用 Python 这样的语言编写计算机代码时，背后有一个编译器将 Python 转换为计算机可以理解的汇编代码或机器代码。曾经有一段时间，程序员用 Fortran 或 C 这样的老式计算机语言编写代码，运行编译器生成汇编语言的代码，然后检查汇编代码以确保它是正确的。我们当时不在场，这可能没有发生很多，但我们能理解为什么当时的程序员不相信编译器。编译器是一种新技术，需要时间来修复错误。此外，编译器输出的代码可能比手写的汇编代码效率低。但是，经过几十年的改进，无论是在正确性还是效率上（编译器优化对任何好奇的人来说都是一个真正令人兴奋和有趣的话题！），很少有程序员会查看编译器的输出。有没有可能有一天，人类仅仅使用大型语言模型（LLMs）作为与计算机的主要接口，并且花很少的时间检查他们产生的代码？让我们思考这个问题的两种可能的答案。

#### 为什么大型语言模型（LLMs）可能不会取代编程语言

有理由相信 LLMs 不会成为人类编程计算机的主要接口。最主要的原因是 LLMs 不是一个严格的编程语言。我们信任编译器，因为每种编程语言都有一个规范，并且每行代码都有预期的确切行为。LLMs 没有这个。这只是有人用英语或其他自然语言向 LLM 写作。LLM 并不一定要以特定方式解释自然语言。它不需要根据任何严格的规范输出答案。而且，随机性和非确定性使得它给出的答案可能会变化或错误！编译器是确定性的，到目前为止，编译器是一种成熟、可信的技术。它们不面临这些问题。

#### 为什么大型语言模型（LLMs）可能会取代编程语言

也有理由相信，就像编译器一样，LLMs 会变得更好，并成为我们的主要编程接口。事实上，对于数据科学来说，这已经开始发生了。

正如我们在整本书中学到的，与 Copilot 一起工作的一个关键挑战是确定生成的代码是否正确。从某种意义上说，这对非程序员来说并不公平：我们给 Copilot 自然语言（我们的偏好），而它给我们回的是非自然语言的代码（计算机的偏好）。如果能“跳过代码”，不仅用自然语言与 Copilot 沟通，还能得到我们的答案，那就太好了。

研究人员开始探索在数百万计算机用户感兴趣的受限领域内这一可能性。以数据科学为例，数据科学家通过探索数据、可视化数据和使用数据来做出预测来理解数据。他们所做的大部分工作都涉及以约束和易于理解的方式操作数据，例如合并电子表格、清理特定列的数据或进行诸如将数据聚类到有意义的类别或简化数据以仅关注其核心基础结构的分析。使用 Python 的数据科学家使用许多库来处理他们的数据，但一个极其流行的库叫做 pandas。

研究人员已经在这个使用 pandas 进行数据科学的环境中“跳过了代码”[3]。以下是它是如何工作的：

1.  用户以自然语言（如英语）表达他们的意图。

1.  人工智能生成 Python 代码并运行以获取结果（例如，分析结果表格或新的电子表格）供用户使用。重要的是，用户看不到这段 Python 代码。

1.  人工智能将代码转换回自然语言，并将转换后的内容（而不是 Python 代码！）呈现给用户。用户收到的自然语言格式一致，可以被人工智能可靠地解释。研究人员这样描述人工智能响应的目的：“这就是你应该向系统提出你刚刚要求系统做的事情。”这个响应有助于用户了解人工智能的能力和有效的查询类型。

1.  如果第 3 步的自然语言不正确，用户可以编辑。如果用户进行了编辑，他们可以提交新的提示，这会重复循环。

研究人员提供的一个例子阐明了这个过程[3]。假设我们有一个电子表格，每行代表一名宇航员。每行有三个相关列：宇航员的名字、他们在太空中的总时间以及他们参与的以逗号分隔的任务列表。我们希望计算每位宇航员的平均任务长度。

在第 1 步中，用户编写一个提示，如“计算平均任务长度”。在第 2 步中，人工智能生成与该提示相对应的代码。它运行代码，并在用户的电子表格中添加一个包含平均任务长度的新的列。在第 3 步中，人工智能将代码转换为自然语言任务列表，如下所示：

1.  创建“任务长度”列。

1.  “太空飞行时间（小时）”列除以（从“任务”列中“，”的数量加 1）。

在第 4 步中，用户可以编辑第 3 步的自然语言，并将更新后的任务重新提交给 AI。我们是否能够在“Python 编程”这个更广泛的领域“跳过代码”，而不是在“使用 pandas 的数据科学”这个更受限的环境中呢？现在还言之过早。数据处理的好处在于可以在视觉媒介中工作，使用电子表格和图表可以直接展示给用户，用户可能能够判断分析是否正确，或者是否需要进一步的提示工程。这样的视觉表示对于通用编程来说并不明显。

尽管如此，我们可以想象一个新时代，在这个时代，人类继续执行重要的任务，如问题分解、指定程序行为、编写测试、设计算法等，但函数编程完全由 LLM（大型语言模型）完成。人类告诉 AI 工具程序需要做什么，并提供测试用例，然后 AI 生成代码。人类可以检查程序是否正常工作，而无需查看代码。

对于 LLM 是否会取代编程语言的另一种看法，我们推荐阅读 Chris Lattner（编程和编译器专家）撰写的博客文章[4]。Lattner 认为，至少在短期内，甚至可能是更长的时间内，编程语言不会消失，因为 LLM 生成的代码可能会存在细微的错误。因此，如果编程语言还会存在一段时间，那么问题是：我们应该使用哪种编程语言？Lattner 说：“最适合 LLM 的语言是那种对人类来说高度可用且易于阅读，但其实现可以扩展到许多不同的用例和应用程序的语言” [4]。现有的语言是否满足这个目标？我们能否通过设计一种比 Python 更容易阅读的编程语言来做得更好？请继续关注！

好吧，也许编程语言会消失，也许不会；也许它们会改变。无论如何，我们是否需要担心程序员的工作？我们认为不需要。任何在软件公司工作过的人都会告诉你，编写代码并不是程序员用他们时间做的唯一或甚至主要的事情。程序员还会与客户会面，确定他们的需求。他们指定程序的功能以及它们如何组合。他们会检查系统的性能和安全问题。他们与其他团队合作，协调大型软件的设计。如果编写代码的步骤变得更容易，也许我们只是得到了更多有用的软件。这就是当我们得到高级语言时发生的事情。没有人会使用汇编语言编写下一个杀手级应用！编译器改善了我们的软件制作方式。如果我们明智地使用 LLM，我们认为 LLM 也能做到这一点。

#### 一个令人兴奋的未来

虽然我们对未来部分不确定，但很清楚，LLMs 将极大地改变编程的未来。也许，现在它们只是帮助软件工程师编写更好代码的辅助工具。也许五年后，然而，大多数软件将由 LLMs 编写，只有一小部分软件工程师会从头开始编写代码。无论哪种结果证明是正确的，变化正在迅速发生，它们可能会使更多的人能够编写满足他们需求的软件。

到目前为止，我们已经对如何使用这些工具有一些见解。在一项调查中，92%的软件开发者表示他们定期使用这些工具[5]。最近的研究发现，使用这些工具的开发者比不使用工具的开发者更有效率[6]。在加州大学圣地亚哥分校进行的一项特别有趣的研究中，研究人员发现，专业开发者使用这些工具的方式有两种：加速和探索[7]。在加速阶段，开发者使用这些工具来帮助他们比如果自己编写代码更快地生成代码。在探索阶段，开发者使用这些工具来帮助他们找到可能有所帮助的库或理解现有的代码库。这些发现与我们在这本书中学到的东西相一致，我们期待未来的研究。

无论如何，我们希望你现在能够根据自己的判断来决定如何使用大型语言模型（LLMs）进行编程，以及 LLMs 可能对编程的未来意味着什么。在这样的时刻，有些人热情地宣称，“编程已经结束了！”而另一些人同样热情地宣称，“编程不会发生太大的变化！”[8]，对我们来说，能够自己权衡这些论点以及这种变化可能对我们以及其他人产生的影响是很重要的。这些工具能帮助我们吗？我们认为可以。因此，我们应该使用它们，但也要负责任地使用。有没有担忧？同样，我们认为有，正如我们在整本书中讨论的那样。我们应该采取一些措施，比如测试和调试，来减轻这些担忧。

在这本书中，我们采用的编程教学方法是新的。像我们这样的教师和教授刚刚开始将像 Copilot 这样的工具融入编程课程[9]，尽管我们仍在努力平衡我们希望学习者何时使用 Copilot 以及何时不使用 Copilot。无论程序员选择何种平衡来学习编程，我们都要强调，你已经学习了每个人都需要的基本技能，无论是你偶尔在工作时编写代码来自动化繁琐的任务，还是你计划成为一名专业的软件工程师。你有一个强大的基础，无论你的道路如何。

## 12.3 练习

1.  解释如何使用人格模式来加强公司中的编码标准。例如，公司可能要求其员工始终使用驼峰命名法（例如，xVal、ZValOut）。提供一个提示示例，让 GitHub Copilot 扮演一个经理的角色，执行特定的编码标准。

1.  你想创建一个 Python 函数，该函数根据用户的首选用户名和全名生成用户名。该函数应遵循以下规则：

    1.  如果首选用户名可用（即尚未被占用），请使用它。

    1.  如果首选用户名已被占用，通过在首选用户名后附加单个数字（例如，1、2、3、……）来生成新的用户名。

    1.  如果生成的用户名也被占用，使用用户的全名通过组合他们的姓氏和名字的部分来生成用户名。

    1.  如果生成的用户名也被占用，函数应继续请求新的首选用户名。

你会使用哪种交互模式（翻转交互模式或人格模式）来帮助 GitHub Copilot 设计这个功能？请证明你的选择，并概述你将如何开始交互。

## 摘要

+   提示模式是一个模板，帮助我们构建一个提示以实现既定目标。

+   翻转交互模式翻转了剧本：不是向 LLM 提出问题，而是 LLM 向我们提出问题。

+   当我们不知道如何有效地提示 LLM 时，翻转交互模式很有用。

+   人格模式用于让 AI 承担特定的角色，例如“入门级编程讲师”或特定的观点。

+   当我们希望 LLM 从给定视角回应时，人格模式很有用。

+   Copilot 目前在处理设计、定义不明确或规模较大的任务时存在困难。

+   有些人认为 LLM 将取代编程语言；另一些人认为编程语言将永远存在。

+   LLM 正在帮助人们执行数据科学任务，而这些人们从未见过底层编程语言代码。

+   可能编程语言本身不会被取代，但主导语言将被开发得比今天的语言更易读。
